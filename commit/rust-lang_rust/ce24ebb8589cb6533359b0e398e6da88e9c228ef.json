{"sha": "ce24ebb8589cb6533359b0e398e6da88e9c228ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMjRlYmI4NTg5Y2I2NTMzMzU5YjBlMzk4ZTZkYTg4ZTljMjI4ZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-11T18:54:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-11T18:54:49Z"}, "message": "auto merge of #5314 : jld/rust/adt-simplification, r=pcwalton\n\nStruct and enum representations have some complicatedness that's no longer needed.  Now that everything's in one place and has access to anything we'd want to know about the type, flatten some of that out.  Slight changes to representations in some cases.", "tree": {"sha": "a7de086a90ab6808afd080579b9235fd86e38b12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7de086a90ab6808afd080579b9235fd86e38b12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce24ebb8589cb6533359b0e398e6da88e9c228ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce24ebb8589cb6533359b0e398e6da88e9c228ef", "html_url": "https://github.com/rust-lang/rust/commit/ce24ebb8589cb6533359b0e398e6da88e9c228ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce24ebb8589cb6533359b0e398e6da88e9c228ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "html_url": "https://github.com/rust-lang/rust/commit/2ebb67487c1530822d83d6da6f71fa62cb68f2cd"}, {"sha": "9eaa608b041165df6ddfc064561f31315c5cb21b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eaa608b041165df6ddfc064561f31315c5cb21b", "html_url": "https://github.com/rust-lang/rust/commit/9eaa608b041165df6ddfc064561f31315c5cb21b"}], "stats": {"total": 117, "additions": 40, "deletions": 77}, "files": [{"sha": "66a32335020ac2eed2c5ff6623ee532733ea62a3", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 40, "deletions": 77, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/ce24ebb8589cb6533359b0e398e6da88e9c228ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce24ebb8589cb6533359b0e398e6da88e9c228ef/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=ce24ebb8589cb6533359b0e398e6da88e9c228ef", "patch": "@@ -71,18 +71,16 @@ use util::ppaux::ty_to_str;\n \n /// Representations.\n pub enum Repr {\n-    /**\n-     * `Unit` exists only so that an enum with a single C-like variant\n-     * can occupy no space, for ABI compatibility with rustc from\n-     * before (and during) the creation of this module.  It may not be\n-     * worth keeping around; `CEnum` and `Univariant` cover it\n-     * overwise.\n-     */\n-    Unit(int),\n     /// C-like enums; basically an int.\n     CEnum(int, int), // discriminant range\n-    /// Single-case variants, and structs/tuples/records.\n-    Univariant(Struct, Destructor),\n+    /**\n+     * Single-case variants, and structs/tuples/records.\n+     *\n+     * Structs with destructors need a dynamic destroyedness flag to\n+     * avoid running the destructor too many times; this is included\n+     * in the `Struct` if present.\n+     */\n+    Univariant(Struct, bool),\n     /**\n      * General-case enums: discriminant as int, followed by fields.\n      * The fields start immediately after the discriminant, meaning\n@@ -92,18 +90,6 @@ pub enum Repr {\n     General(~[Struct])\n }\n \n-/**\n- * Structs without destructors have historically had an extra layer of\n- * LLVM-struct to make accessing them work the same as structs with\n- * destructors.  This could probably be flattened to a boolean now\n- * that this module exists.\n- */\n-enum Destructor {\n-    StructWithDtor,\n-    StructWithoutDtor,\n-    NonStruct\n-}\n-\n /// For structs, and struct-like parts of anything fancier.\n struct Struct {\n     size: u64,\n@@ -129,14 +115,17 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n     }\n     let repr = @match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, *elems), NonStruct)\n+            Univariant(mk_struct(cx, *elems), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n-            let dt = ty::ty_dtor(cx.tcx, def_id).is_present();\n-            Univariant(mk_struct(cx, fields.map(|field| {\n+            let ftys = do fields.map |field| {\n                 ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n-            })), if dt { StructWithDtor } else { StructWithoutDtor })\n+            };\n+            let dtor = ty::ty_dtor(cx.tcx, def_id).is_present();\n+            let ftys =\n+                if dtor { ftys + [ty::mk_bool(cx.tcx)] } else { ftys };\n+            Univariant(mk_struct(cx, ftys), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             struct Case { discr: int, tys: ~[ty::t] };\n@@ -149,18 +138,15 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n             };\n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n-                Unit(0)\n-            } else if cases.len() == 1 && cases[0].tys.len() == 0 {\n-                // `()`-like; see comment on definition of `Unit`.\n-                Unit(cases[0].discr)\n-            } else if cases.len() == 1 {\n-                // Equivalent to a struct/tuple/newtype.\n-                fail_unless!(cases[0].discr == 0);\n-                Univariant(mk_struct(cx, cases[0].tys), NonStruct)\n+                Univariant(mk_struct(cx, ~[]), false)\n             } else if cases.all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n                 let discrs = cases.map(|c| c.discr);\n                 CEnum(discrs.min(), discrs.max())\n+            } else if cases.len() == 1 {\n+                // Equivalent to a struct/tuple/newtype.\n+                fail_unless!(cases[0].discr == 0);\n+                Univariant(mk_struct(cx, cases[0].tys), false)\n             } else {\n                 // The general case.  Since there's at least one\n                 // non-empty body, explicit discriminants should have\n@@ -204,18 +190,12 @@ pub fn sizing_fields_of(cx: @CrateContext, r: &Repr) -> ~[TypeRef] {\n fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n     -> ~[TypeRef] {\n     match *r {\n-        Unit(*) => ~[],\n         CEnum(*) => ~[T_enum_discrim(cx)],\n-        Univariant(ref st, dt) => {\n-            let f = if sizing {\n+        Univariant(ref st, _dtor) => {\n+            if sizing {\n                 st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n             } else {\n                 st.fields.map(|&ty| type_of::type_of(cx, ty))\n-            };\n-            match dt {\n-                NonStruct => f,\n-                StructWithoutDtor => ~[T_struct(f)],\n-                StructWithDtor => ~[T_struct(f), T_i8()]\n             }\n         }\n         General(ref sts) => {\n@@ -237,7 +217,7 @@ pub fn trans_switch(bcx: block, r: &Repr, scrutinee: ValueRef)\n         CEnum(*) | General(*) => {\n             (_match::switch, Some(trans_get_discr(bcx, r, scrutinee)))\n         }\n-        Unit(*) | Univariant(*) => {\n+        Univariant(*) => {\n             (_match::single, None)\n         }\n     }\n@@ -247,7 +227,6 @@ pub fn trans_switch(bcx: block, r: &Repr, scrutinee: ValueRef)\n pub fn trans_get_discr(bcx: block, r: &Repr, scrutinee: ValueRef)\n     -> ValueRef {\n     match *r {\n-        Unit(the_disc) => C_int(bcx.ccx(), the_disc),\n         CEnum(min, max) => load_discr(bcx, scrutinee, min, max),\n         Univariant(*) => C_int(bcx.ccx(), 0),\n         General(ref cases) => load_discr(bcx, scrutinee, 0,\n@@ -285,7 +264,7 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n         CEnum(*) => {\n             _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n         }\n-        Unit(*) | Univariant(*)=> {\n+        Univariant(*)=> {\n             bcx.ccx().sess.bug(~\"no cases for univariants or structs\")\n         }\n         General(*) => {\n@@ -301,16 +280,14 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n  */\n pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n     match *r {\n-        Unit(the_discr) => {\n-            fail_unless!(discr == the_discr);\n-        }\n         CEnum(min, max) => {\n             fail_unless!(min <= discr && discr <= max);\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n-        Univariant(_, StructWithDtor) => {\n+        Univariant(ref st, true) => {\n             fail_unless!(discr == 0);\n-            Store(bcx, C_u8(1), GEPi(bcx, val, [0, 1]))\n+            Store(bcx, C_bool(true),\n+                  GEPi(bcx, val, [0, st.fields.len() - 1]))\n         }\n         Univariant(*) => {\n             fail_unless!(discr == 0);\n@@ -327,8 +304,11 @@ pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n  */\n pub fn num_args(r: &Repr, discr: int) -> uint {\n     match *r {\n-        Unit(*) | CEnum(*) => 0,\n-        Univariant(ref st, _) => { fail_unless!(discr == 0); st.fields.len() }\n+        CEnum(*) => 0,\n+        Univariant(ref st, dtor) => {\n+            fail_unless!(discr == 0);\n+            st.fields.len() - (if dtor { 1 } else { 0 })\n+        }\n         General(ref cases) => cases[discr as uint].fields.len()\n     }\n }\n@@ -340,15 +320,11 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well.\n     match *r {\n-        Unit(*) | CEnum(*) => {\n+        CEnum(*) => {\n             bcx.ccx().sess.bug(~\"element access in C-like enum\")\n         }\n-        Univariant(ref st, dt) => {\n+        Univariant(ref st, _dtor) => {\n             fail_unless!(discr == 0);\n-            let val = match dt {\n-                NonStruct => val,\n-                StructWithDtor | StructWithoutDtor => GEPi(bcx, val, [0, 0])\n-            };\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(ref cases) => {\n@@ -376,7 +352,7 @@ fn struct_field_ptr(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n /// Access the struct drop flag, if present.\n pub fn trans_drop_flag_ptr(bcx: block, r: &Repr, val: ValueRef) -> ValueRef {\n     match *r {\n-        Univariant(_, StructWithDtor) => GEPi(bcx, val, [0, 1]),\n+        Univariant(ref st, true) => GEPi(bcx, val, [0, st.fields.len() - 1]),\n         _ => bcx.ccx().sess.bug(~\"tried to get drop flag of non-droppable \\\n                                   type\")\n     }\n@@ -407,23 +383,14 @@ pub fn trans_drop_flag_ptr(bcx: block, r: &Repr, val: ValueRef) -> ValueRef {\n pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n-        Unit(*) => {\n-            C_struct(~[])\n-        }\n         CEnum(min, max) => {\n             fail_unless!(vals.len() == 0);\n             fail_unless!(min <= discr && discr <= max);\n             C_int(ccx, discr)\n         }\n-        Univariant(ref st, dt) => {\n+        Univariant(ref st, _dro) => {\n             fail_unless!(discr == 0);\n-            let s = C_struct(build_const_struct(ccx, st, vals));\n-            match dt {\n-                NonStruct => s,\n-                // The actual destructor flag doesn't need to be present.\n-                // But add an extra struct layer for compatibility.\n-                StructWithDtor | StructWithoutDtor => C_struct(~[s])\n-            }\n+            C_struct(build_const_struct(ccx, st, vals))\n         }\n         General(ref cases) => {\n             let case = &cases[discr as uint];\n@@ -489,7 +456,6 @@ fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n     -> int {\n     match *r {\n-        Unit(discr) => discr,\n         CEnum(*) => const_to_int(val) as int,\n         Univariant(*) => 0,\n         General(*) => const_to_int(const_get_elt(ccx, val, [0])) as int,\n@@ -506,11 +472,9 @@ pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n pub fn const_get_field(ccx: @CrateContext, r: &Repr, val: ValueRef,\n                        _discr: int, ix: uint) -> ValueRef {\n     match *r {\n-        Unit(*) | CEnum(*) => ccx.sess.bug(~\"element access in C-like enum \\\n+        CEnum(*) => ccx.sess.bug(~\"element access in C-like enum \\\n                                              const\"),\n-        Univariant(_, NonStruct) => const_struct_field(ccx, val, ix),\n-        Univariant(*) => const_struct_field(ccx, const_get_elt(ccx, val,\n-                                                               [0]), ix),\n+        Univariant(*) => const_struct_field(ccx, val, ix),\n         General(*) => const_struct_field(ccx, const_get_elt(ccx, val,\n                                                             [1, 0]), ix)\n     }\n@@ -542,8 +506,7 @@ fn const_struct_field(ccx: @CrateContext, val: ValueRef, ix: uint)\n /// Is it safe to bitcast a value to the one field of its one variant?\n pub fn is_newtypeish(r: &Repr) -> bool {\n     match *r {\n-        Univariant(ref st, StructWithoutDtor)\n-        | Univariant(ref st, NonStruct) => st.fields.len() == 1,\n+        Univariant(ref st, false) => st.fields.len() == 1,\n         _ => false\n     }\n }"}]}