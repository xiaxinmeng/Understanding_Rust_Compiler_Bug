{"sha": "7fb3c29dc63fd0fcbb5c3698a6d0e4951452e671", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmYjNjMjlkYzYzZmQwZmNiYjVjMzY5OGE2ZDBlNDk1MTQ1MmU2NzE=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-07-02T18:15:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-02T18:15:10Z"}, "message": "Rollup merge of #86308 - bstrie:intrinsafe, r=JohnTitor\n\nDocs: clarify that certain intrinsics are not unsafe\n\nAs determined by the hardcoded list at https://github.com/rust-lang/rust/blob/003b8eadd7a476c51956fe447894532d6e21937e/compiler/rustc_typeck/src/check/intrinsic.rs#L59-L92", "tree": {"sha": "0cb3ee37bd49dce763c5a33e1dc91bcab801c5cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cb3ee37bd49dce763c5a33e1dc91bcab801c5cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fb3c29dc63fd0fcbb5c3698a6d0e4951452e671", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg31euCRBK7hj4Ov3rIwAAP6kIAGEnzHrgcFFQ4WDCq1y5RiFH\nWBZULhnm7ZTKwR38tsQpCMNinRStt4VzO0PHuklGtSsxTRWxrqZR8Q0WJY07+74e\nrN5ItTi9baEqDszAs6ovKMRk6KuehCCbSlF9g18jYtUrF1Uob1Z80Ueb1m37wMo/\nNXFOF3QaZQqYv+WTDVt3qm8juV+uiximq3kP8yU/ugDM1i62zooMoZAsfFsjMBeM\nCoN8TsKSdKRqyS2X1agZmnuIvy7pjWYnPmltyrTpp0mSvKN8Fdt6t114kwUV8ayV\nJcBSjn4d2C+nOUnYNS9Hr6aiOvkBBCoP+uvF8y3B/LK+WvqMQtTNTwsI9JvgnAw=\n=26ag\n-----END PGP SIGNATURE-----\n", "payload": "tree 0cb3ee37bd49dce763c5a33e1dc91bcab801c5cb\nparent fb736d96c33702f1aabac4092003c412c1d9d00a\nparent 16168dd1143c95c7ad1bebb1f8f0690c3265734d\nauthor Yuki Okushi <jtitor@2k36.org> 1625249710 +0900\ncommitter GitHub <noreply@github.com> 1625249710 +0900\n\nRollup merge of #86308 - bstrie:intrinsafe, r=JohnTitor\n\nDocs: clarify that certain intrinsics are not unsafe\n\nAs determined by the hardcoded list at https://github.com/rust-lang/rust/blob/003b8eadd7a476c51956fe447894532d6e21937e/compiler/rustc_typeck/src/check/intrinsic.rs#L59-L92\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fb3c29dc63fd0fcbb5c3698a6d0e4951452e671", "html_url": "https://github.com/rust-lang/rust/commit/7fb3c29dc63fd0fcbb5c3698a6d0e4951452e671", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fb3c29dc63fd0fcbb5c3698a6d0e4951452e671/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb736d96c33702f1aabac4092003c412c1d9d00a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb736d96c33702f1aabac4092003c412c1d9d00a", "html_url": "https://github.com/rust-lang/rust/commit/fb736d96c33702f1aabac4092003c412c1d9d00a"}, {"sha": "16168dd1143c95c7ad1bebb1f8f0690c3265734d", "url": "https://api.github.com/repos/rust-lang/rust/commits/16168dd1143c95c7ad1bebb1f8f0690c3265734d", "html_url": "https://github.com/rust-lang/rust/commit/16168dd1143c95c7ad1bebb1f8f0690c3265734d"}], "stats": {"total": 169, "additions": 169, "deletions": 0}, "files": [{"sha": "882d5d54b7c9fa238b091d2e1df3668f3f9ac409", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fb3c29dc63fd0fcbb5c3698a6d0e4951452e671/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb3c29dc63fd0fcbb5c3698a6d0e4951452e671/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=7fb3c29dc63fd0fcbb5c3698a6d0e4951452e671", "patch": "@@ -65,6 +65,10 @@ fn equate_intrinsic_type<'tcx>(\n /// Returns the unsafety of the given intrinsic.\n pub fn intrinsic_operation_unsafety(intrinsic: Symbol) -> hir::Unsafety {\n     match intrinsic {\n+        // When adding a new intrinsic to this list,\n+        // it's usually worth updating that intrinsic's documentation\n+        // to note that it's safe to call, since\n+        // safe extern fns are otherwise unprecedented.\n         sym::abort\n         | sym::size_of\n         | sym::min_align_of"}, {"sha": "b4311bbe5f41fa6ccd3a6495776c0ed2d012ef02", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7fb3c29dc63fd0fcbb5c3698a6d0e4951452e671/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fb3c29dc63fd0fcbb5c3698a6d0e4951452e671/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=7fb3c29dc63fd0fcbb5c3698a6d0e4951452e671", "patch": "@@ -712,6 +712,11 @@ extern \"rust-intrinsic\" {\n \n     /// Aborts the execution of the process.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// A more user-friendly and stable version of this operation is\n     /// [`std::process::abort`](../../std/process/fn.abort.html).\n     pub fn abort() -> !;\n@@ -745,6 +750,11 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Any use other than with `if` statements will probably not have an effect.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     pub fn likely(b: bool) -> bool;\n@@ -754,6 +764,11 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Any use other than with `if` statements will probably not have an effect.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     pub fn unlikely(b: bool) -> bool;\n@@ -765,6 +780,11 @@ extern \"rust-intrinsic\" {\n \n     /// The size of a type in bytes.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// More specifically, this is the offset in bytes between successive\n     /// items of the same type, including alignment padding.\n     ///\n@@ -774,6 +794,11 @@ extern \"rust-intrinsic\" {\n \n     /// The minimum alignment of a type.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is [`core::mem::align_of`].\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     pub fn min_align_of<T>() -> usize;\n@@ -796,6 +821,11 @@ extern \"rust-intrinsic\" {\n \n     /// Gets a static string slice containing the name of a type.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is [`core::any::type_name`].\n     #[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n@@ -804,6 +834,11 @@ extern \"rust-intrinsic\" {\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is [`core::any::TypeId::of`].\n     #[rustc_const_unstable(feature = \"const_type_id\", issue = \"77125\")]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n@@ -829,6 +864,11 @@ extern \"rust-intrinsic\" {\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// Consider using [`core::panic::Location::caller`] instead.\n     #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n@@ -837,6 +877,11 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This exists solely for [`mem::forget_unsized`]; normal `forget` uses\n     /// `ManuallyDrop` instead.\n+    ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_intrinsic_forget\", issue = \"none\")]\n     pub fn forget<T: ?Sized>(_: T);\n \n@@ -1090,6 +1135,11 @@ extern \"rust-intrinsic\" {\n     /// If the actual type neither requires drop glue nor implements\n     /// `Copy`, then the return value of this function is unspecified.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is [`mem::needs_drop`](crate::mem::needs_drop).\n     #[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.40.0\")]\n     pub fn needs_drop<T>() -> bool;\n@@ -1310,21 +1360,41 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the minimum of two `f32` values.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::min`]\n     pub fn minnumf32(x: f32, y: f32) -> f32;\n     /// Returns the minimum of two `f64` values.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::min`]\n     pub fn minnumf64(x: f64, y: f64) -> f64;\n     /// Returns the maximum of two `f32` values.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::max`]\n     pub fn maxnumf32(x: f32, y: f32) -> f32;\n     /// Returns the maximum of two `f64` values.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::max`]\n     pub fn maxnumf64(x: f64, y: f64) -> f64;\n@@ -1438,6 +1508,11 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the number of bits set in an integer type `T`\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `count_ones` method. For example,\n     /// [`u32::count_ones`]\n@@ -1446,6 +1521,11 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `leading_zeros` method. For example,\n     /// [`u32::leading_zeros`]\n@@ -1497,6 +1577,11 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `trailing_zeros` method. For example,\n     /// [`u32::trailing_zeros`]\n@@ -1548,6 +1633,11 @@ extern \"rust-intrinsic\" {\n \n     /// Reverses the bytes in an integer type `T`.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `swap_bytes` method. For example,\n     /// [`u32::swap_bytes`]\n@@ -1556,6 +1646,11 @@ extern \"rust-intrinsic\" {\n \n     /// Reverses the bits in an integer type `T`.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `reverse_bits` method. For example,\n     /// [`u32::reverse_bits`]\n@@ -1564,6 +1659,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs checked integer addition.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_add` method. For example,\n     /// [`u32::overflowing_add`]\n@@ -1572,6 +1672,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs checked integer subtraction\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_sub` method. For example,\n     /// [`u32::overflowing_sub`]\n@@ -1580,6 +1685,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs checked integer multiplication\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_mul` method. For example,\n     /// [`u32::overflowing_mul`]\n@@ -1649,6 +1759,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs rotate left.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_left` method. For example,\n     /// [`u32::rotate_left`]\n@@ -1657,6 +1772,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs rotate right.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_right` method. For example,\n     /// [`u32::rotate_right`]\n@@ -1665,20 +1785,35 @@ extern \"rust-intrinsic\" {\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_add` method. For example,\n     /// [`u32::wrapping_add`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_add<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_sub` method. For example,\n     /// [`u32::wrapping_sub`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_sub<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_mul` method. For example,\n     /// [`u32::wrapping_mul`]\n@@ -1687,13 +1822,23 @@ extern \"rust-intrinsic\" {\n \n     /// Computes `a + b`, saturating at numeric bounds.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_add` method. For example,\n     /// [`u32::saturating_add`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     pub fn saturating_add<T: Copy>(a: T, b: T) -> T;\n     /// Computes `a - b`, saturating at numeric bounds.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_sub` method. For example,\n     /// [`u32::saturating_sub`]\n@@ -1703,13 +1848,23 @@ extern \"rust-intrinsic\" {\n     /// Returns the value of the discriminant for the variant in 'v';\n     /// if `T` has no discriminant, returns `0`.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The stabilized version of this intrinsic is [`core::mem::discriminant`].\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n     pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n \n     /// Returns the number of variants of the type `T` cast to a `usize`;\n     /// if `T` has no variants, returns `0`. Uninhabited variants will be counted.\n     ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n+    ///\n     /// The to-be-stabilized version of this intrinsic is [`mem::variant_count`].\n     #[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n     pub fn variant_count<T>() -> usize;\n@@ -1732,10 +1887,20 @@ extern \"rust-intrinsic\" {\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n+    ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     pub fn ptr_guaranteed_eq<T>(ptr: *const T, other: *const T) -> bool;\n \n     /// See documentation of `<*const T>::guaranteed_ne` for details.\n+    ///\n+    /// Note that, unlike most intrinsics, this is safe to call;\n+    /// it does not require an `unsafe` block.\n+    /// Therefore, implementations must not require the user to uphold\n+    /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool;\n "}]}