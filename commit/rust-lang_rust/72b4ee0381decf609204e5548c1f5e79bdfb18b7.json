{"sha": "72b4ee0381decf609204e5548c1f5e79bdfb18b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYjRlZTAzODFkZWNmNjA5MjA0ZTU1NDhjMWY1ZTc5YmRmYjE4Yjc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-03-11T12:20:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-11T12:20:18Z"}, "message": "Merge pull request #659 from rust-lang/update\n\nUse the new rustc interface", "tree": {"sha": "751e2f1835c584b128b3d27b94451604b6fd35a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/751e2f1835c584b128b3d27b94451604b6fd35a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72b4ee0381decf609204e5548c1f5e79bdfb18b7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJchlKCCRBK7hj4Ov3rIwAAdHIIAE6cWSZ3tEUX4XiueKE8HdY4\nkStBAtdhOrIAy6RSd/qjy/Lf+f3zs8M31TWnmSJKi+LxqhW41sBLlqCqpV5ARmfS\nDmkqZ6G9ueR+IGKiwvM+iSpJHCkK3R9UNNXxezApk/ORtSwchg54ff4xZFQMr2kq\nqNpL1qJE3jcSIUHum8OlY2AQiH4Yx0JQ25ozO2m2wFFqP/TJOkCZPJIXnhpM64lj\nVZIfmjmL9rskohuQRn4YoD9iNJSjldzn8H3wYLU54hFfjMipLkixT5NURw0HRyfU\nbNW2ikc/d5qpHIx4dEt2nogypeMpUdqL+fuboXynsT83fot2aSt1h/mAAuZbb/w=\n=EM66\n-----END PGP SIGNATURE-----\n", "payload": "tree 751e2f1835c584b128b3d27b94451604b6fd35a2\nparent e66d6ec58bb18145bfbd2a42c8032657d8986d95\nparent 8568c20f4de4b52d3cc625c9f9c5052ee0e74d67\nauthor Ralf Jung <post@ralfj.de> 1552306818 +0100\ncommitter GitHub <noreply@github.com> 1552306818 +0100\n\nMerge pull request #659 from rust-lang/update\n\nUse the new rustc interface"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72b4ee0381decf609204e5548c1f5e79bdfb18b7", "html_url": "https://github.com/rust-lang/rust/commit/72b4ee0381decf609204e5548c1f5e79bdfb18b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72b4ee0381decf609204e5548c1f5e79bdfb18b7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e66d6ec58bb18145bfbd2a42c8032657d8986d95", "url": "https://api.github.com/repos/rust-lang/rust/commits/e66d6ec58bb18145bfbd2a42c8032657d8986d95", "html_url": "https://github.com/rust-lang/rust/commit/e66d6ec58bb18145bfbd2a42c8032657d8986d95"}, {"sha": "8568c20f4de4b52d3cc625c9f9c5052ee0e74d67", "url": "https://api.github.com/repos/rust-lang/rust/commits/8568c20f4de4b52d3cc625c9f9c5052ee0e74d67", "html_url": "https://github.com/rust-lang/rust/commit/8568c20f4de4b52d3cc625c9f9c5052ee0e74d67"}], "stats": {"total": 349, "additions": 104, "deletions": 245}, "files": [{"sha": "01fef16e4a9708a099f2b3e57a1849d8a170c22d", "filename": "benches/helpers/miri_helper.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/72b4ee0381decf609204e5548c1f5e79bdfb18b7/benches%2Fhelpers%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b4ee0381decf609204e5548c1f5e79bdfb18b7/benches%2Fhelpers%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmiri_helper.rs?ref=72b4ee0381decf609204e5548c1f5e79bdfb18b7", "patch": "@@ -2,18 +2,39 @@ extern crate getopts;\n extern crate miri;\n extern crate rustc;\n extern crate rustc_driver;\n+extern crate rustc_interface;\n extern crate test;\n \n-use rustc_driver::{driver, Compilation};\n+use self::miri::eval_main;\n use rustc::hir::def_id::LOCAL_CRATE;\n-use std::cell::RefCell;\n-use std::rc::Rc;\n+use rustc_interface::interface;\n+use crate::test::Bencher;\n+\n+struct MiriCompilerCalls<'a> {\n+    bencher: &'a mut Bencher,\n+}\n \n-use miri::{MiriConfig, eval_main};\n+impl rustc_driver::Callbacks for MiriCompilerCalls<'_> {\n+    fn after_analysis(&mut self, compiler: &interface::Compiler) -> bool {\n+        compiler.session().abort_if_errors();\n \n-use crate::test::Bencher;\n+        compiler.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n+            let (entry_def_id, _) = tcx.entry_fn(LOCAL_CRATE).expect(\n+                \"no main or start function found\",\n+            );\n \n-pub struct MiriCompilerCalls<'a>(Rc<RefCell<&'a mut Bencher>>);\n+            self.bencher.iter(|| {\n+                let config = miri::MiriConfig { validate: true, args: vec![] };\n+                eval_main(tcx, entry_def_id, config);\n+            });\n+        });\n+\n+        compiler.session().abort_if_errors();\n+\n+        // Don't continue execution\n+        false\n+    }\n+}\n \n fn find_sysroot() -> String {\n     // Taken from https://github.com/Manishearth/rust-clippy/pull/911.\n@@ -38,26 +59,5 @@ pub fn run(filename: &str, bencher: &mut Bencher) {\n         \"--sysroot\".to_string(),\n         find_sysroot(),\n     ];\n-    let bencher = RefCell::new(bencher);\n-\n-    let mut control = driver::CompileController::basic();\n-\n-    control.after_analysis.stop = Compilation::Stop;\n-    control.after_analysis.callback = Box::new(move |state| {\n-        state.session.abort_if_errors();\n-\n-        let tcx = state.tcx.unwrap();\n-        let (entry_def_id, _) = tcx.entry_fn(LOCAL_CRATE).expect(\n-            \"no main or start function found\",\n-        );\n-\n-        bencher.borrow_mut().iter(|| {\n-            let config = MiriConfig { validate: true, args: vec![] };\n-            eval_main(tcx, entry_def_id, config);\n-        });\n-\n-        state.session.abort_if_errors();\n-    });\n-\n-    rustc_driver::run_compiler(args, Box::new(control), None, None);\n+    rustc_driver::run_compiler(args, &mut MiriCompilerCalls { bencher }, None, None).unwrap()\n }"}, {"sha": "7abca8ef469414e688981481f516b10c613660d1", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72b4ee0381decf609204e5548c1f5e79bdfb18b7/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/72b4ee0381decf609204e5548c1f5e79bdfb18b7/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=72b4ee0381decf609204e5548c1f5e79bdfb18b7", "patch": "@@ -1 +1 @@\n-nightly-2019-03-02\n+nightly-2019-03-11"}, {"sha": "8984a0bc4f91519e38aeb17cf276a754281aefe4", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72b4ee0381decf609204e5548c1f5e79bdfb18b7/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b4ee0381decf609204e5548c1f5e79bdfb18b7/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=72b4ee0381decf609204e5548c1f5e79bdfb18b7", "patch": "@@ -25,13 +25,6 @@ Common options:\n Other [options] are the same as `cargo rustc`.  Everything after the first \"--\" is\n passed verbatim to Miri, which will pass everything after the second \"--\" verbatim\n to the interpreted program.\n-\n-The config flag `miri` is automatically defined for convenience. You can use\n-it to configure the resource limits\n-\n-    #![cfg_attr(miri, memory_size = 42)]\n-\n-available resource limits are `memory_size`, `step_limit`, `stack_limit`\n \"#;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}, {"sha": "43bf466c70ee3089ccd8f3ad2530d1f3f34a9e55", "filename": "src/bin/miri-rustc-tests.rs", "status": "modified", "additions": 43, "deletions": 89, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/72b4ee0381decf609204e5548c1f5e79bdfb18b7/src%2Fbin%2Fmiri-rustc-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b4ee0381decf609204e5548c1f5e79bdfb18b7/src%2Fbin%2Fmiri-rustc-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri-rustc-tests.rs?ref=72b4ee0381decf609204e5548c1f5e79bdfb18b7", "patch": "@@ -6,115 +6,72 @@ extern crate rustc_metadata;\n extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_codegen_utils;\n+extern crate rustc_interface;\n extern crate syntax;\n \n-use std::path::{PathBuf, Path};\n+use std::path::Path;\n use std::io::Write;\n use std::sync::{Mutex, Arc};\n use std::io;\n \n \n-use rustc::session::Session;\n-use rustc_metadata::cstore::CStore;\n-use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};\n-use rustc_driver::driver::{CompileState, CompileController};\n-use rustc::session::config::{self, Input, ErrorOutputType};\n+use rustc_interface::interface;\n use rustc::hir::{self, itemlikevisit};\n-use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc::ty::TyCtxt;\n-use syntax::ast;\n use rustc::hir::def_id::LOCAL_CRATE;\n \n use miri::MiriConfig;\n \n struct MiriCompilerCalls {\n-    default: Box<RustcDefaultCalls>,\n     /// whether we are building for the host\n     host_target: bool,\n }\n \n-impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n-    fn early_callback(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        descriptions: &rustc_errors::registry::Registry,\n-        output: ErrorOutputType\n-    ) -> Compilation {\n-        self.default.early_callback(matches, sopts, cfg, descriptions, output)\n-    }\n-    fn no_input(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-        descriptions: &rustc_errors::registry::Registry\n-    ) -> Option<(Input, Option<PathBuf>)> {\n-        self.default.no_input(matches, sopts, cfg, odir, ofile, descriptions)\n-    }\n-    fn late_callback(\n-        &mut self,\n-        trans: &CodegenBackend,\n-        matches: &getopts::Matches,\n-        sess: &Session,\n-        cstore: &CStore,\n-        input: &Input,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-    ) -> Compilation {\n-        self.default.late_callback(trans, matches, sess, cstore, input, odir, ofile)\n-    }\n-    fn build_controller(self: Box<Self>, sess: &Session, matches: &getopts::Matches) -> CompileController<'a> {\n-        let this = *self;\n-        let mut control = this.default.build_controller(sess, matches);\n-        control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n-        control.after_analysis.callback = Box::new(after_analysis);\n-        if !this.host_target {\n-            // only fully compile targets on the host\n-            control.after_analysis.stop = Compilation::Stop;\n-        }\n-        control\n-    }\n-}\n-\n-fn after_hir_lowering(state: &mut CompileState) {\n-    let attr = (String::from(\"miri\"), syntax::feature_gate::AttributeType::Whitelisted);\n-    state.session.plugin_attributes.borrow_mut().push(attr);\n-}\n+impl rustc_driver::Callbacks for MiriCompilerCalls {\n+    fn after_parsing(&mut self, compiler: &interface::Compiler) -> bool {\n+        let attr = (\n+            String::from(\"miri\"),\n+            syntax::feature_gate::AttributeType::Whitelisted,\n+        );\n+        compiler.session().plugin_attributes.borrow_mut().push(attr);\n \n-fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n-    state.session.abort_if_errors();\n-\n-    let tcx = state.tcx.unwrap();\n+        // Continue execution\n+        true\n+    }\n \n-    if std::env::args().any(|arg| arg == \"--test\") {\n-        struct Visitor<'a, 'tcx: 'a>(TyCtxt<'a, 'tcx, 'tcx>, &'a CompileState<'a, 'tcx>);\n-        impl<'a, 'tcx: 'a, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'a, 'tcx> {\n-            fn visit_item(&mut self, i: &'hir hir::Item) {\n-                if let hir::ItemKind::Fn(.., body_id) = i.node {\n-                    if i.attrs.iter().any(|attr| attr.name() == \"test\") {\n-                        let config = MiriConfig { validate: true, args: vec![] };\n-                        let did = self.0.hir().body_owner_def_id(body_id);\n-                        println!(\"running test: {}\", self.0.def_path_debug_str(did));\n-                        miri::eval_main(self.0, did, config);\n-                        self.1.session.abort_if_errors();\n+    fn after_analysis(&mut self, compiler: &interface::Compiler) -> bool {\n+        compiler.session().abort_if_errors();\n+        compiler.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n+            if std::env::args().any(|arg| arg == \"--test\") {\n+                struct Visitor<'a, 'tcx: 'a>(TyCtxt<'a, 'tcx, 'tcx>);\n+                impl<'a, 'tcx: 'a, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'a, 'tcx> {\n+                    fn visit_item(&mut self, i: &'hir hir::Item) {\n+                        if let hir::ItemKind::Fn(.., body_id) = i.node {\n+                            if i.attrs.iter().any(|attr| attr.name() == \"test\") {\n+                                let config = MiriConfig { validate: true, args: vec![] };\n+                                let did = self.0.hir().body_owner_def_id(body_id);\n+                                println!(\"running test: {}\", self.0.def_path_debug_str(did));\n+                                miri::eval_main(self.0, did, config);\n+                                self.0.sess.abort_if_errors();\n+                            }\n+                        }\n                     }\n+                    fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n+                    fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n                 }\n+                tcx.hir().krate().visit_all_item_likes(&mut Visitor(tcx));\n+            } else if let Some((entry_def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n+                let config = MiriConfig { validate: true, args: vec![] };\n+                miri::eval_main(tcx, entry_def_id, config);\n+\n+                compiler.session().abort_if_errors();\n+            } else {\n+                println!(\"no main function found, assuming auxiliary build\");\n             }\n-            fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n-            fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n-        }\n-        state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(tcx, state));\n-    } else if let Some((entry_def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n-        let config = MiriConfig { validate: true, args: vec![] };\n-        miri::eval_main(tcx, entry_def_id, config);\n+        });\n \n-        state.session.abort_if_errors();\n-    } else {\n-        println!(\"no main function found, assuming auxiliary build\");\n+        // Continue execution on host target\n+        self.host_target\n     }\n }\n \n@@ -185,10 +142,7 @@ fn main() {\n         let buf = BufWriter::default();\n         let output = buf.clone();\n         let result = std::panic::catch_unwind(|| {\n-            rustc_driver::run_compiler(&args, Box::new(MiriCompilerCalls {\n-                default: Box::new(RustcDefaultCalls),\n-                host_target,\n-            }), None, Some(Box::new(buf)));\n+            let _ = rustc_driver::run_compiler(&args, &mut MiriCompilerCalls { host_target }, None, Some(Box::new(buf)));\n         });\n \n         match result {"}, {"sha": "4cc0d955d3c217ce17bb9b185967b5cf32f083a5", "filename": "src/bin/miri.rs", "status": "modified", "additions": 32, "deletions": 100, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/72b4ee0381decf609204e5548c1f5e79bdfb18b7/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b4ee0381decf609204e5548c1f5e79bdfb18b7/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=72b4ee0381decf609204e5548c1f5e79bdfb18b7", "patch": "@@ -11,115 +11,50 @@ extern crate rustc_metadata;\n extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_codegen_utils;\n+extern crate rustc_interface;\n extern crate syntax;\n \n-use std::path::PathBuf;\n use std::str::FromStr;\n use std::env;\n \n-use miri::MiriConfig;\n-use rustc::session::Session;\n-use rustc_metadata::cstore::CStore;\n-use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};\n-use rustc_driver::driver::{CompileState, CompileController};\n-use rustc::session::config::{self, Input, ErrorOutputType};\n-use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_interface::interface;\n use rustc::hir::def_id::LOCAL_CRATE;\n-use syntax::ast;\n \n struct MiriCompilerCalls {\n-    default: Box<RustcDefaultCalls>,\n-    miri_config: MiriConfig,\n+    miri_config: miri::MiriConfig,\n }\n \n-impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n-    fn early_callback(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        descriptions: &rustc_errors::registry::Registry,\n-        output: ErrorOutputType,\n-    ) -> Compilation {\n-        self.default.early_callback(\n-            matches,\n-            sopts,\n-            cfg,\n-            descriptions,\n-            output,\n-        )\n-    }\n-    fn no_input(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-        descriptions: &rustc_errors::registry::Registry,\n-    ) -> Option<(Input, Option<PathBuf>)> {\n-        self.default.no_input(\n-            matches,\n-            sopts,\n-            cfg,\n-            odir,\n-            ofile,\n-            descriptions,\n-        )\n-    }\n-    fn late_callback(\n-        &mut self,\n-        codegen_backend: &CodegenBackend,\n-        matches: &getopts::Matches,\n-        sess: &Session,\n-        cstore: &CStore,\n-        input: &Input,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-    ) -> Compilation {\n-        // Called *before* `build_controller`. Add filename to `miri` arguments.\n-        self.miri_config.args.insert(0, input.filestem().to_string());\n-        self.default.late_callback(codegen_backend, matches, sess, cstore, input, odir, ofile)\n-    }\n-    fn build_controller(\n-        self: Box<Self>,\n-        sess: &Session,\n-        matches: &getopts::Matches,\n-    ) -> CompileController<'a> {\n-        let this = *self;\n-        let mut control = this.default.build_controller(sess, matches);\n-        control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n-        let miri_config = this.miri_config;\n-        control.after_analysis.callback =\n-            Box::new(move |state| after_analysis(state, miri_config.clone()));\n-        control.after_analysis.stop = Compilation::Stop;\n-        control\n-    }\n-}\n+impl rustc_driver::Callbacks for MiriCompilerCalls {\n+    fn after_parsing(&mut self, compiler: &interface::Compiler) -> bool {\n+        let attr = (\n+            String::from(\"miri\"),\n+            syntax::feature_gate::AttributeType::Whitelisted,\n+        );\n+        compiler.session().plugin_attributes.borrow_mut().push(attr);\n \n-fn after_hir_lowering(state: &mut CompileState) {\n-    let attr = (\n-        String::from(\"miri\"),\n-        syntax::feature_gate::AttributeType::Whitelisted,\n-    );\n-    state.session.plugin_attributes.borrow_mut().push(attr);\n-}\n+        // Continue execution\n+        true\n+    }\n \n-fn after_analysis<'a, 'tcx>(\n-    state: &mut CompileState<'a, 'tcx>,\n-    miri_config: MiriConfig,\n-) {\n-    init_late_loggers();\n-    state.session.abort_if_errors();\n+    fn after_analysis(&mut self, compiler: &interface::Compiler) -> bool {\n+        init_late_loggers();\n+        compiler.session().abort_if_errors();\n \n-    let tcx = state.tcx.unwrap();\n+        compiler.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n+            let (entry_def_id, _) = tcx.entry_fn(LOCAL_CRATE).expect(\"no main function found!\");\n+            let mut config = self.miri_config.clone();\n \n+            // Add filename to `miri` arguments.\n+            config.args.insert(0, compiler.input().filestem().to_string());\n \n-    let (entry_def_id, _) = tcx.entry_fn(LOCAL_CRATE).expect(\"no main function found!\");\n+            miri::eval_main(tcx, entry_def_id, config);\n+        });\n \n-    miri::eval_main(tcx, entry_def_id, miri_config);\n+        compiler.session().abort_if_errors();\n \n-    state.session.abort_if_errors();\n+        // Don't continue execution\n+        false\n+    }\n }\n \n fn init_early_loggers() {\n@@ -228,12 +163,9 @@ fn main() {\n \n     debug!(\"rustc arguments: {:?}\", rustc_args);\n     debug!(\"miri arguments: {:?}\", miri_args);\n-    let miri_config = MiriConfig { validate, args: miri_args };\n-    let result = rustc_driver::run(move || {\n-        rustc_driver::run_compiler(&rustc_args, Box::new(MiriCompilerCalls {\n-            default: Box::new(RustcDefaultCalls),\n-            miri_config,\n-        }), None, None)\n-    });\n-    std::process::exit(result as i32);\n+    let miri_config = miri::MiriConfig { validate, args: miri_args };\n+    let result = rustc_driver::report_ices_to_stderr_if_any(move || {\n+        rustc_driver::run_compiler(&rustc_args, &mut MiriCompilerCalls { miri_config }, None, None)\n+    }).and_then(|result| result);\n+    std::process::exit(result.is_err() as i32);\n }"}, {"sha": "5645217fe1ff04fed17b4fe7d0a1a64dfa116f78", "filename": "tests/compile-fail/stack_limit.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e66d6ec58bb18145bfbd2a42c8032657d8986d95/tests%2Fcompile-fail%2Fstack_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e66d6ec58bb18145bfbd2a42c8032657d8986d95/tests%2Fcompile-fail%2Fstack_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstack_limit.rs?ref=e66d6ec58bb18145bfbd2a42c8032657d8986d95", "patch": "@@ -1,20 +0,0 @@\n-#![feature(custom_attribute)]\n-#![miri(stack_limit=16)]\n-\n-//error-pattern: reached the configured maximum number of stack frames\n-\n-fn bar() {\n-    foo();\n-}\n-\n-fn foo() {\n-    cake();\n-}\n-\n-fn cake() {\n-    bar();\n-}\n-\n-fn main() {\n-    bar();\n-}"}]}