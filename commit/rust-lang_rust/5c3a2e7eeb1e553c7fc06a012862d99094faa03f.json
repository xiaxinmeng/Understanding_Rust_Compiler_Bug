{"sha": "5c3a2e7eeb1e553c7fc06a012862d99094faa03f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjM2EyZTdlZWIxZTU1M2M3ZmMwNmEwMTI4NjJkOTkwOTRmYWEwM2Y=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-09T21:52:01Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-10T00:31:01Z"}, "message": "Change TLS to almost be able to contain owned types", "tree": {"sha": "f6237ed53a3dc736b8facf5e5b270bf2e480096f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6237ed53a3dc736b8facf5e5b270bf2e480096f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c3a2e7eeb1e553c7fc06a012862d99094faa03f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c3a2e7eeb1e553c7fc06a012862d99094faa03f", "html_url": "https://github.com/rust-lang/rust/commit/5c3a2e7eeb1e553c7fc06a012862d99094faa03f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c3a2e7eeb1e553c7fc06a012862d99094faa03f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "692a22e69d916f8d0153ee9dfa906272561e364a", "url": "https://api.github.com/repos/rust-lang/rust/commits/692a22e69d916f8d0153ee9dfa906272561e364a", "html_url": "https://github.com/rust-lang/rust/commit/692a22e69d916f8d0153ee9dfa906272561e364a"}], "stats": {"total": 232, "additions": 145, "deletions": 87}, "files": [{"sha": "89f918204418c7058dff0aef6b0aa8b98d77694f", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c3a2e7eeb1e553c7fc06a012862d99094faa03f/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3a2e7eeb1e553c7fc06a012862d99094faa03f/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=5c3a2e7eeb1e553c7fc06a012862d99094faa03f", "patch": "@@ -26,7 +26,7 @@ pub struct Handler<T, U> {\n \n pub struct Condition<'self, T, U> {\n     name: &'static str,\n-    key: local_data::LocalDataKey<'self, Handler<T, U>>\n+    key: local_data::LocalDataKey<'self, @Handler<T, U>>\n }\n \n impl<'self, T, U> Condition<'self, T, U> {"}, {"sha": "77bbe4f5b979842592891ea9a6f2f96eb0fd1a2c", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c3a2e7eeb1e553c7fc06a012862d99094faa03f/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3a2e7eeb1e553c7fc06a012862d99094faa03f/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=5c3a2e7eeb1e553c7fc06a012862d99094faa03f", "patch": "@@ -46,41 +46,35 @@ use task::local_data_priv::{local_get, local_pop, local_set, Handle};\n  *\n  * These two cases aside, the interface is safe.\n  */\n-pub type LocalDataKey<'self,T> = &'self fn:Copy(v: @T);\n+pub type LocalDataKey<'self,T> = &'self fn:Copy(v: T);\n \n /**\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it.\n  */\n-pub unsafe fn local_data_pop<T: 'static>(\n-    key: LocalDataKey<T>) -> Option<@T> {\n-\n+pub unsafe fn local_data_pop<T: 'static>(key: LocalDataKey<T>) -> Option<T> {\n     local_pop(Handle::new(), key)\n }\n /**\n  * Retrieve a task-local data value. It will also be kept alive in the\n  * table until explicitly removed.\n  */\n-pub unsafe fn local_data_get<T: 'static>(\n-    key: LocalDataKey<T>) -> Option<@T> {\n-\n-    local_get(Handle::new(), key)\n+pub unsafe fn local_data_get<T: 'static>(key: LocalDataKey<@T>) -> Option<@T> {\n+    local_get(Handle::new(), key, |loc| loc.map(|&x| *x))\n }\n /**\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n-pub unsafe fn local_data_set<T: 'static>(\n-    key: LocalDataKey<T>, data: @T) {\n-\n+pub unsafe fn local_data_set<T: 'static>(key: LocalDataKey<@T>, data: @T) {\n     local_set(Handle::new(), key, data)\n }\n /**\n  * Modify a task-local data value. If the function returns 'None', the\n  * data is removed (and its reference dropped).\n  */\n pub unsafe fn local_data_modify<T: 'static>(\n-    key: LocalDataKey<T>,\n+    key: LocalDataKey<@T>,\n     modify_fn: &fn(Option<@T>) -> Option<@T>) {\n \n     let cur = local_data_pop(key);"}, {"sha": "07eebea4a6238dc63af16b220e76408d666686b4", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 117, "deletions": 55, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/5c3a2e7eeb1e553c7fc06a012862d99094faa03f/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3a2e7eeb1e553c7fc06a012862d99094faa03f/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=5c3a2e7eeb1e553c7fc06a012862d99094faa03f", "patch": "@@ -13,9 +13,13 @@\n use cast;\n use libc;\n use local_data::LocalDataKey;\n+use managed::raw::BoxRepr;\n use prelude::*;\n+use ptr;\n use sys;\n use task::rt;\n+use unstable::intrinsics;\n+use util;\n \n use super::rt::rust_task;\n use rt::task::{Task, LocalStorage};\n@@ -47,15 +51,24 @@ trait LocalData {}\n impl<T: 'static> LocalData for T {}\n \n // The task-local-map actuall stores all TLS information. Right now it's a list\n-// of key-value pairs. Each value is an actual Rust type so that when the map is\n-// destroyed all of the contents are destroyed. Each of the keys are actually\n-// addresses which don't need to be destroyed.\n+// of triples of (key, value, loans). The key is a code pointer (right now at\n+// least), the value is a trait so destruction can work, and the loans value\n+// is a count of the number of times the value is currently on loan via\n+// `local_data_get`.\n+//\n+// TLS is designed to be able to store owned data, so `local_data_get` must\n+// return a borrowed pointer to this data. In order to have a proper lifetime, a\n+// borrowed pointer is insted yielded to a closure specified to the `get`\n+// function. As a result, it would be unsound to perform `local_data_set` on the\n+// same key inside of a `local_data_get`, so we ensure at runtime that this does\n+// not happen.\n //\n // n.b. Has to be a pointer at outermost layer; the foreign call returns void *.\n //\n // n.b. If TLS is used heavily in future, this could be made more efficient with\n // a proper map.\n-type TaskLocalMap = ~[Option<(*libc::c_void, @LocalData)>];\n+type TaskLocalMap = ~[Option<(*libc::c_void, TLSValue, uint)>];\n+type TLSValue = @LocalData;\n \n fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n     unsafe {\n@@ -123,64 +136,98 @@ unsafe fn key_to_key_value<T: 'static>(key: LocalDataKey<T>) -> *libc::c_void {\n     return pair.code as *libc::c_void;\n }\n \n-// If returning Some(..), returns with @T with the map's reference. Careful!\n-unsafe fn local_data_lookup<T: 'static>(map: &TaskLocalMap,\n-                                        key: LocalDataKey<T>)\n-                                            -> Option<(uint, @T)>\n-{\n-    use managed::raw::BoxRepr;\n+unsafe fn transmute_back<'a, T>(data: &'a TLSValue) -> (*BoxRepr, &'a T) {\n+    // Currently, a TLSValue is an '@Trait' instance which means that its actual\n+    // representation is a pair of (vtable, box). Also, because of issue #7673\n+    // the box actually points to another box which has the data. Hence, to get\n+    // a pointer to the actual value that we're interested in, we decode the\n+    // trait pointer and pass through one layer of boxes to get to the actual\n+    // data we're interested in.\n+    //\n+    // The reference count of the containing @Trait box is already taken care of\n+    // because the TLSValue is owned by the containing TLS map which means that\n+    // the reference count is at least one. Extra protections are then added at\n+    // runtime to ensure that once a loan on a value in TLS has been given out,\n+    // the value isn't modified by another user.\n+    let (_vt, box) = *cast::transmute::<&TLSValue, &(uint, *BoxRepr)>(data);\n+\n+    return (box, cast::transmute(&(*box).data));\n+}\n \n+pub unsafe fn local_pop<T: 'static>(handle: Handle,\n+                                    key: LocalDataKey<T>) -> Option<T> {\n+    // If you've never seen horrendously unsafe code written in rust before,\n+    // just feel free to look a bit farther...\n+    let map = get_local_map(handle);\n     let key_value = key_to_key_value(key);\n-    for map.iter().enumerate().advance |(i, entry)| {\n+\n+    for map.mut_iter().advance |entry| {\n         match *entry {\n-            Some((k, ref data)) if k == key_value => {\n-                // We now have the correct 'data' as type @LocalData which we\n-                // need to somehow transmute this back to @T. This was\n-                // originally stored into the map as:\n-                //\n-                //    let data = @T;\n-                //    let element = @data as @LocalData;\n-                //    insert(key, element);\n-                //\n-                // This means that the element stored is a 2-word pair (because\n-                // it's a trait). The second element is the vtable (we don't\n-                // need it), and the first element is actually '@@T'. Not only\n-                // is this @@T, but it's a pointer to the base of the @@T (box\n-                // and all), so we have to traverse this to find the actual\n-                // pointer that we want.\n-                let (_vtable, box) =\n-                    *cast::transmute::<&@LocalData, &(uint, *BoxRepr)>(data);\n-                let ptr: &@T = cast::transmute(&(*box).data);\n-                return Some((i, *ptr));\n+            Some((k, _, loans)) if k == key_value => {\n+                if loans != 0 {\n+                    fail!(\"TLS value has been loaned via get already\");\n+                }\n+                // Move the data out of the `entry` slot via util::replace. This\n+                // is guaranteed to succeed because we already matched on `Some`\n+                // above.\n+                let data = match util::replace(entry, None) {\n+                    Some((_, data, _)) => data,\n+                    None => libc::abort(),\n+                };\n+\n+                // First, via some various cheats/hacks, we extract the value\n+                // contained within the TLS box. This leaves a big chunk of\n+                // memory which needs to be deallocated now.\n+                let (chunk, inside) = transmute_back(&data);\n+                let inside = cast::transmute_mut(inside);\n+                let ret = ptr::read_ptr(inside);\n+\n+                // Forget the trait box because we're about to manually\n+                // deallocate the other box. And for my next trick (kids don't\n+                // try this at home), transmute the chunk of @ memory from the\n+                // @-trait box to a pointer to a zero-sized '@' block which will\n+                // then cause it to get properly deallocated, but it won't touch\n+                // any of the uninitialized memory beyond the end.\n+                cast::forget(data);\n+                let chunk: *mut BoxRepr = cast::transmute(chunk);\n+                (*chunk).header.type_desc =\n+                    cast::transmute(intrinsics::get_tydesc::<()>());\n+                let _: @() = cast::transmute(chunk);\n+\n+                return Some(ret);\n             }\n             _ => {}\n         }\n     }\n     return None;\n }\n \n-pub unsafe fn local_pop<T: 'static>(handle: Handle,\n-                                    key: LocalDataKey<T>) -> Option<@T> {\n+pub unsafe fn local_get<T: 'static, U>(handle: Handle,\n+                                       key: LocalDataKey<T>,\n+                                       f: &fn(Option<&T>) -> U) -> U {\n+    // This does in theory take multiple mutable loans on the tls map, but the\n+    // references returned are never removed because the map is only increasing\n+    // in size (it never shrinks).\n     let map = get_local_map(handle);\n-    match local_data_lookup(map, key) {\n-        Some((index, data)) => {\n-            map[index] = None;\n-            Some(data)\n+    let key_value = key_to_key_value(key);\n+    for map.mut_iter().advance |entry| {\n+        match *entry {\n+            Some((k, ref data, ref mut loans)) if k == key_value => {\n+                *loans = *loans + 1;\n+                let (_, val) = transmute_back(data);\n+                let ret = f(Some(val));\n+                *loans = *loans - 1;\n+                return ret;\n+            }\n+            _ => {}\n         }\n-        None => None\n-    }\n-}\n-\n-pub unsafe fn local_get<T: 'static>(handle: Handle,\n-                                    key: LocalDataKey<T>) -> Option<@T> {\n-    match local_data_lookup(get_local_map(handle), key) {\n-        Some((_, data)) => Some(data),\n-        None => None\n     }\n+    return f(None);\n }\n \n+// FIXME(#7673): This shouldn't require '@', it should use '~'\n pub unsafe fn local_set<T: 'static>(handle: Handle,\n-                                    key: LocalDataKey<T>,\n+                                    key: LocalDataKey<@T>,\n                                     data: @T) {\n     let map = get_local_map(handle);\n     let keyval = key_to_key_value(key);\n@@ -191,16 +238,31 @@ pub unsafe fn local_set<T: 'static>(handle: Handle,\n     // everything to a trait (LocalData) which is then stored inside the map.\n     // Upon destruction of the map, all the objects will be destroyed and the\n     // traits have enough information about them to destroy themselves.\n-    let entry = Some((keyval, @data as @LocalData));\n-\n-    match local_data_lookup(map, key) {\n-        Some((index, _)) => { map[index] = entry; }\n-        None => {\n-            // Find an empty slot. If not, grow the vector.\n-            match map.iter().position(|x| x.is_none()) {\n-                Some(empty_index) => { map[empty_index] = entry; }\n-                None => { map.push(entry); }\n+    let data = @data as @LocalData;\n+\n+    // First, try to insert it if we already have it.\n+    for map.mut_iter().advance |entry| {\n+        match *entry {\n+            Some((key, ref mut value, loans)) if key == keyval => {\n+                if loans != 0 {\n+                    fail!(\"TLS value has been loaned via get already\");\n+                }\n+                util::replace(value, data);\n+                return;\n+            }\n+            _ => {}\n+        }\n+    }\n+    // Next, search for an open spot\n+    for map.mut_iter().advance |entry| {\n+        match *entry {\n+            Some(*) => {}\n+            None => {\n+                *entry = Some((keyval, data, 0));\n+                return;\n             }\n         }\n     }\n+    // Finally push it on the end of the list\n+    map.push(Some((keyval, data, 0)));\n }"}, {"sha": "7fe640dbf8c5bfe53c1c125616dc10b81dbfb6f3", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5c3a2e7eeb1e553c7fc06a012862d99094faa03f/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3a2e7eeb1e553c7fc06a012862d99094faa03f/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=5c3a2e7eeb1e553c7fc06a012862d99094faa03f", "patch": "@@ -477,26 +477,28 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n          * Step 1. Get spawner's taskgroup info.\n          *##################################################################*/\n         let spawner_group: @@mut TCB =\n-            match local_get(OldHandle(spawner), taskgroup_key!()) {\n-                None => {\n-                    // Main task, doing first spawn ever. Lazily initialise\n-                    // here.\n-                    let mut members = new_taskset();\n-                    taskset_insert(&mut members, spawner);\n-                    let tasks = exclusive(Some(TaskGroupData {\n-                        members: members,\n-                        descendants: new_taskset(),\n-                    }));\n-                    // Main task/group has no ancestors, no notifier, etc.\n-                    let group = @@mut TCB(spawner,\n-                                          tasks,\n-                                          AncestorList(None),\n-                                          true,\n-                                          None);\n-                    local_set(OldHandle(spawner), taskgroup_key!(), group);\n-                    group\n+            do local_get(OldHandle(spawner), taskgroup_key!()) |group| {\n+                match group {\n+                    None => {\n+                        // Main task, doing first spawn ever. Lazily initialise\n+                        // here.\n+                        let mut members = new_taskset();\n+                        taskset_insert(&mut members, spawner);\n+                        let tasks = exclusive(Some(TaskGroupData {\n+                            members: members,\n+                            descendants: new_taskset(),\n+                        }));\n+                        // Main task/group has no ancestors, no notifier, etc.\n+                        let group = @@mut TCB(spawner,\n+                                              tasks,\n+                                              AncestorList(None),\n+                                              true,\n+                                              None);\n+                        local_set(OldHandle(spawner), taskgroup_key!(), group);\n+                        group\n+                    }\n+                    Some(&group) => group\n                 }\n-                Some(group) => group\n             };\n         let spawner_group: &mut TCB = *spawner_group;\n "}]}