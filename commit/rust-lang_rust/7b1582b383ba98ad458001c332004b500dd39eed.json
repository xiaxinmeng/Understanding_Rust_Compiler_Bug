{"sha": "7b1582b383ba98ad458001c332004b500dd39eed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMTU4MmIzODNiYTk4YWQ0NTgwMDFjMzMyMDA0YjUwMGRkMzllZWQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-22T04:38:43Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-22T04:38:43Z"}, "message": "permit integer addition and subtraction on ptr-integers", "tree": {"sha": "e06ecb7bcb02d2422e7eb5d1f68e35e0d0c8763b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e06ecb7bcb02d2422e7eb5d1f68e35e0d0c8763b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b1582b383ba98ad458001c332004b500dd39eed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b1582b383ba98ad458001c332004b500dd39eed", "html_url": "https://github.com/rust-lang/rust/commit/7b1582b383ba98ad458001c332004b500dd39eed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b1582b383ba98ad458001c332004b500dd39eed/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8", "html_url": "https://github.com/rust-lang/rust/commit/b8c5e7fd0eead08be1c6ba7bbb20104b1c266cd8"}], "stats": {"total": 94, "additions": 87, "deletions": 7}, "files": [{"sha": "b6a823736875424a10de8175d797c8e24a21bd14", "filename": "src/memory.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b1582b383ba98ad458001c332004b500dd39eed/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b1582b383ba98ad458001c332004b500dd39eed/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=7b1582b383ba98ad458001c332004b500dd39eed", "patch": "@@ -64,10 +64,20 @@ impl Pointer {\n         Pointer::new(self.alloc_id, value::wrapping_signed_offset(self.offset, i, layout))\n     }\n \n+    pub fn overflowing_signed_offset<'tcx>(self, i: i128, layout: &TargetDataLayout) -> (Self, bool) {\n+        let (res, over) = value::overflowing_signed_offset(self.offset, i, layout);\n+        (Pointer::new(self.alloc_id, res), over)\n+    }\n+\n     pub fn signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n         Ok(Pointer::new(self.alloc_id, value::signed_offset(self.offset, i, layout)?))\n     }\n \n+    pub fn overflowing_offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> (Self, bool) {\n+        let (res, over) = value::overflowing_offset(self.offset, i, layout);\n+        (Pointer::new(self.alloc_id, res), over)\n+    }\n+\n     pub fn offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n         Ok(Pointer::new(self.alloc_id, value::offset(self.offset, i, layout)?))\n     }"}, {"sha": "adcd237e819ffb7dddb420d71ea7befeb2e448a2", "filename": "src/operator.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7b1582b383ba98ad458001c332004b500dd39eed/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b1582b383ba98ad458001c332004b500dd39eed/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=7b1582b383ba98ad458001c332004b500dd39eed", "patch": "@@ -130,6 +130,19 @@ macro_rules! f64_arithmetic {\n     )\n }\n \n+macro_rules! ptr_add {\n+    ($signed:expr, $ptr:expr, $int:expr, $layout:expr) => ({\n+        let ptr = $ptr;\n+        let int = $int;\n+        let (res, over) = if $signed {\n+            ptr.overflowing_signed_offset(int as i128, $layout)\n+        } else {\n+            ptr.overflowing_offset(int as u64, $layout)\n+        };\n+        (PrimVal::Ptr(res), over)\n+    })\n+}\n+\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     /// Returns the result of the specified operation and whether it overflowed.\n     pub fn binary_op(\n@@ -145,6 +158,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         let left_kind  = self.ty_to_primval_kind(left_ty)?;\n         let right_kind = self.ty_to_primval_kind(right_ty)?;\n+        //trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n \n         // I: Handle operations that support pointers\n         let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n@@ -187,6 +201,29 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         return Err(EvalError::InvalidPointerMath);\n                     }\n                 }\n+                // These work if one operand is a pointer, the other an integer\n+                Sub\n+                if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n+                && left.is_ptr() && right.is_bytes() => {\n+                    let left = left.to_ptr()?;\n+                    let right = right.to_bytes()? as i128; // this cast is fine as the kind is max. 64bit\n+                    let (res, over) = left.overflowing_signed_offset(-right, self.memory.layout);\n+                    return Ok((PrimVal::Ptr(res), over))\n+                }\n+                Add\n+                if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n+                && left.is_ptr() && right.is_bytes() => {\n+                    let left = left.to_ptr()?;\n+                    let right = right.to_bytes()?;\n+                    return Ok(ptr_add!(left_kind == isize, left, right, self.memory.layout));\n+                }\n+                Add\n+                if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n+                && left.is_bytes() && right.is_ptr() => {\n+                    let left = left.to_bytes()?;\n+                    let right = right.to_ptr()?;\n+                    return Ok(ptr_add!(left_kind == isize, right, left, self.memory.layout));\n+                }\n                 _ => {}\n             }\n         }"}, {"sha": "519c048f3ef8da7a0b105d9634a14265e0c17f6f", "filename": "src/value.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7b1582b383ba98ad458001c332004b500dd39eed/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b1582b383ba98ad458001c332004b500dd39eed/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=7b1582b383ba98ad458001c332004b500dd39eed", "patch": "@@ -260,29 +260,45 @@ impl<'tcx> PrimVal {\n     }\n }\n \n-pub fn signed_offset<'tcx>(val: u64, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n+// Overflow checking only works properly on the range from -u64 to +u64.\n+pub fn overflowing_signed_offset<'tcx>(val: u64, i: i128, layout: &TargetDataLayout) -> (u64, bool) {\n     // FIXME: is it possible to over/underflow here?\n     if i < 0 {\n         // trickery to ensure that i64::min_value() works fine\n         // this formula only works for true negative values, it panics for zero!\n         let n = u64::max_value() - (i as u64) + 1;\n-        val.checked_sub(n).ok_or(EvalError::OverflowingMath)\n+        val.overflowing_sub(n)\n+    } else {\n+        overflowing_offset(val, i as u64, layout)\n+    }\n+}\n+\n+pub fn overflowing_offset<'tcx>(val: u64, i: u64, layout: &TargetDataLayout) -> (u64, bool) {\n+    let (res, over) = val.overflowing_add(i);\n+    ((res as u128 % (1u128 << layout.pointer_size.bits())) as u64,\n+     over || res as u128 >= (1u128 << layout.pointer_size.bits()))\n+}\n+\n+pub fn signed_offset<'tcx>(val: u64, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n+    let (res, over) = overflowing_signed_offset(val, i as i128, layout);\n+    if over {\n+        Err(EvalError::OverflowingMath)\n     } else {\n-        offset(val, i as u64, layout)\n+        Ok(res)\n     }\n }\n \n pub fn offset<'tcx>(val: u64, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, u64> {\n-    let res = val.checked_add(i).ok_or(EvalError::OverflowingMath)?;\n-    if res as u128 >= (1u128 << layout.pointer_size.bits()) {\n+    let (res, over) = overflowing_offset(val, i, layout);\n+    if over {\n         Err(EvalError::OverflowingMath)\n     } else {\n         Ok(res)\n     }\n }\n \n pub fn wrapping_signed_offset<'tcx>(val: u64, i: i64, layout: &TargetDataLayout) -> u64 {\n-    (val.wrapping_add(i as u64) as u128 % (1u128 << layout.pointer_size.bits())) as u64\n+    overflowing_signed_offset(val, i as i128, layout).0\n }\n \n impl PrimValKind {"}, {"sha": "b7b17089efc7df49925193681d156cc4e34355eb", "filename": "tests/run-pass/ptr_int_casts.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7b1582b383ba98ad458001c332004b500dd39eed/tests%2Frun-pass%2Fptr_int_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b1582b383ba98ad458001c332004b500dd39eed/tests%2Frun-pass%2Fptr_int_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_int_casts.rs?ref=7b1582b383ba98ad458001c332004b500dd39eed", "patch": "@@ -1,15 +1,32 @@\n+use std::mem;\n+\n fn eq_ref<T>(x: &T, y: &T) -> bool {\n     x as *const _ == y as *const _\n }\n \n+fn f() -> i32 { 42 }\n+\n fn main() {\n     // int-ptr-int\n     assert_eq!(1 as *const i32 as usize, 1);\n+    assert_eq!((1 as *const i32).wrapping_offset(4) as usize, 1 + 4*4);\n \n     {   // ptr-int-ptr\n         let x = 13;\n-        let y = &x as *const _ as usize;\n+        let mut y = &x as *const _ as usize;\n+        y += 13;\n+        y -= 13;\n         let y = y as *const _;\n         assert!(eq_ref(&x, unsafe { &*y }));\n     }\n+\n+    {   // fnptr-int-fnptr\n+        let x : fn() -> i32 = f;\n+        let y : *mut u8 = unsafe { mem::transmute(x) };\n+        let mut y = y as usize;\n+        y += 13;\n+        y -= 13;\n+        let x : fn() -> i32 = unsafe { mem::transmute(y as *mut u8) };\n+        assert_eq!(x(), 42);\n+    }\n }"}]}