{"sha": "01dcb3bdf0fd779208c915d704ae634beb5c4448", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxZGNiM2JkZjBmZDc3OTIwOGM5MTVkNzA0YWU2MzRiZWI1YzQ0NDg=", "commit": {"author": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-07-13T03:33:17Z"}, "committer": {"name": "Jared Roesch", "email": "jroesch@MacBook.home", "date": "2015-07-26T02:57:58Z"}, "message": "Refactor the default type parameter algorithm\n\nThe algorithm was not correctly detecting conflicts after moving\ndefaults into TypeVariableValue. The updated algorithm\ncorrectly detects and reports conflicts with information about\nwhere the conflict occured and which items the defaults were\nintroduced by. The span's for said items are not being correctly\nattached and still need to be patched.", "tree": {"sha": "ec27faccd1f53aca313f7f6c68c1848336fae34a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec27faccd1f53aca313f7f6c68c1848336fae34a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01dcb3bdf0fd779208c915d704ae634beb5c4448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01dcb3bdf0fd779208c915d704ae634beb5c4448", "html_url": "https://github.com/rust-lang/rust/commit/01dcb3bdf0fd779208c915d704ae634beb5c4448", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01dcb3bdf0fd779208c915d704ae634beb5c4448/comments", "author": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d782e35c30a9642afe4ea28614efc08025694b1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d782e35c30a9642afe4ea28614efc08025694b1b", "html_url": "https://github.com/rust-lang/rust/commit/d782e35c30a9642afe4ea28614efc08025694b1b"}], "stats": {"total": 251, "additions": 198, "deletions": 53}, "files": [{"sha": "fbf19a10d93bf025deab497f004d342a9279c779", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=01dcb3bdf0fd779208c915d704ae634beb5c4448", "patch": "@@ -893,8 +893,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             self.report_inference_failure(vo.clone());\n         }\n         self.give_suggestion(same_regions);\n-        for &(ref trace, terr) in trace_origins {\n-            self.report_and_explain_type_error(trace.clone(), &terr);\n+        for &(ref trace, ref terr) in trace_origins {\n+            self.report_and_explain_type_error(trace.clone(), terr);\n         }\n     }\n "}, {"sha": "d38417143ce06d50a134709880d3f7ef6afe091d", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=01dcb3bdf0fd779208c915d704ae634beb5c4448", "patch": "@@ -40,6 +40,7 @@ use syntax::codemap;\n use syntax::codemap::{Span, DUMMY_SP};\n use util::nodemap::{FnvHashMap, NodeMap};\n \n+use ast_map;\n use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::error_reporting::ErrorReporting;\n@@ -72,7 +73,7 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n     // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n+    pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n     // Map from integral variable to the kind of integer it represents\n     int_unification_table: RefCell<UnificationTable<ty::IntVid>>,\n@@ -690,7 +691,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         variables.extend(unbound_ty_vars);\n         variables.extend(unbound_int_vars);\n         variables.extend(unbound_float_vars);\n-        \n+\n         return variables;\n     }\n \n@@ -1047,15 +1048,36 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn type_vars_for_defs(&self,\n+                              span: Span,\n+                              // substs: Substs,\n                               defs: &[ty::TypeParameterDef<'tcx>])\n                               -> Vec<ty::Ty<'tcx>> {\n+\n+        fn definition_span<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: ast::DefId) -> Span {\n+            let parent = tcx.map.get_parent(def_id.node);\n+            debug!(\"definition_span def_id={:?} parent={:?} node={:?} parent_node={:?}\",\n+                def_id, parent, tcx.map.find(def_id.node), tcx.map.find(parent));\n+            match tcx.map.find(parent) {\n+                None => DUMMY_SP,\n+                Some(ref node) => match *node {\n+                    ast_map::NodeItem(ref item) => item.span,\n+                    ast_map::NodeForeignItem(ref item) => item.span,\n+                    ast_map::NodeTraitItem(ref item) => item.span,\n+                    ast_map::NodeImplItem(ref item) => item.span,\n+                    _ => DUMMY_SP\n+                }\n+            }\n+        }\n+\n         let mut substs = Substs::empty();\n         let mut vars = Vec::with_capacity(defs.len());\n \n         for def in defs.iter() {\n             let default = def.default.map(|default| {\n                 type_variable::Default {\n-                    ty: default\n+                    ty: default,\n+                    origin_span: span,\n+                    definition_span: definition_span(self.tcx, def.def_id)\n                 }\n             });\n             //.subst(self.tcx, &substs)\n@@ -1077,7 +1099,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let mut type_params = subst::VecPerParamSpace::empty();\n \n         for space in subst::ParamSpace::all().iter() {\n-            type_params.replace(*space, self.type_vars_for_defs(generics.types.get_slice(*space)))\n+            type_params.replace(*space,\n+                                self.type_vars_for_defs(span, generics.types.get_slice(*space)))\n         }\n \n         let region_params =\n@@ -1102,7 +1125,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         assert!(generics.regions.len(subst::FnSpace) == 0);\n \n         let type_parameter_defs = generics.types.get_slice(subst::TypeSpace);\n-        let type_parameters = self.type_vars_for_defs(type_parameter_defs);\n+        let type_parameters = self.type_vars_for_defs(span, type_parameter_defs);\n \n         let region_param_defs = generics.regions.get_slice(subst::TypeSpace);\n         let regions = self.region_vars_for_defs(span, region_param_defs);\n@@ -1344,13 +1367,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn report_conflicting_default_types(&self,\n                                    span: Span,\n-                                   expected: Ty<'tcx>,\n-                                   actual: Ty<'tcx>) {\n+                                   expected: type_variable::Default<'tcx>,\n+                                   actual: type_variable::Default<'tcx>) {\n         let trace = TypeTrace {\n             origin: Misc(span),\n             values: Types(ty::expected_found {\n-                expected: expected,\n-                found: actual\n+                expected: expected.ty,\n+                found: actual.ty\n             })\n         };\n "}, {"sha": "8707306a149c7f1514d09883ab610515fde65094", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=01dcb3bdf0fd779208c915d704ae634beb5c4448", "patch": "@@ -11,8 +11,9 @@\n pub use self::RelationDir::*;\n use self::TypeVariableValue::*;\n use self::UndoEntry::*;\n-\n use middle::ty::{self, Ty};\n+use syntax::codemap::Span;\n+\n use std::cmp::min;\n use std::marker::PhantomData;\n use std::mem;\n@@ -38,9 +39,13 @@ enum TypeVariableValue<'tcx> {\n \n // We will use this to store the required information to recapitulate what happened when\n // an error occurs.\n-#[derive(Clone)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct Default<'tcx> {\n-    pub ty: Ty<'tcx>\n+    pub ty: Ty<'tcx>,\n+    /// The span where the default was incurred\n+    pub origin_span: Span,\n+    /// The definition that the default originates from\n+    pub definition_span: Span\n }\n \n pub struct Snapshot {"}, {"sha": "19add679bbfdc90dda1756fd2f70c81570414d6d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=01dcb3bdf0fd779208c915d704ae634beb5c4448", "patch": "@@ -54,6 +54,7 @@ use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangIte\n use middle::region;\n use middle::resolve_lifetime;\n use middle::infer;\n+use middle::infer::type_variable;\n use middle::pat_util;\n use middle::region::RegionMaps;\n use middle::stability;\n@@ -2068,7 +2069,7 @@ pub enum TypeError<'tcx> {\n     ConvergenceMismatch(ExpectedFound<bool>),\n     ProjectionNameMismatched(ExpectedFound<ast::Name>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n-    terr_ty_param_default_mismatch(expected_found<Ty<'tcx>>)\n+    TyParamDefaultMismatch(ExpectedFound<Ty<'tcx>>)\n }\n \n /// Bounds suitable for an existentially quantified type parameter\n@@ -5083,9 +5084,9 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        values.found)\n             },\n             terr_ty_param_default_mismatch(ref values) => {\n-                write!(f, \"conflicting type parameter defaults {} {}\",\n-                       values.expected,\n-                       values.found)\n+                write!(f, \"conflicting type parameter defaults {} and {}\",\n+                       values.expected.ty,\n+                       values.found.ty)\n             }\n         }\n     }\n@@ -5405,7 +5406,7 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn note_and_explain_type_err(&self, err: &TypeError<'tcx>, sp: Span) {\n         use self::TypeError::*;\n \n-        match *err {\n+        match err.clone() {\n             RegionsDoesNotOutlive(subregion, superregion) => {\n                 self.note_and_explain_region(\"\", subregion, \"...\");\n                 self.note_and_explain_region(\"...does not necessarily outlive \",\n@@ -5444,10 +5445,21 @@ impl<'tcx> ctxt<'tcx> {\n                                   using it as a trait object\"));\n                 }\n             },\n-            terr_ty_param_default_mismatch(expected) => {\n+            terr_ty_param_default_mismatch(values) => {\n+                let expected = values.expected;\n+                let found = values.found;\n                 self.sess.span_note(sp,\n-                    &format!(\"found conflicting defaults {:?} {:?}\",\n-                             expected.expected, expected.found))\n+                    &format!(\"conflicting type parameter defaults {} and {}\",\n+                             expected.ty,\n+                             found.ty));\n+                self.sess.span_note(expected.definition_span,\n+                    &format!(\"...a default was defined\"));\n+                self.sess.span_note(expected.origin_span,\n+                    &format!(\"...that was applied to an unconstrained type variable here\"));\n+                self.sess.span_note(found.definition_span,\n+                    &format!(\"...a second default was defined\"));\n+                self.sess.span_note(found.origin_span,\n+                    &format!(\"...that also applies to the same type variable here\"));\n             }\n             _ => {}\n         }"}, {"sha": "3925f4e751c20097cdbe96f5de4d440529ea7728", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=01dcb3bdf0fd779208c915d704ae634beb5c4448", "patch": "@@ -111,7 +111,7 @@ pub trait AstConv<'tcx> {\n     }\n \n     /// What type should we use when a type is omitted?\n-    fn ty_infer(&self, default: Option<Ty<'tcx>>, span: Span) -> Ty<'tcx>;\n+    fn ty_infer(&self, default: Option<ty::TypeParameterDef<'tcx>>, span: Span) -> Ty<'tcx>;\n \n     /// Projecting an associated type from a (potentially)\n     /// higher-ranked trait reference is more complicated, because of\n@@ -403,7 +403,7 @@ fn create_substs_for_ast_path<'tcx>(\n     // they were optional (e.g. paths inside expressions).\n     let mut type_substs = if param_mode == PathParamMode::Optional &&\n                              types_provided.is_empty() {\n-        ty_param_defs.iter().map(|p| this.ty_infer(p.default, span)).collect()\n+        ty_param_defs.iter().map(|p| this.ty_infer(Some(p.clone()), span)).collect()\n     } else {\n         types_provided\n     };"}, {"sha": "488428833ac13c4a8a6b7d21f89d180fb38da248", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=01dcb3bdf0fd779208c915d704ae634beb5c4448", "patch": "@@ -315,11 +315,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         let method_types = {\n             if num_supplied_types == 0 {\n-                self.fcx.infcx().type_vars_for_defs(method_types)\n+                self.fcx.infcx().type_vars_for_defs(self.span, method_types)\n             } else if num_method_types == 0 {\n                 span_err!(self.tcx().sess, self.span, E0035,\n                     \"does not take type parameters\");\n-                self.fcx.infcx().type_vars_for_defs(method_types)\n+                self.fcx.infcx().type_vars_for_defs(self.span, method_types)\n             } else if num_supplied_types != num_method_types {\n                 span_err!(self.tcx().sess, self.span, E0036,\n                     \"incorrect number of type parameters given for this method\");"}, {"sha": "767797e843caffb104336ad2eee15da575cf1a45", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=01dcb3bdf0fd779208c915d704ae634beb5c4448", "patch": "@@ -176,7 +176,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         None => {\n-            fcx.inh.infcx.type_vars_for_defs(type_parameter_defs)\n+            fcx.inh.infcx.type_vars_for_defs(span, type_parameter_defs)\n         }\n     };\n "}, {"sha": "b190e7a7a48305381d0ec07ca67c946fea59d9b5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=01dcb3bdf0fd779208c915d704ae634beb5c4448", "patch": "@@ -1207,7 +1207,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             !method.generics.regions.is_empty_in(subst::FnSpace)\n         {\n             let method_types =\n-                self.infcx().type_vars_for_defs(\n+                self.infcx().type_vars_for_defs(self.span,\n                     method.generics.types.get_slice(subst::FnSpace));\n \n             // In general, during probe we erase regions. See"}, {"sha": "3a93c7ed9161d2e632dc1884f2314af1884d3255", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 128, "deletions": 23, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=01dcb3bdf0fd779208c915d704ae634beb5c4448", "patch": "@@ -1139,8 +1139,9 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         trait_def.associated_type_names.contains(&assoc_name)\n     }\n \n-    fn ty_infer(&self, default: Option<Ty<'tcx>>, _span: Span) -> Ty<'tcx> {\n-        let default = default.map(|t| type_variable::Default { ty: t });\n+    fn ty_infer(&self, ty_param_def: Option<ty::TypeParameterDef<'tcx>>, span: Span) -> Ty<'tcx> {\n+        let default = ty_param_def.and_then(|t|\n+            t.default.map(|ty| type_variable::Default { ty: ty, origin_span: span, definition_span: span }));\n         self.infcx().next_ty_var_with_default(default)\n     }\n \n@@ -1694,39 +1695,61 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn select_all_obligations_and_apply_defaults(&self) {\n         use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n \n-        // debug!(\"select_all_obligations_and_apply_defaults: defaults={:?}\", self.infcx().defaults);\n+        // For the time being this errs on the side of being memory wasteful but provides better\n+        // error reporting.\n+        // let type_variables = self.infcx().type_variables.clone();\n \n+        // There is a possibility that this algorithm will have to run an arbitrary number of times\n+        // to terminate so we bound it by the compiler's recursion limit.\n         for _ in (0..self.tcx().sess.recursion_limit.get()) {\n+            // First we try to solve all obligations, it is possible that the last iteration\n+            // has made it possible to make more progress.\n             self.select_obligations_where_possible();\n \n+            let mut conflicts = Vec::new();\n+\n+            // Collect all unsolved type, integral and floating point variables.\n             let unsolved_variables = self.inh.infcx.unsolved_variables();\n+\n+            // We must collect the defaults *before* we do any unification. Because we have\n+            // directly attached defaults to the type variables any unification that occurs\n+            // will erase defaults causing conflicting defaults to be completely ignored.\n+            let default_map: FnvHashMap<_, _> =\n+                unsolved_variables\n+                    .iter()\n+                    .filter_map(|t| self.infcx().default(t).map(|d| (t, d)))\n+                    .collect();\n+\n             let mut unbound_tyvars = HashSet::new();\n \n-            // Gather all unconstrainted integer and float variables\n+            debug!(\"select_all_obligations_and_apply_defaults: defaults={:?}\", default_map);\n+\n+            // We loop over the unsolved variables, resolving them and if they are\n+            // and unconstrainted numberic type we add them to the set of unbound\n+            // variables. We do this so we only apply literal fallback to type\n+            // variables without defaults.\n             for ty in &unsolved_variables {\n                 let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n                 if self.infcx().type_var_diverges(resolved) {\n                     demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n                 } else {\n                     match self.infcx().type_is_unconstrained_numeric(resolved) {\n-                        UnconstrainedInt => {\n+                        UnconstrainedInt | UnconstrainedFloat => {\n                             unbound_tyvars.insert(resolved);\n                         },\n-                        UnconstrainedFloat => {\n-                            unbound_tyvars.insert(resolved);\n-                        }\n                         Neither => {}\n                     }\n                 }\n             }\n \n-            // Collect the set of variables that need fallback applied\n+            // We now remove any numeric types that also have defaults, and instead insert\n+            // the type variable with a defined fallback.\n             for ty in &unsolved_variables {\n-                if let Some(_) = self.inh.infcx.default(ty) {\n+                if let Some(_default) = default_map.get(ty) {\n                     let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n \n-                    // debug!(\"select_all_obligations_and_apply_defaults: ty: {:?} with default: {:?}\",\n-                    //         ty, self.inh.infcx.defaults.borrow().get(ty));\n+                    debug!(\"select_all_obligations_and_apply_defaults: ty: {:?} with default: {:?}\",\n+                             ty, _default);\n \n                     match resolved.sty {\n                         ty::TyInfer(ty::TyVar(_)) => {\n@@ -1745,11 +1768,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n \n+            // If there are no more fallbacks to apply at this point we have applied all possible\n+            // defaults and type inference will procede as normal.\n             if unbound_tyvars.is_empty() {\n                 break;\n             }\n \n-            // Go through the unbound variables and unify them with the proper fallbacks\n+            // Finally we go through each of the unbound type variables and unify them with\n+            // the proper fallback, reporting a conflicting default error if any of the\n+            // unifications fail. We know it must be a conflicting default because the\n+            // variable would only be in `unbound_tyvars` and have a concrete value if\n+            // it had been solved by previously applying a default.\n+\n+            // We take a snapshot for use in error reporting.\n+            let snapshot = self.infcx().type_variables.borrow_mut().snapshot();\n+\n             for ty in &unbound_tyvars {\n                 if self.infcx().type_var_diverges(ty) {\n                     demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n@@ -1762,16 +1795,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n                         }\n                         Neither => {\n-                            if let Some(default) = self.inh.infcx.default(ty) {\n+                            if let Some(default) = default_map.get(ty) {\n+                                let default = default.clone();\n                                 match infer::mk_eqty(self.infcx(), false,\n-                                                     infer::Misc(codemap::DUMMY_SP),\n+                                                     infer::Misc(default.origin_span),\n                                                      ty, default.ty) {\n-                                    Ok(()) => { /* ok */ }\n+                                    Ok(()) => {}\n                                     Err(_) => {\n-                                        self.infcx().report_conflicting_default_types(\n-                                            codemap::DUMMY_SP,\n-                                            ty,\n-                                            default.ty)\n+                                        conflicts.push((*ty, default));\n                                     }\n                                 }\n                             }\n@@ -1780,8 +1811,82 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            self.select_obligations_where_possible();\n+            // There were some errors to report\n+            if conflicts.len() > 0 {\n+                self.infcx().type_variables.borrow_mut().rollback_to(snapshot);\n+\n+                for (conflict, default) in conflicts {\n+                    let conflicting_default =\n+                        self.find_conflicting_default(\n+                            &unbound_tyvars,\n+                            &default_map,\n+                            conflict).unwrap_or(type_variable::Default {\n+                                ty: self.infcx().next_ty_var(),\n+                                origin_span: codemap::DUMMY_SP,\n+                                definition_span: codemap::DUMMY_SP\n+                            });\n+\n+                            self.infcx().report_conflicting_default_types(\n+                                conflicting_default.origin_span,\n+                                conflicting_default,\n+                                default)\n+                }\n+            } else {\n+                self.infcx().type_variables.borrow_mut().commit(snapshot)\n+            }\n         }\n+\n+        self.select_obligations_where_possible();\n+    }\n+\n+    // For use in error handling related to default type parameter fallback. We explicitly\n+    // apply the default that caused conflict first to a local version of the type variable\n+    // table then apply defaults until we find a conflict. That default must be the one\n+    // that caused conflict earlier.\n+    fn find_conflicting_default(&self,\n+                                unbound_vars: &HashSet<Ty<'tcx>>,\n+                                default_map: &FnvHashMap<&Ty<'tcx>, type_variable::Default<'tcx>>,\n+                                conflict: Ty<'tcx>)\n+                                -> Option<type_variable::Default<'tcx>> {\n+        use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n+\n+        // Ensure that the conflicting default is applied first\n+        let mut unbound_tyvars = Vec::with_capacity(unbound_vars.len() + 1);\n+        unbound_tyvars.push(conflict);\n+        unbound_tyvars.extend(unbound_vars.iter());\n+\n+        let mut result = None;\n+        // We run the same code as above applying defaults in order, this time when\n+        // we find the conflict we just return it for error reporting above.\n+        for ty in &unbound_tyvars {\n+            if self.infcx().type_var_diverges(ty) {\n+                demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n+            } else {\n+                match self.infcx().type_is_unconstrained_numeric(ty) {\n+                    UnconstrainedInt => {\n+                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n+                    },\n+                    UnconstrainedFloat => {\n+                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n+                    },\n+                    Neither => {\n+                        if let Some(default) = default_map.get(ty) {\n+                            let default = default.clone();\n+                            match infer::mk_eqty(self.infcx(), false,\n+                                                 infer::Misc(default.origin_span),\n+                                                 ty, default.ty) {\n+                                Ok(()) => {}\n+                                Err(_) => {\n+                                    result = Some(default);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return result;\n     }\n \n     fn select_all_obligations_or_error(&self) {\n@@ -2495,7 +2600,7 @@ pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     debug!(\"impl_self_ty: tps={:?} rps={:?} raw_ty={:?}\", tps, rps, raw_ty);\n \n     let rps = fcx.inh.infcx.region_vars_for_defs(span, rps);\n-    let tps = fcx.inh.infcx.type_vars_for_defs(tps);\n+    let tps = fcx.inh.infcx.type_vars_for_defs(span, tps);\n     let substs = subst::Substs::new_type(tps, rps);\n     let substd_ty = fcx.instantiate_type_scheme(span, &substs, &raw_ty);\n \n@@ -4715,7 +4820,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // Nothing specified at all: supply inference variables for\n         // everything.\n         if provided_len == 0 && !(require_type_space && space == subst::TypeSpace) {\n-            substs.types.replace(space, fcx.infcx().type_vars_for_defs(&desired[..]));\n+            substs.types.replace(space, fcx.infcx().type_vars_for_defs(span, &desired[..]));\n             return;\n         }\n "}, {"sha": "8b38c58ce7a1bdf97b0edfc8ed7b5e00fdb00bdb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01dcb3bdf0fd779208c915d704ae634beb5c4448/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=01dcb3bdf0fd779208c915d704ae634beb5c4448", "patch": "@@ -404,7 +404,7 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn ty_infer(&self, _default: Option<Ty<'tcx>>, span: Span) -> Ty<'tcx> {\n+    fn ty_infer(&self, _default: Option<ty::TypeParameterDef<'tcx>>, span: Span) -> Ty<'tcx> {\n         span_err!(self.tcx().sess, span, E0121,\n                   \"the type placeholder `_` is not allowed within types on item signatures\");\n         self.tcx().types.err"}, {"sha": "8e4f8ea581502a2edc8177a040300e05ff7f91e3", "filename": "src/rust-installer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frust-installer?ref=01dcb3bdf0fd779208c915d704ae634beb5c4448", "patch": "@@ -1 +1 @@\n-Subproject commit c37d3747da75c280237dc2d6b925078e69555499\n+Subproject commit 8e4f8ea581502a2edc8177a040300e05ff7f91e3"}]}