{"sha": "1ba46dc378bbc3101a657a095d66a9c62a80a423", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiYTQ2ZGMzNzhiYmMzMTAxYTY1N2EwOTVkNjZhOWM2MmE4MGE0MjM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-14T10:36:28Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-14T10:36:28Z"}, "message": "Move mir validation out of tree", "tree": {"sha": "5817c5418a9bc58b95716f15d9b3ef5f39fd7dc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5817c5418a9bc58b95716f15d9b3ef5f39fd7dc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ba46dc378bbc3101a657a095d66a9c62a80a423", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAloyVCwACgkQpp+NIls6\n19mW1BAAgvsmtET2ePD/mFFiKfg2SItXclwz7TGA2njS91a44pSF2nZZRkXshOMZ\nD2g6SM92CxdKtruVedgI1ZMM7epJu37heTaq6Sc/C4r6ipvubaikF2O0l555Z9Nj\nFfm14PublBrwU0/Oatio4nXFRY7KeEAFjOKVJI/fZnLbrkbUqAQLgKoDrhLOHZON\n2TSl7t9umeJnWvCx21rOR9UmhNCy3+CSCDObJO4BKiegnD8NzhpPsKIk7JGOFt8F\nUCUtlJ5yiPeLCc0JHTHUkVrwIdCoGtOGuWBYLHhBpv/HvpUXgV5QOivWayy0Mp4p\nADzOZVz+MbLveSFUr5NOoD4KyR4ij5/rePolHV4Hp6L9iZXQLTU7Dj1IGDkgmE16\nfh0XlvOljethXgeGubCH9Ohxa+Up2bMMRHWjr+8obXDz6r3Ui1UB1HBbVXdFxsx1\n8tztgVrVY79IK4QKvHYgEOMqArwF9vJ3DzQu6rX4+K4DoG2XFPCPXtV06VU0exNJ\n+iSeOksZQYq1GQ0q0ieU7CvDlh/+U778edLDbAhnMDITo8zdgwhjSMB/4FzwQSSn\nZfhUcYqr7lYjTr9WyKpskkaFmcD+7FEbczudjOlBlFWoUCojQVq9vG4AO9yOPH1G\ngOhkPvPFdfwSf9U7Vi0n4iaNXRTCPylJQ78UtwoZpD1rTUOOxyY=\n=UZUA\n-----END PGP SIGNATURE-----", "payload": "tree 5817c5418a9bc58b95716f15d9b3ef5f39fd7dc4\nparent acac58502b3d86c5808d8d152d7870f8c6423074\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1513247788 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1513247788 +0100\n\nMove mir validation out of tree\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ba46dc378bbc3101a657a095d66a9c62a80a423", "html_url": "https://github.com/rust-lang/rust/commit/1ba46dc378bbc3101a657a095d66a9c62a80a423", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ba46dc378bbc3101a657a095d66a9c62a80a423/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acac58502b3d86c5808d8d152d7870f8c6423074", "url": "https://api.github.com/repos/rust-lang/rust/commits/acac58502b3d86c5808d8d152d7870f8c6423074", "html_url": "https://github.com/rust-lang/rust/commit/acac58502b3d86c5808d8d152d7870f8c6423074"}], "stats": {"total": 1559, "additions": 61, "deletions": 1498}, "files": [{"sha": "27e7438ddfd2602bf9a1de72a564bcc85ac536cf", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=1ba46dc378bbc3101a657a095d66a9c62a80a423", "patch": "@@ -961,11 +961,6 @@ name = \"lazy_static\"\n version = \"0.2.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"lazy_static\"\n-version = \"1.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"lazycell\"\n version = \"0.5.1\"\n@@ -1625,7 +1620,6 @@ dependencies = [\n  \"jobserver 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n@@ -1868,10 +1862,8 @@ dependencies = [\n  \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n- \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n@@ -2771,7 +2763,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum kuchiki 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e03098e8e719c92b7794515dfd5c1724e2b12f5ce1788e61cfa4663f82eba8d8\"\n \"checksum languageserver-types 0.16.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"773e175c945800aeea4c21c04090bcb9db987b1a566ad9c6f569972299950e3e\"\n \"checksum lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76f033c7ad61445c5b347c7382dd1237847eb1bce590fe50365dcb33d546be73\"\n-\"checksum lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c8f31047daa365f19be14b47c29df4f7c3b581832407daabe6ae77397619237d\"\n \"checksum lazycell 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b585b7a6811fb03aa10e74b278a0f00f8dd9b45dc681f148bb29fa5cb61859b\"\n \"checksum libc 0.2.34 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36fbc8a8929c632868295d0178dd8f63fc423fd7537ad0738372bd010b3ac9b0\"\n \"checksum libgit2-sys 0.6.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6f74b4959cef96898f5123148724fc7dee043b9a6b99f219d948851bfbe53cb2\""}, {"sha": "a8892cb22101a6245cedd353d4c250f54d4d18f7", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=1ba46dc378bbc3101a657a095d66a9c62a80a423", "patch": "@@ -24,7 +24,6 @@ rustc_errors = { path = \"../librustc_errors\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-regex = \"0.2.2\"\n backtrace = \"0.3.3\"\n byteorder = { version = \"1.1\", features = [\"i128\"]}\n "}, {"sha": "bf7484156a64a0dff0d95dea4a92fdb1ae5273aa", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=1ba46dc378bbc3101a657a095d66a9c62a80a423", "patch": "@@ -92,7 +92,6 @@ extern crate serialize as rustc_serialize; // used by deriving\n \n extern crate rustc_apfloat;\n extern crate byteorder;\n-extern crate regex;\n extern crate backtrace;\n \n // Note that librustc doesn't actually depend on these crates, see the note in"}, {"sha": "40ea4e1801b2680a817fab520760e0a7be23ccd8", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=1ba46dc378bbc3101a657a095d66a9c62a80a423", "patch": "@@ -13,7 +13,6 @@ bitflags = \"1.0\"\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.3\"\n log_settings = \"0.1.1\"\n-lazy_static = \"1.0\"\n rustc = { path = \"../librustc\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n@@ -23,5 +22,4 @@ serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n byteorder = { version = \"1.1\", features = [\"i128\"] }\n-regex = \"0.2\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }"}, {"sha": "6b33fd246daa874da1f3751e6ad03c180be8c8f0", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=1ba46dc378bbc3101a657a095d66a9c62a80a423", "patch": "@@ -1,4 +1,4 @@\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashSet;\n use std::fmt::Write;\n \n use rustc::hir::def_id::DefId;\n@@ -13,13 +13,13 @@ use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::{self, DUMMY_SP};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n-    PtrAndAlign, DynamicLifetime, GlobalId, Value, Pointer, PrimVal, PrimValKind,\n+    PtrAndAlign, GlobalId, Value, Pointer, PrimVal, PrimValKind,\n     EvalError, EvalResult, EvalErrorKind, MemoryPointer,\n };\n \n use super::{Place, PlaceExtra, Memory,\n             HasMemory, MemoryKind, operator,\n-            ValidationQuery, Machine};\n+            Machine};\n \n pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     /// Stores the `Machine` instance.\n@@ -34,9 +34,6 @@ pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     /// The virtual memory system.\n     pub memory: Memory<'a, 'tcx, M>,\n \n-    /// Places that were suspended by the validation subsystem, and will be recovered later\n-    pub(crate) suspended: HashMap<DynamicLifetime, Vec<ValidationQuery<'tcx>>>,\n-\n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'tcx>>,\n \n@@ -203,7 +200,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             tcx,\n             param_env,\n             memory: Memory::new(tcx, limits.memory_size, memory_data),\n-            suspended: HashMap::new(),\n             stack: Vec::new(),\n             stack_limit: limits.stack_limit,\n             steps_remaining: limits.step_limit,\n@@ -471,7 +467,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation -= 1;\n-        self.end_region(None)?;\n+        M::end_region(self, None)?;\n         let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n         );\n@@ -996,7 +992,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     /// ensures this Value is not a ByRef\n-    pub(super) fn follow_by_ref_value(\n+    pub fn follow_by_ref_value(\n         &self,\n         value: Value,\n         ty: Ty<'tcx>,\n@@ -1396,15 +1392,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n-    pub(super) fn frame_mut(&mut self) -> &mut Frame<'tcx> {\n+    pub fn frame_mut(&mut self) -> &mut Frame<'tcx> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n \n     pub(super) fn mir(&self) -> &'tcx mir::Mir<'tcx> {\n         self.frame().mir\n     }\n \n-    pub(super) fn substs(&self) -> &'tcx Substs<'tcx> {\n+    pub fn substs(&self) -> &'tcx Substs<'tcx> {\n         if let Some(frame) = self.stack.last() {\n             frame.instance.substs\n         } else {"}, {"sha": "47a6bfeb37ba3088f8f45bad6e28cb6c2711b500", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=1ba46dc378bbc3101a657a095d66a9c62a80a423", "patch": "@@ -2,8 +2,8 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n-use rustc::mir::interpret::{EvalResult, PrimVal};\n-use super::{EvalContext, Place, ValTy};\n+use rustc::mir::interpret::{EvalResult, PrimVal, MemoryPointer, AccessKind};\n+use super::{EvalContext, Place, ValTy, Memory};\n \n use rustc::mir;\n use rustc::ty::{self, Ty};\n@@ -77,4 +77,41 @@ pub trait Machine<'tcx>: Sized {\n         instance: ty::Instance<'tcx>,\n         mutability: Mutability,\n     ) -> EvalResult<'tcx>;\n+\n+    fn check_locks<'a>(\n+        _mem: &Memory<'a, 'tcx, Self>,\n+        _ptr: MemoryPointer,\n+        _size: u64,\n+        _access: AccessKind,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    fn add_lock<'a>(\n+        _mem: &mut Memory<'a, 'tcx, Self>,\n+        _id: u64,\n+    ) {}\n+\n+    fn free_lock<'a>(\n+        _mem: &mut Memory<'a, 'tcx, Self>,\n+        _id: u64,\n+        _len: u64,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    fn end_region<'a>(\n+        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _reg: Option<::rustc::middle::region::Scope>,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    fn validation_op<'a>(\n+        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _op: ::rustc::mir::ValidationOp,\n+        _operand: &::rustc::mir::ValidationOperand<'tcx, ::rustc::mir::Place<'tcx>>,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n }"}, {"sha": "490ac0e0fb76754222b5cd98e2161a6c5b027ced", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 8, "deletions": 401, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=1ba46dc378bbc3101a657a095d66a9c62a80a423", "patch": "@@ -6,77 +6,11 @@ use std::cell::Cell;\n use rustc::ty::{Instance, TyCtxt};\n use rustc::ty::layout::{self, TargetDataLayout};\n use syntax::ast::Mutability;\n-use rustc::middle::region;\n \n-use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, UndefMask, PtrAndAlign, Value, DynamicLifetime, Pointer,\n+use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, UndefMask, PtrAndAlign, Value, Pointer,\n                             EvalResult, PrimVal, EvalErrorKind};\n \n-use super::{EvalContext, Machine, RangeMap, AbsPlace};\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Locks\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// Information about a lock that is currently held.\n-#[derive(Clone, Debug)]\n-struct LockInfo<'tcx> {\n-    /// Stores for which lifetimes (of the original write lock) we got\n-    /// which suspensions.\n-    suspended: HashMap<WriteLockId<'tcx>, Vec<region::Scope>>,\n-    /// The current state of the lock that's actually effective.\n-    active: Lock,\n-}\n-\n-/// Write locks are identified by a stack frame and an \"abstract\" (untyped) place.\n-/// It may be tempting to use the lifetime as identifier, but that does not work\n-/// for two reasons:\n-/// * First of all, due to subtyping, the same lock may be referred to with different\n-///   lifetimes.\n-/// * Secondly, different write locks may actually have the same lifetime.  See `test2`\n-///   in `run-pass/many_shr_bor.rs`.\n-/// The Id is \"captured\" when the lock is first suspended; at that point, the borrow checker\n-/// considers the path frozen and hence the Id remains stable.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-struct WriteLockId<'tcx> {\n-    frame: usize,\n-    path: AbsPlace<'tcx>,\n-}\n-\n-\n-use rustc::mir::interpret::Lock::*;\n-use rustc::mir::interpret::Lock;\n-\n-impl<'tcx> Default for LockInfo<'tcx> {\n-    fn default() -> Self {\n-        LockInfo::new(NoLock)\n-    }\n-}\n-\n-impl<'tcx> LockInfo<'tcx> {\n-    fn new(lock: Lock) -> LockInfo<'tcx> {\n-        LockInfo {\n-            suspended: HashMap::new(),\n-            active: lock,\n-        }\n-    }\n-\n-    fn access_permitted(&self, frame: Option<usize>, access: AccessKind) -> bool {\n-        use self::AccessKind::*;\n-        match (&self.active, access) {\n-            (&NoLock, _) => true,\n-            (&ReadLock(ref lfts), Read) => {\n-                assert!(!lfts.is_empty(), \"Someone left an empty read lock behind.\");\n-                // Read access to read-locked region is okay, no matter who's holding the read lock.\n-                true\n-            }\n-            (&WriteLock(ref lft), _) => {\n-                // All access is okay if we are the ones holding it\n-                Some(lft.frame) == frame\n-            }\n-            _ => false, // Nothing else is okay.\n-        }\n-    }\n-}\n+use super::{EvalContext, Machine};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n@@ -123,36 +57,9 @@ pub struct Memory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     writes_are_aligned: Cell<bool>,\n \n     /// The current stack frame.  Used to check accesses against locks.\n-    pub(super) cur_frame: usize,\n+    pub cur_frame: usize,\n \n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-\n-    /// Memory regions that are locked by some function\n-    ///\n-    /// Only mutable (static mut, heap, stack) allocations have an entry in this map.\n-    /// The entry is created when allocating the memory and deleted after deallocation.\n-    locks: HashMap<u64, RangeMap<LockInfo<'tcx>>>,\n-}\n-\n-impl<'tcx> RangeMap<LockInfo<'tcx>> {\n-    fn check(\n-        &self,\n-        frame: Option<usize>,\n-        offset: u64,\n-        len: u64,\n-        access: AccessKind,\n-    ) -> Result<(), LockInfo<'tcx>> {\n-        if len == 0 {\n-            return Ok(());\n-        }\n-        for lock in self.iter(offset, len) {\n-            // Check if the lock is in conflict with the access.\n-            if !lock.access_permitted(frame, access) {\n-                return Err(lock.clone());\n-            }\n-        }\n-        Ok(())\n-    }\n }\n \n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n@@ -168,7 +75,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             reads_are_aligned: Cell::new(true),\n             writes_are_aligned: Cell::new(true),\n             cur_frame: usize::max_value(),\n-            locks: HashMap::new(),\n         }\n     }\n \n@@ -214,7 +120,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             align,\n         };\n         let id = self.tcx.interpret_interner.borrow_mut().reserve();\n-        self.locks.insert(id, RangeMap::new());\n+        M::add_lock(self, id);\n         match kind {\n             Some(kind @ MemoryKind::Stack) |\n             Some(kind @ MemoryKind::Machine(_)) => {\n@@ -320,21 +226,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         // However, we should check *something*.  For now, we make sure that there is no conflicting write\n         // lock by another frame.  We *have* to permit deallocation if we hold a read lock.\n         // TODO: Figure out the exact rules here.\n-        self.locks\n-            .remove(&ptr.alloc_id.0)\n-            .expect(\"allocation has no corresponding locks\")\n-            .check(\n-                Some(self.cur_frame),\n-                0,\n-                alloc.bytes.len() as u64,\n-                AccessKind::Read,\n-            )\n-            .map_err(|lock| {\n-                EvalErrorKind::DeallocatedLockedMemory {\n-                    ptr,\n-                    lock: lock.active,\n-                }\n-            })?;\n+        M::free_lock(self, ptr.alloc_id.0, alloc.bytes.len() as u64)?;\n \n         if alloc_kind != kind {\n             return err!(DeallocatedWrongMemoryKind(\n@@ -419,291 +311,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n }\n \n-/// Locking\n-impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n-    pub(crate) fn check_locks(\n-        &self,\n-        ptr: MemoryPointer,\n-        len: u64,\n-        access: AccessKind,\n-    ) -> EvalResult<'tcx> {\n-        if len == 0 {\n-            return Ok(());\n-        }\n-        let locks = match self.locks.get(&ptr.alloc_id.0) {\n-            Some(locks) => locks,\n-            // immutable static or other constant memory\n-            None => return Ok(()),\n-        };\n-        let frame = self.cur_frame;\n-        locks\n-            .check(Some(frame), ptr.offset, len, access)\n-            .map_err(|lock| {\n-                EvalErrorKind::MemoryLockViolation {\n-                    ptr,\n-                    len,\n-                    frame,\n-                    access,\n-                    lock: lock.active,\n-                }.into()\n-            })\n-    }\n-\n-    /// Acquire the lock for the given lifetime\n-    pub(crate) fn acquire_lock(\n-        &mut self,\n-        ptr: MemoryPointer,\n-        len: u64,\n-        region: Option<region::Scope>,\n-        kind: AccessKind,\n-    ) -> EvalResult<'tcx> {\n-        let frame = self.cur_frame;\n-        assert!(len > 0);\n-        trace!(\n-            \"Frame {} acquiring {:?} lock at {:?}, size {} for region {:?}\",\n-            frame,\n-            kind,\n-            ptr,\n-            len,\n-            region\n-        );\n-        self.check_bounds(ptr.offset(len, &*self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-\n-        let locks = match self.locks.get_mut(&ptr.alloc_id.0) {\n-            Some(locks) => locks,\n-            // immutable static or other constant memory\n-            None => return Ok(()),\n-        };\n-\n-        // Iterate over our range and acquire the lock.  If the range is already split into pieces,\n-        // we have to manipulate all of them.\n-        let lifetime = DynamicLifetime { frame, region };\n-        for lock in locks.iter_mut(ptr.offset, len) {\n-            if !lock.access_permitted(None, kind) {\n-                return err!(MemoryAcquireConflict {\n-                    ptr,\n-                    len,\n-                    kind,\n-                    lock: lock.active.clone(),\n-                });\n-            }\n-            // See what we have to do\n-            match (&mut lock.active, kind) {\n-                (active @ &mut NoLock, AccessKind::Write) => {\n-                    *active = WriteLock(lifetime);\n-                }\n-                (active @ &mut NoLock, AccessKind::Read) => {\n-                    *active = ReadLock(vec![lifetime]);\n-                }\n-                (&mut ReadLock(ref mut lifetimes), AccessKind::Read) => {\n-                    lifetimes.push(lifetime);\n-                }\n-                _ => bug!(\"We already checked that there is no conflicting lock\"),\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    /// Release or suspend a write lock of the given lifetime prematurely.\n-    /// When releasing, if there is a read lock or someone else's write lock, that's an error.\n-    /// If no lock is held, that's fine.  This can happen when e.g. a local is initialized\n-    /// from a constant, and then suspended.\n-    /// When suspending, the same cases are fine; we just register an additional suspension.\n-    pub(crate) fn suspend_write_lock(\n-        &mut self,\n-        ptr: MemoryPointer,\n-        len: u64,\n-        lock_path: &AbsPlace<'tcx>,\n-        suspend: Option<region::Scope>,\n-    ) -> EvalResult<'tcx> {\n-        assert!(len > 0);\n-        let cur_frame = self.cur_frame;\n-        let locks = match self.locks.get_mut(&ptr.alloc_id.0) {\n-            Some(locks) => locks,\n-            // immutable static or other constant memory\n-            None => return Ok(()),\n-        };\n-\n-        'locks: for lock in locks.iter_mut(ptr.offset, len) {\n-            let is_our_lock = match lock.active {\n-                WriteLock(lft) =>\n-                    // Double-check that we are holding the lock.\n-                    // (Due to subtyping, checking the region would not make any sense.)\n-                    lft.frame == cur_frame,\n-                ReadLock(_) | NoLock => false,\n-            };\n-            if is_our_lock {\n-                trace!(\"Releasing {:?}\", lock.active);\n-                // Disable the lock\n-                lock.active = NoLock;\n-            } else {\n-                trace!(\n-                    \"Not touching {:?} as it is not our lock\",\n-                    lock.active,\n-                );\n-            }\n-            // Check if we want to register a suspension\n-            if let Some(suspend_region) = suspend {\n-                let lock_id = WriteLockId {\n-                    frame: cur_frame,\n-                    path: lock_path.clone(),\n-                };\n-                trace!(\"Adding suspension to {:?}\", lock_id);\n-                let mut new_suspension = false;\n-                lock.suspended\n-                    .entry(lock_id)\n-                    // Remember whether we added a new suspension or not\n-                    .or_insert_with(|| { new_suspension = true; Vec::new() })\n-                    .push(suspend_region);\n-                // If the suspension is new, we should have owned this.\n-                // If there already was a suspension, we should NOT have owned this.\n-                if new_suspension == is_our_lock {\n-                    // All is well\n-                    continue 'locks;\n-                }\n-            } else {\n-                if !is_our_lock {\n-                    // All is well.\n-                    continue 'locks;\n-                }\n-            }\n-            // If we get here, releasing this is an error except for NoLock.\n-            if lock.active != NoLock {\n-                return err!(InvalidMemoryLockRelease {\n-                    ptr,\n-                    len,\n-                    frame: cur_frame,\n-                    lock: lock.active.clone(),\n-                });\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Release a suspension from the write lock.  If this is the last suspension or if there is no suspension, acquire the lock.\n-    pub(crate) fn recover_write_lock(\n-        &mut self,\n-        ptr: MemoryPointer,\n-        len: u64,\n-        lock_path: &AbsPlace<'tcx>,\n-        lock_region: Option<region::Scope>,\n-        suspended_region: region::Scope,\n-    ) -> EvalResult<'tcx> {\n-        assert!(len > 0);\n-        let cur_frame = self.cur_frame;\n-        let lock_id = WriteLockId {\n-            frame: cur_frame,\n-            path: lock_path.clone(),\n-        };\n-        let locks = match self.locks.get_mut(&ptr.alloc_id.0) {\n-            Some(locks) => locks,\n-            // immutable static or other constant memory\n-            None => return Ok(()),\n-        };\n-\n-        for lock in locks.iter_mut(ptr.offset, len) {\n-            // Check if we have a suspension here\n-            let (got_the_lock, remove_suspension) = match lock.suspended.get_mut(&lock_id) {\n-                None => {\n-                    trace!(\"No suspension around, we can just acquire\");\n-                    (true, false)\n-                }\n-                Some(suspensions) => {\n-                    trace!(\"Found suspension of {:?}, removing it\", lock_id);\n-                    // That's us!  Remove suspension (it should be in there).  The same suspension can\n-                    // occur multiple times (when there are multiple shared borrows of this that have the same\n-                    // lifetime); only remove one of them.\n-                    let idx = match suspensions.iter().enumerate().find(|&(_, re)| re == &suspended_region) {\n-                        None => // TODO: Can the user trigger this?\n-                            bug!(\"We have this lock suspended, but not for the given region.\"),\n-                        Some((idx, _)) => idx\n-                    };\n-                    suspensions.remove(idx);\n-                    let got_lock = suspensions.is_empty();\n-                    if got_lock {\n-                        trace!(\"All suspensions are gone, we can have the lock again\");\n-                    }\n-                    (got_lock, got_lock)\n-                }\n-            };\n-            if remove_suspension {\n-                // with NLL, we could do that up in the match above...\n-                assert!(got_the_lock);\n-                lock.suspended.remove(&lock_id);\n-            }\n-            if got_the_lock {\n-                match lock.active {\n-                    ref mut active @ NoLock => {\n-                        *active = WriteLock(\n-                            DynamicLifetime {\n-                                frame: cur_frame,\n-                                region: lock_region,\n-                            }\n-                        );\n-                    }\n-                    _ => {\n-                        return err!(MemoryAcquireConflict {\n-                            ptr,\n-                            len,\n-                            kind: AccessKind::Write,\n-                            lock: lock.active.clone(),\n-                        })\n-                    }\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    pub(crate) fn locks_lifetime_ended(&mut self, ending_region: Option<region::Scope>) {\n-        let cur_frame = self.cur_frame;\n-        trace!(\n-            \"Releasing frame {} locks that expire at {:?}\",\n-            cur_frame,\n-            ending_region\n-        );\n-        let has_ended = |lifetime: &DynamicLifetime| -> bool {\n-            if lifetime.frame != cur_frame {\n-                return false;\n-            }\n-            match ending_region {\n-                None => true, // When a function ends, we end *all* its locks. It's okay for a function to still have lifetime-related locks\n-                // when it returns, that can happen e.g. with NLL when a lifetime can, but does not have to, extend beyond the\n-                // end of a function.  Same for a function still having recoveries.\n-                Some(ending_region) => lifetime.region == Some(ending_region),\n-            }\n-        };\n-\n-        for alloc_locks in self.locks.values_mut() {\n-            for lock in alloc_locks.iter_mut_all() {\n-                // Delete everything that ends now -- i.e., keep only all the other lifetimes.\n-                let lock_ended = match lock.active {\n-                    WriteLock(ref lft) => has_ended(lft),\n-                    ReadLock(ref mut lfts) => {\n-                        lfts.retain(|lft| !has_ended(lft));\n-                        lfts.is_empty()\n-                    }\n-                    NoLock => false,\n-                };\n-                if lock_ended {\n-                    lock.active = NoLock;\n-                }\n-                // Also clean up suspended write locks when the function returns\n-                if ending_region.is_none() {\n-                    lock.suspended.retain(|id, _suspensions| id.frame != cur_frame);\n-                }\n-            }\n-            // Clean up the map\n-            alloc_locks.retain(|lock| match lock.active {\n-                NoLock => lock.suspended.len() > 0,\n-                _ => true,\n-            });\n-        }\n-    }\n-}\n-\n /// Allocation accessors\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n@@ -882,7 +489,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         if size == 0 {\n             return Ok(&[]);\n         }\n-        self.check_locks(ptr, size, AccessKind::Read)?;\n+        M::check_locks(self, ptr, size, AccessKind::Read)?;\n         self.check_bounds(ptr.offset(size, self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -902,7 +509,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         if size == 0 {\n             return Ok(&mut []);\n         }\n-        self.check_locks(ptr, size, AccessKind::Write)?;\n+        M::check_locks(self, ptr, size, AccessKind::Write)?;\n         self.check_bounds(ptr.offset(size, &*self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -1089,7 +696,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                     return err!(ReadPointerAsBytes);\n                 }\n                 self.check_defined(ptr, (size + 1) as u64)?;\n-                self.check_locks(ptr, (size + 1) as u64, AccessKind::Read)?;\n+                M::check_locks(self, ptr, (size + 1) as u64, AccessKind::Read)?;\n                 Ok(&alloc.bytes[offset..offset + size])\n             }\n             None => err!(UnterminatedCString(ptr)),"}, {"sha": "fee62c8a82e2f08a2895fb02949919143612cff4", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=1ba46dc378bbc3101a657a095d66a9c62a80a423", "patch": "@@ -4,11 +4,9 @@ mod cast;\n mod const_eval;\n mod eval_context;\n mod place;\n-mod validation;\n mod machine;\n mod memory;\n mod operator;\n-mod range_map;\n mod step;\n mod terminator;\n mod traits;\n@@ -20,10 +18,6 @@ pub use self::place::{Place, PlaceExtra};\n \n pub use self::memory::{Memory, MemoryKind, HasMemory};\n \n-use self::range_map::RangeMap;\n-\n pub use self::const_eval::{eval_body_as_integer, eval_body, CompileTimeEvaluator, const_eval_provider};\n \n pub use self::machine::Machine;\n-\n-pub use self::validation::{ValidationQuery, AbsPlace};"}, {"sha": "0e44b414d7fe5ce98eb79d691868fa67a3e91363", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=1ba46dc378bbc3101a657a095d66a9c62a80a423", "patch": "@@ -278,7 +278,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok((Place::Ptr { ptr, extra }, field))\n     }\n \n-    pub(super) fn val_to_place(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Place> {\n+    pub fn val_to_place(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Place> {\n         Ok(match self.tcx.struct_tail(ty).sty {\n             ty::TyDynamic(..) => {\n                 let (ptr, vtable) = self.into_ptr_vtable_pair(val)?;\n@@ -298,7 +298,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         })\n     }\n \n-    pub(super) fn place_index(\n+    pub fn place_index(\n         &mut self,\n         base: Place,\n         outer_ty: Ty<'tcx>,\n@@ -335,7 +335,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(Place::Ptr { ptr, extra })\n     }\n \n-    pub(super) fn eval_place_projection(\n+    pub fn eval_place_projection(\n         &mut self,\n         base: Place,\n         base_ty: Ty<'tcx>,"}, {"sha": "5cdcbe35121a579e26b6d74c461b5cb64ece2676", "filename": "src/librustc_mir/interpret/range_map.rs", "status": "removed", "additions": 0, "deletions": 250, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -1,250 +0,0 @@\n-//! Implements a map from integer indices to data.\n-//! Rather than storing data for every index, internally, this maps entire ranges to the data.\n-//! To this end, the APIs all work on ranges, not on individual integers. Ranges are split as\n-//! necessary (e.g. when [0,5) is first associated with X, and then [1,2) is mutated).\n-//! Users must not depend on whether a range is coalesced or not, even though this is observable\n-//! via the iteration APIs.\n-use std::collections::BTreeMap;\n-use std::ops;\n-\n-#[derive(Clone, Debug)]\n-pub struct RangeMap<T> {\n-    map: BTreeMap<Range, T>,\n-}\n-\n-// The derived `Ord` impl sorts first by the first field, then, if the fields are the same,\n-// by the second field.\n-// This is exactly what we need for our purposes, since a range query on a BTReeSet/BTreeMap will give us all\n-// `MemoryRange`s whose `start` is <= than the one we're looking for, but not > the end of the range we're checking.\n-// At the same time the `end` is irrelevant for the sorting and range searching, but used for the check.\n-// This kind of search breaks, if `end < start`, so don't do that!\n-#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n-struct Range {\n-    start: u64,\n-    end: u64, // Invariant: end > start\n-}\n-\n-impl Range {\n-    fn range(offset: u64, len: u64) -> ops::Range<Range> {\n-        assert!(len > 0);\n-        // We select all elements that are within\n-        // the range given by the offset into the allocation and the length.\n-        // This is sound if all ranges that intersect with the argument range, are in the\n-        // resulting range of ranges.\n-        let left = Range {\n-            // lowest range to include `offset`\n-            start: 0,\n-            end: offset + 1,\n-        };\n-        let right = Range {\n-            // lowest (valid) range not to include `offset+len`\n-            start: offset + len,\n-            end: offset + len + 1,\n-        };\n-        left..right\n-    }\n-\n-    /// Tests if all of [offset, offset+len) are contained in this range.\n-    fn overlaps(&self, offset: u64, len: u64) -> bool {\n-        assert!(len > 0);\n-        offset < self.end && offset + len >= self.start\n-    }\n-}\n-\n-impl<T> RangeMap<T> {\n-    pub fn new() -> RangeMap<T> {\n-        RangeMap { map: BTreeMap::new() }\n-    }\n-\n-    fn iter_with_range<'a>(\n-        &'a self,\n-        offset: u64,\n-        len: u64,\n-    ) -> impl Iterator<Item = (&'a Range, &'a T)> + 'a {\n-        assert!(len > 0);\n-        self.map.range(Range::range(offset, len)).filter_map(\n-            move |(range,\n-                   data)| {\n-                if range.overlaps(offset, len) {\n-                    Some((range, data))\n-                } else {\n-                    None\n-                }\n-            },\n-        )\n-    }\n-\n-    pub fn iter<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item = &'a T> + 'a {\n-        self.iter_with_range(offset, len).map(|(_, data)| data)\n-    }\n-\n-    fn split_entry_at(&mut self, offset: u64)\n-    where\n-        T: Clone,\n-    {\n-        let range = match self.iter_with_range(offset, 1).next() {\n-            Some((&range, _)) => range,\n-            None => return,\n-        };\n-        assert!(\n-            range.start <= offset && range.end > offset,\n-            \"We got a range that doesn't even contain what we asked for.\"\n-        );\n-        // There is an entry overlapping this position, see if we have to split it\n-        if range.start < offset {\n-            let data = self.map.remove(&range).unwrap();\n-            let old = self.map.insert(\n-                Range {\n-                    start: range.start,\n-                    end: offset,\n-                },\n-                data.clone(),\n-            );\n-            assert!(old.is_none());\n-            let old = self.map.insert(\n-                Range {\n-                    start: offset,\n-                    end: range.end,\n-                },\n-                data,\n-            );\n-            assert!(old.is_none());\n-        }\n-    }\n-\n-    pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item = &'a mut T> + 'a {\n-        self.map.values_mut()\n-    }\n-\n-    /// Provide mutable iteration over everything in the given range.  As a side-effect,\n-    /// this will split entries in the map that are only partially hit by the given range,\n-    /// to make sure that when they are mutated, the effect is constrained to the given range.\n-    pub fn iter_mut_with_gaps<'a>(\n-        &'a mut self,\n-        offset: u64,\n-        len: u64,\n-    ) -> impl Iterator<Item = &'a mut T> + 'a\n-    where\n-        T: Clone,\n-    {\n-        assert!(len > 0);\n-        // Preparation: Split first and last entry as needed.\n-        self.split_entry_at(offset);\n-        self.split_entry_at(offset + len);\n-        // Now we can provide a mutable iterator\n-        self.map.range_mut(Range::range(offset, len)).filter_map(\n-            move |(&range, data)| {\n-                if range.overlaps(offset, len) {\n-                    assert!(\n-                        offset <= range.start && offset + len >= range.end,\n-                        \"The splitting went wrong\"\n-                    );\n-                    Some(data)\n-                } else {\n-                    // Skip this one\n-                    None\n-                }\n-            },\n-        )\n-    }\n-\n-    /// Provide a mutable iterator over everything in the given range, with the same side-effects as\n-    /// iter_mut_with_gaps.  Furthermore, if there are gaps between ranges, fill them with the given default.\n-    /// This is also how you insert.\n-    pub fn iter_mut<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item = &'a mut T> + 'a\n-    where\n-        T: Clone + Default,\n-    {\n-        // Do a first iteration to collect the gaps\n-        let mut gaps = Vec::new();\n-        let mut last_end = offset;\n-        for (range, _) in self.iter_with_range(offset, len) {\n-            if last_end < range.start {\n-                gaps.push(Range {\n-                    start: last_end,\n-                    end: range.start,\n-                });\n-            }\n-            last_end = range.end;\n-        }\n-        if last_end < offset + len {\n-            gaps.push(Range {\n-                start: last_end,\n-                end: offset + len,\n-            });\n-        }\n-\n-        // Add default for all gaps\n-        for gap in gaps {\n-            let old = self.map.insert(gap, Default::default());\n-            assert!(old.is_none());\n-        }\n-\n-        // Now provide mutable iteration\n-        self.iter_mut_with_gaps(offset, len)\n-    }\n-\n-    pub fn retain<F>(&mut self, mut f: F)\n-    where\n-        F: FnMut(&T) -> bool,\n-    {\n-        let mut remove = Vec::new();\n-        for (range, data) in self.map.iter() {\n-            if !f(data) {\n-                remove.push(*range);\n-            }\n-        }\n-\n-        for range in remove {\n-            self.map.remove(&range);\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    /// Query the map at every offset in the range and collect the results.\n-    fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64) -> Vec<T> {\n-        (offset..offset + len)\n-            .into_iter()\n-            .map(|i| *map.iter(i, 1).next().unwrap())\n-            .collect()\n-    }\n-\n-    #[test]\n-    fn basic_insert() {\n-        let mut map = RangeMap::<i32>::new();\n-        // Insert\n-        for x in map.iter_mut(10, 1) {\n-            *x = 42;\n-        }\n-        // Check\n-        assert_eq!(to_vec(&map, 10, 1), vec![42]);\n-    }\n-\n-    #[test]\n-    fn gaps() {\n-        let mut map = RangeMap::<i32>::new();\n-        for x in map.iter_mut(11, 1) {\n-            *x = 42;\n-        }\n-        for x in map.iter_mut(15, 1) {\n-            *x = 42;\n-        }\n-\n-        // Now request a range that needs three gaps filled\n-        for x in map.iter_mut(10, 10) {\n-            if *x != 42 {\n-                *x = 23;\n-            }\n-        }\n-\n-        assert_eq!(\n-            to_vec(&map, 10, 10),\n-            vec![23, 42, 23, 23, 23, 42, 23, 23, 23, 23]\n-        );\n-        assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 42, 23, 23]);\n-    }\n-}"}, {"sha": "352e151e3a19566a5319d194bc403ec325ee0954", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=1ba46dc378bbc3101a657a095d66a9c62a80a423", "patch": "@@ -126,11 +126,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // Validity checks.\n             Validate(op, ref places) => {\n                 for operand in places {\n-                    self.validation_op(op, operand)?;\n+                    M::validation_op(self, op, operand)?;\n                 }\n             }\n             EndRegion(ce) => {\n-                self.end_region(Some(ce))?;\n+                M::end_region(self, Some(ce))?;\n             }\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the"}, {"sha": "740a2c53e2f73858d0ffe3094cb8ff776a3e349a", "filename": "src/librustc_mir/interpret/validation.rs", "status": "removed", "additions": 0, "deletions": 805, "changes": 805, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -1,805 +0,0 @@\n-use rustc::hir::{self, Mutability};\n-use rustc::hir::Mutability::*;\n-use rustc::mir::{self, ValidationOp, ValidationOperand};\n-use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n-use rustc::ty::layout::LayoutOf;\n-use rustc::ty::subst::{Substs, Subst};\n-use rustc::traits;\n-use rustc::infer::InferCtxt;\n-use rustc::traits::Reveal;\n-use rustc::middle::region;\n-use rustc_data_structures::indexed_vec::Idx;\n-use interpret::memory::HasMemory;\n-\n-use super::{EvalContext, Place, PlaceExtra, Machine, ValTy};\n-use rustc::mir::interpret::{DynamicLifetime, AccessKind, EvalErrorKind, Value, EvalError, EvalResult};\n-\n-pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, (AbsPlace<'tcx>, Place)>;\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-enum ValidationMode {\n-    Acquire,\n-    /// Recover because the given region ended\n-    Recover(region::Scope),\n-    ReleaseUntil(Option<region::Scope>),\n-}\n-\n-impl ValidationMode {\n-    fn acquiring(self) -> bool {\n-        use self::ValidationMode::*;\n-        match self {\n-            Acquire | Recover(_) => true,\n-            ReleaseUntil(_) => false,\n-        }\n-    }\n-}\n-\n-// Abstract places\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum AbsPlace<'tcx> {\n-    Local(mir::Local),\n-    Static(hir::def_id::DefId),\n-    Projection(Box<AbsPlaceProjection<'tcx>>),\n-}\n-\n-type AbsPlaceProjection<'tcx> = mir::Projection<'tcx, AbsPlace<'tcx>, u64, ()>;\n-type AbsPlaceElem<'tcx> = mir::ProjectionElem<'tcx, u64, ()>;\n-\n-impl<'tcx> AbsPlace<'tcx> {\n-    pub fn field(self, f: mir::Field) -> AbsPlace<'tcx> {\n-        self.elem(mir::ProjectionElem::Field(f, ()))\n-    }\n-\n-    pub fn deref(self) -> AbsPlace<'tcx> {\n-        self.elem(mir::ProjectionElem::Deref)\n-    }\n-\n-    pub fn downcast(self, adt_def: &'tcx ty::AdtDef, variant_index: usize) -> AbsPlace<'tcx> {\n-        self.elem(mir::ProjectionElem::Downcast(adt_def, variant_index))\n-    }\n-\n-    pub fn index(self, index: u64) -> AbsPlace<'tcx> {\n-        self.elem(mir::ProjectionElem::Index(index))\n-    }\n-\n-    fn elem(self, elem: AbsPlaceElem<'tcx>) -> AbsPlace<'tcx> {\n-        AbsPlace::Projection(Box::new(AbsPlaceProjection {\n-            base: self,\n-            elem,\n-        }))\n-    }\n-}\n-\n-impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n-    fn abstract_place_projection(&self, proj: &mir::PlaceProjection<'tcx>) -> EvalResult<'tcx, AbsPlaceProjection<'tcx>> {\n-        use self::mir::ProjectionElem::*;\n-\n-        let elem = match proj.elem {\n-            Deref => Deref,\n-            Field(f, _) => Field(f, ()),\n-            Index(v) => {\n-                let value = self.frame().get_local(v)?;\n-                let ty = self.tcx.types.usize;\n-                let n = self.value_to_primval(ValTy { value, ty })?.to_u64()?;\n-                Index(n)\n-            },\n-            ConstantIndex { offset, min_length, from_end } =>\n-                ConstantIndex { offset, min_length, from_end },\n-            Subslice { from, to } =>\n-                Subslice { from, to },\n-            Downcast(adt, sz) => Downcast(adt, sz),\n-        };\n-        Ok(AbsPlaceProjection {\n-            base: self.abstract_place(&proj.base)?,\n-            elem\n-        })\n-    }\n-\n-    fn abstract_place(&self, place: &mir::Place<'tcx>) -> EvalResult<'tcx, AbsPlace<'tcx>> {\n-        Ok(match place {\n-            &mir::Place::Local(l) => AbsPlace::Local(l),\n-            &mir::Place::Static(ref s) => AbsPlace::Static(s.def_id),\n-            &mir::Place::Projection(ref p) =>\n-                AbsPlace::Projection(Box::new(self.abstract_place_projection(&*p)?)),\n-        })\n-    }\n-\n-    // Validity checks\n-    pub(crate) fn validation_op(\n-        &mut self,\n-        op: ValidationOp,\n-        operand: &ValidationOperand<'tcx, mir::Place<'tcx>>,\n-    ) -> EvalResult<'tcx> {\n-        // If mir-emit-validate is set to 0 (i.e., disabled), we may still see validation commands\n-        // because other crates may have been compiled with mir-emit-validate > 0.  Ignore those\n-        // commands.  This makes mir-emit-validate also a flag to control whether miri will do\n-        // validation or not.\n-        if self.tcx.sess.opts.debugging_opts.mir_emit_validate == 0 {\n-            return Ok(());\n-        }\n-        debug_assert!(self.memory.cur_frame == self.cur_frame());\n-\n-        // HACK: Determine if this method is whitelisted and hence we do not perform any validation.\n-        // We currently insta-UB on anything passing around uninitialized memory, so we have to whitelist\n-        // the places that are allowed to do that.\n-        // The second group is stuff libstd does that is forbidden even under relaxed validation.\n-        {\n-            // The regexp we use for filtering\n-            use regex::Regex;\n-            lazy_static! {\n-                static ref RE: Regex = Regex::new(\"^(\\\n-                    (std|alloc::heap::__core)::mem::(uninitialized|forget)::|\\\n-                    <(std|alloc)::heap::Heap as (std::heap|alloc::allocator)::Alloc>::|\\\n-                    <(std|alloc::heap::__core)::mem::ManuallyDrop<T>><.*>::new$|\\\n-                    <(std|alloc::heap::__core)::mem::ManuallyDrop<T> as std::ops::DerefMut><.*>::deref_mut$|\\\n-                    (std|alloc::heap::__core)::ptr::read::|\\\n-                    \\\n-                    <std::sync::Arc<T>><.*>::inner$|\\\n-                    <std::sync::Arc<T>><.*>::drop_slow$|\\\n-                    (std::heap|alloc::allocator)::Layout::for_value::|\\\n-                    (std|alloc::heap::__core)::mem::(size|align)_of_val::\\\n-                )\").unwrap();\n-            }\n-            // Now test\n-            let name = self.stack[self.cur_frame()].instance.to_string();\n-            if RE.is_match(&name) {\n-                return Ok(());\n-            }\n-        }\n-\n-        // We need to monomorphize ty *without* erasing lifetimes\n-        trace!(\"validation_op1: {:?}\", operand.ty.sty);\n-        let ty = operand.ty.subst(self.tcx, self.substs());\n-        trace!(\"validation_op2: {:?}\", operand.ty.sty);\n-        let place = self.eval_place(&operand.place)?;\n-        let abs_place = self.abstract_place(&operand.place)?;\n-        let query = ValidationQuery {\n-            place: (abs_place, place),\n-            ty,\n-            re: operand.re,\n-            mutbl: operand.mutbl,\n-        };\n-\n-        // Check the mode, and also perform mode-specific operations\n-        let mode = match op {\n-            ValidationOp::Acquire => ValidationMode::Acquire,\n-            ValidationOp::Release => ValidationMode::ReleaseUntil(None),\n-            ValidationOp::Suspend(scope) => {\n-                if query.mutbl == MutMutable {\n-                    let lft = DynamicLifetime {\n-                        frame: self.cur_frame(),\n-                        region: Some(scope), // Notably, we only ever suspend things for given regions.\n-                        // Suspending for the entire function does not make any sense.\n-                    };\n-                    trace!(\"Suspending {:?} until {:?}\", query, scope);\n-                    self.suspended.entry(lft).or_insert_with(Vec::new).push(\n-                        query.clone(),\n-                    );\n-                }\n-                ValidationMode::ReleaseUntil(Some(scope))\n-            }\n-        };\n-        self.validate(query, mode)\n-    }\n-\n-    /// Release locks and executes suspensions of the given region (or the entire fn, in case of None).\n-    pub(crate) fn end_region(&mut self, scope: Option<region::Scope>) -> EvalResult<'tcx> {\n-        debug_assert!(self.memory.cur_frame == self.cur_frame());\n-        self.memory.locks_lifetime_ended(scope);\n-        match scope {\n-            Some(scope) => {\n-                // Recover suspended places\n-                let lft = DynamicLifetime {\n-                    frame: self.cur_frame(),\n-                    region: Some(scope),\n-                };\n-                if let Some(queries) = self.suspended.remove(&lft) {\n-                    for query in queries {\n-                        trace!(\"Recovering {:?} from suspension\", query);\n-                        self.validate(query, ValidationMode::Recover(scope))?;\n-                    }\n-                }\n-            }\n-            None => {\n-                // Clean suspension table of current frame\n-                let cur_frame = self.cur_frame();\n-                self.suspended.retain(|lft, _| {\n-                    lft.frame != cur_frame // keep only what is in the other (lower) frames\n-                });\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    fn normalize_type_unerased(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        return normalize_associated_type(self.tcx, &ty);\n-\n-        use syntax::codemap::{Span, DUMMY_SP};\n-\n-        // We copy a bunch of stuff from rustc/infer/mod.rs to be able to tweak its behavior\n-        fn normalize_projections_in<'a, 'gcx, 'tcx, T>(\n-            self_: &InferCtxt<'a, 'gcx, 'tcx>,\n-            param_env: ty::ParamEnv<'tcx>,\n-            value: &T,\n-        ) -> T::Lifted\n-        where\n-            T: TypeFoldable<'tcx> + ty::Lift<'gcx>,\n-        {\n-            let mut selcx = traits::SelectionContext::new(self_);\n-            let cause = traits::ObligationCause::dummy();\n-            let traits::Normalized {\n-                value: result,\n-                obligations,\n-            } = traits::normalize(&mut selcx, param_env, cause, value);\n-\n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n-\n-            for obligation in obligations {\n-                fulfill_cx.register_predicate_obligation(self_, obligation);\n-            }\n-\n-            drain_fulfillment_cx_or_panic(self_, DUMMY_SP, &mut fulfill_cx, &result)\n-        }\n-\n-        fn drain_fulfillment_cx_or_panic<'a, 'gcx, 'tcx, T>(\n-            self_: &InferCtxt<'a, 'gcx, 'tcx>,\n-            span: Span,\n-            fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-            result: &T,\n-        ) -> T::Lifted\n-        where\n-            T: TypeFoldable<'tcx> + ty::Lift<'gcx>,\n-        {\n-            // In principle, we only need to do this so long as `result`\n-            // contains unbound type parameters. It could be a slight\n-            // optimization to stop iterating early.\n-            match fulfill_cx.select_all_or_error(self_) {\n-                Ok(()) => { }\n-                Err(errors) => {\n-                    span_bug!(\n-                        span,\n-                        \"Encountered errors `{:?}` resolving bounds after type-checking\",\n-                        errors\n-                    );\n-                }\n-            }\n-\n-            let result = self_.resolve_type_vars_if_possible(result);\n-            let result = self_.tcx.fold_regions(\n-                &result,\n-                &mut false,\n-                |r, _| match *r {\n-                    ty::ReVar(_) => self_.tcx.types.re_erased,\n-                    _ => r,\n-                },\n-            );\n-\n-            match self_.tcx.lift_to_global(&result) {\n-                Some(result) => result,\n-                None => {\n-                    span_bug!(span, \"Uninferred types/regions in `{:?}`\", result);\n-                }\n-            }\n-        }\n-\n-        trait MyTransNormalize<'gcx>: TypeFoldable<'gcx> {\n-            fn my_trans_normalize<'a, 'tcx>(\n-                &self,\n-                infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                param_env: ty::ParamEnv<'tcx>,\n-            ) -> Self;\n-        }\n-\n-        macro_rules! items { ($($item:item)+) => ($($item)+) }\n-        macro_rules! impl_trans_normalize {\n-            ($lt_gcx:tt, $($ty:ty),+) => {\n-                items!($(impl<$lt_gcx> MyTransNormalize<$lt_gcx> for $ty {\n-                    fn my_trans_normalize<'a, 'tcx>(&self,\n-                                                infcx: &InferCtxt<'a, $lt_gcx, 'tcx>,\n-                                                param_env: ty::ParamEnv<'tcx>)\n-                                                -> Self {\n-                        normalize_projections_in(infcx, param_env, self)\n-                    }\n-                })+);\n-            }\n-        }\n-\n-        impl_trans_normalize!('gcx,\n-            Ty<'gcx>,\n-            &'gcx Substs<'gcx>,\n-            ty::FnSig<'gcx>,\n-            ty::PolyFnSig<'gcx>,\n-            ty::ClosureSubsts<'gcx>,\n-            ty::PolyTraitRef<'gcx>,\n-            ty::ExistentialTraitRef<'gcx>\n-        );\n-\n-        fn normalize_associated_type<'a, 'tcx, T>(self_: TyCtxt<'a, 'tcx, 'tcx>, value: &T) -> T\n-        where\n-            T: MyTransNormalize<'tcx>,\n-        {\n-            let param_env = ty::ParamEnv::empty(Reveal::All);\n-\n-            if !value.has_projections() {\n-                return value.clone();\n-            }\n-\n-            self_.infer_ctxt().enter(|infcx| {\n-                value.my_trans_normalize(&infcx, param_env)\n-            })\n-        }\n-    }\n-\n-    // This is a copy of `Layout::field`\n-    //\n-    // FIXME: remove once validation does not depend on lifetimes\n-    fn field_with_lifetimes(\n-        &mut self,\n-        base: Place,\n-        mut layout: ty::layout::TyLayout<'tcx>,\n-        i: usize,\n-    ) -> EvalResult<'tcx, Ty<'tcx>> {\n-        match base {\n-            Place::Ptr { extra: PlaceExtra::DowncastVariant(variant_index), .. } => {\n-                layout = layout.for_variant(&self, variant_index);\n-            }\n-            _ => {}\n-        }\n-        let tcx = self.tcx;\n-        Ok(match layout.ty.sty {\n-            ty::TyBool |\n-            ty::TyChar |\n-            ty::TyInt(_) |\n-            ty::TyUint(_) |\n-            ty::TyFloat(_) |\n-            ty::TyFnPtr(_) |\n-            ty::TyNever |\n-            ty::TyFnDef(..) |\n-            ty::TyDynamic(..) |\n-            ty::TyForeign(..) => {\n-                bug!(\"TyLayout::field_type({:?}): not applicable\", layout)\n-            }\n-\n-            // Potentially-fat pointers.\n-            ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n-                assert!(i < 2);\n-\n-                // Reuse the fat *T type as its own thin pointer data field.\n-                // This provides information about e.g. DST struct pointees\n-                // (which may have no non-DST form), and will work as long\n-                // as the `Abi` or `FieldPlacement` is checked by users.\n-                if i == 0 {\n-                    return Ok(layout.ty);\n-                }\n-\n-                match tcx.struct_tail(pointee).sty {\n-                    ty::TySlice(_) |\n-                    ty::TyStr => tcx.types.usize,\n-                    ty::TyDynamic(..) => {\n-                        // FIXME(eddyb) use an usize/fn() array with\n-                        // the correct number of vtables slots.\n-                        tcx.mk_imm_ref(tcx.types.re_static, tcx.mk_nil())\n-                    }\n-                    _ => bug!(\"TyLayout::field_type({:?}): not applicable\", layout)\n-                }\n-            }\n-\n-            // Arrays and slices.\n-            ty::TyArray(element, _) |\n-            ty::TySlice(element) => element,\n-            ty::TyStr => tcx.types.u8,\n-\n-            // Tuples, generators and closures.\n-            ty::TyClosure(def_id, ref substs) => {\n-                substs.upvar_tys(def_id, tcx).nth(i).unwrap()\n-            }\n-\n-            ty::TyGenerator(def_id, ref substs, _) => {\n-                substs.field_tys(def_id, tcx).nth(i).unwrap()\n-            }\n-\n-            ty::TyTuple(tys, _) => tys[i],\n-\n-            // SIMD vector types.\n-            ty::TyAdt(def, ..) if def.repr.simd() => {\n-                layout.ty.simd_type(tcx)\n-            }\n-\n-            // ADTs.\n-            ty::TyAdt(def, substs) => {\n-                use rustc::ty::layout::Variants;\n-                match layout.variants {\n-                    Variants::Single { index } => {\n-                        def.variants[index].fields[i].ty(tcx, substs)\n-                    }\n-\n-                    // Discriminant field for enums (where applicable).\n-                    Variants::Tagged { ref discr, .. } |\n-                    Variants::NicheFilling { niche: ref discr, .. } => {\n-                        assert_eq!(i, 0);\n-                        return Ok(discr.value.to_ty(tcx))\n-                    }\n-                }\n-            }\n-\n-            ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n-            ty::TyInfer(_) | ty::TyError => {\n-                bug!(\"TyLayout::field_type: unexpected type `{}`\", layout.ty)\n-            }\n-        })\n-    }\n-\n-    fn validate_fields(\n-        &mut self,\n-        query: ValidationQuery<'tcx>,\n-        mode: ValidationMode,\n-    ) -> EvalResult<'tcx> {\n-        let mut layout = self.layout_of(query.ty)?;\n-        layout.ty = query.ty;\n-\n-        // TODO: Maybe take visibility/privacy into account.\n-        for idx in 0..layout.fields.count() {\n-            let field = mir::Field::new(idx);\n-            let (field_place, field_layout) =\n-                self.place_field(query.place.1, field, layout)?;\n-            // layout stuff erases lifetimes, get the field ourselves\n-            let field_ty = self.field_with_lifetimes(query.place.1, layout, idx)?;\n-            trace!(\"assuming \\n{:?}\\n == \\n{:?}\\n except for lifetimes\", field_layout.ty, field_ty);\n-            self.validate(\n-                ValidationQuery {\n-                    place: (query.place.0.clone().field(field), field_place),\n-                    ty: field_ty,\n-                    ..query\n-                },\n-                mode,\n-            )?;\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn validate_ptr(\n-        &mut self,\n-        val: Value,\n-        abs_place: AbsPlace<'tcx>,\n-        pointee_ty: Ty<'tcx>,\n-        re: Option<region::Scope>,\n-        mutbl: Mutability,\n-        mode: ValidationMode,\n-    ) -> EvalResult<'tcx> {\n-        // Check alignment and non-NULLness\n-        let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n-        let ptr = self.into_ptr(val)?;\n-        self.memory.check_align(ptr, align.abi(), None)?;\n-\n-        // Recurse\n-        let pointee_place = self.val_to_place(val, pointee_ty)?;\n-        self.validate(\n-            ValidationQuery {\n-                place: (abs_place.deref(), pointee_place),\n-                ty: pointee_ty,\n-                re,\n-                mutbl,\n-            },\n-            mode,\n-        )\n-    }\n-\n-    /// Validate the place at the given type. If `acquire` is false, just do a release of all write locks\n-    fn validate(\n-        &mut self,\n-        mut query: ValidationQuery<'tcx>,\n-        mode: ValidationMode,\n-    ) -> EvalResult<'tcx> {\n-        use rustc::ty::TypeVariants::*;\n-        use rustc::ty::RegionKind::*;\n-        use rustc::ty::AdtKind;\n-\n-        // No point releasing shared stuff.\n-        if !mode.acquiring() && query.mutbl == MutImmutable {\n-            return Ok(());\n-        }\n-        // When we recover, we may see data whose validity *just* ended.  Do not acquire it.\n-        if let ValidationMode::Recover(ending_ce) = mode {\n-            if query.re == Some(ending_ce) {\n-                return Ok(());\n-            }\n-        }\n-\n-        query.ty = self.normalize_type_unerased(&query.ty);\n-        trace!(\"{:?} on {:#?}\", mode, query);\n-        trace!(\"{:#?}\", query.ty.sty);\n-\n-        // Decide whether this type *owns* the memory it covers (like integers), or whether it\n-        // just assembles pieces (that each own their memory) together to a larger whole.\n-        // TODO: Currently, we don't acquire locks for padding and discriminants. We should.\n-        let is_owning = match query.ty.sty {\n-            TyInt(_) | TyUint(_) | TyRawPtr(_) | TyBool | TyFloat(_) | TyChar | TyStr |\n-            TyRef(..) | TyFnPtr(..) | TyFnDef(..) | TyNever => true,\n-            TyAdt(adt, _) if adt.is_box() => true,\n-            TySlice(_) | TyAdt(_, _) | TyTuple(..) | TyClosure(..) | TyArray(..) |\n-            TyDynamic(..) | TyGenerator(..) | TyForeign(_) => false,\n-            TyParam(_) | TyInfer(_) | TyProjection(_) | TyAnon(..) | TyError => {\n-                bug!(\"I got an incomplete/unnormalized type for validation\")\n-            }\n-        };\n-        if is_owning {\n-            // We need to lock.  So we need memory.  So we have to force_acquire.\n-            // Tracking the same state for locals not backed by memory would just duplicate too\n-            // much machinery.\n-            // FIXME: We ignore alignment.\n-            let (ptr, extra) = self.force_allocation(query.place.1)?.to_ptr_extra_aligned();\n-            // Determine the size\n-            // FIXME: Can we reuse size_and_align_of_dst for Places?\n-            let layout = self.layout_of(query.ty)?;\n-            let len = if !layout.is_unsized() {\n-                assert_eq!(extra, PlaceExtra::None, \"Got a fat ptr to a sized type\");\n-                layout.size.bytes()\n-            } else {\n-                // The only unsized typ we concider \"owning\" is TyStr.\n-                assert_eq!(\n-                    query.ty.sty,\n-                    TyStr,\n-                    \"Found a surprising unsized owning type\"\n-                );\n-                // The extra must be the length, in bytes.\n-                match extra {\n-                    PlaceExtra::Length(len) => len,\n-                    _ => bug!(\"TyStr must have a length as extra\"),\n-                }\n-            };\n-            // Handle locking\n-            if len > 0 {\n-                let ptr = ptr.to_ptr()?;\n-                match query.mutbl {\n-                    MutImmutable => {\n-                        if mode.acquiring() {\n-                            self.memory.acquire_lock(\n-                                ptr,\n-                                len,\n-                                query.re,\n-                                AccessKind::Read,\n-                            )?;\n-                        }\n-                    }\n-                    // No releasing of read locks, ever.\n-                    MutMutable => {\n-                        match mode {\n-                            ValidationMode::Acquire => {\n-                                self.memory.acquire_lock(\n-                                    ptr,\n-                                    len,\n-                                    query.re,\n-                                    AccessKind::Write,\n-                                )?\n-                            }\n-                            ValidationMode::Recover(ending_ce) => {\n-                                self.memory.recover_write_lock(\n-                                    ptr,\n-                                    len,\n-                                    &query.place.0,\n-                                    query.re,\n-                                    ending_ce,\n-                                )?\n-                            }\n-                            ValidationMode::ReleaseUntil(suspended_ce) => {\n-                                self.memory.suspend_write_lock(\n-                                    ptr,\n-                                    len,\n-                                    &query.place.0,\n-                                    suspended_ce,\n-                                )?\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        let res = do catch {\n-            match query.ty.sty {\n-                TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n-                    if mode.acquiring() {\n-                        // Make sure we can read this.\n-                        let val = self.read_place(query.place.1)?;\n-                        self.follow_by_ref_value(val, query.ty)?;\n-                        // FIXME: It would be great to rule out Undef here, but that doesn't actually work.\n-                        // Passing around undef data is a thing that e.g. Vec::extend_with does.\n-                    }\n-                    Ok(())\n-                }\n-                TyBool | TyFloat(_) | TyChar => {\n-                    if mode.acquiring() {\n-                        let val = self.read_place(query.place.1)?;\n-                        let val = self.value_to_primval(ValTy { value: val, ty: query.ty })?;\n-                        val.to_bytes()?;\n-                        // TODO: Check if these are valid bool/float/codepoint/UTF-8\n-                    }\n-                    Ok(())\n-                }\n-                TyNever => err!(ValidationFailure(format!(\"The empty type is never valid.\"))),\n-                TyRef(region,\n-                    ty::TypeAndMut {\n-                        ty: pointee_ty,\n-                        mutbl,\n-                    }) => {\n-                    let val = self.read_place(query.place.1)?;\n-                    // Sharing restricts our context\n-                    if mutbl == MutImmutable {\n-                        query.mutbl = MutImmutable;\n-                    }\n-                    // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n-                    // we record the region of this borrow to the context.\n-                    if query.re == None {\n-                        match *region {\n-                            ReScope(scope) => query.re = Some(scope),\n-                            // It is possible for us to encounter erased lifetimes here because the lifetimes in\n-                            // this functions' Subst will be erased.\n-                            _ => {}\n-                        }\n-                    }\n-                    self.validate_ptr(val, query.place.0, pointee_ty, query.re, query.mutbl, mode)\n-                }\n-                TyAdt(adt, _) if adt.is_box() => {\n-                    let val = self.read_place(query.place.1)?;\n-                    self.validate_ptr(val, query.place.0, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n-                }\n-                TyFnPtr(_sig) => {\n-                    let ptr = self.read_place(query.place.1)?;\n-                    let ptr = self.into_ptr(ptr)?.to_ptr()?;\n-                    self.memory.get_fn(ptr)?;\n-                    // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n-                    Ok(())\n-                }\n-                TyFnDef(..) => {\n-                    // This is a zero-sized type with all relevant data sitting in the type.\n-                    // There is nothing to validate.\n-                    Ok(())\n-                }\n-\n-                // Compound types\n-                TyStr => {\n-                    // TODO: Validate strings\n-                    Ok(())\n-                }\n-                TySlice(elem_ty) => {\n-                    let len = match query.place.1 {\n-                        Place::Ptr { extra: PlaceExtra::Length(len), .. } => len,\n-                        _ => {\n-                            bug!(\n-                                \"acquire_valid of a TySlice given non-slice place: {:?}\",\n-                                query.place\n-                            )\n-                        }\n-                    };\n-                    for i in 0..len {\n-                        let inner_place = self.place_index(query.place.1, query.ty, i)?;\n-                        self.validate(\n-                            ValidationQuery {\n-                                place: (query.place.0.clone().index(i), inner_place),\n-                                ty: elem_ty,\n-                                ..query\n-                            },\n-                            mode,\n-                        )?;\n-                    }\n-                    Ok(())\n-                }\n-                TyArray(elem_ty, len) => {\n-                    let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n-                    for i in 0..len {\n-                        let inner_place = self.place_index(query.place.1, query.ty, i as u64)?;\n-                        self.validate(\n-                            ValidationQuery {\n-                                place: (query.place.0.clone().index(i as u64), inner_place),\n-                                ty: elem_ty,\n-                                ..query\n-                            },\n-                            mode,\n-                        )?;\n-                    }\n-                    Ok(())\n-                }\n-                TyDynamic(_data, _region) => {\n-                    // Check that this is a valid vtable\n-                    let vtable = match query.place.1 {\n-                        Place::Ptr { extra: PlaceExtra::Vtable(vtable), .. } => vtable,\n-                        _ => {\n-                            bug!(\n-                                \"acquire_valid of a TyDynamic given non-trait-object place: {:?}\",\n-                                query.place\n-                            )\n-                        }\n-                    };\n-                    self.read_size_and_align_from_vtable(vtable)?;\n-                    // TODO: Check that the vtable contains all the function pointers we expect it to have.\n-                    // Trait objects cannot have any operations performed\n-                    // on them directly.  We cannot, in general, even acquire any locks as the trait object *could*\n-                    // contain an UnsafeCell.  If we call functions to get access to data, we will validate\n-                    // their return values.  So, it doesn't seem like there's anything else to do.\n-                    Ok(())\n-                }\n-                TyAdt(adt, _) => {\n-                    if Some(adt.did) == self.tcx.lang_items().unsafe_cell_type() &&\n-                        query.mutbl == MutImmutable\n-                    {\n-                        // No locks for shared unsafe cells.  Also no other validation, the only field is private anyway.\n-                        return Ok(());\n-                    }\n-\n-                    match adt.adt_kind() {\n-                        AdtKind::Enum => {\n-                            let discr = self.read_discriminant_value(query.place.1, query.ty)?;\n-\n-                            // Get variant index for discriminant\n-                            let variant_idx = adt.discriminants(self.tcx).position(|variant_discr| {\n-                                variant_discr.to_u128_unchecked() == discr\n-                            });\n-                            let variant_idx = match variant_idx {\n-                                Some(val) => val,\n-                                None => return err!(InvalidDiscriminant),\n-                            };\n-                            let variant = &adt.variants[variant_idx];\n-\n-                            if variant.fields.len() > 0 {\n-                                // Downcast to this variant, if needed\n-                                let place = if adt.is_enum() {\n-                                    (\n-                                        query.place.0.downcast(adt, variant_idx),\n-                                        self.eval_place_projection(\n-                                            query.place.1,\n-                                            query.ty,\n-                                            &mir::ProjectionElem::Downcast(adt, variant_idx),\n-                                        )?,\n-                                    )\n-                                } else {\n-                                    query.place\n-                                };\n-\n-                                // Recursively validate the fields\n-                                self.validate_fields(\n-                                    ValidationQuery { place, ..query },\n-                                    mode,\n-                                )\n-                            } else {\n-                                // No fields, nothing left to check.  Downcasting may fail, e.g. in case of a CEnum.\n-                                Ok(())\n-                            }\n-                        }\n-                        AdtKind::Struct => {\n-                            self.validate_fields(query, mode)\n-                        }\n-                        AdtKind::Union => {\n-                            // No guarantees are provided for union types.\n-                            // TODO: Make sure that all access to union fields is unsafe; otherwise, we may have some checking to do (but what exactly?)\n-                            Ok(())\n-                        }\n-                    }\n-                }\n-                TyTuple(..) |\n-                TyClosure(..) => {\n-                    // TODO: Check if the signature matches for `TyClosure`\n-                    // (should be the same check as what terminator/mod.rs already does on call?).\n-                    // Is there other things we can/should check?  Like vtable pointers?\n-                    self.validate_fields(query, mode)\n-                }\n-                // FIXME: generators aren't validated right now\n-                TyGenerator(..) => Ok(()),\n-                _ => bug!(\"We already established that this is a type we support. ({})\", query.ty),\n-            }\n-        };\n-        match res {\n-            // ReleaseUntil(None) of an uninitalized variable is a NOP.  This is needed because\n-            // we have to release the return value of a function; due to destination-passing-style\n-            // the callee may directly write there.\n-            // TODO: Ideally we would know whether the destination is already initialized, and only\n-            // release if it is.  But of course that can't even always be statically determined.\n-            Err(EvalError { kind: EvalErrorKind::ReadUndefBytes, .. })\n-                if mode == ValidationMode::ReleaseUntil(None) => {\n-                return Ok(());\n-            }\n-            res => res,\n-        }\n-    }\n-}"}, {"sha": "e7dd94f75e5b4774a7730566daab1f6692fc0e57", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba46dc378bbc3101a657a095d66a9c62a80a423/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=1ba46dc378bbc3101a657a095d66a9c62a80a423", "patch": "@@ -52,10 +52,7 @@ extern crate rustc_const_math;\n extern crate rustc_const_eval;\n extern crate core; // for NonZero\n extern crate log_settings;\n-#[macro_use]\n-extern crate lazy_static;\n extern crate rustc_apfloat;\n-extern crate regex;\n extern crate byteorder;\n \n mod diagnostics;\n@@ -67,7 +64,7 @@ mod hair;\n mod shim;\n pub mod transform;\n pub mod util;\n-mod interpret;\n+pub mod interpret;\n \n use rustc::ty::maps::Providers;\n "}, {"sha": "bde093fa140cbf95023482a94b92b0b16af4b521", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=1ba46dc378bbc3101a657a095d66a9c62a80a423", "patch": "@@ -1 +1 @@\n-Subproject commit eccf680b5d191bb39ef2fc5ae51bf3909c312bbe\n+Subproject commit bde093fa140cbf95023482a94b92b0b16af4b521"}]}