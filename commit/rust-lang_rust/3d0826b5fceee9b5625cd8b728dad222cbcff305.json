{"sha": "3d0826b5fceee9b5625cd8b728dad222cbcff305", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMDgyNmI1ZmNlZWU5YjU2MjVjZDhiNzI4ZGFkMjIyY2JjZmYzMDU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-25T22:39:59Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-25T22:39:59Z"}, "message": "rt: Remove lock_free_queue. Unused. Issue #2701", "tree": {"sha": "997cc5adcf3b1253f1b88c2304f55544f7e7cde9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/997cc5adcf3b1253f1b88c2304f55544f7e7cde9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d0826b5fceee9b5625cd8b728dad222cbcff305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d0826b5fceee9b5625cd8b728dad222cbcff305", "html_url": "https://github.com/rust-lang/rust/commit/3d0826b5fceee9b5625cd8b728dad222cbcff305", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d0826b5fceee9b5625cd8b728dad222cbcff305/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "216105fc55b723065a2a912678ab7b5e7af34671", "url": "https://api.github.com/repos/rust-lang/rust/commits/216105fc55b723065a2a912678ab7b5e7af34671", "html_url": "https://github.com/rust-lang/rust/commit/216105fc55b723065a2a912678ab7b5e7af34671"}], "stats": {"total": 266, "additions": 0, "deletions": 266}, "files": [{"sha": "90595a6ed1164fdb08fa0b24446e093ac54311f9", "filename": "src/rt/sync/lock_free_queue.cpp", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/216105fc55b723065a2a912678ab7b5e7af34671/src%2Frt%2Fsync%2Flock_free_queue.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/216105fc55b723065a2a912678ab7b5e7af34671/src%2Frt%2Fsync%2Flock_free_queue.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_free_queue.cpp?ref=216105fc55b723065a2a912678ab7b5e7af34671", "patch": "@@ -1,54 +0,0 @@\n-/*\n- * Interrupt transparent queue, Schoen et. al, \"On Interrupt-Transparent\n- * Synchronization in an Embedded Object-Oriented Operating System\", 2000.\n- * enqueue() is allowed to interrupt enqueue() and dequeue(), however,\n- * dequeue() is not allowed to interrupt itself.\n- */\n-\n-#include \"../rust_globals.h\"\n-#include \"lock_free_queue.h\"\n-\n-lock_free_queue_node::lock_free_queue_node() : next(NULL) {\n-\n-}\n-\n-lock_free_queue::lock_free_queue() : _tail(this) {\n-\n-}\n-\n-void\n-lock_free_queue::enqueue(lock_free_queue_node *item) {\n-    lock.lock();\n-    item->next = (lock_free_queue_node *) NULL;\n-    lock_free_queue_node *last = _tail;\n-    _tail = item;\n-    while (last->next) {\n-        last = last->next;\n-    }\n-    last->next = item;\n-    lock.unlock();\n-}\n-\n-lock_free_queue_node *\n-lock_free_queue::dequeue() {\n-    lock.lock();\n-    lock_free_queue_node *item = next;\n-    if (item && !(next = item->next)) {\n-        _tail = (lock_free_queue_node *) this;\n-        if (item->next) {\n-            lock_free_queue_node *lost = item->next;\n-            lock_free_queue_node *help;\n-            do {\n-                help = lost->next;\n-                enqueue(lost);\n-            } while ((lost = help) != (lock_free_queue_node *) NULL);\n-        }\n-    }\n-    lock.unlock();\n-    return item;\n-}\n-\n-bool\n-lock_free_queue::is_empty() {\n-    return next == NULL;\n-}"}, {"sha": "ed11b1aa321b304b4683ecf76f7a93f1fbb0e911", "filename": "src/rt/sync/lock_free_queue.h", "status": "removed", "additions": 0, "deletions": 212, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/216105fc55b723065a2a912678ab7b5e7af34671/src%2Frt%2Fsync%2Flock_free_queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/216105fc55b723065a2a912678ab7b5e7af34671/src%2Frt%2Fsync%2Flock_free_queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_free_queue.h?ref=216105fc55b723065a2a912678ab7b5e7af34671", "patch": "@@ -1,212 +0,0 @@\n-#ifndef LOCK_FREE_QUEUE_H\n-#define LOCK_FREE_QUEUE_H\n-\n-/**\n- * How and why this lock free queue works:\n- *\n- * Adapted from the paper titled \"Simple, Fast, and Practical Non-Blocking\n- * and Blocking Concurrent Queue Algorithms\" by Maged M. Michael,\n- * Michael L. Scott.\n- *\n- * Safety Properties:\n- *\n- * 1. The linked list is always connected.\n- * 2. Nodes are only inserted after the last node in the linked list.\n- * 3. Nodes are only deleted from the beginning of the linked list.\n- * 4. Head always points to the first node in the linked list.\n- * 5. Tail always points to a node in the linked list.\n- *\n- *\n- * 1. The linked list is always connected because the next pointer is not set\n- *    to null before the node is freed, and no node is freed until deleted\n- *    from the linked list.\n- *\n- * 2. Nodes are only inserted at the end of the linked list because they are\n- *    linked through the tail pointer which always points to a node in the\n- *    linked list (5) and an inserted node is only linked to a node that has\n- *    a null next pointer, and the only such node is the last one (1).\n- *\n- * 3. Nodes are deleted from the beginning of the list because they are\n- *    deleted only when they are pointed to by head which always points to the\n- *    first node (4).\n- *\n- * 4. Head always points to the first node in the list because it only changes\n- *    its value to the next node atomically. The new value of head cannot be\n- *    null because if there is only one node in the list the dequeue operation\n- *    returns without deleting any nodes.\n- *\n- * 5. Tail always points to a node in the linked list because it never lags\n- *    behind head, so it can never point to a deleted node. Also, when tail\n- *    changes its value it always swings to the next node in the list and it\n- *    never tires to change its value if the next pointer is NULL.\n- */\n-\n-#include <assert.h>\n-\n-template <class T>\n-class lock_free_queue {\n-\n-    struct node_t;\n-    struct pointer_t {\n-        node_t *node;\n-        uint32_t count;\n-        pointer_t() : node(NULL), count(0) {\n-        }\n-        pointer_t(node_t *node, uint32_t count) {\n-            this->node = node;\n-            this->count = count;\n-        }\n-        bool equals(pointer_t &other) {\n-            return node == other.node && count == other.count;\n-        }\n-    };\n-\n-    struct node_t {\n-        T value;\n-        pointer_t next;\n-\n-        node_t() {\n-            next.node = NULL;\n-            next.count = 0;\n-        }\n-\n-        node_t(pointer_t next, T value) {\n-            this->next = next;\n-            this->value = value;\n-        }\n-    };\n-\n-    // Always points to the first node in the list.\n-    pointer_t head;\n-\n-    // Always points to a node in the list, (not necessarily the last).\n-    pointer_t tail;\n-\n-    // Compare and swap counted pointers, we can only do this if pointr_t is\n-    // 8 bytes or less since that the maximum size CAS can handle.\n-    bool compare_and_swap(pointer_t *address,\n-        pointer_t *oldValue,\n-        pointer_t newValue) {\n-\n-        // FIXME (#2701) this is requiring us to pass -fno-strict-aliasing\n-        // to GCC (possibly there are other, similar problems)\n-        if (sync::compare_and_swap(\n-                (uint64_t*) address,\n-                *(uint64_t*) oldValue,\n-                *(uint64_t*) &newValue)) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-public:\n-    lock_free_queue() {\n-        // We can only handle 64bit CAS for counted pointers, so this will\n-        // not work with 64bit pointers.\n-        assert (sizeof(pointer_t) == sizeof(uint64_t));\n-\n-        // Allocate a dummy node to be used as the first node in the list.\n-        node_t *node = new node_t();\n-\n-        // Head and tail both start out pointing to the dummy node.\n-        head.node = node;\n-        tail.node = node;\n-    }\n-\n-    virtual ~lock_free_queue() {\n-        // Delete dummy node.\n-        delete head.node;\n-    }\n-\n-    bool is_empty() {\n-        return head.node == tail.node;\n-    }\n-\n-    virtual void enqueue(T value) {\n-\n-        // Create a new node to be inserted in the linked list, and set the\n-        // next node to NULL.\n-        node_t *node = new node_t();\n-        node->value = value;\n-        node->next.node = NULL;\n-        pointer_t tail;\n-\n-        // Keep trying until enqueue is done.\n-        while (true) {\n-            // Read the current tail which may either point to the last node\n-            // or to the second to last node (not sure why second to last,\n-            // and not any other node).\n-            tail = this->tail;\n-\n-            // Reads the next node after the tail which will be the last node\n-            // if null.\n-            pointer_t next;\n-            if (tail.node != NULL) {\n-                next = tail.node->next;\n-            }\n-\n-            // Loop if another thread changed the tail since we last read it.\n-            if (tail.equals(this->tail) == false) {\n-                continue;\n-            }\n-\n-            // If next is not pointing to the last node try to swing tail to\n-            // the last node and loop.\n-            if (next.node != NULL) {\n-                compare_and_swap(&this->tail, &tail,\n-                    pointer_t(next.node, tail.count + 1));\n-                continue;\n-            }\n-\n-            // Try to link node at the end of the linked list.\n-            if (compare_and_swap(&tail.node->next, &next,\n-                    pointer_t(node, next.count + 1))) {\n-                // Enqueueing is done.\n-                break;\n-            }\n-        }\n-\n-        // Enqueue is done, try to swing tail to the inserted node.\n-        compare_and_swap(&this->tail, &tail,\n-            pointer_t(node, tail.count + 1));\n-    }\n-\n-    bool dequeue(T *value) {\n-        pointer_t head;\n-\n-        // Keep trying until dequeue is done.\n-        while(true) {\n-            head = this->head;\n-            pointer_t tail = this->tail;\n-            pointer_t next = head.node->next;\n-\n-            if (head.equals(this->head) == false) {\n-                continue;\n-            }\n-\n-            // If queue is empty, or if tail is falling behind.\n-            if (head.node == tail.node) {\n-                // If queue is empty.\n-                if (next.node == NULL) {\n-                    return false;\n-                }\n-                // Tail is falling behind, advance it.\n-                compare_and_swap(&this->tail,\n-                    &tail,\n-                    pointer_t(next.node, tail.count + 1));\n-            } else {\n-                // Read value before CAS, otherwise another\n-                // dequeue might advance it.\n-                *value = next.node->value;\n-                if (compare_and_swap(&this->head, &head,\n-                    pointer_t(next.node, head.count + 1))) {\n-                    break;\n-                }\n-            }\n-        }\n-        delete head.node;\n-        return true;\n-    }\n-};\n-\n-#endif /* LOCK_FREE_QUEUE_H */"}]}