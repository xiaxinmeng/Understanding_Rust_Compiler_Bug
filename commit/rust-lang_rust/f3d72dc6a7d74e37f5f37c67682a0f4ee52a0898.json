{"sha": "f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzZDcyZGM2YTdkNzRlMzdmNWYzN2M2NzY4MmEwZjRlZTUyYTA4OTg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-30T15:58:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-31T00:36:49Z"}, "message": "rollup merge of #18443 : alexcrichton/deref-vec-and-string", "tree": {"sha": "13a9b4e952602b35e006911f2cb8e949d28da0da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13a9b4e952602b35e006911f2cb8e949d28da0da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898", "html_url": "https://github.com/rust-lang/rust/commit/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7ee04c5c4f18cf56ddbe3f1b1758f3657cd6830", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7ee04c5c4f18cf56ddbe3f1b1758f3657cd6830", "html_url": "https://github.com/rust-lang/rust/commit/d7ee04c5c4f18cf56ddbe3f1b1758f3657cd6830"}, {"sha": "8e9f8f924cda8193ce1416c45cdcfce35fa6b8d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9f8f924cda8193ce1416c45cdcfce35fa6b8d1", "html_url": "https://github.com/rust-lang/rust/commit/8e9f8f924cda8193ce1416c45cdcfce35fa6b8d1"}], "stats": {"total": 539, "additions": 102, "deletions": 437}, "files": [{"sha": "4e5b2ae70a7169c4d4dbb6af16a97e2315457965", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898", "patch": "@@ -1677,40 +1677,6 @@ mod tests {\n         assert_eq!(pos, p.len());\n     }\n \n-    #[test]\n-    fn test_split_char_iterator() {\n-        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-        let split: Vec<&str> = data.split(' ').collect();\n-        assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-        let mut rsplit: Vec<&str> = data.split(' ').rev().collect();\n-        rsplit.reverse();\n-        assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-        let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n-        assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-        let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n-        rsplit.reverse();\n-        assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-        // Unicode\n-        let split: Vec<&str> = data.split('\u00e4').collect();\n-        assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-        let mut rsplit: Vec<&str> = data.split('\u00e4').rev().collect();\n-        rsplit.reverse();\n-        assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-        let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n-        assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-        let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n-        rsplit.reverse();\n-        assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-    }\n-\n     #[test]\n     fn test_splitn_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n@@ -1729,28 +1695,6 @@ mod tests {\n         assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n     }\n \n-    #[test]\n-    fn test_rsplitn_char_iterator() {\n-        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-        let mut split: Vec<&str> = data.rsplitn(3, ' ').collect();\n-        split.reverse();\n-        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-        let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == ' ').collect();\n-        split.reverse();\n-        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n-\n-        // Unicode\n-        let mut split: Vec<&str> = data.rsplitn(3, '\u00e4').collect();\n-        split.reverse();\n-        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-\n-        let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == '\u00e4').collect();\n-        split.reverse();\n-        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n-    }\n-\n     #[test]\n     fn test_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n@@ -1762,19 +1706,6 @@ mod tests {\n         assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n \n-    #[test]\n-    fn test_rev_split_char_iterator_no_trailing() {\n-        let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-\n-        let mut split: Vec<&str> = data.split('\\n').rev().collect();\n-        split.reverse();\n-        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n-\n-        let mut split: Vec<&str> = data.split_terminator('\\n').rev().collect();\n-        split.reverse();\n-        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n-    }\n-\n     #[test]\n     fn test_words() {\n         let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";"}, {"sha": "507cfbf191c4ac604c051c2cc95e7903d3ae20b9", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898", "patch": "@@ -744,6 +744,11 @@ impl ops::Slice<uint, str> for String {\n     }\n }\n \n+#[experimental = \"waiting on Deref stabilization\"]\n+impl ops::Deref<str> for String {\n+    fn deref<'a>(&'a self) -> &'a str { self.as_slice() }\n+}\n+\n /// Wrapper type providing a `&String` reference via `Deref`.\n #[experimental]\n pub struct DerefString<'a> {"}, {"sha": "1d01a91ed1415b352a093c2442e98bad1ac70d8d", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 20, "deletions": 363, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898", "patch": "@@ -28,8 +28,7 @@ use core::raw::Slice as RawSlice;\n use core::uint;\n \n use {Mutable, MutableSeq};\n-use slice::{MutableOrdSlice, MutableSliceAllocating, CloneableVector};\n-use slice::{Items, MutItems};\n+use slice::{CloneableVector};\n \n /// An owned, growable vector.\n ///\n@@ -464,6 +463,16 @@ impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n     }\n }\n \n+#[experimental = \"waiting on Deref stability\"]\n+impl<T> ops::Deref<[T]> for Vec<T> {\n+    fn deref<'a>(&'a self) -> &'a [T] { self.as_slice() }\n+}\n+\n+#[experimental = \"waiting on DerefMut stability\"]\n+impl<T> ops::DerefMut<[T]> for Vec<T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut [T] { self.as_mut_slice() }\n+}\n+\n #[experimental = \"waiting on FromIterator stability\"]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n@@ -717,7 +726,7 @@ impl<T> Vec<T> {\n     #[deprecated = \"use .extend(other.into_iter())\"]\n     #[cfg(stage0)]\n     pub fn push_all_move(&mut self, other: Vec<T>) {\n-            self.extend(other.into_iter());\n+        self.extend(other.into_iter());\n     }\n \n     /// Returns a mutable slice of the elements of `self`.\n@@ -735,7 +744,7 @@ impl<T> Vec<T> {\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n-                data: self.as_mut_ptr() as *const T,\n+                data: self.ptr as *const T,\n                 len: self.len,\n             })\n         }\n@@ -809,124 +818,6 @@ impl<T> Vec<T> {\n         &mut self.as_mut_slice()[index]\n     }\n \n-    /// Returns an iterator over references to the elements of the vector in\n-    /// order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3];\n-    /// for num in vec.iter() {\n-    ///     println!(\"{}\", *num);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn iter<'a>(&'a self) -> Items<'a,T> {\n-        self.as_slice().iter()\n-    }\n-\n-    /// Returns an iterator over mutable references to the elements of the\n-    /// vector in order.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// for num in vec.iter_mut() {\n-    ///     *num = 0;\n-    /// }\n-    /// assert_eq!(vec, vec![0i, 0, 0]);\n-    /// ```\n-    #[inline]\n-    pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a,T> {\n-        self.as_mut_slice().iter_mut()\n-    }\n-\n-    /// Sorts the vector, in place, using `compare` to compare elements.\n-    ///\n-    /// This sort is `O(n log n)` worst-case and stable, but allocates\n-    /// approximately `2 * n`, where `n` is the length of `self`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut v = vec![5i, 4, 1, 3, 2];\n-    /// v.sort_by(|a, b| a.cmp(b));\n-    /// assert_eq!(v, vec![1i, 2, 3, 4, 5]);\n-    ///\n-    /// // reverse sorting\n-    /// v.sort_by(|a, b| b.cmp(a));\n-    /// assert_eq!(v, vec![5i, 4, 3, 2, 1]);\n-    /// ```\n-    #[inline]\n-    pub fn sort_by(&mut self, compare: |&T, &T| -> Ordering) {\n-        self.as_mut_slice().sort_by(compare)\n-    }\n-\n-    /// Returns a slice of self spanning the interval [`start`, `end`).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when the slice (or part of it) is outside the bounds of self, or when\n-    /// `start` > `end`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[0..2] == [1, 2]);\n-    /// ```\n-    #[inline]\n-    pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n-        self[start..end]\n-    }\n-\n-    /// Returns a slice containing all but the first element of the vector.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when the vector is empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec.tail() == [2, 3]);\n-    /// ```\n-    #[inline]\n-    pub fn tail<'a>(&'a self) -> &'a [T] {\n-        self[].tail()\n-    }\n-\n-    /// Returns a reference to the last element of a vector, or `None` if it is\n-    /// empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec.last() == Some(&3));\n-    /// ```\n-    #[inline]\n-    pub fn last<'a>(&'a self) -> Option<&'a T> {\n-        self[].last()\n-    }\n-\n-    /// Returns a mutable reference to the last element of a vector, or `None`\n-    /// if it is empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// *vec.last_mut().unwrap() = 4;\n-    /// assert_eq!(vec, vec![1i, 2, 4]);\n-    /// ```\n-    #[inline]\n-    pub fn last_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        self.as_mut_slice().last_mut()\n-    }\n-\n     /// Removes an element from anywhere in the vector and return it, replacing\n     /// it with the last element. This does not preserve ordering, but is O(1).\n     ///\n@@ -1035,215 +926,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Returns a mutable slice of `self` between `start` and `end`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when `start` or `end` point outside the bounds of `self`, or when\n-    /// `start` > `end`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[mut 0..2] == [1, 2]);\n-    /// ```\n-    #[inline]\n-    pub fn slice_mut<'a>(&'a mut self, start: uint, end: uint)\n-                         -> &'a mut [T] {\n-        self[mut start..end]\n-    }\n-\n-    /// Returns a mutable slice of `self` from `start` to the end of the `Vec`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when `start` points outside the bounds of self.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[mut 2..] == [3, 4]);\n-    /// ```\n-    #[inline]\n-    pub fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        self[mut start..]\n-    }\n-\n-    /// Returns a mutable slice of `self` from the start of the `Vec` to `end`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when `end` points outside the bounds of self.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[mut ..2] == [1, 2]);\n-    /// ```\n-    #[inline]\n-    pub fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        self[mut ..end]\n-    }\n-\n-    /// Returns a pair of mutable slices that divides the `Vec` at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if `mid > len`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4, 5, 6];\n-    ///\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///    let (left, right) = vec.split_at_mut(0);\n-    ///    assert!(left == &mut []);\n-    ///    assert!(right == &mut [1, 2, 3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = vec.split_at_mut(2);\n-    ///     assert!(left == &mut [1, 2]);\n-    ///     assert!(right == &mut [3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = vec.split_at_mut(6);\n-    ///     assert!(left == &mut [1, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == &mut []);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        self[mut].split_at_mut(mid)\n-    }\n-\n-    /// Reverses the order of elements in a vector, in place.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut v = vec![1i, 2, 3];\n-    /// v.reverse();\n-    /// assert_eq!(v, vec![3i, 2, 1]);\n-    /// ```\n-    #[inline]\n-    pub fn reverse(&mut self) {\n-        self[mut].reverse()\n-    }\n-\n-    /// Returns a slice of `self` from `start` to the end of the vec.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when `start` points outside the bounds of self.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec[1..] == [2, 3]);\n-    /// ```\n-    #[inline]\n-    pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n-        self[start..]\n-    }\n-\n-    /// Returns a slice of self from the start of the vec to `end`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when `end` points outside the bounds of self.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[..2] == [1, 2]);\n-    /// ```\n-    #[inline]\n-    pub fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n-        self[..end]\n-    }\n-\n-    /// Returns a slice containing all but the last element of the vector.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the vector is empty\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec.init() == [1, 2]);\n-    /// ```\n-    #[inline]\n-    pub fn init<'a>(&'a self) -> &'a [T] {\n-        self[0..self.len() - 1]\n-    }\n-\n-\n-    /// Returns an unsafe pointer to the vector's buffer.\n-    ///\n-    /// The caller must ensure that the vector outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the vector may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let v = vec![1i, 2, 3];\n-    /// let p = v.as_ptr();\n-    /// unsafe {\n-    ///     // Examine each element manually\n-    ///     assert_eq!(*p, 1i);\n-    ///     assert_eq!(*p.offset(1), 2i);\n-    ///     assert_eq!(*p.offset(2), 3i);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn as_ptr(&self) -> *const T {\n-        self.ptr as *const T\n-    }\n-\n-    /// Returns a mutable unsafe pointer to the vector's buffer.\n-    ///\n-    /// The caller must ensure that the vector outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the vector may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::ptr;\n-    ///\n-    /// let mut v = vec![1i, 2, 3];\n-    /// let p = v.as_mut_ptr();\n-    /// unsafe {\n-    ///     ptr::write(p, 9i);\n-    ///     ptr::write(p.offset(2), 5i);\n-    /// }\n-    /// assert_eq!(v, vec![9i, 2, 5]);\n-    /// ```\n-    #[inline]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        self.ptr\n-    }\n-\n     /// Retains only the elements specified by the predicate.\n     ///\n     /// In other words, remove all elements `e` such that `f(&e)` returns false.\n@@ -1297,24 +979,6 @@ impl<T> Vec<T> {\n     }\n }\n \n-impl<T:Ord> Vec<T> {\n-    /// Sorts the vector in place.\n-    ///\n-    /// This sort is `O(n log n)` worst-case and stable, but allocates\n-    /// approximately `2 * n`, where `n` is the length of `self`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut vec = vec![3i, 1, 2];\n-    /// vec.sort();\n-    /// assert_eq!(vec, vec![1, 2, 3]);\n-    /// ```\n-    pub fn sort(&mut self) {\n-        self.as_mut_slice().sort()\n-    }\n-}\n-\n #[experimental = \"waiting on Mutable stability\"]\n impl<T> Mutable for Vec<T> {\n     #[inline]\n@@ -1325,19 +989,6 @@ impl<T> Mutable for Vec<T> {\n }\n \n impl<T: PartialEq> Vec<T> {\n-    /// Returns true if a vector contains an element equal to the given value.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec.contains(&1));\n-    /// ```\n-    #[inline]\n-    pub fn contains(&self, x: &T) -> bool {\n-        self.as_slice().contains(x)\n-    }\n-\n     /// Removes consecutive repeated elements in the vector.\n     ///\n     /// If the vector is sorted, this removes all duplicates.\n@@ -1449,7 +1100,12 @@ impl<T> AsSlice<T> for Vec<T> {\n     #[inline]\n     #[stable]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n-        unsafe { mem::transmute(RawSlice { data: self.as_ptr(), len: self.len }) }\n+        unsafe {\n+            mem::transmute(RawSlice {\n+                data: self.ptr as *const T,\n+                len: self.len\n+            })\n+        }\n     }\n }\n \n@@ -1697,6 +1353,7 @@ pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n pub mod raw {\n     use super::Vec;\n     use core::ptr;\n+    use core::slice::MutableSlice;\n \n     /// Constructs a vector from an unsafe pointer to a buffer.\n     ///"}, {"sha": "d3f77c47c44bcb7845ea26ac56e1751d724cdf80", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898", "patch": "@@ -38,3 +38,72 @@ fn test_strslice_contains() {\n     let x = \"There are moments, Jeeves, when one asks oneself, 'Do trousers matter?'\";\n     check_contains_all_substrings(x);\n }\n+\n+#[test]\n+fn test_rsplitn_char_iterator() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let mut split: Vec<&str> = data.rsplitn(3, ' ').collect();\n+    split.reverse();\n+    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == ' ').collect();\n+    split.reverse();\n+    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    // Unicode\n+    let mut split: Vec<&str> = data.rsplitn(3, '\u00e4').collect();\n+    split.reverse();\n+    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == '\u00e4').collect();\n+    split.reverse();\n+    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+}\n+\n+#[test]\n+fn test_split_char_iterator() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.split(' ').collect();\n+    assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split(' ').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n+    assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+\n+    // Unicode\n+    let split: Vec<&str> = data.split('\u00e4').collect();\n+    assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split('\u00e4').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n+    assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+\n+    let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n+    rsplit.reverse();\n+    assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+}\n+\n+#[test]\n+fn test_rev_split_char_iterator_no_trailing() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let mut split: Vec<&str> = data.split('\\n').rev().collect();\n+    split.reverse();\n+    assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+\n+    let mut split: Vec<&str> = data.split_terminator('\\n').rev().collect();\n+    split.reverse();\n+    assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+}"}, {"sha": "a4d794d1f99fb0a0ce9a6c2f99b37feee4ee26a5", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898", "patch": "@@ -58,7 +58,7 @@ impl<'a,T> IntoMaybeOwnedVector<'a,T> for &'a [T] {\n impl<'a,T> MaybeOwnedVector<'a,T> {\n     pub fn iter(&'a self) -> slice::Items<'a,T> {\n         match self {\n-            &Growable(ref v) => v.iter(),\n+            &Growable(ref v) => v.as_slice().iter(),\n             &Borrowed(ref v) => v.iter(),\n         }\n     }"}, {"sha": "91f3f38f89dcbb1a3722be827826da3b56bb1cfe", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898", "patch": "@@ -15,7 +15,7 @@ use comm::{Sender, Receiver};\n use io;\n use option::{None, Some};\n use result::{Ok, Err};\n-use slice::{bytes, CloneableVector};\n+use slice::{bytes, CloneableVector, ImmutableSlice};\n use super::{Buffer, Reader, Writer, IoResult};\n use vec::Vec;\n "}, {"sha": "eaf47bb004cf634bd15e52de278127930d22ecb5", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898", "patch": "@@ -125,6 +125,7 @@ fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n // permission without help of apk\n #[cfg(all(test, not(target_os = \"android\")))]\n mod test {\n+    use prelude::*;\n     use super::*;\n     use io::net::ip::*;\n "}, {"sha": "ba39f3e0d176d4fd22e099ad10de744c6ac18053", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=f3d72dc6a7d74e37f5f37c67682a0f4ee52a0898", "patch": "@@ -29,14 +29,16 @@ impl<'a> Drop for r<'a> {\n fn f<T>(_i: Vec<T> , _j: Vec<T> ) {\n }\n \n+fn clone<T: Clone>(t: &T) -> T { t.clone() }\n+\n fn main() {\n     let i1 = &Cell::new(0);\n     let i2 = &Cell::new(1);\n     let r1 = vec!(box r { i: i1 });\n     let r2 = vec!(box r { i: i2 });\n-    f(r1.clone(), r2.clone());\n-    //~^ ERROR does not implement any method in scope named `clone`\n-    //~^^ ERROR does not implement any method in scope named `clone`\n+    f(clone(&r1), clone(&r2));\n+    //~^ ERROR the trait `core::clone::Clone` is not implemented for the type\n+    //~^^ ERROR the trait `core::clone::Clone` is not implemented for the type\n     println!(\"{}\", (r2, i1.get()));\n     println!(\"{}\", (r1, i2.get()));\n }"}]}