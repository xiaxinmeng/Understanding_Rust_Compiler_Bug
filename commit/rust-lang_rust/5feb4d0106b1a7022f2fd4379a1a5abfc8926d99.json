{"sha": "5feb4d0106b1a7022f2fd4379a1a5abfc8926d99", "node_id": "C_kwDOAAsO6NoAKDVmZWI0ZDAxMDZiMWE3MDIyZjJmZDQzNzlhMWE1YWJmYzg5MjZkOTk", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-11-19T02:33:40Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:27Z"}, "message": "Refactor code to keep most drop range analysis in drop_ranges.rs", "tree": {"sha": "60ce8476fecce3b7e15df873d7ea9b6317e06433", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60ce8476fecce3b7e15df873d7ea9b6317e06433"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5feb4d0106b1a7022f2fd4379a1a5abfc8926d99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5feb4d0106b1a7022f2fd4379a1a5abfc8926d99", "html_url": "https://github.com/rust-lang/rust/commit/5feb4d0106b1a7022f2fd4379a1a5abfc8926d99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5feb4d0106b1a7022f2fd4379a1a5abfc8926d99/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "904c2701496143e089e01b3a10ccbe7eaa1bf9e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/904c2701496143e089e01b3a10ccbe7eaa1bf9e5", "html_url": "https://github.com/rust-lang/rust/commit/904c2701496143e089e01b3a10ccbe7eaa1bf9e5"}], "stats": {"total": 565, "additions": 283, "deletions": 282}, "files": [{"sha": "68269f24e9d33d37fcd9469e2ff3270832cddf93", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 8, "deletions": 280, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/5feb4d0106b1a7022f2fd4379a1a5abfc8926d99/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5feb4d0106b1a7022f2fd4379a1a5abfc8926d99/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=5feb4d0106b1a7022f2fd4379a1a5abfc8926d99", "patch": "@@ -3,12 +3,9 @@\n //! is calculated in `rustc_const_eval::transform::generator` and may be a subset of the\n //! types computed here.\n \n-use crate::expr_use_visitor::{self, ExprUseVisitor};\n-\n-use self::drop_ranges::DropRanges;\n-\n+use self::drop_ranges::{DropRangeVisitor, DropRanges, ExprUseDelegate};\n use super::FnCtxt;\n-use hir::{HirIdMap, Node};\n+use crate::expr_use_visitor::ExprUseVisitor;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::pluralize;\n use rustc_hir as hir;\n@@ -17,8 +14,6 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::HirIdSet;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind};\n-use rustc_middle::hir::map::Map;\n-use rustc_middle::hir::place::{Place, PlaceBase};\n use rustc_middle::middle::region::{self, YieldData};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n@@ -194,11 +189,7 @@ pub fn resolve_interior<'a, 'tcx>(\n     let body = fcx.tcx.hir().body(body_id);\n \n     let mut visitor = {\n-        let mut expr_use_visitor = ExprUseDelegate {\n-            hir: fcx.tcx.hir(),\n-            consumed_places: <_>::default(),\n-            borrowed_places: <_>::default(),\n-        };\n+        let mut expr_use_visitor = ExprUseDelegate::new(fcx.tcx.hir());\n \n         // Run ExprUseVisitor to find where values are consumed.\n         ExprUseVisitor::new(\n@@ -211,14 +202,14 @@ pub fn resolve_interior<'a, 'tcx>(\n         .consume_body(body);\n \n         let region_scope_tree = fcx.tcx.region_scope_tree(def_id);\n-\n-        let mut drop_range_visitor = DropRangeVisitor::from(\n+        let mut drop_range_visitor = DropRangeVisitor::from_uses(\n             expr_use_visitor,\n             region_scope_tree.body_expr_count(body.id()).unwrap_or(0),\n         );\n         intravisit::walk_body(&mut drop_range_visitor, body);\n \n-        drop_range_visitor.drop_ranges.propagate_to_fixpoint();\n+        let mut drop_ranges = drop_range_visitor.into_drop_ranges();\n+        drop_ranges.propagate_to_fixpoint();\n \n         InteriorVisitor {\n             fcx,\n@@ -230,7 +221,7 @@ pub fn resolve_interior<'a, 'tcx>(\n             guard_bindings: <_>::default(),\n             guard_bindings_set: <_>::default(),\n             linted_values: <_>::default(),\n-            drop_ranges: drop_range_visitor.drop_ranges,\n+            drop_ranges: drop_ranges,\n         }\n     };\n     intravisit::walk_body(&mut visitor, body);\n@@ -377,7 +368,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                             self.expr_count += 1;\n \n                             // Record the rest of the call expression normally.\n-                            for arg in args.iter() {\n+                            for arg in *args {\n                                 self.visit_expr(arg);\n                             }\n                         }\n@@ -664,266 +655,3 @@ fn check_must_not_suspend_def(\n     }\n     false\n }\n-\n-// The following structs and impls are used for drop range analysis.\n-//\n-// Drop range analysis finds the portions of the tree where a value is guaranteed to be dropped\n-// (i.e. moved, uninitialized, etc.). This is used to exclude the types of those values from the\n-// generator type. See `InteriorVisitor::record` for where the results of this analysis are used.\n-//\n-// There are three phases to this analysis:\n-// 1. Use `ExprUseVisitor` to identify the interesting values that are consumed and borrowed.\n-// 2. Use `DropRangeVisitor` to find where the interesting values are dropped or reinitialized,\n-//    and also build a control flow graph.\n-// 3. Use `DropRanges::propagate_to_fixpoint` to flow the dropped/reinitialized information through\n-//    the CFG and find the exact points where we know a value is definitely dropped.\n-//\n-// The end result is a data structure that maps the post-order index of each node in the HIR tree\n-// to a set of values that are known to be dropped at that location.\n-\n-/// Works with ExprUseVisitor to find interesting values for the drop range analysis.\n-///\n-/// Interesting values are those that are either dropped or borrowed. For dropped values, we also\n-/// record the parent expression, which is the point where the drop actually takes place.\n-struct ExprUseDelegate<'tcx> {\n-    hir: Map<'tcx>,\n-    /// Maps a HirId to a set of HirIds that are dropped by that node.\n-    consumed_places: HirIdMap<HirIdSet>,\n-    borrowed_places: HirIdSet,\n-}\n-\n-impl<'tcx> ExprUseDelegate<'tcx> {\n-    fn mark_consumed(&mut self, consumer: HirId, target: HirId) {\n-        if !self.consumed_places.contains_key(&consumer) {\n-            self.consumed_places.insert(consumer, <_>::default());\n-        }\n-        self.consumed_places.get_mut(&consumer).map(|places| places.insert(target));\n-    }\n-}\n-\n-impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n-    fn consume(\n-        &mut self,\n-        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-    ) {\n-        let parent = match self.hir.find_parent_node(place_with_id.hir_id) {\n-            Some(parent) => parent,\n-            None => place_with_id.hir_id,\n-        };\n-        debug!(\n-            \"consume {:?}; diag_expr_id={:?}, using parent {:?}\",\n-            place_with_id, diag_expr_id, parent\n-        );\n-        self.mark_consumed(parent, place_with_id.hir_id);\n-        place_hir_id(&place_with_id.place).map(|place| self.mark_consumed(parent, place));\n-    }\n-\n-    fn borrow(\n-        &mut self,\n-        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _diag_expr_id: hir::HirId,\n-        _bk: rustc_middle::ty::BorrowKind,\n-    ) {\n-        place_hir_id(&place_with_id.place).map(|place| self.borrowed_places.insert(place));\n-    }\n-\n-    fn mutate(\n-        &mut self,\n-        _assignee_place: &expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _diag_expr_id: hir::HirId,\n-    ) {\n-    }\n-\n-    fn fake_read(\n-        &mut self,\n-        _place: expr_use_visitor::Place<'tcx>,\n-        _cause: rustc_middle::mir::FakeReadCause,\n-        _diag_expr_id: hir::HirId,\n-    ) {\n-    }\n-}\n-\n-/// Gives the hir_id associated with a place if one exists. This is the hir_id that we want to\n-/// track for a value in the drop range analysis.\n-fn place_hir_id(place: &Place<'_>) -> Option<HirId> {\n-    match place.base {\n-        PlaceBase::Rvalue | PlaceBase::StaticItem => None,\n-        PlaceBase::Local(hir_id)\n-        | PlaceBase::Upvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id }, .. }) => Some(hir_id),\n-    }\n-}\n-\n-/// This struct is used to gather the information for `DropRanges` to determine the regions of the\n-/// HIR tree for which a value is dropped.\n-///\n-/// We are interested in points where a variables is dropped or initialized, and the control flow\n-/// of the code. We identify locations in code by their post-order traversal index, so it is\n-/// important for this traversal to match that in `RegionResolutionVisitor` and `InteriorVisitor`.\n-struct DropRangeVisitor<'tcx> {\n-    hir: Map<'tcx>,\n-    /// Maps a HirId to a set of HirIds that are dropped by that node.\n-    consumed_places: HirIdMap<HirIdSet>,\n-    borrowed_places: HirIdSet,\n-    drop_ranges: DropRanges,\n-    expr_count: usize,\n-}\n-\n-impl<'tcx> DropRangeVisitor<'tcx> {\n-    fn from(uses: ExprUseDelegate<'tcx>, num_exprs: usize) -> Self {\n-        debug!(\"consumed_places: {:?}\", uses.consumed_places);\n-        let drop_ranges = DropRanges::new(\n-            uses.consumed_places.iter().flat_map(|(_, places)| places.iter().copied()),\n-            &uses.hir,\n-            num_exprs,\n-        );\n-        Self {\n-            hir: uses.hir,\n-            consumed_places: uses.consumed_places,\n-            borrowed_places: uses.borrowed_places,\n-            drop_ranges,\n-            expr_count: 0,\n-        }\n-    }\n-\n-    fn record_drop(&mut self, hir_id: HirId) {\n-        if self.borrowed_places.contains(&hir_id) {\n-            debug!(\"not marking {:?} as dropped because it is borrowed at some point\", hir_id);\n-        } else {\n-            debug!(\"marking {:?} as dropped at {}\", hir_id, self.expr_count);\n-            let count = self.expr_count;\n-            self.drop_ranges.drop_at(hir_id, count);\n-        }\n-    }\n-\n-    /// ExprUseVisitor's consume callback doesn't go deep enough for our purposes in all\n-    /// expressions. This method consumes a little deeper into the expression when needed.\n-    fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n-        debug!(\"consuming expr {:?}, count={}\", expr.hir_id, self.expr_count);\n-        let places = self\n-            .consumed_places\n-            .get(&expr.hir_id)\n-            .map_or(vec![], |places| places.iter().cloned().collect());\n-        for place in places {\n-            for_each_consumable(place, self.hir.find(place), |hir_id| self.record_drop(hir_id));\n-        }\n-    }\n-\n-    fn reinit_expr(&mut self, expr: &hir::Expr<'_>) {\n-        if let ExprKind::Path(hir::QPath::Resolved(\n-            _,\n-            hir::Path { res: hir::def::Res::Local(hir_id), .. },\n-        )) = expr.kind\n-        {\n-            let location = self.expr_count;\n-            debug!(\"reinitializing {:?} at {}\", hir_id, location);\n-            self.drop_ranges.reinit_at(*hir_id, location);\n-        } else {\n-            debug!(\"reinitializing {:?} is not supported\", expr);\n-        }\n-    }\n-}\n-\n-/// Applies `f` to consumable portion of a HIR node.\n-///\n-/// The `node` parameter should be the result of calling `Map::find(place)`.\n-fn for_each_consumable(place: HirId, node: Option<Node<'_>>, mut f: impl FnMut(HirId)) {\n-    f(place);\n-    if let Some(Node::Expr(expr)) = node {\n-        match expr.kind {\n-            hir::ExprKind::Path(hir::QPath::Resolved(\n-                _,\n-                hir::Path { res: hir::def::Res::Local(hir_id), .. },\n-            )) => {\n-                f(*hir_id);\n-            }\n-            _ => (),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n-    type Map = intravisit::ErasedMap<'tcx>;\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        let mut reinit = None;\n-        match expr.kind {\n-            ExprKind::If(test, if_true, if_false) => {\n-                self.visit_expr(test);\n-\n-                let fork = self.expr_count;\n-\n-                self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n-                self.visit_expr(if_true);\n-                let true_end = self.expr_count;\n-\n-                self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n-                if let Some(if_false) = if_false {\n-                    self.visit_expr(if_false);\n-                }\n-\n-                self.drop_ranges.add_control_edge(true_end, self.expr_count + 1);\n-            }\n-            ExprKind::Assign(lhs, rhs, _) => {\n-                self.visit_expr(lhs);\n-                self.visit_expr(rhs);\n-\n-                reinit = Some(lhs);\n-            }\n-            ExprKind::Loop(body, ..) => {\n-                let loop_begin = self.expr_count + 1;\n-                self.visit_block(body);\n-                self.drop_ranges.add_control_edge(self.expr_count, loop_begin);\n-            }\n-            ExprKind::Match(scrutinee, arms, ..) => {\n-                self.visit_expr(scrutinee);\n-\n-                let fork = self.expr_count;\n-                let arm_end_ids = arms\n-                    .iter()\n-                    .map(|Arm { pat, body, guard, .. }| {\n-                        self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n-                        self.visit_pat(pat);\n-                        match guard {\n-                            Some(Guard::If(expr)) => self.visit_expr(expr),\n-                            Some(Guard::IfLet(pat, expr)) => {\n-                                self.visit_pat(pat);\n-                                self.visit_expr(expr);\n-                            }\n-                            None => (),\n-                        }\n-                        self.visit_expr(body);\n-                        self.expr_count\n-                    })\n-                    .collect::<Vec<_>>();\n-                arm_end_ids.into_iter().for_each(|arm_end| {\n-                    self.drop_ranges.add_control_edge(arm_end, self.expr_count + 1)\n-                });\n-            }\n-            ExprKind::Break(hir::Destination { target_id: Ok(target), .. }, ..)\n-            | ExprKind::Continue(hir::Destination { target_id: Ok(target), .. }, ..) => {\n-                self.drop_ranges.add_control_edge_hir_id(self.expr_count, target);\n-            }\n-\n-            _ => intravisit::walk_expr(self, expr),\n-        }\n-\n-        self.expr_count += 1;\n-        self.drop_ranges.add_node_mapping(expr.hir_id, self.expr_count);\n-        self.consume_expr(expr);\n-        if let Some(expr) = reinit {\n-            self.reinit_expr(expr);\n-        }\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n-        intravisit::walk_pat(self, pat);\n-\n-        // Increment expr_count here to match what InteriorVisitor expects.\n-        self.expr_count += 1;\n-    }\n-}"}, {"sha": "708ce8247800079359f74804cbb5ecaf3754dd3f", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "modified", "additions": 275, "deletions": 2, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/5feb4d0106b1a7022f2fd4379a1a5abfc8926d99/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5feb4d0106b1a7022f2fd4379a1a5abfc8926d99/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=5feb4d0106b1a7022f2fd4379a1a5abfc8926d99", "patch": "@@ -1,14 +1,287 @@\n+//! Drop range analysis finds the portions of the tree where a value is guaranteed to be dropped\n+//! (i.e. moved, uninitialized, etc.). This is used to exclude the types of those values from the\n+//! generator type. See `InteriorVisitor::record` for where the results of this analysis are used.\n+//!\n+//! There are three phases to this analysis:\n+//! 1. Use `ExprUseVisitor` to identify the interesting values that are consumed and borrowed.\n+//! 2. Use `DropRangeVisitor` to find where the interesting values are dropped or reinitialized,\n+//!    and also build a control flow graph.\n+//! 3. Use `DropRanges::propagate_to_fixpoint` to flow the dropped/reinitialized information through\n+//!    the CFG and find the exact points where we know a value is definitely dropped.\n+//!\n+//! The end result is a data structure that maps the post-order index of each node in the HIR tree\n+//! to a set of values that are known to be dropped at that location.\n+\n use std::collections::BTreeMap;\n use std::fmt::Debug;\n use std::mem::swap;\n \n+use hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use hir::{Expr, ExprKind, Guard, HirId, HirIdMap, HirIdSet, Node};\n use rustc_graphviz as dot;\n-use rustc_hir::{HirId, HirIdMap};\n+use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::hir::map::Map;\n+use rustc_middle::hir::place::{Place, PlaceBase};\n+use rustc_middle::ty;\n+\n+use crate::expr_use_visitor;\n+\n+/// Works with ExprUseVisitor to find interesting values for the drop range analysis.\n+///\n+/// Interesting values are those that are either dropped or borrowed. For dropped values, we also\n+/// record the parent expression, which is the point where the drop actually takes place.\n+pub struct ExprUseDelegate<'tcx> {\n+    hir: Map<'tcx>,\n+    /// Maps a HirId to a set of HirIds that are dropped by that node.\n+    consumed_places: HirIdMap<HirIdSet>,\n+    borrowed_places: HirIdSet,\n+}\n+\n+impl<'tcx> ExprUseDelegate<'tcx> {\n+    pub fn new(hir: Map<'tcx>) -> Self {\n+        Self { hir, consumed_places: <_>::default(), borrowed_places: <_>::default() }\n+    }\n+\n+    fn mark_consumed(&mut self, consumer: HirId, target: HirId) {\n+        if !self.consumed_places.contains_key(&consumer) {\n+            self.consumed_places.insert(consumer, <_>::default());\n+        }\n+        self.consumed_places.get_mut(&consumer).map(|places| places.insert(target));\n+    }\n+}\n+\n+impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n+    fn consume(\n+        &mut self,\n+        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        diag_expr_id: hir::HirId,\n+    ) {\n+        let parent = match self.hir.find_parent_node(place_with_id.hir_id) {\n+            Some(parent) => parent,\n+            None => place_with_id.hir_id,\n+        };\n+        debug!(\n+            \"consume {:?}; diag_expr_id={:?}, using parent {:?}\",\n+            place_with_id, diag_expr_id, parent\n+        );\n+        self.mark_consumed(parent, place_with_id.hir_id);\n+        place_hir_id(&place_with_id.place).map(|place| self.mark_consumed(parent, place));\n+    }\n+\n+    fn borrow(\n+        &mut self,\n+        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _diag_expr_id: hir::HirId,\n+        _bk: rustc_middle::ty::BorrowKind,\n+    ) {\n+        place_hir_id(&place_with_id.place).map(|place| self.borrowed_places.insert(place));\n+    }\n+\n+    fn mutate(\n+        &mut self,\n+        _assignee_place: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _diag_expr_id: hir::HirId,\n+    ) {\n+    }\n+\n+    fn fake_read(\n+        &mut self,\n+        _place: expr_use_visitor::Place<'tcx>,\n+        _cause: rustc_middle::mir::FakeReadCause,\n+        _diag_expr_id: hir::HirId,\n+    ) {\n+    }\n+}\n+\n+/// Gives the hir_id associated with a place if one exists. This is the hir_id that we want to\n+/// track for a value in the drop range analysis.\n+fn place_hir_id(place: &Place<'_>) -> Option<HirId> {\n+    match place.base {\n+        PlaceBase::Rvalue | PlaceBase::StaticItem => None,\n+        PlaceBase::Local(hir_id)\n+        | PlaceBase::Upvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id }, .. }) => Some(hir_id),\n+    }\n+}\n+\n+/// This struct is used to gather the information for `DropRanges` to determine the regions of the\n+/// HIR tree for which a value is dropped.\n+///\n+/// We are interested in points where a variables is dropped or initialized, and the control flow\n+/// of the code. We identify locations in code by their post-order traversal index, so it is\n+/// important for this traversal to match that in `RegionResolutionVisitor` and `InteriorVisitor`.\n+pub struct DropRangeVisitor<'tcx> {\n+    hir: Map<'tcx>,\n+    /// Maps a HirId to a set of HirIds that are dropped by that node.\n+    consumed_places: HirIdMap<HirIdSet>,\n+    borrowed_places: HirIdSet,\n+    drop_ranges: DropRanges,\n+    expr_count: usize,\n+}\n+\n+impl<'tcx> DropRangeVisitor<'tcx> {\n+    pub fn from_uses(uses: ExprUseDelegate<'tcx>, num_exprs: usize) -> Self {\n+        debug!(\"consumed_places: {:?}\", uses.consumed_places);\n+        let drop_ranges = DropRanges::new(\n+            uses.consumed_places.iter().flat_map(|(_, places)| places.iter().copied()),\n+            &uses.hir,\n+            num_exprs,\n+        );\n+        Self {\n+            hir: uses.hir,\n+            consumed_places: uses.consumed_places,\n+            borrowed_places: uses.borrowed_places,\n+            drop_ranges,\n+            expr_count: 0,\n+        }\n+    }\n+\n+    pub fn into_drop_ranges(self) -> DropRanges {\n+        self.drop_ranges\n+    }\n+\n+    fn record_drop(&mut self, hir_id: HirId) {\n+        if self.borrowed_places.contains(&hir_id) {\n+            debug!(\"not marking {:?} as dropped because it is borrowed at some point\", hir_id);\n+        } else {\n+            debug!(\"marking {:?} as dropped at {}\", hir_id, self.expr_count);\n+            let count = self.expr_count;\n+            self.drop_ranges.drop_at(hir_id, count);\n+        }\n+    }\n+\n+    /// ExprUseVisitor's consume callback doesn't go deep enough for our purposes in all\n+    /// expressions. This method consumes a little deeper into the expression when needed.\n+    fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n+        debug!(\"consuming expr {:?}, count={}\", expr.hir_id, self.expr_count);\n+        let places = self\n+            .consumed_places\n+            .get(&expr.hir_id)\n+            .map_or(vec![], |places| places.iter().cloned().collect());\n+        for place in places {\n+            for_each_consumable(place, self.hir.find(place), |hir_id| self.record_drop(hir_id));\n+        }\n+    }\n+\n+    fn reinit_expr(&mut self, expr: &hir::Expr<'_>) {\n+        if let ExprKind::Path(hir::QPath::Resolved(\n+            _,\n+            hir::Path { res: hir::def::Res::Local(hir_id), .. },\n+        )) = expr.kind\n+        {\n+            let location = self.expr_count;\n+            debug!(\"reinitializing {:?} at {}\", hir_id, location);\n+            self.drop_ranges.reinit_at(*hir_id, location);\n+        } else {\n+            debug!(\"reinitializing {:?} is not supported\", expr);\n+        }\n+    }\n+}\n \n-use super::for_each_consumable;\n+/// Applies `f` to consumable portion of a HIR node.\n+///\n+/// The `node` parameter should be the result of calling `Map::find(place)`.\n+fn for_each_consumable(place: HirId, node: Option<Node<'_>>, mut f: impl FnMut(HirId)) {\n+    f(place);\n+    if let Some(Node::Expr(expr)) = node {\n+        match expr.kind {\n+            hir::ExprKind::Path(hir::QPath::Resolved(\n+                _,\n+                hir::Path { res: hir::def::Res::Local(hir_id), .. },\n+            )) => {\n+                f(*hir_id);\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n+    type Map = intravisit::ErasedMap<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        let mut reinit = None;\n+        match expr.kind {\n+            ExprKind::If(test, if_true, if_false) => {\n+                self.visit_expr(test);\n+\n+                let fork = self.expr_count;\n+\n+                self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n+                self.visit_expr(if_true);\n+                let true_end = self.expr_count;\n+\n+                self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n+                if let Some(if_false) = if_false {\n+                    self.visit_expr(if_false);\n+                }\n+\n+                self.drop_ranges.add_control_edge(true_end, self.expr_count + 1);\n+            }\n+            ExprKind::Assign(lhs, rhs, _) => {\n+                self.visit_expr(lhs);\n+                self.visit_expr(rhs);\n+\n+                reinit = Some(lhs);\n+            }\n+            ExprKind::Loop(body, ..) => {\n+                let loop_begin = self.expr_count + 1;\n+                self.visit_block(body);\n+                self.drop_ranges.add_control_edge(self.expr_count, loop_begin);\n+            }\n+            ExprKind::Match(scrutinee, arms, ..) => {\n+                self.visit_expr(scrutinee);\n+\n+                let fork = self.expr_count;\n+                let arm_end_ids = arms\n+                    .iter()\n+                    .map(|hir::Arm { pat, body, guard, .. }| {\n+                        self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n+                        self.visit_pat(pat);\n+                        match guard {\n+                            Some(Guard::If(expr)) => self.visit_expr(expr),\n+                            Some(Guard::IfLet(pat, expr)) => {\n+                                self.visit_pat(pat);\n+                                self.visit_expr(expr);\n+                            }\n+                            None => (),\n+                        }\n+                        self.visit_expr(body);\n+                        self.expr_count\n+                    })\n+                    .collect::<Vec<_>>();\n+                arm_end_ids.into_iter().for_each(|arm_end| {\n+                    self.drop_ranges.add_control_edge(arm_end, self.expr_count + 1)\n+                });\n+            }\n+            ExprKind::Break(hir::Destination { target_id: Ok(target), .. }, ..)\n+            | ExprKind::Continue(hir::Destination { target_id: Ok(target), .. }, ..) => {\n+                self.drop_ranges.add_control_edge_hir_id(self.expr_count, target);\n+            }\n+\n+            _ => intravisit::walk_expr(self, expr),\n+        }\n+\n+        self.expr_count += 1;\n+        self.drop_ranges.add_node_mapping(expr.hir_id, self.expr_count);\n+        self.consume_expr(expr);\n+        if let Some(expr) = reinit {\n+            self.reinit_expr(expr);\n+        }\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n+        intravisit::walk_pat(self, pat);\n+\n+        // Increment expr_count here to match what InteriorVisitor expects.\n+        self.expr_count += 1;\n+    }\n+}\n \n rustc_index::newtype_index! {\n     pub struct PostOrderId {"}]}