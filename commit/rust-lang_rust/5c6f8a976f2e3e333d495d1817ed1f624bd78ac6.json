{"sha": "5c6f8a976f2e3e333d495d1817ed1f624bd78ac6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNmY4YTk3NmYyZTNlMzMzZDQ5NWQxODE3ZWQxZjYyNGJkNzhhYzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-24T20:56:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-25T21:27:42Z"}, "message": "rustdoc: Linkify all reexports.\n\nThis way each component of a reexport path is click-able to the destination that\nit's referencing.", "tree": {"sha": "90d2fedf58290a82ca5d92c5bcacf53b2630a30e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90d2fedf58290a82ca5d92c5bcacf53b2630a30e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c6f8a976f2e3e333d495d1817ed1f624bd78ac6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c6f8a976f2e3e333d495d1817ed1f624bd78ac6", "html_url": "https://github.com/rust-lang/rust/commit/5c6f8a976f2e3e333d495d1817ed1f624bd78ac6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c6f8a976f2e3e333d495d1817ed1f624bd78ac6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c838351ba673c283564875226a2fc6bad0bc1ea1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c838351ba673c283564875226a2fc6bad0bc1ea1", "html_url": "https://github.com/rust-lang/rust/commit/c838351ba673c283564875226a2fc6bad0bc1ea1"}], "stats": {"total": 261, "additions": 227, "deletions": 34}, "files": [{"sha": "f4772d7adc3d38a45efbe14d82badde8ed34270f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5c6f8a976f2e3e333d495d1817ed1f624bd78ac6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6f8a976f2e3e333d495d1817ed1f624bd78ac6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5c6f8a976f2e3e333d495d1817ed1f624bd78ac6", "patch": "@@ -2499,6 +2499,26 @@ impl Resolver {\n         assert!(import_resolution.outstanding_references >= 1);\n         import_resolution.outstanding_references -= 1;\n \n+        // record what this import resolves to for later uses in documentation,\n+        // this may resolve to either a value or a type, but for documentation\n+        // purposes it's good enough to just favor one over the other.\n+        match i.value_target {\n+            Some(target) => {\n+                self.def_map.insert(i.value_id,\n+                                    target.bindings.value_def.get_ref().def);\n+            }\n+            None => {}\n+        }\n+        match i.type_target {\n+            Some(target) => {\n+                match target.bindings.type_def.get_ref().type_def {\n+                    Some(def) => { self.def_map.insert(i.type_id, def); }\n+                    None => {}\n+                }\n+            }\n+            None => {}\n+        }\n+\n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n     }\n@@ -2626,6 +2646,14 @@ impl Resolver {\n             merge_import_resolution(name, name_bindings);\n         }\n \n+        // Record the destination of this import\n+        match containing_module.def_id {\n+            Some(did) => {\n+                self.def_map.insert(id, DefMod(did));\n+            }\n+            None => {}\n+        }\n+\n         debug!(\"(resolving glob import) successfully resolved import\");\n         return Success(());\n     }"}, {"sha": "291476c13904497ba3eb883e8a36625add60fd62", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5c6f8a976f2e3e333d495d1817ed1f624bd78ac6/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6f8a976f2e3e333d495d1817ed1f624bd78ac6/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=5c6f8a976f2e3e333d495d1817ed1f624bd78ac6", "patch": "@@ -930,26 +930,45 @@ impl Clean<ViewItemInner> for ast::view_item_ {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub enum ViewPath {\n-    SimpleImport(~str, Path, ast::NodeId),\n-    GlobImport(Path, ast::NodeId),\n-    ImportList(Path, ~[ViewListIdent], ast::NodeId)\n+    // use str = source;\n+    SimpleImport(~str, ImportSource),\n+    // use source::*;\n+    GlobImport(ImportSource),\n+    // use source::{a, b, c};\n+    ImportList(ImportSource, ~[ViewListIdent]),\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct ImportSource {\n+    path: Path,\n+    did: Option<ast::DefId>,\n }\n \n impl Clean<ViewPath> for ast::view_path {\n     fn clean(&self) -> ViewPath {\n         match self.node {\n-            ast::view_path_simple(ref i, ref p, ref id) => SimpleImport(i.clean(), p.clean(), *id),\n-            ast::view_path_glob(ref p, ref id) => GlobImport(p.clean(), *id),\n-            ast::view_path_list(ref p, ref pl, ref id) => ImportList(p.clean(), pl.clean(), *id),\n+            ast::view_path_simple(ref i, ref p, id) =>\n+                SimpleImport(i.clean(), resolve_use_source(p.clean(), id)),\n+            ast::view_path_glob(ref p, id) =>\n+                GlobImport(resolve_use_source(p.clean(), id)),\n+            ast::view_path_list(ref p, ref pl, id) =>\n+                ImportList(resolve_use_source(p.clean(), id), pl.clean()),\n         }\n     }\n }\n \n-pub type ViewListIdent = ~str;\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct ViewListIdent {\n+    name: ~str,\n+    source: Option<ast::DefId>,\n+}\n \n impl Clean<ViewListIdent> for ast::path_list_ident {\n     fn clean(&self) -> ViewListIdent {\n-        self.node.name.clean()\n+        ViewListIdent {\n+            name: self.node.name.clean(),\n+            source: resolve_def(self.node.id),\n+        }\n     }\n }\n \n@@ -1092,6 +1111,18 @@ fn resolve_type(t: &Type) -> Type {\n         let cname = cratedata.name.to_owned();\n         External(cname + \"::\" + path, ty)\n     } else {\n-        ResolvedPath {path: path.clone(), typarams: tpbs.clone(), id: def_id.node}\n+        ResolvedPath {path: path.clone(), typarams: tpbs, id: def_id.node}\n     }\n }\n+\n+fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n+    ImportSource {\n+        path: path,\n+        did: resolve_def(id),\n+    }\n+}\n+\n+fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n+    let dm = local_data::get(super::ctxtkey, |x| *x.unwrap()).tycx.def_map;\n+    dm.find(&id).map_move(|&d| ast_util::def_id_of_def(d))\n+}"}, {"sha": "7010e7fa4eab6a51de94ba65a3ced8ce9d1f65cf", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 109, "deletions": 23, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/5c6f8a976f2e3e333d495d1817ed1f624bd78ac6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6f8a976f2e3e333d495d1817ed1f624bd78ac6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5c6f8a976f2e3e333d495d1817ed1f624bd78ac6", "patch": "@@ -97,7 +97,8 @@ impl fmt::Default for clean::Path {\n     }\n }\n \n-fn resolved_path(w: &mut io::Writer, id: ast::NodeId, path: &clean::Path) {\n+fn resolved_path(w: &mut io::Writer, id: ast::NodeId,\n+                 path: &clean::Path, print_all: bool) {\n     // The generics will get written to both the title and link\n     let mut generics = ~\"\";\n     let last = path.segments.last();\n@@ -119,47 +120,73 @@ fn resolved_path(w: &mut io::Writer, id: ast::NodeId, path: &clean::Path) {\n     // Did someone say rightward-drift?\n     do local_data::get(current_location_key) |loc| {\n         let loc = loc.unwrap();\n+\n+        if print_all {\n+            let mut root = match path.segments[0].name.as_slice() {\n+                \"super\" => ~\"../\",\n+                \"self\" => ~\"\",\n+                _ => \"../\".repeat(loc.len() - 1),\n+            };\n+            let amt = path.segments.len() - 1;\n+            for seg in path.segments.slice_to(amt).iter() {\n+                if \"super\" == seg.name || \"self\" == seg.name {\n+                    write!(w, \"{}::\", seg.name);\n+                } else {\n+                    root.push_str(seg.name);\n+                    root.push_str(\"/\");\n+                    write!(w, \"<a class='mod'\n+                                  href='{}index.html'>{}</a>::\",\n+                           root,\n+                           seg.name);\n+                }\n+            }\n+        }\n+\n         do local_data::get(cache_key) |cache| {\n             do cache.unwrap().read |cache| {\n                 match cache.paths.find(&id) {\n                     // This is a documented path, link to it!\n                     Some(&(ref fqp, shortty)) => {\n                         let fqn = fqp.connect(\"::\");\n-                        let mut same = 0;\n-                        for (a, b) in loc.iter().zip(fqp.iter()) {\n-                            if *a == *b {\n-                                same += 1;\n-                            } else {\n-                                break;\n-                            }\n-                        }\n+                        let same = loc.iter().zip(fqp.iter())\n+                                      .take_while(|&(a, b)| *a == *b).len();\n \n                         let mut url = ~\"\";\n-                        for _ in range(same, loc.len()) {\n+                        if \"super\" == path.segments[0].name {\n                             url.push_str(\"../\");\n+                        } else if \"self\" != path.segments[0].name {\n+                            url.push_str(\"../\".repeat(loc.len() - same));\n                         }\n-                        if same == fqp.len() {\n-                            url.push_str(shortty);\n-                            url.push_str(\".\");\n-                            url.push_str(*fqp.last());\n-                            url.push_str(\".html\");\n-                        } else {\n+                        if same < fqp.len() {\n                             let remaining = fqp.slice_from(same);\n                             let to_link = remaining.slice_to(remaining.len() - 1);\n                             for component in to_link.iter() {\n                                 url.push_str(*component);\n                                 url.push_str(\"/\");\n                             }\n-                            url.push_str(shortty);\n-                            url.push_str(\".\");\n-                            url.push_str(*remaining.last());\n-                            url.push_str(\".html\");\n                         }\n-\n+                        match shortty {\n+                            \"mod\" => {\n+                                url.push_str(*fqp.last());\n+                                url.push_str(\"/index.html\");\n+                            }\n+                            _ => {\n+                                url.push_str(shortty);\n+                                url.push_str(\".\");\n+                                url.push_str(*fqp.last());\n+                                url.push_str(\".html\");\n+                            }\n+                        }\n                         write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>{}\",\n                                shortty, url, fqn, last.name, generics);\n                     }\n                     None => {\n+                        if print_all {\n+                            let amt = path.segments.len() - 1;\n+                            for seg in path.segments.iter().take(amt) {\n+                                write!(w, \"{}::\", seg.name);\n+                            }\n+                        }\n                         write!(w, \"{}{}\", last.name, generics);\n                     }\n                 };\n@@ -178,9 +205,8 @@ impl fmt::Default for clean::Type {\n                     }\n                 }\n             }\n-            clean::Unresolved(*) => unreachable!(),\n             clean::ResolvedPath{id, typarams: ref typarams, path: ref path} => {\n-                resolved_path(f.buf, id, path);\n+                resolved_path(f.buf, id, path, false);\n                 match *typarams {\n                     Some(ref params) => {\n                         f.buf.write(\"&lt;\".as_bytes());\n@@ -366,3 +392,63 @@ impl fmt::Default for PuritySpace {\n         }\n     }\n }\n+\n+impl fmt::Default for clean::ViewPath {\n+    fn fmt(v: &clean::ViewPath, f: &mut fmt::Formatter) {\n+        match *v {\n+            clean::SimpleImport(ref name, ref src) => {\n+                if *name == src.path.segments.last().name {\n+                    write!(f.buf, \"use {};\", *src);\n+                } else {\n+                    write!(f.buf, \"use {} = {};\", *name, *src);\n+                }\n+            }\n+            clean::GlobImport(ref src) => {\n+                write!(f.buf, \"use {}::*;\", *src);\n+            }\n+            clean::ImportList(ref src, ref names) => {\n+                write!(f.buf, \"use {}::\\\\{\", *src);\n+                for (i, n) in names.iter().enumerate() {\n+                    if i > 0 { write!(f.buf, \", \"); }\n+                    write!(f.buf, \"{}\", *n);\n+                }\n+                write!(f.buf, \"\\\\};\");\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Default for clean::ImportSource {\n+    fn fmt(v: &clean::ImportSource, f: &mut fmt::Formatter) {\n+        match v.did {\n+            Some(did) if ast_util::is_local(did) => {\n+                resolved_path(f.buf, did.node, &v.path, true);\n+            }\n+            _ => {\n+                for (i, seg) in v.path.segments.iter().enumerate() {\n+                    if i > 0 { write!(f.buf, \"::\") }\n+                    write!(f.buf, \"{}\", seg.name);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Default for clean::ViewListIdent {\n+    fn fmt(v: &clean::ViewListIdent, f: &mut fmt::Formatter) {\n+        match v.source {\n+            Some(did) if ast_util::is_local(did) => {\n+                let path = clean::Path {\n+                    global: false,\n+                    segments: ~[clean::PathSegment {\n+                        name: v.name.clone(),\n+                        lifetime: None,\n+                        types: ~[],\n+                    }]\n+                };\n+                resolved_path(f.buf, did.node, &path, false);\n+            }\n+            _ => write!(f.buf, \"{}\", v.name),\n+        }\n+    }\n+}"}, {"sha": "790d9bef746ced62b919d69ae6539e3259fd57ea", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5c6f8a976f2e3e333d495d1817ed1f624bd78ac6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6f8a976f2e3e333d495d1817ed1f624bd78ac6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5c6f8a976f2e3e333d495d1817ed1f624bd78ac6", "patch": "@@ -288,7 +288,9 @@ impl<'self> DocFolder for Cache {\n         } else { false };\n         match item.inner {\n             clean::StructItem(*) | clean::EnumItem(*) |\n-            clean::TypedefItem(*) | clean::TraitItem(*) => {\n+            clean::TypedefItem(*) | clean::TraitItem(*) |\n+            clean::FunctionItem(*) | clean::ModuleItem(*) |\n+            clean::VariantItem(*) => {\n                 self.paths.insert(item.id, (self.stack.clone(), shortty(&item)));\n             }\n             _ => {}\n@@ -479,6 +481,8 @@ impl Context {\n         }\n \n         match item.inner {\n+            // modules are special because they add a namespace. We also need to\n+            // recurse into the items of the module as well.\n             clean::ModuleItem(*) => {\n                 let name = item.name.get_ref().to_owned();\n                 let item = Cell::new(item);\n@@ -498,11 +502,29 @@ impl Context {\n                     }\n                 }\n             }\n+\n+            // Things which don't have names (like impls) don't get special\n+            // pages dedicated to them.\n             _ if item.name.is_some() => {\n                 let dst = self.dst.push(item_path(&item));\n                 let writer = dst.open_writer(io::CreateOrTruncate);\n                 render(writer.unwrap(), self, &item, true);\n+\n+                // recurse if necessary\n+                let name = item.name.get_ref().clone();\n+                match item.inner {\n+                    clean::EnumItem(e) => {\n+                        let mut it = e.variants.move_iter();\n+                        do self.recurse(name) |this| {\n+                            for item in it {\n+                                f(this, item);\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n             }\n+\n             _ => {}\n         }\n     }\n@@ -696,17 +718,43 @@ fn item_module(w: &mut io::Writer, cx: &Context,\n \n                 write!(w, \"\n                     <tr>\n-                        <td><code>{}: {} = </code>{}</td>\n+                        <td><code>{}static {}: {} = </code>{}</td>\n                         <td class='docblock'>{}&nbsp;</td>\n                     </tr>\n                 \",\n+                VisSpace(myitem.visibility),\n                 *myitem.name.get_ref(),\n                 s.type_,\n                 Initializer(s.expr),\n                 Markdown(blank(myitem.doc_value())));\n             }\n \n+            clean::ViewItemItem(ref item) => {\n+                match item.inner {\n+                    clean::ExternMod(ref name, ref src, _, _) => {\n+                        write!(w, \"<tr><td><code>extern mod {}\",\n+                               name.as_slice());\n+                        match *src {\n+                            Some(ref src) => write!(w, \" = \\\"{}\\\"\",\n+                                                    src.as_slice()),\n+                            None => {}\n+                        }\n+                        write!(w, \";</code></td></tr>\");\n+                    }\n+\n+                    clean::Import(ref imports) => {\n+                        for import in imports.iter() {\n+                            write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n+                                   VisSpace(myitem.visibility),\n+                                   *import);\n+                        }\n+                    }\n+                }\n+\n+            }\n+\n             _ => {\n+                if myitem.name.is_none() { loop }\n                 write!(w, \"\n                     <tr>\n                         <td><a class='{class}' href='{href}'"}]}