{"sha": "af204b1f3e83d77427f5fe78285537378be103ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMjA0YjFmM2U4M2Q3NzQyN2Y1ZmU3ODI4NTUzNzM3OGJlMTAzZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-18T07:02:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-18T07:02:11Z"}, "message": "Auto merge of #55171 - kennytm:rollup, r=kennytm\n\nRollup of 18 pull requests\n\nSuccessful merges:\n\n - #54646 (improve documentation on std::thread::sleep)\n - #54933 (Cleanup the rest of codegen_llvm)\n - #54964 (Run both lldb and gdb tests)\n - #55016 (Deduplicate some code and compile-time values around vtables)\n - #55031 (Improve verify_llvm_ir config option)\n - #55050 (doc std::fmt: the Python inspiration is already mentioned in precedin\u2026)\n - #55077 (rustdoc: Use dyn keyword when rendering dynamic traits)\n - #55080 (Detect if access to localStorage is forbidden by the user's browser)\n - #55090 (regression test for move out of borrow via pattern)\n - #55102 (resolve: Do not skip extern prelude during speculative resolution)\n - #55104 (Add test for #34229)\n - #55111 ([Rustc Book] Explain --cfg's arguments)\n - #55122 (Cleanup mir/borrowck)\n - #55127 (Remove HybridBitSet::dummy)\n - #55128 (Fix LLVMRustInlineAsmVerify return type mismatch)\n - #55142 (miri: layout should not affect CTFE checks (outside of validation))\n - #55151 (Cleanup nll)\n - #55161 ([librustdoc] Disable spellcheck for search field)", "tree": {"sha": "9cb6f52d303dfd226216893cb08a28860ffa2301", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cb6f52d303dfd226216893cb08a28860ffa2301"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af204b1f3e83d77427f5fe78285537378be103ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af204b1f3e83d77427f5fe78285537378be103ec", "html_url": "https://github.com/rust-lang/rust/commit/af204b1f3e83d77427f5fe78285537378be103ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af204b1f3e83d77427f5fe78285537378be103ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7eb7fbbf6bca0eaa146c4a48cd39c133a257706", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7eb7fbbf6bca0eaa146c4a48cd39c133a257706", "html_url": "https://github.com/rust-lang/rust/commit/f7eb7fbbf6bca0eaa146c4a48cd39c133a257706"}, {"sha": "1c090061e9a7dbe7ce65c34f81b8fd55318adeb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c090061e9a7dbe7ce65c34f81b8fd55318adeb0", "html_url": "https://github.com/rust-lang/rust/commit/1c090061e9a7dbe7ce65c34f81b8fd55318adeb0"}], "stats": {"total": 1287, "additions": 740, "deletions": 547}, "files": [{"sha": "b6764c1aaeab6a22c3ef8af857c626b01529a601", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -287,10 +287,6 @@ fn main() {\n         cmd.arg(\"--cfg\").arg(\"parallel_queries\");\n     }\n \n-    if env::var_os(\"RUSTC_VERIFY_LLVM_IR\").is_some() {\n-        cmd.arg(\"-Z\").arg(\"verify-llvm-ir\");\n-    }\n-\n     if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() && env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none()\n     {\n         cmd.arg(\"-Dwarnings\");"}, {"sha": "aa4e44df2ef9401d53109f404a74bc6baf3ca8cb", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -1000,10 +1000,6 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_BACKTRACE_ON_ICE\", \"1\");\n         }\n \n-        if self.config.rust_verify_llvm_ir {\n-            cargo.env(\"RUSTC_VERIFY_LLVM_IR\", \"1\");\n-        }\n-\n         cargo.env(\"RUSTC_VERBOSE\", self.verbosity.to_string());\n \n         // in std, we want to avoid denying warnings for stage 0 as that makes cfg's painful."}, {"sha": "69d45acdedaf9dc0859a2ecca9e315bf78eed70d", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -569,6 +569,9 @@ pub fn rustc_cargo_env(builder: &Builder, cargo: &mut Command) {\n     if builder.config.rustc_parallel_queries {\n         cargo.env(\"RUSTC_PARALLEL_QUERIES\", \"1\");\n     }\n+    if builder.config.rust_verify_llvm_ir {\n+        cargo.env(\"RUSTC_VERIFY_LLVM_IR\", \"1\");\n+    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]"}, {"sha": "80c89b9ff3826eec1964229c3df3780c907ad801", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -812,8 +812,7 @@ default_test!(Incremental {\n \n default_test!(Debuginfo {\n     path: \"src/test/debuginfo\",\n-    // What this runs varies depending on the native platform being apple\n-    mode: \"debuginfo-XXX\",\n+    mode: \"debuginfo\",\n     suite: \"debuginfo\"\n });\n \n@@ -950,18 +949,11 @@ impl Step for Compiletest {\n                 return;\n             }\n \n-            if mode == \"debuginfo-XXX\" {\n-                return if builder.config.build.contains(\"apple\") {\n-                    builder.ensure(Compiletest {\n-                        mode: \"debuginfo-lldb\",\n-                        ..self\n-                    });\n-                } else {\n-                    builder.ensure(Compiletest {\n-                        mode: \"debuginfo-gdb\",\n-                        ..self\n-                    });\n-                };\n+            if mode == \"debuginfo\" {\n+                return builder.ensure(Compiletest {\n+                    mode: \"debuginfo-both\",\n+                    ..self\n+                });\n             }\n \n             builder.ensure(dist::DebuggerScripts {"}, {"sha": "42561cf95d3ac56342b9c8881e69e132f696b565", "filename": "src/ci/run.sh", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -61,6 +61,7 @@ if [ \"$DEPLOY$DEPLOY_ALT\" != \"\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-llvm-assertions\"\n   elif [ \"$DEPLOY_ALT\" != \"\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-llvm-assertions\"\n+    RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set rust.verify-llvm-ir\"\n   fi\n else\n   # We almost always want debug assertions enabled, but sometimes this takes too\n@@ -74,6 +75,8 @@ else\n   if [ \"$NO_LLVM_ASSERTIONS\" = \"\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-llvm-assertions\"\n   fi\n+\n+  RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set rust.verify-llvm-ir\"\n fi\n \n if [ \"$RUST_RELEASE_CHANNEL\" = \"nightly\" ] || [ \"$DIST_REQUIRE_ALL_TOOLS\" = \"\" ]; then"}, {"sha": "b60c55240140e437d999306b2491a48f07fdc65b", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -10,6 +10,11 @@ This flag will print out help information for `rustc`.\n \n This flag can turn on or off various `#[cfg]` settings.\n \n+The value can either be a single identifier or two identifiers separated by `=`.\n+\n+For examples, `--cfg 'verbose'` or `--cfg 'feature=\"serde\"'`. These correspond\n+to `#[cfg(verbose)]` and `#[cfg(feature = \"serde\")]` respectively.\n+\n ## `-L`: add a directory to the library search path\n \n When looking for external crates, a directory passed to this flag will be searched."}, {"sha": "b857964ccb3c3eb96b72a28ef03cae4d9e65c3aa", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -335,8 +335,7 @@\n //!\n //! Each argument being formatted can be transformed by a number of formatting\n //! parameters (corresponding to `format_spec` in the syntax above). These\n-//! parameters affect the string representation of what's being formatted. This\n-//! syntax draws heavily from Python's, so it may seem a bit familiar.\n+//! parameters affect the string representation of what's being formatted.\n //!\n //! ## Fill/Alignment\n //!"}, {"sha": "bde503d86de739fa7cc5171d87a49856cd28c9d9", "filename": "src/librustc/build.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbuild.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -8,8 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::env;\n+\n fn main() {\n     println!(\"cargo:rerun-if-changed=build.rs\");\n     println!(\"cargo:rerun-if-env-changed=CFG_LIBDIR_RELATIVE\");\n     println!(\"cargo:rerun-if-env-changed=CFG_COMPILER_HOST_TRIPLE\");\n+    println!(\"cargo:rerun-if-env-changed=RUSTC_VERIFY_LLVM_IR\");\n+\n+    if env::var_os(\"RUSTC_VERIFY_LLVM_IR\").is_some() {\n+        println!(\"cargo:rustc-cfg=always_verify_llvm_ir\");\n+    }\n }"}, {"sha": "2b90a27b6a8ceb2ac0b9b8c704d186f136260d06", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -525,6 +525,7 @@ impl Session {\n     }\n     pub fn verify_llvm_ir(&self) -> bool {\n         self.opts.debugging_opts.verify_llvm_ir\n+            || cfg!(always_verify_llvm_ir)\n     }\n     pub fn borrowck_stats(&self) -> bool {\n         self.opts.debugging_opts.borrowck_stats"}, {"sha": "14e4ddfcdd6361af1cebe7a8e0eb544da1a8cf52", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -369,16 +369,16 @@ define_queries! { <'tcx>\n             -> Lrc<specialization_graph::Graph>,\n         [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n \n-        // Get the ParameterEnvironment for a given item; this environment\n-        // will be in \"user-facing\" mode, meaning that it is suitabe for\n-        // type-checking etc, and it does not normalize specializable\n-        // associated types. This is almost always what you want,\n-        // unless you are doing MIR optimizations, in which case you\n-        // might want to use `reveal_all()` method to change modes.\n+        /// Get the ParameterEnvironment for a given item; this environment\n+        /// will be in \"user-facing\" mode, meaning that it is suitabe for\n+        /// type-checking etc, and it does not normalize specializable\n+        /// associated types. This is almost always what you want,\n+        /// unless you are doing MIR optimizations, in which case you\n+        /// might want to use `reveal_all()` method to change modes.\n         [] fn param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n \n-        // Trait selection queries. These are best used by invoking `ty.moves_by_default()`,\n-        // `ty.is_copy()`, etc, since that will prune the environment where possible.\n+        /// Trait selection queries. These are best used by invoking `ty.moves_by_default()`,\n+        /// `ty.is_copy()`, etc, since that will prune the environment where possible.\n         [] fn is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n         [] fn is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n         [] fn is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,"}, {"sha": "169bd9a8466a03b2508b94fc20823d85c55618d5", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -756,7 +756,7 @@ impl Builder<'a, 'll, 'tcx> {\n             // Ask LLVM to verify that the constraints are well-formed.\n             let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons);\n             debug!(\"Constraint verification result: {:?}\", constraints_ok);\n-            if constraints_ok == llvm::True {\n+            if constraints_ok {\n                 let v = llvm::LLVMRustInlineAsm(\n                     fty, asm, cons, volatile, alignstack, dia);\n                 Some(self.call(v, inputs, None))"}, {"sha": "56352ae963f20ab4d1febe92224d51cf80767c5e", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -37,7 +37,7 @@ pub struct MirDebugScope<'ll> {\n \n impl MirDebugScope<'ll> {\n     pub fn is_valid(&self) -> bool {\n-        !self.scope_metadata.is_none()\n+        self.scope_metadata.is_some()\n     }\n }\n "}, {"sha": "f5e5287cd42c5409741715fe23b6bb5ac6c2bc28", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -163,10 +163,10 @@ impl TypeMap<'ll, 'tcx> {\n     fn get_unique_type_id_of_type<'a>(&mut self, cx: &CodegenCx<'a, 'tcx>,\n                                       type_: Ty<'tcx>) -> UniqueTypeId {\n         // Let's see if we already have something in the cache\n-        match self.type_to_unique_id.get(&type_).cloned() {\n-            Some(unique_type_id) => return unique_type_id,\n-            None => { /* generate one */}\n-        };\n+        if let Some(unique_type_id) = self.type_to_unique_id.get(&type_).cloned() {\n+            return unique_type_id;\n+        }\n+        // if not, generate one\n \n         // The hasher we are using to generate the UniqueTypeId. We want\n         // something that provides more than the 64 bits of the DefaultHasher.\n@@ -286,11 +286,11 @@ impl RecursiveTypeDescription<'ll, 'tcx> {\n // unique id can be found in the type map\n macro_rules! return_if_metadata_created_in_meantime {\n     ($cx: expr, $unique_type_id: expr) => (\n-        match debug_context($cx).type_map\n-                                .borrow()\n-                                .find_metadata_for_unique_id($unique_type_id) {\n-            Some(metadata) => return MetadataCreationResult::new(metadata, true),\n-            None => { /* proceed normally */ }\n+        if let Some(metadata) = debug_context($cx).type_map\n+            .borrow()\n+            .find_metadata_for_unique_id($unique_type_id)\n+        {\n+            return MetadataCreationResult::new(metadata, true);\n         }\n     )\n }\n@@ -352,15 +352,15 @@ fn vec_slice_metadata(\n \n     let member_descriptions = vec![\n         MemberDescription {\n-            name: \"data_ptr\".to_string(),\n+            name: \"data_ptr\".to_owned(),\n             type_metadata: data_ptr_metadata,\n             offset: Size::ZERO,\n             size: pointer_size,\n             align: pointer_align,\n             flags: DIFlags::FlagZero,\n         },\n         MemberDescription {\n-            name: \"length\".to_string(),\n+            name: \"length\".to_owned(),\n             type_metadata: type_metadata(cx, cx.tcx.types.usize, span),\n             offset: pointer_size,\n             size: usize_size,\n@@ -458,7 +458,7 @@ fn trait_pointer_metadata(\n     let vtable_field = layout.field(cx, 1);\n     let member_descriptions = vec![\n         MemberDescription {\n-            name: \"pointer\".to_string(),\n+            name: \"pointer\".to_owned(),\n             type_metadata: type_metadata(cx,\n                 cx.tcx.mk_mut_ptr(cx.tcx.types.u8),\n                 syntax_pos::DUMMY_SP),\n@@ -468,7 +468,7 @@ fn trait_pointer_metadata(\n             flags: DIFlags::FlagArtificial,\n         },\n         MemberDescription {\n-            name: \"vtable\".to_string(),\n+            name: \"vtable\".to_owned(),\n             type_metadata: type_metadata(cx, vtable_field.ty, syntax_pos::DUMMY_SP),\n             offset: layout.fields.offset(1),\n             size: vtable_field.size,\n@@ -543,12 +543,12 @@ pub fn type_metadata(\n             _ => {\n                 let pointee_metadata = type_metadata(cx, ty, usage_site_span);\n \n-                match debug_context(cx).type_map\n-                                        .borrow()\n-                                        .find_metadata_for_unique_id(unique_type_id) {\n-                    Some(metadata) => return Err(metadata),\n-                    None => { /* proceed normally */ }\n-                };\n+                if let Some(metadata) = debug_context(cx).type_map\n+                    .borrow()\n+                    .find_metadata_for_unique_id(unique_type_id)\n+                {\n+                    return Err(metadata);\n+                }\n \n                 Ok(MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n                    false))\n@@ -577,12 +577,12 @@ pub fn type_metadata(\n         }\n         ty::Dynamic(..) => {\n             MetadataCreationResult::new(\n-                        trait_pointer_metadata(cx, t, None, unique_type_id),\n-            false)\n+                trait_pointer_metadata(cx, t, None, unique_type_id),\n+                false)\n         }\n         ty::Foreign(..) => {\n             MetadataCreationResult::new(\n-                        foreign_type_metadata(cx, t, unique_type_id),\n+            foreign_type_metadata(cx, t, unique_type_id),\n             false)\n         }\n         ty::RawPtr(ty::TypeAndMut{ty, ..}) |\n@@ -603,12 +603,12 @@ pub fn type_metadata(\n                                                        unique_type_id,\n                                                        t.fn_sig(cx.tcx),\n                                                        usage_site_span).metadata;\n-            match debug_context(cx).type_map\n-                                   .borrow()\n-                                   .find_metadata_for_unique_id(unique_type_id) {\n-                Some(metadata) => return metadata,\n-                None => { /* proceed normally */ }\n-            };\n+            if let Some(metadata) = debug_context(cx).type_map\n+               .borrow()\n+               .find_metadata_for_unique_id(unique_type_id)\n+            {\n+                return metadata;\n+            }\n \n             // This is actually a function pointer, so wrap it in pointer DI\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n@@ -641,16 +641,16 @@ pub fn type_metadata(\n             }\n             AdtKind::Union => {\n                 prepare_union_metadata(cx,\n-                                    t,\n-                                    unique_type_id,\n-                                    usage_site_span).finalize(cx)\n+                                       t,\n+                                       unique_type_id,\n+                                       usage_site_span).finalize(cx)\n             }\n             AdtKind::Enum => {\n                 prepare_enum_metadata(cx,\n-                                    t,\n-                                    def.did,\n-                                    unique_type_id,\n-                                    usage_site_span).finalize(cx)\n+                                      t,\n+                                      def.did,\n+                                      unique_type_id,\n+                                      usage_site_span).finalize(cx)\n             }\n         },\n         ty::Tuple(ref elements) => {\n@@ -938,7 +938,7 @@ enum MemberDescriptionFactory<'ll, 'tcx> {\n \n impl MemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         match *self {\n             StructMDF(ref this) => {\n                 this.create_member_descriptions(cx)\n@@ -972,7 +972,7 @@ struct StructMemberDescriptionFactory<'tcx> {\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         let layout = cx.layout_of(self.ty);\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let name = if self.variant.ctor_kind == CtorKind::Fn {\n@@ -1042,7 +1042,7 @@ struct TupleMemberDescriptionFactory<'tcx> {\n \n impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         let layout = cx.layout_of(self.ty);\n         self.component_types.iter().enumerate().map(|(i, &component_type)| {\n             let (size, align) = cx.size_and_align_of(component_type);\n@@ -1096,7 +1096,7 @@ struct UnionMemberDescriptionFactory<'tcx> {\n \n impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = self.layout.field(cx, i);\n             let (size, align) = field.size_and_align();\n@@ -1165,7 +1165,7 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>)\n-                                      -> Vec<MemberDescription<'ll>> {\n+                                  -> Vec<MemberDescription<'ll>> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n         match self.layout.variants {\n             layout::Variants::Single { .. } if adt.variants.is_empty() => vec![],\n@@ -1357,7 +1357,7 @@ fn describe_enum_variant(\n             // We have the layout of an enum variant, we need the layout of the outer enum\n             let enum_layout = cx.layout_of(layout.ty);\n             (Some(enum_layout.fields.offset(0)),\n-             Some((\"RUST$ENUM$DISR\".to_string(), enum_layout.field(cx, 0).ty)))\n+             Some((\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, 0).ty)))\n         }\n         _ => (None, None),\n     };\n@@ -1471,9 +1471,8 @@ fn prepare_enum_metadata(\n         }\n     };\n \n-    match (&layout.abi, discriminant_type_metadata) {\n-        (&layout::Abi::Scalar(_), Some(discr)) => return FinalMetadata(discr),\n-        _ => {}\n+    if let (&layout::Abi::Scalar(_), Some(discr)) = (&layout.abi, discriminant_type_metadata) {\n+        return FinalMetadata(discr);\n     }\n \n     let (enum_type_size, enum_type_align) = layout.size_and_align();\n@@ -1546,7 +1545,7 @@ fn composite_type_metadata(\n                                   composite_type_metadata,\n                                   member_descriptions);\n \n-    return composite_type_metadata;\n+    composite_type_metadata\n }\n \n fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n@@ -1634,7 +1633,7 @@ fn create_struct_stub(\n             unique_type_id.as_ptr())\n     };\n \n-    return metadata_stub;\n+    metadata_stub\n }\n \n fn create_union_stub(\n@@ -1670,7 +1669,7 @@ fn create_union_stub(\n             unique_type_id.as_ptr())\n     };\n \n-    return metadata_stub;\n+    metadata_stub\n }\n \n /// Creates debug information for the given global variable."}, {"sha": "acb79d6f568cc5cb6fa1a9abc394547ddf3e6367", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -271,16 +271,14 @@ pub fn create_function_debug_context(\n     let mut flags = DIFlags::FlagPrototyped;\n \n     let local_id = cx.tcx.hir.as_local_node_id(def_id);\n-    match *cx.sess().entry_fn.borrow() {\n-        Some((id, _, _)) => {\n-            if local_id == Some(id) {\n-                flags = flags | DIFlags::FlagMainSubprogram;\n-            }\n+    if let Some((id, _, _)) = *cx.sess().entry_fn.borrow() {\n+        if local_id == Some(id) {\n+            flags |= DIFlags::FlagMainSubprogram;\n         }\n-        None => {}\n-    };\n+    }\n+\n     if cx.layout_of(sig.output()).abi.is_uninhabited() {\n-        flags = flags | DIFlags::FlagNoReturn;\n+        flags |= DIFlags::FlagNoReturn;\n     }\n \n     let fn_metadata = unsafe {\n@@ -371,7 +369,7 @@ pub fn create_function_debug_context(\n             }\n         }\n \n-        return create_DIArray(DIB(cx), &signature[..]);\n+        create_DIArray(DIB(cx), &signature[..])\n     }\n \n     fn get_template_parameters(\n@@ -428,7 +426,7 @@ pub fn create_function_debug_context(\n             vec![]\n         };\n \n-        return create_DIArray(DIB(cx), &template_params[..]);\n+        create_DIArray(DIB(cx), &template_params[..])\n     }\n \n     fn get_parameter_names(cx: &CodegenCx,"}, {"sha": "60ebcb888166ff96bb0193f05edf153b7551d9c5", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -56,11 +56,8 @@ pub fn set_source_location(\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is codegened.\n pub fn start_emitting_source_locations(dbg_context: &FunctionDebugContext<'ll>) {\n-    match *dbg_context {\n-        FunctionDebugContext::RegularContext(ref data) => {\n-            data.source_locations_enabled.set(true)\n-        },\n-        _ => { /* safe to ignore */ }\n+    if let FunctionDebugContext::RegularContext(ref data) = *dbg_context {\n+        data.source_locations_enabled.set(true);\n     }\n }\n "}, {"sha": "f5abb527e430fa91c41a6ce4f6c12c9c3a9b21d1", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -177,7 +177,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::GeneratorWitness(..) |\n         ty::Param(_) => {\n             bug!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {:?}\", t);\n+                  unexpected type: {:?}\", t);\n         }\n     }\n "}, {"sha": "e0a9f31e508ba2f0cac91a8ca32c03d481146eab", "filename": "src/librustc_codegen_llvm/llvm/archive_ro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -40,7 +40,7 @@ impl ArchiveRO {\n         return unsafe {\n             let s = path2cstr(dst);\n             let ar = super::LLVMRustOpenArchive(s.as_ptr()).ok_or_else(|| {\n-                super::last_error().unwrap_or(\"failed to open archive\".to_string())\n+                super::last_error().unwrap_or(\"failed to open archive\".to_owned())\n             })?;\n             Ok(ArchiveRO { raw: ar })\n         };"}, {"sha": "0b98fa4eaf55139ebce5967de1a234a26379b759", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -1212,8 +1212,8 @@ extern \"C\" {\n                              Dialect: AsmDialect)\n                              -> &Value;\n     pub fn LLVMRustInlineAsmVerify(Ty: &Type,\n-                             Constraints: *const c_char)\n-                             -> Bool;\n+                                   Constraints: *const c_char)\n+                                   -> bool;\n \n     pub fn LLVMRustDebugMetadataVersion() -> u32;\n     pub fn LLVMRustVersionMajor() -> u32;"}, {"sha": "29c2e71960c2cdc9d5da061ff7a0f89f0147f8da", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -94,6 +94,10 @@ pub fn get_vtable(\n     });\n \n     let (size, align) = cx.size_and_align_of(ty);\n+    // /////////////////////////////////////////////////////////////////////////////////////////////\n+    // If you touch this code, be sure to also make the corresponding changes to\n+    // `get_vtable` in rust_mir/interpret/traits.rs\n+    // /////////////////////////////////////////////////////////////////////////////////////////////\n     let components: Vec<_> = [\n         callee::get_fn(cx, monomorphize::resolve_drop_in_place(cx.tcx, ty)),\n         C_usize(cx, size.bytes()),"}, {"sha": "68e30227185c0ba68c22ca50b705fb6c8d671432", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -125,10 +125,10 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     this.unreachable_block()\n                 };\n                 let invokeret = bx.invoke(fn_ptr,\n-                                           &llargs,\n-                                           ret_bx,\n-                                           llblock(this, cleanup),\n-                                           cleanup_bundle);\n+                                          &llargs,\n+                                          ret_bx,\n+                                          llblock(this, cleanup),\n+                                          cleanup_bundle);\n                 fn_ty.apply_attrs_callsite(&bx, invokeret);\n \n                 if let Some((ret_dest, target)) = destination {\n@@ -213,7 +213,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 } else {\n                     let (otherwise, targets) = targets.split_last().unwrap();\n                     let switch = bx.switch(discr.immediate(),\n-                                            llblock(self, *otherwise), values.len());\n+                                           llblock(self, *otherwise),\n+                                           values.len());\n                     let switch_llty = bx.cx.layout_of(switch_ty).immediate_llvm_type(bx.cx);\n                     for (&value, target) in values.iter().zip(targets) {\n                         let llval = C_uint_big(switch_llty, value);\n@@ -387,8 +388,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         let msg_str = Symbol::intern(str).as_str();\n                         let msg_str = C_str_slice(bx.cx, msg_str);\n                         let msg_file_line_col = C_struct(bx.cx,\n-                                                     &[msg_str, filename, line, col],\n-                                                     false);\n+                                                         &[msg_str, filename, line, col],\n+                                                         false);\n                         let msg_file_line_col = consts::addr_of(bx.cx,\n                                                                 msg_file_line_col,\n                                                                 align,\n@@ -509,8 +510,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     let msg_str = Symbol::intern(&str).as_str();\n                     let msg_str = C_str_slice(bx.cx, msg_str);\n                     let msg_file_line_col = C_struct(bx.cx,\n-                                                    &[msg_str, filename, line, col],\n-                                                    false);\n+                                                     &[msg_str, filename, line, col],\n+                                                     false);\n                     let msg_file_line_col = consts::addr_of(bx.cx,\n                                                             msg_file_line_col,\n                                                             align,\n@@ -619,7 +620,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n                     let callee_ty = instance.as_ref().unwrap().ty(bx.cx.tcx);\n                     codegen_intrinsic_call(&bx, callee_ty, &fn_ty, &args, dest,\n-                                         terminator.source_info.span);\n+                                           terminator.source_info.span);\n \n                     if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n                         self.store_return(&bx, ret_dest, &fn_ty.ret, dst.llval);\n@@ -756,7 +757,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n                 llval = bx.load(bx.pointercast(llval, ty.llvm_type(bx.cx).ptr_to()),\n-                                 align.min(arg.layout.align));\n+                                align.min(arg.layout.align));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n                 // may have a type we don't treat as immediate, but the ABI\n@@ -778,10 +779,10 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n \n     fn codegen_arguments_untupled(&mut self,\n-                                bx: &Builder<'a, 'll, 'tcx>,\n-                                operand: &mir::Operand<'tcx>,\n-                                llargs: &mut Vec<&'ll Value>,\n-                                args: &[ArgType<'tcx, Ty<'tcx>>]) {\n+                                  bx: &Builder<'a, 'll, 'tcx>,\n+                                  operand: &mir::Operand<'tcx>,\n+                                  llargs: &mut Vec<&'ll Value>,\n+                                  args: &[ArgType<'tcx, Ty<'tcx>>]) {\n         let tuple = self.codegen_operand(bx, operand);\n \n         // Handle both by-ref and immediate tuples.\n@@ -933,8 +934,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n \n     fn codegen_transmute(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n-                       src: &mir::Operand<'tcx>,\n-                       dst: &mir::Place<'tcx>) {\n+                         src: &mir::Operand<'tcx>,\n+                         dst: &mir::Place<'tcx>) {\n         if let mir::Place::Local(index) = *dst {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n@@ -961,8 +962,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     }\n \n     fn codegen_transmute_into(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n-                            src: &mir::Operand<'tcx>,\n-                            dst: PlaceRef<'ll, 'tcx>) {\n+                              src: &mir::Operand<'tcx>,\n+                              dst: PlaceRef<'ll, 'tcx>) {\n         let src = self.codegen_operand(bx, src);\n         let llty = src.layout.llvm_type(bx.cx);\n         let cast_ptr = bx.pointercast(dst.llval, llty.ptr_to());"}, {"sha": "a6e2ccf92e4e3fd416a028c1950679fb0fce14a0", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -162,16 +162,16 @@ impl FunctionCx<'a, 'll, 'tcx> {\n     // corresponding to span's containing source scope.  If so, we need to create a DIScope\n     // \"extension\" into that file.\n     fn scope_metadata_for_loc(&self, scope_id: mir::SourceScope, pos: BytePos)\n-                               -> Option<&'ll DIScope> {\n+                              -> Option<&'ll DIScope> {\n         let scope_metadata = self.scopes[scope_id].scope_metadata;\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n             let cm = self.cx.sess().source_map();\n             let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n             Some(debuginfo::extend_scope_to_file(self.cx,\n-                                            scope_metadata.unwrap(),\n-                                            &cm.lookup_char_pos(pos).file,\n-                                            defining_crate))\n+                                                 scope_metadata.unwrap(),\n+                                                 &cm.lookup_char_pos(pos).file,\n+                                                 defining_crate))\n         } else {\n             scope_metadata\n         }"}, {"sha": "28aad49b09b998678ca52d7574718636c6c10ded", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -423,15 +423,6 @@ pub enum HybridBitSet<T: Idx> {\n }\n \n impl<T: Idx> HybridBitSet<T> {\n-    // FIXME: This function is used in conjunction with `mem::replace()` in\n-    // several pieces of awful code below. I can't work out how else to appease\n-    // the borrow checker.\n-    fn dummy() -> Self {\n-        // The cheapest HybridBitSet to construct, which is only used to get\n-        // around the borrow checker.\n-        HybridBitSet::Sparse(SparseBitSet::new_empty(0))\n-    }\n-\n     pub fn new_empty(domain_size: usize) -> Self {\n         HybridBitSet::Sparse(SparseBitSet::new_empty(domain_size))\n     }\n@@ -487,20 +478,14 @@ impl<T: Idx> HybridBitSet<T> {\n                 // that doesn't matter because `elem` is already present.\n                 false\n             }\n-            HybridBitSet::Sparse(_) => {\n+            HybridBitSet::Sparse(sparse) => {\n                 // The set is sparse and full. Convert to a dense set.\n-                match mem::replace(self, HybridBitSet::dummy()) {\n-                    HybridBitSet::Sparse(sparse) => {\n-                        let mut dense = sparse.to_dense();\n-                        let changed = dense.insert(elem);\n-                        assert!(changed);\n-                        *self = HybridBitSet::Dense(dense);\n-                        changed\n-                    }\n-                    _ => unreachable!()\n-                }\n+                let mut dense = sparse.to_dense();\n+                let changed = dense.insert(elem);\n+                assert!(changed);\n+                *self = HybridBitSet::Dense(dense);\n+                changed\n             }\n-\n             HybridBitSet::Dense(dense) => dense.insert(elem),\n         }\n     }\n@@ -525,33 +510,26 @@ impl<T: Idx> HybridBitSet<T> {\n \n     pub fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n         match self {\n-            HybridBitSet::Sparse(_) => {\n+            HybridBitSet::Sparse(self_sparse) => {\n                 match other {\n                     HybridBitSet::Sparse(other_sparse) => {\n                         // Both sets are sparse. Add the elements in\n-                        // `other_sparse` to `self_hybrid` one at a time. This\n-                        // may or may not cause `self_hybrid` to be densified.\n+                        // `other_sparse` to `self` one at a time. This\n+                        // may or may not cause `self` to be densified.\n                         assert_eq!(self.domain_size(), other.domain_size());\n-                        let mut self_hybrid = mem::replace(self, HybridBitSet::dummy());\n                         let mut changed = false;\n                         for elem in other_sparse.iter() {\n-                            changed |= self_hybrid.insert(*elem);\n+                            changed |= self.insert(*elem);\n                         }\n-                        *self = self_hybrid;\n                         changed\n                     }\n                     HybridBitSet::Dense(other_dense) => {\n                         // `self` is sparse and `other` is dense. Densify\n                         // `self` and then do the bitwise union.\n-                        match mem::replace(self, HybridBitSet::dummy()) {\n-                            HybridBitSet::Sparse(self_sparse) => {\n-                                let mut new_dense = self_sparse.to_dense();\n-                                let changed = new_dense.union(other_dense);\n-                                *self = HybridBitSet::Dense(new_dense);\n-                                changed\n-                            }\n-                            _ => unreachable!()\n-                        }\n+                        let mut new_dense = self_sparse.to_dense();\n+                        let changed = new_dense.union(other_dense);\n+                        *self = HybridBitSet::Dense(new_dense);\n+                        changed\n                     }\n                 }\n             }"}, {"sha": "a316fc5ca1029ca2f47f86532b5b0e07bcd18f11", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 48, "deletions": 52, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -92,12 +92,12 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n             mir::BorrowKind::Mut { .. } => \"mut \",\n         };\n         let region = self.region.to_string();\n-        let region = if region.len() > 0 {\n-            format!(\"{} \", region)\n+        let separator = if !region.is_empty() {\n+            \" \"\n         } else {\n-            region\n+            \"\"\n         };\n-        write!(w, \"&{}{}{:?}\", region, kind, self.borrowed_place)\n+        write!(w, \"&{}{}{}{:?}\", region, separator, kind, self.borrowed_place)\n     }\n }\n \n@@ -244,7 +244,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n             K: Clone + Eq + Hash,\n             V: Eq + Hash,\n         {\n-            map.entry(k.clone()).or_insert(FxHashSet()).insert(v);\n+            map.entry(k.clone()).or_default().insert(v);\n         }\n     }\n \n@@ -261,57 +261,53 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n             // ... check whether we (earlier) saw a 2-phase borrow like\n             //\n             //     TMP = &mut place\n-            match self.pending_activations.get(temp) {\n-                Some(&borrow_index) => {\n-                    let borrow_data = &mut self.idx_vec[borrow_index];\n-\n-                    // Watch out: the use of TMP in the borrow itself\n-                    // doesn't count as an activation. =)\n-                    if borrow_data.reserve_location == location && context == PlaceContext::Store {\n-                        return;\n-                    }\n+            if let Some(&borrow_index) = self.pending_activations.get(temp) {\n+                let borrow_data = &mut self.idx_vec[borrow_index];\n \n-                    if let TwoPhaseActivation::ActivatedAt(other_location) =\n-                            borrow_data.activation_location {\n-                        span_bug!(\n-                            self.mir.source_info(location).span,\n-                            \"found two uses for 2-phase borrow temporary {:?}: \\\n-                             {:?} and {:?}\",\n-                            temp,\n-                            location,\n-                            other_location,\n-                        );\n-                    }\n+                // Watch out: the use of TMP in the borrow itself\n+                // doesn't count as an activation. =)\n+                if borrow_data.reserve_location == location && context == PlaceContext::Store {\n+                    return;\n+                }\n \n-                    // Otherwise, this is the unique later use\n-                    // that we expect.\n-                    borrow_data.activation_location = match context {\n-                        // The use of TMP in a shared borrow does not\n-                        // count as an actual activation.\n-                        PlaceContext::Borrow { kind: mir::BorrowKind::Shared, .. }\n-                        | PlaceContext::Borrow { kind: mir::BorrowKind::Shallow, .. } => {\n-                            TwoPhaseActivation::NotActivated\n-                        }\n-                        _ => {\n-                            // Double check: This borrow is indeed a two-phase borrow (that is,\n-                            // we are 'transitioning' from `NotActivated` to `ActivatedAt`) and\n-                            // we've not found any other activations (checked above).\n-                            assert_eq!(\n-                                borrow_data.activation_location,\n-                                TwoPhaseActivation::NotActivated,\n-                                \"never found an activation for this borrow!\",\n-                            );\n-\n-                            self.activation_map\n-                                .entry(location)\n-                                .or_default()\n-                                .push(borrow_index);\n-                            TwoPhaseActivation::ActivatedAt(location)\n-                        }\n-                    };\n+                if let TwoPhaseActivation::ActivatedAt(other_location) =\n+                        borrow_data.activation_location {\n+                    span_bug!(\n+                        self.mir.source_info(location).span,\n+                        \"found two uses for 2-phase borrow temporary {:?}: \\\n+                         {:?} and {:?}\",\n+                        temp,\n+                        location,\n+                        other_location,\n+                    );\n                 }\n \n-                None => {}\n+                // Otherwise, this is the unique later use\n+                // that we expect.\n+                borrow_data.activation_location = match context {\n+                    // The use of TMP in a shared borrow does not\n+                    // count as an actual activation.\n+                    PlaceContext::Borrow { kind: mir::BorrowKind::Shared, .. }\n+                    | PlaceContext::Borrow { kind: mir::BorrowKind::Shallow, .. } => {\n+                        TwoPhaseActivation::NotActivated\n+                    }\n+                    _ => {\n+                        // Double check: This borrow is indeed a two-phase borrow (that is,\n+                        // we are 'transitioning' from `NotActivated` to `ActivatedAt`) and\n+                        // we've not found any other activations (checked above).\n+                        assert_eq!(\n+                            borrow_data.activation_location,\n+                            TwoPhaseActivation::NotActivated,\n+                            \"never found an activation for this borrow!\",\n+                        );\n+\n+                        self.activation_map\n+                            .entry(location)\n+                            .or_default()\n+                            .push(borrow_index);\n+                        TwoPhaseActivation::ActivatedAt(location)\n+                    }\n+                };\n             }\n         }\n     }"}, {"sha": "759b842e9dfee24731e9fb0493a18d165db6ffba", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 163, "deletions": 178, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -77,9 +77,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if move_out_indices.is_empty() {\n             let root_place = self.prefixes(&used_place, PrefixSet::All).last().unwrap();\n \n-            if self.uninitialized_error_reported\n-                .contains(&root_place.clone())\n-            {\n+            if self.uninitialized_error_reported.contains(root_place) {\n                 debug!(\n                     \"report_use_of_moved_or_uninitialized place: error about {:?} suppressed\",\n                     root_place\n@@ -188,11 +186,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         let tables = self.infcx.tcx.typeck_tables_of(id);\n                         let node_id = self.infcx.tcx.hir.as_local_node_id(id).unwrap();\n                         let hir_id = self.infcx.tcx.hir.node_to_hir_id(node_id);\n-                        if tables.closure_kind_origins().get(hir_id).is_some() {\n-                            false\n-                        } else {\n-                            true\n-                        }\n+\n+                        tables.closure_kind_origins().get(hir_id).is_none()\n                     }\n                     _ => true,\n                 };\n@@ -582,7 +577,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn report_local_value_does_not_live_long_enough(\n         &mut self,\n         context: Context,\n-        name: &String,\n+        name: &str,\n         scope_tree: &Lrc<ScopeTree>,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n@@ -1195,10 +1190,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Static(ref static_) => self.describe_field_from_ty(&static_.ty, field),\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Deref => self.describe_field(&proj.base, field),\n-                ProjectionElem::Downcast(def, variant_index) => format!(\n-                    \"{}\",\n-                    def.variants[variant_index].fields[field.index()].ident\n-                ),\n+                ProjectionElem::Downcast(def, variant_index) =>\n+                    def.variants[variant_index].fields[field.index()].ident.to_string(),\n                 ProjectionElem::Field(_, field_type) => {\n                     self.describe_field_from_ty(&field_type, field)\n                 }\n@@ -1366,191 +1359,184 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"annotate_argument_and_return_for_borrow: location={:?}\",\n             location\n         );\n-        match &self.mir[location.block]\n-            .statements\n-            .get(location.statement_index)\n+        if let Some(&Statement { kind: StatementKind::Assign(ref reservation, _), ..})\n+             = &self.mir[location.block].statements.get(location.statement_index)\n         {\n-            Some(&Statement {\n-                kind: StatementKind::Assign(ref reservation, _),\n-                ..\n-            }) => {\n+            debug!(\n+                \"annotate_argument_and_return_for_borrow: reservation={:?}\",\n+                reservation\n+            );\n+            // Check that the initial assignment of the reserve location is into a temporary.\n+            let mut target = *match reservation {\n+                Place::Local(local) if self.mir.local_kind(*local) == LocalKind::Temp => local,\n+                _ => return None,\n+            };\n+\n+            // Next, look through the rest of the block, checking if we are assigning the\n+            // `target` (that is, the place that contains our borrow) to anything.\n+            let mut annotated_closure = None;\n+            for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n                 debug!(\n-                    \"annotate_argument_and_return_for_borrow: reservation={:?}\",\n-                    reservation\n+                    \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n+                    target, stmt\n                 );\n-                // Check that the initial assignment of the reserve location is into a temporary.\n-                let mut target = *match reservation {\n-                    Place::Local(local) if self.mir.local_kind(*local) == LocalKind::Temp => local,\n-                    _ => return None,\n-                };\n-\n-                // Next, look through the rest of the block, checking if we are assigning the\n-                // `target` (that is, the place that contains our borrow) to anything.\n-                let mut annotated_closure = None;\n-                for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+                if let StatementKind::Assign(Place::Local(assigned_to), box rvalue) = &stmt.kind\n+                {\n                     debug!(\n-                        \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n-                        target, stmt\n+                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n+                         rvalue={:?}\",\n+                        assigned_to, rvalue\n                     );\n-                    if let StatementKind::Assign(Place::Local(assigned_to), box rvalue) = &stmt.kind\n+                    // Check if our `target` was captured by a closure.\n+                    if let Rvalue::Aggregate(\n+                        box AggregateKind::Closure(def_id, substs),\n+                        operands,\n+                    ) = rvalue\n                     {\n-                        debug!(\n-                            \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n-                             rvalue={:?}\",\n-                            assigned_to, rvalue\n-                        );\n-                        // Check if our `target` was captured by a closure.\n-                        if let Rvalue::Aggregate(\n-                            box AggregateKind::Closure(def_id, substs),\n-                            operands,\n-                        ) = rvalue\n-                        {\n-                            for operand in operands {\n-                                let assigned_from = match operand {\n-                                    Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                        assigned_from\n-                                    }\n-                                    _ => continue,\n-                                };\n-                                debug!(\n-                                    \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                        for operand in operands {\n+                            let assigned_from = match operand {\n+                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n                                     assigned_from\n-                                );\n-\n-                                // Find the local from the operand.\n-                                let assigned_from_local = match assigned_from.local() {\n-                                    Some(local) => local,\n-                                    None => continue,\n-                                };\n-\n-                                if assigned_from_local != target {\n-                                    continue;\n                                 }\n+                                _ => continue,\n+                            };\n+                            debug!(\n+                                \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                                assigned_from\n+                            );\n \n-                                // If a closure captured our `target` and then assigned\n-                                // into a place then we should annotate the closure in\n-                                // case it ends up being assigned into the return place.\n-                                annotated_closure = self.annotate_fn_sig(\n-                                    *def_id,\n-                                    self.infcx.closure_sig(*def_id, *substs),\n-                                );\n-                                debug!(\n-                                    \"annotate_argument_and_return_for_borrow: \\\n-                                     annotated_closure={:?} assigned_from_local={:?} \\\n-                                     assigned_to={:?}\",\n-                                    annotated_closure, assigned_from_local, assigned_to\n-                                );\n-\n-                                if *assigned_to == mir::RETURN_PLACE {\n-                                    // If it was assigned directly into the return place, then\n-                                    // return now.\n-                                    return annotated_closure;\n-                                } else {\n-                                    // Otherwise, update the target.\n-                                    target = *assigned_to;\n-                                }\n+                            // Find the local from the operand.\n+                            let assigned_from_local = match assigned_from.local() {\n+                                Some(local) => local,\n+                                None => continue,\n+                            };\n+\n+                            if assigned_from_local != target {\n+                                continue;\n                             }\n \n-                            // If none of our closure's operands matched, then skip to the next\n-                            // statement.\n-                            continue;\n+                            // If a closure captured our `target` and then assigned\n+                            // into a place then we should annotate the closure in\n+                            // case it ends up being assigned into the return place.\n+                            annotated_closure = self.annotate_fn_sig(\n+                                *def_id,\n+                                self.infcx.closure_sig(*def_id, *substs),\n+                            );\n+                            debug!(\n+                                \"annotate_argument_and_return_for_borrow: \\\n+                                 annotated_closure={:?} assigned_from_local={:?} \\\n+                                 assigned_to={:?}\",\n+                                annotated_closure, assigned_from_local, assigned_to\n+                            );\n+\n+                            if *assigned_to == mir::RETURN_PLACE {\n+                                // If it was assigned directly into the return place, then\n+                                // return now.\n+                                return annotated_closure;\n+                            } else {\n+                                // Otherwise, update the target.\n+                                target = *assigned_to;\n+                            }\n                         }\n \n-                        // Otherwise, look at other types of assignment.\n-                        let assigned_from = match rvalue {\n-                            Rvalue::Ref(_, _, assigned_from) => assigned_from,\n-                            Rvalue::Use(operand) => match operand {\n-                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                    assigned_from\n-                                }\n-                                _ => continue,\n-                            },\n-                            _ => continue,\n-                        };\n-                        debug!(\n-                            \"annotate_argument_and_return_for_borrow: \\\n-                             assigned_from={:?}\",\n-                            assigned_from,\n-                        );\n+                        // If none of our closure's operands matched, then skip to the next\n+                        // statement.\n+                        continue;\n+                    }\n \n-                        // Find the local from the rvalue.\n-                        let assigned_from_local = match assigned_from.local() {\n-                            Some(local) => local,\n-                            None => continue,\n-                        };\n-                        debug!(\n-                            \"annotate_argument_and_return_for_borrow: \\\n-                             assigned_from_local={:?}\",\n-                            assigned_from_local,\n-                        );\n+                    // Otherwise, look at other types of assignment.\n+                    let assigned_from = match rvalue {\n+                        Rvalue::Ref(_, _, assigned_from) => assigned_from,\n+                        Rvalue::Use(operand) => match operand {\n+                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                assigned_from\n+                            }\n+                            _ => continue,\n+                        },\n+                        _ => continue,\n+                    };\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: \\\n+                         assigned_from={:?}\",\n+                        assigned_from,\n+                    );\n \n-                        // Check if our local matches the target - if so, we've assigned our\n-                        // borrow to a new place.\n-                        if assigned_from_local != target {\n-                            continue;\n-                        }\n+                    // Find the local from the rvalue.\n+                    let assigned_from_local = match assigned_from.local() {\n+                        Some(local) => local,\n+                        None => continue,\n+                    };\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: \\\n+                         assigned_from_local={:?}\",\n+                        assigned_from_local,\n+                    );\n \n-                        // If we assigned our `target` into a new place, then we should\n-                        // check if it was the return place.\n-                        debug!(\n-                            \"annotate_argument_and_return_for_borrow: \\\n-                             assigned_from_local={:?} assigned_to={:?}\",\n-                            assigned_from_local, assigned_to\n-                        );\n-                        if *assigned_to == mir::RETURN_PLACE {\n-                            // If it was then return the annotated closure if there was one,\n-                            // else, annotate this function.\n-                            return annotated_closure.or_else(fallback);\n-                        }\n+                    // Check if our local matches the target - if so, we've assigned our\n+                    // borrow to a new place.\n+                    if assigned_from_local != target {\n+                        continue;\n+                    }\n \n-                        // If we didn't assign into the return place, then we just update\n-                        // the target.\n-                        target = *assigned_to;\n+                    // If we assigned our `target` into a new place, then we should\n+                    // check if it was the return place.\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: \\\n+                         assigned_from_local={:?} assigned_to={:?}\",\n+                        assigned_from_local, assigned_to\n+                    );\n+                    if *assigned_to == mir::RETURN_PLACE {\n+                        // If it was then return the annotated closure if there was one,\n+                        // else, annotate this function.\n+                        return annotated_closure.or_else(fallback);\n                     }\n+\n+                    // If we didn't assign into the return place, then we just update\n+                    // the target.\n+                    target = *assigned_to;\n                 }\n+            }\n \n-                // Check the terminator if we didn't find anything in the statements.\n-                let terminator = &self.mir[location.block].terminator();\n+            // Check the terminator if we didn't find anything in the statements.\n+            let terminator = &self.mir[location.block].terminator();\n+            debug!(\n+                \"annotate_argument_and_return_for_borrow: target={:?} terminator={:?}\",\n+                target, terminator\n+            );\n+            if let TerminatorKind::Call {\n+                destination: Some((Place::Local(assigned_to), _)),\n+                args,\n+                ..\n+            } = &terminator.kind\n+            {\n                 debug!(\n-                    \"annotate_argument_and_return_for_borrow: target={:?} terminator={:?}\",\n-                    target, terminator\n+                    \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n+                    assigned_to, args\n                 );\n-                if let TerminatorKind::Call {\n-                    destination: Some((Place::Local(assigned_to), _)),\n-                    args,\n-                    ..\n-                } = &terminator.kind\n-                {\n+                for operand in args {\n+                    let assigned_from = match operand {\n+                        Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                            assigned_from\n+                        }\n+                        _ => continue,\n+                    };\n                     debug!(\n-                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n-                        assigned_to, args\n+                        \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                        assigned_from,\n                     );\n-                    for operand in args {\n-                        let assigned_from = match operand {\n-                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                assigned_from\n-                            }\n-                            _ => continue,\n-                        };\n+\n+                    if let Some(assigned_from_local) = assigned_from.local() {\n                         debug!(\n-                            \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n-                            assigned_from,\n+                            \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n+                            assigned_from_local,\n                         );\n \n-                        if let Some(assigned_from_local) = assigned_from.local() {\n-                            debug!(\n-                                \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n-                                assigned_from_local,\n-                            );\n-\n-                            if *assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n-                                return annotated_closure.or_else(fallback);\n-                            }\n+                        if *assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n+                            return annotated_closure.or_else(fallback);\n                         }\n                     }\n                 }\n             }\n-            _ => {}\n         }\n \n         // If we haven't found an assignment into the return place, then we need not add\n@@ -1605,13 +1591,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // Need to use the `rustc::ty` types to compare against the\n                             // `return_region`. Then use the `rustc::hir` type to get only\n                             // the lifetime span.\n-                            match &fn_decl.inputs[index].node {\n-                                hir::TyKind::Rptr(lifetime, _) => {\n-                                    // With access to the lifetime, we can get\n-                                    // the span of it.\n-                                    arguments.push((*argument, lifetime.span));\n-                                }\n-                                _ => bug!(\"ty type is a ref but hir type is not\"),\n+                            if let hir::TyKind::Rptr(lifetime, _) = &fn_decl.inputs[index].node {\n+                                // With access to the lifetime, we can get\n+                                // the span of it.\n+                                arguments.push((*argument, lifetime.span));\n+                            } else {\n+                                bug!(\"ty type is a ref but hir type is not\");\n                             }\n                         }\n                     }\n@@ -1794,8 +1779,8 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                 ty::RegionKind::RePlaceholder(ty::Placeholder { name: br, .. }),\n                 _,\n                 _,\n-            ) => with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", ty)),\n-            _ => format!(\"{}\", ty),\n+            ) => with_highlight_region_for_bound_region(*br, counter, || ty.to_string()),\n+            _ => ty.to_string(),\n         }\n     }\n \n@@ -1806,9 +1791,9 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n             ty::TyKind::Ref(region, _, _) => match region {\n                 ty::RegionKind::ReLateBound(_, br)\n                 | ty::RegionKind::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n-                    with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", region))\n+                    with_highlight_region_for_bound_region(*br, counter, || region.to_string())\n                 }\n-                _ => format!(\"{}\", region),\n+                _ => region.to_string(),\n             },\n             _ => bug!(\"ty for annotation of borrow region is not a reference\"),\n         }"}, {"sha": "a7b356c146163e1c1d1989990183e64d8a4dcdac", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -284,7 +284,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let temporary_used_locals: FxHashSet<Local> = mbcx\n         .used_mut\n         .iter()\n-        .filter(|&local| !mbcx.mir.local_decls[*local].is_user_variable.is_some())\n+        .filter(|&local| mbcx.mir.local_decls[*local].is_user_variable.is_none())\n         .cloned()\n         .collect();\n     mbcx.gather_used_muts(temporary_used_locals);\n@@ -342,7 +342,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         diag.buffer(&mut mbcx.errors_buffer);\n     }\n \n-    if mbcx.errors_buffer.len() > 0 {\n+    if !mbcx.errors_buffer.is_empty() {\n         mbcx.errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n \n         if tcx.migrate_borrowck() {\n@@ -1009,13 +1009,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         return Control::Continue;\n                     }\n \n+                    error_reported = true;\n                     match kind {\n                         ReadKind::Copy  => {\n-                            error_reported = true;\n                             this.report_use_while_mutably_borrowed(context, place_span, borrow)\n                         }\n                         ReadKind::Borrow(bk) => {\n-                            error_reported = true;\n                             this.report_conflicting_borrow(context, place_span, bk, &borrow)\n                         }\n                     }\n@@ -1045,25 +1044,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         Read(..) | Write(..) => {}\n                     }\n \n+                    error_reported = true;\n                     match kind {\n                         WriteKind::MutableBorrow(bk) => {\n-                            error_reported = true;\n                             this.report_conflicting_borrow(context, place_span, bk, &borrow)\n                         }\n                         WriteKind::StorageDeadOrDrop => {\n-                            error_reported = true;\n                             this.report_borrowed_value_does_not_live_long_enough(\n                                 context,\n                                 borrow,\n                                 place_span,\n                                 Some(kind))\n                         }\n                         WriteKind::Mutate => {\n-                            error_reported = true;\n                             this.report_illegal_mutation_of_borrowed(context, place_span, borrow)\n                         }\n                         WriteKind::Move => {\n-                            error_reported = true;\n                             this.report_move_out_while_borrowed(context, place_span, &borrow)\n                         }\n                     }\n@@ -1593,7 +1589,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Local(_) => panic!(\"should have move path for every Local\"),\n             Place::Projection(_) => panic!(\"PrefixSet::All meant don't stop for Projection\"),\n             Place::Promoted(_) |\n-            Place::Static(_) => return Err(NoMovePathFound::ReachedStatic),\n+            Place::Static(_) => Err(NoMovePathFound::ReachedStatic),\n         }\n     }\n \n@@ -1885,18 +1881,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         // at this point, we have set up the error reporting state.\n-        if previously_initialized {\n+        return if previously_initialized {\n             self.report_mutability_error(\n                 place,\n                 span,\n                 the_place_err,\n                 error_access,\n                 location,\n             );\n-            return true;\n+            true\n         } else {\n-            return false;\n-        }\n+            false\n+        };\n     }\n \n     fn is_local_ever_initialized(&self,\n@@ -1911,7 +1907,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 return Some(index);\n             }\n         }\n-        return None;\n+        None\n     }\n \n     /// Adds the place into the used mutable variables set\n@@ -2171,7 +2167,7 @@ impl ContextKind {\n     fn new(self, loc: Location) -> Context {\n         Context {\n             kind: self,\n-            loc: loc,\n+            loc,\n         }\n     }\n }"}, {"sha": "a556199b875bf343d046e73740224d0a6b4adcc1", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             _ => {\n                                 let source = self.borrowed_content_source(place);\n                                 self.infcx.tcx.cannot_move_out_of(\n-                                    span, &format!(\"{}\", source), origin\n+                                    span, &source.to_string(), origin\n                                 )\n                             },\n                         }\n@@ -469,9 +469,9 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             let binding_span = bind_to.source_info.span;\n \n             if j == 0 {\n-                err.span_label(binding_span, format!(\"data moved here\"));\n+                err.span_label(binding_span, \"data moved here\");\n             } else {\n-                err.span_label(binding_span, format!(\"...and here\"));\n+                err.span_label(binding_span, \"...and here\");\n             }\n \n             if binds_to.len() == 1 {"}, {"sha": "30f4fc9d5ea231388159297f0850924e507bf7b1", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -408,7 +408,6 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             .map(|replacement| (pattern_span, replacement))\n                     }\n \n-                    //\n                     ClearCrossCrate::Set(mir::BindingForm::RefForGuard) => unreachable!(),\n \n                     ClearCrossCrate::Clear => bug!(\"saw cleared local state\"),\n@@ -505,7 +504,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                                 );\n \n                                 let extra = if found {\n-                                    String::from(\"\")\n+                                    String::new()\n                                 } else {\n                                     format!(\", but it is not implemented for `{}`\",\n                                             substs.type_at(0))\n@@ -573,7 +572,7 @@ fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n     opt_ty_info: Option<Span>,\n ) -> (Span, String) {\n     let locations = mir.find_assignments(local);\n-    if locations.len() > 0 {\n+    if !locations.is_empty() {\n         let assignment_rhs_span = mir.source_info(locations[0]).span;\n         if let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span) {\n             if let (true, Some(ws_pos)) = (\n@@ -584,7 +583,7 @@ fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n                 let ty = &src[ws_pos..];\n                 return (assignment_rhs_span, format!(\"&{} mut {}\", lt_name, ty));\n             } else if src.starts_with('&') {\n-                let borrowed_expr = src[1..].to_string();\n+                let borrowed_expr = &src[1..];\n                 return (assignment_rhs_span, format!(\"&mut {}\", borrowed_expr));\n             }\n         }"}, {"sha": "495e84528a3c3266d0eb8f9b34dba6158a00248a", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -141,6 +141,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         if let Some(all_facts) = self.all_facts {\n             if let Place::Local(temp) = place {\n                 if let Some(borrow_indices) = self.borrow_set.local_map.get(temp) {\n+                    all_facts.killed.reserve(borrow_indices.len());\n                     for &borrow_index in borrow_indices {\n                         let location_index = self.location_table.mid_index(location);\n                         all_facts.killed.push((borrow_index, location_index));\n@@ -164,7 +165,9 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n                 self.location_table.mid_index(location),\n             ));\n \n-            for successor_block in terminator.successors() {\n+            let successor_blocks = terminator.successors();\n+            all_facts.cfg_edge.reserve(successor_blocks.size_hint().0);\n+            for successor_block in successor_blocks {\n                 all_facts.cfg_edge.push((\n                     self.location_table.mid_index(location),\n                     self.location_table"}, {"sha": "a0f832c54493430ff52b70f6d362e2457b4f73cb", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -87,9 +87,9 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                     // Otherwise, just report the whole type (and use\n                     // the intentionally fuzzy phrase \"destructor\")\n                     ty::Closure(..) =>\n-                        (\"destructor\", format!(\"closure\")),\n+                        (\"destructor\", \"closure\".to_owned()),\n                     ty::Generator(..) =>\n-                        (\"destructor\", format!(\"generator\")),\n+                        (\"destructor\", \"generator\".to_owned()),\n \n                     _ => (\"destructor\", format!(\"type `{}`\", local_decl.ty)),\n                 };\n@@ -279,9 +279,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         pending_locations.push(target.start_location());\n                     },\n                     TerminatorKind::SwitchInt { ref targets, .. } => {\n-                        for target in targets {\n-                            pending_locations.push(target.start_location());\n-                        }\n+                        pending_locations.extend(\n+                            targets.into_iter().map(|target| target.start_location()));\n                     },\n                     TerminatorKind::Drop { target, unwind, .. } |\n                     TerminatorKind::DropAndReplace { target, unwind, .. } |\n@@ -303,9 +302,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     },\n                     TerminatorKind::FalseEdges { real_target, ref imaginary_targets, .. } => {\n                         pending_locations.push(real_target.start_location());\n-                        for target in imaginary_targets {\n-                            pending_locations.push(target.start_location());\n-                        }\n+                        pending_locations.extend(\n+                            imaginary_targets.into_iter().map(|target| target.start_location()));\n                     },\n                     _ => {},\n                 }\n@@ -441,17 +439,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             Operand::Move(Place::Local(from)) if *from == target => {\n                                 debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n                                 // Check the type for a trait object.\n-                                match ty.sty {\n+                                return match ty.sty {\n                                     // `&dyn Trait`\n-                                    ty::TyKind::Ref(_, ty, _) if ty.is_trait() => return true,\n+                                    ty::TyKind::Ref(_, ty, _) if ty.is_trait() => true,\n                                     // `Box<dyn Trait>`\n                                     _ if ty.is_box() && ty.boxed_ty().is_trait() =>\n-                                        return true,\n+                                        true,\n                                     // `dyn Trait`\n-                                    _ if ty.is_trait() => return true,\n+                                    _ if ty.is_trait() => true,\n                                     // Anything else.\n-                                    _ => return false,\n-                                }\n+                                    _ => false,\n+                                };\n                             },\n                             _ => return false,\n                         },\n@@ -466,32 +464,29 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let terminator = block.terminator();\n                 debug!(\"was_captured_by_trait_object: terminator={:?}\", terminator);\n \n-                match &terminator.kind {\n-                    TerminatorKind::Call {\n-                        destination: Some((Place::Local(dest), block)),\n-                        args,\n-                        ..\n-                    } => {\n-                        debug!(\n-                            \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n-                            target, dest, args\n-                        );\n-                        // Check if one of the arguments to this function is the target place.\n-                        let found_target = args.iter().any(|arg| {\n-                            if let Operand::Move(Place::Local(potential)) = arg {\n-                                *potential == target\n-                            } else {\n-                                false\n-                            }\n-                        });\n-\n-                        // If it is, follow this to the next block and update the target.\n-                        if found_target {\n-                            target = *dest;\n-                            queue.push(block.start_location());\n+                if let TerminatorKind::Call {\n+                    destination: Some((Place::Local(dest), block)),\n+                    args,\n+                    ..\n+                } = &terminator.kind {\n+                    debug!(\n+                        \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n+                        target, dest, args\n+                    );\n+                    // Check if one of the arguments to this function is the target place.\n+                    let found_target = args.iter().any(|arg| {\n+                        if let Operand::Move(Place::Local(potential)) = arg {\n+                            *potential == target\n+                        } else {\n+                            false\n                         }\n-                    },\n-                    _ => {},\n+                    });\n+\n+                    // If it is, follow this to the next block and update the target.\n+                    if found_target {\n+                        target = *dest;\n+                        queue.push(block.start_location());\n+                    }\n                 }\n             }\n "}, {"sha": "002f35880ae6b92d1dda52012b3f8cab6e747c89", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -35,7 +35,7 @@ pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n     mir: &Mir<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n ) {\n-    if !all_facts.is_some() {\n+    if all_facts.is_none() {\n         // Nothing to do if we don't have any facts\n         return;\n     }"}, {"sha": "268a37c70868151cb34455724fb96806b666a6ca", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -36,12 +36,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 let outlived_by = self.universal_region_relations.regions_outlived_by(region);\n                 writeln!(\n                     out,\n-                    \"| {r:rw$} | {c:cw$} | {ob}\",\n-                    r = format!(\"{:?}\", region),\n+                    \"| {r:rw$?} | {c:cw$?} | {ob:?}\",\n+                    r = region,\n                     rw = REGION_WIDTH,\n-                    c = format!(\"{:?}\", classification),\n+                    c = classification,\n                     cw = 8, // \"External\" at most\n-                    ob = format!(\"{:?}\", outlived_by)\n+                    ob = outlived_by\n                 )?;\n             }\n         }\n@@ -51,8 +51,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for region in self.regions() {\n             writeln!(\n                 out,\n-                \"| {r:rw$} | {ui:4?} | {v}\",\n-                r = format!(\"{:?}\", region),\n+                \"| {r:rw$?} | {ui:4?} | {v}\",\n+                r = region,\n                 rw = REGION_WIDTH,\n                 ui = self.region_universe(region),\n                 v = self.region_value_str(region),"}, {"sha": "5ff50c606d641c6e17e143a1ec3f8650f1dbe091", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -550,7 +550,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     let span = infcx.tcx.def_span(*did);\n                     if let Ok(snippet) = infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         let suggestable_fr_name = if fr_name.was_named() {\n-                            format!(\"{}\", fr_name)\n+                            fr_name.to_string()\n                         } else {\n                             \"'_\".to_string()\n                         };"}, {"sha": "e07dfda406b19052ad87487f2a148204b07bcb6e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -462,9 +462,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_hir_ty: &hir::Ty,\n         counter: &mut usize,\n     ) -> Option<RegionName> {\n-        let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty)> = &mut Vec::new();\n-\n-        search_stack.push((argument_ty, argument_hir_ty));\n+        let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty)> =\n+            &mut vec![(argument_ty, argument_hir_ty)];\n \n         while let Some((ty, hir_ty)) = search_stack.pop() {\n             match (&ty.sty, &hir_ty.node) {\n@@ -567,10 +566,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             | hir::LifetimeName::Underscore => {\n                 let region_name = self.synthesize_region_name(counter);\n                 let ampersand_span = lifetime.span;\n-                return Some(RegionName {\n+                Some(RegionName {\n                     name: region_name,\n                     source: RegionNameSource::MatchedAdtAndSegment(ampersand_span),\n-                });\n+                })\n             }\n \n             hir::LifetimeName::Implicit => {\n@@ -585,7 +584,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // T>`. We don't consider this a match; instead we let\n                 // the \"fully elaborated\" type fallback above handle\n                 // it.\n-                return None;\n+                None\n             }\n         }\n     }"}, {"sha": "f5e824b7628887724b86c80d240cc226f0da2e64", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -327,12 +327,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait\n-                let trait_ref = data.principal().with_self_ty(\n-                    *self.tcx,\n-                    src_pointee_ty,\n-                );\n-                let trait_ref = self.tcx.erase_regions(&trait_ref);\n-                let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n+                let vtable = self.get_vtable(src_pointee_ty, data.principal())?;\n                 let ptr = self.read_value(src)?.to_scalar_ptr()?;\n                 let val = Value::new_dyn_trait(ptr, vtable);\n                 self.write_value(val, dest)"}, {"sha": "cf5358a9896720365448dc3b7f741eb56c608926", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -27,6 +27,7 @@ use rustc::mir::interpret::{\n     EvalResult, EvalErrorKind,\n     truncate, sign_extend,\n };\n+use rustc_data_structures::fx::FxHashMap;\n \n use syntax::source_map::{self, Span};\n \n@@ -50,6 +51,9 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n \n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'mir, 'tcx, M::PointerTag>>,\n+\n+    /// A cache for deduplicating vtables\n+    pub(super) vtables: FxHashMap<(Ty<'tcx>, ty::PolyExistentialTraitRef<'tcx>), AllocId>,\n }\n \n /// A stack frame.\n@@ -209,6 +213,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             param_env,\n             memory: Memory::new(tcx, memory_data),\n             stack: Vec::new(),\n+            vtables: FxHashMap::default(),\n         }\n     }\n "}, {"sha": "2d6b19ca4a7fcc42b44e0d06426bf00ef1a27593", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -688,9 +688,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         rval: OpTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, (u128, usize)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n-        if rval.layout.abi.is_uninhabited() {\n-            return err!(Unreachable);\n-        }\n \n         match rval.layout.variants {\n             layout::Variants::Single { index } => {"}, {"sha": "2b0febc1ce717eb507740c88029c639dc9adc97c", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -24,20 +24,32 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn get_vtable(\n         &mut self,\n         ty: Ty<'tcx>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        poly_trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n     ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n-        debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n+        debug!(\"get_vtable(trait_ref={:?})\", poly_trait_ref);\n \n-        // FIXME: Cache this!\n+        let (ty, poly_trait_ref) = self.tcx.erase_regions(&(ty, poly_trait_ref));\n \n-        let layout = self.layout_of(trait_ref.self_ty())?;\n+        if let Some(&vtable) = self.vtables.get(&(ty, poly_trait_ref)) {\n+            return Ok(Pointer::from(vtable).with_default_tag());\n+        }\n+\n+        let trait_ref = poly_trait_ref.with_self_ty(*self.tcx, ty);\n+        let trait_ref = self.tcx.erase_regions(&trait_ref);\n+\n+        let methods = self.tcx.vtable_methods(trait_ref);\n+\n+        let layout = self.layout_of(ty)?;\n         assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n         let size = layout.size.bytes();\n         let align = layout.align.abi();\n \n         let ptr_size = self.pointer_size();\n         let ptr_align = self.tcx.data_layout.pointer_align;\n-        let methods = self.tcx.vtable_methods(trait_ref);\n+        // /////////////////////////////////////////////////////////////////////////////////////////\n+        // If you touch this code, be sure to also make the corresponding changes to\n+        // `get_vtable` in rust_codegen_llvm/meth.rs\n+        // /////////////////////////////////////////////////////////////////////////////////////////\n         let vtable = self.memory.allocate(\n             ptr_size * (3 + methods.len() as u64),\n             ptr_align,\n@@ -64,6 +76,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         }\n \n         self.memory.mark_immutable(vtable.alloc_id)?;\n+        assert!(self.vtables.insert((ty, poly_trait_ref), vtable.alloc_id).is_none());\n \n         Ok(vtable)\n     }"}, {"sha": "ac0616e50b0913938a088bbc4c3bcb8f2eb2a53c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -1980,9 +1980,15 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         }\n \n         if !module.no_implicit_prelude {\n-            // `record_used` means that we don't try to load crates during speculative resolution\n-            if record_used && ns == TypeNS && self.extern_prelude.contains(&ident.name) {\n-                let crate_id = self.crate_loader.process_path_extern(ident.name, ident.span);\n+            if ns == TypeNS && self.extern_prelude.contains(&ident.name) {\n+                let crate_id = if record_used {\n+                    self.crate_loader.process_path_extern(ident.name, ident.span)\n+                } else if let Some(crate_id) =\n+                        self.crate_loader.maybe_process_path_extern(ident.name, ident.span) {\n+                    crate_id\n+                } else {\n+                    return None;\n+                };\n                 let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 self.populate_module_if_necessary(&crate_root);\n "}, {"sha": "445fc2e833a3f503b570edcbf1a3e2f959fdda3d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -553,6 +553,9 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n             f.write_str(name)\n         }\n         clean::ResolvedPath{ did, ref typarams, ref path, is_generic } => {\n+            if typarams.is_some() {\n+                f.write_str(\"dyn \")?;\n+            }\n             // Paths like T::Output and Self::Output should be rendered with all segments\n             resolved_path(f, did, path, is_generic, use_absolute)?;\n             tybounds(f, typarams)"}, {"sha": "6868c7707adc897a3c33cdab23da2f73245eb5e1", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -83,6 +83,7 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n             <div class=\\\"search-container\\\">\\\n                 <input class=\\\"search-input\\\" name=\\\"search\\\" \\\n                        autocomplete=\\\"off\\\" \\\n+                       spellcheck=\\\"false\\\" \\\n                        placeholder=\\\"Click or press \u2018S\u2019 to search, \u2018?\u2019 for more options\u2026\\\" \\\n                        type=\\\"search\\\">\\\n                 <a id=\\\"settings-menu\\\" href=\\\"{root_path}settings.html\\\">\\"}, {"sha": "e10e330402f5edf3ca56fae7f527ab7bad8cdcb2", "filename": "src/librustdoc/html/static/storage.js", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -26,16 +26,34 @@ function onEach(arr, func) {\n     return false;\n }\n \n+function usableLocalStorage() {\n+    // Check if the browser supports localStorage at all:\n+    if (typeof(Storage) === \"undefined\") {\n+        return false;\n+    }\n+    // Check if we can access it; this access will fail if the browser\n+    // preferences deny access to localStorage, e.g., to prevent storage of\n+    // \"cookies\" (or cookie-likes, as is the case here).\n+    try {\n+        window.localStorage;\n+    } catch(err) {\n+        // Storage is supported, but browser preferences deny access to it.\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n function updateLocalStorage(name, value) {\n-    if (typeof(Storage) !== \"undefined\") {\n+    if (usableLocalStorage()) {\n         localStorage[name] = value;\n     } else {\n         // No Web Storage support so we do nothing\n     }\n }\n \n function getCurrentValue(name) {\n-    if (typeof(Storage) !== \"undefined\" && localStorage[name] !== undefined) {\n+    if (usableLocalStorage() && localStorage[name] !== undefined) {\n         return localStorage[name];\n     }\n     return null;"}, {"sha": "c1f0a6fecefe90d05b1f5fbd53695a6fe2066827", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -650,15 +650,17 @@ pub fn panicking() -> bool {\n     panicking::panicking()\n }\n \n-/// Puts the current thread to sleep for the specified amount of time.\n+/// Puts the current thread to sleep for at least the specified amount of time.\n ///\n /// The thread may sleep longer than the duration specified due to scheduling\n-/// specifics or platform-dependent functionality.\n+/// specifics or platform-dependent functionality. It will never sleep less.\n ///\n /// # Platform-specific behavior\n ///\n-/// On Unix platforms this function will not return early due to a\n-/// signal being received or a spurious wakeup.\n+/// On Unix platforms, the underlying syscall may be interrupted by a\n+/// spurious wakeup or signal handler. To ensure the sleep occurs for at least\n+/// the specified duration, this function may invoke that system call multiple\n+/// times.\n ///\n /// # Examples\n ///\n@@ -674,17 +676,19 @@ pub fn sleep_ms(ms: u32) {\n     sleep(Duration::from_millis(ms as u64))\n }\n \n-/// Puts the current thread to sleep for the specified amount of time.\n+/// Puts the current thread to sleep for at least the specified amount of time.\n ///\n /// The thread may sleep longer than the duration specified due to scheduling\n-/// specifics or platform-dependent functionality.\n+/// specifics or platform-dependent functionality. It will never sleep less.\n ///\n /// # Platform-specific behavior\n ///\n-/// On Unix platforms this function will not return early due to a\n-/// signal being received or a spurious wakeup. Platforms which do not support\n-/// nanosecond precision for sleeping will have `dur` rounded up to the nearest\n-/// granularity of time they can sleep for.\n+/// On Unix platforms, the underlying syscall may be interrupted by a\n+/// spurious wakeup or signal handler. To ensure the sleep occurs for at least\n+/// the specified duration, this function may invoke that system call multiple\n+/// times.\n+/// Platforms which do not support nanosecond precision for sleeping will\n+/// have `dur` rounded up to the nearest granularity of time they can sleep for.\n ///\n /// # Examples\n ///"}, {"sha": "d11a42bb0ed139d8bdf4027120eecc9d9f9bec56", "filename": "src/test/debuginfo/lexical-scope-with-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // min-lldb-version: 310\n-// ignore-macos FIXME #48807\n+// ignore-lldb FIXME #48807\n \n // compile-flags:-g -Zdebug-macros\n "}, {"sha": "372f34454de927508e770c45ecf39b37bec9a5bb", "filename": "src/test/run-pass/extern/extern-prelude-no-speculative.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Frun-pass%2Fextern%2Fextern-prelude-no-speculative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Frun-pass%2Fextern%2Fextern-prelude-no-speculative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern%2Fextern-prelude-no-speculative.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -10,7 +10,7 @@\n \n // run-pass\n #![allow(unused_variables)]\n-// compile-flags: --extern LooksLikeExternCrate=/path/to/nowhere\n+// compile-flags: --extern LooksLikeExternCrate\n \n mod m {\n     pub struct LooksLikeExternCrate;"}, {"sha": "cbb2a00214a5a30458589108ebba6ad49bc05323", "filename": "src/test/rustdoc/assoc-consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-consts.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -52,7 +52,7 @@ pub fn f(_: &(ToString + 'static)) {}\n \n impl Bar {\n     // @has assoc_consts/struct.Bar.html '//*[@id=\"associatedconstant.F\"]' \\\n-    //      \"const F: fn(_: &(ToString + 'static))\"\n+    //      \"const F: fn(_: &(dyn ToString + 'static))\"\n     pub const F: fn(_: &(ToString + 'static)) = f;\n }\n "}, {"sha": "c55a69bcb7bc5f5414bfa1052ac106f0fb40ed7b", "filename": "src/test/rustdoc/inline_cross/issue-32881.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-32881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-32881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-32881.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -15,8 +15,8 @@\n extern crate rustdoc_trait_object_impl;\n \n // @has issue_32881/trait.Bar.html\n-// @has - '//code' \"impl<'a> Bar\"\n-// @has - '//code' \"impl<'a> Debug for Bar\"\n+// @has - '//code' \"impl<'a> dyn Bar\"\n+// @has - '//code' \"impl<'a> Debug for dyn Bar\"\n \n pub use rustdoc_trait_object_impl::Bar;\n "}, {"sha": "0c9452fa1e1af218b033fd8eec6231dca2b475dc", "filename": "src/test/rustdoc/test-parens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Frustdoc%2Ftest-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Frustdoc%2Ftest-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftest-parens.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -11,5 +11,5 @@\n #![crate_name = \"foo\"]\n \n // @has foo/fn.foo.html\n-// @has - '//*[@class=\"rust fn\"]' \"_: &(ToString + 'static)\"\n+// @has - '//*[@class=\"rust fn\"]' \"_: &(dyn ToString + 'static)\"\n pub fn foo(_: &(ToString + 'static)) {}"}, {"sha": "0749900986d2e4e7e94619d702b52a4926c9fce7", "filename": "src/test/ui/borrowck/issue-54597-reject-move-out-of-borrow-via-pat.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fborrowck%2Fissue-54597-reject-move-out-of-borrow-via-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fborrowck%2Fissue-54597-reject-move-out-of-borrow-via-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54597-reject-move-out-of-borrow-via-pat.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -0,0 +1,22 @@\n+#![feature(nll)]\n+\n+#![allow(dead_code)]\n+\n+#[derive(Debug)]\n+struct Value;\n+impl Value {\n+    fn as_array(&self) -> Option<&Vec<Value>> {\n+        None\n+    }\n+}\n+\n+fn foo(val: Value) {\n+    let _reviewers_original: Vec<Value> = match val.as_array() {\n+        Some(array) => {\n+            *array\n+        }\n+        None => vec![]\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "6a12016b2a5e3b62ea17f37ee673f340e1ae5468", "filename": "src/test/ui/borrowck/issue-54597-reject-move-out-of-borrow-via-pat.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fborrowck%2Fissue-54597-reject-move-out-of-borrow-via-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fborrowck%2Fissue-54597-reject-move-out-of-borrow-via-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54597-reject-move-out-of-borrow-via-pat.stderr?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -0,0 +1,12 @@\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/issue-54597-reject-move-out-of-borrow-via-pat.rs:16:13\n+   |\n+LL |             *array\n+   |             ^^^^^^\n+   |             |\n+   |             cannot move out of borrowed content\n+   |             help: consider removing the `*`: `array`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0507`."}, {"sha": "8eaeafa5207df828c4d354116c319ef11dd2ef6b", "filename": "src/test/ui/impl-trait/auxiliary/extra-item.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fimpl-trait%2Fauxiliary%2Fextra-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fimpl-trait%2Fauxiliary%2Fextra-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauxiliary%2Fextra-item.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -0,0 +1 @@\n+pub trait MyTrait {}"}, {"sha": "d82237ccecc7ddd14dad8eaa3298a6e265f9c10c", "filename": "src/test/ui/impl-trait/extra-item.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fimpl-trait%2Fextra-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fimpl-trait%2Fextra-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fextra-item.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -0,0 +1,10 @@\n+// aux-build:extra-item.rs\n+// compile-flags:--extern extra_item\n+\n+struct S;\n+\n+impl extra_item::MyTrait for S {\n+    fn extra() {} //~ ERROR method `extra` is not a member of trait `extra_item::MyTrait`\n+}\n+\n+fn main() {}"}, {"sha": "de3c7ba5d3118151465488085ec0f6d86a1a25d2", "filename": "src/test/ui/impl-trait/extra-item.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fimpl-trait%2Fextra-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fimpl-trait%2Fextra-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fextra-item.stderr?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -0,0 +1,9 @@\n+error[E0407]: method `extra` is not a member of trait `extra_item::MyTrait`\n+  --> $DIR/extra-item.rs:7:5\n+   |\n+LL |     fn extra() {} //~ ERROR method `extra` is not a member of trait `extra_item::MyTrait`\n+   |     ^^^^^^^^^^^^^ not a member of trait `extra_item::MyTrait`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0407`."}, {"sha": "bcdfcc767fb9e4a82a53500282a242de4fd19b38", "filename": "src/test/ui/issues/issue-34229.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fissues%2Fissue-34229.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fissues%2Fissue-34229.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34229.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -0,0 +1,4 @@\n+#[derive(PartialEq)] struct Comparable;\n+#[derive(PartialEq, PartialOrd)] struct Nope(Comparable);\n+\n+fn main() {}"}, {"sha": "c57f80cd4091c1f3d99c407cf5d040857e563b11", "filename": "src/test/ui/issues/issue-34229.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fissues%2Fissue-34229.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftest%2Fui%2Fissues%2Fissue-34229.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34229.stderr?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: can't compare `Comparable` with `Comparable`\n+  --> $DIR/issue-34229.rs:2:46\n+   |\n+LL | #[derive(PartialEq, PartialOrd)] struct Nope(Comparable);\n+   |                                              ^^^^^^^^^^ no implementation for `Comparable < Comparable` and `Comparable > Comparable`\n+   |\n+   = help: the trait `std::cmp::PartialOrd` is not implemented for `Comparable`\n+   = note: required by `std::cmp::PartialOrd::partial_cmp`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "fab2ea7ba6c36d58e4501af5615e6b35f2b5d9cf", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -25,6 +25,7 @@ pub enum Mode {\n     RunPass,\n     RunPassValgrind,\n     Pretty,\n+    DebugInfoBoth,\n     DebugInfoGdb,\n     DebugInfoLldb,\n     Codegen,\n@@ -60,6 +61,7 @@ impl FromStr for Mode {\n             \"run-pass\" => Ok(RunPass),\n             \"run-pass-valgrind\" => Ok(RunPassValgrind),\n             \"pretty\" => Ok(Pretty),\n+            \"debuginfo-both\" => Ok(DebugInfoBoth),\n             \"debuginfo-lldb\" => Ok(DebugInfoLldb),\n             \"debuginfo-gdb\" => Ok(DebugInfoGdb),\n             \"codegen\" => Ok(Codegen),\n@@ -83,6 +85,7 @@ impl fmt::Display for Mode {\n             RunPass => \"run-pass\",\n             RunPassValgrind => \"run-pass-valgrind\",\n             Pretty => \"pretty\",\n+            DebugInfoBoth => \"debuginfo-both\",\n             DebugInfoGdb => \"debuginfo-gdb\",\n             DebugInfoLldb => \"debuginfo-lldb\",\n             Codegen => \"codegen\","}, {"sha": "06eeef61a194ddf3e535e77c979df2add9bce39c", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 130, "deletions": 27, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -19,10 +19,62 @@ use util;\n \n use extract_gdb_version;\n \n+/// Whether to ignore the test.\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub enum Ignore {\n+    /// Run it.\n+    Run,\n+    /// Ignore it totally.\n+    Ignore,\n+    /// Ignore only the gdb test, but run the lldb test.\n+    IgnoreGdb,\n+    /// Ignore only the lldb test, but run the gdb test.\n+    IgnoreLldb,\n+}\n+\n+impl Ignore {\n+    pub fn can_run_gdb(&self) -> bool {\n+        *self == Ignore::Run || *self == Ignore::IgnoreLldb\n+    }\n+\n+    pub fn can_run_lldb(&self) -> bool {\n+        *self == Ignore::Run || *self == Ignore::IgnoreGdb\n+    }\n+\n+    pub fn no_gdb(&self) -> Ignore {\n+        match *self {\n+            Ignore::Run => Ignore::IgnoreGdb,\n+            Ignore::IgnoreGdb => Ignore::IgnoreGdb,\n+            _ => Ignore::Ignore,\n+        }\n+    }\n+\n+    pub fn no_lldb(&self) -> Ignore {\n+        match *self {\n+            Ignore::Run => Ignore::IgnoreLldb,\n+            Ignore::IgnoreLldb => Ignore::IgnoreLldb,\n+            _ => Ignore::Ignore,\n+        }\n+    }\n+}\n+\n+/// The result of parse_cfg_name_directive.\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+enum ParsedNameDirective {\n+    /// No match.\n+    NoMatch,\n+    /// Match.\n+    Match,\n+    /// Mode was DebugInfoBoth and this matched gdb.\n+    MatchGdb,\n+    /// Mode was DebugInfoBoth and this matched lldb.\n+    MatchLldb,\n+}\n+\n /// Properties which must be known very early, before actually running\n /// the test.\n pub struct EarlyProps {\n-    pub ignore: bool,\n+    pub ignore: Ignore,\n     pub should_fail: bool,\n     pub aux: Vec<String>,\n     pub revisions: Vec<String>,\n@@ -31,20 +83,55 @@ pub struct EarlyProps {\n impl EarlyProps {\n     pub fn from_file(config: &Config, testfile: &Path) -> Self {\n         let mut props = EarlyProps {\n-            ignore: false,\n+            ignore: Ignore::Run,\n             should_fail: false,\n             aux: Vec::new(),\n             revisions: vec![],\n         };\n \n+        if config.mode == common::DebugInfoBoth {\n+            if config.lldb_python_dir.is_none() {\n+                props.ignore = props.ignore.no_lldb();\n+            }\n+            if config.gdb_version.is_none() {\n+                props.ignore = props.ignore.no_gdb();\n+            }\n+        }\n+\n         iter_header(testfile, None, &mut |ln| {\n             // we should check if any only-<platform> exists and if it exists\n             // and does not matches the current platform, skip the test\n-            props.ignore = props.ignore || config.parse_cfg_name_directive(ln, \"ignore\")\n-                || (config.has_cfg_prefix(ln, \"only\")\n-                    && !config.parse_cfg_name_directive(ln, \"only\"))\n-                || ignore_gdb(config, ln) || ignore_lldb(config, ln)\n-                || ignore_llvm(config, ln);\n+            if props.ignore != Ignore::Ignore {\n+                props.ignore = match config.parse_cfg_name_directive(ln, \"ignore\") {\n+                    ParsedNameDirective::Match => Ignore::Ignore,\n+                    ParsedNameDirective::NoMatch => props.ignore,\n+                    ParsedNameDirective::MatchGdb => props.ignore.no_gdb(),\n+                    ParsedNameDirective::MatchLldb => props.ignore.no_lldb(),\n+                };\n+\n+                if config.has_cfg_prefix(ln, \"only\") {\n+                    props.ignore = match config.parse_cfg_name_directive(ln, \"only\") {\n+                        ParsedNameDirective::Match => props.ignore,\n+                        ParsedNameDirective::NoMatch => Ignore::Ignore,\n+                        ParsedNameDirective::MatchLldb => props.ignore.no_gdb(),\n+                        ParsedNameDirective::MatchGdb => props.ignore.no_lldb(),\n+                    };\n+                }\n+\n+                if ignore_llvm(config, ln) {\n+                    props.ignore = Ignore::Ignore;\n+                }\n+            }\n+\n+            if (config.mode == common::DebugInfoGdb || config.mode == common::DebugInfoBoth) &&\n+                props.ignore.can_run_gdb() && ignore_gdb(config, ln) {\n+                props.ignore = props.ignore.no_gdb();\n+            }\n+\n+            if (config.mode == common::DebugInfoLldb || config.mode == common::DebugInfoBoth) &&\n+                props.ignore.can_run_lldb() && ignore_lldb(config, ln) {\n+                props.ignore = props.ignore.no_lldb();\n+            }\n \n             if let Some(s) = config.parse_aux_build(ln) {\n                 props.aux.push(s);\n@@ -60,10 +147,6 @@ impl EarlyProps {\n         return props;\n \n         fn ignore_gdb(config: &Config, line: &str) -> bool {\n-            if config.mode != common::DebugInfoGdb {\n-                return false;\n-            }\n-\n             if let Some(actual_version) = config.gdb_version {\n                 if line.starts_with(\"min-gdb-version\") {\n                     let (start_ver, end_ver) = extract_gdb_version_range(line);\n@@ -120,10 +203,6 @@ impl EarlyProps {\n         }\n \n         fn ignore_lldb(config: &Config, line: &str) -> bool {\n-            if config.mode != common::DebugInfoLldb {\n-                return false;\n-            }\n-\n             if let Some(ref actual_version) = config.lldb_version {\n                 if line.starts_with(\"min-lldb-version\") {\n                     let min_version = line.trim_right()\n@@ -604,7 +683,7 @@ impl Config {\n     }\n \n     fn parse_custom_normalization(&self, mut line: &str, prefix: &str) -> Option<(String, String)> {\n-        if self.parse_cfg_name_directive(line, prefix) {\n+        if self.parse_cfg_name_directive(line, prefix) == ParsedNameDirective::Match {\n             let from = match parse_normalization_string(&mut line) {\n                 Some(s) => s,\n                 None => return None,\n@@ -620,35 +699,59 @@ impl Config {\n     }\n \n     /// Parses a name-value directive which contains config-specific information, e.g. `ignore-x86`\n-    /// or `normalize-stderr-32bit`. Returns `true` if the line matches it.\n-    fn parse_cfg_name_directive(&self, line: &str, prefix: &str) -> bool {\n+    /// or `normalize-stderr-32bit`.\n+    fn parse_cfg_name_directive(&self, line: &str, prefix: &str) -> ParsedNameDirective {\n         if line.starts_with(prefix) && line.as_bytes().get(prefix.len()) == Some(&b'-') {\n             let name = line[prefix.len() + 1..]\n                 .split(&[':', ' '][..])\n                 .next()\n                 .unwrap();\n \n-            name == \"test\" ||\n+            if name == \"test\" ||\n                 util::matches_os(&self.target, name) ||             // target\n                 name == util::get_arch(&self.target) ||             // architecture\n                 name == util::get_pointer_width(&self.target) ||    // pointer width\n                 name == self.stage_id.split('-').next().unwrap() || // stage\n                 Some(name) == util::get_env(&self.target) ||        // env\n-                match self.mode {\n-                    common::DebugInfoGdb => name == \"gdb\",\n-                    common::DebugInfoLldb => name == \"lldb\",\n-                    common::Pretty => name == \"pretty\",\n-                    _ => false,\n-                } ||\n                 (self.target != self.host && name == \"cross-compile\") ||\n                 match self.compare_mode {\n                     Some(CompareMode::Nll) => name == \"compare-mode-nll\",\n                     Some(CompareMode::Polonius) => name == \"compare-mode-polonius\",\n                     None => false,\n                 } ||\n-                (cfg!(debug_assertions) && name == \"debug\")\n+                (cfg!(debug_assertions) && name == \"debug\") {\n+                ParsedNameDirective::Match\n+            } else {\n+                match self.mode {\n+                    common::DebugInfoBoth => {\n+                        if name == \"gdb\" {\n+                            ParsedNameDirective::MatchGdb\n+                        } else if name == \"lldb\" {\n+                            ParsedNameDirective::MatchLldb\n+                        } else {\n+                            ParsedNameDirective::NoMatch\n+                        }\n+                    },\n+                    common::DebugInfoGdb => if name == \"gdb\" {\n+                        ParsedNameDirective::Match\n+                    } else {\n+                        ParsedNameDirective::NoMatch\n+                    },\n+                    common::DebugInfoLldb => if name == \"lldb\" {\n+                        ParsedNameDirective::Match\n+                    } else {\n+                        ParsedNameDirective::NoMatch\n+                    },\n+                    common::Pretty => if name == \"pretty\" {\n+                        ParsedNameDirective::Match\n+                    } else {\n+                        ParsedNameDirective::NoMatch\n+                    },\n+                    _ => ParsedNameDirective::NoMatch,\n+                }\n+            }\n         } else {\n-            false\n+            ParsedNameDirective::NoMatch\n         }\n     }\n "}, {"sha": "c931d3c0e30b7ab8146e960971ecd2627d5099ff", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -32,7 +32,7 @@ extern crate rustfix;\n use common::CompareMode;\n use common::{expected_output_path, output_base_dir, output_relative_path, UI_EXTENSIONS};\n use common::{Config, TestPaths};\n-use common::{DebugInfoGdb, DebugInfoLldb, Mode, Pretty};\n+use common::{DebugInfoBoth, DebugInfoGdb, DebugInfoLldb, Mode, Pretty};\n use filetime::FileTime;\n use getopts::Options;\n use std::env;\n@@ -44,7 +44,7 @@ use std::process::Command;\n use test::ColorConfig;\n use util::logv;\n \n-use self::header::EarlyProps;\n+use self::header::{EarlyProps, Ignore};\n \n pub mod common;\n pub mod errors;\n@@ -425,7 +425,7 @@ pub fn opt_str2(maybestr: Option<String>) -> String {\n \n pub fn run_tests(config: &Config) {\n     if config.target.contains(\"android\") {\n-        if let DebugInfoGdb = config.mode {\n+        if config.mode == DebugInfoGdb || config.mode == DebugInfoBoth {\n             println!(\n                 \"{} debug-info test uses tcp 5039 port.\\\n                  please reserve it\",\n@@ -443,7 +443,9 @@ pub fn run_tests(config: &Config) {\n     }\n \n     match config.mode {\n-        DebugInfoLldb => {\n+        // Note that we don't need to emit the gdb warning when\n+        // DebugInfoBoth, so it is ok to list that here.\n+        DebugInfoBoth | DebugInfoLldb => {\n             if let Some(lldb_version) = config.lldb_version.as_ref() {\n                 if is_blacklisted_lldb_version(&lldb_version[..]) {\n                     println!(\n@@ -647,23 +649,26 @@ pub fn make_test(config: &Config, testpaths: &TestPaths) -> Vec<test::TestDescAn\n         .into_iter()\n         .map(|revision| {\n             // Debugging emscripten code doesn't make sense today\n-            let ignore = early_props.ignore\n+            let ignore = early_props.ignore == Ignore::Ignore\n                 || !up_to_date(\n                     config,\n                     testpaths,\n                     &early_props,\n                     revision.map(|s| s.as_str()),\n                 )\n-                || (config.mode == DebugInfoGdb || config.mode == DebugInfoLldb)\n-                    && config.target.contains(\"emscripten\");\n+                || ((config.mode == DebugInfoBoth ||\n+                     config.mode == DebugInfoGdb || config.mode == DebugInfoLldb)\n+                    && config.target.contains(\"emscripten\"))\n+                || (config.mode == DebugInfoGdb && !early_props.ignore.can_run_gdb())\n+                || (config.mode == DebugInfoLldb && !early_props.ignore.can_run_lldb());\n             test::TestDescAndFn {\n                 desc: test::TestDesc {\n                     name: make_test_name(config, testpaths, revision),\n                     ignore,\n                     should_panic,\n                     allow_fail: false,\n                 },\n-                testfn: make_test_closure(config, testpaths, revision),\n+                testfn: make_test_closure(config, early_props.ignore, testpaths, revision),\n             }\n         })\n         .collect()\n@@ -774,10 +779,21 @@ fn make_test_name(\n \n fn make_test_closure(\n     config: &Config,\n+    ignore: Ignore,\n     testpaths: &TestPaths,\n     revision: Option<&String>,\n ) -> test::TestFn {\n-    let config = config.clone();\n+    let mut config = config.clone();\n+    if config.mode == DebugInfoBoth {\n+        // If both gdb and lldb were ignored, then the test as a whole\n+        // would be ignored.\n+        if !ignore.can_run_gdb() {\n+            config.mode = DebugInfoLldb;\n+        } else if !ignore.can_run_lldb() {\n+            config.mode = DebugInfoGdb;\n+        }\n+    }\n+\n     let testpaths = testpaths.clone();\n     let revision = revision.cloned();\n     test::DynTestFn(Box::new(move || {"}, {"sha": "8c3b1bb4df333a6fbbddf38e563cd648b48dc309", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af204b1f3e83d77427f5fe78285537378be103ec/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=af204b1f3e83d77427f5fe78285537378be103ec", "patch": "@@ -11,7 +11,7 @@\n use common::CompareMode;\n use common::{expected_output_path, UI_EXTENSIONS, UI_FIXED, UI_STDERR, UI_STDOUT};\n use common::{output_base_dir, output_base_name, output_testname_unique};\n-use common::{Codegen, CodegenUnits, DebugInfoGdb, DebugInfoLldb, Rustdoc};\n+use common::{Codegen, CodegenUnits, DebugInfoBoth, DebugInfoGdb, DebugInfoLldb, Rustdoc};\n use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n use common::{Config, TestPaths};\n use common::{Incremental, MirOpt, RunMake, Ui};\n@@ -225,19 +225,20 @@ pub fn run(config: Config, testpaths: &TestPaths, revision: Option<&str>) {\n pub fn compute_stamp_hash(config: &Config) -> String {\n     let mut hash = DefaultHasher::new();\n     config.stage_id.hash(&mut hash);\n-    match config.mode {\n-        DebugInfoGdb => match config.gdb {\n+\n+    if config.mode == DebugInfoGdb || config.mode == DebugInfoBoth {\n+        match config.gdb {\n             None => env::var_os(\"PATH\").hash(&mut hash),\n             Some(ref s) if s.is_empty() => env::var_os(\"PATH\").hash(&mut hash),\n             Some(ref s) => s.hash(&mut hash),\n-        },\n-        DebugInfoLldb => {\n-            env::var_os(\"PATH\").hash(&mut hash);\n-            env::var_os(\"PYTHONPATH\").hash(&mut hash);\n-        },\n+        };\n+    }\n+\n+    if config.mode == DebugInfoLldb || config.mode == DebugInfoBoth {\n+        env::var_os(\"PATH\").hash(&mut hash);\n+        env::var_os(\"PYTHONPATH\").hash(&mut hash);\n+    }\n \n-        _ => {},\n-    };\n     format!(\"{:x}\", hash.finish())\n }\n \n@@ -268,6 +269,10 @@ impl<'test> TestCx<'test> {\n             RunFail => self.run_rfail_test(),\n             RunPassValgrind => self.run_valgrind_test(),\n             Pretty => self.run_pretty_test(),\n+            DebugInfoBoth => {\n+                self.run_debuginfo_gdb_test();\n+                self.run_debuginfo_lldb_test();\n+            },\n             DebugInfoGdb => self.run_debuginfo_gdb_test(),\n             DebugInfoLldb => self.run_debuginfo_lldb_test(),\n             Codegen => self.run_codegen_test(),\n@@ -640,6 +645,7 @@ impl<'test> TestCx<'test> {\n         let config = Config {\n             target_rustcflags: self.cleanup_debug_info_options(&self.config.target_rustcflags),\n             host_rustcflags: self.cleanup_debug_info_options(&self.config.host_rustcflags),\n+            mode: DebugInfoGdb,\n             ..self.config.clone()\n         };\n \n@@ -910,6 +916,7 @@ impl<'test> TestCx<'test> {\n         let config = Config {\n             target_rustcflags: self.cleanup_debug_info_options(&self.config.target_rustcflags),\n             host_rustcflags: self.cleanup_debug_info_options(&self.config.host_rustcflags),\n+            mode: DebugInfoLldb,\n             ..self.config.clone()\n         };\n \n@@ -1774,7 +1781,7 @@ impl<'test> TestCx<'test> {\n \n                 rustc.arg(dir_opt);\n             }\n-            RunFail | RunPassValgrind | Pretty | DebugInfoGdb | DebugInfoLldb\n+            RunFail | RunPassValgrind | Pretty | DebugInfoBoth | DebugInfoGdb | DebugInfoLldb\n             | Codegen | Rustdoc | RunMake | CodegenUnits => {\n                 // do not use JSON output\n             }"}]}