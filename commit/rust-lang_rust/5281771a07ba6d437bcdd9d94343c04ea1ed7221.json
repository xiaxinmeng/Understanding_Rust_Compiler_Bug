{"sha": "5281771a07ba6d437bcdd9d94343c04ea1ed7221", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyODE3NzFhMDdiYTZkNDM3YmNkZDlkOTQzNDNjMDRlYTFlZDcyMjE=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-06-22T04:21:57Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-06-22T04:21:57Z"}, "message": "Merge pull request #2706 from mozilla/incoming\n\nIncoming", "tree": {"sha": "6b6be9d90fe119c484d02577edef0ed6ea36c0fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b6be9d90fe119c484d02577edef0ed6ea36c0fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5281771a07ba6d437bcdd9d94343c04ea1ed7221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5281771a07ba6d437bcdd9d94343c04ea1ed7221", "html_url": "https://github.com/rust-lang/rust/commit/5281771a07ba6d437bcdd9d94343c04ea1ed7221", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5281771a07ba6d437bcdd9d94343c04ea1ed7221/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a6943dd31e8002b2e0267b7539b55ba9da7490b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a6943dd31e8002b2e0267b7539b55ba9da7490b", "html_url": "https://github.com/rust-lang/rust/commit/0a6943dd31e8002b2e0267b7539b55ba9da7490b"}, {"sha": "b8710de5fffdc45c19ccc27ad8ed98c1ee51c025", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8710de5fffdc45c19ccc27ad8ed98c1ee51c025", "html_url": "https://github.com/rust-lang/rust/commit/b8710de5fffdc45c19ccc27ad8ed98c1ee51c025"}], "stats": {"total": 2581, "additions": 1524, "deletions": 1057}, "files": [{"sha": "a33f05a95f60151584462fa4679ac3368c4bfe8d", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -165,7 +165,8 @@ fn test_is_uuid() {\n     assert !is_uuid(\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa\u0e1b\");\n }\n \n-// FIXME: implement url/URL parsing so we don't have to resort to weak checks\n+// FIXME (#2661): implement url/URL parsing so we don't have to resort\n+// to weak checks\n \n fn has_archive_extension(p: str) -> bool {\n     str::ends_with(p, \".tar\") ||\n@@ -188,8 +189,8 @@ fn is_archive_path(u: str) -> bool {\n }\n \n fn is_archive_url(u: str) -> bool {\n-    // FIXME: this requires the protocol bit - if we had proper url parsing,\n-    // we wouldn't need it\n+    // FIXME (#2661): this requires the protocol bit - if we had proper\n+    // url parsing, we wouldn't need it\n \n     alt str::find_str(u, \"://\") {\n         option::some(i) { has_archive_extension(u) }\n@@ -315,7 +316,7 @@ fn load_crate(filename: str) -> option<crate> {\n \n                 alt *attr_name {\n                     \"std\" | \"core\" { }\n-                    _ { e.deps += [query]; }\n+                    _ { vec::push(e.deps, query); }\n                 }\n             }\n             _ { }\n@@ -774,7 +775,7 @@ fn install_source(c: cargo, path: str) {\n     let mut cratefiles = [];\n     for os::walk_dir(\".\") {|p|\n         if str::ends_with(p, \".rc\") {\n-            cratefiles += [p];\n+            vec::push(cratefiles, p);\n         }\n     }\n \n@@ -956,9 +957,10 @@ fn cmd_uninstall(c: cargo) {\n     let bin = c.bindir;\n     let target = c.opts.free[2u];\n \n-    // FIXME: needs stronger pattern matching\n-    // FIXME: needs to uninstall from a specified location in a cache instead\n-    // of looking for it (binaries can be uninstalled by name only)\n+    // FIXME (#2662): needs stronger pattern matching\n+    // FIXME (#2662): needs to uninstall from a specified location in a\n+    // cache instead of looking for it (binaries can be uninstalled by\n+    // name only)\n     if is_uuid(target) {\n         for os::list_dir(lib).each { |file|\n             alt str::find_str(file, \"-\" + target + \"-\") {\n@@ -1059,8 +1061,8 @@ fn install_query(c: cargo, wd: str, target: str) {\n         }\n     }\n \n-    // FIXME: This whole dep_cache and current_install\n-    // thing is a bit of a hack. It should be cleaned up in the future.\n+    // FIXME (#2662): This whole dep_cache and current_install thing is\n+    // a bit of a hack. It should be cleaned up in the future.\n \n     if target == c.current_install {\n         for c.dep_cache.each { |k, _v|\n@@ -1894,7 +1896,7 @@ fn main(argv: [str]) {\n     if !first_time && o.free[1] != \"init\" {\n         cmd_init(c);\n \n-        // FIXME: shouldn't need to reconfigure\n+        // FIXME (#2662): shouldn't need to reconfigure\n         c = configure(o);\n     }\n "}, {"sha": "06428a993d2aa8a7e810d3666247f02c2fa559ff", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -139,7 +139,7 @@ fn make_tests(config: config) -> [test::test_desc] {\n         let file = file;\n         #debug(\"inspecting file %s\", file);\n         if is_test(config, file) {\n-            tests += [make_test(config, file)]\n+            vec::push(tests, make_test(config, file))\n         }\n     }\n     ret tests;"}, {"sha": "642e2073e6bf676dad56192688b595fc1b9c4e3b", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -31,7 +31,7 @@ fn load_props(testfile: str) -> test_props {\n     let mut pp_exact = option::none;\n     for iter_header(testfile) {|ln|\n         alt parse_error_pattern(ln) {\n-          option::some(ep) { error_patterns += [ep]; }\n+          option::some(ep) { vec::push(error_patterns, ep) }\n           option::none { }\n         };\n \n@@ -44,11 +44,11 @@ fn load_props(testfile: str) -> test_props {\n         }\n \n         option::iter(parse_aux_build(ln)) {|ab|\n-            aux_builds += [ab];\n+            vec::push(aux_builds, ab);\n         }\n \n         option::iter(parse_exec_env(ln)) {|ee|\n-            exec_env += [ee];\n+            vec::push(exec_env, ee);\n         }\n     };\n     ret {"}, {"sha": "354d966c2ccd247142288cd8d612ce6b919cecd2", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -19,7 +19,7 @@ fn target_env(lib_path: str, prog: str) -> [(str,str)] {\n         else { (k,v) }\n     };\n     if str::ends_with(prog, \"rustc.exe\") {\n-        env += [(\"RUST_THREADS\", \"1\")]\n+        vec::push(env, (\"RUST_THREADS\", \"1\"));\n     }\n     ret env;\n }\n@@ -32,7 +32,7 @@ fn target_env(_lib_path: str, _prog: str) -> [(str,str)] {\n }\n \n \n-// FIXME: This code is duplicated in core::run::program_output\n+// FIXME (#2659): This code is duplicated in core::run::program_output\n fn run(lib_path: str,\n        prog: str,\n        args: [str],"}, {"sha": "749af7d9f73501ae446f0f6e859667ae37ad8f85", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -104,7 +104,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: str) {\n                           procres);\n         }\n \n-        srcs += [procres.stdout];\n+        vec::push(srcs, procres.stdout);\n         round += 1;\n     }\n "}, {"sha": "7d390c8c9aafb4bd3604f7e27fe3da460184f192", "filename": "src/etc/get-snapshot.py", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fetc%2Fget-snapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fetc%2Fget-snapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fget-snapshot.py?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -8,11 +8,7 @@ def unpack_snapshot(triple, dl_path):\n   tar = tarfile.open(dl_path)\n   kernel = get_kernel(triple)\n   for p in tar.getnames():\n-\n-    # FIXME: Fix this once win32 snapshot globs are fixed.\n-    name = p.replace(\"rust-stage0/stage3/\", \"\", 1);\n-    name = name.replace(\"rust-stage0/\", \"\", 1);\n-\n+    name = p.replace(\"rust-stage0/\", \"\", 1);\n     stagep = os.path.join(triple, \"stage0\")\n     fp = os.path.join(stagep, name)\n     print(\"extracting \" + p)"}, {"sha": "780ba4282094163a1a455d2cd0c10a4628a4fdfd", "filename": "src/etc/snapshot.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fetc%2Fsnapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fetc%2Fsnapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsnapshot.py?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -183,7 +183,7 @@ def in_tar_name(fn):\n     shutil.move(file0, file1)\n \n     if flag == \"install\":\n-      # FIXME this is an ugly quick hack; pls make it better\n+      # FIXME (#2664): this is an ugly quick hack; pls make it better\n       path  = file1\n       comps = path.split(\"-\")\n       parts = { 'year': comps[2], \\"}, {"sha": "51e13e7af19d6051545d522c4c39eb861c4eb201", "filename": "src/etc/tidy.py", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -1,6 +1,6 @@\n #!/usr/bin/env python\n \n-import sys, fileinput, subprocess\n+import sys, fileinput, subprocess, re\n \n err=0\n cols=78\n@@ -23,6 +23,11 @@ def report_err(s):\n try:\n     for line in fileinput.input(file_names,\n                                 openhook=fileinput.hook_encoded(\"utf-8\")):\n+\n+        if fileinput.filename().find(\"tidy.py\") == -1:\n+            if line.find(\"FIXME\") != -1:\n+                if re.search(\"FIXME.*#\\d+\", line) == None:\n+                    report_err(\"FIXME without issue number\")\n         if (line.find('\\t') != -1 and\n             fileinput.filename().find(\"Makefile\") == -1):\n             report_err(\"tab character\")"}, {"sha": "4773a331c130a20fcd2e1a1fad1b5617c358a057", "filename": "src/fuzzer/cycles.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ffuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ffuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fcycles.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -62,7 +62,7 @@ fn test_cycles(r : rand::rng, k: uint, n: uint)\n \n     // Create a graph with no edges\n     range(0u, vlen) {|_i|\n-        v += [mut empty_pointy()];\n+        vec::push(v, empty_pointy());\n     }\n \n     // Fill in the graph with random edges, with density k/n\n@@ -77,7 +77,7 @@ fn test_cycles(r : rand::rng, k: uint, n: uint)\n           // https://github.com/mozilla/rust/issues/1899\n \n         if (likelihood(r, k, n)) { v[i].m = [p(choice(r, v))]; }\n-        if (likelihood(r, k, n)) { v[i].n += [mut p(choice(r, v))]; }\n+        if (likelihood(r, k, n)) { vec::push(v[i].n, mut p(choice(r, v))); }\n         if (likelihood(r, k, n)) { v[i].o = {x: 0, y: p(choice(r, v))}; }\n     }\n "}, {"sha": "7c59ceeef008eebd1f968365751a33e54d81c627", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -129,7 +129,7 @@ fn stash_ty_if(c: fn@(@ast::ty, test_mode)->bool,\n                e: @ast::ty,\n                tm: test_mode) {\n     if c(e, tm) {\n-        *es += [*e];\n+        vec::push(*es,*e);\n     } else {/* now my indices are wrong :( */ }\n }\n "}, {"sha": "9ea4d888fb286044fc2e3635dc8eeef294e04be7", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -57,11 +57,11 @@ fn vec_edits<T: copy>(v: [T], xs: [T]) -> [[T]] {\n \n     if Lv != 1u {\n         // When Lv == 1u, this is redundant with omit.\n-        edits += [[]];\n+        vec::push(edits, []);\n     }\n     if Lv >= 3u {\n         // When Lv == 2u, this is redundant with swap.\n-        edits += [vec::reversed(v)];\n+        vec::push(edits, vec::reversed(v));\n     }\n     ix(0u, 1u, Lv) {|i| edits += [vec_omit(v, i)]; }\n     ix(0u, 1u, Lv) {|i| edits += [vec_dup(v, i)]; }\n@@ -71,10 +71,10 @@ fn vec_edits<T: copy>(v: [T], xs: [T]) -> [[T]] {\n \n     ix(0u, 1u, len(xs)) {|j|\n         ix(0u, 1u, Lv) {|i|\n-            edits += [vec_poke(v, i, xs[j])];\n+            vec::push(edits, vec_poke(v, i, xs[j]));\n         }\n         ix(0u, 0u, Lv) {|i|\n-            edits += [vec_insert(v, i, xs[j])];\n+            vec::push(edits, vec_insert(v, i, xs[j]));\n         }\n     }\n "}, {"sha": "3f5c00c313ffd8620a0b6f661e4e7f2b0b4d2e94", "filename": "src/fuzzer/rand_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ffuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ffuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Frand_util.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -62,7 +62,7 @@ fn weighted_vec<T: copy>(v : [weighted<T>]) -> [T] {\n     for {weight: weight, item: item} in v {\n         let i = 0u;\n         while i < weight {\n-            r += [item];\n+            vec::push(r, item);\n             i += 1u;\n         }\n     }"}, {"sha": "ddbc4e8321f9846448dd8a4bfaea1528327ab5aa", "filename": "src/libcore/arc.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farc.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -68,17 +68,18 @@ allowing them to share the underlying data.\"]\n fn clone<T: const>(rc: &arc<T>) -> arc<T> {\n     unsafe {\n         let ptr: ~arc_data<T> = unsafe::reinterpret_cast(**rc);\n-        rustrt::rust_atomic_increment(&mut ptr.count);\n+        let new_count = rustrt::rust_atomic_increment(&mut ptr.count);\n+        assert new_count >= 2;\n         unsafe::forget(ptr);\n     }\n     arc_destruct(**rc)\n }\n \n // An arc over mutable data that is protected by a lock.\n-type ex_data<T> = {lock: sys::lock_and_signal, data: T};\n-type exclusive<T> = arc_destruct<ex_data<T>>;\n+type ex_data<T: send> = {lock: sys::lock_and_signal, data: T};\n+type exclusive<T: send> = arc_destruct<ex_data<T>>;\n \n-fn exclusive<T>(-data: T) -> exclusive<T> {\n+fn exclusive<T:send >(-data: T) -> exclusive<T> {\n     let data = ~{mut count: 1, data: {lock: sys::create_lock(),\n                                       data: data}};\n     unsafe {\n@@ -88,12 +89,13 @@ fn exclusive<T>(-data: T) -> exclusive<T> {\n     }\n }\n \n-impl methods<T> for exclusive<T> {\n+impl methods<T: send> for exclusive<T> {\n     fn clone() -> exclusive<T> {\n         unsafe {\n             // this makes me nervous...\n             let ptr: ~arc_data<ex_data<T>> = unsafe::reinterpret_cast(*self);\n-            rustrt::rust_atomic_increment(&mut ptr.count);\n+            let new_count = rustrt::rust_atomic_increment(&mut ptr.count);\n+            assert new_count > 1;\n             unsafe::forget(ptr);\n         }\n         arc_destruct(*self)"}, {"sha": "fbb434d8e4b5cd83e121d6f1fd9a5f0e160aad19", "filename": "src/libcore/cmath.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmath.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -2,8 +2,8 @@ export c_float;\n export c_double;\n \n // uncomment once #1433 is fixed\n-// FIXME export c_float_math_consts;\n-// FIXME export c_double_math_consts;\n+// FIXME (#1433): export c_float_math_consts;\n+// FIXME (#1433): export c_double_math_consts;\n \n export c_float_targ_consts;\n export c_double_targ_consts;\n@@ -68,8 +68,7 @@ native mod c_double {\n     #[link_name=\"ilogb\"] pure fn ilog_radix(n: c_double) -> c_int;\n     pure fn modf(n: c_double, &iptr: c_double) -> c_double;\n     pure fn pow(n: c_double, e: c_double) -> c_double;\n-// FIXME enable when rounding modes become available\n-// (See Issue #1379)\n+// FIXME (#1379): enable when rounding modes become available\n //    pure fn rint(n: c_double) -> c_double;\n     pure fn round(n: c_double) -> c_double;\n     // rename: for consistency with logradix\n@@ -149,8 +148,7 @@ native mod c_float {\n     #[link_name=\"modff\"] pure fn modf(n: c_float,\n                                       &iptr: c_float) -> c_float;\n     #[link_name=\"powf\"] pure fn pow(n: c_float, e: c_float) -> c_float;\n-// FIXME enable when rounding modes become available\n-// (See Issue #1379)\n+// FIXME (#1379): enable when rounding modes become available\n //    #[link_name=\"rintf\"] pure fn rint(n: c_float) -> c_float;\n     #[link_name=\"roundf\"] pure fn round(n: c_float) -> c_float;\n     #[link_name=\"scalbnf\"] pure fn ldexp_radix(n: c_float, i: c_int)\n@@ -176,8 +174,8 @@ mod c_float_targ_consts {\n     const max_exp: uint = 128u;\n     const min_10_exp: int = -37;\n     const max_10_exp: int = 38;\n-    // FIXME this is wrong! replace with hexadecimal (%a) constants below\n-    // (see Issue #1433)\n+    // FIXME (#1433): this is wrong, replace with hexadecimal (%a) constants\n+    // below.\n     const min_value: f32 = 1.175494e-38_f32;\n     const max_value: f32 = 3.402823e+38_f32;\n     const epsilon: f32 = 0.000000_f32;\n@@ -191,8 +189,8 @@ mod c_double_targ_consts {\n     const max_exp: uint = 1024u;\n     const min_10_exp: int = -307;\n     const max_10_exp: int = 308;\n-    // FIXME this is wrong! replace with hexadecimal (%a) constants below\n-    // (see Issue #1433)\n+    // FIXME (#1433): this is wrong, replace with hexadecimal (%a) constants\n+    // below.\n     const min_value: f64 = 2.225074e-308_f64;\n     const max_value: f64 = 1.797693e+308_f64;\n     const epsilon: f64 = 2.220446e-16_f64;"}, {"sha": "722c485d72e89e8115e5ea9a5ab7bc768817d2d3", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -94,27 +94,29 @@ fn listen<T: send, U>(f: fn(chan<T>) -> U) -> U {\n     f(po.chan())\n }\n \n-resource port_ptr<T: send>(po: *rust_port) unsafe {\n+class port_ptr<T:send> {\n+  let po: *rust_port;\n+  new(po: *rust_port) { self.po = po; }\n+  drop unsafe {\n     task::unkillable {||\n         // Once the port is detached it's guaranteed not to receive further\n         // messages\n         let yield = 0u;\n         let yieldp = ptr::addr_of(yield);\n-        rustrt::rust_port_begin_detach(po, yieldp);\n+        rustrt::rust_port_begin_detach(self.po, yieldp);\n         if yield != 0u {\n             // Need to wait for the port to be detached\n-            // FIXME: If this fails then we're going to leave our port\n-            // in a bogus state. (Issue #1988)\n             task::yield();\n         }\n-        rustrt::rust_port_end_detach(po);\n+        rustrt::rust_port_end_detach(self.po);\n \n         // Drain the port so that all the still-enqueued items get dropped\n-        while rustrt::rust_port_size(po) > 0u as size_t {\n-            recv_::<T>(po);\n+        while rustrt::rust_port_size(self.po) > 0u as size_t {\n+            recv_::<T>(self.po);\n         }\n-        rustrt::del_port(po);\n+        rustrt::del_port(self.po);\n     }\n+  }\n }\n \n #[doc = \"\n@@ -126,29 +128,34 @@ Fails if the port is detached or dead. Fails if the port\n is owned by a different task.\n \"]\n fn as_raw_port<T: send, U>(ch: comm::chan<T>, f: fn(*rust_port) -> U) -> U {\n-    resource portref(p: *rust_port) {\n-        if !ptr::is_null(p) {\n-            rustrt::rust_port_drop(p);\n-        }\n+\n+    class portref {\n+       let p: *rust_port;\n+       new(p: *rust_port) { self.p = p; }\n+       drop {\n+         if !ptr::is_null(self.p) {\n+           rustrt::rust_port_drop(self.p);\n+         }\n+       }\n     }\n \n     let p = portref(rustrt::rust_port_take(*ch));\n \n-    if ptr::is_null(*p) {\n+    if ptr::is_null(p.p) {\n         fail \"unable to locate port for channel\"\n-    } else if rustrt::get_task_id() != rustrt::rust_port_task(*p) {\n+    } else if rustrt::get_task_id() != rustrt::rust_port_task(p.p) {\n         fail \"unable to access unowned port\"\n     }\n \n-    f(*p)\n+    f(p.p)\n }\n \n #[doc = \"\n Constructs a channel. The channel is bound to the port used to\n construct it.\n \"]\n fn chan<T: send>(p: port<T>) -> chan<T> {\n-    chan_t(rustrt::get_port_id(***p))\n+    chan_t(rustrt::get_port_id((**p).po))\n }\n \n #[doc = \"\n@@ -170,10 +177,10 @@ fn send<T: send>(ch: chan<T>, -data: T) {\n Receive from a port.  If no data is available on the port then the\n task will block until data becomes available.\n \"]\n-fn recv<T: send>(p: port<T>) -> T { recv_(***p) }\n+fn recv<T: send>(p: port<T>) -> T { recv_((**p).po) }\n \n #[doc = \"Returns true if there are messages available\"]\n-fn peek<T: send>(p: port<T>) -> bool { peek_(***p) }\n+fn peek<T: send>(p: port<T>) -> bool { peek_((**p).po) }\n \n #[doc(hidden)]\n fn recv_chan<T: send>(ch: comm::chan<T>) -> T {\n@@ -196,7 +203,7 @@ fn recv_<T: send>(p: *rust_port) -> T {\n         // Data isn't available yet, so res has not been initialized.\n         task::yield();\n     } else {\n-        // In the absense of compiler-generated preemption points\n+        // In the absence of compiler-generated preemption points\n         // this is a good place to yield\n         task::yield();\n     }\n@@ -210,7 +217,7 @@ fn peek_(p: *rust_port) -> bool unsafe {\n #[doc = \"Receive on one of two ports\"]\n fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n     -> either<A, B> unsafe {\n-    let ports = [***p_a, ***p_b];\n+    let ports = [(**p_a).po, (**p_b).po];\n     let n_ports = 2 as libc::size_t;\n     let yield = 0u, yieldp = ptr::addr_of(yield);\n \n@@ -233,9 +240,9 @@ fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n     // Now we know the port we're supposed to receive from\n     assert resport != ptr::null();\n \n-    if resport == ***p_a {\n+    if resport == (**p_a).po {\n         either::left(recv(p_a))\n-    } else if resport == ***p_b {\n+    } else if resport == (**p_b).po {\n         either::right(recv(p_b))\n     } else {\n         fail \"unexpected result from rust_port_select\";\n@@ -482,4 +489,4 @@ fn test_port_detach_fail() {\n             }\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "8f4b301adaf2e7f58b4acc38c66e5b48e42881b2", "filename": "src/libcore/core.rc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -39,7 +39,7 @@ export float, f32, f64;\n export box, char, str, ptr, vec, bool;\n export either, option, result, iter;\n export libc, os, io, run, rand, sys, unsafe, logging;\n-export arc, comm, task, future;\n+export arc, newcomm, comm, task, future;\n export extfmt;\n export tuple;\n export to_str;\n@@ -50,9 +50,9 @@ export num;\n // NDM seems to be necessary for resolve to work\n export option_iter;\n \n-// FIXME: This creates some APIs that I do not want to commit to. It is\n-// currently exported for the uv code in std, but when that code moves into\n-// core this should become unexported\n+// FIXME (#2648): This creates some APIs that I do not want to commit\n+// to. It is currently exported for the uv code in std, but when that\n+// code moves into core this should become unexported\n export priv;\n \n \n@@ -176,6 +176,7 @@ mod dvec_iter {\n \n // Concurrency\n mod arc;\n+mod newcomm;\n mod comm;\n mod task;\n mod future;"}, {"sha": "85d61d3f606fc5260396ba83d69aba5bf669f511", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -113,6 +113,7 @@ impl extensions<A> for dvec<A> {\n     and return a new vector to replace it with.\n \n     \"]\n+    #[inline(always)]\n     fn swap(f: fn(-[mut A]) -> [mut A]) {\n         self.borrow { |v| self.return(f(v)) }\n     }\n@@ -131,15 +132,6 @@ impl extensions<A> for dvec<A> {\n         self.check_not_borrowed();\n         self.data <- w;\n     }\n-}\n-\n-impl extensions<A:copy> for dvec<A> {\n-    #[doc = \"Append a single item to the end of the list\"]\n-    fn push(t: A) {\n-        self.swap { |v|\n-            let mut v <- v; v += [t]; v // more efficient than v + [t]\n-        }\n-    }\n \n     #[doc = \"Remove and return the last element\"]\n     fn pop() -> A {\n@@ -151,6 +143,38 @@ impl extensions<A:copy> for dvec<A> {\n         }\n     }\n \n+    #[doc = \"Insert a single item at the front of the list\"]\n+    fn unshift(-t: A) {\n+        unsafe {\n+            let mut data = unsafe::reinterpret_cast(null::<()>());\n+            data <-> self.data;\n+            let data_ptr: *() = unsafe::reinterpret_cast(data);\n+            if data_ptr.is_null() { fail \"Recursive use of dvec\"; }\n+            log(error, \"a\");\n+            self.data <- [mut t] + data;\n+            log(error, \"b\");\n+        }\n+    }\n+\n+    #[doc = \"Append a single item to the end of the list\"]\n+    fn push(+t: A) {\n+        self.check_not_borrowed();\n+        vec::push(self.data, t);\n+    }\n+\n+\n+    #[doc = \"Remove and return the first element\"]\n+    fn shift() -> A {\n+        self.borrow { |v|\n+            let mut v = vec::from_mut(v);\n+            let result = vec::shift(v);\n+            self.return(vec::to_mut(v));\n+            result\n+        }\n+    }\n+}\n+\n+impl extensions<A:copy> for dvec<A> {\n     #[doc = \"\n         Append all elements of a vector to the end of the list\n \n@@ -170,7 +194,7 @@ impl extensions<A:copy> for dvec<A> {\n             vec::reserve(v, new_len);\n             let mut i = from_idx;\n             while i < to_idx {\n-                v += [ts[i]];\n+                vec::push(v, ts[i]);\n                 i += 1u;\n             }\n             v\n@@ -213,16 +237,6 @@ impl extensions<A:copy> for dvec<A> {\n         }\n     }\n \n-    #[doc = \"Remove and return the first element\"]\n-    fn shift() -> A {\n-        self.borrow { |v|\n-            let mut v = vec::from_mut(v);\n-            let result = vec::shift(v);\n-            self.return(vec::to_mut(v));\n-            result\n-        }\n-    }\n-\n     #[doc = \"Copy out an individual element\"]\n     #[inline(always)]\n     fn [](idx: uint) -> A {"}, {"sha": "144ea571d7c5931394f5af635ce3891b215e78ad", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -274,8 +274,8 @@ mod rt {\n     enum count { count_is(int), count_implied, }\n     enum ty { ty_default, ty_bits, ty_hex_upper, ty_hex_lower, ty_octal, }\n \n-    // FIXME: May not want to use a vector here for flags;\n-    // instead just use a bool per flag (see Issue #1993)\n+    // FIXME (#1993): May not want to use a vector here for flags; instead\n+    // just use a bool per flag.\n     type conv = {flags: [flag], width: count, precision: count, ty: ty};\n \n     fn conv_int(cv: conv, i: int) -> str {"}, {"sha": "821fa68f55c7774c09727d3b47204f41d16842d8", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -6,8 +6,6 @@ import cmath::c_float::*;\n import cmath::c_float_targ_consts::*;\n import num::num;\n \n-// FIXME find out why these have to be exported explicitly\n-\n export add, sub, mul, div, rem, lt, le, gt, eq, eq, ne;\n export is_positive, is_negative, is_nonpositive, is_nonnegative;\n export is_zero, is_infinite, is_finite;\n@@ -55,9 +53,8 @@ pure fn ge(x: f32, y: f32) -> bool { ret x >= y; }\n \n pure fn gt(x: f32, y: f32) -> bool { ret x > y; }\n \n-// FIXME replace the predicates below with llvm intrinsics or calls\n-// to the libmath macros in the rust runtime for performance\n-// See Issue #1999\n+// FIXME (#1999): replace the predicates below with llvm intrinsics or\n+// calls to the libmath macros in the rust runtime for performance.\n \n #[doc = \"\n Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n@@ -106,14 +103,13 @@ pure fn is_finite(x: f32) -> bool {\n     ret !(is_NaN(x) || is_infinite(x));\n }\n \n-// FIXME add is_normal, is_subnormal, and fpclassify\n-// also see Issue #1999\n+// FIXME (#1999): add is_normal, is_subnormal, and fpclassify.\n \n /* Module: consts */\n mod consts {\n \n-    // FIXME replace with mathematical constants from cmath\n-    // (requires Issue #1433 to fix)\n+    // FIXME (requires Issue #1433 to fix): replace with mathematical\n+    // constants from cmath.\n     #[doc = \"Archimedes' constant\"]\n     const pi: f32 = 3.14159265358979323846264338327950288_f32;\n \n@@ -167,9 +163,8 @@ pure fn logarithm(n: f32, b: f32) -> f32 {\n \n #[cfg(target_os=\"freebsd\")]\n pure fn logarithm(n: f32, b: f32) -> f32 {\n-    // FIXME check if it is good to use log2 instead of ln here;\n+    // FIXME (#2000): check if it is good to use log2 instead of ln here;\n     // in theory should be faster since the radix is 2\n-    // See Issue #2000\n     ret ln(n) / ln(b);\n }\n "}, {"sha": "066b1b818c7d218acde74677eb167f699a0f579b", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -29,8 +29,7 @@ export num;\n \n // PORT check per architecture\n \n-// FIXME obtain these in a different way\n-// (perhaps related to Issue #1433)\n+// FIXME (#1433): obtain these in a different way\n \n const radix: uint = 2u;\n \n@@ -127,14 +126,13 @@ pure fn is_finite(x: f64) -> bool {\n     ret !(is_NaN(x) || is_infinite(x));\n }\n \n-// FIXME add is_normal, is_subnormal, and fpclassify\n-// also see Issue #1999\n+// FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n \n /* Module: consts */\n mod consts {\n \n-    // FIXME replace with mathematical constants from cmath\n-    // (requires Issue #1433 to fix)\n+    // FIXME (requires Issue #1433 to fix): replace with mathematical\n+    // constants from cmath.\n     #[doc = \"Archimedes' constant\"]\n     const pi: f64 = 3.14159265358979323846264338327950288_f64;\n \n@@ -188,9 +186,8 @@ pure fn logarithm(n: f64, b: f64) -> f64 {\n \n #[cfg(target_os=\"freebsd\")]\n pure fn logarithm(n: f64, b: f64) -> f64 {\n-    // FIXME check if it is good to use log2 instead of ln here;\n-    // in theory should be faster since the radix is 2\n-    // See Issue #2000\n+    // FIXME (#2000): check if it is good to use log2 instead of ln here; in\n+    // theory should be faster since the radix is 2\n     ret ln(n) / ln(b);\n }\n "}, {"sha": "9c995100273f64872a81b8eff4425c9ec95227f8", "filename": "src/libcore/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -38,8 +38,8 @@ const neg_infinity: float = -1.0/0.0;\n /* Module: consts */\n mod consts {\n \n-    // FIXME replace with mathematical constants from cmath\n-    // (requires Issue #1433 to fix)\n+    // FIXME (requires Issue #1433 to fix): replace with mathematical\n+    // constants from cmath.\n     #[doc = \"Archimedes' constant\"]\n     const pi: float = 3.14159265358979323846264338327950288;\n "}, {"sha": "635b3f9ebf41f2fc1da1b5ff0f61dcfb639bcd79", "filename": "src/libcore/io.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -22,14 +22,14 @@ native mod rustrt {\n \n // Reading\n \n-// FIXME This is all buffered. We might need an unbuffered variant as well\n-// #2004\n+// FIXME (#2004): This is all buffered. We might need an unbuffered variant\n+// as well\n enum seek_style { seek_set, seek_end, seek_cur, }\n \n \n // The raw underlying reader iface. All readers must implement this.\n iface reader {\n-    // FIXME: Seekable really should be orthogonal. // #2004\n+    // FIXME (#2004): Seekable really should be orthogonal.\n     fn read_bytes(uint) -> [u8];\n     fn read_byte() -> int;\n     fn unread_byte(int);\n@@ -82,8 +82,8 @@ impl reader_util for reader {\n         while nbread > 0u {\n             let data = self.read_bytes(nbread);\n             if vec::len(data) == 0u {\n-                // eof - FIXME should we do something if\n-                // we're split in a unicode char? // #2004\n+                // eof - FIXME (#2004): should we do something if\n+                // we're split in a unicode char?\n                 break;\n             }\n             buf += data;\n@@ -234,9 +234,9 @@ fn FILE_reader(f: *libc::FILE, cleanup: bool) -> reader {\n     }\n }\n \n-// FIXME: this should either be an iface-less impl, a set of top-level\n-// functions that take a reader, or a set of default methods on reader\n-// (which can then be called reader) // #2004\n+// FIXME (#2004): this should either be an iface-less impl, a set of\n+// top-level functions that take a reader, or a set of default methods on\n+// reader (which can then be called reader)\n \n fn stdin() -> reader { rustrt::rust_get_stdin() as reader }\n \n@@ -312,9 +312,8 @@ fn with_str_reader<T>(s: str, f: fn(reader) -> T) -> T {\n // Writing\n enum fileflag { append, create, truncate, no_flag, }\n \n-// FIXME: Seekable really should be orthogonal.\n-// FIXME: eventually u64\n-// #2004\n+// FIXME (#2004): Seekable really should be orthogonal.\n+// FIXME (#2004): eventually u64\n iface writer {\n     fn write([const u8]/&);\n     fn seek(int, seek_style);\n@@ -586,9 +585,9 @@ fn buffered_file_writer(path: str) -> result<writer, str> {\n     else { result::ok(FILE_writer(f, true)) }\n }\n \n-// FIXME it would be great if this could be a const\n-// FIXME why are these different from the way stdin() is implemented?\n-// #2004\n+// FIXME (#2004) it would be great if this could be a const\n+// FIXME (#2004) why are these different from the way stdin() is\n+// implemented?\n fn stdout() -> writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n fn stderr() -> writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n \n@@ -670,8 +669,8 @@ fn read_whole_file_str(file: str) -> result<str, str> {\n     })\n }\n \n-// FIXME implement this in a low-level way. Going through the abstractions is\n-// pointless. // #2004\n+// FIXME (#2004): implement this in a low-level way. Going through the\n+// abstractions is pointless.\n fn read_whole_file(file: str) -> result<[u8], str> {\n     result::chain(file_reader(file), { |rdr|\n         result::ok(rdr.read_whole_stream())\n@@ -714,8 +713,8 @@ mod fsync {\n     };\n \n     // fsync file after executing blk\n-    // FIXME find better way to create resources within lifetime of outer res\n-    // #2004\n+    // FIXME (#2004) find better way to create resources within lifetime of\n+    // outer res\n     fn FILE_res_sync(&&file: FILE_res, opt_level: option<level>,\n                   blk: fn(&&res<*libc::FILE>)) {\n         blk(res({"}, {"sha": "070e909c626d18e1af372afae955da15016033f2", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -97,8 +97,8 @@ fn min<A:copy,IA:base_iter<A>>(self: IA) -> A {\n     alt foldl::<A,option<A>,IA>(self, none) {|a, b|\n         alt a {\n           some(a_) if a_ < b {\n-            // FIXME: Not sure if this is successfully optimized to a move\n-            // #2005\n+            // FIXME (#2005): Not sure if this is successfully optimized to\n+            // a move\n             a\n           }\n           _ { some(b) }\n@@ -113,8 +113,8 @@ fn max<A:copy,IA:base_iter<A>>(self: IA) -> A {\n     alt foldl::<A,option<A>,IA>(self, none) {|a, b|\n         alt a {\n           some(a_) if a_ > b {\n-            // FIXME: Not sure if this is successfully optimized to a move\n-            // #2005\n+            // FIXME (#2005): Not sure if this is successfully optimized to\n+            // a move.\n             a\n           }\n           _ { some(b) }"}, {"sha": "c2679c6956e95d817c1d1986d53fd9e958716071", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -37,8 +37,7 @@ dissolved.\n // Initial glob-exports mean that all the contents of all the modules\n // wind up exported, if you're interested in writing platform-specific code.\n \n-// FIXME: change these to glob-exports when sufficiently supported.\n-// Issue #2006\n+// FIXME (#2006): change these to glob-exports when sufficiently supported.\n \n import types::common::c95::*;\n import types::common::c99::*;\n@@ -79,10 +78,9 @@ import funcs::posix08::unistd::*;\n import funcs::bsd44::*;\n import funcs::extra::*;\n \n-// FIXME: remove these 3 exports (and their uses next door in os::) when\n-// export globs work. They provide access (for now) for os:: to dig around in\n-// the rest of the platform-specific definitions.\n-// Issue #2006\n+// FIXME (#2006): remove these 3 exports (and their uses next door in os::)\n+// when export globs work. They provide access (for now) for os:: to dig\n+// around in the rest of the platform-specific definitions.\n \n export types, funcs, consts;\n "}, {"sha": "24c4c1cbd9cdbf775fd838ea13606ce77eee2097", "filename": "src/libcore/newcomm.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fnewcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fnewcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnewcomm.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,82 @@\n+#[doc=\"A new implementation of communication.\n+\n+This should be implementing almost entirely in Rust, and hopefully\n+avoid needing a single global lock.\"]\n+\n+import arc::methods;\n+import dvec::dvec;\n+import dvec::{extensions};\n+\n+export port;\n+export chan;\n+export send, recv;\n+export methods;\n+\n+type raw_port<T: send> = arc::exclusive<dvec<T>>;\n+\n+enum port<T: send> {\n+    port_(raw_port<T>)\n+}\n+enum chan<T: send> {\n+    chan_(raw_port<T>)\n+}\n+\n+fn port<T: send>() -> port<T> {\n+    port_(arc::exclusive(dvec()))\n+}\n+\n+fn chan<T: send>(p: port<T>) -> chan<T> {\n+    chan_((*p).clone())\n+}\n+\n+fn send<T: send>(c: chan<T>, -x: T) {\n+    let mut x <- some(x);\n+    (*c).with {|cond, data|\n+        let mut xx = none;\n+        xx <-> x;\n+        (*data).push(option::unwrap(xx));\n+        cond.signal();\n+    }\n+}\n+\n+fn recv<T: send>(p: port<T>) -> T {\n+    (*p).with {|cond, data|\n+        if (*data).len() == 0u {\n+            cond.wait();\n+        }\n+        assert (*data).len() > 0u;\n+        (*data).shift()\n+    }\n+}\n+\n+impl methods<T: send> for chan<T> {\n+    fn send(-x: T) {\n+        send(self, x)\n+    }\n+\n+    fn clone() -> chan<T> {\n+        chan_((*self).clone())\n+    }\n+}\n+\n+impl methods<T: send> for port<T> {\n+    fn recv() -> T {\n+        recv(self)\n+    }\n+\n+    fn chan() -> chan<T> {\n+        chan(self)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn newport_simple() {\n+        let p = port();\n+        let c = chan(p);\n+\n+        c.send(42);\n+        assert p.recv() == 42;\n+    }\n+}"}, {"sha": "9ee7a80fcdaeea5c8de0e608bd43fd24b3d96b43", "filename": "src/libcore/os.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -166,8 +166,8 @@ mod global_env {\n             task::set_opts(builder, {\n                 sched:  some({\n                     mode: task::single_threaded,\n-                    // FIXME: This would be a good place to use\n-                    // a very small native stack (#2621)\n+                    // FIXME (#2621): This would be a good place to use a\n+                    // very small native stack\n                     native_stack_size: none\n                 })\n                 with task::get_opts(builder)\n@@ -499,8 +499,8 @@ fn path_exists(p: path) -> bool {\n     }\n }\n \n-// FIXME: under Windows, we should prepend the current drive letter to paths\n-// that start with a slash. #2622\n+// FIXME (#2622): under Windows, we should prepend the current drive letter\n+// to paths that start with a slash.\n #[doc = \"\n Convert a relative path to an absolute path\n \n@@ -696,8 +696,8 @@ fn remove_file(p: path) -> bool {\n \n     #[cfg(windows)]\n     fn unlink(p: path) -> bool {\n-        // FIXME: remove imports when export globs work properly.\n-        // (similar to Issue #2006)\n+        // FIXME (similar to Issue #2006): remove imports when export globs\n+        // work properly.\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;"}, {"sha": "2a89abc040f858f48c347bd91087c1dc77d9b239", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -10,6 +10,7 @@ export is_null;\n export is_not_null;\n export memcpy;\n export memmove;\n+export memset;\n export buf_len;\n export position;\n export extensions;\n@@ -23,6 +24,8 @@ native mod libc_ {\n     fn memcpy(dest: *c_void, src: *c_void, n: libc::size_t) -> *c_void;\n     #[rust_stack]\n     fn memmove(dest: *c_void, src: *c_void, n: libc::size_t) -> *c_void;\n+    #[rust_stack]\n+    fn memset(dest: *c_void, c: libc::c_int, len: libc::size_t) -> *c_void;\n }\n \n #[abi = \"rust-intrinsic\"]\n@@ -108,6 +111,12 @@ unsafe fn memmove<T>(dst: *T, src: *T, count: uint)  {\n     libc_::memmove(dst as *c_void, src as *c_void, n as size_t);\n }\n \n+#[inline(always)]\n+unsafe fn memset<T>(dst: *mut T, c: int, count: uint)  {\n+    let n = count * sys::size_of::<T>();\n+    libc_::memset(dst as *c_void, c as libc::c_int, n as size_t);\n+}\n+\n #[doc = \"Extension methods for pointers\"]\n impl extensions<T> for *T {\n     #[doc = \"Returns true if the pointer is equal to the null pointer.\"]"}, {"sha": "401454c40dfced326c730249106f60f7e99c5d1c", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -286,8 +286,8 @@ fn program_output(prog: str, args: [str]) ->\n \n     // Spawn two entire schedulers to read both stdout and sterr\n     // in parallel so we don't deadlock while blocking on one\n-    // or the other. FIXME: Surely there's a much more clever way\n-    // to do this. (#2625)\n+    // or the other. FIXME (#2625): Surely there's a much more\n+    // clever way to do this.\n     let p = comm::port();\n     let ch = comm::chan(p);\n     task::spawn_sched(task::single_threaded) {||"}, {"sha": "0041dde319d2c47c807c9458182b852eb6d2f775", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -23,10 +23,10 @@ fn walk_stack(visit: fn(frame) -> bool) {\n             reinterpret_cast(frame_pointer)\n         };\n         loop {\n-            let frame = frame(frame_address);\n+            let fr = frame(frame_address);\n \n-            #debug(\"frame: %x\", unsafe { reinterpret_cast(frame.fp) });\n-            visit(frame);\n+            #debug(\"frame: %x\", unsafe { reinterpret_cast(fr.fp) });\n+            visit(fr);\n \n             unsafe {\n                 let next_fp: **word = reinterpret_cast(frame_address);\n@@ -44,7 +44,7 @@ fn walk_stack(visit: fn(frame) -> bool) {\n \n #[test]\n fn test_simple() {\n-    for walk_stack { |frame|\n+    for walk_stack { |_frame|\n     }\n }\n \n@@ -53,7 +53,7 @@ fn test_simple_deep() {\n     fn run(i: int) {\n         if i == 0 { ret }\n \n-        for walk_stack { |frame|\n+        for walk_stack { |_frame|\n             unsafe {\n                 breakpoint();\n             }"}, {"sha": "dbdd798033ce2750ad648418b8b3bc202c6e98c9", "filename": "src/libcore/str.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -566,7 +566,7 @@ pure fn to_upper(s: str/&) -> str {\n }\n \n #[doc = \"\n-Replace all occurances of one string with another\n+Replace all occurrences of one string with another\n \n # Arguments\n \n@@ -593,8 +593,8 @@ Section: Comparing strings\n \n #[doc = \"Bytewise string equality\"]\n pure fn eq(&&a: str, &&b: str) -> bool {\n-    // FIXME: This should just be \"a == b\" but that calls into the shape code\n-    // :( (#2627)\n+    // FIXME (#2627): This should just be \"a == b\" but that calls into the\n+    // shape code.\n     let a_len = a.len();\n     let b_len = b.len();\n     if a_len != b_len { ret false; }\n@@ -1743,8 +1743,9 @@ mod unsafe {\n    Does not verify that the vector contains valid UTF-8.\n    \"]\n    unsafe fn from_bytes(v: [const u8]) -> str unsafe {\n-       let vcopy = v + [0u8];\n-       ret ::unsafe::transmute(vcopy);\n+       let mut vcopy : [u8] = ::unsafe::transmute(copy v);\n+       vec::push(vcopy, 0u8);\n+       ::unsafe::transmute(vcopy)\n    }\n \n    #[doc = \""}, {"sha": "77207d8aebf78cfeca93d35eb64ba0175b7a4d71", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -51,6 +51,7 @@ pure fn get_type_desc<T>() -> *type_desc {\n }\n \n #[doc = \"Returns the size of a type\"]\n+#[inline(always)]\n pure fn size_of<T>() -> uint unsafe {\n     unchecked { rusti::size_of::<T>() }\n }"}, {"sha": "ab9b4f7d3d7ea8fc4e99df3e14ad2492507d51bf", "filename": "src/libcore/task.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -64,8 +64,8 @@ Indicates the manner in which a task exited.\n A task that completes without failing and whose supervised children complete\n without failing is considered to exit successfully.\n \n-FIXME: This description does not indicate the current behavior for linked\n-failure. (See #1868)\n+FIXME (See #1868): This description does not indicate the current behavior\n+for linked failure.\n \"]\n enum task_result {\n     success,\n@@ -275,7 +275,7 @@ fn future_result(builder: builder) -> future::future<task_result> {\n     task.\n     \"];\n \n-    // FIXME (1087, 1857): Once linked failure and notification are\n+    // FIXME (#1087, #1857): Once linked failure and notification are\n     // handled in the library, I can imagine implementing this by just\n     // registering an arbitrary number of task::on_exit handlers and\n     // sending out messages.\n@@ -506,10 +506,10 @@ fn spawn_raw(opts: task_opts, +f: fn~()) unsafe {\n     let mut f = if opts.supervise {\n         f\n     } else {\n-        // FIXME: The runtime supervision API is weird here because it\n-        // was designed to let the child unsupervise itself, when what\n-        // we actually want is for parents to unsupervise new\n-        // children. (#1868, #1789)\n+        // FIXME (#1868, #1789): The runtime supervision API is weird here\n+        // because it was designed to let the child unsupervise itself,\n+        // when what we actually want is for parents to unsupervise new\n+        // children.\n         fn~() {\n             rustrt::unsupervise();\n             f();\n@@ -529,7 +529,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) unsafe {\n     };\n \n     option::iter(opts.notify_chan) {|c|\n-        // FIXME (1087): Would like to do notification in Rust\n+        // FIXME (#1087): Would like to do notification in Rust\n         rustrt::rust_task_config_notify(new_task, c);\n     }\n "}, {"sha": "be491433cd0fc2157c555e88c7983500721b3de3", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -173,10 +173,9 @@ fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n          0u8,0u8,0u8,0u8,0u8\n          ]/65;\n \n-    // FIXME: post-snapshot, you can do this without\n-    // the raw pointers and unsafe bits, and the\n-    // codegen will prove it's all in-bounds, no\n-    // extra cost.\n+    // FIXME (#2649): post-snapshot, you can do this without the raw\n+    // pointers and unsafe bits, and the codegen will prove it's all\n+    // in-bounds, no extra cost.\n \n     vec::unpack_slice(buf) {|p, len|\n         let mp = p as *mut u8;"}, {"sha": "843215bd4b9b3e6e7badf797f743fd3bf5e2ee47", "filename": "src/libcore/uint-template/uint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fuint.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -81,6 +81,7 @@ fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n }\n \n #[doc = \"Returns the smallest power of 2 greater than or equal to `n`\"]\n+#[inline(always)]\n fn next_power_of_two(n: uint) -> uint {\n     let halfbits: uint = sys::size_of::<uint>() * 4u;\n     let mut tmp: uint = n - 1u;"}, {"sha": "494470e32e4017df2063839bfb72bc2bf4693598", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 131, "deletions": 28, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -4,6 +4,7 @@ import option::{some, none};\n import ptr::addr_of;\n import libc::size_t;\n \n+export append;\n export init_op;\n export is_empty;\n export is_not_empty;\n@@ -91,6 +92,11 @@ native mod rustrt {\n                            ++count: libc::size_t) -> *unsafe::vec_repr;\n }\n \n+#[abi = \"rust-intrinsic\"]\n+native mod rusti {\n+    fn move_val_init<T>(&dst: T, -src: T);\n+}\n+\n #[doc = \"A function used to initialize the elements of a vector\"]\n type init_op<T> = fn(uint) -> T;\n \n@@ -187,7 +193,9 @@ pure fn from_elem<T: copy>(n_elts: uint, t: T) -> [T] {\n     let mut v = [];\n     unchecked{reserve(v, n_elts)}\n     let mut i: uint = 0u;\n-    while i < n_elts { v += [t]; i += 1u; }\n+    unsafe { // because push is impure\n+        while i < n_elts { push(v, t); i += 1u; }\n+    }\n     ret v;\n }\n \n@@ -363,20 +371,30 @@ fn rsplitn<T: copy>(v: [T]/&, n: uint, f: fn(T) -> bool) -> [[T]] {\n // Mutators\n \n #[doc = \"Removes the first element from a vector and return it\"]\n-fn shift<T: copy>(&v: [T]) -> T {\n+fn shift<T>(&v: [T]) -> T {\n     let ln = len::<T>(v);\n     assert (ln > 0u);\n-    let e = v[0];\n-    v = slice::<T>(v, 1u, ln);\n-    ret e;\n-}\n \n-#[doc = \"Prepend an element to a vector\"]\n-fn unshift<T: copy>(&v: [const T], +t: T) {\n-    // n.b.---for most callers, using unshift() ought not to type check, but\n-    // it does. It's because the type system is unaware of the mutability of\n-    // `v` and so allows the vector to be covariant.\n-    v = [const t] + v;\n+    let mut vv = [];\n+    v <-> vv;\n+\n+    unsafe {\n+        let mut rr;\n+        {\n+            let vv = unsafe::to_ptr(vv);\n+            let mut r <- *vv;\n+\n+            for uint::range(1u, ln) {|i|\n+                // FIXME (#2703): this isn't legal, per se...\n+                let r <- *ptr::offset(vv, i);\n+                push(v, r);\n+            }\n+            rr <- r;\n+        }\n+        unsafe::set_len(vv, 0u);\n+\n+        rr\n+    }\n }\n \n #[doc = \"Remove the last element from a vector and return it\"]\n@@ -390,12 +408,85 @@ fn pop<T>(&v: [const T]) -> T unsafe {\n }\n \n #[doc = \"Append an element to a vector\"]\n+#[inline(always)]\n fn push<T>(&v: [const T], +initval: T) {\n-    v += [initval];\n+    unsafe {\n+        let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        let fill = (**repr).fill;\n+        if (**repr).alloc > fill {\n+            let sz = sys::size_of::<T>();\n+            (**repr).fill += sz;\n+            let p = ptr::addr_of((**repr).data);\n+            let p = ptr::offset(p, fill) as *mut T;\n+            rusti::move_val_init(*p, initval);\n+        }\n+        else {\n+            push_slow(v, initval);\n+        }\n+    }\n }\n \n+fn push_slow<T>(&v: [const T], +initval: T) {\n+    unsafe {\n+        let ln = v.len();\n+        reserve_at_least(v, ln + 1u);\n+        let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        let fill = (**repr).fill;\n+        let sz = sys::size_of::<T>();\n+        (**repr).fill += sz;\n+        let p = ptr::addr_of((**repr).data);\n+        let p = ptr::offset(p, fill) as *mut T;\n+        rusti::move_val_init(*p, initval);\n+    }\n+}\n+\n+#[inline(always)]\n+fn push_all<T: copy>(&v: [const T], rhs: [const T]/&) {\n+    for uint::range(0u, rhs.len()) {|i|\n+        push(v, rhs[i]);\n+    }\n+}\n \n // Appending\n+#[inline(always)]\n+pure fn append<T: copy>(lhs: [T]/&, rhs: [const T]/&) -> [T] {\n+    let mut v = [];\n+    let mut i = 0u;\n+    while i < lhs.len() {\n+        unsafe { // This is impure, but it appears pure to the caller.\n+            push(v, lhs[i]);\n+        }\n+        i += 1u;\n+    }\n+    i = 0u;\n+    while i < rhs.len() {\n+        unsafe { // This is impure, but it appears pure to the caller.\n+            push(v, rhs[i]);\n+        }\n+        i += 1u;\n+    }\n+    ret v;\n+}\n+\n+#[inline(always)]\n+pure fn append_mut<T: copy>(lhs: [mut T]/&, rhs: [const T]/&) -> [mut T] {\n+    let mut v = [mut];\n+    let mut i = 0u;\n+    while i < lhs.len() {\n+        unsafe { // This is impure, but it appears pure to the caller.\n+            push(v, lhs[i]);\n+        }\n+        i += 1u;\n+    }\n+    i = 0u;\n+    while i < rhs.len() {\n+        unsafe { // This is impure, but it appears pure to the caller.\n+            push(v, rhs[i]);\n+        }\n+        i += 1u;\n+    }\n+    ret v;\n+}\n \n #[doc = \"\n Expands a vector in place, initializing the new elements to a given value\n@@ -409,7 +500,8 @@ Expands a vector in place, initializing the new elements to a given value\n fn grow<T: copy>(&v: [const T], n: uint, initval: T) {\n     reserve_at_least(v, len(v) + n);\n     let mut i: uint = 0u;\n-    while i < n { v += [initval]; i += 1u; }\n+\n+    while i < n { push(v, initval); i += 1u; }\n }\n \n #[doc = \"\n@@ -428,7 +520,7 @@ Function `init_op` is called `n` times with the values [0..`n`)\n fn grow_fn<T>(&v: [const T], n: uint, op: init_op<T>) {\n     reserve_at_least(v, len(v) + n);\n     let mut i: uint = 0u;\n-    while i < n { v += [op(i)]; i += 1u; }\n+    while i < n { push(v, op(i)); i += 1u; }\n }\n \n #[doc = \"\n@@ -439,6 +531,7 @@ Sets the element at position `index` to `val`. If `index` is past the end\n of the vector, expands the vector by replicating `initval` to fill the\n intervening space.\n \"]\n+#[inline(always)]\n fn grow_set<T: copy>(&v: [mut T], index: uint, initval: T, val: T) {\n     if index >= len(v) { grow(v, index - len(v) + 1u, initval); }\n     v[index] = val;\n@@ -453,7 +546,7 @@ Apply a function to each element of a vector and return the results\n pure fn map<T, U>(v: [T]/&, f: fn(T) -> U) -> [U] {\n     let mut result = [];\n     unchecked{reserve(result, len(v));}\n-    for each(v) {|elem| result += [f(elem)]; }\n+    for each(v) {|elem| unsafe { push(result, f(elem)); } }\n     ret result;\n }\n \n@@ -486,7 +579,10 @@ pure fn map2<T: copy, U: copy, V>(v0: [T]/&, v1: [U]/&,\n     if v0_len != len(v1) { fail; }\n     let mut u: [V] = [];\n     let mut i = 0u;\n-    while i < v0_len { u += [f(copy v0[i], copy v1[i])]; i += 1u; }\n+    while i < v0_len {\n+        unsafe { push(u, f(copy v0[i], copy v1[i])) };\n+        i += 1u;\n+    }\n     ret u;\n }\n \n@@ -502,7 +598,7 @@ pure fn filter_map<T, U: copy>(v: [T]/&, f: fn(T) -> option<U>)\n     for each(v) {|elem|\n         alt f(elem) {\n           none {/* no-op */ }\n-          some(result_elem) { result += [result_elem]; }\n+          some(result_elem) { unsafe { push(result, result_elem); } }\n         }\n     }\n     ret result;\n@@ -518,7 +614,7 @@ only those elements for which `f` returned true.\n pure fn filter<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [T] {\n     let mut result = [];\n     for each(v) {|elem|\n-        if f(elem) { result += [elem]; }\n+        if f(elem) { unsafe { push(result, elem); } }\n     }\n     ret result;\n }\n@@ -530,7 +626,7 @@ Flattens a vector of vectors of T into a single vector of T.\n \"]\n pure fn concat<T: copy>(v: [[T]]/&) -> [T] {\n     let mut r = [];\n-    for each(v) {|inner| r += inner; }\n+    for each(v) {|inner| unsafe { push_all(r, inner); } }\n     ret r;\n }\n \n@@ -541,7 +637,7 @@ pure fn connect<T: copy>(v: [[T]]/&, sep: T) -> [T] {\n     let mut r: [T] = [];\n     let mut first = true;\n     for each(v) {|inner|\n-        if first { first = false; } else { r += [sep]; }\n+        if first { first = false; } else { unsafe { push(r, sep); } }\n         r += inner;\n     }\n     ret r;\n@@ -1025,6 +1121,20 @@ pure fn unpack_mut_slice<T,U>(s: [mut T]/&,\n     f(buf, len / sys::size_of::<T>())\n }\n \n+impl extensions<T: copy> for [T] {\n+    #[inline(always)]\n+    pure fn +(rhs: [T]/&) -> [T] {\n+        append(self, rhs)\n+    }\n+}\n+\n+impl extensions<T: copy> for [mut T] {\n+    #[inline(always)]\n+    pure fn +(rhs: [mut T]/&) -> [mut T] {\n+        append_mut(self, rhs)\n+    }\n+}\n+\n #[doc = \"Extension methods for vectors\"]\n impl extensions/&<T> for [const T]/& {\n     #[doc = \"Returns true if a vector contains no elements\"]\n@@ -2088,13 +2198,6 @@ mod tests {\n         assert addr == addr_imm;\n     }\n \n-    #[test]\n-    fn test_unshift() {\n-        let mut x = [1, 2, 3];\n-        unshift(x, 0);\n-        assert x == [0, 1, 2, 3];\n-    }\n-\n     #[test]\n     fn test_capacity() {\n         let mut v = [0u64];"}, {"sha": "254ed4d4ede42c5ff4fd1e5c2765af51705c6d42", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -16,11 +16,10 @@ export to_vec;\n export to_str;\n export eq_vec;\n \n-// FIXME: With recursive object types, we could implement binary methods like\n-//        union, intersection, and difference. At that point, we could write\n-//        an optimizing version of this module that produces a different obj\n-//        for the case where nbits <= 32.\n-// (Issue #2341)\n+// FIXME (#2341): With recursive object types, we could implement binary\n+// methods like union, intersection, and difference. At that point, we could\n+// write an optimizing version of this module that produces a different obj\n+// for the case where nbits <= 32.\n \n #[doc = \"The bitvector type\"]\n type bitv = @{storage: [mut uint], nbits: uint};"}, {"sha": "f57d2a21af6a41fada5a67d8f14df467ed11cbad", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -14,8 +14,8 @@ iface t<T> {\n     fn get(int) -> T;\n }\n \n-// FIXME eventually, a proper datatype plus an exported impl would be\n-// preferrable (#2343)\n+// FIXME (#2343) eventually, a proper datatype plus an exported impl would\n+// be preferrable.\n fn create<T: copy>() -> t<T> {\n     type cell<T> = option<T>;\n \n@@ -33,8 +33,8 @@ fn create<T: copy>() -> t<T> {\n         let nalloc = uint::next_power_of_two(nelts + 1u);\n         while i < nalloc {\n             if i < nelts {\n-                rv += [mut elts[(lo + i) % nelts]];\n-            } else { rv += [mut none]; }\n+                vec::push(rv, elts[(lo + i) % nelts]);\n+            } else { vec::push(rv, none); }\n             i += 1u;\n         }\n "}, {"sha": "c988b167fd0caf072fec8e13d8dde5745dec7c2c", "filename": "src/libstd/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -67,8 +67,8 @@ iface map<K, V: copy> {\n     fn each_value(fn(V) -> bool);\n }\n \n-// FIXME: package this up and export it as a datatype usable for\n-// external code that doesn't want to pay the cost of a box. (#2344)\n+// FIXME (#2344): package this up and export it as a datatype usable for\n+// external code that doesn't want to pay the cost of a box.\n mod chained {\n     export t, mk, hashmap;\n "}, {"sha": "64cded848d1abead4f9ff7c53f1925c5d41b7f15", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -36,7 +36,7 @@ fn format_addr(ip: ip_addr) -> str {\n         #fmt[\"%u.%u.%u.%u\", a as uint, b as uint, c as uint, d as uint]\n       }\n       ipv6(_, _, _, _, _, _, _, _) {\n-        fail \"FIXME impl parsing of ipv6 addr\";\n+        fail \"FIXME (#2651) impl parsing of ipv6 addr\";\n       }\n     }\n }"}, {"sha": "a2d36ac354b8e893a316ce1f43d0d3ccc449b6e9", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -2,15 +2,12 @@\n High-level interface to libuv's TCP functionality\n \"];\n \n-// FIXME: Fewer import *'s\n import ip = net_ip;\n import uv::iotask;\n import uv::iotask::iotask;\n-import comm::*;\n-import result::*;\n-import str::*;\n-import future::*;\n-import libc::size_t;\n+import comm::methods;\n+import future::future;\n+import result::{result,err,ok,extensions};\n \n // data\n export tcp_socket, tcp_conn_port, tcp_err_data;\n@@ -364,8 +361,8 @@ fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint,\n     let new_conn_po = comm::port::<result::result<*uv::ll::uv_tcp_t,\n                                                   tcp_err_data>>();\n     let new_conn_ch = comm::chan(new_conn_po);\n-    // FIXME: This shared box should not be captured in the i/o task\n-    // Make it a unique pointer.\n+    // FIXME (#2656): This shared box should not be captured in the i/o\n+    // task Make it a unique pointer.\n     let server_data: @tcp_conn_port_data = @{\n         server_stream: uv::ll::tcp_t(),\n         stream_closed_po: stream_closed_po,\n@@ -946,10 +943,10 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n           }\n         }\n     };\n-    // FIXME: Instead of passing unsafe pointers to local data, and waiting\n-    // here for the write to complete, we should transfer ownership of\n-    // everything to the I/O task and let it deal with the aftermath,\n-    // so we don't have to sit here blocking.\n+    // FIXME (#2656): Instead of passing unsafe pointers to local data,\n+    // and waiting here for the write to complete, we should transfer\n+    // ownership of everything to the I/O task and let it deal with the\n+    // aftermath, so we don't have to sit here blocking.\n     alt comm::recv(result_po) {\n       tcp_write_success { result::ok(()) }\n       tcp_write_error(err_data) { result::err(err_data.to_tcp_err()) }\n@@ -1191,20 +1188,16 @@ crust fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n                               status: libc::c_int) unsafe {\n     let write_data_ptr = uv::ll::get_data_for_req(write_req)\n         as *write_req_data;\n-    // FIXME: if instead of alt\n-    alt status {\n-      0i32 {\n+    if status == 0i32 {\n         log(debug, \"successful write complete\");\n         comm::send((*write_data_ptr).result_ch, tcp_write_success);\n-      }\n-      _ {\n+    } else {\n         let stream_handle_ptr = uv::ll::get_stream_handle_from_write_req(\n             write_req);\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(stream_handle_ptr);\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n         log(debug, \"failure to write\");\n         comm::send((*write_data_ptr).result_ch, tcp_write_error(err_data));\n-      }\n     }\n }\n \n@@ -1273,20 +1266,20 @@ type tcp_socket_data = {\n // convert rust ip_addr to libuv's native representation\n fn ipv4_ip_addr_to_sockaddr_in(input_ip: ip::ip_addr,\n                                port: uint) -> uv::ll::sockaddr_in unsafe {\n-    // FIXME ipv6\n+    // FIXME (#2656): ipv6\n     alt input_ip {\n       ip::ipv4(_,_,_,_) {\n         uv::ll::ip4_addr(ip::format_addr(input_ip), port as int)\n       }\n       ip::ipv6(_,_,_,_,_,_,_,_) {\n-        fail \"FIXME ipv6 not yet supported\";\n+        fail \"FIXME (#2656) ipv6 not yet supported\";\n       }\n     }\n }\n \n #[cfg(test)]\n mod test {\n-    // FIXME don't run on fbsd or linux 32 bit(#2064)\n+    // FIXME don't run on fbsd or linux 32 bit (#2064)\n     #[cfg(target_os=\"win32\")]\n     #[cfg(target_os=\"darwin\")]\n     #[cfg(target_os=\"linux\")]"}, {"sha": "e621fd787249d8113af5b355319a88cba0215ada", "filename": "src/libstd/par.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -7,7 +7,7 @@ import future::future;\n export map, mapi, alli, any, mapi_factory;\n \n #[doc=\"The maximum number of tasks this module will spawn for a single\n-operationg.\"]\n+operation.\"]\n const max_tasks : uint = 32u;\n \n #[doc=\"The minimum number of elements each task will process.\"]"}, {"sha": "a8cd3b65ef838c02ed325066881a2f417f0f5b78", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -864,7 +864,7 @@ mod node {\n         loop {\n             alt (leaf_iterator::next(it)) {\n               option::none   { break; }\n-              option::some(x) { forest += [mut @leaf(x)]; }\n+              option::some(x) { vec::push(forest, @leaf(x)); }\n             }\n         }\n         //2. Rebuild tree from forest"}, {"sha": "89e9d0338fe4eedef027e7fe0408c2f8a23428ed", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -6,8 +6,8 @@ import core::option;\n import core::option::{some, none};\n import dvec::{dvec, extensions};\n \n-// FIXME: Should not be @; there's a bug somewhere in rustc that requires this\n-// to be. (#2347)\n+// FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n+// requires this to be.\n type smallintmap<T: copy> = @{v: dvec<option<T>>};\n \n #[doc = \"Create a smallintmap\"]\n@@ -19,6 +19,7 @@ fn mk<T: copy>() -> smallintmap<T> {\n Add a value to the map. If the map already contains a value for\n the specified key then the original value is replaced.\n \"]\n+#[inline(always)]\n fn insert<T: copy>(self: smallintmap<T>, key: uint, val: T) {\n     self.v.grow_set_elt(key, none, some(val));\n }\n@@ -62,6 +63,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n         }\n         sz\n     }\n+    #[inline(always)]\n     fn insert(+key: uint, +value: V) -> bool {\n         let exists = contains_key(self, key);\n         insert(self, key, value);"}, {"sha": "d06749b57576326b6224a45e34d6857d487567d4", "filename": "src/libstd/time.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -319,15 +319,14 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 .chain { |pos| parse_type(s, pos, 'd', tm) }\n           }\n           'H' {\n-            // FIXME: range check. (#2350 -- same issue for all FIXMEs in this\n-            // file.)\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n               none { err(\"Invalid hour\") }\n             }\n           }\n           'I' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) {\n                   let (v, pos) = item;\n@@ -338,7 +337,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n             }\n           }\n           'j' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 3u, false) {\n               some(item) {\n                 let (v, pos) = item;\n@@ -349,14 +348,14 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n             }\n           }\n           'k' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, true) {\n               some(item) { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n               none { err(\"Invalid hour\") }\n             }\n           }\n           'l' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, true) {\n               some(item) {\n                   let (v, pos) = item;\n@@ -367,14 +366,14 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n             }\n           }\n           'M' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) { let (v, pos) = item; tm.tm_min = v; ok(pos) }\n               none { err(\"Invalid minute\") }\n             }\n           }\n           'm' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) {\n                 let (v, pos) = item;\n@@ -412,7 +411,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 .chain { |pos| parse_type(s, pos, 'p', tm) }\n           }\n           'S' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) {\n                 let (v, pos) = item;\n@@ -432,7 +431,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           }\n           't' { parse_char(s, pos, '\\t') }\n           'u' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 1u, false) {\n               some(item) {\n                 let (v, pos) = item;\n@@ -451,7 +450,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           }\n           //'W' {}\n           'w' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 1u, false) {\n               some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n               none { err(\"Invalid weekday\") }\n@@ -460,7 +459,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           //'X' {}\n           //'x' {}\n           'Y' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 4u, false) {\n               some(item) {\n                 let (v, pos) = item;\n@@ -471,7 +470,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n             }\n           }\n           'y' {\n-            // FIXME: range check.\n+            // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) {\n                 let (v, pos) = item;\n@@ -584,7 +583,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n \n fn strftime(format: str, tm: tm) -> str {\n     fn parse_type(ch: char, tm: tm) -> str {\n-        //FIXME: Implement missing types.\n+        //FIXME (#2350): Implement missing types.\n         alt check ch {\n           'A' {\n             alt check tm.tm_wday as int {\n@@ -915,7 +914,7 @@ mod tests {\n         assert local.tm_isdst == 0_i32;\n         assert local.tm_gmtoff == -28800_i32;\n \n-        // FIXME: We should probably standardize on the timezone\n+        // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let zone = local.tm_zone;\n         assert zone == \"PST\" || zone == \"Pacific Standard Time\";\n@@ -1063,8 +1062,8 @@ mod tests {\n         assert test(\"2009-02-13\", \"%F\");\n         assert test(\"03\", \"%H\");\n         assert test(\"13\", \"%H\");\n-        assert test(\"03\", \"%I\"); // FIXME: flesh out\n-        assert test(\"11\", \"%I\"); // FIXME: flesh out\n+        assert test(\"03\", \"%I\"); // FIXME (#2350): flesh out\n+        assert test(\"11\", \"%I\"); // FIXME (#2350): flesh out\n         assert test(\"044\", \"%j\");\n         assert test(\" 3\", \"%k\");\n         assert test(\"13\", \"%k\");\n@@ -1162,15 +1161,15 @@ mod tests {\n         assert local.strftime(\"%Y\") == \"2009\";\n         assert local.strftime(\"%y\") == \"09\";\n \n-        // FIXME: We should probably standardize on the timezone\n+        // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let zone = local.strftime(\"%Z\");\n         assert zone == \"PST\" || zone == \"Pacific Standard Time\";\n \n         assert local.strftime(\"%z\") == \"-0800\";\n         assert local.strftime(\"%%\") == \"%\";\n \n-        // FIXME: We should probably standardize on the timezone\n+        // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let rfc822 = local.rfc822();\n         let prefix = \"Fri, 13 Feb 2009 15:31:30 \";"}, {"sha": "b7e1ee7d82cdb5d99e79157eb8bcee1d326cb92b", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -505,7 +505,7 @@ native mod rustrt {\n                            tcp_handle_ptr: *uv_tcp_t,\n                            ++after_cb: *u8,\n                            ++addr: *sockaddr_in) -> libc::c_int;\n-    // FIXME ref 2064\n+    // FIXME ref #2064\n     fn rust_uv_tcp_bind(tcp_server: *uv_tcp_t,\n                         ++addr: *sockaddr_in) -> libc::c_int;\n     fn rust_uv_listen(stream: *libc::c_void, backlog: libc::c_int,"}, {"sha": "9d3dcb0f23e37cb6e28bd8109795f90d3fecc52c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -176,9 +176,7 @@ enum proto {\n \n #[auto_serialize]\n enum vstore {\n-    /* FIXME: Change uint to @expr (actually only constant exprs,\n-       as per #2112)\n-     */\n+    // FIXME (#2112): Change uint to @expr (actually only constant exprs)\n     vstore_fixed(option<uint>),   // [1,2,3,4]/_ or 4\n     vstore_uniq,                  // [1,2,3,4]/~\n     vstore_box,                   // [1,2,3,4]/@\n@@ -256,12 +254,11 @@ enum init_op { init_assign, init_move, }\n #[auto_serialize]\n type initializer = {op: init_op, expr: @expr};\n \n+// FIXME (pending discussion of #1697, #2178...): local should really be\n+// a refinement on pat.\n #[auto_serialize]\n-type local_ =  /* FIXME: should really be a refinement on pat\n-                  (pending discussion of #1697, #2178...)\n-                */\n-    {is_mutbl: bool, ty: @ty, pat: @pat,\n-     init: option<initializer>, id: node_id};\n+type local_ =  {is_mutbl: bool, ty: @ty, pat: @pat,\n+                init: option<initializer>, id: node_id};\n \n #[auto_serialize]\n type local = spanned<local_>;\n@@ -322,9 +319,8 @@ enum expr_ {\n     expr_block(blk),\n \n     /*\n-     * FIXME: many of these @exprs should be constrained with\n+     * FIXME (#34): many of these @exprs should be constrained with\n      * is_lval once we have constrained types working.\n-     * (See #34)\n      */\n     expr_copy(@expr),\n     expr_move(@expr, @expr),"}, {"sha": "9355da5779e17424841f70f87c98f6e023b36199", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -13,16 +13,16 @@ type path = [path_elt];\n fn path_to_str_with_sep(p: path, sep: str) -> str {\n     let strs = vec::map(p) {|e|\n         alt e {\n-          path_mod(s) { /* FIXME: bad */ copy *s }\n-          path_name(s) { /* FIXME: bad */ copy *s }\n+          path_mod(s) { /* FIXME (#2543) */ copy *s }\n+          path_name(s) { /* FIXME (#2543) */ copy *s }\n         }\n     };\n     str::connect(strs, sep)\n }\n \n fn path_ident_to_str(p: path, i: ident) -> str {\n     if vec::is_empty(p) {\n-        /* FIXME: bad */ copy *i\n+        /* FIXME (#2543) */ copy *i\n     } else {\n         #fmt[\"%s::%s\", path_to_str(p), *i]\n     }\n@@ -98,7 +98,7 @@ fn map_decoded_item(diag: span_handler,\n     // even if we did I think it only needs an ordering between local\n     // variables that are simultaneously in scope).\n     let cx = {map: map,\n-              mut path: /* FIXME: bad */ copy path,\n+              mut path: /* FIXME (#2543) */ copy path,\n               mut local_id: 0u,\n               diag: diag};\n     let v = mk_ast_map_visitor();\n@@ -124,27 +124,29 @@ fn map_decoded_item(diag: span_handler,\n fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n           sp: codemap::span, id: node_id, cx: ctx, v: vt) {\n     for decl.inputs.each {|a|\n-        cx.map.insert(a.id, node_arg(/* FIXME: bad */ copy a, cx.local_id));\n+        cx.map.insert(a.id,\n+                      node_arg(/* FIXME (#2543) */\n+                          copy a, cx.local_id));\n         cx.local_id += 1u;\n     }\n     alt fk {\n       visit::fk_ctor(nm, tps, self_id, parent_id) {\n           let ct = @{node: {id: id,\n                             self_id: self_id,\n-                            dec: /* FIXME: bad */ copy decl,\n-                            body: /* FIXME: bad */ copy body},\n+                            dec: /* FIXME (#2543) */ copy decl,\n+                            body: /* FIXME (#2543) */ copy body},\n                     span: sp};\n-          cx.map.insert(id, node_ctor(/* FIXME: bad */ copy nm,\n-                                      /* FIXME: bad */ copy tps,\n+          cx.map.insert(id, node_ctor(/* FIXME (#2543) */ copy nm,\n+                                      /* FIXME (#2543) */ copy tps,\n                                       class_ctor(ct, parent_id),\n-                                      @/* FIXME: bad */ copy cx.path));\n+                                      @/* FIXME (#2543) */ copy cx.path));\n        }\n       visit::fk_dtor(tps, self_id, parent_id) {\n           let dt = @{node: {id: id, self_id: self_id,\n-                     body: /* FIXME: bad */ copy body}, span: sp};\n-          cx.map.insert(id, node_dtor(/* FIXME: bad */ copy tps, dt,\n+                     body: /* FIXME (#2543) */ copy body}, span: sp};\n+          cx.map.insert(id, node_dtor(/* FIXME (#2543) */ copy tps, dt,\n                                       parent_id,\n-                                      @/* FIXME: bad */ copy cx.path));\n+                                      @/* FIXME (#2543) */ copy cx.path));\n        }\n \n        _ {}\n@@ -153,7 +155,7 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n }\n \n fn map_block(b: blk, cx: ctx, v: vt) {\n-    cx.map.insert(b.node.id, node_block(/* FIXME: bad */ copy b));\n+    cx.map.insert(b.node.id, node_block(/* FIXME (#2543) */ copy b));\n     visit::visit_block(b, cx, v);\n }\n \n@@ -187,7 +189,7 @@ fn map_method(impl_did: def_id, impl_path: @path,\n }\n \n fn map_item(i: @item, cx: ctx, v: vt) {\n-    let item_path = @/* FIXME: bad */ copy cx.path;\n+    let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     alt i.node {\n       item_impl(_, _, _, _, ms) {\n@@ -198,17 +200,18 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         }\n       }\n       item_res(decl, tps, _, dtor_id, ctor_id, _) {\n-        cx.map.insert(ctor_id, node_ctor(/* FIXME: bad */ copy i.ident,\n-                                         /* FIXME: bad */ copy tps,\n-                                         res_ctor(/* FIXME: bad */ copy decl,\n+        cx.map.insert(ctor_id, node_ctor(/* FIXME (#2543) */ copy i.ident,\n+                                         /* FIXME (#2543) */ copy tps,\n+                                         res_ctor(/* FIXME (#2543) */\n+                                                  copy decl,\n                                                   ctor_id, i.span),\n                                          item_path));\n         cx.map.insert(dtor_id, node_item(i, item_path));\n       }\n       item_enum(vs, _, _) {\n         for vs.each {|v|\n             cx.map.insert(v.node.id, node_variant(\n-                /* FIXME: bad */ copy v, i,\n+                /* FIXME (#2543) */ copy v, i,\n                 extend(cx, i.ident)));\n         }\n       }\n@@ -220,7 +223,8 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         for nm.items.each {|nitem|\n             cx.map.insert(nitem.id,\n                           node_native_item(nitem, abi,\n-                                           @/* FIXME: bad */ copy cx.path));\n+                                           /* FIXME (#2543) */\n+                                           @copy cx.path));\n         }\n       }\n       item_class(tps, ifces, items, ctor, dtor, _) {\n@@ -251,7 +255,9 @@ fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n       view_item_export(vps) {\n         for vps.each {|vp|\n             let (id, name) = alt vp.node {\n-              view_path_simple(nm, _, id) { (id, /* FIXME: bad */ copy nm) }\n+              view_path_simple(nm, _, id) {\n+                (id, /* FIXME (#2543) */ copy nm)\n+              }\n               view_path_glob(pth, id) | view_path_list(pth, _, id) {\n                 (id, path_to_ident(pth))\n               }\n@@ -294,19 +300,19 @@ fn node_id_to_str(map: map, id: node_id) -> str {\n       }\n       // FIXMEs are as per #2410\n       some(node_export(_, path)) {\n-        #fmt[\"export %s (id=%?)\", // FIXME: add more info here\n+        #fmt[\"export %s (id=%?)\", // add more info here\n              path_to_str(*path), id]\n       }\n-      some(node_arg(_, _)) { // FIXME: add more info here\n+      some(node_arg(_, _)) { // add more info here\n         #fmt[\"arg (id=%?)\", id]\n       }\n-      some(node_local(_)) { // FIXME: add more info here\n+      some(node_local(_)) { // add more info here\n         #fmt[\"local (id=%?)\", id]\n       }\n-      some(node_ctor(*)) { // FIXME: add more info here\n+      some(node_ctor(*)) { // add more info here\n         #fmt[\"node_ctor (id=%?)\", id]\n       }\n-      some(node_dtor(*)) { // FIXME: add more info here\n+      some(node_dtor(*)) { // add more info here\n         #fmt[\"node_dtor (id=%?)\", id]\n       }\n       some(node_block(_)) {"}, {"sha": "8ce34a06329e85594a116d118a7593bde90b3ccc", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -159,7 +159,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n             for variants.each {|v|\n                 if v.node.name == i {\n                    local = true;\n-                   parent_enum = some(/* FIXME: bad */ copy it.ident);\n+                   parent_enum = some(/* FIXME (#2543) */ copy it.ident);\n                 }\n             }\n           }\n@@ -268,7 +268,7 @@ pure fn is_unguarded(&&a: arm) -> bool {\n }\n \n pure fn unguarded_pat(a: arm) -> option<[@pat]> {\n-    if is_unguarded(a) { some(/* FIXME: bad */ copy a.pats) } else { none }\n+    if is_unguarded(a) { some(/* FIXME (#2543) */ copy a.pats) } else { none }\n }\n \n // Provides an extra node_id to hang callee information on, in case the\n@@ -278,8 +278,8 @@ fn op_expr_callee_id(e: @expr) -> node_id { e.id - 1 }\n \n pure fn class_item_ident(ci: @class_member) -> ident {\n     alt ci.node {\n-      instance_var(i,_,_,_,_) { /* FIXME: bad */ copy i }\n-      class_method(it) { /* FIXME: bad */ copy it.ident }\n+      instance_var(i,_,_,_,_) { /* FIXME (#2543) */ copy i }\n+      class_method(it) { /* FIXME (#2543) */ copy it.ident }\n     }\n }\n \n@@ -297,7 +297,7 @@ fn split_class_items(cs: [@class_member]) -> ([ivar], [@method]) {\n     for cs.each {|c|\n       alt c.node {\n         instance_var(i, t, cm, id, vis) {\n-          vs += [{ident: /* FIXME: bad */ copy i,\n+          vs += [{ident: /* FIXME (#2543) */ copy i,\n                   ty: t,\n                   cm: cm,\n                   id: id,\n@@ -319,11 +319,11 @@ pure fn class_member_visibility(ci: @class_member) -> visibility {\n impl inlined_item_methods for inlined_item {\n     fn ident() -> ident {\n         alt self {\n-          ii_item(i) { /* FIXME: bad */ copy i.ident }\n-          ii_native(i) { /* FIXME: bad */ copy i.ident }\n-          ii_method(_, m) { /* FIXME: bad */ copy m.ident }\n-          ii_ctor(_, nm, _, _) { /* FIXME: bad */ copy nm }\n-          ii_dtor(_, nm, _, _) { /* FIXME: bad */ copy nm }\n+          ii_item(i) { /* FIXME (#2543) */ copy i.ident }\n+          ii_native(i) { /* FIXME (#2543) */ copy i.ident }\n+          ii_method(_, m) { /* FIXME (#2543) */ copy m.ident }\n+          ii_ctor(_, nm, _, _) { /* FIXME (#2543) */ copy nm }\n+          ii_dtor(_, nm, _, _) { /* FIXME (#2543) */ copy nm }\n         }\n     }\n \n@@ -480,12 +480,17 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             vfn(id);\n         },\n \n-        visit_fn: fn@(fk: visit::fn_kind, d: fn_decl,\n-                      _b: blk, _sp: span, id: node_id) {\n+        visit_fn: fn@(fk: visit::fn_kind, d: ast::fn_decl,\n+                      _b: ast::blk, _sp: span, id: ast::node_id) {\n             vfn(id);\n \n             alt fk {\n-              visit::fk_ctor(_, tps, self_id, parent_id) |\n+              visit::fk_ctor(nm, tps, self_id, parent_id) {\n+                vec::iter(tps) {|tp| vfn(tp.id)}\n+                vfn(id);\n+                vfn(self_id);\n+                vfn(parent_id.node);\n+              }\n               visit::fk_dtor(tps, self_id, parent_id) {\n                 vec::iter(tps) {|tp| vfn(tp.id)}\n                 vfn(id);\n@@ -500,7 +505,11 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n                 vfn(m.self_id);\n                 vec::iter(tps) {|tp| vfn(tp.id)}\n               }\n-              visit::fk_anon(*) | visit::fk_fn_block(*) {\n+              visit::fk_anon(_, capture_clause)\n+              | visit::fk_fn_block(capture_clause) {\n+                for vec::each(*capture_clause) {|clause|\n+                    vfn(clause.id);\n+                }\n               }\n             }\n "}, {"sha": "fb9560065a86ee77410ce332dedc540701f9fbd4", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -91,9 +91,9 @@ fn get_attr_name(attr: ast::attribute) -> ast::ident {\n // All \"bad\" FIXME copies are as per #2543\n fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n     alt meta.node {\n-      ast::meta_word(n) { /* FIXME bad */ copy n }\n-      ast::meta_name_value(n, _) { /* FIXME bad */ copy n }\n-      ast::meta_list(n, _) { /* FIXME bad */ copy n }\n+      ast::meta_word(n) { /* FIXME (#2543) */ copy n }\n+      ast::meta_name_value(n, _) { /* FIXME (#2543) */ copy n }\n+      ast::meta_list(n, _) { /* FIXME (#2543) */ copy n }\n     }\n }\n \n@@ -120,7 +120,7 @@ fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@str> {\n #[doc = \"Gets a list of inner meta items from a list meta_item type\"]\n fn get_meta_item_list(meta: @ast::meta_item) -> option<[@ast::meta_item]> {\n     alt meta.node {\n-      ast::meta_list(_, l) { option::some(/* FIXME bad */ copy l) }\n+      ast::meta_list(_, l) { option::some(/* FIXME (#2543) */ copy l) }\n       _ { option::none }\n     }\n }\n@@ -266,15 +266,15 @@ fn last_meta_item_list_by_name(\n \n /* Higher-level applications */\n \n-// FIXME: This needs to sort by meta_item variant in addition to the item name\n-// (See [Fixme-sorting])\n+// FIXME (#607): This needs to sort by meta_item variant in addition to\n+// the item name (See [Fixme-sorting])\n fn sort_meta_items(+items: [@ast::meta_item]) -> [@ast::meta_item] {\n     fn lteq(&&ma: @ast::meta_item, &&mb: @ast::meta_item) -> bool {\n         fn key(m: @ast::meta_item) -> ast::ident {\n             alt m.node {\n-              ast::meta_word(name) { /* FIXME bad */ copy name }\n-              ast::meta_name_value(name, _) { /* FIXME bad */ copy name }\n-              ast::meta_list(name, _) { /* FIXME bad */ copy name }\n+              ast::meta_word(name) { /* FIXME (#2543) */ copy name }\n+              ast::meta_name_value(name, _) { /* FIXME (#2543) */ copy name }\n+              ast::meta_list(name, _) { /* FIXME (#2543) */ copy name }\n             }\n         }\n         ret key(ma) <= key(mb);\n@@ -292,7 +292,7 @@ fn remove_meta_items_by_name(items: [@ast::meta_item], name: ast::ident) ->\n     ret vec::filter_map(items, {\n         |item|\n         if get_meta_item_name(item) != name {\n-            option::some(/* FIXME bad */ copy item)\n+            option::some(/* FIXME (#2543) */ copy item)\n         } else {\n             option::none\n         }\n@@ -317,7 +317,7 @@ linkage\n fn find_linkage_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n     find_linkage_attrs(attrs).flat_map {|attr|\n         alt check attr.node.value.node {\n-          ast::meta_list(_, items) { /* FIXME bad */ copy items }\n+          ast::meta_list(_, items) { /* FIXME (#2543) */ copy items }\n         }\n     }\n }"}, {"sha": "49560fb5bbdd9c4c13d4a391af0d50db455f663f", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -123,7 +123,7 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n     let loc = lookup_char_pos(map, pos);\n     alt (loc.file.substr) {\n       fss_none {\n-        {filename: /* FIXME bad */ copy loc.file.name,\n+        {filename: /* FIXME (#2543) */ copy loc.file.name,\n          line: loc.line,\n          col: loc.col,\n          file: some(loc.file)}\n@@ -132,7 +132,7 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n         lookup_char_pos_adj(map, sp.lo + (pos - loc.file.start_pos.ch))\n       }\n       fss_external(eloc) {\n-        {filename: /* FIXME bad */ copy eloc.filename,\n+        {filename: /* FIXME (#2543) */ copy eloc.filename,\n          line: eloc.line + loc.line - 1u,\n          col: if loc.line == 1u {eloc.col + loc.col} else {loc.col},\n          file: none}\n@@ -178,7 +178,7 @@ type file_lines = {file: filemap, lines: [uint]};\n \n fn span_to_filename(sp: span, cm: codemap::codemap) -> filename {\n     let lo = lookup_char_pos(cm, sp.lo);\n-    ret /* FIXME bad */ copy lo.file.name;\n+    ret /* FIXME (#2543) */ copy lo.file.name;\n }\n \n fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {"}, {"sha": "b8ebb27f51b83d5563b7c0d726ff69e0de3fdfd8", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -201,7 +201,7 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     // arbitrarily only print up to six lines of the error\n     let max_lines = 6u;\n     let mut elided = false;\n-    let mut display_lines = /* FIXME bad */ copy lines.lines;\n+    let mut display_lines = /* FIXME (#2543) */ copy lines.lines;\n     if vec::len(display_lines) > max_lines {\n         display_lines = vec::slice(display_lines, 0u, max_lines);\n         elided = true;"}, {"sha": "26a906f8cf0cce8a3c97d4e8f36391ebb6637822", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -11,8 +11,8 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n     let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), \"env\");\n \n-    // FIXME: if this was more thorough it would manufacture an\n-    // option<str> rather than just an maybe-empty string. (Issue #2248)\n+    // FIXME (#2248): if this was more thorough it would manufacture an\n+    // option<str> rather than just an maybe-empty string.\n \n     let var = expr_to_str(cx, args[0], \"#env requires a string\");\n     alt os::getenv(var) {"}, {"sha": "26313e974946342780e6f0819ed784313141089a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -109,10 +109,10 @@ fn new_span(cx: ext_ctxt, sp: span) -> span {\n     ret {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n }\n \n-// FIXME: this is a terrible kludge to inject some macros into the default\n-// compilation environment. When the macro-definition system is substantially\n-// more mature, these should move from here, into a compiled part of libcore\n-// at very least. (Issue #2247)\n+// FIXME (#2247): this is a terrible kludge to inject some macros into\n+// the default compilation environment. When the macro-definition system\n+// is substantially more mature, these should move from here, into a\n+// compiled part of libcore at very least.\n \n fn core_macros() -> str {\n     ret"}, {"sha": "0cc4ba0a570a0ed1911f2af66084d82f7ef86f01", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -30,11 +30,10 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     ret pieces_to_expr(cx, sp, pieces, args);\n }\n \n-// FIXME: A lot of these functions for producing expressions can probably\n-// be factored out in common with other code that builds expressions.\n-// FIXME: Cleanup the naming of these functions\n+// FIXME (#2249): A lot of these functions for producing expressions can\n+// probably be factored out in common with other code that builds\n+// expressions.  Also: Cleanup the naming of these functions.\n // NOTE: Moved many of the common ones to build.rs --kevina\n-// See Issue #2249\n fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n    -> @ast::expr {\n     fn make_path_vec(_cx: ext_ctxt, ident: ast::ident) -> [ast::ident] {"}, {"sha": "3f3eb0012507bc34b34a9e93049e3e7663e673d5", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -104,8 +104,8 @@ fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n               with *default_visitor()};\n     let cx = @{lo:lo, gather: dvec()};\n     node.visit(cx, mk_vt(v));\n-    // FIXME: Maybe this is an overkill (merge_sort), it might be better\n-    //   to just keep the gather array in sorted order ... (Issue #2250)\n+    // FIXME (#2250): Maybe this is an overkill (merge_sort), it might\n+    // be better to just keep the gather array in sorted order.\n     cx.gather.swap { |v|\n         vec::to_mut(std::sort::merge_sort({|a,b| a.lo < b.lo}, v))\n     };"}, {"sha": "4dad13dc06a526d70ad42e45740bce705035b67e", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -466,8 +466,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n               }\n             }\n           }\n-          /* FIXME: handle embedded types and blocks, at least\n-             (Issue #2251) */\n+          /* FIXME (#2251): handle embedded types and blocks, at least */\n           expr_mac(mac) {\n             p_t_s_r_mac(cx, mac, s, b);\n           }\n@@ -722,8 +721,8 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                         [@{params: pattern_to_selectors(cx, arg),\n                            body: elts[1u]}];\n \n-                    // FIXME: check duplicates (or just simplify\n-                    // the macro arg situation) (Issue #2251)\n+                    // FIXME (#2251): check duplicates (or just simplify\n+                    // the macro arg situation)\n                   }\n                   _ {\n                       cx.span_bug(mac.span, \"undocumented invariant in \\"}, {"sha": "ff296eb5aad3c0d2b89a6e9ed97028769503f323", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -88,11 +88,12 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n                 meta_word(id) { meta_word(fld.fold_ident(id)) }\n                 meta_list(id, mis) {\n                   let fold_meta_item = {|x|fold_meta_item_(x, fld)};\n-                  meta_list(/* FIXME: bad */ copy id,\n+                  meta_list(/* FIXME: (#2543) */ copy id,\n                             vec::map(mis, fold_meta_item))\n                 }\n                 meta_name_value(id, s) {\n-                  meta_name_value(fld.fold_ident(id), /* FIXME: bad */ copy s)\n+                  meta_name_value(fld.fold_ident(id),\n+                                  /* FIXME (#2543) */ copy s)\n                 }\n               },\n           span: fld.new_span(mi.span)};\n@@ -123,8 +124,8 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n                mac_embed_type(ty) { mac_embed_type(fld.fold_ty(ty)) }\n                mac_embed_block(blk) { mac_embed_block(fld.fold_block(blk)) }\n                mac_ellipsis { mac_ellipsis }\n-               mac_aq(_,_) { /* FIXME: bad */ copy m.node }\n-               mac_var(_) { /* FIXME: bad */ copy m.node }\n+               mac_aq(_,_) { /* FIXME (#2543) */ copy m.node }\n+               mac_var(_) { /* FIXME (#2543) */ copy m.node }\n              },\n          span: fld.new_span(m.span)};\n }\n@@ -145,7 +146,7 @@ fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n }\n \n fn fold_ty_param(tp: ty_param, fld: ast_fold) -> ty_param {\n-    {ident: /* FIXME: bad */ copy tp.ident,\n+    {ident: /* FIXME (#2543) */ copy tp.ident,\n      id: fld.new_id(tp.id),\n      bounds: @vec::map(*tp.bounds, {|x|fold_ty_param_bound(x, fld)})}\n }\n@@ -168,20 +169,20 @@ fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n    crate_directive_ {\n     ret alt cd {\n           cdir_src_mod(id, attrs) {\n-            cdir_src_mod(fld.fold_ident(id), /* FIXME: bad */ copy attrs)\n+            cdir_src_mod(fld.fold_ident(id), /* FIXME (#2543) */ copy attrs)\n           }\n           cdir_dir_mod(id, cds, attrs) {\n             cdir_dir_mod(fld.fold_ident(id),\n                          vec::map(cds, fld.fold_crate_directive),\n-                         /* FIXME: bad */ copy attrs)\n+                         /* FIXME (#2543) */ copy attrs)\n           }\n           cdir_view_item(vi) { cdir_view_item(fld.fold_view_item(vi)) }\n           cdir_syntax(_) { copy cd }\n         }\n }\n \n fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n-    ret /* FIXME: bad */ copy vi;\n+    ret /* FIXME (#2543) */ copy vi;\n }\n \n \n@@ -223,8 +224,8 @@ fn noop_fold_class_item(&&ci: @class_member, fld: ast_fold)\n     -> @class_member {\n     @{node: alt ci.node {\n         instance_var(ident, t, cm, id, p) {\n-           instance_var(/* FIXME: bad */ copy ident, fld.fold_ty(t), cm, id,\n-                        p)\n+           instance_var(/* FIXME (#2543) */ copy ident,\n+                        fld.fold_ty(t), cm, id, p)\n         }\n         class_method(m) { class_method(fld.fold_method(m)) }\n       },\n@@ -260,7 +261,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                         id: dtor_id with dtor.node}\n                     with dtor}};\n               item_class(\n-                  /* FIXME: bad */ copy typms,\n+                  /* FIXME (#2543) */ copy typms,\n                   vec::map(ifaces, {|p| fold_iface_ref(p, fld) }),\n                   vec::map(items, fld.fold_class_item),\n                   {node: {body: ctor_body,\n@@ -278,7 +279,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_iface(tps, rp, methods) {\n             item_iface(fold_ty_params(tps, fld),\n                        rp,\n-                       /* FIXME: bad */ copy methods)\n+                       /* FIXME (#2543) */ copy methods)\n           }\n           item_res(decl, typms, body, did, cid, rp) {\n             item_res(fold_fn_decl(decl, fld),\n@@ -297,7 +298,7 @@ fn fold_iface_ref(&&p: @iface_ref, fld: ast_fold) -> @iface_ref {\n \n fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n     ret @{ident: fld.fold_ident(m.ident),\n-          attrs: /* FIXME: bad */ copy m.attrs,\n+          attrs: /* FIXME (#2543) */ copy m.attrs,\n           tps: fold_ty_params(m.tps, fld),\n           decl: fold_fn_decl(m.decl, fld),\n           body: fld.fold_block(m.body),\n@@ -344,7 +345,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           pat_rec(fields, etc) {\n             let mut fs = [];\n             for fields.each {|f|\n-                fs += [{ident: /* FIXME: bad */ copy f.ident,\n+                fs += [{ident: /* FIXME (#2543) */ copy f.ident,\n                         pat: fld.fold_pat(f.pat)}];\n             }\n             pat_rec(fs, etc)\n@@ -507,13 +508,13 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n }\n \n fn noop_fold_constr(c: constr_, fld: ast_fold) -> constr_ {\n-    {path: fld.fold_path(c.path), args: /* FIXME: bad */ copy c.args,\n+    {path: fld.fold_path(c.path), args: /* FIXME (#2543) */ copy c.args,\n      id: fld.new_id(c.id)}\n }\n \n fn noop_fold_ty_constr(c: ty_constr_, fld: ast_fold) -> ty_constr_ {\n     let rslt: ty_constr_ =\n-        {path: fld.fold_path(c.path), args: /* FIXME: bad */ copy c.args,\n+        {path: fld.fold_path(c.path), args: /* FIXME (#2543) */ copy c.args,\n          id: fld.new_id(c.id)};\n     rslt\n }\n@@ -542,15 +543,15 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n       some(e) {some(fld.fold_expr(e))}\n       none {none}\n     };\n-    ret {name: /* FIXME: bad */ copy v.name,\n+    ret {name: /* FIXME (#2543) */ copy v.name,\n          attrs: attrs,\n          args: args, id: fld.new_id(v.id),\n          disr_expr: de,\n          vis: v.vis};\n }\n \n fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident {\n-    ret /* FIXME: bad */ copy i;\n+    ret /* FIXME (#2543) */ copy i;\n }\n \n fn noop_fold_path(&&p: path, fld: ast_fold) -> path {\n@@ -644,7 +645,7 @@ impl of ast_fold for ast_fold_precursor {\n     fn fold_class_item(&&ci: @class_member) -> @class_member {\n         @{node: alt ci.node {\n            instance_var(nm, t, mt, id, p) {\n-               instance_var(/* FIXME: bad */ copy nm,\n+               instance_var(/* FIXME (#2543) */ copy nm,\n                             (self as ast_fold).fold_ty(t), mt, id, p)\n            }\n            class_method(m) {"}, {"sha": "d062f4bde6d69f582bd06fc976aa0bf87a46e856", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -17,7 +17,7 @@ import attr::parser_attr;\n import common::parser_common;\n import ast::node_id;\n import util::interner;\n-// FIXME: resolve badness\n+// FIXME (#1935): resolve badness\n import lexer::*;//{string_reader_as_reader, tt_reader_as_reader,\n                //reader, string_reader, tt_reader};\n import diagnostic::{span_handler, mk_span_handler, mk_handler, emitter};\n@@ -75,7 +75,7 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n     let cdirs = p.parse_crate_directives(token::EOF, first_cdir_attr);\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n-    let cx = @{sess: sess, cfg: /* FIXME: bad */ copy p.cfg};\n+    let cx = @{sess: sess, cfg: /* FIXME (#2543) */ copy p.cfg};\n     let (companionmod, _) = path::splitext(path::basename(input));\n     let (m, attrs) = eval::eval_crate_directives_to_mod(\n         cx, cdirs, prefix, option::some(companionmod));\n@@ -85,7 +85,7 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n                           {directives: cdirs,\n                            module: m,\n                            attrs: crate_attrs + attrs,\n-                           config: /* FIXME: bad */ copy p.cfg});\n+                           config: /* FIXME (#2543) */ copy p.cfg});\n }\n \n fn parse_crate_from_source_file(input: str, cfg: ast::crate_cfg,"}, {"sha": "f1415cb9e203c2f59e0a1060b979169959b2fc40", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -203,7 +203,7 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n         let {tok: tok, sp: sp} = rdr.next_token();\n         if token::is_lit(tok) {\n             let s = get_str_from(rdr, bstart);\n-            literals += [{lit: s, pos: sp.lo}];\n+            vec::push(literals, {lit: s, pos: sp.lo});\n             log(debug, \"tok lit: \" + s);\n         } else {\n             log(debug, \"tok: \" + token::to_str(*rdr.interner, tok));"}, {"sha": "52cb9366df8c4693649e3a0ccba9c10eab984770", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -93,8 +93,8 @@ impl parser_common for parser {\n     fn eat_keyword(word: str) -> bool {\n         self.require_keyword(word);\n \n-        // FIXME: this gratuitous use of @ is to\n-        // workaround LLVM bug #13042\n+        // FIXME (#13042): this gratuitous use of @ is to\n+        // workaround LLVM bug.\n         alt @self.token {\n           @token::IDENT(sid, false) {\n             if str::eq(word, *self.get_str(sid)) {\n@@ -159,7 +159,7 @@ impl parser_common for parser {\n                        else { self.expect(t); } }\n               _ { }\n             }\n-            v += [f(self)];\n+            vec::push(v, f(self));\n         }\n \n         ret v;\n@@ -202,7 +202,7 @@ impl parser_common for parser {\n               _ { }\n             }\n             if sep.trailing_sep_allowed && self.token == ket { break; }\n-            v += [f(self)];\n+            vec::push(v, f(self));\n         }\n         ret v;\n     }"}, {"sha": "ae11c883443623147286ec113bdfdb97518d73fe", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -103,7 +103,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n \n         let i = p0.mk_item(cdir.span.lo, cdir.span.hi,\n-                           /* FIXME: bad */ copy id,\n+                           /* FIXME (#2543) */ copy id,\n                            ast::item_mod(m0), ast::public, mod_attrs);\n         // Thread defids, chpos and byte_pos through the parsers\n         cx.sess.chpos = r0.chpos;\n@@ -119,7 +119,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n         let (m0, a0) = eval_crate_directives_to_mod(\n             cx, cdirs, full_path, none);\n         let i =\n-            @{ident: /* FIXME: bad */ copy id,\n+            @{ident: /* FIXME (#2543) */ copy id,\n               attrs: attrs + a0,\n               id: cx.sess.next_id,\n               node: ast::item_mod(m0),"}, {"sha": "02b34e8dc865548773acab8ebfea0797f5ce45ca", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -154,7 +154,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token::token, sp: span} {\n             ret ret_val;\n           }\n           tt_frame_up(option::some(tt_f)) {\n-            r.cur <- tt_f;\n+            r.cur = tt_f;\n             /* the above `if` would need to be a `while` if we didn't know\n             that the last thing in a `tt_delim` is always a `tt_flat` */\n             r.cur.idx += 1u;\n@@ -414,9 +414,9 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n             bump(rdr);\n             ret token::LIT_FLOAT(intern(*rdr.interner, @num_str),\n                                  ast::ty_f64);\n-            /* FIXME: if this is out of range for either a 32-bit or\n-            64-bit float, it won't be noticed till the back-end (Issue #2252)\n-            */\n+            /* FIXME (#2252): if this is out of range for either a\n+            32-bit or 64-bit float, it won't be noticed till the\n+            back-end.  */\n         } else {\n             is_float = true;\n         }"}, {"sha": "46e838fd4bef0f6f34edb8d23a74cacb956305ce", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -17,10 +17,10 @@ import dvec::{dvec, extensions};\n export file_type;\n export parser;\n \n-// FIXME: #ast expects to find this here but it's actually defined in `parse`\n-// Fixing this will be easier when we have export decls on individual items --\n-// then parse can export this publicly, and everything else crate-visibly.\n-// (See #1893)\n+// FIXME (#1893): #ast expects to find this here but it's actually\n+// defined in `parse` Fixing this will be easier when we have export\n+// decls on individual items -- then parse can export this publicly, and\n+// everything else crate-visibly.\n import parse_from_source_str;\n export parse_from_source_str;\n \n@@ -172,10 +172,10 @@ class parser {\n             {mode: mode, ty: p.parse_ty(false), ident: name,\n              id: p.get_id()}\n         };\n-        // FIXME: constrs is empty because right now, higher-order functions\n-        // can't have constrained types.\n-        // Not sure whether that would be desirable anyway. See #34 for the\n-        // story on constrained types.\n+        // FIXME (#34): constrs is empty because right now, higher-order\n+        // functions can't have constrained types. Not sure whether\n+        // that would be desirable anyway. See bug for the story on\n+        // constrained types.\n         let constrs: [@constr] = [];\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         ret {inputs: inputs, output: ret_ty,\n@@ -2039,7 +2039,7 @@ class parser {\n     }\n \n     fn parse_ctor(result_ty: ast::ty_) -> class_contents {\n-        // Can ctors/dtors have attrs? FIXME\n+        // FIXME (#2660): Can ctors/dtors have attrs?\n         let lo = self.last_span.lo;\n         let (decl_, _) = self.parse_fn_decl(impure_fn, {|p| p.parse_arg()});\n         let decl = {output: @{id: self.get_id(),\n@@ -2050,7 +2050,7 @@ class parser {\n     }\n \n     fn parse_dtor() -> class_contents {\n-        // Can ctors/dtors have attrs? FIXME\n+        // FIXME (#2660): Can ctors/dtors have attrs?\n         let lo = self.last_span.lo;\n         let body = self.parse_block();\n         dtor_decl(body, mk_sp(lo, self.last_span.hi))"}, {"sha": "89f3b2d3aba960579d48070dafa597dd77a1a9ee", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -545,12 +545,11 @@ fn print_item(s: ps, &&item: @ast::item) {\n           }\n           for items.each {|ci|\n                   /*\n-                     FIXME: collect all private items and print them\n-                     in a single \"priv\" section\n+                     FIXME (#1893): collect all private items and print\n+                     them in a single \"priv\" section\n \n                      tjc: I'm not going to fix this yet b/c we might\n                      change how exports work, including for class items\n-                     (see #1893)\n                    */\n              hardbreak_if_not_bol(s);\n              maybe_print_comment(s, ci.span.lo);"}, {"sha": "5d27ee1452fe0267e17d565ae799c2e41d900dde", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -28,7 +28,7 @@ enum fn_kind {\n fn name_of_fn(fk: fn_kind) -> ident {\n     alt fk {\n       fk_item_fn(name, _) | fk_method(name, _, _) | fk_res(name, _, _)\n-          | fk_ctor(name, _, _, _) { /* FIXME: bad */ copy name }\n+          | fk_ctor(name, _, _, _) { /* FIXME (#2543) */ copy name }\n       fk_anon(*) | fk_fn_block(*) { @\"anon\" }\n       fk_dtor(*)                  { @\"drop\" }\n     }\n@@ -38,7 +38,7 @@ fn tps_of_fn(fk: fn_kind) -> [ty_param] {\n     alt fk {\n       fk_item_fn(_, tps) | fk_method(_, tps, _) | fk_res(_, tps, _)\n               | fk_ctor(_, tps, _, _) | fk_dtor(tps, _, _) {\n-          /* FIXME: bad */ copy tps\n+          /* FIXME (#2543) */ copy tps\n       }\n       fk_anon(*) | fk_fn_block(*) { [] }\n     }\n@@ -117,8 +117,8 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     alt i.node {\n       item_const(t, ex) { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n       item_fn(decl, tp, body) {\n-        v.visit_fn(fk_item_fn(/* FIXME: bad */ copy i.ident,\n-                              /* FIXME: bad */ copy tp), decl, body,\n+        v.visit_fn(fk_item_fn(/* FIXME (#2543) */ copy i.ident,\n+                              /* FIXME (#2543) */ copy tp), decl, body,\n                    i.span, i.id, e, v);\n       }\n       item_mod(m) { v.visit_mod(m, i.span, i.id, e, v); }\n@@ -131,8 +131,8 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         v.visit_ty_params(tps, e, v);\n       }\n       item_res(decl, tps, body, dtor_id, _, rp) {\n-        v.visit_fn(fk_res(/* FIXME: bad */ copy i.ident,\n-                          /* FIXME: bad */ copy tps,\n+        v.visit_fn(fk_res(/* FIXME (#2543) */ copy i.ident,\n+                          /* FIXME (#2543) */ copy tps,\n                           rp),\n                    decl, body, i.span, dtor_id, e, v);\n       }\n@@ -287,23 +287,24 @@ fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n-    v.visit_fn(fk_method(/* FIXME: bad */ copy m.ident,\n-                         /* FIXME: bad */ copy m.tps, m),\n+    v.visit_fn(fk_method(/* FIXME (#2543) */ copy m.ident,\n+                         /* FIXME (#2543) */ copy m.tps, m),\n                m.decl, m.body, m.span, m.id, e, v);\n }\n \n // Similar logic to the comment on visit_method_helper - Tim\n fn visit_class_ctor_helper<E>(ctor: class_ctor, nm: ident, tps: [ty_param],\n                               parent_id: def_id, e: E, v: vt<E>) {\n-    v.visit_fn(fk_ctor(/* FIXME: bad */ copy nm, /* FIXME: bad */ copy tps,\n+    v.visit_fn(fk_ctor(/* FIXME (#2543) */ copy nm,\n+                       /* FIXME (#2543) */ copy tps,\n                        ctor.node.self_id, parent_id), ctor.node.dec,\n                ctor.node.body, ctor.span, ctor.node.id, e, v)\n \n }\n \n fn visit_class_dtor_helper<E>(dtor: class_dtor, tps: [ty_param],\n                               parent_id: def_id, e: E, v: vt<E>) {\n-    v.visit_fn(fk_dtor(/* FIXME: bad */ copy tps, dtor.node.self_id,\n+    v.visit_fn(fk_dtor(/* FIXME (#2543) */ copy tps, dtor.node.self_id,\n                        parent_id), ast_util::dtor_dec(),\n                dtor.node.body, dtor.span, dtor.node.id, e, v)\n "}, {"sha": "7f2205b573a8c77d9890257aa4b0e19f01685d0e", "filename": "src/rt/arch/i386/morestack.S", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fmorestack.S?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -213,15 +213,6 @@ MORESTACK:\n \n \tpopl %ebp\n \n-\t// FIXME: I don't think these rules are necessary\n-\t// since the unwinder should never encounter an instruction\n-\t// pointer pointing here.\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n-\t// Restore the rule for how to find %ebp\n-\t.cfi_restore %ebp\n-\t// Tell the unwinder how to find the CFA in terms of %esp\n-\t.cfi_def_cfa %esp, 16\n-#endif\n \tretl $8\n \n .L$bail:"}, {"sha": "4ae21a3c4f69b01f732b06e2ec423f317de1cd0b", "filename": "src/rt/arch/x86_64/morestack.S", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -51,7 +51,7 @@ MORESTACK:\n \n         subq $184, %rsp\n \n-\t// FIXME: libgcc also saves rax. not sure if we need to\n+\t// FIXME: libgcc also saves rax. not sure if we need to (#2685)\n \n \t// Save argument registers of the original function\n \tmovq %rdi,       (%rsp)\n@@ -133,11 +133,6 @@ MORESTACK:\n \n \tpopq %rax // Restore the return value\n \tpopq %rbp\n-\t// FIXME: I don't think these rules are necessary\n-\t// since the unwinder should never encounter an instruction\n-\t// pointer pointing here.\n-\t.cfi_restore %rbp\n-\t.cfi_def_cfa %rsp, 16\n \tret\n \t\n \t.cfi_endproc"}, {"sha": "be8689672a897f993f43cb25d7bc0a84d09fb502", "filename": "src/rt/memory_region.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Fmemory_region.h", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Fmemory_region.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.h?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -2,8 +2,8 @@\n  * The Rust runtime uses memory regions to provide a primitive level of\n  * memory management and isolation between tasks, and domains.\n  *\n- * FIXME: Implement a custom lock-free malloc / free instead of relying solely\n- *       on the standard malloc / free.\n+ * FIXME (#2686): Implement a custom lock-free malloc / free instead of\n+ *       relying solely on the standard malloc / free.\n  */\n \n #ifndef MEMORY_REGION_H"}, {"sha": "67b3bf84938bed092c24f61f10820e777cb25a1b", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -68,7 +68,7 @@ command_line_args : public kernel_owned<command_line_args>\n \n // A global that indicates whether Rust typestate claim statements should be\n // executed Generated code will read this variable directly (I think).\n-// FIXME: This belongs somewhere else\n+// FIXME (#2670): This belongs somewhere else\n int check_claims = 0;\n \n /**"}, {"sha": "cab1b6b427cbffca9fcb3233abcc9490ea1d866e", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -232,7 +232,7 @@ rand_free(randctx *rctx) {\n \n /* Debug helpers strictly to verify ABI conformance.\n  *\n- * FIXME: move these into a testcase when the testsuite\n+ * FIXME (#2665): move these into a testcase when the testsuite\n  * understands how to have explicit C files included.\n  */\n \n@@ -288,18 +288,20 @@ debug_opaque(type_desc *t, uint8_t *front) {\n     rust_task *task = rust_get_current_task();\n     LOG(task, stdlib, \"debug_opaque\");\n     debug_tydesc_helper(t);\n-    // FIXME may want to actually account for alignment.  `front` may not\n-    // indeed be the front byte of the passed-in argument.\n+    // FIXME (#2667) may want to actually account for alignment.\n+    // `front` may not indeed be the front byte of the passed-in\n+    // argument.\n     for (uintptr_t i = 0; i < t->size; ++front, ++i) {\n         LOG(task, stdlib, \"  byte %\" PRIdPTR \": 0x%\" PRIx8, i, *front);\n     }\n }\n \n-// FIXME this no longer reflects the actual structure of boxes!\n+// FIXME (#2667) this no longer reflects the actual structure of boxes!\n struct rust_box {\n     RUST_REFCOUNTED(rust_box)\n \n-    // FIXME `data` could be aligned differently from the actual box body data\n+    // FIXME (#2667) `data` could be aligned differently from the actual\n+    // box body data\n     uint8_t data[];\n };\n \n@@ -635,7 +637,7 @@ extern \"C\" CDECL rust_task*\n rust_new_task_in_sched(rust_sched_id id) {\n     rust_task *task = rust_get_current_task();\n     rust_scheduler *sched = task->kernel->get_scheduler_by_id(id);\n-    // FIXME: What if we didn't get the scheduler?\n+    // FIXME (#2668): What if we didn't get the scheduler?\n     return new_task_common(sched, task);\n }\n "}, {"sha": "ed31ddd9dad7527b573e01947f2023aad6511c18", "filename": "src/rt/rust_cc.cpp", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_cc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_cc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cc.cpp?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -79,7 +79,7 @@ class irc : public shape::data<irc,shape::ptr> {\n         shape::ptr data_end = sub.end_dp = shape::ptr(data_range.second);\n         while (sub.dp < data_end) {\n             sub.walk_reset();\n-            // FIXME: shouldn't this be 'sub.align = true;'?\n+            // FIXME (#2669): shouldn't this be 'sub.align = true;'?\n             align = true;\n         }\n     }\n@@ -214,7 +214,7 @@ irc::walk_variant2(shape::tag_info &tinfo, uint32_t variant_id,\n                    variant_ptr_and_end) {\n     irc sub(*this, variant_ptr_and_end.first);\n \n-    assert(variant_id < 256);   // FIXME: Temporary sanity check.\n+    assert(variant_id < 256);   // FIXME (#2666): Temporary sanity check.\n \n     const uint8_t *variant_end = variant_ptr_and_end.second;\n     while (sub.sp < variant_end) {\n@@ -329,7 +329,7 @@ class mark : public shape::data<mark,shape::ptr> {\n             return;\n \n         if (data_range.second - data_range.first > 100000)\n-            abort();    // FIXME: Temporary sanity check.\n+            abort();    // FIXME (#2666): Temporary sanity check.\n \n         mark sub(*this, shape::ptr(data_range.first));\n         shape::ptr data_end = sub.end_dp = shape::ptr(data_range.second);\n@@ -454,7 +454,7 @@ mark::walk_variant2(shape::tag_info &tinfo, uint32_t variant_id,\n                    variant_ptr_and_end) {\n     mark sub(*this, variant_ptr_and_end.first);\n \n-    assert(variant_id < 256);   // FIXME: Temporary sanity check.\n+    assert(variant_id < 256);   // FIXME (#2666): Temporary sanity check.\n \n     const uint8_t *variant_end = variant_ptr_and_end.second;\n     while (sub.sp < variant_end) {\n@@ -550,7 +550,9 @@ maybe_cc(rust_task *task) {\n         return;\n     }\n \n-    // FIXME: Needs a snapshot.\n+    // FIXME (#1498): depressingly, due to alignment bugs the whole file is\n+    // disabled presently unless you're doing testing. Remove the whole thing\n+    // when we transition to using a visitor for GC/CC.\n #if 0\n     if (task->cc_counter++ > RUST_CC_FREQUENCY) {\n         task->cc_counter = 0;"}, {"sha": "68f9e3d451984f4ba4d2380a7ae36fd7ff93b9c1", "filename": "src/rt/rust_debug.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_debug.h", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_debug.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_debug.h?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -34,7 +34,7 @@ class flag {\n     flag(const char *in_name) : name(in_name), valid(false) {}\n \n     bool operator*() {\n-        // FIXME: We ought to lock this.\n+        // FIXME (#2689): We ought to lock this.\n         if (!valid) {\n             char *ev = getenv(name);\n             value = ev && ev[0] != '\\0' && ev[0] != '0';"}, {"sha": "b13b1490c0f8bd2f42fdbddd5f10666d3dc0a5a7", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -184,23 +184,22 @@ rust_kernel::run() {\n     return rval;\n }\n \n-// FIXME: Fix all these FIXMEs\n void\n rust_kernel::fail() {\n-    // FIXME: On windows we're getting \"Application has requested the\n-    // Runtime to terminate it in an unusual way\" when trying to shutdown\n-    // cleanly.\n+    // FIXME (#2671): On windows we're getting \"Application has\n+    // requested the Runtime to terminate it in an unusual way\" when\n+    // trying to shutdown cleanly.\n     set_exit_status(PROC_FAIL_CODE);\n #if defined(__WIN32__)\n     exit(rval);\n #endif\n     // Copy the list of schedulers so that we don't hold the lock while\n     // running kill_all_tasks.\n-    // FIXME: There's a lot that happens under kill_all_tasks, and I don't\n-    // know that holding sched_lock here is ok, but we need to hold the\n-    // sched lock to prevent the scheduler from being destroyed while\n-    // we are using it. Probably we need to make rust_scheduler atomicly\n-    // reference counted.\n+    // FIXME (#2671): There's a lot that happens under kill_all_tasks,\n+    // and I don't know that holding sched_lock here is ok, but we need\n+    // to hold the sched lock to prevent the scheduler from being\n+    // destroyed while we are using it. Probably we need to make\n+    // rust_scheduler atomicly reference counted.\n     std::vector<rust_scheduler*> scheds;\n     {\n         scoped_lock with(sched_lock);\n@@ -210,9 +209,9 @@ rust_kernel::fail() {\n         }\n     }\n \n-    // FIXME: This is not a foolproof way to kill all tasks while ensuring\n-    // that no new tasks or schedulers are created in the meantime that\n-    // keep the scheduler alive.\n+    // FIXME (#2671): This is not a foolproof way to kill all tasks\n+    // while ensuring that no new tasks or schedulers are created in the\n+    // meantime that keep the scheduler alive.\n     for (std::vector<rust_scheduler*>::iterator iter = scheds.begin();\n          iter != scheds.end(); iter++) {\n         (*iter)->kill_all_tasks();"}, {"sha": "5074b1f40c6a242ed0e1ca57e2e4331c5000dc67", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -126,7 +126,7 @@ rust_log::trace_ln(rust_task *task, uint32_t level, char *message) {\n         assert(!task->on_rust_stack() && \"logging on rust stack\");\n     }\n \n-    // FIXME: The scheduler and task names used to have meaning,\n+    // FIXME (#2672): The scheduler and task names used to have meaning,\n     // but they are always equal to 'main' currently\n #if 0\n \n@@ -233,8 +233,9 @@ void update_crate_map(const cratemap* map, log_directive* dirs,\n     // First update log levels for this crate\n     update_module_map(map->entries, dirs, n_dirs, n_matches);\n     // Then recurse on linked crates\n-    // FIXME this does double work in diamond-shaped deps. could keep\n-    //   a set of visited addresses, if it turns out to be actually slow\n+    // FIXME (#2673) this does double work in diamond-shaped deps. could\n+    //   keep a set of visited addresses, if it turns out to be actually\n+    //   slow\n     for (size_t i = 0; map->children[i]; i++) {\n         update_crate_map(map->children[i], dirs, n_dirs, n_matches);\n     }"}, {"sha": "739527b84eb7413f338043794ac86907f3cfe183", "filename": "src/rt/rust_run_program.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_run_program.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_run_program.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_run_program.cpp?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -160,7 +160,7 @@ rust_run_program(const char* argv[],\n     for (int fd = getdtablesize() - 1; fd >= 3; fd--) close(fd);\n     if (dir) {\n         int result = chdir(dir);\n-        // FIXME: need error handling\n+        // FIXME (#2674): need error handling\n         assert(!result && \"chdir failed\");\n     }\n \n@@ -178,7 +178,7 @@ rust_run_program(const char* argv[],\n \n extern \"C\" CDECL int\n rust_process_wait(int proc) {\n-    // FIXME: stub; exists to placate linker.\n+    // FIXME: stub; exists to placate linker. (#2692)\n     return 0;\n }\n "}, {"sha": "a69084fc3adb0b33812b48bbacc25d0bb1ebce78", "filename": "src/rt/rust_sched_loop.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -134,7 +134,7 @@ rust_task *\n rust_sched_loop::schedule_task() {\n     lock.must_have_lock();\n     assert(this);\n-    // FIXME: in the face of failing tasks, this is not always right.\n+    // FIXME: in the face of failing tasks, this is not always right. (#2695)\n     // assert(n_live_tasks() > 0);\n     if (running_tasks.length() > 0) {\n         size_t k = isaac_rand(&rctx);"}, {"sha": "61fd8ac05fd6cdfc5f1505c30b904a1263dcab7b", "filename": "src/rt/rust_sched_loop.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_sched_loop.h", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_sched_loop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.h?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -87,10 +87,7 @@ struct rust_sched_loop\n     memory_region local_region;\n \n     randctx rctx;\n-\n-    // FIXME: Neither of these are used\n-    int32_t list_index;\n-    const char *const name;\n+    const char *const name; // Used for debugging\n \n     // Only a pointer to 'name' is kept, so it must live as long as this\n     // domain."}, {"sha": "74e6d6bf2bd1641945aa8e2ef23f3691220799ea", "filename": "src/rt/rust_scheduler.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_scheduler.h", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_scheduler.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.h?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -16,7 +16,7 @@ class rust_sched_launcher;\n class rust_sched_launcher_factory;\n \n class rust_scheduler : public kernel_owned<rust_scheduler> {\n-    // FIXME: Make these private\n+    // FIXME (#2693): Make these private\n public:\n     rust_kernel *kernel;\n private:"}, {"sha": "cfac33008b94725393ea1f94600e578f91dd1a9c", "filename": "src/rt/rust_shape.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -43,8 +43,6 @@ const uint8_t SHAPE_I64 = 7u;\n const uint8_t SHAPE_F32 = 8u;\n const uint8_t SHAPE_F64 = 9u;\n const uint8_t SHAPE_BOX = 10u;\n-// FIXME: remove after snapshot (6/18/12)\n-const uint8_t SHAPE_VEC = 11u;\n const uint8_t SHAPE_TAG = 12u;\n const uint8_t SHAPE_STRUCT = 17u;\n const uint8_t SHAPE_BOX_FN = 18u;\n@@ -86,7 +84,7 @@ class arena {\n \n     template<typename T>\n     inline T *alloc(size_t count = 1) {\n-        // FIXME: align\n+        // FIXME: align (probably won't fix before #1498)\n         size_t sz = count * sizeof(T);\n         T *rv = (T *)ptr;\n         ptr += sz;\n@@ -304,7 +302,6 @@ ctxt<T>::walk() {\n     case SHAPE_I64:      WALK_NUMBER(int64_t);       break;\n     case SHAPE_F32:      WALK_NUMBER(float);         break;\n     case SHAPE_F64:      WALK_NUMBER(double);        break;\n-    case SHAPE_VEC:      walk_vec0();             break;\n     case SHAPE_TAG:      walk_tag0();             break;\n     case SHAPE_BOX:      walk_box0();             break;\n     case SHAPE_STRUCT:   walk_struct0();          break;\n@@ -897,7 +894,8 @@ class data : public ctxt< data<T,U> > {\n     void walk_tag1(tag_info &tinfo);\n \n     void walk_struct1(const uint8_t *end_sp) {\n-        // FIXME: shouldn't we be aligning to the first element here?\n+        // FIXME (probably won't fix before #1498): shouldn't we be aligning\n+        // to the first element here?\n         static_cast<T *>(this)->walk_struct2(end_sp);\n     }\n "}, {"sha": "adbd75f1c90c760bec2070108885f0794d00ff6f", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -59,15 +59,16 @@ rust_task::delete_this()\n     DLOG(sched_loop, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n          name, (uintptr_t)this, ref_count);\n \n-    // FIXME: We should do this when the task exits, not in the destructor\n+    // FIXME (#2677): We should do this when the task exits, not in the\n+    // destructor\n     {\n         scoped_lock with(supervisor_lock);\n         if (supervisor) {\n             supervisor->deref();\n         }\n     }\n \n-    /* FIXME: tighten this up, there are some more\n+    /* FIXME (#2677): tighten this up, there are some more\n        assertions that hold at task-lifecycle events. */\n     assert(ref_count == 0); // ||\n     //   (ref_count == 1 && this == sched->root_task));\n@@ -114,13 +115,14 @@ cleanup_task(cleanup_args *args) {\n         }\n     }\n \n-    // FIXME: For performance we should do the annihilator instead\n-    // of the cycle collector even under normal termination, but\n+    // FIXME (#2676): For performance we should do the annihilator\n+    // instead of the cycle collector even under normal termination, but\n     // since that would hide memory management errors (like not derefing\n     // boxes), it needs to be disableable in debug builds.\n     if (threw_exception) {\n-        // FIXME: When the annihilator is more powerful and successfully\n-        // runs resource destructors, etc. we can get rid of this cc\n+        // FIXME (#2676): When the annihilator is more powerful and\n+        // successfully runs resource destructors, etc. we can get rid\n+        // of this cc\n         cc::do_cc(task);\n         annihilate_boxes(task);\n     }\n@@ -287,7 +289,7 @@ void\n rust_task::begin_failure(char const *expr, char const *file, size_t line) {\n \n     if (expr) {\n-        // FIXME: Change this message to be\n+        // FIXME (#2678): Change this message to be\n         // 'task failed at ...'\n         LOG_ERR(this, task, \"upcall fail '%s', %s:%\" PRIdPTR,\n                 expr, file, line);\n@@ -301,7 +303,7 @@ rust_task::begin_failure(char const *expr, char const *file, size_t line) {\n #else\n     die();\n     conclude_failure();\n-    // FIXME: Need unwinding on windows. This will end up aborting\n+    // FIXME (#908): Need unwinding on windows. This will end up aborting\n     sched_loop->fail();\n #endif\n }\n@@ -458,7 +460,7 @@ rust_task::calloc(size_t size, const char *tag) {\n \n void\n rust_task::notify(bool success) {\n-    // FIXME (1078) Do this in rust code\n+    // FIXME (#1078) Do this in rust code\n     if(notify_enabled) {\n         rust_port *target_port =\n             kernel->get_port_by_id(notify_port);\n@@ -622,7 +624,7 @@ rust_task::reset_stack_limit() {\n     uintptr_t sp = get_sp();\n     // Have to do the rest on the C stack because it involves\n     // freeing stack segments, logging, etc.\n-    // FIXME: This probably doesn't need to happen on the C\n+    // FIXME (#2679): This probably doesn't need to happen on the C\n     // stack now\n     reset_args ra = {this, sp};\n     call_on_c_stack(&ra, (void*)reset_stack_limit_on_c_stack);"}, {"sha": "2a58725c6a43a937205c32b4008755baa7cf16fb", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -18,10 +18,11 @@\n    threads at any time. This may keep the task from being destroyed even after\n    the task is dead from a Rust task lifecycle perspective.\n \n-   FIXME: The task and the scheduler have an over-complicated, undocumented\n-   protocol for shutting down the task, hopefully without races. It would be\n-   easier to reason about if other runtime objects could not access the task\n-   from arbitrary threads, and didn't need to be atomically refcounted.\n+   FIXME (#2696): The task and the scheduler have an over-complicated,\n+   undocumented protocol for shutting down the task, hopefully without\n+   races. It would be easier to reason about if other runtime objects could\n+   not access the task from arbitrary threads, and didn't need to be\n+   atomically refcounted.\n  */\n \n #ifndef RUST_TASK_H\n@@ -42,8 +43,9 @@\n \n // The amount of extra space at the end of each stack segment, available\n // to the rt, compiler and dynamic linker for running small functions\n-// FIXME: We want this to be 128 but need to slim the red zone calls down,\n-// disable lazy symbol relocation, and other things we haven't discovered yet\n+// FIXME (#1509): We want this to be 128 but need to slim the red zone calls\n+// down, disable lazy symbol relocation, and other things we haven't\n+// discovered yet\n #define RZ_LINUX_32 (1024*2)\n #define RZ_LINUX_64 (1024*2)\n #define RZ_MAC_32   (1024*20)\n@@ -303,7 +305,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     void allow_kill();\n };\n \n-// FIXME: It would be really nice to be able to get rid of this.\n+// FIXME (#2697): It would be really nice to be able to get rid of this.\n inline void *operator new[](size_t size, rust_task *task, const char *tag) {\n     return task->malloc(size, tag);\n }\n@@ -360,9 +362,9 @@ sanitize_next_sp(uintptr_t next_sp) {\n     // to the amount of stack needed for calling __morestack I've added some\n     // extra bytes here.\n \n-    // FIXME: On the rust stack this potentially puts is quite far into the\n-    // red zone. Might want to just allocate a new rust stack every time we\n-    // switch back to rust.\n+    // FIXME (#2698): On the rust stack this potentially puts is quite far\n+    // into the red zone. Might want to just allocate a new rust stack every\n+    // time we switch back to rust.\n     const uintptr_t padding = 16;\n \n     return align_down(next_sp - padding);\n@@ -416,7 +418,7 @@ rust_task::call_on_rust_stack(void *args, void *fn_ptr) {\n \n     uintptr_t sp = sanitize_next_sp(next_rust_sp);\n \n-    // FIXME(2047): There are times when this is called and needs\n+    // FIXME (#2047): There are times when this is called and needs\n     // to be able to throw, and we don't account for that.\n     __morestack(args, fn_ptr, sp);\n \n@@ -529,7 +531,7 @@ rust_task::record_stack_limit() {\n inline rust_task* rust_get_current_task() {\n     uintptr_t sp_limit = get_sp_limit();\n \n-    // FIXME (1226) - Because of a hack in upcall_call_shim_on_c_stack this\n+    // FIXME (#1226) - Because of a hack in upcall_call_shim_on_c_stack this\n     // value is sometimes inconveniently set to 0, so we can't use this\n     // method of retreiving the task pointer and need to fall back to TLS.\n     if (sp_limit == 0)"}, {"sha": "940cf3aa01a6f1e3b74eab66549e2c9cb1bf7e3d", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 44, "deletions": 84, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -49,7 +49,7 @@ extern \"C\" CDECL void\n upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n     rust_task *task = rust_get_current_task();\n \n-    // FIXME (1226) - The shim functions generated by rustc contain the\n+    // FIXME (#1226) - The shim functions generated by rustc contain the\n     // morestack prologue, so we need to let them know they have enough\n     // stack.\n     record_sp_limit(0);\n@@ -72,9 +72,9 @@ extern \"C\" CDECL void\n upcall_call_shim_on_rust_stack(void *args, void *fn_ptr) {\n     rust_task *task = rust_get_current_task();\n \n-    // FIXME: Because of the hack in the other function that disables the\n-    // stack limit when entering the C stack, here we restore the stack limit\n-    // again.\n+    // FIXME (#2680): Because of the hack in the other function that disables\n+    // the stack limit when entering the C stack, here we restore the stack\n+    // limit again.\n     task->record_stack_limit();\n \n     try {\n@@ -86,7 +86,7 @@ upcall_call_shim_on_rust_stack(void *args, void *fn_ptr) {\n         assert(false && \"Rust task failed after reentering the Rust stack\");\n     }\n \n-    // FIXME: As above\n+    // FIXME (#2680): As above\n     record_sp_limit(0);\n }\n \n@@ -143,66 +143,46 @@ upcall_trace(char const *msg,\n  * Allocate an object in the exchange heap\n  */\n \n-extern \"C\" CDECL uintptr_t\n-exchange_malloc(rust_task *task, type_desc *td, uintptr_t size) {\n-\n-    LOG(task, mem, \"upcall exchange malloc(0x%\" PRIxPTR \")\", td);\n-\n-    size_t total_size = get_box_size(size, td->align);\n-    void *p = task->kernel->calloc(total_size, \"exchange malloc\");\n-\n-    rust_opaque_box *header = static_cast<rust_opaque_box*>(p);\n-    header->ref_count = -1; // This is not ref counted\n-    header->td = td;\n-    header->prev = 0;\n-    header->next = 0;\n-\n-    return (uintptr_t)header;\n-}\n-\n-// FIXME: remove after snapshot (6/13/12)\n struct s_exchange_malloc_args {\n     rust_task *task;\n     uintptr_t retval;\n     type_desc *td;\n+    uintptr_t size;\n };\n \n extern \"C\" CDECL void\n upcall_s_exchange_malloc(s_exchange_malloc_args *args) {\n     rust_task *task = args->task;\n     LOG_UPCALL_ENTRY(task);\n+    LOG(task, mem, \"upcall exchange malloc(0x%\" PRIxPTR \")\", args->td);\n+\n+    size_t total_size = get_box_size(args->size, args->td->align);\n+    // FIXME--does this have to be calloc? (Issue #2682)\n+    void *p = task->kernel->calloc(total_size, \"exchange malloc\");\n+\n+    rust_opaque_box *header = static_cast<rust_opaque_box*>(p);\n+    header->ref_count = -1; // This is not ref counted\n+    header->td = args->td;\n+    header->prev = 0;\n+    header->next = 0;\n \n-    args->retval = exchange_malloc(task, args->td, args->td->size);\n+    args->retval = (uintptr_t)header;\n }\n \n extern \"C\" CDECL uintptr_t\n-upcall_exchange_malloc(type_desc *td) {\n+upcall_exchange_malloc(type_desc *td, uintptr_t size) {\n     rust_task *task = rust_get_current_task();\n-    s_exchange_malloc_args args = {task, 0, td};\n+    s_exchange_malloc_args args = {task, 0, td, size};\n     UPCALL_SWITCH_STACK(task, &args, upcall_s_exchange_malloc);\n     return args.retval;\n }\n \n-struct s_exchange_malloc_dyn_args {\n-    rust_task *task;\n-    uintptr_t retval;\n-    type_desc *td;\n-    uintptr_t size;\n-};\n-\n-extern \"C\" CDECL void\n-upcall_s_exchange_malloc_dyn(s_exchange_malloc_dyn_args *args) {\n-    rust_task *task = args->task;\n-    LOG_UPCALL_ENTRY(task);\n-\n-    args->retval = exchange_malloc(task, args->td, args->size);\n-}\n-\n+// FIXME (#2681): remove after snapshot (6/21/12)\n extern \"C\" CDECL uintptr_t\n upcall_exchange_malloc_dyn(type_desc *td, uintptr_t size) {\n     rust_task *task = rust_get_current_task();\n-    s_exchange_malloc_dyn_args args = {task, 0, td, size};\n-    UPCALL_SWITCH_STACK(task, &args, upcall_s_exchange_malloc_dyn);\n+    s_exchange_malloc_args args = {task, 0, td, size};\n+    UPCALL_SWITCH_STACK(task, &args, upcall_s_exchange_malloc);\n     return args.retval;\n }\n \n@@ -229,69 +209,49 @@ upcall_exchange_free(void *ptr) {\n  * Allocate an object in the task-local heap.\n  */\n \n-extern \"C\" CDECL uintptr_t\n-shared_malloc(rust_task *task, type_desc *td, uintptr_t size) {\n-    LOG(task, mem, \"upcall malloc(0x%\" PRIxPTR \")\", td);\n-\n-    cc::maybe_cc(task);\n-\n-    // FIXME--does this have to be calloc?\n-    rust_opaque_box *box = task->boxed.calloc(td, size);\n-    void *body = box_body(box);\n-\n-    debug::maybe_track_origin(task, box);\n-\n-    LOG(task, mem,\n-        \"upcall malloc(0x%\" PRIxPTR \") = box 0x%\" PRIxPTR\n-        \" with body 0x%\" PRIxPTR,\n-        td, (uintptr_t)box, (uintptr_t)body);\n-\n-    return (uintptr_t)box;\n-}\n-\n-// FIXME: remove after snapshot (6/13/12)\n struct s_malloc_args {\n     rust_task *task;\n     uintptr_t retval;\n     type_desc *td;\n+    uintptr_t size;\n };\n \n extern \"C\" CDECL void\n upcall_s_malloc(s_malloc_args *args) {\n     rust_task *task = args->task;\n     LOG_UPCALL_ENTRY(task);\n+    LOG(task, mem, \"upcall malloc(0x%\" PRIxPTR \")\", args->td);\n+\n+    cc::maybe_cc(task);\n+\n+    // FIXME--does this have to be calloc? (Issue #2682)\n+    rust_opaque_box *box = task->boxed.calloc(args->td, args->size);\n+    void *body = box_body(box);\n+\n+    debug::maybe_track_origin(task, box);\n \n-    args->retval = shared_malloc(task, args->td, args->td->size);\n+    LOG(task, mem,\n+        \"upcall malloc(0x%\" PRIxPTR \") = box 0x%\" PRIxPTR\n+        \" with body 0x%\" PRIxPTR,\n+        args->td, (uintptr_t)box, (uintptr_t)body);\n+\n+    args->retval = (uintptr_t)box;\n }\n \n extern \"C\" CDECL uintptr_t\n-upcall_malloc(type_desc *td) {\n+upcall_malloc(type_desc *td, uintptr_t size) {\n     rust_task *task = rust_get_current_task();\n-    s_malloc_args args = {task, 0, td};\n+    s_malloc_args args = {task, 0, td, size};\n     UPCALL_SWITCH_STACK(task, &args, upcall_s_malloc);\n     return args.retval;\n }\n \n-struct s_malloc_dyn_args {\n-    rust_task *task;\n-    uintptr_t retval;\n-    type_desc *td;\n-    uintptr_t size;\n-};\n-\n-extern \"C\" CDECL void\n-upcall_s_malloc_dyn(s_malloc_dyn_args *args) {\n-    rust_task *task = args->task;\n-    LOG_UPCALL_ENTRY(task);\n-\n-    args->retval = shared_malloc(task, args->td, args->size);\n-}\n-\n+// FIXME (#2681): remove after snapshot (6/21/12)\n extern \"C\" CDECL uintptr_t\n upcall_malloc_dyn(type_desc *td, uintptr_t size) {\n     rust_task *task = rust_get_current_task();\n-    s_malloc_dyn_args args = {task, 0, td, size};\n-    UPCALL_SWITCH_STACK(task, &args, upcall_s_malloc_dyn);\n+    s_malloc_args args = {task, 0, td, size};\n+    UPCALL_SWITCH_STACK(task, &args, upcall_s_malloc);\n     return args.retval;\n }\n "}, {"sha": "247f253fd9f4412f553d53f2c27d55d555e5aa3f", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -111,7 +111,7 @@ make_str_vec(rust_kernel* kernel, size_t nstrs, char **strs) {\n \n inline size_t get_box_size(size_t body_size, size_t body_align) {\n     size_t header_size = sizeof(rust_opaque_box);\n-    // FIXME: This alignment calculation is suspicious. Is it right?\n+    // FIXME (#2699): This alignment calculation is suspicious. Is it right?\n     size_t total_size = align_to(header_size, body_align) + body_size;\n     return total_size;\n }"}, {"sha": "9558aaa7c06b976afadcc0be478269f9bd91826f", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -9,7 +9,8 @@\n  * if you're using a pthreads cvar+mutex pair.\n  */\n \n-// FIXME: This is not a portable way of specifying an invalid pthread_t\n+// FIXME (#2683): This is not a portable way of specifying an invalid\n+// pthread_t\n #define INVALID_THREAD 0\n \n "}, {"sha": "ed11b1aa321b304b4683ecf76f7a93f1fbb0e911", "filename": "src/rt/sync/lock_free_queue.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Fsync%2Flock_free_queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Fsync%2Flock_free_queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_free_queue.h?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -88,8 +88,8 @@ class lock_free_queue {\n         pointer_t *oldValue,\n         pointer_t newValue) {\n \n-        // FIXME this is requiring us to pass -fno-strict-aliasing to GCC\n-        // (possibly there are other, similar problems)\n+        // FIXME (#2701) this is requiring us to pass -fno-strict-aliasing\n+        // to GCC (possibly there are other, similar problems)\n         if (sync::compare_and_swap(\n                 (uint64_t*) address,\n                 *(uint64_t*) oldValue,"}, {"sha": "0204517d51239e6eac7d4d0d65fe18a1ea6455bf", "filename": "src/rt/sync/timer.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Fsync%2Ftimer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frt%2Fsync%2Ftimer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Ftimer.cpp?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -10,7 +10,7 @@ uint64_t ns_per_s = 1000000000LL;\n timer::timer() {\n #if __WIN32__\n     _ticks_per_s = 0LL;\n-    // FIXME: assert this works or have a workaround.\n+    // FIXME (#2675): assert this works or have a workaround.\n     QueryPerformanceFrequency((LARGE_INTEGER *)&_ticks_per_s);\n     if (_ticks_per_s == 0LL) {\n       _ticks_per_s = 1LL;"}, {"sha": "4875fbd69ca6bcd40f366a02a2f24cfe660464e5", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -85,13 +85,12 @@ mod write {\n             }\n         }\n         if !sess.no_verify() { llvm::LLVMAddVerifierPass(pm.llpm); }\n-        // FIXME: This is mostly a copy of the bits of opt's -O2 that are\n-        // available in the C api.\n-        // FIXME2: We might want to add optimization levels like -O1, -O2,\n+        // FIXME (#2396): This is mostly a copy of the bits of opt's -O2 that\n+        // are available in the C api.\n+        // Also: We might want to add optimization levels like -O1, -O2,\n         // -Os, etc\n-        // FIXME3: Should we expose and use the pass lists used by the opt\n+        // Also: Should we expose and use the pass lists used by the opt\n         // tool?\n-        // See #2396\n \n         if opts.optimize != 0u {\n             let fpm = mk_pass_manager();\n@@ -668,9 +667,8 @@ fn link_binary(sess: session,\n     // Stack growth requires statically linking a __morestack function\n     cc_args += [\"-lmorestack\"];\n \n-    // FIXME: At some point we want to rpath our guesses as to where\n+    // FIXME (#2397): At some point we want to rpath our guesses as to where\n     // native libraries might live, based on the addl_lib_search_paths\n-    // #2397\n     cc_args += rpath::get_rpath_flags(sess, output);\n \n     #debug(\"%s link args: %s\", cc_prog, str::connect(cc_args, \" \"));"}, {"sha": "2cae381431d012873e773896194446650e026c1a", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -10,9 +10,9 @@ import lib::llvm::{type_names, ModuleRef, ValueRef, TypeRef};\n type upcalls =\n     {_fail: ValueRef,\n      trace: ValueRef,\n-     malloc_dyn: ValueRef,\n+     malloc: ValueRef,\n      free: ValueRef,\n-     exchange_malloc_dyn: ValueRef,\n+     exchange_malloc: ValueRef,\n      exchange_free: ValueRef,\n      validate_box: ValueRef,\n      mark: ValueRef,\n@@ -55,14 +55,14 @@ fn declare_upcalls(targ_cfg: @session::config,\n           trace: dv(\"trace\", [T_ptr(T_i8()),\n                               T_ptr(T_i8()),\n                               int_t]),\n-          malloc_dyn:\n-              nothrow(d(\"malloc_dyn\",\n+          malloc:\n+              nothrow(d(\"malloc\",\n                         [T_ptr(tydesc_type), int_t],\n                         T_ptr(T_i8()))),\n           free:\n               nothrow(dv(\"free\", [T_ptr(T_i8())])),\n-          exchange_malloc_dyn:\n-              nothrow(d(\"exchange_malloc_dyn\",\n+          exchange_malloc:\n+              nothrow(d(\"exchange_malloc\",\n                         [T_ptr(tydesc_type), int_t],\n                         T_ptr(T_i8()))),\n           exchange_free:"}, {"sha": "553db7695a8a9b0e4f388a150835004cb36b0d88", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -78,9 +78,9 @@ fn build_configuration(sess: session, argv0: str, input: input) ->\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n fn parse_cfgspecs(cfgspecs: [str]) -> ast::crate_cfg {\n-    // FIXME: It would be nice to use the parser to parse all varieties of\n-    // meta_item here. At the moment we just support the meta_word variant.\n-    // #2399\n+    // FIXME (#2399): It would be nice to use the parser to parse all\n+    // varieties of meta_item here. At the moment we just support the\n+    // meta_word variant.\n     let mut words = [];\n     for cfgspecs.each {|s| words += [attr::mk_word_item(@s)]; }\n     ret words;\n@@ -100,8 +100,7 @@ fn parse_input(sess: session, cfg: ast::crate_cfg, input: input)\n         parse::parse_crate_from_file(file, cfg, sess.parse_sess)\n       }\n       str_input(src) {\n-        // FIXME: Don't really want to box the source string\n-        // #2319\n+        // FIXME (#2319): Don't really want to box the source string\n         parse::parse_crate_from_source_str(\n             anon_src(), @src, cfg, sess.parse_sess)\n       }\n@@ -389,9 +388,10 @@ fn host_triple() -> str {\n     // idea of the host triple is the same as for the set of libraries we've\n     // actually built.  We can't just take LLVM's host triple because they\n     // normalize all ix86 architectures to i386.\n-    // FIXME: Instead of grabbing the host triple we really should be\n-    // grabbing (at compile time) the target triple that this rustc is\n-    // built with and calling that (at runtime) the host triple. (#2400)\n+\n+    // FIXME (#2400): Instead of grabbing the host triple we really should\n+    // be grabbing (at compile time) the target triple that this rustc is\n+    // built with and calling that (at runtime) the host triple.\n     let ht = #env(\"CFG_HOST_TRIPLE\");\n     ret if ht != \"\" {\n             ht\n@@ -660,10 +660,10 @@ fn build_output_filenames(input: input,\n         };\n \n         if sess.building_library {\n-            // FIXME: We might want to warn here; we're actually not going to\n-            // respect the user's choice of library name when it comes time to\n-            // link, we'll be linking to lib<basename>-<hash>-<version>.so no\n-            // matter what. (#2401)\n+            // FIXME (#2401): We might want to warn here; we're actually not\n+            // going to respect the user's choice of library name when it\n+            // comes time to link, we'll be linking to\n+            // lib<basename>-<hash>-<version>.so no matter what.\n         }\n \n         if odir != none {"}, {"sha": "9645d919b04bf5c7953f33b2b5736465023c7600", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -32,7 +32,7 @@ const stats: uint = 16u;\n const no_asm_comments: uint = 32u;\n const no_verify: uint = 64u;\n const trace: uint = 128u;\n-// FIXME: This exists to transition to a Rust crate runtime\n+// FIXME (#2377): This exists to transition to a Rust crate runtime\n // It should be removed\n const no_rt: uint = 256u;\n "}, {"sha": "2c40db16a455ada28003a28d4f719773ac251150", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -64,9 +64,10 @@ fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n fn fold_mod(_cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n \n     // Remove any defined main function from the AST so it doesn't clash with\n-    // the one we're going to add.  FIXME: This is sloppy. Instead we should\n-    // have some mechanism to indicate to the translation pass which function\n-    // we want to be main. (#2403)\n+    // the one we're going to add.\n+\n+    // FIXME (#2403): This is sloppy. Instead we should have some mechanism to\n+    // indicate to the translation pass which function we want to be main.\n     fn nomain(&&item: @ast::item) -> option<@ast::item> {\n         alt item.node {\n           ast::item_fn(_, _, _) {\n@@ -338,8 +339,8 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n }\n \n // Produces a bare function that wraps the test function\n-// FIXME: This can go away once fn is the type of bare function\n-// (See #1281)\n+\n+// FIXME (#1281): This can go away once fn is the type of bare function.\n fn mk_test_wrapper(cx: test_ctxt,\n                    fn_path_expr: ast::expr,\n                    span: span) -> @ast::expr {"}, {"sha": "c63d03ce2399c764dc415b207d03190f5be62515", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -261,8 +261,8 @@ fn resolve_crate_deps(e: env, cdata: @[u8]) -> cstore::cnum_map {\n           none {\n             #debug(\"need to load it\");\n             // This is a new one so we've got to load it\n-            // FIXME: Need better error reporting than just a bogus span\n-            // #2404\n+            // FIXME (#2404): Need better error reporting than just a bogus\n+            // span.\n             let fake_span = ast_util::dummy_sp();\n             let local_cnum =\n                 resolve_crate(e, cname, cmetas, *dep.hash, fake_span);"}, {"sha": "7209d4e67311768c58b3c24d9827789d30b44e2f", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -433,8 +433,7 @@ fn item_impl_methods(cdata: cmd, item: ebml::doc, base_tps: uint)\n         let m_did = parse_def_id(ebml::doc_data(doc));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         rslt += [@{did: translate_def_id(cdata, m_did),\n-                    /* FIXME tjc: take a look at this, it may relate\n-                     to #2323 */\n+                    /* FIXME (maybe #2323) tjc: take a look at this. */\n                    n_tps: item_ty_param_count(mth_item) - base_tps,\n                    ident: item_name(mth_item)}];\n     }"}, {"sha": "62c4a0789528b5a6f651c86fb8fd6c57c7de0e86", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -1028,9 +1028,8 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n \n     // We're just going to write a list of crate 'name-hash-version's, with\n     // the assumption that they are numbered 1 to n.\n-    // FIXME: This is not nearly enough to support correct versioning\n+    // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n-    // See #2166\n     ebml_w.start_tag(tag_crate_deps);\n     for get_ordered_deps(cstore).each {|dep|\n         encode_crate_dep(ebml_w, dep);"}, {"sha": "eeb44f80fd7cd6ecced442e54b4c3e3db1d0127a", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -1,6 +1,6 @@\n // A module for searching for libraries\n-// FIXME: I'm not happy how this module turned out. Should probably\n-// just be folded into cstore.\n+// FIXME (#2658): I'm not happy how this module turned out. Should\n+// probably just be folded into cstore.\n \n import result::result;\n export filesearch;"}, {"sha": "a5874aa29fa48911adab0c17ca94b5a4984e83e8", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -125,8 +125,8 @@ fn crate_name_from_metas(metas: [@ast::meta_item]) -> @str {\n       some(i) {\n         alt attr::get_meta_item_value_str(i) {\n           some(n) { n }\n-          // FIXME: Probably want a warning here since the user\n-          // is using the wrong type of meta item (#2406)\n+          // FIXME (#2406): Probably want a warning here since the user\n+          // is using the wrong type of meta item.\n           _ { fail }\n         }\n       }"}, {"sha": "2fae0850187284fb2c35151c9431cc8f97ac25cc", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 17, "deletions": 182, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -66,8 +66,8 @@ type decode_ctxt = @{\n \n type extended_decode_ctxt = @{\n     dcx: decode_ctxt,\n-    from_id_range: id_range,\n-    to_id_range: id_range\n+    from_id_range: ast_util::id_range,\n+    to_id_range: ast_util::id_range\n };\n \n iface tr {\n@@ -86,9 +86,9 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n            ast_map::path_to_str(path), *ii.ident(),\n            ebml_w.writer.tell()];\n \n-    let id_range = compute_id_range(ii);\n+    let id_range = ast_util::compute_id_range_for_inlined_item(ii);\n     ebml_w.wr_tag(c::tag_ast as uint) {||\n-        encode_id_range(ebml_w, id_range);\n+        ast_util::serialize_id_range(ebml_w, id_range);\n         encode_ast(ebml_w, simplify_ast(ii));\n         encode_side_tables_for_ii(ecx, maps, ebml_w, ii);\n     }\n@@ -108,7 +108,8 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n       none { none }\n       some(ast_doc) {\n         #debug[\"> Decoding inlined fn: %s::?\", ast_map::path_to_str(path)];\n-        let from_id_range = decode_id_range(ast_doc);\n+        let ast_dsr = ebml::ebml_deserializer(ast_doc);\n+        let from_id_range = ast_util::deserialize_id_range(ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n         let xcx = @{dcx: dcx,\n                     from_id_range: from_id_range,\n@@ -136,178 +137,10 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n-type id_range = {min: ast::node_id, max: ast::node_id};\n-\n-fn empty(range: id_range) -> bool {\n-    range.min >= range.max\n-}\n-\n-fn visit_ids(item: ast::inlined_item, vfn: fn@(ast::node_id)) {\n-    let visitor = visit::mk_simple_visitor(@{\n-        visit_mod: fn@(_m: ast::_mod, _sp: span, id: ast::node_id) {\n-            vfn(id)\n-        },\n-\n-        visit_view_item: fn@(vi: @ast::view_item) {\n-            alt vi.node {\n-              ast::view_item_use(_, _, id) { vfn(id) }\n-              ast::view_item_import(vps) | ast::view_item_export(vps) {\n-                vec::iter(vps) {|vp|\n-                    alt vp.node {\n-                      ast::view_path_simple(_, _, id) { vfn(id) }\n-                      ast::view_path_glob(_, id) { vfn(id) }\n-                      ast::view_path_list(_, _, id) { vfn(id) }\n-                    }\n-                }\n-              }\n-            }\n-        },\n-\n-        visit_native_item: fn@(ni: @ast::native_item) {\n-            vfn(ni.id)\n-        },\n-\n-        visit_item: fn@(i: @ast::item) {\n-            vfn(i.id);\n-            alt i.node {\n-              ast::item_res(_, _, _, d_id, c_id, _) { vfn(d_id); vfn(c_id); }\n-              ast::item_enum(vs, _, _) { for vs.each {|v| vfn(v.node.id); } }\n-              _ {}\n-            }\n-        },\n-\n-        visit_local: fn@(l: @ast::local) {\n-            vfn(l.node.id);\n-        },\n-\n-        visit_block: fn@(b: ast::blk) {\n-            vfn(b.node.id);\n-        },\n-\n-        visit_stmt: fn@(s: @ast::stmt) {\n-            vfn(ast_util::stmt_id(*s));\n-        },\n-\n-        visit_arm: fn@(_a: ast::arm) { },\n-\n-        visit_pat: fn@(p: @ast::pat) {\n-            vfn(p.id)\n-        },\n-\n-        visit_decl: fn@(_d: @ast::decl) {\n-        },\n-\n-        visit_expr: fn@(e: @ast::expr) {\n-            vfn(e.id);\n-            alt e.node {\n-              ast::expr_unary(*) | ast::expr_binary(*) | ast::expr_index(*) {\n-                vfn(ast_util::op_expr_callee_id(e));\n-              }\n-              _ { /* fallthrough */ }\n-            }\n-        },\n-\n-        visit_ty: fn@(t: @ast::ty) {\n-            alt t.node {\n-              ast::ty_path(_, id) {\n-                vfn(id)\n-              }\n-              _ { /* fall through */ }\n-            }\n-        },\n-\n-        visit_ty_params: fn@(ps: [ast::ty_param]) {\n-            vec::iter(ps) {|p| vfn(p.id) }\n-        },\n-\n-        visit_constr: fn@(_p: @ast::path, _sp: span, id: ast::node_id) {\n-            vfn(id);\n-        },\n-\n-        visit_fn: fn@(fk: visit::fn_kind, d: ast::fn_decl,\n-                      _b: ast::blk, _sp: span, id: ast::node_id) {\n-            vfn(id);\n-\n-            alt fk {\n-              visit::fk_ctor(nm, tps, self_id, parent_id) {\n-                vec::iter(tps) {|tp| vfn(tp.id)}\n-                vfn(id);\n-                vfn(self_id);\n-                vfn(parent_id.node);\n-              }\n-              visit::fk_dtor(tps, self_id, parent_id) {\n-                vec::iter(tps) {|tp| vfn(tp.id)}\n-                vfn(id);\n-                vfn(self_id);\n-                vfn(parent_id.node);\n-              }\n-              visit::fk_item_fn(_, tps) |\n-              visit::fk_res(_, tps, _) {\n-                vec::iter(tps) {|tp| vfn(tp.id)}\n-              }\n-              visit::fk_method(_, tps, m) {\n-                vfn(m.self_id);\n-                vec::iter(tps) {|tp| vfn(tp.id)}\n-              }\n-              visit::fk_anon(_, capture_clause)\n-              | visit::fk_fn_block(capture_clause) {\n-                for vec::each(*capture_clause) {|clause|\n-                    vfn(clause.id);\n-                }\n-              }\n-            }\n-\n-            vec::iter(d.inputs) {|arg|\n-                vfn(arg.id)\n-            }\n-        },\n-\n-        visit_class_item: fn@(c: @ast::class_member) {\n-            alt c.node {\n-              ast::instance_var(_, _, _, id,_) {\n-                vfn(id)\n-              }\n-              ast::class_method(_) {\n-              }\n-            }\n-        }\n-    });\n-\n-    item.accept((), visitor)\n-}\n-\n-fn compute_id_range(item: ast::inlined_item) -> id_range {\n-    let min = @mut int::max_value;\n-    let max = @mut int::min_value;\n-    visit_ids(item) {|id|\n-        *min = int::min(*min, id);\n-        *max = int::max(*max, id + 1);\n-    }\n-    ret {min:*min, max:*max};\n-}\n-\n-fn encode_id_range(ebml_w: ebml::writer, id_range: id_range) {\n-    ebml_w.wr_tag(c::tag_id_range as uint) {||\n-        ebml_w.emit_tup(2u) {||\n-            ebml_w.emit_tup_elt(0u) {|| ebml_w.emit_int(id_range.min) }\n-            ebml_w.emit_tup_elt(1u) {|| ebml_w.emit_int(id_range.max) }\n-        }\n-    }\n-}\n-\n-fn decode_id_range(par_doc: ebml::doc) -> id_range {\n-    let range_doc = par_doc[c::tag_id_range];\n-    let dsr = ebml::ebml_deserializer(range_doc);\n-    dsr.read_tup(2u) {||\n-        {min: dsr.read_tup_elt(0u) {|| dsr.read_int() },\n-         max: dsr.read_tup_elt(1u) {|| dsr.read_int() }}\n-    }\n-}\n-\n fn reserve_id_range(sess: session,\n-                    from_id_range: id_range) -> id_range {\n+                    from_id_range: ast_util::id_range) -> ast_util::id_range {\n     // Handle the case of an empty range:\n-    if empty(from_id_range) { ret from_id_range; }\n+    if ast_util::empty(from_id_range) { ret from_id_range; }\n     let cnt = from_id_range.max - from_id_range.min;\n     let to_id_min = sess.parse_sess.next_id;\n     let to_id_max = sess.parse_sess.next_id + cnt;\n@@ -318,7 +151,7 @@ fn reserve_id_range(sess: session,\n impl translation_routines for extended_decode_ctxt {\n     fn tr_id(id: ast::node_id) -> ast::node_id {\n         // from_id_range should be non-empty\n-        assert !empty(self.from_id_range);\n+        assert !ast_util::empty(self.from_id_range);\n         (id - self.from_id_range.min + self.to_id_range.min)\n     }\n     fn tr_def_id(did: ast::def_id) -> ast::def_id {\n@@ -749,12 +582,14 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n                              ebml_w: ebml::writer,\n                              ii: ast::inlined_item) {\n     ebml_w.wr_tag(c::tag_table as uint) {||\n-        visit_ids(ii, fn@(id: ast::node_id, copy ebml_w) {\n-            // Note: this will cause a copy of ebml_w, which is bad as\n-            // it has mut fields.  But I believe it's harmless since\n-            // we generate balanced EBML.\n-            encode_side_tables_for_id(ecx, maps, ebml_w, id)\n-        });\n+        ast_util::visit_ids_for_inlined_item(\n+            ii,\n+            fn@(id: ast::node_id, copy ebml_w) {\n+                // Note: this will cause a copy of ebml_w, which is bad as\n+                // it has mut fields.  But I believe it's harmless since\n+                // we generate balanced EBML.\n+                encode_side_tables_for_id(ecx, maps, ebml_w, id)\n+            });\n     }\n }\n "}, {"sha": "9818c1c648b6cfdb092e6ae89e47dfc11e5aee69", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -175,6 +175,7 @@ fn check_crate(tcx: ty::ctxt,\n     let bccx = @{tcx: tcx,\n                  method_map: method_map,\n                  last_use_map: last_use_map,\n+                 binding_map: int_hash(),\n                  root_map: root_map(),\n                  mutbl_map: int_hash()};\n \n@@ -189,6 +190,7 @@ fn check_crate(tcx: ty::ctxt,\n type borrowck_ctxt = @{tcx: ty::ctxt,\n                        method_map: typeck::method_map,\n                        last_use_map: liveness::last_use_map,\n+                       binding_map: binding_map,\n                        root_map: root_map,\n                        mutbl_map: mutbl_map};\n \n@@ -208,6 +210,10 @@ type root_map_key = {id: ast::node_id, derefs: uint};\n // this is used in trans for optimization purposes.\n type mutbl_map = std::map::hashmap<ast::node_id, ()>;\n \n+// maps from each binding's id to the mutability of the location it\n+// points at.  See gather_loan.rs for more detail (search for binding_map)\n+type binding_map = std::map::hashmap<ast::node_id, ast::mutability>;\n+\n // Errors that can occur\"]\n enum bckerr_code {\n     err_mut_uniq,\n@@ -228,6 +234,7 @@ enum categorization {\n     cat_rvalue,                     // result of eval'ing some misc expr\n     cat_special(special_kind),      //\n     cat_local(ast::node_id),        // local variable\n+    cat_binding(ast::node_id),      // pattern binding\n     cat_arg(ast::node_id),          // formal argument\n     cat_stack_upvar(cmt),           // upvar in stack closure\n     cat_deref(cmt, uint, ptr_kind), // deref of a ptr\n@@ -381,6 +388,7 @@ impl to_str_methods for borrowck_ctxt {\n           cat_stack_upvar(_) { \"stack-upvar\" }\n           cat_rvalue { \"rvalue\" }\n           cat_local(node_id) { #fmt[\"local(%d)\", node_id] }\n+          cat_binding(node_id) { #fmt[\"binding(%d)\", node_id] }\n           cat_arg(node_id) { #fmt[\"arg(%d)\", node_id] }\n           cat_deref(cmt, derefs, ptr) {\n             #fmt[\"%s->(%s, %u)\", self.cat_to_repr(cmt.cat),\n@@ -466,6 +474,7 @@ impl to_str_methods for borrowck_ctxt {\n           cat_special(sk_heap_upvar) { \"variable declared in an outer block\" }\n           cat_rvalue { \"non-lvalue\" }\n           cat_local(_) { mut_str + \" local variable\" }\n+          cat_binding(_) { \"pattern binding\" }\n           cat_arg(_) { \"argument\" }\n           cat_deref(_, _, pk) { #fmt[\"dereference of %s %s pointer\",\n                                      mut_str, self.pk_to_sigil(pk)] }"}, {"sha": "b7143706fc3f1713a594c86d47a4f3155c74cc06", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -265,12 +265,16 @@ impl public_methods for borrowck_ctxt {\n               mutbl:m, ty:expr_ty}\n           }\n \n-          ast::def_binding(vid) {\n-            // no difference between a binding and any other local variable\n-            // from out point of view, except that they are always immutable\n+          ast::def_binding(pid) {\n+            // bindings are \"special\" since they are implicit pointers.\n+\n+            // lookup the mutability for this binding that we found in\n+            // gather_loans when we categorized it\n+            let mutbl = self.binding_map.get(pid);\n+\n             @{id:id, span:span,\n-              cat:cat_local(vid), lp:some(@lp_local(vid)),\n-              mutbl:m_imm, ty:expr_ty}\n+              cat:cat_binding(pid), lp:none,\n+              mutbl:mutbl, ty:expr_ty}\n           }\n         }\n     }"}, {"sha": "bae0f4648d2bfc31865e0385f8badd75e74816b3", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -47,6 +47,7 @@ fn check_loans(bccx: borrowck_ctxt,\n                                  mut declared_purity: ast::impure_fn,\n                                  mut fn_args: @[]});\n     let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n+                            visit_local: check_loans_in_local,\n                             visit_block: check_loans_in_block,\n                             visit_fn: check_loans_in_fn\n                             with *visit::default_visitor()});\n@@ -419,6 +420,9 @@ impl methods for check_loan_ctxt {\n           // rvalues, I guess.\n           cat_special(sk_static_item) { }\n \n+          cat_deref(_, _, unsafe_ptr) {\n+          }\n+\n           // Nothing else.\n           _ {\n             self.bccx.span_err(\n@@ -542,6 +546,18 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n     #debug[\"purity on exit=%?\", copy self.declared_purity];\n }\n \n+fn check_loans_in_local(local: @ast::local,\n+                        &&self: check_loan_ctxt,\n+                        vt: visit::vt<check_loan_ctxt>) {\n+    alt local.node.init {\n+      some({op: ast::init_move, expr: expr}) {\n+        self.check_move_out(expr);\n+      }\n+      some({op: ast::init_assign, _}) | none {}\n+    }\n+    visit::visit_local(local, self, vt);\n+}\n+\n fn check_loans_in_expr(expr: @ast::expr,\n                        &&self: check_loan_ctxt,\n                        vt: visit::vt<check_loan_ctxt>) {"}, {"sha": "df46a4cef8f420a2f82823d0d45b4a5624936d81", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -85,12 +85,12 @@ fn req_loans_in_expr(ex: @ast::expr,\n                 // is mutable in the caller's frame, thus effectively\n                 // passing the buck onto us to enforce this)\n                 //\n-                // FIXME---this handling is not really adequate.  For\n-                // example, if there is a type like, {f: [int]}, we\n-                // will ignore it, but we ought to be requiring it to\n-                // be immutable (whereas something like {f:int} would\n-                // be fine).\n-                // (See #2493)\n+                // FIXME (#2493): this handling is not really adequate.\n+                // For example, if there is a type like, {f: [int]}, we\n+                // will ignore it, but we ought to be requiring it to be\n+                // immutable (whereas something like {f:int} would be\n+                // fine).\n+                //\n \n                 alt opt_deref_kind(arg_ty.ty) {\n                   some(deref_ptr(region_ptr)) |\n@@ -130,7 +130,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n         // Here, in an overloaded operator, the call is this expression,\n         // and hence the scope of the borrow is this call.\n         //\n-        // FIXME/NOT REALLY---technically we should check the other\n+        // FIX? / NOT REALLY---technically we should check the other\n         // argument and consider the argument mode.  But how annoying.\n         // And this problem when goes away when argument modes are\n         // phased out.  So I elect to leave this undone.\n@@ -364,6 +364,16 @@ impl methods for gather_loan_ctxt {\n             // cat_discr in the method preserve():\n             let cmt1 = self.bccx.cat_discr(cmt, alt_id);\n             let arm_scope = ty::re_scope(arm_id);\n+\n+            // Remember the mutability of the location that this\n+            // binding refers to.  This will be used later when\n+            // categorizing the binding.  This is a bit of a hack that\n+            // would be better fixed by #2329; in that case we could\n+            // allow the user to specify if they want an imm, const,\n+            // or mut binding, or else just reflect the mutability\n+            // through the type of the region pointer.\n+            self.bccx.binding_map.insert(pat.id, cmt1.mutbl);\n+\n             self.guarantee_valid(cmt1, m_const, arm_scope);\n \n             for o_pat.each { |p|"}, {"sha": "bbeca85174234a0c441548bbc05f7d5e461ae994", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -43,7 +43,7 @@ impl loan_methods for loan_ctxt {\n         }\n \n         alt cmt.cat {\n-          cat_rvalue | cat_special(_) {\n+          cat_binding(_) | cat_rvalue | cat_special(_) {\n             // should never be loanable\n             self.bccx.tcx.sess.span_bug(\n                 cmt.span,"}, {"sha": "cbe9c4e3a4add52ec98a2d421a38fba5dbd9e86d", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -29,6 +29,12 @@ impl public_methods for borrowck_ctxt {\n             }\n             ok(())\n           }\n+          cat_binding(_) {\n+            // Bindings are these kind of weird implicit pointers (cc\n+            // #2329).  We require (in gather_loans) that they be\n+            // rooted in an immutable location.\n+            ok(())\n+          }\n           cat_arg(_) {\n             // This can happen as not all args are lendable (e.g., &&\n             // modes).  In that case, the caller guarantees stability."}, {"sha": "26ffbdc0273c5dfbbeedd7328960e4c4b7d66e96", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -1,7 +1,7 @@\n import syntax::ast::*;\n \n-// FIXME this doesn't handle big integer/float literals correctly (nor does\n-// the rest of our literal handling - issue #33)\n+// FIXME (#33): this doesn't handle big integer/float literals correctly\n+// (nor does the rest of our literal handling).\n enum const_val {\n     const_float(f64),\n     const_int(i64),"}, {"sha": "9ad4009c51303d64c2d70c1c162885e0b000c946", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -1669,7 +1669,14 @@ impl check_methods for @liveness {\n                     #fmt[\"illegal move from field `%s`\", *name]);\n                 ret;\n               }\n-              vk_local(*) | vk_self | vk_implicit_ret {\n+              vk_self {\n+                self.tcx.sess.span_err(\n+                    move_span,\n+                    \"illegal move from self (cannot move out of a field of \\\n+                       self)\");\n+                ret;\n+              }\n+              vk_local(*) | vk_implicit_ret {\n                 self.tcx.sess.span_bug(\n                     move_span,\n                     #fmt[\"illegal reader (%?) for `%?`\","}, {"sha": "0ae04c25ccd2d76d3ebdc829fbf25b2261d684be", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -215,9 +215,9 @@ fn iter_effective_import_paths(vi: ast::view_item,\n     iter_export_paths(vi) {|vp|\n         alt vp.node {\n           ast::view_path_simple(_, _, _) { }\n-          // FIXME: support uniform ident-list exports eventually;\n-          // at the moment they have half a meaning as reaching into\n-          // tags. (but also see #1893)\n+          // FIXME (but also see #1893): support uniform ident-list exports\n+          // eventually; at the moment they have half a meaning as reaching\n+          // into tags.\n           ast::view_path_list(_, _, _) {}\n           ast::view_path_glob(_,_) {\n             f(vp);\n@@ -573,7 +573,6 @@ fn visit_item_with_scope(e: @env, i: @ast::item,\n       }\n       ast::item_class(tps, ifaces, members, ctor, m_dtor, _) {\n         v.visit_ty_params(tps, sc, v);\n-        // Can maybe skip this now that we require self on class fields\n         let class_scope = @cons(scope_item(i), sc);\n         /* visit the constructor... */\n         let ctor_scope = @cons(scope_method(ctor.node.self_id, tps),\n@@ -1061,7 +1060,7 @@ fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n               }\n               ast::item_class(tps, _, members, ctor, _, _) {\n                   if ns == ns_type {\n-                    ret lookup_in_ty_params(e, name, tps);\n+                      ret lookup_in_ty_params(e, name, tps);\n                   }\n                   if ns == ns_val && name == it.ident {\n                       ret some(ast::def_fn(local_def(ctor.node.id),\n@@ -1317,13 +1316,14 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n     alt i.node {\n       ast::item_const(*) {\n         if ns == ns_val {\n-            ret some(ast::def_const(local_def(i.id))); }\n+            ret some(ast::def_const(local_def(i.id)));\n+        }\n       }\n       ast::item_fn(decl, _, _) {\n-        if ns == ns_val {\n+          if ns == ns_val {\n             ret some(ast::def_fn(local_def(i.id), decl.purity));\n-        }\n-      }\n+           }\n+       }\n       ast::item_mod(_) {\n         if ns == ns_module { ret some(ast::def_mod(local_def(i.id))); }\n       }\n@@ -1342,9 +1342,16 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n           _ { }\n         }\n       }\n-      ast::item_class(*) {\n-          if ns == ns_type {\n-            ret some(ast::def_class(local_def(i.id)));\n+      ast::item_class(_, _, _members, ct, _, _) {\n+          alt ns {\n+             ns_type {\n+               ret some(ast::def_class(local_def(i.id)));\n+             }\n+             ns_val {\n+               ret some(ast::def_fn(local_def(ct.node.id),\n+                                    ast::impure_fn));\n+             }\n+             ns_module { }\n           }\n       }\n       ast::item_impl(*) { /* ??? */ }\n@@ -1653,14 +1660,6 @@ fn index_mod(md: ast::_mod) -> mod_index {\n           ast::item_class(tps, _, items, ctor, _, _) {\n               // add the class name itself\n               add_to_index(index, it.ident, mie_item(it));\n-              // add the constructor decl\n-              add_to_index(index, it.ident,\n-                           mie_item(@{ident: it.ident, attrs: [],\n-                            id: ctor.node.id,\n-                            node:\n-                              item_fn(ctor.node.dec, tps, ctor.node.body),\n-                            vis: ast::public,\n-                            span: ctor.node.body.span}));\n           }\n         }\n     }"}, {"sha": "d202ba7a123f32845bc33606d3a9ff32a4d4ec59", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 100, "deletions": 49, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -356,9 +356,9 @@ fn malloc_raw_dyn(bcx: block, t: ty::t, heap: heap,\n     let ccx = bcx.ccx();\n \n     let (mk_fn, upcall) = alt heap {\n-      heap_shared { (ty::mk_imm_box, ccx.upcalls.malloc_dyn) }\n+      heap_shared { (ty::mk_imm_box, ccx.upcalls.malloc) }\n       heap_exchange {\n-        (ty::mk_imm_uniq, ccx.upcalls.exchange_malloc_dyn )\n+        (ty::mk_imm_uniq, ccx.upcalls.exchange_malloc )\n       }\n     };\n \n@@ -754,7 +754,8 @@ fn trans_class_drop(bcx: block, v0: ValueRef, dtor_did: ast::def_id,\n       // We have to cast v0\n      let classptr = GEPi(bcx, v0, [0u, 1u]);\n      // Find and call the actual destructor\n-     let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, substs.tps);\n+     let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, some(class_did),\n+                                  substs.tps);\n      // The second argument is the \"self\" argument for drop\n      let params = lib::llvm::fn_ty_param_tys\n          (llvm::LLVMGetElementType\n@@ -829,7 +830,11 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, substs: [ty::t])\n+fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n+                // Parent ID is an option because resources don't\n+                // have one. We can make this a def_id when\n+                // resources get removed.\n+                opt_id: option<ast::def_id>, substs: [ty::t])\n    -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n     if (substs.len() > 0u) {\n@@ -841,14 +846,27 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, substs: [ty::t])\n     } else if did.crate == ast::local_crate {\n         get_item_val(ccx, did.node)\n     } else {\n-        let fty = ty::mk_fn(ccx.tcx, {purity: ast::impure_fn,\n-                                      proto: ast::proto_bare,\n-                                      inputs: [{mode: ast::expl(ast::by_ref),\n+        alt opt_id {\n+           some(parent_id) {\n+             let tcx = ccx.tcx;\n+             let name = csearch::get_symbol(ccx.sess.cstore, did);\n+             let class_ty = ty::subst_tps(tcx, substs,\n+                              ty::lookup_item_type(tcx, parent_id).ty);\n+             let llty = type_of_dtor(ccx, class_ty);\n+             get_extern_fn(ccx.externs, ccx.llmod, name, lib::llvm::CCallConv,\n+                           llty)\n+           }\n+           none {\n+             let fty = ty::mk_fn(ccx.tcx, {purity: ast::impure_fn,\n+                                       proto: ast::proto_bare,\n+                                     inputs: [{mode: ast::expl(ast::by_ref),\n                                                 ty: ty::mk_nil_ptr(ccx.tcx)}],\n                                       output: ty::mk_nil(ccx.tcx),\n                                       ret_style: ast::return_val,\n                                       constraints: []});\n-        trans_external_path(ccx, did, fty)\n+             trans_external_path(ccx, did, fty)\n+           }\n+      }\n     }\n }\n \n@@ -862,7 +880,7 @@ fn trans_res_drop(bcx: block, rs: ValueRef, did: ast::def_id,\n     with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) {|bcx|\n         let valptr = GEPi(bcx, rs, [0u, 1u]);\n         // Find and call the actual destructor.\n-        let dtor_addr = get_res_dtor(ccx, did, tps);\n+        let dtor_addr = get_res_dtor(ccx, did, none, tps);\n         let args = [bcx.fcx.llretptr, null_env_ptr(bcx)];\n         // Kludge to work around the fact that we know the precise type of the\n         // value here, but the dtor expects a type that might have opaque\n@@ -1336,10 +1354,10 @@ fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n \n fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n                 n_bytes: ValueRef) {\n-    // FIXME: Provide LLVM with better alignment information when the\n-    // alignment is statically known (it must be nothing more than a constant\n-    // int, or LLVM complains -- not even a constant element of a tydesc\n-    // works). (Related to #1645, I think?)\n+    // FIXME (Related to #1645, I think?): Provide LLVM with better\n+    // alignment information when the alignment is statically known (it must\n+    // be nothing more than a constant int, or LLVM complains -- not even a\n+    // constant element of a tydesc works).\n     let _icx = cx.insn_ctxt(\"call_memmove\");\n     let ccx = cx.ccx();\n     let key = alt ccx.sess.targ_cfg.arch {\n@@ -1421,11 +1439,12 @@ fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n \n // This works like copy_val, except that it deinitializes the source.\n // Since it needs to zero out the source, src also needs to be an lval.\n-// FIXME: We always zero out the source. Ideally we would detect the\n+// FIXME (#839): We always zero out the source. Ideally we would detect the\n // case where a variable is always deinitialized by block exit and thus\n-// doesn't need to be dropped. (Issue #839)\n+// doesn't need to be dropped.\n fn move_val(cx: block, action: copy_action, dst: ValueRef,\n             src: lval_result, t: ty::t) -> block {\n+\n     let _icx = cx.insn_ctxt(\"move_val\");\n     let mut src_val = src.val;\n     let tcx = cx.tcx();\n@@ -1633,8 +1652,8 @@ fn cast_shift_rhs(op: ast::binop,\n         if lhs_sz < rhs_sz {\n             trunc(rhs, lhs_llty)\n         } else if lhs_sz > rhs_sz {\n-            // FIXME: If shifting by negative values becomes not undefined\n-            // then this is wrong. (See discussion at #1570)\n+            // FIXME (See discussion at #1570): If shifting by negative\n+            // values becomes not undefined then this is wrong.\n             zext(rhs, lhs_llty)\n         } else {\n             rhs\n@@ -1758,17 +1777,29 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n     // A user-defined operator method\n     alt bcx.ccx().maps.method_map.find(ex.id) {\n       some(origin) {\n+        let bcx = lhs_res.bcx;\n         let callee_id = ast_util::op_expr_callee_id(ex);\n+        #debug[\"user-defined method callee_id: %s\",\n+               ast_map::node_id_to_str(bcx.tcx().items, callee_id)];\n         let fty = node_id_type(bcx, callee_id);\n-        ret trans_call_inner(\n+\n+        let dty = expr_ty(bcx, dst);\n+        let target = alloc_ty(bcx, dty);\n+\n+        let bcx = trans_call_inner(\n             bcx, ex.info(), fty,\n             expr_ty(bcx, ex),\n             {|bcx|\n-                // FIXME provide the already-computed address, not the expr\n-                // #2528\n+                // FIXME (#2528): provide the already-computed address, not\n+                // the expr.\n                 impl::trans_method_callee(bcx, callee_id, dst, origin)\n             },\n-            arg_exprs([src]), save_in(lhs_res.val));\n+            arg_exprs([src]), save_in(target));\n+\n+        ret move_val(bcx, DROP_EXISTING, lhs_res.val,\n+                     // FIXME (#2704): should kind be owned?\n+                     {bcx: bcx, val: target, kind: owned},\n+                     dty);\n       }\n       _ {}\n     }\n@@ -2304,14 +2335,14 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n         }\n       }\n       ast_map::node_dtor(_, dtor, _, pt) {\n-          let parent_id = alt ty::ty_to_def_id(ty::node_id_to_type(ccx.tcx,\n-                                     dtor.node.self_id)) {\n-                  some(did) { did }\n-                  none      { ccx.sess.span_bug(dtor.span, \"Bad self ty in \\\n+        let parent_id = alt ty::ty_to_def_id(ty::node_id_to_type(ccx.tcx,\n+                                              dtor.node.self_id)) {\n+                some(did) { did }\n+                none      { ccx.sess.span_bug(dtor.span, \"Bad self ty in \\\n                                dtor\"); }\n-          };\n-          trans_class_dtor(ccx, *pt, dtor.node.body,\n-                           dtor.node.id, psubsts, some(hash_id), parent_id)\n+        };\n+        trans_class_dtor(ccx, *pt, dtor.node.body,\n+          dtor.node.id, psubsts, some(hash_id), parent_id)\n       }\n       // Ugh -- but this ensures any new variants won't be forgotten\n       ast_map::node_expr(*) { ccx.tcx.sess.bug(\"Can't monomorphize an expr\") }\n@@ -3317,7 +3348,7 @@ fn need_invoke(bcx: block) -> bool {\n     loop {\n         alt cur.kind {\n           block_scope(inf) {\n-            for inf.cleanups.each {|cleanup|\n+            for vec::each(inf.cleanups) {|cleanup|\n                 alt cleanup {\n                   clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) {\n                     if cleanup_type == normal_exit_and_unwind {\n@@ -4728,9 +4759,9 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n }\n \n \n-// FIXME: this should do some structural hash-consing to avoid\n-// duplicate constants. I think. Maybe LLVM has a magical mode\n-// that does so later on? (#2530)\n+// FIXME (#2530): this should do some structural hash-consing to avoid\n+// duplicate constants. I think. Maybe LLVM has a magical mode that does so\n+// later on?\n fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_const_expr\");\n     alt e.node {\n@@ -4832,9 +4863,9 @@ fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n               ast_map::node_item(@{\n                 node: ast::item_const(_, subexpr), _\n               }, _) {\n-                // FIXME: Instead of recursing here to regenerate the values\n-                // for other constants, we should just look up the\n-                // already-defined value (#2530)\n+                // FIXME (#2530): Instead of recursing here to regenerate\n+                // the values for other constants, we should just look up\n+                // the already-defined value.\n                 trans_const_expr(cx, subexpr)\n               }\n               _ {\n@@ -4930,15 +4961,15 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n }\n \n fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n-    body: ast::blk,\n-    dtor_id: ast::node_id, substs: option<param_substs>,\n-                    hash_id: option<mono_id>, parent_id: ast::def_id)\n+    body: ast::blk, dtor_id: ast::node_id,\n+    psubsts: option<param_substs>,\n+    hash_id: option<mono_id>, parent_id: ast::def_id)\n     -> ValueRef {\n   let tcx = ccx.tcx;\n   /* Look up the parent class's def_id */\n   let mut class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n   /* Substitute in the class type if necessary */\n-  option::iter(substs) {|ss|\n+  option::iter(psubsts) {|ss|\n     class_ty = ty::subst_tps(tcx, ss.tys, class_ty);\n   }\n \n@@ -4947,7 +4978,9 @@ fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n   let lldty = T_fn([T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n                     T_ptr(type_of(ccx, class_ty))],\n                    llvm::LLVMVoidType());\n-  let s = get_dtor_symbol(ccx, path, dtor_id);\n+\n+  let s = get_dtor_symbol(ccx, path, dtor_id, psubsts);\n+\n   /* Register the dtor as a function. It has external linkage */\n   let lldecl = decl_internal_cdecl_fn(ccx.llmod, s, lldty);\n   lib::llvm::SetLinkage(lldecl, lib::llvm::ExternalLinkage);\n@@ -4959,7 +4992,7 @@ fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n   }\n   /* Translate the dtor body */\n   trans_fn(ccx, path, ast_util::dtor_dec(),\n-           body, lldecl, impl_self(class_ty), substs, dtor_id);\n+           body, lldecl, impl_self(class_ty), psubsts, dtor_id);\n   lldecl\n }\n \n@@ -5196,16 +5229,34 @@ fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n     } + [path_name(i.ident)]\n }\n \n-/* If there's already a symbol for the dtor with <id>, return it;\n-   otherwise, create one and register it, returning it as well */\n-fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id) -> str {\n+/* If there's already a symbol for the dtor with <id> and substs <substs>,\n+   return it; otherwise, create one and register it, returning it as well */\n+fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n+                   substs: option<param_substs>) -> str {\n+  let t = ty::node_id_to_type(ccx.tcx, id);\n   alt ccx.item_symbols.find(id) {\n      some(s) { s }\n+     none if is_none(substs) {\n+       let s = mangle_exported_name(ccx,\n+                               path + [path_name(@ccx.names(\"dtor\"))],\n+                               t);\n+       ccx.item_symbols.insert(id, s);\n+       s\n+     }\n      none    {\n-         let s = mangle_exported_name(ccx, path +\n-           [path_name(@ccx.names(\"dtor\"))], ty::node_id_to_type(ccx.tcx, id));\n-         ccx.item_symbols.insert(id, s);\n-         s\n+       // Monomorphizing, so just make a symbol, don't add\n+       // this to item_symbols\n+       alt substs {\n+         some(ss) {\n+           let mono_ty = ty::subst_tps(ccx.tcx, ss.tys, t);\n+           mangle_exported_name(ccx, path +\n+                           [path_name(@ccx.names(\"dtor\"))], mono_ty)\n+         }\n+         none {\n+             ccx.sess.bug(#fmt(\"get_dtor_symbol: not monomorphizing and \\\n+               couldn't find a symbol for dtor %?\", path));\n+         }\n+       }\n      }\n   }\n }\n@@ -5289,7 +5340,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             let lldty = T_fn([T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n                     T_ptr(type_of(ccx, class_ty))],\n                                    llvm::LLVMVoidType());\n-            let s = get_dtor_symbol(ccx, *pt, dt.node.id);\n+            let s = get_dtor_symbol(ccx, *pt, dt.node.id, none);\n \n             /* Make the declaration for the dtor */\n             let llfn = decl_internal_cdecl_fn(ccx.llmod, s, lldty);"}, {"sha": "745c25f6f7997441d1aff609340c288691b4a579", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -545,7 +545,7 @@ fn make_opaque_cbox_take_glue(\n         let sz = Add(bcx, sz, shape::llsize_of(ccx, T_box_header(ccx)));\n \n         // Allocate memory, update original ptr, and copy existing data\n-        let malloc = ccx.upcalls.exchange_malloc_dyn;\n+        let malloc = ccx.upcalls.exchange_malloc;\n         let cbox_out = Call(bcx, malloc, [tydesc, sz]);\n         let cbox_out = PointerCast(bcx, cbox_out, llopaquecboxty);\n         call_memmove(bcx, cbox_out, cbox_in, sz);"}, {"sha": "e90590f0228e7ce0315f199919885113b2f1e78c", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -522,7 +522,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n       option::none {}\n     }*/\n \n-    /* FIXME I am disabling this code as part of the patch that moves\n+    /* FIXME (#2012): disabled this code as part of the patch that moves\n      * recognition of named builtin types into resolve. I tried to fix\n      * it, but it seems to already be broken -- it's only called when\n      * --xg is given, and compiling with --xg fails on trivial programs.\n@@ -531,8 +531,6 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n      * needed. It is only done to track spans, but you will not get the\n      * right spans anyway -- types tend to refer to stuff defined\n      * elsewhere, not be self-contained.\n-     *\n-     * See Issue #2012\n      */\n \n     fail;"}, {"sha": "fcc7f370f743c0b3b48ebe86c778dc4cbbf96208", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -700,8 +700,8 @@ fn trans_native_mod(ccx: @crate_ctxt,\n         }\n     }\n \n-    // FIXME this is very shaky and probably gets ABIs wrong all over\n-    // the place (#2535)\n+    // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n+    // over the place\n     fn build_direct_fn(ccx: @crate_ctxt, decl: ValueRef,\n                        item: @ast::native_item, tys: @c_stack_tys,\n                        cc: lib::llvm::CallConv) {"}, {"sha": "740d53ed773125f0486f9b3a2a7ee62a80261feb", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -163,8 +163,8 @@ impl methods for reflector {\n             self.visit(\"leave_tup\", extra);\n           }\n \n-          // FIXME: fetch constants out of intrinsic:: for the numbers.\n-          // (#2594)\n+          // FIXME (#2594): fetch constants out of intrinsic:: for the\n+          // numbers.\n           ty::ty_fn(fty) {\n             let pureval = alt fty.purity {\n               ast::pure_fn { 0u }\n@@ -226,10 +226,10 @@ impl methods for reflector {\n             self.visit(\"leave_class\", extra);\n           }\n \n-          // FIXME: visiting all the variants in turn is probably\n-          // not ideal. It'll work but will get costly on big enums.\n-          // Maybe let the visitor tell us if it wants to visit only\n-          // a particular variant? (#2595)\n+          // FIXME (#2595): visiting all the variants in turn is probably\n+          // not ideal. It'll work but will get costly on big enums. Maybe\n+          // let the visitor tell us if it wants to visit only a particular\n+          // variant?\n           ty::ty_enum(did, substs) {\n             let bcx = self.bcx;\n             let tcx = bcx.ccx().tcx;"}, {"sha": "f28d0b53e538d167844ff4e61985fe67a279098f", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -21,12 +21,14 @@ import std::map::hashmap;\n \n import ty_ctxt = middle::ty::ctxt;\n \n-type nominal_id = @{did: ast::def_id, tps: [ty::t]};\n+type nominal_id = @{did: ast::def_id, parent_id: option<ast::def_id>,\n+                    tps: [ty::t]};\n \n fn mk_nominal_id(tcx: ty::ctxt, did: ast::def_id,\n+                 parent_id: option<ast::def_id>,\n                  tps: [ty::t]) -> nominal_id {\n     let tps_norm = tps.map { |t| ty::normalize_ty(tcx, t) };\n-    @{did: did, tps: tps_norm}\n+    @{did: did, parent_id: parent_id, tps: tps_norm}\n }\n \n fn hash_nominal_id(&&ri: nominal_id) -> uint {\n@@ -233,7 +235,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n           tk_enum { [s_variant_enum_t(ccx.tcx)] }\n           tk_newtype | tk_complex {\n             let mut s = [shape_enum], id;\n-            let nom_id = mk_nominal_id(ccx.tcx, did, substs.tps);\n+            let nom_id = mk_nominal_id(ccx.tcx, did, none, substs.tps);\n             alt ccx.shape_cx.tag_id_to_index.find(nom_id) {\n               none {\n                 id = ccx.shape_cx.next_tag_id;\n@@ -335,7 +337,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n           else { [shape_struct] };\n         let mut sub = [];\n         option::iter(m_dtor_did) {|dtor_did|\n-          let ri = @{did: dtor_did, tps: tps};\n+          let ri = @{did: dtor_did, parent_id: some(did), tps: tps};\n           let id = interner::intern(ccx.shape_cx.resources, ri);\n           add_u16(s, id as u16);\n \n@@ -362,7 +364,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n         for substs.tps.each() {|t| assert !ty::type_has_params(t); }\n         let subt = ty::subst(ccx.tcx, substs, raw_subt);\n         let tps = substs.tps;\n-        let ri = @{did: did, tps: tps};\n+        let ri = @{did: did, parent_id: none, tps: tps};\n         let id = interner::intern(ccx.shape_cx.resources, ri);\n \n         let mut s = [shape_res];\n@@ -489,7 +491,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n         // Compute the minimum and maximum size and alignment for each\n         // variant.\n         //\n-        // FIXME: We could do better here; e.g. we know that any\n+        // NB: We could do better here; e.g. we know that any\n         // variant that contains (T,T) must be as least as large as\n         // any variant that contains just T.\n         let mut ranges = [];\n@@ -498,7 +500,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n             let mut min_size = 0u, min_align = 0u;\n             for vec::each(variant.args) {|elem_t|\n                 if ty::type_has_params(elem_t) {\n-                    // FIXME: We could do better here; this causes us to\n+                    // NB: We could do better here; this causes us to\n                     // conservatively assume that (int, T) has minimum size 0,\n                     // when in fact it has minimum size sizeof(int).\n                     bounded = false;\n@@ -597,7 +599,8 @@ fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n     for uint::range(0u, len) {|i|\n         let ri = interner::get(ccx.shape_cx.resources, i);\n         for ri.tps.each() {|s| assert !ty::type_has_params(s); }\n-        dtors += [trans::base::get_res_dtor(ccx, ri.did, ri.tps)];\n+        dtors += [trans::base::get_res_dtor(ccx, ri.did, ri.parent_id,\n+                                            ri.tps)];\n     }\n     ret mk_global(ccx, \"resource_shapes\", C_struct(dtors), true);\n }\n@@ -696,7 +699,7 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n // Computes the static size of a enum, without using mk_tup(), which is\n // bad for performance.\n //\n-// FIXME: Migrate trans over to use this.\n+// NB: Migrate trans over to use this.\n \n // Computes the size of the data part of an enum.\n fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {"}, {"sha": "d05629b990f0f2edbb19c8a3d3ea88673c98e8f0", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -190,7 +190,7 @@ fn trans_evec(bcx: block, args: [@ast::expr],\n         let lleltptr = InBoundsGEP(bcx, dataptr, [C_uint(ccx, i)]);\n         bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n         add_clean_temp_mem(bcx, lleltptr, unit_ty);\n-        temp_cleanups += [lleltptr];\n+        vec::push(temp_cleanups, lleltptr);\n         i += 1u;\n     }\n \n@@ -422,8 +422,9 @@ fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n \n     // Calculate the last pointer address we want to handle.\n-    // FIXME: Optimize this when the size of the unit type is statically\n-    // known to not use pointer casts, which tend to confuse LLVM. (#2536)\n+    // FIXME (#2536): Optimize this when the size of the unit type is\n+    // statically known to not use pointer casts, which tend to confuse\n+    // LLVM.\n     let data_end_ptr = pointer_add(bcx, data_ptr, fill);\n \n     // Now perform the iteration."}, {"sha": "dc8dc1b92cf362b939a1ceab64bb4f350c55d46c", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -8,6 +8,7 @@ import std::map::hashmap;\n import ty::*;\n \n export type_of;\n+export type_of_dtor;\n export type_of_explicit_args;\n export type_of_fn_from_ty;\n export type_of_fn;\n@@ -251,3 +252,9 @@ fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> str {\n     );\n }\n \n+fn type_of_dtor(ccx: @crate_ctxt, self_ty: ty::t) -> TypeRef {\n+    T_fn([T_ptr(type_of(ccx, ty::mk_nil(ccx.tcx))),\n+          T_ptr(type_of(ccx, self_ty))],\n+         llvm::LLVMVoidType())\n+}\n+"}, {"sha": "628d407feadc71a62328d387c437f4c145e950e4", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -183,8 +183,8 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         node_type_needs(cx, use_repr, val.id);\n       }\n       expr_index(base, _) | expr_field(base, _, _) {\n-        // FIXME could be more careful and not count fields\n-        // after the chosen field (#2537)\n+        // FIXME (#2537): could be more careful and not count fields after\n+        // the chosen field.\n         let base_ty = ty::node_id_to_type(cx.ccx.tcx, base.id);\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n "}, {"sha": "f20ad0f73dc80f032b0dca80326d2453f1977f57", "filename": "src/rustc/middle/tstate/ann.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -243,8 +243,8 @@ fn trit_str(t: trit) -> str {\n     alt t { dont_care { \"?\" } ttrue { \"1\" } tfalse { \"0\" } }\n }\n \n-// FIXME: Would be nice to have unit tests for some of these operations, as\n-// a step towards formalizing them more rigorously. #2538\n+// FIXME (#2538): Would be nice to have unit tests for some of these\n+// operations, as a step towards formalizing them more rigorously.\n \n //\n // Local Variables:"}, {"sha": "d20cbcfe4d47e70c0cfe9865667bc14867c9b032", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -7,16 +7,18 @@ import aux::{num_constraints, get_fn_info, crate_ctxt, add_node};\n import ann::empty_ann;\n import pat_util::pat_binding_ids;\n \n-fn collect_ids_expr(e: @expr, rs: @mut [node_id]) { *rs += [e.id]; }\n+fn collect_ids_expr(e: @expr, rs: @mut [node_id]) { vec::push(*rs, e.id); }\n \n-fn collect_ids_block(b: blk, rs: @mut [node_id]) { *rs += [b.node.id]; }\n+fn collect_ids_block(b: blk, rs: @mut [node_id]) {\n+    vec::push(*rs, b.node.id);\n+}\n \n fn collect_ids_stmt(s: @stmt, rs: @mut [node_id]) {\n     alt s.node {\n       stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) {\n         #debug[\"node_id %s\", int::str(id)];\n         #debug[\"%s\", stmt_to_str(*s)];\n-        *rs += [id];\n+        vec::push(*rs, id);\n       }\n     }\n }"}, {"sha": "5fb79dc1318d6beb2099aa676a3d29e0db02aa5f", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -195,8 +195,8 @@ may be the operator in a \"check\" expression in the source.  */\n \n type constraint = {\n     path: @path,\n-    // FIXME: really only want it to be mut during collect_locals.\n-    // freeze it after that. (#2539)\n+    // FIXME (#2539): really only want it to be mut during\n+    // collect_locals.  freeze it after that.\n     descs: @dvec<pred_args>\n };\n \n@@ -494,9 +494,8 @@ fn constraints(fcx: fn_ctxt) -> [norm_constraint] {\n     ret rslt;\n }\n \n-// FIXME\n-// Would rather take an immutable vec as an argument,\n-// should freeze it at some earlier point. (#2539)\n+// FIXME (#2539): Would rather take an immutable vec as an argument,\n+// should freeze it at some earlier point.\n fn match_args(fcx: fn_ctxt, occs: @dvec<pred_args>,\n               occ: [@constr_arg_use]) -> uint {\n     #debug(\"match_args: looking at %s\","}, {"sha": "4883422a90872d6ce0b5903c98be2d093e6b1fac", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -169,9 +169,9 @@ fn find_pre_post_state_call(fcx: fn_ctxt, pres: prestate, a: @expr,\n                             id: node_id, ops: [init_op], bs: [@expr],\n                             cf: ret_style) -> bool {\n     let mut changed = find_pre_post_state_expr(fcx, pres, a);\n-    // FIXME: This could be a typestate constraint (except we're\n-    // not using them inside the compiler, I guess... see\n-    // discussion at #2178)\n+    // FIXME (#2178): This could be a typestate constraint (except we're\n+    // not using them inside the compiler, I guess... see discussion in\n+    // bug)\n     if vec::len(bs) != vec::len(ops) {\n         fcx.ccx.tcx.sess.span_bug(a.span,\n                                   #fmt[\"mismatched arg lengths: \\"}, {"sha": "7bcc4840d25e26f4f1177752e86069e44cfda110", "filename": "src/rustc/middle/tstate/tritv.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -25,10 +25,10 @@ export to_str;\n    01 = \"this constraint is definitely true\"\n    00 = \"this constraint is definitely false\"\n    11 should never appear\n- FIXME: typestate precondition (uncertain and val must\n+ FIXME (#2178): typestate precondition (uncertain and val must\n  have the same length; 11 should never appear in a given position)\n  (except we're not putting typestate constraints in the compiler, as\n- per discussion at #2178).\n+ per discussion at).\n */\n \n type t = {uncertain: bitv::bitv, val: bitv::bitv, nbits: uint};\n@@ -90,8 +90,8 @@ fn trit_or(a: trit, b: trit) -> trit {\n       tfalse {\n         alt b {\n           ttrue { dont_care }\n-          /* FIXME: ??????\n-             Again, unit tests would help here -- #2538\n+          /* FIXME (#2538): ??????\n+             Again, unit tests would help here\n            */\n           _ {\n             tfalse\n@@ -101,12 +101,11 @@ fn trit_or(a: trit, b: trit) -> trit {\n     }\n }\n \n-// FIXME: This still seems kind of dodgy to me (that is,\n+// FIXME (#2538): This still seems kind of dodgy to me (that is,\n // that 1 + ? = 1. But it might work out given that\n // all variables start out in a 0 state. Probably I need\n // to make it so that all constraints start out in a 0 state\n // (we consider a constraint false until proven true), too.\n-// #2538 would help.\n fn trit_and(a: trit, b: trit) -> trit {\n     alt a {\n       dont_care { b }"}, {"sha": "3083563d220e6c5f173e9191f3dae8401df4b39c", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -1209,7 +1209,6 @@ pure fn type_is_scalar(ty: t) -> bool {\n     }\n }\n \n-// FIXME maybe inline this for speed?\n fn type_is_immediate(ty: t) -> bool {\n     ret type_is_scalar(ty) || type_is_boxed(ty) ||\n         type_is_unique(ty) || type_is_region_ptr(ty);\n@@ -1614,7 +1613,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n       }\n       ty_constr(t, _) { type_kind(cx, t) }\n-      // FIXME: is self ever const?\n+      // FIXME (#2663): is self ever const?\n       ty_self { kind_noncopyable() }\n       ty_var(_) | ty_var_integral(_) {\n         cx.sess.bug(\"Asked to compute kind of a type variable\");\n@@ -2038,7 +2037,6 @@ fn hash_type_structure(st: sty) -> uint {\n     fn hash_type_constr(id: uint, c: @type_constr) -> uint {\n         let mut h = id;\n         h = (h << 2u) + hash_def(h, c.node.id);\n-        // FIXME this makes little sense\n         for c.node.args.each {|a|\n             alt a.node {\n               carg_base { h += h << 2u; }\n@@ -2169,7 +2167,6 @@ fn args_eq<T>(eq: fn(T, T) -> bool,\n fn constr_eq(c: @constr, d: @constr) -> bool {\n     fn eq_int(&&x: uint, &&y: uint) -> bool { ret x == y; }\n     ret path_to_str(c.node.path) == path_to_str(d.node.path) &&\n-            // FIXME: hack\n             args_eq(eq_int, c.node.args, d.node.args);\n }\n "}, {"sha": "3c7bddc9022c0b7fa1b5262498ad0605897ceb4e", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -188,33 +188,29 @@ fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n \n fn require_same_types(\n     tcx: ty::ctxt,\n+    maybe_infcx: option<infer::infer_ctxt>,\n     span: span,\n     t1: ty::t,\n     t2: ty::t,\n     msg: fn() -> str) -> bool {\n \n-    alt infer::compare_tys(tcx, t1, t2) {\n-      result::ok(()) { true }\n-      result::err(terr) {\n-        tcx.sess.span_err(span, msg() + \": \" +\n-            ty::type_err_to_str(tcx, terr));\n-        false\n+    let l_tcx, l_infcx;\n+    alt maybe_infcx {\n+      none {\n+        l_tcx = tcx;\n+        l_infcx = infer::new_infer_ctxt(tcx);\n+      }\n+      some(i) {\n+        l_tcx = i.tcx;\n+        l_infcx = i;\n       }\n     }\n-}\n-\n-fn require_same_types_in_infcx(\n-    infcx: infer::infer_ctxt,\n-    span: span,\n-    t1: ty::t,\n-    t2: ty::t,\n-    msg: fn() -> str) -> bool {\n \n-    alt infer::compare_tys_in_infcx(infcx, t1, t2) {\n+    alt infer::mk_eqty(l_infcx, t1, t2) {\n       result::ok(()) { true }\n       result::err(terr) {\n-        infcx.tcx.sess.span_err(span, msg() + \": \" +\n-            ty::type_err_to_str(infcx.tcx, terr));\n+        l_tcx.sess.span_err(span, msg() + \": \" +\n+            ty::type_err_to_str(l_tcx, terr));\n         false\n       }\n     }"}, {"sha": "e3f6ba40aefda3fabec4088d0c87f680d5c95ff8", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 8, "deletions": 37, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -74,7 +74,7 @@ import rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n import rscope::{in_binding_rscope, region_scope, type_rscope};\n import syntax::ast::ty_i;\n import typeck::infer::{unify_methods}; // infcx.set()\n-import typeck::infer::{force_level, force_none, force_non_region_vars_only,\n+import typeck::infer::{force_level, force_none, force_ty_vars_only,\n                        force_all};\n \n type fn_ctxt =\n@@ -606,14 +606,6 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n     };\n }\n \n-// Returns true if the two types unify and false if they don't.\n-fn are_compatible(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n-    alt fcx.mk_eqty(expected, actual) {\n-      result::ok(_) { ret true; }\n-      result::err(_) { ret false; }\n-    }\n-}\n-\n // AST fragment checking\n fn check_lit(fcx: @fn_ctxt, lit: @ast::lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n@@ -929,22 +921,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let lhs_t = fcx.expr_ty(lhs);\n         let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n         ret alt (op, ty::get(lhs_t).struct) {\n-          (ast::add, ty::ty_vec(lhs_mt)) {\n-            // For adding vectors with type L=[ML TL] and R=[MR TR], the the\n-            // result [ML T] where TL <: T and TR <: T.  In other words, the\n-            // result type is (generally) the LUB of (TL, TR) and takes the\n-            // mutability from the LHS.\n-            let t_var = fcx.infcx.next_ty_var();\n-            let const_vec_t = ty::mk_vec(tcx, {ty: t_var,\n-                                               mutbl: ast::m_const});\n-            demand::suptype(fcx, lhs.span, const_vec_t, lhs_t);\n-            let rhs_bot = check_expr_with(fcx, rhs, const_vec_t);\n-            let result_vec_t = ty::mk_vec(tcx, {ty: t_var,\n-                                                mutbl: lhs_mt.mutbl});\n-            fcx.write_ty(expr.id, result_vec_t);\n-            lhs_bot | rhs_bot\n-          }\n-\n           (_, _) if ty::type_is_integral(lhs_t) &&\n           ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs can be any integral type\n@@ -1198,14 +1174,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             }\n           }\n           ast::neg {\n-            // If the operand's type is an integral type variable, we\n-            // don't want to resolve it yet, because the rest of the\n-            // typing context might not have had the opportunity to\n-            // constrain it yet.\n-            if !(ty::type_is_var_integral(oprnd_t)) {\n-                oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n-                                                     oprnd_t);\n-            }\n+            oprnd_t = structurally_resolved_type(fcx, oprnd.span, oprnd_t);\n             if !(ty::type_is_integral(oprnd_t) ||\n                  ty::type_is_fp(oprnd_t)) {\n                 oprnd_t = check_user_unop(fcx, \"-\", \"unary-\", expr,\n@@ -1248,9 +1217,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         };\n         alt expr_opt {\n           none {\n-            if !are_compatible(fcx, ret_ty, ty::mk_nil(tcx)) {\n+            alt fcx.mk_eqty(ret_ty, ty::mk_nil(tcx)) {\n+              result::ok(_) { /* fall through */ }\n+              result::err(_) {\n                 tcx.sess.span_err(expr.span,\n-                                  \"ret; in function returning non-nil\");\n+                                  \"ret; in function returning non-nil\"); }\n             }\n           }\n           some(e) { check_expr_with(fcx, e, ret_ty); }\n@@ -2138,7 +2109,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n // resolution is possible, then an error is reported.\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n     alt infer::resolve_shallow(fcx.infcx, tp,\n-                               force_non_region_vars_only) {\n+                               force_ty_vars_only) {\n       result::ok(t_s) if !ty::type_is_var(t_s) { ret t_s; }\n       _ {\n         fcx.ccx.tcx.sess.span_fatal\n@@ -2305,7 +2276,7 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::native_item) {\n                                          expected %u\", i_n_tps, n_tps));\n     } else {\n         require_same_types(\n-            tcx, it.span, i_ty.ty, fty,\n+            tcx, none, it.span, i_ty.ty, fty,\n             {|| #fmt[\"intrinsic has wrong type. \\\n                       expected %s\",\n                      ty_to_str(ccx.tcx, fty)]});"}, {"sha": "7a1eca4fc257dab576a88494f1e5a8b0139d4410", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -141,8 +141,8 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             fcx.infcx.resolve_type_vars_if_possible(fcx.expr_ty(end));\n         #debug[\"pat_range beginning type: %?\", b_ty];\n         #debug[\"pat_range ending type: %?\", e_ty];\n-        if !require_same_types_in_infcx(\n-            fcx.infcx, pat.span, b_ty, e_ty,\n+        if !require_same_types(\n+            tcx, some(fcx.infcx), pat.span, b_ty, e_ty,\n             {|| \"mismatched types in range\" }) {\n             // no-op\n         } else if !ty::type_is_numeric(b_ty) {"}, {"sha": "1c2d1234118d601a5321e615c714840773fddf1e", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -154,6 +154,7 @@ class lookup {\n     }\n \n     fn add_candidates_from_param(n: uint, did: ast::def_id) {\n+        #debug[\"candidates_from_param\"];\n \n         let tcx = self.tcx();\n         let mut iface_bnd_idx = 0u; // count only iface bounds\n@@ -202,6 +203,8 @@ class lookup {\n \n     fn add_candidates_from_iface(did: ast::def_id, iface_substs: ty::substs) {\n \n+        #debug[\"method_from_iface\"];\n+\n         let ms = *ty::iface_methods(self.tcx(), did);\n         for ms.eachi {|i, m|\n             if m.ident != self.m_name { cont; }\n@@ -235,6 +238,8 @@ class lookup {\n \n     fn add_candidates_from_class(did: ast::def_id, class_substs: ty::substs) {\n \n+        #debug[\"method_from_class\"];\n+\n         let ms = *ty::iface_methods(self.tcx(), did);\n \n         for ms.each {|m|\n@@ -285,6 +290,8 @@ class lookup {\n         let impls_vecs = self.fcx.ccx.impl_map.get(self.expr.id);\n         let mut added_any = false;\n \n+        #debug[\"method_from_scope\"];\n+\n         for list::each(impls_vecs) {|impls|\n             for vec::each(*impls) {|im|\n                 // Check whether this impl has a method with the right name.\n@@ -297,9 +304,11 @@ class lookup {\n \n                     // if we can assign the caller to the callee, that's a\n                     // potential match.  Collect those in the vector.\n-                    alt self.fcx.can_mk_assignty(\n+                    let can_assign = self.fcx.can_mk_assignty(\n                         self.self_expr, self.borrow_scope,\n-                        self.self_ty, impl_ty) {\n+                        self.self_ty, impl_ty);\n+                    #debug[\"can_assign = %?\", can_assign];\n+                    alt can_assign {\n                       result::err(_) { /* keep looking */ }\n                       result::ok(_) {\n                         let fty = self.ty_from_did(m.did);"}, {"sha": "b693ddb8492e7ed86282f0cf4269f0bf60479e39", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -25,8 +25,8 @@ import rscope::*;\n \n fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n \n-    // FIXME: hooking into the \"intrinsic\" root module is crude.\n-    // there ought to be a better approach. Attributes? (#2592)\n+    // FIXME (#2592): hooking into the \"intrinsic\" root module is crude.\n+    // There ought to be a better approach. Attributes?\n \n     for crate.node.module.items.each {|crate_item|\n         if *crate_item.ident == \"intrinsic\" {\n@@ -210,7 +210,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n         ty::subst(tcx, substs, if_fty)\n     };\n     require_same_types(\n-        tcx, sp, impl_fty, if_fty,\n+        tcx, none, sp, impl_fty, if_fty,\n         {|| \"method `\" + *if_m.ident + \"` has an incompatible type\"});\n     ret;\n "}, {"sha": "e948e999e5c8c95692d39334028b024a51c37f4f", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -193,13 +193,11 @@ export resolve_deep;\n export resolve_deep_var;\n export methods; // for infer_ctxt\n export unify_methods; // for infer_ctxt\n-export compare_tys;\n-export compare_tys_in_infcx;\n export fixup_err, fixup_err_to_str;\n export assignment;\n export root, to_str;\n export int_ty_set_all;\n-export force_level, force_none, force_non_region_vars_only, force_all;\n+export force_level, force_none, force_ty_vars_only, force_all;\n \n // Bitvector to represent sets of integral types\n enum int_ty_set = uint;\n@@ -389,25 +387,16 @@ fn can_mk_assignty(cx: infer_ctxt, anmnt: assignment,\n     #debug[\"can_mk_assignty(%? / %s <: %s)\",\n            anmnt, a.to_str(cx), b.to_str(cx)];\n \n-    // FIXME---this will not unroll any entries we make in the\n-    // borrowings table.  But this is OK for the moment because this\n-    // is only used in method lookup, and there must be exactly one\n-    // match or an error is reported. Still, it should be fixed. (#2593)\n+    // FIXME (#2593): this will not unroll any entries we make in the\n+    // borrowings table.  But this is OK for the moment because this is only\n+    // used in method lookup, and there must be exactly one match or an\n+    // error is reported. Still, it should be fixed.\n \n     indent {|| cx.probe {||\n         cx.assign_tys(anmnt, a, b)\n     } }.to_ures()\n }\n \n-fn compare_tys(tcx: ty::ctxt, a: ty::t, b: ty::t) -> ures {\n-    let infcx = new_infer_ctxt(tcx);\n-    mk_eqty(infcx, a, b)\n-}\n-\n-fn compare_tys_in_infcx(infcx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n-    mk_eqty(infcx, a, b)\n-}\n-\n // See comment on the type `resolve_state` below\n fn resolve_shallow(cx: infer_ctxt, a: ty::t,\n                    force_vars: force_level) -> fres<ty::t> {\n@@ -1104,9 +1093,9 @@ enum force_level {\n     // Any unconstrained variables are OK.\n     force_none,\n \n-    // Unconstrained region vars are OK; unconstrained ty vars and\n-    // integral ty vars result in an error.\n-    force_non_region_vars_only,\n+    // Unconstrained region vars and integral ty vars are OK;\n+    // unconstrained general-purpose ty vars result in an error.\n+    force_ty_vars_only,\n \n     // Any unconstrained variables result in an error.\n     force_all,\n@@ -1248,7 +1237,7 @@ impl methods for resolve_state {\n               { ub:_, lb:some(t) } { self.resolve1(t) }\n               { ub:none, lb:none } {\n                 alt self.force_vars {\n-                  force_non_region_vars_only | force_all {\n+                  force_ty_vars_only | force_all {\n                     self.err = some(unresolved_ty(vid));\n                   }\n                   force_none { /* ok */ }\n@@ -1271,7 +1260,7 @@ impl methods for resolve_state {\n           some(t) { t }\n           none {\n             alt self.force_vars {\n-              force_non_region_vars_only | force_all {\n+              force_all {\n                 // As a last resort, default to int.\n                 let ty = ty::mk_int(self.infcx.tcx);\n                 self.infcx.set(\n@@ -1281,7 +1270,7 @@ impl methods for resolve_state {\n                         nde.rank));\n                 ty\n               }\n-              force_none {\n+              force_none | force_ty_vars_only {\n                 ty::mk_var_integral(self.infcx.tcx, vid)\n               }\n             }\n@@ -1718,16 +1707,16 @@ fn super_fns<C:combine>(\n             argvecs(self, a_f.inputs, b_f.inputs).chain {|inputs|\n                 self.tys(a_f.output, b_f.output).chain {|output|\n                     self.purities(a_f.purity, b_f.purity).chain {|purity|\n-                    //FIXME self.infcx().constrvecs(a_f.constraints,\n-                    //FIXME                         b_f.constraints).then {||\n-                    // (Fix this if #2588 doesn't get accepted)\n+                    // FIXME: uncomment if #2588 doesn't get accepted:\n+                    // self.infcx().constrvecs(a_f.constraints,\n+                    //                         b_f.constraints).then {||\n                         ok({purity: purity,\n                             proto: p,\n                             inputs: inputs,\n                             output: output,\n                             ret_style: rs,\n                             constraints: a_f.constraints})\n-                    //FIXME }\n+                    // }\n                     }\n                 }\n             }"}, {"sha": "6e6c5fa740e5ce8c98f48335d276fe8f2d491f70", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -70,8 +70,8 @@ fn local_rhs_span(l: @ast::local, def: span) -> span {\n }\n \n fn is_main_name(path: syntax::ast_map::path) -> bool {\n-    // FIXME: path should be a constrained type, so we know\n-    // the call to last doesn't fail (#34)\n+    // FIXME (#34): path should be a constrained type, so we know\n+    // the call to last doesn't fail.\n     vec::last(path) == syntax::ast_map::path_name(@\"main\")\n }\n "}, {"sha": "83167597bb876c9e56914129d36b409d671e62e8", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -28,12 +28,12 @@ fn bound_region_to_str(cx: ctxt, br: bound_region) -> str {\n }\n \n fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> str {\n-    alt cx.items.get(node_id) {\n-      ast_map::node_block(blk) {\n+    alt cx.items.find(node_id) {\n+      some(ast_map::node_block(blk)) {\n         #fmt(\"<block at %s>\",\n              codemap::span_to_str(blk.span, cx.sess.codemap))\n       }\n-      ast_map::node_expr(expr) {\n+      some(ast_map::node_expr(expr)) {\n         alt expr.node {\n           ast::expr_call(*) {\n             #fmt(\"<call at %s>\","}, {"sha": "f39fe1f8120d0c2556f6610623488b37a2d02db3", "filename": "src/rustdoc/demo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdemo.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -8,7 +8,7 @@\n     for testing purposes. It doesn't surve any functional\n     purpose. This here, for instance, is just some filler text.\n \n-    FIXME (1654): It would be nice if we could run some automated\n+    FIXME (#1654): It would be nice if we could run some automated\n     tests on this file\n \n \"];"}, {"sha": "84d7c8c31fd3b6e1f53b0e20aea685ea1acc3b9c", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -20,9 +20,9 @@ type section = {\n     body: str\n };\n \n-// FIXME: We currently give topmod the name of the crate.  There would\n-// probably be fewer special cases if the crate had its own name and\n-// topmod's name was the empty string. (#2596)\n+// FIXME (#2596): We currently give topmod the name of the crate.  There\n+// would probably be fewer special cases if the crate had its own name\n+// and topmod's name was the empty string.\n type cratedoc = {\n     topmod: moddoc,\n };"}, {"sha": "169a866731637231a0ab8875e9db9dfc21ba50b2", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -1,3 +1,11 @@\n+S 2012-06-20 c891dec\n+  macos-x86_64 cd7b3213a05e11dbf7440db016c9f7db16598501\n+  macos-i386 eba609b4c815c415ca9485cac749c08ede5bf9ff\n+  freebsd-x86_64 c93d3297bf68d12a55af04fecab5c1792394fcca\n+  linux-x86_64 eb0e614c6f463fdbf3f40953ff122eb7cd829b85\n+  linux-i386 6d858ef6915517135e633043115ab51d677010c5\n+  winnt-i386 ffc26150a21aac3c5b023070c0e52d3c01b1881c\n+\n S 2012-06-19 de491ea\n   freebsd-x86_64 b5c1080df70136bb316286e1973fa2b5734c9a01\n   winnt-i386 fa1c7b2295dbde00269f859b8cb637a59a8deec4"}, {"sha": "cde1c76e344096d4c04bb5fdbeeea1fe975dfe48", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -7,7 +7,7 @@ import io::writer_util;\n fn collect_raw(num: uint) -> [uint] {\n     let mut result = [];\n     for uint::range(0u, num) { |i|\n-        result += [i];\n+        vec::push(result, i);\n     }\n     ret result;\n }\n@@ -43,18 +43,18 @@ fn main(args: [str]) {\n \n     let raw = mid - start;\n     let dvec = end - mid;\n-\n+    \n     let maxf = max as float;\n     let rawf = raw as float;\n     let dvecf = dvec as float;\n-\n+    \n     io::stdout().write_str(#fmt(\"Raw     : %? seconds\\n\", raw));\n     io::stdout().write_str(#fmt(\"        : %f op/sec\\n\", maxf/rawf));\n     io::stdout().write_str(#fmt(\"\\n\"));\n     io::stdout().write_str(#fmt(\"Dvec    : %? seconds\\n\", dvec));\n     io::stdout().write_str(#fmt(\"        : %f op/sec\\n\", maxf/dvecf));\n     io::stdout().write_str(#fmt(\"\\n\"));\n-\n+    \n     if dvec < raw {\n         io::stdout().write_str(#fmt(\"Dvec is %f%% faster than raw\\n\",\n                                     (rawf - dvecf) / rawf * 100.0));"}, {"sha": "6c6466017ef53eb3b6cb6efa5ac77c68ed0cea2c", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -1,6 +1,6 @@\n /**\n \n-An implementation of the Graph500 Bread First Search problem in Rust.\n+An implementation of the Graph500 Breadth First Search problem in Rust.\n \n */\n "}, {"sha": "cba62f2ada11900b9a6a236fec9fb8a94b27145c", "filename": "src/test/bench/msgsend-ring-new.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,76 @@\n+// This test creates a bunch of tasks that simultaneously send to each\n+// other in a ring. The messages should all be basically\n+// independent. It's designed to hammer the global kernel lock, so\n+// that things will look really good once we get that lock out of the\n+// message path.\n+\n+import newcomm::*;\n+import future::future;\n+\n+use std;\n+import std::time;\n+\n+fn thread_ring(i: uint,\n+               count: uint,\n+               num_chan: chan<uint>,\n+               num_port: port<uint>) {\n+    // Send/Receive lots of messages.\n+    for uint::range(0u, count) {|j|\n+        num_chan.send(i * j);\n+        num_port.recv();\n+    };\n+}\n+\n+fn main(args: [str]) {\n+    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+        [\"\", \"100\", \"10000\"]\n+    } else if args.len() <= 1u {\n+        [\"\", \"100\", \"1000\"]\n+    } else {\n+        args\n+    };        \n+\n+    let num_tasks = option::get(uint::from_str(args[1]));\n+    let msg_per_task = option::get(uint::from_str(args[2]));\n+\n+    let num_port = port();\n+    let mut num_chan = chan(num_port);\n+\n+    let start = time::precise_time_s();\n+\n+    // create the ring\n+    let mut futures = [];\n+\n+    for uint::range(1u, num_tasks) {|i|\n+        let get_chan = port();\n+        let get_chan_chan = chan(get_chan);\n+        {\n+            let num_chan = num_chan.clone();\n+            futures += [future::spawn {|move num_chan, move get_chan_chan|\n+                let p = port();\n+                get_chan_chan.send(chan(p));\n+                thread_ring(i, msg_per_task, num_chan,  p)\n+            }];\n+        }\n+        \n+        num_chan = get_chan.recv();\n+    };\n+\n+    // do our iteration\n+    thread_ring(0u, msg_per_task, num_chan, num_port);\n+\n+    // synchronize\n+    for futures.each {|f| f.get() };\n+\n+    let stop = time::precise_time_s();\n+\n+    // all done, report stats.\n+    let num_msgs = num_tasks * msg_per_task;\n+    let elapsed = (stop - start);\n+    let rate = (num_msgs as float) / elapsed;\n+\n+    io::println(#fmt(\"Sent %? messages in %? seconds\",\n+                     num_msgs, elapsed));\n+    io::println(#fmt(\"  %? messages / second\", rate));\n+    io::println(#fmt(\"  %? \u03bcs / message\", 1000000. / rate));\n+}"}, {"sha": "75e0763e4a60dd45ec9181947fd8bfc454b83b8a", "filename": "src/test/compile-fail/alt-pattern-field-mismatch-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch-2.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,16 @@\n+fn main() {\n+    enum color {\n+        rgb(uint, uint, uint),\n+        cmyk(uint, uint, uint, uint),\n+        no_color,\n+    }\n+\n+    fn foo(c: color) {\n+        alt c {\n+          rgb(_, _, _) { }\n+          cmyk(_, _, _, _) { }\n+          no_color(_) { }\n+          //!^ ERROR this pattern has 1 field, but the corresponding variant has no fields\n+        }\n+    }\n+}"}, {"sha": "086267a85b3bea9da84b8ebb9e3e75d54769ec20", "filename": "src/test/compile-fail/alt-pattern-field-mismatch.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-pattern-field-mismatch.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,16 @@\n+fn main() {\n+    enum color {\n+        rgb(uint, uint, uint),\n+        cmyk(uint, uint, uint, uint),\n+        no_color,\n+    }\n+\n+    fn foo(c: color) {\n+        alt c {\n+          rgb(_, _) { }\n+          //!^ ERROR this pattern has 2 fields, but the corresponding variant has 3 fields\n+          cmyk(_, _, _, _) { }\n+          no_color { }\n+        }\n+    }\n+}"}, {"sha": "ffa812c8b719a3e4c72f5941fbd3654e95dcaf4a", "filename": "src/test/compile-fail/binop-logic-int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fbinop-logic-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fbinop-logic-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-logic-int.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:&& cannot be applied to type `int`\n \n-fn main() { let x = 1 && 2; }\n+fn main() { let x = 1i && 2i; }"}, {"sha": "183106aa28e8ca45ec810e3cfa7fe9be0c82d11c", "filename": "src/test/compile-fail/borrowck-binding-mutbl.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fborrowck-binding-mutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fborrowck-binding-mutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-binding-mutbl.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,13 @@\n+fn impure(_v: [int]) {\n+}\n+\n+fn main() {\n+    let x = {mut f: [3]};\n+\n+    alt x {\n+      {f: v} => {\n+        impure(v); //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+        //!^ NOTE impure due to access to impure function\n+      }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "00c579dc45ee0de4d0bfd0be996d82f793d06644", "filename": "src/test/compile-fail/borrowck-issue-2657-1.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+let x = some(~1);\n+alt x { //! NOTE loan of immutable local variable granted here\n+  some(y) {\n+    let _a <- x; //! ERROR moving out of immutable local variable prohibited due to outstanding loan\n+  }\n+  _ {}\n+}\n+}"}, {"sha": "d8d068ee8fd74423017c0925abcfc8fdf380a206", "filename": "src/test/compile-fail/borrowck-issue-2657-2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+let x = some(~1);\n+alt x {\n+  some(y) {\n+    let _b <- y; //! ERROR moving out of pattern binding\n+  }\n+  _ {}\n+}\n+}"}, {"sha": "03fbb6b975ce8407ae4009c08b2988bd39634633", "filename": "src/test/compile-fail/borrowck-move-from-unsafe-ptr.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,7 @@\n+fn foo(x: *~int) -> ~int {\n+    let y <- *x; //! ERROR dereference of unsafe pointer requires unsafe function or block\n+    ret y;\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "eea825060612b7c511936384eff6c78e0e4c3434", "filename": "src/test/compile-fail/issue-1896.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fissue-1896.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fissue-1896.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,8 @@\n+type t<T> = { f: fn() -> T };\n+\n+fn f<T>(_x: t<T>) {}\n+\n+fn main() {\n+  let x: t<()> = { f: { || () } }; //! ERROR expressions with stack closure\n+    f(x);\n+}"}, {"sha": "5e289af9f517f763f7c2c926de2c1dd65ec5fce1", "filename": "src/test/compile-fail/issue-2111.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2111.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,11 @@\n+fn foo(a: option<uint>, b: option<uint>) {\n+  alt (a,b) { //! ERROR: non-exhaustive patterns: none not covered\n+    (some(a), some(b)) if a == b { }\n+    (some(_), none) |\n+    (none, some(_)) { }\n+  }\n+}\n+\n+fn main() {\n+  foo(none, none);\n+}\n\\ No newline at end of file"}, {"sha": "2429273e1ecc8b37d4007342884edb3d379018ce", "filename": "src/test/compile-fail/issue-2467.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,6 @@\n+enum test { thing = 3u } //! ERROR mismatched types\n+//!^ ERROR expected signed integer constant\n+fn main() {\n+    log(error, thing as int);\n+    assert(thing as int == 3);\n+}"}, {"sha": "c27fee9f8a876ab6631ef4ab59afced3d5c2df5c", "filename": "src/test/compile-fail/issue-2590.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,13 @@\n+import dvec::dvec;\n+\n+type parser = {\n+    tokens: dvec<int>,\n+};\n+\n+impl parser for parser {\n+    fn parse() -> [mut int] {\n+        dvec::unwrap(self.tokens) //! ERROR illegal move from self\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6d18bf9e2f8e17c57437207e68deb1a2137b401e", "filename": "src/test/compile-fail/vec-add.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-add.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -1,3 +1,9 @@\n+// xfail-test\n+\n+// FIXME: + should allow immutable or mutable vectors on the right\n+// hand side in all cases. We are getting compiler errors about this\n+// now, so I'm xfailing the test for now. -eholk\n+\n fn add(i: [int], m: [mut int], c: [const int]) {\n \n     // Check that:\n@@ -6,23 +12,23 @@ fn add(i: [int], m: [mut int], c: [const int]) {\n \n    add(i + [3],\n        m + [3],\n-       c + [3]);\n+       [3]);\n \n    add(i + [mut 3],\n        m + [mut 3],\n-       c + [mut 3]);\n+       [mut 3]);\n \n    add(i + i,\n        m + i,\n-       c + i);\n+       i);\n \n    add(i + m,\n        m + m,\n-       c + m);\n+       m);\n \n    add(i + c,\n        m + c,\n-       c + c);\n+       c);\n \n    add(m + [3], //! ERROR mismatched types\n        m + [3],\n@@ -33,8 +39,10 @@ fn add(i: [int], m: [mut int], c: [const int]) {\n        i + [3]);\n \n    add(c + [3], //! ERROR mismatched types\n-       c + [3], //! ERROR mismatched types\n-       c + [3]);\n+                //!^ ERROR binary operation + cannot be applied\n+       c + [3], //! ERROR binary operation + cannot be applied\n+                //!^ mismatched types\n+       [3]);\n \n    add(m + [mut 3], //! ERROR mismatched types\n        m + [mut 3],\n@@ -44,9 +52,11 @@ fn add(i: [int], m: [mut int], c: [const int]) {\n        i + [mut 3], //! ERROR mismatched types\n        i + [mut 3]);\n \n-   add(c + [mut 3], //! ERROR mismatched types\n-       c + [mut 3], //! ERROR mismatched types\n-       c + [mut 3]);\n+   add(c + [mut 3], //! ERROR binary operation + cannot be applied\n+                    //!^ mismatched types\n+       c + [mut 3], //! ERROR binary operation + cannot be applied\n+                    //!^ mismatched types\n+       [mut 3]);\n \n    add(m + i, //! ERROR mismatched types\n        m + i,\n@@ -56,9 +66,11 @@ fn add(i: [int], m: [mut int], c: [const int]) {\n        i + i, //! ERROR mismatched types\n        i + i);\n \n-   add(c + i, //! ERROR mismatched types\n-       c + i, //! ERROR mismatched types\n-       c + i);\n+   add(c + i, //! ERROR binary operation + cannot be applied\n+              //!^ ERROR mismatched types\n+       c + i, //! ERROR binary operation + cannot be applied\n+              //!^ ERROR mismatched types\n+       i);\n \n    add(m + m, //! ERROR mismatched types\n        m + m,\n@@ -68,9 +80,11 @@ fn add(i: [int], m: [mut int], c: [const int]) {\n        i + m, //! ERROR mismatched types\n        i + m);\n \n-   add(c + m, //! ERROR mismatched types\n-       c + m, //! ERROR mismatched types\n-       c + m);\n+   add(c + m, //! ERROR binary operation + cannot be applied\n+              //!^ ERROR mismatched types\n+       c + m, //! ERROR binary operation + cannot be applied\n+              //!^ ERROR mismatched types\n+       m);\n \n    add(m + c, //! ERROR mismatched types\n        m + c,\n@@ -80,9 +94,11 @@ fn add(i: [int], m: [mut int], c: [const int]) {\n        i + c, //! ERROR mismatched types\n        i + c);\n \n-   add(c + c, //! ERROR mismatched types\n-       c + c, //! ERROR mismatched types\n-       c + c);\n+   add(c + c, //! ERROR binary operation + cannot be applied\n+              //!^ ERROR mismatched types\n+       c + c, //! ERROR binary operation + cannot be applied\n+              //!^ ERROR mismatched types\n+       c);\n }\n \n fn main() {"}, {"sha": "736b61cb935f967a6dcca93399835f12fcb09329", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -10,15 +10,15 @@ fn enum_chars(start: u8, end: u8) -> [char] {\n     assert start < end;\n     let mut i = start;\n     let mut r = [];\n-    while i <= end { r += [i as char]; i += 1u as u8; }\n+    while i <= end { vec::push(r, i as char); i += 1u as u8; }\n     ret r;\n }\n \n fn enum_uints(start: uint, end: uint) -> [uint] {\n     assert start < end;\n     let mut i = start;\n     let mut r = [];\n-    while i <= end { r += [i]; i += 1u; }\n+    while i <= end { vec::push(r, i); i += 1u; }\n     ret r;\n }\n "}, {"sha": "ef0803c00d0efcc7c0fb34fad2390b97745a7268", "filename": "src/test/run-pass/borrowck-move-from-unsafe-ptr-ok.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fborrowck-move-from-unsafe-ptr-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fborrowck-move-from-unsafe-ptr-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-move-from-unsafe-ptr-ok.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,11 @@\n+// just make sure this compiles:\n+\n+fn bar(x: *~int) -> ~int {\n+    unsafe {\n+        let y <- *x;\n+        ret y;\n+    }\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "c1473b1a0d4e69d8445aa64ec9c537143ccdab90", "filename": "src/test/run-pass/import-glob-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -4,6 +4,6 @@ import vec::*;\n \n fn main() {\n     let mut v = from_elem(0u, 0);\n-    v += [4, 2];\n+    v = vec::append(v, [4, 2]);\n     assert (reversed(v) == [2, 4]);\n }"}, {"sha": "35434e11f613174e6f725989c36a181786c83f01", "filename": "src/test/run-pass/issue-2101.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fissue-2101.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fissue-2101.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2101.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,20 @@\n+// xfail-test\n+use std;\n+import std::arena;\n+import std::arena::arena;\n+\n+enum hold { s(str) }\n+\n+fn init(ar: &a.arena::arena, str: str) -> &a.hold {\n+    new(*ar) s(str)\n+}\n+\n+fn main(args: [str]) {\n+    let ar = arena::arena();\n+    let leak = init(&ar, args[0]);\n+    alt *leak {\n+        s(astr) {\n+            io::println(#fmt(\"%?\", astr));\n+        }\n+    };\n+}"}, {"sha": "6795375e8699936e9a3c766ac1a809207156be88", "filename": "src/test/run-pass/issue-2214.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2214.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,24 @@\n+import libc::{c_double, c_int};\n+import f64::*;\n+\n+fn lgamma(n: c_double, value: &mut int) -> c_double {\n+  ret m::lgamma(n, value as &mut c_int);\n+}\n+\n+#[link_name = \"m\"]\n+#[abi = \"cdecl\"]\n+native mod m {\n+    #[cfg(unix)]\n+    #[link_name=\"lgamma_r\"] fn lgamma(n: c_double, sign: &mut c_int)\n+      -> c_double;\n+    #[cfg(windows)]\n+    #[link_name=\"__lgamma_r\"] fn lgamma(n: c_double,\n+                                        sign: &mut c_int) -> c_double;\n+\n+}\n+\n+fn main() {\n+  let mut y: int = 5;\n+  let x: &mut int = &mut y;\n+  assert (lgamma(1.0 as c_double, x) == 0.0 as c_double);\n+}\n\\ No newline at end of file"}, {"sha": "77a349b4ec9bc75a59e10ac5d65a656025c54a0a", "filename": "src/test/run-pass/issue-912.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fissue-912.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fissue-912.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-912.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,8 @@\n+// xfail-test\n+fn find<T>(_f: fn(@T) -> bool, _v: [@T]) {}\n+\n+fn main() {\n+    let x = 10, arr = [];\n+    find({|f| f.id == x}, arr);\n+    arr += [{id: 20}]; // This assigns a type to arr\n+}"}, {"sha": "b0f62cc3ea915a7d7365f344c90738728e4a1be6", "filename": "src/test/run-pass/nested-class.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fnested-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fnested-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-class.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,15 @@\n+fn main() {\n+  \n+  class b {\n+    let i: int;\n+    fn do_stuff() -> int { ret 37; }\n+    new(i:int) { self.i = i; }\n+  }\n+\n+  //  fn b(x:int) -> int { fail; }\n+\n+  let z = b(42);\n+  assert(z.i == 42);\n+  assert(z.do_stuff() == 37);\n+  \n+}\n\\ No newline at end of file"}, {"sha": "a67bffa2e92e5ddc0123a78881160e5cd76eb69d", "filename": "src/test/run-pass/operator-overloading-leaks.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Foperator-overloading-leaks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Foperator-overloading-leaks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading-leaks.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,74 @@\n+// The cases commented as \"Leaks\" need to not leak. Issue #2581\n+\n+impl methods<T: copy> for [T] {\n+    fn -(x: [T]/&) -> [T] {\n+        [x[0], x[0], x[0]]\n+    }\n+\n+    fn foo(x: [T]/&) -> [T] {\n+        [x[0], x[0], x[0]]\n+    }\n+}\n+\n+impl methods<T: copy> for ~T {\n+    fn +(rhs: ~T) -> ~T {\n+        rhs\n+    }\n+}\n+\n+impl methods for ~int {\n+    fn -(rhs: ~int) -> ~int {\n+        ~(*self - *rhs)\n+    }\n+}\n+\n+impl methods for @int {\n+    fn +(rhs: @int) -> @int {\n+        @(*self + *rhs)\n+    }\n+}\n+\n+fn main() {\n+    // leaks\n+    let mut bar = [1, 2, 3];\n+    bar -= [3, 2, 1];\n+    bar -= [4, 5, 6];\n+    \n+    io::println(#fmt(\"%?\", bar));\n+\n+    // okay\n+    let mut bar = [1, 2, 3];\n+    bar = bar.foo([3, 2, 1]);\n+    bar = bar.foo([4, 5, 6]);\n+\n+    io::println(#fmt(\"%?\", bar));\n+\n+    // okay\n+    let mut bar = [1, 2, 3];\n+    bar = bar - [3, 2, 1];\n+    bar = bar - [4, 5, 6];\n+\n+    io::println(#fmt(\"%?\", bar));\n+\n+    // Leaks\n+    let mut bar = ~1;\n+    bar += ~2;\n+    bar += ~3;\n+    \n+    io:: println(#fmt(\"%?\", bar));\n+\n+    // Leaks\n+    let mut bar = ~1;\n+    bar -= ~2;\n+    bar -= ~3;\n+    \n+    io:: println(#fmt(\"%?\", bar));\n+\n+    // Leaks\n+    let mut bar = @1;\n+    bar += @2;\n+    bar += @3;\n+    \n+    io:: println(#fmt(\"%?\", bar));\n+\n+}"}, {"sha": "ce052203d4d83e7eab29877827692b2afc61454a", "filename": "src/test/run-pass/unary-minus-suffix-inference.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Funary-minus-suffix-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Funary-minus-suffix-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funary-minus-suffix-inference.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -0,0 +1,43 @@\n+fn main() {\n+    let a = 1;\n+    let a_neg: i8 = -a;\n+    log(error, a_neg);\n+\n+    let b = 1;\n+    let b_neg: i16 = -b;\n+    log(error, b_neg);\n+\n+    let c = 1;\n+    let c_neg: i32 = -c;\n+    log(error, b_neg);\n+\n+    let d = 1;\n+    let d_neg: i64 = -d;\n+    log(error, b_neg);\n+\n+    let e = 1;\n+    let e_neg: int = -e;\n+    log(error, b_neg);\n+\n+    // intentional overflows\n+\n+    let f = 1;\n+    let f_neg: u8 = -f;\n+    log(error, f_neg);\n+\n+    let g = 1;\n+    let g_neg: u16 = -g;\n+    log(error, g_neg);\n+\n+    let h = 1;\n+    let h_neg: u32 = -h;\n+    log(error, h_neg);\n+\n+    let i = 1;\n+    let i_neg: u64 = -i;\n+    log(error, i_neg);\n+\n+    let j = 1;\n+    let j_neg: uint = -j;\n+    log(error, j_neg);\n+}"}, {"sha": "15b9239c44bcc4a8e90e72818872a9474bc1bdba", "filename": "src/test/run-pass/vec-push.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fvec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fvec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-push.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -1,5 +1 @@\n-\n-\n-fn push<T: copy>(&v: [const T], t: T) { v += [t]; }\n-\n-fn main() { let mut v = [1, 2, 3]; push(v, 1); }\n+fn main() { let mut v = [1, 2, 3]; vec::push(v, 1); }"}, {"sha": "9ffb564ace6531277541bdca8849a255679c263a", "filename": "src/test/run-pass/zip-same-length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5281771a07ba6d437bcdd9d94343c04ea1ed7221/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzip-same-length.rs?ref=5281771a07ba6d437bcdd9d94343c04ea1ed7221", "patch": "@@ -10,15 +10,15 @@ fn enum_chars(start: u8, end: u8) -> [char] {\n     assert start < end;\n     let mut i = start;\n     let mut r = [];\n-    while i <= end { r += [i as char]; i += 1u as u8; }\n+    while i <= end { vec::push(r, i as char); i += 1u as u8; }\n     ret r;\n }\n \n fn enum_uints(start: uint, end: uint) -> [uint] {\n     assert start < end;\n     let mut i = start;\n     let mut r = [];\n-    while i <= end { r += [i]; i += 1u; }\n+    while i <= end { vec::push(r, i); i += 1u; }\n     ret r;\n }\n "}]}