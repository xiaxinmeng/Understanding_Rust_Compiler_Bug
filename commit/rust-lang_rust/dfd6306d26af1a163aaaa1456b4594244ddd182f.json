{"sha": "dfd6306d26af1a163aaaa1456b4594244ddd182f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZDYzMDZkMjZhZjFhMTYzYWFhYTE0NTZiNDU5NDI0NGRkZDE4MmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-27T06:37:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-27T06:37:21Z"}, "message": "Auto merge of #88326 - eddyb:inline-ty-layout-methods, r=oli-obk\n\n`#[inline]` non-generic `pub fn`s in `rustc_target::abi` and `ty::layout`.\n\nMostly doing this as a perf curiosity, having spotted that `#[inline]` usage is a bit spotty.", "tree": {"sha": "ed5e40de6babdffac41acd5959a2712214bd531e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed5e40de6babdffac41acd5959a2712214bd531e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfd6306d26af1a163aaaa1456b4594244ddd182f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfd6306d26af1a163aaaa1456b4594244ddd182f", "html_url": "https://github.com/rust-lang/rust/commit/dfd6306d26af1a163aaaa1456b4594244ddd182f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfd6306d26af1a163aaaa1456b4594244ddd182f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "720a1b23c1eda3c78e28126362238a500eaa20d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/720a1b23c1eda3c78e28126362238a500eaa20d4", "html_url": "https://github.com/rust-lang/rust/commit/720a1b23c1eda3c78e28126362238a500eaa20d4"}, {"sha": "efb4148865f9332c5d7d9c81202be9470fa336eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/efb4148865f9332c5d7d9c81202be9470fa336eb", "html_url": "https://github.com/rust-lang/rust/commit/efb4148865f9332c5d7d9c81202be9470fa336eb"}], "stats": {"total": 31, "additions": 31, "deletions": 0}, "files": [{"sha": "5068ace58b466a5c90c762a22db30ef40be41673", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfd6306d26af1a163aaaa1456b4594244ddd182f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd6306d26af1a163aaaa1456b4594244ddd182f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=dfd6306d26af1a163aaaa1456b4594244ddd182f", "patch": "@@ -42,6 +42,7 @@ pub trait IntegerExt {\n }\n \n impl IntegerExt for Integer {\n+    #[inline]\n     fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>, signed: bool) -> Ty<'tcx> {\n         match (*self, signed) {\n             (I8, false) => tcx.types.u8,\n@@ -149,6 +150,7 @@ pub trait PrimitiveExt {\n }\n \n impl PrimitiveExt for Primitive {\n+    #[inline]\n     fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             Int(i, signed) => i.to_ty(tcx, signed),\n@@ -160,6 +162,7 @@ impl PrimitiveExt for Primitive {\n \n     /// Return an *integer* type matching this primitive.\n     /// Useful in particular when dealing with enum discriminants.\n+    #[inline]\n     fn to_int_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             Int(i, signed) => i.to_ty(tcx, signed),\n@@ -2018,12 +2021,14 @@ pub trait HasParamEnv<'tcx> {\n }\n \n impl<'tcx> HasDataLayout for TyCtxt<'tcx> {\n+    #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.data_layout\n     }\n }\n \n impl<'tcx> HasTyCtxt<'tcx> for TyCtxt<'tcx> {\n+    #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         *self\n     }\n@@ -2055,6 +2060,7 @@ impl<'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode, and will normalize the input type.\n+    #[inline]\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         self.tcx.layout_of(self.param_env.and(ty))\n     }\n@@ -2066,6 +2072,7 @@ impl LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx>> {\n \n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode, and will normalize the input type.\n+    #[inline]\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n         self.tcx.layout_of(self.param_env.and(ty))\n     }\n@@ -2416,6 +2423,7 @@ where\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for LayoutError<'tcx> {\n+    #[inline]\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         use crate::ty::layout::LayoutError::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n@@ -2606,6 +2614,7 @@ where\n /// compiled with `-Cpanic=unwind` and referenced from another crate compiled\n /// with `-Cpanic=abort` will look like they can't unwind when in fact they\n /// might (from a foreign exception or similar).\n+#[inline]\n pub fn fn_can_unwind(\n     tcx: TyCtxt<'tcx>,\n     codegen_fn_attr_flags: CodegenFnAttrFlags,\n@@ -2681,6 +2690,7 @@ pub fn fn_can_unwind(\n     }\n }\n \n+#[inline]\n pub fn conv_from_spec_abi(tcx: TyCtxt<'_>, abi: SpecAbi) -> Conv {\n     use rustc_target::spec::abi::Abi::*;\n     match tcx.sess.target.adjust_abi(abi) {"}, {"sha": "2820a486dfd4be89dbe1a175142771cc403d021c", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dfd6306d26af1a163aaaa1456b4594244ddd182f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd6306d26af1a163aaaa1456b4594244ddd182f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=dfd6306d26af1a163aaaa1456b4594244ddd182f", "patch": "@@ -194,6 +194,7 @@ impl TargetDataLayout {\n     /// to represent object size in bits. It would need to be 1 << 61 to account for this, but is\n     /// currently conservatively bounded to 1 << 47 as that is enough to cover the current usable\n     /// address space on 64-bit ARMv8 and x86_64.\n+    #[inline]\n     pub fn obj_size_bound(&self) -> u64 {\n         match self.pointer_size.bits() {\n             16 => 1 << 15,\n@@ -203,6 +204,7 @@ impl TargetDataLayout {\n         }\n     }\n \n+    #[inline]\n     pub fn ptr_sized_integer(&self) -> Integer {\n         match self.pointer_size.bits() {\n             16 => I16,\n@@ -212,6 +214,7 @@ impl TargetDataLayout {\n         }\n     }\n \n+    #[inline]\n     pub fn vector_align(&self, vec_size: Size) -> AbiAndPrefAlign {\n         for &(size, align) in &self.vector_align {\n             if size == vec_size {\n@@ -562,14 +565,17 @@ pub struct AbiAndPrefAlign {\n }\n \n impl AbiAndPrefAlign {\n+    #[inline]\n     pub fn new(align: Align) -> AbiAndPrefAlign {\n         AbiAndPrefAlign { abi: align, pref: align }\n     }\n \n+    #[inline]\n     pub fn min(self, other: AbiAndPrefAlign) -> AbiAndPrefAlign {\n         AbiAndPrefAlign { abi: self.abi.min(other.abi), pref: self.pref.min(other.pref) }\n     }\n \n+    #[inline]\n     pub fn max(self, other: AbiAndPrefAlign) -> AbiAndPrefAlign {\n         AbiAndPrefAlign { abi: self.abi.max(other.abi), pref: self.pref.max(other.pref) }\n     }\n@@ -586,6 +592,7 @@ pub enum Integer {\n }\n \n impl Integer {\n+    #[inline]\n     pub fn size(self) -> Size {\n         match self {\n             I8 => Size::from_bytes(1),\n@@ -609,6 +616,7 @@ impl Integer {\n     }\n \n     /// Finds the smallest Integer type which can represent the signed value.\n+    #[inline]\n     pub fn fit_signed(x: i128) -> Integer {\n         match x {\n             -0x0000_0000_0000_0080..=0x0000_0000_0000_007f => I8,\n@@ -620,6 +628,7 @@ impl Integer {\n     }\n \n     /// Finds the smallest Integer type which can represent the unsigned value.\n+    #[inline]\n     pub fn fit_unsigned(x: u128) -> Integer {\n         match x {\n             0..=0x0000_0000_0000_00ff => I8,\n@@ -655,6 +664,9 @@ impl Integer {\n         I8\n     }\n \n+    // FIXME(eddyb) consolidate this and other methods that find the appropriate\n+    // `Integer` given some requirements.\n+    #[inline]\n     fn from_size(size: Size) -> Result<Self, String> {\n         match size.bits() {\n             8 => Ok(Integer::I8),\n@@ -706,10 +718,14 @@ impl Primitive {\n         }\n     }\n \n+    // FIXME(eddyb) remove, it's trivial thanks to `matches!`.\n+    #[inline]\n     pub fn is_float(self) -> bool {\n         matches!(self, F32 | F64)\n     }\n \n+    // FIXME(eddyb) remove, it's completely unused.\n+    #[inline]\n     pub fn is_int(self) -> bool {\n         matches!(self, Int(..))\n     }\n@@ -786,6 +802,7 @@ pub struct Scalar {\n }\n \n impl Scalar {\n+    #[inline]\n     pub fn is_bool(&self) -> bool {\n         matches!(self.value, Int(I8, false))\n             && matches!(self.valid_range, WrappingRange { start: 0, end: 1 })\n@@ -852,6 +869,7 @@ pub enum FieldsShape {\n }\n \n impl FieldsShape {\n+    #[inline]\n     pub fn count(&self) -> usize {\n         match *self {\n             FieldsShape::Primitive => 0,\n@@ -861,6 +879,7 @@ impl FieldsShape {\n         }\n     }\n \n+    #[inline]\n     pub fn offset(&self, i: usize) -> Size {\n         match *self {\n             FieldsShape::Primitive => {\n@@ -884,6 +903,7 @@ impl FieldsShape {\n         }\n     }\n \n+    #[inline]\n     pub fn memory_index(&self, i: usize) -> usize {\n         match *self {\n             FieldsShape::Primitive => {\n@@ -967,6 +987,7 @@ impl Abi {\n     }\n \n     /// Returns `true` if this is a single signed integer scalar\n+    #[inline]\n     pub fn is_signed(&self) -> bool {\n         match *self {\n             Abi::Scalar(ref scal) => match scal.value {"}]}