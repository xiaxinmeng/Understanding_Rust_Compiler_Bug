{"sha": "2480c9eac15608591f58730aed27caac9c30b4c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ODBjOWVhYzE1NjA4NTkxZjU4NzMwYWVkMjdjYWFjOWMzMGI0YzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-17T09:17:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-17T09:17:18Z"}, "message": "Auto merge of #68305 - Dylan-DPC:rollup-aoohsz8, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #67956 (Detail transitive containment in E0588 diagnostic)\n - #68153 (resolve: Point at the private item definitions in privacy errors)\n - #68195 (Account for common `impl Trait`/`dyn Trait` return type errors)\n - #68288 (Fix some of the rustfmt fallout in Miri)\n - #68292 (don't clone types that are copy)\n - #68301 (Don't propagate __RUST_TEST_INVOKE to subprocess)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "a1b4e27967406769ec10400cde0384abf4cfd061", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1b4e27967406769ec10400cde0384abf4cfd061"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2480c9eac15608591f58730aed27caac9c30b4c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2480c9eac15608591f58730aed27caac9c30b4c2", "html_url": "https://github.com/rust-lang/rust/commit/2480c9eac15608591f58730aed27caac9c30b4c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2480c9eac15608591f58730aed27caac9c30b4c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91ff7c689d4a2beb45bdd45f14cb65424a46ad9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/91ff7c689d4a2beb45bdd45f14cb65424a46ad9c", "html_url": "https://github.com/rust-lang/rust/commit/91ff7c689d4a2beb45bdd45f14cb65424a46ad9c"}, {"sha": "98347cdbfffe9cf9328af24592ced2f240340255", "url": "https://api.github.com/repos/rust-lang/rust/commits/98347cdbfffe9cf9328af24592ced2f240340255", "html_url": "https://github.com/rust-lang/rust/commit/98347cdbfffe9cf9328af24592ced2f240340255"}], "stats": {"total": 8964, "additions": 5522, "deletions": 3442}, "files": [{"sha": "febf4f21a67555a2b48a85cb41d79254e1fdd9b6", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2008,7 +2008,7 @@ impl<'tcx> ObligationCause<'tcx> {\n                 TypeError::IntrinsicCast => {\n                     Error0308(\"cannot coerce intrinsics to function pointers\")\n                 }\n-                TypeError::ObjectUnsafeCoercion(did) => Error0038(did.clone()),\n+                TypeError::ObjectUnsafeCoercion(did) => Error0038(*did),\n                 _ => Error0308(\"mismatched types\"),\n             },\n         }"}, {"sha": "42d896af8014d0720387540838d9791cdfaaa5a0", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -33,7 +33,7 @@ impl ErrorHandled {\n             ErrorHandled::Reported => {}\n             ErrorHandled::TooGeneric => bug!(\n                 \"MIR interpretation failed without reporting an error \\\n-                                              even though it was fully monomorphized\"\n+                 even though it was fully monomorphized\"\n             ),\n         }\n     }"}, {"sha": "e554b280ef78cbc8723d559869c455a66a847fb4", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -403,8 +403,8 @@ impl<'tcx> AllocMap<'tcx> {\n         let next = self.next_id;\n         self.next_id.0 = self.next_id.0.checked_add(1).expect(\n             \"You overflowed a u64 by incrementing by 1... \\\n-                     You've just earned yourself a free drink if we ever meet. \\\n-                     Seriously, how did you do that?!\",\n+             You've just earned yourself a free drink if we ever meet. \\\n+             Seriously, how did you do that?!\",\n         );\n         next\n     }"}, {"sha": "7f151af7abe502faf39c976fa86e289146864e73", "filename": "src/librustc/traits/error_reporting.rs", "status": "removed", "additions": 0, "deletions": 2991, "changes": 2991, "blob_url": "https://github.com/rust-lang/rust/blob/91ff7c689d4a2beb45bdd45f14cb65424a46ad9c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ff7c689d4a2beb45bdd45f14cb65424a46ad9c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=91ff7c689d4a2beb45bdd45f14cb65424a46ad9c"}, {"sha": "db3173989ac605e114159989fa5665110fc972c2", "filename": "src/librustc/traits/error_reporting/mod.rs", "status": "added", "additions": 1412, "deletions": 0, "changes": 1412, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -0,0 +1,1412 @@\n+pub mod on_unimplemented;\n+pub mod suggestions;\n+\n+use super::{\n+    ConstEvalFailure, EvaluationResult, FulfillmentError, FulfillmentErrorCode,\n+    MismatchedProjectionTypes, ObjectSafetyViolation, Obligation, ObligationCause,\n+    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote,\n+    OutputTypeParameterMismatch, Overflow, PredicateObligation, SelectionContext, SelectionError,\n+    TraitNotObjectSafe,\n+};\n+\n+use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n+use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::infer::{self, InferCtxt};\n+use crate::mir::interpret::ErrorHandled;\n+use crate::session::DiagnosticMessageId;\n+use crate::traits::object_safety_violations;\n+use crate::ty::error::ExpectedFound;\n+use crate::ty::fast_reject;\n+use crate::ty::fold::TypeFolder;\n+use crate::ty::SubtypePredicate;\n+use crate::ty::{self, AdtKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_span::source_map::SourceMap;\n+use rustc_span::{ExpnKind, Span, DUMMY_SP};\n+use std::fmt;\n+use syntax::ast;\n+\n+use rustc_error_codes::*;\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    pub fn report_fulfillment_errors(\n+        &self,\n+        errors: &[FulfillmentError<'tcx>],\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n+        #[derive(Debug)]\n+        struct ErrorDescriptor<'tcx> {\n+            predicate: ty::Predicate<'tcx>,\n+            index: Option<usize>, // None if this is an old error\n+        }\n+\n+        let mut error_map: FxHashMap<_, Vec<_>> = self\n+            .reported_trait_errors\n+            .borrow()\n+            .iter()\n+            .map(|(&span, predicates)| {\n+                (\n+                    span,\n+                    predicates\n+                        .iter()\n+                        .map(|predicate| ErrorDescriptor {\n+                            predicate: predicate.clone(),\n+                            index: None,\n+                        })\n+                        .collect(),\n+                )\n+            })\n+            .collect();\n+\n+        for (index, error) in errors.iter().enumerate() {\n+            // We want to ignore desugarings here: spans are equivalent even\n+            // if one is the result of a desugaring and the other is not.\n+            let mut span = error.obligation.cause.span;\n+            let expn_data = span.ctxt().outer_expn_data();\n+            if let ExpnKind::Desugaring(_) = expn_data.kind {\n+                span = expn_data.call_site;\n+            }\n+\n+            error_map.entry(span).or_default().push(ErrorDescriptor {\n+                predicate: error.obligation.predicate.clone(),\n+                index: Some(index),\n+            });\n+\n+            self.reported_trait_errors\n+                .borrow_mut()\n+                .entry(span)\n+                .or_default()\n+                .push(error.obligation.predicate.clone());\n+        }\n+\n+        // We do this in 2 passes because we want to display errors in order, though\n+        // maybe it *is* better to sort errors by span or something.\n+        let mut is_suppressed = vec![false; errors.len()];\n+        for (_, error_set) in error_map.iter() {\n+            // We want to suppress \"duplicate\" errors with the same span.\n+            for error in error_set {\n+                if let Some(index) = error.index {\n+                    // Suppress errors that are either:\n+                    // 1) strictly implied by another error.\n+                    // 2) implied by an error with a smaller index.\n+                    for error2 in error_set {\n+                        if error2.index.map_or(false, |index2| is_suppressed[index2]) {\n+                            // Avoid errors being suppressed by already-suppressed\n+                            // errors, to prevent all errors from being suppressed\n+                            // at once.\n+                            continue;\n+                        }\n+\n+                        if self.error_implies(&error2.predicate, &error.predicate)\n+                            && !(error2.index >= error.index\n+                                && self.error_implies(&error.predicate, &error2.predicate))\n+                        {\n+                            info!(\"skipping {:?} (implied by {:?})\", error, error2);\n+                            is_suppressed[index] = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (error, suppressed) in errors.iter().zip(is_suppressed) {\n+            if !suppressed {\n+                self.report_fulfillment_error(error, body_id, fallback_has_occurred);\n+            }\n+        }\n+    }\n+\n+    // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n+    // `error` occurring implies that `cond` occurs.\n+    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool {\n+        if cond == error {\n+            return true;\n+        }\n+\n+        let (cond, error) = match (cond, error) {\n+            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error)) => (cond, error),\n+            _ => {\n+                // FIXME: make this work in other cases too.\n+                return false;\n+            }\n+        };\n+\n+        for implication in super::elaborate_predicates(self.tcx, vec![cond.clone()]) {\n+            if let ty::Predicate::Trait(implication) = implication {\n+                let error = error.to_poly_trait_ref();\n+                let implication = implication.to_poly_trait_ref();\n+                // FIXME: I'm just not taking associated types at all here.\n+                // Eventually I'll need to implement param-env-aware\n+                // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n+                let param_env = ty::ParamEnv::empty();\n+                if self.can_sub(param_env, error, implication).is_ok() {\n+                    debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    fn report_fulfillment_error(\n+        &self,\n+        error: &FulfillmentError<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n+        debug!(\"report_fulfillment_error({:?})\", error);\n+        match error.code {\n+            FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n+                self.report_selection_error(\n+                    &error.obligation,\n+                    selection_error,\n+                    fallback_has_occurred,\n+                    error.points_at_arg_span,\n+                );\n+            }\n+            FulfillmentErrorCode::CodeProjectionError(ref e) => {\n+                self.report_projection_error(&error.obligation, e);\n+            }\n+            FulfillmentErrorCode::CodeAmbiguity => {\n+                self.maybe_report_ambiguity(&error.obligation, body_id);\n+            }\n+            FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n+                self.report_mismatched_types(\n+                    &error.obligation.cause,\n+                    expected_found.expected,\n+                    expected_found.found,\n+                    err.clone(),\n+                )\n+                .emit();\n+            }\n+        }\n+    }\n+\n+    fn report_projection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &MismatchedProjectionTypes<'tcx>,\n+    ) {\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+\n+        if predicate.references_error() {\n+            return;\n+        }\n+\n+        self.probe(|_| {\n+            let err_buf;\n+            let mut err = &error.err;\n+            let mut values = None;\n+\n+            // try to find the mismatched types to report the error with.\n+            //\n+            // this can fail if the problem was higher-ranked, in which\n+            // cause I have no idea for a good error message.\n+            if let ty::Predicate::Projection(ref data) = predicate {\n+                let mut selcx = SelectionContext::new(self);\n+                let (data, _) = self.replace_bound_vars_with_fresh_vars(\n+                    obligation.cause.span,\n+                    infer::LateBoundRegionConversionTime::HigherRankedType,\n+                    data,\n+                );\n+                let mut obligations = vec![];\n+                let normalized_ty = super::normalize_projection_type(\n+                    &mut selcx,\n+                    obligation.param_env,\n+                    data.projection_ty,\n+                    obligation.cause.clone(),\n+                    0,\n+                    &mut obligations,\n+                );\n+\n+                debug!(\n+                    \"report_projection_error obligation.cause={:?} obligation.param_env={:?}\",\n+                    obligation.cause, obligation.param_env\n+                );\n+\n+                debug!(\n+                    \"report_projection_error normalized_ty={:?} data.ty={:?}\",\n+                    normalized_ty, data.ty\n+                );\n+\n+                let is_normalized_ty_expected = match &obligation.cause.code {\n+                    ObligationCauseCode::ItemObligation(_)\n+                    | ObligationCauseCode::BindingObligation(_, _)\n+                    | ObligationCauseCode::ObjectCastObligation(_) => false,\n+                    _ => true,\n+                };\n+\n+                if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n+                    is_normalized_ty_expected,\n+                    normalized_ty,\n+                    data.ty,\n+                ) {\n+                    values = Some(infer::ValuePairs::Types(ExpectedFound::new(\n+                        is_normalized_ty_expected,\n+                        normalized_ty,\n+                        data.ty,\n+                    )));\n+\n+                    err_buf = error;\n+                    err = &err_buf;\n+                }\n+            }\n+\n+            let msg = format!(\"type mismatch resolving `{}`\", predicate);\n+            let error_id = (DiagnosticMessageId::ErrorId(271), Some(obligation.cause.span), msg);\n+            let fresh = self.tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n+            if fresh {\n+                let mut diag = struct_span_err!(\n+                    self.tcx.sess,\n+                    obligation.cause.span,\n+                    E0271,\n+                    \"type mismatch resolving `{}`\",\n+                    predicate\n+                );\n+                self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n+                self.note_obligation_cause(&mut diag, obligation);\n+                diag.emit();\n+            }\n+        });\n+    }\n+\n+    fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+        /// returns the fuzzy category of a given type, or None\n+        /// if the type can be equated to any type.\n+        fn type_category(t: Ty<'_>) -> Option<u32> {\n+            match t.kind {\n+                ty::Bool => Some(0),\n+                ty::Char => Some(1),\n+                ty::Str => Some(2),\n+                ty::Int(..) | ty::Uint(..) | ty::Infer(ty::IntVar(..)) => Some(3),\n+                ty::Float(..) | ty::Infer(ty::FloatVar(..)) => Some(4),\n+                ty::Ref(..) | ty::RawPtr(..) => Some(5),\n+                ty::Array(..) | ty::Slice(..) => Some(6),\n+                ty::FnDef(..) | ty::FnPtr(..) => Some(7),\n+                ty::Dynamic(..) => Some(8),\n+                ty::Closure(..) => Some(9),\n+                ty::Tuple(..) => Some(10),\n+                ty::Projection(..) => Some(11),\n+                ty::Param(..) => Some(12),\n+                ty::Opaque(..) => Some(13),\n+                ty::Never => Some(14),\n+                ty::Adt(adt, ..) => match adt.adt_kind() {\n+                    AdtKind::Struct => Some(15),\n+                    AdtKind::Union => Some(16),\n+                    AdtKind::Enum => Some(17),\n+                },\n+                ty::Generator(..) => Some(18),\n+                ty::Foreign(..) => Some(19),\n+                ty::GeneratorWitness(..) => Some(20),\n+                ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => None,\n+                ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n+            }\n+        }\n+\n+        match (type_category(a), type_category(b)) {\n+            (Some(cat_a), Some(cat_b)) => match (&a.kind, &b.kind) {\n+                (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => def_a == def_b,\n+                _ => cat_a == cat_b,\n+            },\n+            // infer and error can be equated to all types\n+            _ => true,\n+        }\n+    }\n+\n+    fn describe_generator(&self, body_id: hir::BodyId) -> Option<&'static str> {\n+        self.tcx.hir().body(body_id).generator_kind.map(|gen_kind| match gen_kind {\n+            hir::GeneratorKind::Gen => \"a generator\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) => \"an async block\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn) => \"an async function\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure) => \"an async closure\",\n+        })\n+    }\n+\n+    fn find_similar_impl_candidates(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Vec<ty::TraitRef<'tcx>> {\n+        let simp = fast_reject::simplify_type(self.tcx, trait_ref.skip_binder().self_ty(), true);\n+        let all_impls = self.tcx.all_impls(trait_ref.def_id());\n+\n+        match simp {\n+            Some(simp) => all_impls\n+                .iter()\n+                .filter_map(|&def_id| {\n+                    let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                    let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n+                    if let Some(imp_simp) = imp_simp {\n+                        if simp != imp_simp {\n+                            return None;\n+                        }\n+                    }\n+\n+                    Some(imp)\n+                })\n+                .collect(),\n+            None => {\n+                all_impls.iter().map(|&def_id| self.tcx.impl_trait_ref(def_id).unwrap()).collect()\n+            }\n+        }\n+    }\n+\n+    fn report_similar_impl_candidates(\n+        &self,\n+        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        if impl_candidates.is_empty() {\n+            return;\n+        }\n+\n+        let len = impl_candidates.len();\n+        let end = if impl_candidates.len() <= 5 { impl_candidates.len() } else { 4 };\n+\n+        let normalize = |candidate| {\n+            self.tcx.infer_ctxt().enter(|ref infcx| {\n+                let normalized = infcx\n+                    .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+                    .normalize(candidate)\n+                    .ok();\n+                match normalized {\n+                    Some(normalized) => format!(\"\\n  {:?}\", normalized.value),\n+                    None => format!(\"\\n  {:?}\", candidate),\n+                }\n+            })\n+        };\n+\n+        // Sort impl candidates so that ordering is consistent for UI tests.\n+        let mut normalized_impl_candidates =\n+            impl_candidates.iter().map(normalize).collect::<Vec<String>>();\n+\n+        // Sort before taking the `..end` range,\n+        // because the ordering of `impl_candidates` may not be deterministic:\n+        // https://github.com/rust-lang/rust/pull/57475#issuecomment-455519507\n+        normalized_impl_candidates.sort();\n+\n+        err.help(&format!(\n+            \"the following implementations were found:{}{}\",\n+            normalized_impl_candidates[..end].join(\"\"),\n+            if len > 5 { format!(\"\\nand {} others\", len - 4) } else { String::new() }\n+        ));\n+    }\n+\n+    /// Reports that an overflow has occurred and halts compilation. We\n+    /// halt compilation unconditionally because it is important that\n+    /// overflows never be masked -- they basically represent computations\n+    /// whose result could not be truly determined and thus we can't say\n+    /// if the program type checks or not -- and they are unusual\n+    /// occurrences in any case.\n+    pub fn report_overflow_error<T>(\n+        &self,\n+        obligation: &Obligation<'tcx, T>,\n+        suggest_increasing_limit: bool,\n+    ) -> !\n+    where\n+        T: fmt::Display + TypeFoldable<'tcx>,\n+    {\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            obligation.cause.span,\n+            E0275,\n+            \"overflow evaluating the requirement `{}`\",\n+            predicate\n+        );\n+\n+        if suggest_increasing_limit {\n+            self.suggest_new_overflow_limit(&mut err);\n+        }\n+\n+        self.note_obligation_cause_code(\n+            &mut err,\n+            &obligation.predicate,\n+            &obligation.cause.code,\n+            &mut vec![],\n+        );\n+\n+        err.emit();\n+        self.tcx.sess.abort_if_errors();\n+        bug!();\n+    }\n+\n+    /// Reports that a cycle was detected which led to overflow and halts\n+    /// compilation. This is equivalent to `report_overflow_error` except\n+    /// that we can give a more helpful error message (and, in particular,\n+    /// we do not suggest increasing the overflow limit, which is not\n+    /// going to help).\n+    pub fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n+        let cycle = self.resolve_vars_if_possible(&cycle.to_owned());\n+        assert!(cycle.len() > 0);\n+\n+        debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n+\n+        self.report_overflow_error(&cycle[0], false);\n+    }\n+\n+    pub fn report_extra_impl_obligation(\n+        &self,\n+        error_span: Span,\n+        item_name: ast::Name,\n+        _impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+        requirement: &dyn fmt::Display,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        let msg = \"impl has stricter requirements than trait\";\n+        let sp = self.tcx.sess.source_map().def_span(error_span);\n+\n+        let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n+\n+        if let Some(trait_item_span) = self.tcx.hir().span_if_local(trait_item_def_id) {\n+            let span = self.tcx.sess.source_map().def_span(trait_item_span);\n+            err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n+        }\n+\n+        err.span_label(sp, format!(\"impl has extra requirement {}\", requirement));\n+\n+        err\n+    }\n+\n+    /// Gets the parent trait chain start\n+    fn get_parent_trait_ref(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+    ) -> Option<(String, Option<Span>)> {\n+        match code {\n+            &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                match self.get_parent_trait_ref(&data.parent_code) {\n+                    Some(t) => Some(t),\n+                    None => {\n+                        let ty = parent_trait_ref.skip_binder().self_ty();\n+                        let span =\n+                            TyCategory::from_ty(ty).map(|(_, def_id)| self.tcx.def_span(def_id));\n+                        Some((ty.to_string(), span))\n+                    }\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn report_selection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &SelectionError<'tcx>,\n+        fallback_has_occurred: bool,\n+        points_at_arg: bool,\n+    ) {\n+        let tcx = self.tcx;\n+        let span = obligation.cause.span;\n+\n+        let mut err = match *error {\n+            SelectionError::Unimplemented => {\n+                if let ObligationCauseCode::CompareImplMethodObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                }\n+                | ObligationCauseCode::CompareImplTypeObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                } = obligation.cause.code\n+                {\n+                    self.report_extra_impl_obligation(\n+                        span,\n+                        item_name,\n+                        impl_item_def_id,\n+                        trait_item_def_id,\n+                        &format!(\"`{}`\", obligation.predicate),\n+                    )\n+                    .emit();\n+                    return;\n+                }\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(ref trait_predicate) => {\n+                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n+\n+                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n+                            return;\n+                        }\n+                        let trait_ref = trait_predicate.to_poly_trait_ref();\n+                        let (post_message, pre_message, type_def) = self\n+                            .get_parent_trait_ref(&obligation.cause.code)\n+                            .map(|(t, s)| {\n+                                (\n+                                    format!(\" in `{}`\", t),\n+                                    format!(\"within `{}`, \", t),\n+                                    s.map(|s| (format!(\"within this `{}`\", t), s)),\n+                                )\n+                            })\n+                            .unwrap_or_default();\n+\n+                        let OnUnimplementedNote { message, label, note, enclosing_scope } =\n+                            self.on_unimplemented_note(trait_ref, obligation);\n+                        let have_alt_message = message.is_some() || label.is_some();\n+                        let is_try = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(span)\n+                            .map(|s| &s == \"?\")\n+                            .unwrap_or(false);\n+                        let is_from = format!(\"{}\", trait_ref.print_only_trait_path())\n+                            .starts_with(\"std::convert::From<\");\n+                        let (message, note) = if is_try && is_from {\n+                            (\n+                                Some(format!(\n+                                    \"`?` couldn't convert the error to `{}`\",\n+                                    trait_ref.self_ty(),\n+                                )),\n+                                Some(\n+                                    \"the question mark operation (`?`) implicitly performs a \\\n+                                     conversion on the error value using the `From` trait\"\n+                                        .to_owned(),\n+                                ),\n+                            )\n+                        } else {\n+                            (message, note)\n+                        };\n+\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0277,\n+                            \"{}\",\n+                            message.unwrap_or_else(|| format!(\n+                                \"the trait bound `{}` is not satisfied{}\",\n+                                trait_ref.to_predicate(),\n+                                post_message,\n+                            ))\n+                        );\n+\n+                        let explanation =\n+                            if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n+                                \"consider using `()`, or a `Result`\".to_owned()\n+                            } else {\n+                                format!(\n+                                    \"{}the trait `{}` is not implemented for `{}`\",\n+                                    pre_message,\n+                                    trait_ref.print_only_trait_path(),\n+                                    trait_ref.self_ty(),\n+                                )\n+                            };\n+\n+                        if self.suggest_add_reference_to_arg(\n+                            &obligation,\n+                            &mut err,\n+                            &trait_ref,\n+                            points_at_arg,\n+                            have_alt_message,\n+                        ) {\n+                            self.note_obligation_cause(&mut err, obligation);\n+                            err.emit();\n+                            return;\n+                        }\n+                        if let Some(ref s) = label {\n+                            // If it has a custom `#[rustc_on_unimplemented]`\n+                            // error message, let's display it as the label!\n+                            err.span_label(span, s.as_str());\n+                            err.help(&explanation);\n+                        } else {\n+                            err.span_label(span, explanation);\n+                        }\n+                        if let Some((msg, span)) = type_def {\n+                            err.span_label(span, &msg);\n+                        }\n+                        if let Some(ref s) = note {\n+                            // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n+                            err.note(s.as_str());\n+                        }\n+                        if let Some(ref s) = enclosing_scope {\n+                            let enclosing_scope_span = tcx.def_span(\n+                                tcx.hir()\n+                                    .opt_local_def_id(obligation.cause.body_id)\n+                                    .unwrap_or_else(|| {\n+                                        tcx.hir().body_owner_def_id(hir::BodyId {\n+                                            hir_id: obligation.cause.body_id,\n+                                        })\n+                                    }),\n+                            );\n+\n+                            err.span_label(enclosing_scope_span, s.as_str());\n+                        }\n+\n+                        self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n+                        self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n+                        self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n+                        self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n+                        self.note_version_mismatch(&mut err, &trait_ref);\n+                        if self.suggest_impl_trait(&mut err, span, &obligation, &trait_ref) {\n+                            err.emit();\n+                            return;\n+                        }\n+\n+                        // Try to report a help message\n+                        if !trait_ref.has_infer_types()\n+                            && self.predicate_can_apply(obligation.param_env, trait_ref)\n+                        {\n+                            // If a where-clause may be useful, remind the\n+                            // user that they can add it.\n+                            //\n+                            // don't display an on-unimplemented note, as\n+                            // these notes will often be of the form\n+                            //     \"the type `T` can't be frobnicated\"\n+                            // which is somewhat confusing.\n+                            self.suggest_restricting_param_bound(\n+                                &mut err,\n+                                &trait_ref,\n+                                obligation.cause.body_id,\n+                            );\n+                        } else {\n+                            if !have_alt_message {\n+                                // Can't show anything else useful, try to find similar impls.\n+                                let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n+                                self.report_similar_impl_candidates(impl_candidates, &mut err);\n+                            }\n+                            self.suggest_change_mut(\n+                                &obligation,\n+                                &mut err,\n+                                &trait_ref,\n+                                points_at_arg,\n+                            );\n+                        }\n+\n+                        // If this error is due to `!: Trait` not implemented but `(): Trait` is\n+                        // implemented, and fallback has occurred, then it could be due to a\n+                        // variable that used to fallback to `()` now falling back to `!`. Issue a\n+                        // note informing about the change in behaviour.\n+                        if trait_predicate.skip_binder().self_ty().is_never()\n+                            && fallback_has_occurred\n+                        {\n+                            let predicate = trait_predicate.map_bound(|mut trait_pred| {\n+                                trait_pred.trait_ref.substs = self.tcx.mk_substs_trait(\n+                                    self.tcx.mk_unit(),\n+                                    &trait_pred.trait_ref.substs[1..],\n+                                );\n+                                trait_pred\n+                            });\n+                            let unit_obligation = Obligation {\n+                                predicate: ty::Predicate::Trait(predicate),\n+                                ..obligation.clone()\n+                            };\n+                            if self.predicate_may_hold(&unit_obligation) {\n+                                err.note(\n+                                    \"the trait is implemented for `()`. \\\n+                                         Possibly this error has been caused by changes to \\\n+                                         Rust's type-inference algorithm \\\n+                                         (see: https://github.com/rust-lang/rust/issues/48950 \\\n+                                         for more info). Consider whether you meant to use the \\\n+                                         type `()` here instead.\",\n+                                );\n+                            }\n+                        }\n+\n+                        err\n+                    }\n+\n+                    ty::Predicate::Subtype(ref predicate) => {\n+                        // Errors for Subtype predicates show up as\n+                        // `FulfillmentErrorCode::CodeSubtypeError`,\n+                        // not selection error.\n+                        span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n+                    }\n+\n+                    ty::Predicate::RegionOutlives(ref predicate) => {\n+                        let predicate = self.resolve_vars_if_possible(predicate);\n+                        let err = self\n+                            .region_outlives_predicate(&obligation.cause, &predicate)\n+                            .err()\n+                            .unwrap();\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0279,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate,\n+                            err,\n+                        )\n+                    }\n+\n+                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0280,\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate\n+                        )\n+                    }\n+\n+                    ty::Predicate::ObjectSafe(trait_def_id) => {\n+                        let violations = object_safety_violations(self.tcx, trait_def_id);\n+                        report_object_safety_error(self.tcx, span, trait_def_id, violations)\n+                    }\n+\n+                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                        let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n+                        let closure_span = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n+                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            closure_span,\n+                            E0525,\n+                            \"expected a closure that implements the `{}` trait, \\\n+                             but this closure only implements `{}`\",\n+                            kind,\n+                            found_kind\n+                        );\n+\n+                        err.span_label(\n+                            closure_span,\n+                            format!(\"this closure implements `{}`, not `{}`\", found_kind, kind),\n+                        );\n+                        err.span_label(\n+                            obligation.cause.span,\n+                            format!(\"the requirement to implement `{}` derives from here\", kind),\n+                        );\n+\n+                        // Additional context information explaining why the closure only implements\n+                        // a particular trait.\n+                        if let Some(tables) = self.in_progress_tables {\n+                            let tables = tables.borrow();\n+                            match (found_kind, tables.closure_kind_origins().get(hir_id)) {\n+                                (ty::ClosureKind::FnOnce, Some((span, name))) => {\n+                                    err.span_label(\n+                                        *span,\n+                                        format!(\n+                                            \"closure is `FnOnce` because it moves the \\\n+                                         variable `{}` out of its environment\",\n+                                            name\n+                                        ),\n+                                    );\n+                                }\n+                                (ty::ClosureKind::FnMut, Some((span, name))) => {\n+                                    err.span_label(\n+                                        *span,\n+                                        format!(\n+                                            \"closure is `FnMut` because it mutates the \\\n+                                         variable `{}` here\",\n+                                            name\n+                                        ),\n+                                    );\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+\n+                        err.emit();\n+                        return;\n+                    }\n+\n+                    ty::Predicate::WellFormed(ty) => {\n+                        if !self.tcx.sess.opts.debugging_opts.chalk {\n+                            // WF predicates cannot themselves make\n+                            // errors. They can only block due to\n+                            // ambiguity; otherwise, they always\n+                            // degenerate into other obligations\n+                            // (which may fail).\n+                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        } else {\n+                            // FIXME: we'll need a better message which takes into account\n+                            // which bounds actually failed to hold.\n+                            self.tcx.sess.struct_span_err(\n+                                span,\n+                                &format!(\"the type `{}` is not well-formed (chalk)\", ty),\n+                            )\n+                        }\n+                    }\n+\n+                    ty::Predicate::ConstEvaluatable(..) => {\n+                        // Errors for `ConstEvaluatable` predicates show up as\n+                        // `SelectionError::ConstEvalFailure`,\n+                        // not `Unimplemented`.\n+                        span_bug!(\n+                            span,\n+                            \"const-evaluatable requirement gave wrong error: `{:?}`\",\n+                            obligation\n+                        )\n+                    }\n+                }\n+            }\n+\n+            OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n+                let found_trait_ref = self.resolve_vars_if_possible(&*found_trait_ref);\n+                let expected_trait_ref = self.resolve_vars_if_possible(&*expected_trait_ref);\n+\n+                if expected_trait_ref.self_ty().references_error() {\n+                    return;\n+                }\n+\n+                let found_trait_ty = found_trait_ref.self_ty();\n+\n+                let found_did = match found_trait_ty.kind {\n+                    ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) => Some(did),\n+                    ty::Adt(def, _) => Some(def.did),\n+                    _ => None,\n+                };\n+\n+                let found_span = found_did\n+                    .and_then(|did| self.tcx.hir().span_if_local(did))\n+                    .map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n+\n+                if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n+                    // We check closures twice, with obligations flowing in different directions,\n+                    // but we want to complain about them only once.\n+                    return;\n+                }\n+\n+                self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n+\n+                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind {\n+                    ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n+                    _ => vec![ArgKind::empty()],\n+                };\n+\n+                let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n+                let expected = match expected_ty.kind {\n+                    ty::Tuple(ref tys) => tys\n+                        .iter()\n+                        .map(|t| ArgKind::from_expected_ty(t.expect_ty(), Some(span)))\n+                        .collect(),\n+                    _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n+                };\n+\n+                if found.len() == expected.len() {\n+                    self.report_closure_arg_mismatch(\n+                        span,\n+                        found_span,\n+                        found_trait_ref,\n+                        expected_trait_ref,\n+                    )\n+                } else {\n+                    let (closure_span, found) = found_did\n+                        .and_then(|did| self.tcx.hir().get_if_local(did))\n+                        .map(|node| {\n+                            let (found_span, found) = self.get_fn_like_arguments(node);\n+                            (Some(found_span), found)\n+                        })\n+                        .unwrap_or((found_span, found));\n+\n+                    self.report_arg_count_mismatch(\n+                        span,\n+                        closure_span,\n+                        expected,\n+                        found,\n+                        found_trait_ty.is_closure(),\n+                    )\n+                }\n+            }\n+\n+            TraitNotObjectSafe(did) => {\n+                let violations = object_safety_violations(self.tcx, did);\n+                report_object_safety_error(self.tcx, span, did, violations)\n+            }\n+\n+            // already reported in the query\n+            ConstEvalFailure(err) => {\n+                if let ErrorHandled::TooGeneric = err {\n+                    // Silence this error, as it can be produced during intermediate steps\n+                    // when a constant is not yet able to be evaluated (but will be later).\n+                    return;\n+                }\n+                self.tcx.sess.delay_span_bug(\n+                    span,\n+                    &format!(\"constant in type had an ignored error: {:?}\", err),\n+                );\n+                return;\n+            }\n+\n+            Overflow => {\n+                bug!(\"overflow should be handled before the `report_selection_error` path\");\n+            }\n+        };\n+\n+        self.note_obligation_cause(&mut err, obligation);\n+        self.point_at_returns_when_relevant(&mut err, &obligation);\n+\n+        err.emit();\n+    }\n+\n+    /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n+    /// with the same path as `trait_ref`, a help message about\n+    /// a probable version mismatch is added to `err`\n+    fn note_version_mismatch(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+    ) {\n+        let get_trait_impl = |trait_def_id| {\n+            let mut trait_impl = None;\n+            self.tcx.for_each_relevant_impl(trait_def_id, trait_ref.self_ty(), |impl_def_id| {\n+                if trait_impl.is_none() {\n+                    trait_impl = Some(impl_def_id);\n+                }\n+            });\n+            trait_impl\n+        };\n+        let required_trait_path = self.tcx.def_path_str(trait_ref.def_id());\n+        let all_traits = self.tcx.all_traits(LOCAL_CRATE);\n+        let traits_with_same_path: std::collections::BTreeSet<_> = all_traits\n+            .iter()\n+            .filter(|trait_def_id| **trait_def_id != trait_ref.def_id())\n+            .filter(|trait_def_id| self.tcx.def_path_str(**trait_def_id) == required_trait_path)\n+            .collect();\n+        for trait_with_same_path in traits_with_same_path {\n+            if let Some(impl_def_id) = get_trait_impl(*trait_with_same_path) {\n+                let impl_span = self.tcx.def_span(impl_def_id);\n+                err.span_help(impl_span, \"trait impl with same name found\");\n+                let trait_crate = self.tcx.crate_name(trait_with_same_path.krate);\n+                let crate_msg = format!(\n+                    \"perhaps two different versions of crate `{}` are being used?\",\n+                    trait_crate\n+                );\n+                err.note(&crate_msg);\n+            }\n+        }\n+    }\n+\n+    fn mk_obligation_for_def_id(\n+        &self,\n+        def_id: DefId,\n+        output_ty: Ty<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> PredicateObligation<'tcx> {\n+        let new_trait_ref =\n+            ty::TraitRef { def_id, substs: self.tcx.mk_substs_trait(output_ty, &[]) };\n+        Obligation::new(cause, param_env, new_trait_ref.to_predicate())\n+    }\n+}\n+\n+pub fn recursive_type_with_infinite_size_error(\n+    tcx: TyCtxt<'tcx>,\n+    type_def_id: DefId,\n+) -> DiagnosticBuilder<'tcx> {\n+    assert!(type_def_id.is_local());\n+    let span = tcx.hir().span_if_local(type_def_id).unwrap();\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0072,\n+        \"recursive type `{}` has infinite size\",\n+        tcx.def_path_str(type_def_id)\n+    );\n+    err.span_label(span, \"recursive type has infinite size\");\n+    err.help(&format!(\n+        \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+                           at some point to make `{}` representable\",\n+        tcx.def_path_str(type_def_id)\n+    ));\n+    err\n+}\n+\n+pub fn report_object_safety_error(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    trait_def_id: DefId,\n+    violations: Vec<ObjectSafetyViolation>,\n+) -> DiagnosticBuilder<'tcx> {\n+    let trait_str = tcx.def_path_str(trait_def_id);\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0038,\n+        \"the trait `{}` cannot be made into an object\",\n+        trait_str\n+    );\n+    err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n+\n+    let mut reported_violations = FxHashSet::default();\n+    for violation in violations {\n+        if reported_violations.insert(violation.clone()) {\n+            match violation.span() {\n+                Some(span) => err.span_label(span, violation.error_msg()),\n+                None => err.note(&violation.error_msg()),\n+            };\n+        }\n+    }\n+\n+    if tcx.sess.trait_methods_not_found.borrow().contains(&span) {\n+        // Avoid emitting error caused by non-existing method (#58734)\n+        err.cancel();\n+    }\n+\n+    err\n+}\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    fn maybe_report_ambiguity(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+    ) {\n+        // Unable to successfully determine, probably means\n+        // insufficient type information, but could mean\n+        // ambiguous impls. The latter *ought* to be a\n+        // coherence violation, so we don't report it here.\n+\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let span = obligation.cause.span;\n+\n+        debug!(\n+            \"maybe_report_ambiguity(predicate={:?}, obligation={:?} body_id={:?}, code={:?})\",\n+            predicate, obligation, body_id, obligation.cause.code,\n+        );\n+\n+        // Ambiguity errors are often caused as fallout from earlier\n+        // errors. So just ignore them if this infcx is tainted.\n+        if self.is_tainted_by_errors() {\n+            return;\n+        }\n+\n+        let mut err = match predicate {\n+            ty::Predicate::Trait(ref data) => {\n+                let trait_ref = data.to_poly_trait_ref();\n+                let self_ty = trait_ref.self_ty();\n+                debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n+\n+                if predicate.references_error() {\n+                    return;\n+                }\n+                // Typically, this ambiguity should only happen if\n+                // there are unresolved type inference variables\n+                // (otherwise it would suggest a coherence\n+                // failure). But given #21974 that is not necessarily\n+                // the case -- we can have multiple where clauses that\n+                // are only distinguished by a region, which results\n+                // in an ambiguity even when all types are fully\n+                // known, since we don't dispatch based on region\n+                // relationships.\n+\n+                // This is kind of a hack: it frequently happens that some earlier\n+                // error prevents types from being fully inferred, and then we get\n+                // a bunch of uninteresting errors saying something like \"<generic\n+                // #0> doesn't implement Sized\".  It may even be true that we\n+                // could just skip over all checks where the self-ty is an\n+                // inference variable, but I was afraid that there might be an\n+                // inference variable created, registered as an obligation, and\n+                // then never forced by writeback, and hence by skipping here we'd\n+                // be ignoring the fact that we don't KNOW the type works\n+                // out. Though even that would probably be harmless, given that\n+                // we're only talking about builtin traits, which are known to be\n+                // inhabited. We used to check for `self.tcx.sess.has_errors()` to\n+                // avoid inundating the user with unnecessary errors, but we now\n+                // check upstream for type errors and dont add the obligations to\n+                // begin with in those cases.\n+                if self\n+                    .tcx\n+                    .lang_items()\n+                    .sized_trait()\n+                    .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n+                {\n+                    self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0282).emit();\n+                    return;\n+                }\n+                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0283);\n+                err.note(&format!(\"cannot resolve `{}`\", predicate));\n+                if let ObligationCauseCode::ItemObligation(def_id) = obligation.cause.code {\n+                    self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n+                } else if let (\n+                    Ok(ref snippet),\n+                    ObligationCauseCode::BindingObligation(ref def_id, _),\n+                ) =\n+                    (self.tcx.sess.source_map().span_to_snippet(span), &obligation.cause.code)\n+                {\n+                    let generics = self.tcx.generics_of(*def_id);\n+                    if !generics.params.is_empty() && !snippet.ends_with('>') {\n+                        // FIXME: To avoid spurious suggestions in functions where type arguments\n+                        // where already supplied, we check the snippet to make sure it doesn't\n+                        // end with a turbofish. Ideally we would have access to a `PathSegment`\n+                        // instead. Otherwise we would produce the following output:\n+                        //\n+                        // error[E0283]: type annotations needed\n+                        //   --> $DIR/issue-54954.rs:3:24\n+                        //    |\n+                        // LL | const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n+                        //    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+                        //    |                        |\n+                        //    |                        cannot infer type\n+                        //    |                        help: consider specifying the type argument\n+                        //    |                        in the function call:\n+                        //    |                        `Tt::const_val::<[i8; 123]>::<T>`\n+                        // ...\n+                        // LL |     const fn const_val<T: Sized>() -> usize {\n+                        //    |              --------- - required by this bound in `Tt::const_val`\n+                        //    |\n+                        //    = note: cannot resolve `_: Tt`\n+\n+                        err.span_suggestion(\n+                            span,\n+                            &format!(\n+                                \"consider specifying the type argument{} in the function call\",\n+                                if generics.params.len() > 1 { \"s\" } else { \"\" },\n+                            ),\n+                            format!(\n+                                \"{}::<{}>\",\n+                                snippet,\n+                                generics\n+                                    .params\n+                                    .iter()\n+                                    .map(|p| p.name.to_string())\n+                                    .collect::<Vec<String>>()\n+                                    .join(\", \")\n+                            ),\n+                            Applicability::HasPlaceholders,\n+                        );\n+                    }\n+                }\n+                err\n+            }\n+\n+            ty::Predicate::WellFormed(ty) => {\n+                // Same hacky approach as above to avoid deluging user\n+                // with error messages.\n+                if ty.references_error() || self.tcx.sess.has_errors() {\n+                    return;\n+                }\n+                self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n+            }\n+\n+            ty::Predicate::Subtype(ref data) => {\n+                if data.references_error() || self.tcx.sess.has_errors() {\n+                    // no need to overload user in such cases\n+                    return;\n+                }\n+                let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n+                // both must be type variables, or the other would've been instantiated\n+                assert!(a.is_ty_var() && b.is_ty_var());\n+                self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n+            }\n+            ty::Predicate::Projection(ref data) => {\n+                let trait_ref = data.to_poly_trait_ref(self.tcx);\n+                let self_ty = trait_ref.self_ty();\n+                if predicate.references_error() {\n+                    return;\n+                }\n+                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0284);\n+                err.note(&format!(\"cannot resolve `{}`\", predicate));\n+                err\n+            }\n+\n+            _ => {\n+                if self.tcx.sess.has_errors() {\n+                    return;\n+                }\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0284,\n+                    \"type annotations needed: cannot resolve `{}`\",\n+                    predicate,\n+                );\n+                err.span_label(span, &format!(\"cannot resolve `{}`\", predicate));\n+                err\n+            }\n+        };\n+        self.note_obligation_cause(&mut err, obligation);\n+        err.emit();\n+    }\n+\n+    /// Returns `true` if the trait predicate may apply for *some* assignment\n+    /// to the type parameters.\n+    fn predicate_can_apply(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        pred: ty::PolyTraitRef<'tcx>,\n+    ) -> bool {\n+        struct ParamToVarFolder<'a, 'tcx> {\n+            infcx: &'a InferCtxt<'a, 'tcx>,\n+            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n+        }\n+\n+        impl<'a, 'tcx> TypeFolder<'tcx> for ParamToVarFolder<'a, 'tcx> {\n+            fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+                self.infcx.tcx\n+            }\n+\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+                if let ty::Param(ty::ParamTy { name, .. }) = ty.kind {\n+                    let infcx = self.infcx;\n+                    self.var_map.entry(ty).or_insert_with(|| {\n+                        infcx.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeParameterDefinition(name, None),\n+                            span: DUMMY_SP,\n+                        })\n+                    })\n+                } else {\n+                    ty.super_fold_with(self)\n+                }\n+            }\n+        }\n+\n+        self.probe(|_| {\n+            let mut selcx = SelectionContext::new(self);\n+\n+            let cleaned_pred =\n+                pred.fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() });\n+\n+            let cleaned_pred = super::project::normalize(\n+                &mut selcx,\n+                param_env,\n+                ObligationCause::dummy(),\n+                &cleaned_pred,\n+            )\n+            .value;\n+\n+            let obligation =\n+                Obligation::new(ObligationCause::dummy(), param_env, cleaned_pred.to_predicate());\n+\n+            self.predicate_may_hold(&obligation)\n+        })\n+    }\n+\n+    fn note_obligation_cause(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) {\n+        // First, attempt to add note to this error with an async-await-specific\n+        // message, and fall back to regular note otherwise.\n+        if !self.maybe_note_obligation_cause_for_async_await(err, obligation) {\n+            self.note_obligation_cause_code(\n+                err,\n+                &obligation.predicate,\n+                &obligation.cause.code,\n+                &mut vec![],\n+            );\n+        }\n+    }\n+\n+    fn is_recursive_obligation(\n+        &self,\n+        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        cause_code: &ObligationCauseCode<'tcx>,\n+    ) -> bool {\n+        if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n+            let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+\n+            if obligated_types.iter().any(|ot| ot == &parent_trait_ref.skip_binder().self_ty()) {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+}\n+\n+/// Summarizes information\n+#[derive(Clone)]\n+pub enum ArgKind {\n+    /// An argument of non-tuple type. Parameters are (name, ty)\n+    Arg(String, String),\n+\n+    /// An argument of tuple type. For a \"found\" argument, the span is\n+    /// the locationo in the source of the pattern. For a \"expected\"\n+    /// argument, it will be None. The vector is a list of (name, ty)\n+    /// strings for the components of the tuple.\n+    Tuple(Option<Span>, Vec<(String, String)>),\n+}\n+\n+impl ArgKind {\n+    fn empty() -> ArgKind {\n+        ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n+    }\n+\n+    /// Creates an `ArgKind` from the expected type of an\n+    /// argument. It has no name (`_`) and an optional source span.\n+    pub fn from_expected_ty(t: Ty<'_>, span: Option<Span>) -> ArgKind {\n+        match t.kind {\n+            ty::Tuple(ref tys) => ArgKind::Tuple(\n+                span,\n+                tys.iter().map(|ty| (\"_\".to_owned(), ty.to_string())).collect::<Vec<_>>(),\n+            ),\n+            _ => ArgKind::Arg(\"_\".to_owned(), t.to_string()),\n+        }\n+    }\n+}\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    generics: &hir::Generics<'_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    source_map: &SourceMap,\n+    span: Span,\n+) -> bool {\n+    let restrict_msg = \"consider further restricting this bound\";\n+    if let Some(param) =\n+        generics.params.iter().filter(|p| p.name.ident().as_str() == param_name).next()\n+    {\n+        if param_name.starts_with(\"impl \") {\n+            // `impl Trait` in argument:\n+            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+            err.span_suggestion(\n+                param.span,\n+                restrict_msg,\n+                // `impl CurrentTrait + MissingTrait`\n+                format!(\"{} + {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if generics.where_clause.predicates.is_empty() && param.bounds.is_empty() {\n+            // If there are no bounds whatsoever, suggest adding a constraint\n+            // to the type parameter:\n+            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            err.span_suggestion(\n+                param.span,\n+                \"consider restricting this bound\",\n+                format!(\"{}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if !generics.where_clause.predicates.is_empty() {\n+            // There is a `where` clause, so suggest expanding it:\n+            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+            err.span_suggestion(\n+                generics.where_clause.span().unwrap().shrink_to_hi(),\n+                &format!(\"consider further restricting type parameter `{}`\", param_name),\n+                format!(\", {}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            // If there is no `where` clause lean towards constraining to the\n+            // type parameter:\n+            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+            let sp = param.span.with_hi(span.hi());\n+            let span = source_map.span_through_char(sp, ':');\n+            if sp != param.span && sp != span {\n+                // Only suggest if we have high certainty that the span\n+                // covers the colon in `foo<T: Trait>`.\n+                err.span_suggestion(\n+                    span,\n+                    restrict_msg,\n+                    format!(\"{}: {} + \", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    param.span,\n+                    &format!(\"consider adding a `where {}: {}` bound\", param_name, constraint),\n+                );\n+            }\n+        }\n+        return true;\n+    }\n+    false\n+}"}, {"sha": "9f3fc91548b218e4c5378f0a31ec8fe559396172", "filename": "src/librustc/traits/error_reporting/on_unimplemented.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -0,0 +1,199 @@\n+use super::{\n+    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote, PredicateObligation,\n+};\n+use crate::infer::InferCtxt;\n+use crate::ty::subst::Subst;\n+use crate::ty::{self, GenericParamDefKind};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::sym;\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    fn impl_similar_to(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> Option<DefId> {\n+        let tcx = self.tcx;\n+        let param_env = obligation.param_env;\n+        let trait_ref = tcx.erase_late_bound_regions(&trait_ref);\n+        let trait_self_ty = trait_ref.self_ty();\n+\n+        let mut self_match_impls = vec![];\n+        let mut fuzzy_match_impls = vec![];\n+\n+        self.tcx.for_each_relevant_impl(trait_ref.def_id, trait_self_ty, |def_id| {\n+            let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n+            let impl_trait_ref = tcx.impl_trait_ref(def_id).unwrap().subst(tcx, impl_substs);\n+\n+            let impl_self_ty = impl_trait_ref.self_ty();\n+\n+            if let Ok(..) = self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n+                self_match_impls.push(def_id);\n+\n+                if trait_ref\n+                    .substs\n+                    .types()\n+                    .skip(1)\n+                    .zip(impl_trait_ref.substs.types().skip(1))\n+                    .all(|(u, v)| self.fuzzy_match_tys(u, v))\n+                {\n+                    fuzzy_match_impls.push(def_id);\n+                }\n+            }\n+        });\n+\n+        let impl_def_id = if self_match_impls.len() == 1 {\n+            self_match_impls[0]\n+        } else if fuzzy_match_impls.len() == 1 {\n+            fuzzy_match_impls[0]\n+        } else {\n+            return None;\n+        };\n+\n+        tcx.has_attr(impl_def_id, sym::rustc_on_unimplemented).then_some(impl_def_id)\n+    }\n+\n+    /// Used to set on_unimplemented's `ItemContext`\n+    /// to be the enclosing (async) block/function/closure\n+    fn describe_enclosure(&self, hir_id: hir::HirId) -> Option<&'static str> {\n+        let hir = &self.tcx.hir();\n+        let node = hir.find(hir_id)?;\n+        if let hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. }) = &node {\n+            self.describe_generator(*body_id).or_else(|| {\n+                Some(if let hir::FnHeader { asyncness: hir::IsAsync::Async, .. } = sig.header {\n+                    \"an async function\"\n+                } else {\n+                    \"a function\"\n+                })\n+            })\n+        } else if let hir::Node::Expr(hir::Expr {\n+            kind: hir::ExprKind::Closure(_is_move, _, body_id, _, gen_movability),\n+            ..\n+        }) = &node\n+        {\n+            self.describe_generator(*body_id).or_else(|| {\n+                Some(if gen_movability.is_some() { \"an async closure\" } else { \"a closure\" })\n+            })\n+        } else if let hir::Node::Expr(hir::Expr { .. }) = &node {\n+            let parent_hid = hir.get_parent_node(hir_id);\n+            if parent_hid != hir_id {\n+                return self.describe_enclosure(parent_hid);\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    crate fn on_unimplemented_note(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> OnUnimplementedNote {\n+        let def_id =\n+            self.impl_similar_to(trait_ref, obligation).unwrap_or_else(|| trait_ref.def_id());\n+        let trait_ref = *trait_ref.skip_binder();\n+\n+        let mut flags = vec![];\n+        flags.push((\n+            sym::item_context,\n+            self.describe_enclosure(obligation.cause.body_id).map(|s| s.to_owned()),\n+        ));\n+\n+        match obligation.cause.code {\n+            ObligationCauseCode::BuiltinDerivedObligation(..)\n+            | ObligationCauseCode::ImplDerivedObligation(..) => {}\n+            _ => {\n+                // this is a \"direct\", user-specified, rather than derived,\n+                // obligation.\n+                flags.push((sym::direct, None));\n+            }\n+        }\n+\n+        if let ObligationCauseCode::ItemObligation(item) = obligation.cause.code {\n+            // FIXME: maybe also have some way of handling methods\n+            // from other traits? That would require name resolution,\n+            // which we might want to be some sort of hygienic.\n+            //\n+            // Currently I'm leaving it for what I need for `try`.\n+            if self.tcx.trait_of_item(item) == Some(trait_ref.def_id) {\n+                let method = self.tcx.item_name(item);\n+                flags.push((sym::from_method, None));\n+                flags.push((sym::from_method, Some(method.to_string())));\n+            }\n+        }\n+        if let Some((t, _)) = self.get_parent_trait_ref(&obligation.cause.code) {\n+            flags.push((sym::parent_trait, Some(t)));\n+        }\n+\n+        if let Some(k) = obligation.cause.span.desugaring_kind() {\n+            flags.push((sym::from_desugaring, None));\n+            flags.push((sym::from_desugaring, Some(format!(\"{:?}\", k))));\n+        }\n+        let generics = self.tcx.generics_of(def_id);\n+        let self_ty = trait_ref.self_ty();\n+        // This is also included through the generics list as `Self`,\n+        // but the parser won't allow you to use it\n+        flags.push((sym::_Self, Some(self_ty.to_string())));\n+        if let Some(def) = self_ty.ty_adt_def() {\n+            // We also want to be able to select self's original\n+            // signature with no type arguments resolved\n+            flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n+        }\n+\n+        for param in generics.params.iter() {\n+            let value = match param.kind {\n+                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n+                    trait_ref.substs[param.index as usize].to_string()\n+                }\n+                GenericParamDefKind::Lifetime => continue,\n+            };\n+            let name = param.name;\n+            flags.push((name, Some(value)));\n+        }\n+\n+        if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n+            flags.push((sym::crate_local, None));\n+        }\n+\n+        // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n+        if self_ty.is_integral() {\n+            flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n+        }\n+\n+        if let ty::Array(aty, len) = self_ty.kind {\n+            flags.push((sym::_Self, Some(\"[]\".to_owned())));\n+            flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n+            if let Some(def) = aty.ty_adt_def() {\n+                // We also want to be able to select the array's type's original\n+                // signature with no type arguments resolved\n+                flags.push((\n+                    sym::_Self,\n+                    Some(format!(\"[{}]\", self.tcx.type_of(def.did).to_string())),\n+                ));\n+                let tcx = self.tcx;\n+                if let Some(len) = len.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n+                    flags.push((\n+                        sym::_Self,\n+                        Some(format!(\"[{}; {}]\", self.tcx.type_of(def.did).to_string(), len)),\n+                    ));\n+                } else {\n+                    flags.push((\n+                        sym::_Self,\n+                        Some(format!(\"[{}; _]\", self.tcx.type_of(def.did).to_string())),\n+                    ));\n+                }\n+            }\n+        }\n+\n+        if let Ok(Some(command)) =\n+            OnUnimplementedDirective::of_item(self.tcx, trait_ref.def_id, def_id)\n+        {\n+            command.evaluate(self.tcx, trait_ref, &flags[..])\n+        } else {\n+            OnUnimplementedNote::default()\n+        }\n+    }\n+}"}, {"sha": "bf6891214ace1637dbb5539135984f15e3266e19", "filename": "src/librustc/traits/error_reporting/suggestions.rs", "status": "added", "additions": 1718, "deletions": 0, "changes": 1718, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -0,0 +1,1718 @@\n+use super::{\n+    ArgKind, EvaluationResult, Obligation, ObligationCause, ObligationCauseCode,\n+    PredicateObligation,\n+};\n+\n+use crate::infer::InferCtxt;\n+use crate::traits::object_safety::object_safety_violations;\n+use crate::ty::TypeckTables;\n+use crate::ty::{self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+\n+use rustc_errors::{\n+    error_code, pluralize, struct_span_err, Applicability, DiagnosticBuilder, Style,\n+};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::Node;\n+use rustc_span::source_map::SourceMap;\n+use rustc_span::symbol::{kw, sym};\n+use rustc_span::{MultiSpan, Span, DUMMY_SP};\n+use std::fmt;\n+\n+use rustc_error_codes::*;\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    crate fn suggest_restricting_param_bound(\n+        &self,\n+        mut err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'_>,\n+        body_id: hir::HirId,\n+    ) {\n+        let self_ty = trait_ref.self_ty();\n+        let (param_ty, projection) = match &self_ty.kind {\n+            ty::Param(_) => (true, None),\n+            ty::Projection(projection) => (false, Some(projection)),\n+            _ => return,\n+        };\n+\n+        let suggest_restriction =\n+            |generics: &hir::Generics<'_>, msg, err: &mut DiagnosticBuilder<'_>| {\n+                let span = generics.where_clause.span_for_predicates_or_empty_place();\n+                if !span.from_expansion() && span.desugaring_kind().is_none() {\n+                    err.span_suggestion(\n+                        generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi(),\n+                        &format!(\"consider further restricting {}\", msg),\n+                        format!(\n+                            \"{} {} \",\n+                            if !generics.where_clause.predicates.is_empty() {\n+                                \",\"\n+                            } else {\n+                                \" where\"\n+                            },\n+                            trait_ref.to_predicate(),\n+                        ),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            };\n+\n+        // FIXME: Add check for trait bound that is already present, particularly `?Sized` so we\n+        //        don't suggest `T: Sized + ?Sized`.\n+        let mut hir_id = body_id;\n+        while let Some(node) = self.tcx.hir().find(hir_id) {\n+            match node {\n+                hir::Node::TraitItem(hir::TraitItem {\n+                    generics,\n+                    kind: hir::TraitItemKind::Method(..),\n+                    ..\n+                }) if param_ty && self_ty == self.tcx.types.self_param => {\n+                    // Restricting `Self` for a single method.\n+                    suggest_restriction(&generics, \"`Self`\", err);\n+                    return;\n+                }\n+\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, generics, _), .. })\n+                | hir::Node::TraitItem(hir::TraitItem {\n+                    generics,\n+                    kind: hir::TraitItemKind::Method(..),\n+                    ..\n+                })\n+                | hir::Node::ImplItem(hir::ImplItem {\n+                    generics,\n+                    kind: hir::ImplItemKind::Method(..),\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, generics, _, _),\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl(_, _, _, generics, ..),\n+                    ..\n+                }) if projection.is_some() => {\n+                    // Missing associated type bound.\n+                    suggest_restriction(&generics, \"the associated type\", err);\n+                    return;\n+                }\n+\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Struct(_, generics),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Enum(_, generics), span, ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Union(_, generics),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, generics, ..),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl(_, _, _, generics, ..),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(_, generics, _),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::TyAlias(_, generics),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::TraitAlias(generics, _),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::OpaqueTy(hir::OpaqueTy { generics, .. }),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::TraitItem(hir::TraitItem { generics, span, .. })\n+                | hir::Node::ImplItem(hir::ImplItem { generics, span, .. })\n+                    if param_ty =>\n+                {\n+                    // Missing generic type parameter bound.\n+                    let param_name = self_ty.to_string();\n+                    let constraint = trait_ref.print_only_trait_path().to_string();\n+                    if suggest_constraining_type_param(\n+                        generics,\n+                        &mut err,\n+                        &param_name,\n+                        &constraint,\n+                        self.tcx.sess.source_map(),\n+                        *span,\n+                    ) {\n+                        return;\n+                    }\n+                }\n+\n+                hir::Node::Crate => return,\n+\n+                _ => {}\n+            }\n+\n+            hir_id = self.tcx.hir().get_parent_item(hir_id);\n+        }\n+    }\n+\n+    /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a\n+    /// suggestion to borrow the initializer in order to use have a slice instead.\n+    crate fn suggest_borrow_on_unsized_slice(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+    ) {\n+        if let &ObligationCauseCode::VariableType(hir_id) = code {\n+            let parent_node = self.tcx.hir().get_parent_node(hir_id);\n+            if let Some(Node::Local(ref local)) = self.tcx.hir().find(parent_node) {\n+                if let Some(ref expr) = local.init {\n+                    if let hir::ExprKind::Index(_, _) = expr.kind {\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n+                            err.span_suggestion(\n+                                expr.span,\n+                                \"consider borrowing here\",\n+                                format!(\"&{}\", snippet),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Given a closure's `DefId`, return the given name of the closure.\n+    ///\n+    /// This doesn't account for reassignments, but it's only used for suggestions.\n+    crate fn get_closure_name(\n+        &self,\n+        def_id: DefId,\n+        err: &mut DiagnosticBuilder<'_>,\n+        msg: &str,\n+    ) -> Option<String> {\n+        let get_name =\n+            |err: &mut DiagnosticBuilder<'_>, kind: &hir::PatKind<'_>| -> Option<String> {\n+                // Get the local name of this closure. This can be inaccurate because\n+                // of the possibility of reassignment, but this should be good enough.\n+                match &kind {\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n+                        Some(format!(\"{}\", name))\n+                    }\n+                    _ => {\n+                        err.note(&msg);\n+                        None\n+                    }\n+                }\n+            };\n+\n+        let hir = self.tcx.hir();\n+        let hir_id = hir.as_local_hir_id(def_id)?;\n+        let parent_node = hir.get_parent_node(hir_id);\n+        match hir.find(parent_node) {\n+            Some(hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(local), .. })) => {\n+                get_name(err, &local.pat.kind)\n+            }\n+            // Different to previous arm because one is `&hir::Local` and the other\n+            // is `P<hir::Local>`.\n+            Some(hir::Node::Local(local)) => get_name(err, &local.pat.kind),\n+            _ => return None,\n+        }\n+    }\n+\n+    /// We tried to apply the bound to an `fn` or closure. Check whether calling it would\n+    /// evaluate to a type that *would* satisfy the trait binding. If it would, suggest calling\n+    /// it: `bar(foo)` \u2192 `bar(foo())`. This case is *very* likely to be hit if `foo` is `async`.\n+    crate fn suggest_fn_call(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    ) {\n+        let self_ty = trait_ref.self_ty();\n+        let (def_id, output_ty, callable) = match self_ty.kind {\n+            ty::Closure(def_id, substs) => {\n+                (def_id, self.closure_sig(def_id, substs).output(), \"closure\")\n+            }\n+            ty::FnDef(def_id, _) => (def_id, self_ty.fn_sig(self.tcx).output(), \"function\"),\n+            _ => return,\n+        };\n+        let msg = format!(\"use parentheses to call the {}\", callable);\n+\n+        let obligation = self.mk_obligation_for_def_id(\n+            trait_ref.def_id(),\n+            output_ty.skip_binder(),\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+        );\n+\n+        match self.evaluate_obligation(&obligation) {\n+            Ok(EvaluationResult::EvaluatedToOk)\n+            | Ok(EvaluationResult::EvaluatedToOkModuloRegions)\n+            | Ok(EvaluationResult::EvaluatedToAmbig) => {}\n+            _ => return,\n+        }\n+        let hir = self.tcx.hir();\n+        // Get the name of the callable and the arguments to be used in the suggestion.\n+        let snippet = match hir.get_if_local(def_id) {\n+            Some(hir::Node::Expr(hir::Expr {\n+                kind: hir::ExprKind::Closure(_, decl, _, span, ..),\n+                ..\n+            })) => {\n+                err.span_label(*span, \"consider calling this closure\");\n+                let name = match self.get_closure_name(def_id, err, &msg) {\n+                    Some(name) => name,\n+                    None => return,\n+                };\n+                let args = decl.inputs.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n+                format!(\"{}({})\", name, args)\n+            }\n+            Some(hir::Node::Item(hir::Item {\n+                ident,\n+                kind: hir::ItemKind::Fn(.., body_id),\n+                ..\n+            })) => {\n+                err.span_label(ident.span, \"consider calling this function\");\n+                let body = hir.body(*body_id);\n+                let args = body\n+                    .params\n+                    .iter()\n+                    .map(|arg| match &arg.pat.kind {\n+                        hir::PatKind::Binding(_, _, ident, None)\n+                        // FIXME: provide a better suggestion when encountering `SelfLower`, it\n+                        // should suggest a method call.\n+                        if ident.name != kw::SelfLower => ident.to_string(),\n+                        _ => \"_\".to_string(),\n+                    })\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n+                format!(\"{}({})\", ident, args)\n+            }\n+            _ => return,\n+        };\n+        if points_at_arg {\n+            // When the obligation error has been ensured to have been caused by\n+            // an argument, the `obligation.cause.span` points at the expression\n+            // of the argument, so we can provide a suggestion. This is signaled\n+            // by `points_at_arg`. Otherwise, we give a more general note.\n+            err.span_suggestion(\n+                obligation.cause.span,\n+                &msg,\n+                snippet,\n+                Applicability::HasPlaceholders,\n+            );\n+        } else {\n+            err.help(&format!(\"{}: `{}`\", msg, snippet));\n+        }\n+    }\n+\n+    crate fn suggest_add_reference_to_arg(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+        has_custom_message: bool,\n+    ) -> bool {\n+        if !points_at_arg {\n+            return false;\n+        }\n+\n+        let span = obligation.cause.span;\n+        let param_env = obligation.param_env;\n+        let trait_ref = trait_ref.skip_binder();\n+\n+        if let ObligationCauseCode::ImplDerivedObligation(obligation) = &obligation.cause.code {\n+            // Try to apply the original trait binding obligation by borrowing.\n+            let self_ty = trait_ref.self_ty();\n+            let found = self_ty.to_string();\n+            let new_self_ty = self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, self_ty);\n+            let substs = self.tcx.mk_substs_trait(new_self_ty, &[]);\n+            let new_trait_ref = ty::TraitRef::new(obligation.parent_trait_ref.def_id(), substs);\n+            let new_obligation =\n+                Obligation::new(ObligationCause::dummy(), param_env, new_trait_ref.to_predicate());\n+            if self.predicate_must_hold_modulo_regions(&new_obligation) {\n+                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                    // We have a very specific type of error, where just borrowing this argument\n+                    // might solve the problem. In cases like this, the important part is the\n+                    // original type obligation, not the last one that failed, which is arbitrary.\n+                    // Because of this, we modify the error to refer to the original obligation and\n+                    // return early in the caller.\n+                    let msg = format!(\n+                        \"the trait bound `{}: {}` is not satisfied\",\n+                        found,\n+                        obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n+                    );\n+                    if has_custom_message {\n+                        err.note(&msg);\n+                    } else {\n+                        err.message = vec![(msg, Style::NoStyle)];\n+                    }\n+                    if snippet.starts_with('&') {\n+                        // This is already a literal borrow and the obligation is failing\n+                        // somewhere else in the obligation chain. Do not suggest non-sense.\n+                        return false;\n+                    }\n+                    err.span_label(\n+                        span,\n+                        &format!(\n+                            \"expected an implementor of trait `{}`\",\n+                            obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n+                        ),\n+                    );\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider borrowing here\",\n+                        format!(\"&{}\", snippet),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,\n+    /// suggest removing these references until we reach a type that implements the trait.\n+    crate fn suggest_remove_reference(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) {\n+        let trait_ref = trait_ref.skip_binder();\n+        let span = obligation.cause.span;\n+\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+            let refs_number =\n+                snippet.chars().filter(|c| !c.is_whitespace()).take_while(|c| *c == '&').count();\n+            if let Some('\\'') =\n+                snippet.chars().filter(|c| !c.is_whitespace()).skip(refs_number).next()\n+            {\n+                // Do not suggest removal of borrow from type arguments.\n+                return;\n+            }\n+\n+            let mut trait_type = trait_ref.self_ty();\n+\n+            for refs_remaining in 0..refs_number {\n+                if let ty::Ref(_, t_type, _) = trait_type.kind {\n+                    trait_type = t_type;\n+\n+                    let new_obligation = self.mk_obligation_for_def_id(\n+                        trait_ref.def_id,\n+                        trait_type,\n+                        ObligationCause::dummy(),\n+                        obligation.param_env,\n+                    );\n+\n+                    if self.predicate_may_hold(&new_obligation) {\n+                        let sp = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n+\n+                        let remove_refs = refs_remaining + 1;\n+                        let format_str =\n+                            format!(\"consider removing {} leading `&`-references\", remove_refs);\n+\n+                        err.span_suggestion_short(\n+                            sp,\n+                            &format_str,\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        break;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Check if the trait bound is implemented for a different mutability and note it in the\n+    /// final error.\n+    crate fn suggest_change_mut(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    ) {\n+        let span = obligation.cause.span;\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+            let refs_number =\n+                snippet.chars().filter(|c| !c.is_whitespace()).take_while(|c| *c == '&').count();\n+            if let Some('\\'') =\n+                snippet.chars().filter(|c| !c.is_whitespace()).skip(refs_number).next()\n+            {\n+                // Do not suggest removal of borrow from type arguments.\n+                return;\n+            }\n+            let trait_ref = self.resolve_vars_if_possible(trait_ref);\n+            if trait_ref.has_infer_types() {\n+                // Do not ICE while trying to find if a reborrow would succeed on a trait with\n+                // unresolved bindings.\n+                return;\n+            }\n+\n+            if let ty::Ref(region, t_type, mutability) = trait_ref.skip_binder().self_ty().kind {\n+                let trait_type = match mutability {\n+                    hir::Mutability::Mut => self.tcx.mk_imm_ref(region, t_type),\n+                    hir::Mutability::Not => self.tcx.mk_mut_ref(region, t_type),\n+                };\n+\n+                let new_obligation = self.mk_obligation_for_def_id(\n+                    trait_ref.skip_binder().def_id,\n+                    trait_type,\n+                    ObligationCause::dummy(),\n+                    obligation.param_env,\n+                );\n+\n+                if self.evaluate_obligation_no_overflow(&new_obligation).must_apply_modulo_regions()\n+                {\n+                    let sp = self\n+                        .tcx\n+                        .sess\n+                        .source_map()\n+                        .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n+                    if points_at_arg && mutability == hir::Mutability::Not && refs_number > 0 {\n+                        err.span_suggestion(\n+                            sp,\n+                            \"consider changing this borrow's mutability\",\n+                            \"&mut \".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        err.note(&format!(\n+                            \"`{}` is implemented for `{:?}`, but not for `{:?}`\",\n+                            trait_ref.print_only_trait_path(),\n+                            trait_type,\n+                            trait_ref.skip_binder().self_ty(),\n+                        ));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    crate fn suggest_semicolon_removal(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) {\n+        let hir = self.tcx.hir();\n+        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let node = hir.find(parent_node);\n+        if let Some(hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(sig, _, body_id), ..\n+        })) = node\n+        {\n+            let body = hir.body(*body_id);\n+            if let hir::ExprKind::Block(blk, _) = &body.value.kind {\n+                if sig.decl.output.span().overlaps(span)\n+                    && blk.expr.is_none()\n+                    && \"()\" == &trait_ref.self_ty().to_string()\n+                {\n+                    // FIXME(estebank): When encountering a method with a trait\n+                    // bound not satisfied in the return type with a body that has\n+                    // no return, suggest removal of semicolon on last statement.\n+                    // Once that is added, close #54771.\n+                    if let Some(ref stmt) = blk.stmts.last() {\n+                        let sp = self.tcx.sess.source_map().end_point(stmt.span);\n+                        err.span_label(sp, \"consider removing this semicolon\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// If all conditions are met to identify a returned `dyn Trait`, suggest using `impl Trait` if\n+    /// applicable and signal that the error has been expanded appropriately and needs to be\n+    /// emitted.\n+    crate fn suggest_impl_trait(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) -> bool {\n+        match obligation.cause.code.peel_derives() {\n+            // Only suggest `impl Trait` if the return type is unsized because it is `dyn Trait`.\n+            ObligationCauseCode::SizedReturnType => {}\n+            _ => return false,\n+        }\n+\n+        let hir = self.tcx.hir();\n+        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let node = hir.find(parent_node);\n+        let (sig, body_id) = if let Some(hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(sig, _, body_id),\n+            ..\n+        })) = node\n+        {\n+            (sig, body_id)\n+        } else {\n+            return false;\n+        };\n+        let body = hir.body(*body_id);\n+        let trait_ref = self.resolve_vars_if_possible(trait_ref);\n+        let ty = trait_ref.skip_binder().self_ty();\n+        let is_object_safe = match ty.kind {\n+            ty::Dynamic(predicates, _) => {\n+                // If the `dyn Trait` is not object safe, do not suggest `Box<dyn Trait>`.\n+                predicates\n+                    .principal_def_id()\n+                    .map_or(true, |def_id| object_safety_violations(self.tcx, def_id).is_empty())\n+            }\n+            // We only want to suggest `impl Trait` to `dyn Trait`s.\n+            // For example, `fn foo() -> str` needs to be filtered out.\n+            _ => return false,\n+        };\n+\n+        let ret_ty = if let hir::FunctionRetTy::Return(ret_ty) = sig.decl.output {\n+            ret_ty\n+        } else {\n+            return false;\n+        };\n+\n+        // Use `TypeVisitor` instead of the output type directly to find the span of `ty` for\n+        // cases like `fn foo() -> (dyn Trait, i32) {}`.\n+        // Recursively look for `TraitObject` types and if there's only one, use that span to\n+        // suggest `impl Trait`.\n+\n+        // Visit to make sure there's a single `return` type to suggest `impl Trait`,\n+        // otherwise suggest using `Box<dyn Trait>` or an enum.\n+        let mut visitor = ReturnsVisitor(vec![]);\n+        visitor.visit_body(&body);\n+\n+        let tables = self.in_progress_tables.map(|t| t.borrow()).unwrap();\n+\n+        let mut ret_types = visitor.0.iter().filter_map(|expr| tables.node_type_opt(expr.hir_id));\n+        let (last_ty, all_returns_have_same_type) =\n+            ret_types.clone().fold((None, true), |(last_ty, mut same), returned_ty| {\n+                same &= last_ty.map_or(true, |ty| ty == returned_ty);\n+                (Some(returned_ty), same)\n+            });\n+        let all_returns_conform_to_trait =\n+            if let Some(ty_ret_ty) = tables.node_type_opt(ret_ty.hir_id) {\n+                match ty_ret_ty.kind {\n+                    ty::Dynamic(predicates, _) => {\n+                        let cause = ObligationCause::misc(ret_ty.span, ret_ty.hir_id);\n+                        let param_env = ty::ParamEnv::empty();\n+                        ret_types.all(|returned_ty| {\n+                            predicates.iter().all(|predicate| {\n+                                let pred = predicate.with_self_ty(self.tcx, returned_ty);\n+                                let obl = Obligation::new(cause.clone(), param_env, pred);\n+                                self.predicate_may_hold(&obl)\n+                            })\n+                        })\n+                    }\n+                    _ => true,\n+                }\n+            } else {\n+                true\n+            };\n+\n+        let (snippet, last_ty) =\n+            if let (true, hir::TyKind::TraitObject(..), Ok(snippet), true, Some(last_ty)) = (\n+                // Verify that we're dealing with a return `dyn Trait`\n+                ret_ty.span.overlaps(span),\n+                &ret_ty.kind,\n+                self.tcx.sess.source_map().span_to_snippet(ret_ty.span),\n+                // If any of the return types does not conform to the trait, then we can't\n+                // suggest `impl Trait` nor trait objects, it is a type mismatch error.\n+                all_returns_conform_to_trait,\n+                last_ty,\n+            ) {\n+                (snippet, last_ty)\n+            } else {\n+                return false;\n+            };\n+        err.code(error_code!(E0746));\n+        err.set_primary_message(\"return type cannot have an unboxed trait object\");\n+        err.children.clear();\n+        let impl_trait_msg = \"for information on `impl Trait`, see \\\n+            <https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+            #returning-types-that-implement-traits>\";\n+        let trait_obj_msg = \"for information on trait objects, see \\\n+            <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n+            #using-trait-objects-that-allow-for-values-of-different-types>\";\n+        let has_dyn = snippet.split_whitespace().next().map_or(false, |s| s == \"dyn\");\n+        let trait_obj = if has_dyn { &snippet[4..] } else { &snippet[..] };\n+        if all_returns_have_same_type {\n+            // Suggest `-> impl Trait`.\n+            err.span_suggestion(\n+                ret_ty.span,\n+                &format!(\n+                    \"return `impl {1}` instead, as all return paths are of type `{}`, \\\n+                        which implements `{1}`\",\n+                    last_ty, trait_obj,\n+                ),\n+                format!(\"impl {}\", trait_obj),\n+                Applicability::MachineApplicable,\n+            );\n+            err.note(impl_trait_msg);\n+        } else {\n+            if is_object_safe {\n+                // Suggest `-> Box<dyn Trait>` and `Box::new(returned_value)`.\n+                // Get all the return values and collect their span and suggestion.\n+                let mut suggestions = visitor\n+                    .0\n+                    .iter()\n+                    .map(|expr| {\n+                        (\n+                            expr.span,\n+                            format!(\n+                                \"Box::new({})\",\n+                                self.tcx.sess.source_map().span_to_snippet(expr.span).unwrap()\n+                            ),\n+                        )\n+                    })\n+                    .collect::<Vec<_>>();\n+                // Add the suggestion for the return type.\n+                suggestions.push((\n+                    ret_ty.span,\n+                    format!(\"Box<{}{}>\", if has_dyn { \"\" } else { \"dyn \" }, snippet),\n+                ));\n+                err.multipart_suggestion(\n+                    \"return a boxed trait object instead\",\n+                    suggestions,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            } else {\n+                // This is currently not possible to trigger because E0038 takes precedence, but\n+                // leave it in for completeness in case anything changes in an earlier stage.\n+                err.note(&format!(\n+                    \"if trait `{}` was object safe, you could return a trait object\",\n+                    trait_obj,\n+                ));\n+            }\n+            err.note(trait_obj_msg);\n+            err.note(&format!(\n+                \"if all the returned values were of the same type you could use \\\n+                    `impl {}` as the return type\",\n+                trait_obj,\n+            ));\n+            err.note(impl_trait_msg);\n+            err.note(\"you can create a new `enum` with a variant for each returned type\");\n+        }\n+        true\n+    }\n+\n+    crate fn point_at_returns_when_relevant(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) {\n+        match obligation.cause.code.peel_derives() {\n+            ObligationCauseCode::SizedReturnType => {}\n+            _ => return,\n+        }\n+\n+        let hir = self.tcx.hir();\n+        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let node = hir.find(parent_node);\n+        if let Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })) =\n+            node\n+        {\n+            let body = hir.body(*body_id);\n+            // Point at all the `return`s in the function as they have failed trait bounds.\n+            let mut visitor = ReturnsVisitor(vec![]);\n+            visitor.visit_body(&body);\n+            let tables = self.in_progress_tables.map(|t| t.borrow()).unwrap();\n+            for expr in &visitor.0 {\n+                if let Some(returned_ty) = tables.node_type_opt(expr.hir_id) {\n+                    let ty = self.resolve_vars_if_possible(&returned_ty);\n+                    err.span_label(expr.span, &format!(\"this returned value is of type `{}`\", ty));\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Given some node representing a fn-like thing in the HIR map,\n+    /// returns a span and `ArgKind` information that describes the\n+    /// arguments it expects. This can be supplied to\n+    /// `report_arg_count_mismatch`.\n+    pub fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>) {\n+        match node {\n+            Node::Expr(&hir::Expr {\n+                kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n+                ..\n+            }) => (\n+                self.tcx.sess.source_map().def_span(span),\n+                self.tcx\n+                    .hir()\n+                    .body(id)\n+                    .params\n+                    .iter()\n+                    .map(|arg| {\n+                        if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n+                            *arg.pat\n+                        {\n+                            ArgKind::Tuple(\n+                                Some(span),\n+                                args.iter()\n+                                    .map(|pat| {\n+                                        let snippet = self\n+                                            .tcx\n+                                            .sess\n+                                            .source_map()\n+                                            .span_to_snippet(pat.span)\n+                                            .unwrap();\n+                                        (snippet, \"_\".to_owned())\n+                                    })\n+                                    .collect::<Vec<_>>(),\n+                            )\n+                        } else {\n+                            let name =\n+                                self.tcx.sess.source_map().span_to_snippet(arg.pat.span).unwrap();\n+                            ArgKind::Arg(name, \"_\".to_owned())\n+                        }\n+                    })\n+                    .collect::<Vec<ArgKind>>(),\n+            ),\n+            Node::Item(&hir::Item { span, kind: hir::ItemKind::Fn(ref sig, ..), .. })\n+            | Node::ImplItem(&hir::ImplItem {\n+                span,\n+                kind: hir::ImplItemKind::Method(ref sig, _),\n+                ..\n+            })\n+            | Node::TraitItem(&hir::TraitItem {\n+                span,\n+                kind: hir::TraitItemKind::Method(ref sig, _),\n+                ..\n+            }) => (\n+                self.tcx.sess.source_map().def_span(span),\n+                sig.decl\n+                    .inputs\n+                    .iter()\n+                    .map(|arg| match arg.clone().kind {\n+                        hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n+                            Some(arg.span),\n+                            vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()],\n+                        ),\n+                        _ => ArgKind::empty(),\n+                    })\n+                    .collect::<Vec<ArgKind>>(),\n+            ),\n+            Node::Ctor(ref variant_data) => {\n+                let span = variant_data\n+                    .ctor_hir_id()\n+                    .map(|hir_id| self.tcx.hir().span(hir_id))\n+                    .unwrap_or(DUMMY_SP);\n+                let span = self.tcx.sess.source_map().def_span(span);\n+\n+                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n+            }\n+            _ => panic!(\"non-FnLike node found: {:?}\", node),\n+        }\n+    }\n+\n+    /// Reports an error when the number of arguments needed by a\n+    /// trait match doesn't match the number that the expression\n+    /// provides.\n+    pub fn report_arg_count_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_args: Vec<ArgKind>,\n+        found_args: Vec<ArgKind>,\n+        is_closure: bool,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        let kind = if is_closure { \"closure\" } else { \"function\" };\n+\n+        let args_str = |arguments: &[ArgKind], other: &[ArgKind]| {\n+            let arg_length = arguments.len();\n+            let distinct = match &other[..] {\n+                &[ArgKind::Tuple(..)] => true,\n+                _ => false,\n+            };\n+            match (arg_length, arguments.get(0)) {\n+                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n+                    format!(\"a single {}-tuple as argument\", fields.len())\n+                }\n+                _ => format!(\n+                    \"{} {}argument{}\",\n+                    arg_length,\n+                    if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n+                    pluralize!(arg_length)\n+                ),\n+            }\n+        };\n+\n+        let expected_str = args_str(&expected_args, &found_args);\n+        let found_str = args_str(&found_args, &expected_args);\n+\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0593,\n+            \"{} is expected to take {}, but it takes {}\",\n+            kind,\n+            expected_str,\n+            found_str,\n+        );\n+\n+        err.span_label(span, format!(\"expected {} that takes {}\", kind, expected_str));\n+\n+        if let Some(found_span) = found_span {\n+            err.span_label(found_span, format!(\"takes {}\", found_str));\n+\n+            // move |_| { ... }\n+            // ^^^^^^^^-- def_span\n+            //\n+            // move |_| { ... }\n+            // ^^^^^-- prefix\n+            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n+            // move |_| { ... }\n+            //      ^^^-- pipe_span\n+            let pipe_span =\n+                if let Some(span) = found_span.trim_start(prefix_span) { span } else { found_span };\n+\n+            // Suggest to take and ignore the arguments with expected_args_length `_`s if\n+            // found arguments is empty (assume the user just wants to ignore args in this case).\n+            // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n+            if found_args.is_empty() && is_closure {\n+                let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n+                err.span_suggestion(\n+                    pipe_span,\n+                    &format!(\n+                        \"consider changing the closure to take and ignore the expected argument{}\",\n+                        if expected_args.len() < 2 { \"\" } else { \"s\" }\n+                    ),\n+                    format!(\"|{}|\", underscores),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+\n+            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n+                if fields.len() == expected_args.len() {\n+                    let sugg = fields\n+                        .iter()\n+                        .map(|(name, _)| name.to_owned())\n+                        .collect::<Vec<String>>()\n+                        .join(\", \");\n+                    err.span_suggestion(\n+                        found_span,\n+                        \"change the closure to take multiple arguments instead of a single tuple\",\n+                        format!(\"|{}|\", sugg),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n+                if fields.len() == found_args.len() && is_closure {\n+                    let sugg = format!(\n+                        \"|({}){}|\",\n+                        found_args\n+                            .iter()\n+                            .map(|arg| match arg {\n+                                ArgKind::Arg(name, _) => name.to_owned(),\n+                                _ => \"_\".to_owned(),\n+                            })\n+                            .collect::<Vec<String>>()\n+                            .join(\", \"),\n+                        // add type annotations if available\n+                        if found_args.iter().any(|arg| match arg {\n+                            ArgKind::Arg(_, ty) => ty != \"_\",\n+                            _ => false,\n+                        }) {\n+                            format!(\n+                                \": ({})\",\n+                                fields\n+                                    .iter()\n+                                    .map(|(_, ty)| ty.to_owned())\n+                                    .collect::<Vec<String>>()\n+                                    .join(\", \")\n+                            )\n+                        } else {\n+                            String::new()\n+                        },\n+                    );\n+                    err.span_suggestion(\n+                        found_span,\n+                        \"change the closure to accept a tuple instead of individual arguments\",\n+                        sugg,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+\n+        err\n+    }\n+\n+    crate fn report_closure_arg_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_ref: ty::PolyTraitRef<'tcx>,\n+        found: ty::PolyTraitRef<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        crate fn build_fn_sig_string<'tcx>(\n+            tcx: TyCtxt<'tcx>,\n+            trait_ref: &ty::TraitRef<'tcx>,\n+        ) -> String {\n+            let inputs = trait_ref.substs.type_at(1);\n+            let sig = if let ty::Tuple(inputs) = inputs.kind {\n+                tcx.mk_fn_sig(\n+                    inputs.iter().map(|k| k.expect_ty()),\n+                    tcx.mk_ty_infer(ty::TyVar(ty::TyVid { index: 0 })),\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    ::rustc_target::spec::abi::Abi::Rust,\n+                )\n+            } else {\n+                tcx.mk_fn_sig(\n+                    ::std::iter::once(inputs),\n+                    tcx.mk_ty_infer(ty::TyVar(ty::TyVid { index: 0 })),\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    ::rustc_target::spec::abi::Abi::Rust,\n+                )\n+            };\n+            ty::Binder::bind(sig).to_string()\n+        }\n+\n+        let argument_is_closure = expected_ref.skip_binder().substs.type_at(0).is_closure();\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0631,\n+            \"type mismatch in {} arguments\",\n+            if argument_is_closure { \"closure\" } else { \"function\" }\n+        );\n+\n+        let found_str = format!(\n+            \"expected signature of `{}`\",\n+            build_fn_sig_string(self.tcx, found.skip_binder())\n+        );\n+        err.span_label(span, found_str);\n+\n+        let found_span = found_span.unwrap_or(span);\n+        let expected_str = format!(\n+            \"found signature of `{}`\",\n+            build_fn_sig_string(self.tcx, expected_ref.skip_binder())\n+        );\n+        err.span_label(found_span, expected_str);\n+\n+        err\n+    }\n+}\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    crate fn suggest_fully_qualified_path(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        def_id: DefId,\n+        span: Span,\n+        trait_ref: DefId,\n+    ) {\n+        if let Some(assoc_item) = self.tcx.opt_associated_item(def_id) {\n+            if let ty::AssocKind::Const | ty::AssocKind::Type = assoc_item.kind {\n+                err.note(&format!(\n+                    \"{}s cannot be accessed directly on a `trait`, they can only be \\\n+                        accessed through a specific `impl`\",\n+                    assoc_item.kind.suggestion_descr(),\n+                ));\n+                err.span_suggestion(\n+                    span,\n+                    \"use the fully qualified path to an implementation\",\n+                    format!(\"<Type as {}>::{}\", self.tcx.def_path_str(trait_ref), assoc_item.ident),\n+                    Applicability::HasPlaceholders,\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Adds an async-await specific note to the diagnostic when the future does not implement\n+    /// an auto trait because of a captured type.\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// note: future does not implement `Qux` as this value is used across an await\n+    ///   --> $DIR/issue-64130-3-other.rs:17:5\n+    ///    |\n+    /// LL |     let x = Foo;\n+    ///    |         - has type `Foo`\n+    /// LL |     baz().await;\n+    ///    |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n+    /// LL | }\n+    ///    | - `x` is later dropped here\n+    /// ```\n+    ///\n+    /// When the diagnostic does not implement `Send` or `Sync` specifically, then the diagnostic\n+    /// is \"replaced\" with a different message and a more specific error.\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// error: future cannot be sent between threads safely\n+    ///   --> $DIR/issue-64130-2-send.rs:21:5\n+    ///    |\n+    /// LL | fn is_send<T: Send>(t: T) { }\n+    ///    |    -------    ---- required by this bound in `is_send`\n+    /// ...\n+    /// LL |     is_send(bar());\n+    ///    |     ^^^^^^^ future returned by `bar` is not send\n+    ///    |\n+    ///    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not\n+    ///            implemented for `Foo`\n+    /// note: future is not send as this value is used across an await\n+    ///   --> $DIR/issue-64130-2-send.rs:15:5\n+    ///    |\n+    /// LL |     let x = Foo;\n+    ///    |         - has type `Foo`\n+    /// LL |     baz().await;\n+    ///    |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n+    /// LL | }\n+    ///    | - `x` is later dropped here\n+    /// ```\n+    ///\n+    /// Returns `true` if an async-await specific note was added to the diagnostic.\n+    crate fn maybe_note_obligation_cause_for_async_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool {\n+        debug!(\n+            \"maybe_note_obligation_cause_for_async_await: obligation.predicate={:?} \\\n+                obligation.cause.span={:?}\",\n+            obligation.predicate, obligation.cause.span\n+        );\n+        let source_map = self.tcx.sess.source_map();\n+\n+        // Attempt to detect an async-await error by looking at the obligation causes, looking\n+        // for a generator to be present.\n+        //\n+        // When a future does not implement a trait because of a captured type in one of the\n+        // generators somewhere in the call stack, then the result is a chain of obligations.\n+        //\n+        // Given a `async fn` A that calls a `async fn` B which captures a non-send type and that\n+        // future is passed as an argument to a function C which requires a `Send` type, then the\n+        // chain looks something like this:\n+        //\n+        // - `BuiltinDerivedObligation` with a generator witness (B)\n+        // - `BuiltinDerivedObligation` with a generator (B)\n+        // - `BuiltinDerivedObligation` with `std::future::GenFuture` (B)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (B)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (B)\n+        // - `BuiltinDerivedObligation` with a generator witness (A)\n+        // - `BuiltinDerivedObligation` with a generator (A)\n+        // - `BuiltinDerivedObligation` with `std::future::GenFuture` (A)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n+        // - `BindingObligation` with `impl_send (Send requirement)\n+        //\n+        // The first obligation in the chain is the most useful and has the generator that captured\n+        // the type. The last generator has information about where the bound was introduced. At\n+        // least one generator should be present for this diagnostic to be modified.\n+        let (mut trait_ref, mut target_ty) = match obligation.predicate {\n+            ty::Predicate::Trait(p) => {\n+                (Some(p.skip_binder().trait_ref), Some(p.skip_binder().self_ty()))\n+            }\n+            _ => (None, None),\n+        };\n+        let mut generator = None;\n+        let mut last_generator = None;\n+        let mut next_code = Some(&obligation.cause.code);\n+        while let Some(code) = next_code {\n+            debug!(\"maybe_note_obligation_cause_for_async_await: code={:?}\", code);\n+            match code {\n+                ObligationCauseCode::BuiltinDerivedObligation(derived_obligation)\n+                | ObligationCauseCode::ImplDerivedObligation(derived_obligation) => {\n+                    let ty = derived_obligation.parent_trait_ref.self_ty();\n+                    debug!(\n+                        \"maybe_note_obligation_cause_for_async_await: \\\n+                            parent_trait_ref={:?} self_ty.kind={:?}\",\n+                        derived_obligation.parent_trait_ref, ty.kind\n+                    );\n+\n+                    match ty.kind {\n+                        ty::Generator(did, ..) => {\n+                            generator = generator.or(Some(did));\n+                            last_generator = Some(did);\n+                        }\n+                        ty::GeneratorWitness(..) => {}\n+                        _ if generator.is_none() => {\n+                            trait_ref = Some(*derived_obligation.parent_trait_ref.skip_binder());\n+                            target_ty = Some(ty);\n+                        }\n+                        _ => {}\n+                    }\n+\n+                    next_code = Some(derived_obligation.parent_code.as_ref());\n+                }\n+                _ => break,\n+            }\n+        }\n+\n+        // Only continue if a generator was found.\n+        debug!(\n+            \"maybe_note_obligation_cause_for_async_await: generator={:?} trait_ref={:?} \\\n+                target_ty={:?}\",\n+            generator, trait_ref, target_ty\n+        );\n+        let (generator_did, trait_ref, target_ty) = match (generator, trait_ref, target_ty) {\n+            (Some(generator_did), Some(trait_ref), Some(target_ty)) => {\n+                (generator_did, trait_ref, target_ty)\n+            }\n+            _ => return false,\n+        };\n+\n+        let span = self.tcx.def_span(generator_did);\n+\n+        // Do not ICE on closure typeck (#66868).\n+        if self.tcx.hir().as_local_hir_id(generator_did).is_none() {\n+            return false;\n+        }\n+\n+        // Get the tables from the infcx if the generator is the function we are\n+        // currently type-checking; otherwise, get them by performing a query.\n+        // This is needed to avoid cycles.\n+        let in_progress_tables = self.in_progress_tables.map(|t| t.borrow());\n+        let generator_did_root = self.tcx.closure_base_def_id(generator_did);\n+        debug!(\n+            \"maybe_note_obligation_cause_for_async_await: generator_did={:?} \\\n+             generator_did_root={:?} in_progress_tables.local_id_root={:?} span={:?}\",\n+            generator_did,\n+            generator_did_root,\n+            in_progress_tables.as_ref().map(|t| t.local_id_root),\n+            span\n+        );\n+        let query_tables;\n+        let tables: &TypeckTables<'tcx> = match &in_progress_tables {\n+            Some(t) if t.local_id_root == Some(generator_did_root) => t,\n+            _ => {\n+                query_tables = self.tcx.typeck_tables_of(generator_did);\n+                &query_tables\n+            }\n+        };\n+\n+        // Look for a type inside the generator interior that matches the target type to get\n+        // a span.\n+        let target_ty_erased = self.tcx.erase_regions(&target_ty);\n+        let target_span = tables\n+            .generator_interior_types\n+            .iter()\n+            .find(|ty::GeneratorInteriorTypeCause { ty, .. }| {\n+                // Careful: the regions for types that appear in the\n+                // generator interior are not generally known, so we\n+                // want to erase them when comparing (and anyway,\n+                // `Send` and other bounds are generally unaffected by\n+                // the choice of region).  When erasing regions, we\n+                // also have to erase late-bound regions. This is\n+                // because the types that appear in the generator\n+                // interior generally contain \"bound regions\" to\n+                // represent regions that are part of the suspended\n+                // generator frame. Bound regions are preserved by\n+                // `erase_regions` and so we must also call\n+                // `erase_late_bound_regions`.\n+                let ty_erased = self.tcx.erase_late_bound_regions(&ty::Binder::bind(*ty));\n+                let ty_erased = self.tcx.erase_regions(&ty_erased);\n+                let eq = ty::TyS::same_type(ty_erased, target_ty_erased);\n+                debug!(\n+                    \"maybe_note_obligation_cause_for_async_await: ty_erased={:?} \\\n+                        target_ty_erased={:?} eq={:?}\",\n+                    ty_erased, target_ty_erased, eq\n+                );\n+                eq\n+            })\n+            .map(|ty::GeneratorInteriorTypeCause { span, scope_span, expr, .. }| {\n+                (span, source_map.span_to_snippet(*span), scope_span, expr)\n+            });\n+\n+        debug!(\n+            \"maybe_note_obligation_cause_for_async_await: target_ty={:?} \\\n+                generator_interior_types={:?} target_span={:?}\",\n+            target_ty, tables.generator_interior_types, target_span\n+        );\n+        if let Some((target_span, Ok(snippet), scope_span, expr)) = target_span {\n+            self.note_obligation_cause_for_async_await(\n+                err,\n+                *target_span,\n+                scope_span,\n+                *expr,\n+                snippet,\n+                generator_did,\n+                last_generator,\n+                trait_ref,\n+                target_ty,\n+                tables,\n+                obligation,\n+                next_code,\n+            );\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Unconditionally adds the diagnostic note described in\n+    /// `maybe_note_obligation_cause_for_async_await`'s documentation comment.\n+    crate fn note_obligation_cause_for_async_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        target_span: Span,\n+        scope_span: &Option<Span>,\n+        expr: Option<hir::HirId>,\n+        snippet: String,\n+        first_generator: DefId,\n+        last_generator: Option<DefId>,\n+        trait_ref: ty::TraitRef<'_>,\n+        target_ty: Ty<'tcx>,\n+        tables: &ty::TypeckTables<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+        next_code: Option<&ObligationCauseCode<'tcx>>,\n+    ) {\n+        let source_map = self.tcx.sess.source_map();\n+\n+        let is_async_fn = self\n+            .tcx\n+            .parent(first_generator)\n+            .map(|parent_did| self.tcx.asyncness(parent_did))\n+            .map(|parent_asyncness| parent_asyncness == hir::IsAsync::Async)\n+            .unwrap_or(false);\n+        let is_async_move = self\n+            .tcx\n+            .hir()\n+            .as_local_hir_id(first_generator)\n+            .and_then(|hir_id| self.tcx.hir().maybe_body_owned_by(hir_id))\n+            .map(|body_id| self.tcx.hir().body(body_id))\n+            .and_then(|body| body.generator_kind())\n+            .map(|generator_kind| match generator_kind {\n+                hir::GeneratorKind::Async(..) => true,\n+                _ => false,\n+            })\n+            .unwrap_or(false);\n+        let await_or_yield = if is_async_fn || is_async_move { \"await\" } else { \"yield\" };\n+\n+        // Special case the primary error message when send or sync is the trait that was\n+        // not implemented.\n+        let is_send = self.tcx.is_diagnostic_item(sym::send_trait, trait_ref.def_id);\n+        let is_sync = self.tcx.is_diagnostic_item(sym::sync_trait, trait_ref.def_id);\n+        let hir = self.tcx.hir();\n+        let trait_explanation = if is_send || is_sync {\n+            let (trait_name, trait_verb) =\n+                if is_send { (\"`Send`\", \"sent\") } else { (\"`Sync`\", \"shared\") };\n+\n+            err.clear_code();\n+            err.set_primary_message(format!(\n+                \"future cannot be {} between threads safely\",\n+                trait_verb\n+            ));\n+\n+            let original_span = err.span.primary_span().unwrap();\n+            let mut span = MultiSpan::from_span(original_span);\n+\n+            let message = if let Some(name) = last_generator\n+                .and_then(|generator_did| self.tcx.parent(generator_did))\n+                .and_then(|parent_did| hir.as_local_hir_id(parent_did))\n+                .and_then(|parent_hir_id| hir.opt_name(parent_hir_id))\n+            {\n+                format!(\"future returned by `{}` is not {}\", name, trait_name)\n+            } else {\n+                format!(\"future is not {}\", trait_name)\n+            };\n+\n+            span.push_span_label(original_span, message);\n+            err.set_span(span);\n+\n+            format!(\"is not {}\", trait_name)\n+        } else {\n+            format!(\"does not implement `{}`\", trait_ref.print_only_trait_path())\n+        };\n+\n+        // Look at the last interior type to get a span for the `.await`.\n+        let await_span = tables.generator_interior_types.iter().map(|t| t.span).last().unwrap();\n+        let mut span = MultiSpan::from_span(await_span);\n+        span.push_span_label(\n+            await_span,\n+            format!(\"{} occurs here, with `{}` maybe used later\", await_or_yield, snippet),\n+        );\n+\n+        span.push_span_label(target_span, format!(\"has type `{}`\", target_ty));\n+\n+        // If available, use the scope span to annotate the drop location.\n+        if let Some(scope_span) = scope_span {\n+            span.push_span_label(\n+                source_map.end_point(*scope_span),\n+                format!(\"`{}` is later dropped here\", snippet),\n+            );\n+        }\n+\n+        err.span_note(\n+            span,\n+            &format!(\n+                \"future {} as this value is used across an {}\",\n+                trait_explanation, await_or_yield,\n+            ),\n+        );\n+\n+        if let Some(expr_id) = expr {\n+            let expr = hir.expect_expr(expr_id);\n+            let is_ref = tables.expr_adjustments(expr).iter().any(|adj| adj.is_region_borrow());\n+            let parent = hir.get_parent_node(expr_id);\n+            if let Some(hir::Node::Expr(e)) = hir.find(parent) {\n+                let method_span = hir.span(parent);\n+                if tables.is_method_call(e) && is_ref {\n+                    err.span_help(\n+                        method_span,\n+                        \"consider moving this method call into a `let` \\\n+                        binding to create a shorter lived borrow\",\n+                    );\n+                }\n+            }\n+        }\n+\n+        // Add a note for the item obligation that remains - normally a note pointing to the\n+        // bound that introduced the obligation (e.g. `T: Send`).\n+        debug!(\"note_obligation_cause_for_async_await: next_code={:?}\", next_code);\n+        self.note_obligation_cause_code(\n+            err,\n+            &obligation.predicate,\n+            next_code.unwrap(),\n+            &mut Vec::new(),\n+        );\n+    }\n+\n+    crate fn note_obligation_cause_code<T>(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        predicate: &T,\n+        cause_code: &ObligationCauseCode<'tcx>,\n+        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+    ) where\n+        T: fmt::Display,\n+    {\n+        let tcx = self.tcx;\n+        match *cause_code {\n+            ObligationCauseCode::ExprAssignable\n+            | ObligationCauseCode::MatchExpressionArm { .. }\n+            | ObligationCauseCode::Pattern { .. }\n+            | ObligationCauseCode::IfExpression { .. }\n+            | ObligationCauseCode::IfExpressionWithNoElse\n+            | ObligationCauseCode::MainFunctionType\n+            | ObligationCauseCode::StartFunctionType\n+            | ObligationCauseCode::IntrinsicType\n+            | ObligationCauseCode::MethodReceiver\n+            | ObligationCauseCode::ReturnNoExpression\n+            | ObligationCauseCode::MiscObligation => {}\n+            ObligationCauseCode::SliceOrArrayElem => {\n+                err.note(\"slice and array elements must have `Sized` type\");\n+            }\n+            ObligationCauseCode::TupleElem => {\n+                err.note(\"only the last element of a tuple may have a dynamically sized type\");\n+            }\n+            ObligationCauseCode::ProjectionWf(data) => {\n+                err.note(&format!(\"required so that the projection `{}` is well-formed\", data,));\n+            }\n+            ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n+                err.note(&format!(\n+                    \"required so that reference `{}` does not outlive its referent\",\n+                    ref_ty,\n+                ));\n+            }\n+            ObligationCauseCode::ObjectTypeBound(object_ty, region) => {\n+                err.note(&format!(\n+                    \"required so that the lifetime bound of `{}` for `{}` is satisfied\",\n+                    region, object_ty,\n+                ));\n+            }\n+            ObligationCauseCode::ItemObligation(item_def_id) => {\n+                let item_name = tcx.def_path_str(item_def_id);\n+                let msg = format!(\"required by `{}`\", item_name);\n+\n+                if let Some(sp) = tcx.hir().span_if_local(item_def_id) {\n+                    let sp = tcx.sess.source_map().def_span(sp);\n+                    err.span_label(sp, &msg);\n+                } else {\n+                    err.note(&msg);\n+                }\n+            }\n+            ObligationCauseCode::BindingObligation(item_def_id, span) => {\n+                let item_name = tcx.def_path_str(item_def_id);\n+                let msg = format!(\"required by this bound in `{}`\", item_name);\n+                if let Some(ident) = tcx.opt_item_name(item_def_id) {\n+                    err.span_label(ident.span, \"\");\n+                }\n+                if span != DUMMY_SP {\n+                    err.span_label(span, &msg);\n+                } else {\n+                    err.note(&msg);\n+                }\n+            }\n+            ObligationCauseCode::ObjectCastObligation(object_ty) => {\n+                err.note(&format!(\n+                    \"required for the cast to the object type `{}`\",\n+                    self.ty_to_string(object_ty)\n+                ));\n+            }\n+            ObligationCauseCode::Coercion { source: _, target } => {\n+                err.note(&format!(\"required by cast to type `{}`\", self.ty_to_string(target)));\n+            }\n+            ObligationCauseCode::RepeatVec(suggest_const_in_array_repeat_expressions) => {\n+                err.note(\n+                    \"the `Copy` trait is required because the repeated element will be copied\",\n+                );\n+                if suggest_const_in_array_repeat_expressions {\n+                    err.note(\n+                        \"this array initializer can be evaluated at compile-time, for more \\\n+                         information, see issue \\\n+                         https://github.com/rust-lang/rust/issues/49147\",\n+                    );\n+                    if tcx.sess.opts.unstable_features.is_nightly_build() {\n+                        err.help(\n+                            \"add `#![feature(const_in_array_repeat_expressions)]` to the \\\n+                             crate attributes to enable\",\n+                        );\n+                    }\n+                }\n+            }\n+            ObligationCauseCode::VariableType(_) => {\n+                err.note(\"all local variables must have a statically known size\");\n+                if !self.tcx.features().unsized_locals {\n+                    err.help(\"unsized locals are gated as an unstable feature\");\n+                }\n+            }\n+            ObligationCauseCode::SizedArgumentType => {\n+                err.note(\"all function arguments must have a statically known size\");\n+                if !self.tcx.features().unsized_locals {\n+                    err.help(\"unsized locals are gated as an unstable feature\");\n+                }\n+            }\n+            ObligationCauseCode::SizedReturnType => {\n+                err.note(\"the return type of a function must have a statically known size\");\n+            }\n+            ObligationCauseCode::SizedYieldType => {\n+                err.note(\"the yield type of a generator must have a statically known size\");\n+            }\n+            ObligationCauseCode::AssignmentLhsSized => {\n+                err.note(\"the left-hand-side of an assignment must have a statically known size\");\n+            }\n+            ObligationCauseCode::TupleInitializerSized => {\n+                err.note(\"tuples must have a statically known size to be initialized\");\n+            }\n+            ObligationCauseCode::StructInitializerSized => {\n+                err.note(\"structs must have a statically known size to be initialized\");\n+            }\n+            ObligationCauseCode::FieldSized { adt_kind: ref item, last } => match *item {\n+                AdtKind::Struct => {\n+                    if last {\n+                        err.note(\n+                            \"the last field of a packed struct may only have a \\\n+                             dynamically sized type if it does not need drop to be run\",\n+                        );\n+                    } else {\n+                        err.note(\n+                            \"only the last field of a struct may have a dynamically sized type\",\n+                        );\n+                    }\n+                }\n+                AdtKind::Union => {\n+                    err.note(\"no field of a union may have a dynamically sized type\");\n+                }\n+                AdtKind::Enum => {\n+                    err.note(\"no field of an enum variant may have a dynamically sized type\");\n+                }\n+            },\n+            ObligationCauseCode::ConstSized => {\n+                err.note(\"constant expressions must have a statically known size\");\n+            }\n+            ObligationCauseCode::ConstPatternStructural => {\n+                err.note(\"constants used for pattern-matching must derive `PartialEq` and `Eq`\");\n+            }\n+            ObligationCauseCode::SharedStatic => {\n+                err.note(\"shared static variables must have a type that implements `Sync`\");\n+            }\n+            ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                let ty = parent_trait_ref.skip_binder().self_ty();\n+                err.note(&format!(\"required because it appears within the type `{}`\", ty));\n+                obligated_types.push(ty);\n+\n+                let parent_predicate = parent_trait_ref.to_predicate();\n+                if !self.is_recursive_obligation(obligated_types, &data.parent_code) {\n+                    self.note_obligation_cause_code(\n+                        err,\n+                        &parent_predicate,\n+                        &data.parent_code,\n+                        obligated_types,\n+                    );\n+                }\n+            }\n+            ObligationCauseCode::ImplDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                err.note(&format!(\n+                    \"required because of the requirements on the impl of `{}` for `{}`\",\n+                    parent_trait_ref.print_only_trait_path(),\n+                    parent_trait_ref.skip_binder().self_ty()\n+                ));\n+                let parent_predicate = parent_trait_ref.to_predicate();\n+                self.note_obligation_cause_code(\n+                    err,\n+                    &parent_predicate,\n+                    &data.parent_code,\n+                    obligated_types,\n+                );\n+            }\n+            ObligationCauseCode::CompareImplMethodObligation { .. } => {\n+                err.note(&format!(\n+                    \"the requirement `{}` appears on the impl method \\\n+                     but not on the corresponding trait method\",\n+                    predicate\n+                ));\n+            }\n+            ObligationCauseCode::CompareImplTypeObligation { .. } => {\n+                err.note(&format!(\n+                    \"the requirement `{}` appears on the associated impl type \\\n+                     but not on the corresponding associated trait type\",\n+                    predicate\n+                ));\n+            }\n+            ObligationCauseCode::ReturnType\n+            | ObligationCauseCode::ReturnValue(_)\n+            | ObligationCauseCode::BlockTailExpression(_) => (),\n+            ObligationCauseCode::TrivialBound => {\n+                err.help(\"see issue #48214\");\n+                if tcx.sess.opts.unstable_features.is_nightly_build() {\n+                    err.help(\"add `#![feature(trivial_bounds)]` to the crate attributes to enable\");\n+                }\n+            }\n+            ObligationCauseCode::AssocTypeBound(ref data) => {\n+                err.span_label(data.original, \"associated type defined here\");\n+                if let Some(sp) = data.impl_span {\n+                    err.span_label(sp, \"in this `impl` item\");\n+                }\n+                for sp in &data.bounds {\n+                    err.span_label(*sp, \"restricted in this bound\");\n+                }\n+            }\n+        }\n+    }\n+\n+    crate fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>) {\n+        let current_limit = self.tcx.sess.recursion_limit.get();\n+        let suggested_limit = current_limit * 2;\n+        err.help(&format!(\n+            \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+            suggested_limit\n+        ));\n+    }\n+}\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    generics: &hir::Generics<'_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    source_map: &SourceMap,\n+    span: Span,\n+) -> bool {\n+    let restrict_msg = \"consider further restricting this bound\";\n+    if let Some(param) =\n+        generics.params.iter().filter(|p| p.name.ident().as_str() == param_name).next()\n+    {\n+        if param_name.starts_with(\"impl \") {\n+            // `impl Trait` in argument:\n+            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+            err.span_suggestion(\n+                param.span,\n+                restrict_msg,\n+                // `impl CurrentTrait + MissingTrait`\n+                format!(\"{} + {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if generics.where_clause.predicates.is_empty() && param.bounds.is_empty() {\n+            // If there are no bounds whatsoever, suggest adding a constraint\n+            // to the type parameter:\n+            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            err.span_suggestion(\n+                param.span,\n+                \"consider restricting this bound\",\n+                format!(\"{}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if !generics.where_clause.predicates.is_empty() {\n+            // There is a `where` clause, so suggest expanding it:\n+            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+            err.span_suggestion(\n+                generics.where_clause.span().unwrap().shrink_to_hi(),\n+                &format!(\"consider further restricting type parameter `{}`\", param_name),\n+                format!(\", {}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            // If there is no `where` clause lean towards constraining to the\n+            // type parameter:\n+            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+            let sp = param.span.with_hi(span.hi());\n+            let span = source_map.span_through_char(sp, ':');\n+            if sp != param.span && sp != span {\n+                // Only suggest if we have high certainty that the span\n+                // covers the colon in `foo<T: Trait>`.\n+                err.span_suggestion(\n+                    span,\n+                    restrict_msg,\n+                    format!(\"{}: {} + \", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    param.span,\n+                    &format!(\"consider adding a `where {}: {}` bound\", param_name, constraint),\n+                );\n+            }\n+        }\n+        return true;\n+    }\n+    false\n+}\n+\n+/// Collect all the returned expressions within the input expression.\n+/// Used to point at the return spans when we want to suggest some change to them.\n+struct ReturnsVisitor<'v>(Vec<&'v hir::Expr<'v>>);\n+\n+impl<'v> Visitor<'v> for ReturnsVisitor<'v> {\n+    type Map = rustc::hir::map::Map<'v>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<'_, Self::Map> {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+        if let hir::ExprKind::Ret(Some(ex)) = ex.kind {\n+            self.0.push(ex);\n+        }\n+        hir::intravisit::walk_expr(self, ex);\n+    }\n+\n+    fn visit_body(&mut self, body: &'v hir::Body<'v>) {\n+        if body.generator_kind().is_none() {\n+            if let hir::ExprKind::Block(block, None) = body.value.kind {\n+                if let Some(expr) = block.expr {\n+                    self.0.push(expr);\n+                }\n+            }\n+        }\n+        hir::intravisit::walk_body(self, body);\n+    }\n+}"}, {"sha": "2e5da2b038254f7ab45131821d959b34b13d29c0", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -155,8 +155,8 @@ pub struct ObligationCause<'tcx> {\n     pub code: ObligationCauseCode<'tcx>,\n }\n \n-impl<'tcx> ObligationCause<'tcx> {\n-    pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n+impl ObligationCause<'_> {\n+    pub fn span(&self, tcx: TyCtxt<'_>) -> Span {\n         match self.code {\n             ObligationCauseCode::CompareImplMethodObligation { .. }\n             | ObligationCauseCode::MainFunctionType\n@@ -1171,6 +1171,17 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n+impl ObligationCauseCode<'_> {\n+    // Return the base obligation, ignoring derived obligations.\n+    pub fn peel_derives(&self) -> &Self {\n+        let mut base_cause = self;\n+        while let BuiltinDerivedObligation(cause) | ImplDerivedObligation(cause) = base_cause {\n+            base_cause = &cause.parent_code;\n+        }\n+        base_cause\n+    }\n+}\n+\n impl<'tcx, N> Vtable<'tcx, N> {\n     pub fn nested_obligations(self) -> Vec<N> {\n         match self {"}, {"sha": "217ca0ca3f6f51d38e464b578ddadaaf16593370", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -244,9 +244,9 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(ref inner, ..) => {\n                 if let Some(principal) = inner.principal() {\n-                    format!(\"trait `{}`\", tcx.def_path_str(principal.def_id())).into()\n+                    format!(\"trait object `dyn {}`\", tcx.def_path_str(principal.def_id())).into()\n                 } else {\n-                    \"trait\".into()\n+                    \"trait object\".into()\n                 }\n             }\n             ty::Closure(..) => \"closure\".into(),"}, {"sha": "2866a1624de5b8686d3d326b1157f1285c34987a", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -909,18 +909,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_expr_asm(&mut self, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n         let inner = hir::InlineAsmInner {\n-            inputs: asm.inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n+            inputs: asm.inputs.iter().map(|&(c, _)| c).collect(),\n             outputs: asm\n                 .outputs\n                 .iter()\n                 .map(|out| hir::InlineAsmOutput {\n-                    constraint: out.constraint.clone(),\n+                    constraint: out.constraint,\n                     is_rw: out.is_rw,\n                     is_indirect: out.is_indirect,\n                     span: out.expr.span,\n                 })\n                 .collect(),\n-            asm: asm.asm.clone(),\n+            asm: asm.asm,\n             asm_str_style: asm.asm_str_style,\n             clobbers: asm.clobbers.clone().into(),\n             volatile: asm.volatile,"}, {"sha": "9226f458165066992215559da8d395550a833f26", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -1608,7 +1608,7 @@ impl<'a> TraitDef<'a> {\n                 } else {\n                     ast::BindingMode::ByRef(mutbl)\n                 };\n-                cx.pat(path.span, PatKind::Ident(binding_mode, (*path).clone(), None))\n+                cx.pat(path.span, PatKind::Ident(binding_mode, *path, None))\n             })\n             .collect()\n     }"}, {"sha": "180ccb15977dd5126b2b9617f75efbedb166fe1f", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -414,6 +414,7 @@ E0742: include_str!(\"./error_codes/E0742.md\"),\n E0743: include_str!(\"./error_codes/E0743.md\"),\n E0744: include_str!(\"./error_codes/E0744.md\"),\n E0745: include_str!(\"./error_codes/E0745.md\"),\n+E0746: include_str!(\"./error_codes/E0746.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "16b2722f0eac2b47519db7523443dc15c2eb87f0", "filename": "src/librustc_error_codes/error_codes/E0746.md", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -0,0 +1,138 @@\n+Return types cannot be `dyn Trait`s as they must be `Sized`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0277\n+# // FIXME: after E0746 is in beta, change the above\n+trait T {\n+    fn bar(&self);\n+}\n+struct S(usize);\n+impl T for S {\n+    fn bar(&self) {}\n+}\n+\n+// Having the trait `T` as return type is invalid because\n+// unboxed trait objects do not have a statically known size:\n+fn foo() -> dyn T {\n+    S(42)\n+}\n+```\n+\n+To avoid the error there are a couple of options.\n+\n+If there is a single type involved, you can use [`impl Trait`]:\n+\n+```\n+# trait T {\n+#     fn bar(&self);\n+# }\n+# struct S(usize);\n+# impl T for S {\n+#     fn bar(&self) {}\n+# }\n+// The compiler will select `S(usize)` as the materialized return type of this\n+// function, but callers will only know that the return type implements `T`.\n+fn foo() -> impl T {\n+    S(42)\n+}\n+```\n+\n+If there are multiple types involved, the only way you care to interact with\n+them is through the trait's interface, and having to rely on dynamic dispatch\n+is acceptable, then you can use [trait objects] with `Box`, or other container\n+types like `Rc` or `Arc`:\n+\n+```\n+# trait T {\n+#     fn bar(&self);\n+# }\n+# struct S(usize);\n+# impl T for S {\n+#     fn bar(&self) {}\n+# }\n+struct O(&'static str);\n+impl T for O {\n+    fn bar(&self) {}\n+}\n+\n+// This now returns a \"trait object\" and callers are only be able to access\n+// associated items from `T`.\n+fn foo(x: bool) -> Box<dyn T> {\n+    if x {\n+        Box::new(S(42))\n+    } else {\n+        Box::new(O(\"val\"))\n+    }\n+}\n+```\n+\n+Finally, if you wish to still be able to access the original type, you can\n+create a new `enum` with a variant for each type:\n+\n+```\n+# trait T {\n+#     fn bar(&self);\n+# }\n+# struct S(usize);\n+# impl T for S {\n+#     fn bar(&self) {}\n+# }\n+# struct O(&'static str);\n+# impl T for O {\n+#     fn bar(&self) {}\n+# }\n+enum E {\n+    S(S),\n+    O(O),\n+}\n+\n+// The caller can access the original types directly, but it needs to match on\n+// the returned `enum E`.\n+fn foo(x: bool) -> E {\n+    if x {\n+        E::S(S(42))\n+    } else {\n+        E::O(O(\"val\"))\n+    }\n+}\n+```\n+\n+You can even implement the `trait` on the returned `enum` so the callers\n+*don't* have to match on the returned value to invoke the associated items:\n+\n+```\n+# trait T {\n+#     fn bar(&self);\n+# }\n+# struct S(usize);\n+# impl T for S {\n+#     fn bar(&self) {}\n+# }\n+# struct O(&'static str);\n+# impl T for O {\n+#     fn bar(&self) {}\n+# }\n+# enum E {\n+#     S(S),\n+#     O(O),\n+# }\n+impl T for E {\n+    fn bar(&self) {\n+        match self {\n+            E::S(s) => s.bar(),\n+            E::O(o) => o.bar(),\n+        }\n+    }\n+}\n+```\n+\n+If you decide to use trait objects, be aware that these rely on\n+[dynamic dispatch], which has performance implications, as the compiler needs\n+to emit code that will figure out which method to call *at runtime* instead of\n+during compilation. Using trait objects we are trading flexibility for\n+performance.\n+\n+[`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits\n+[trait objects]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n+[dynamic dispatch]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch"}, {"sha": "009ab6ac5b12f90ea37822a2ac6d7e05a546799b", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -196,7 +196,7 @@ impl AnnotateSnippetEmitterWriter {\n     ) {\n         let converter = DiagnosticConverter {\n             source_map: self.source_map.clone(),\n-            level: level.clone(),\n+            level: *level,\n             message,\n             code: code.clone(),\n             msp: msp.clone(),"}, {"sha": "5c1d600c837c4b07692683b522e6cf3bc5acd0eb", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -377,6 +377,13 @@ pub enum GenericBound<'hir> {\n }\n \n impl GenericBound<'_> {\n+    pub fn trait_def_id(&self) -> Option<DefId> {\n+        match self {\n+            GenericBound::Trait(data, _) => Some(data.trait_ref.trait_def_id()),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn span(&self) -> Span {\n         match self {\n             &GenericBound::Trait(ref t, ..) => t.span,"}, {"sha": "87f39dedd02734331310758d29aab7753f81d091", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -236,7 +236,7 @@ fn encode_work_product_index(\n     let serialized_products: Vec<_> = work_products\n         .iter()\n         .map(|(id, work_product)| SerializedWorkProduct {\n-            id: id.clone(),\n+            id: *id,\n             work_product: work_product.clone(),\n         })\n         .collect();"}, {"sha": "42ec8787cb2878a51391110e70f0ef02b1600972", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -245,7 +245,7 @@ impl LintStore {\n \n     pub fn register_renamed(&mut self, old_name: &str, new_name: &str) {\n         let target = match self.by_name.get(new_name) {\n-            Some(&Id(lint_id)) => lint_id.clone(),\n+            Some(&Id(lint_id)) => lint_id,\n             _ => bug!(\"invalid lint renaming of {} to {}\", old_name, new_name),\n         };\n         self.by_name.insert(old_name.to_string(), Renamed(new_name.to_string(), target));"}, {"sha": "6280121f655660fab155a744edb8a5b1a6144446", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -840,7 +840,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n-            true => self.root.proc_macro_stability.clone(),\n+            true => self.root.proc_macro_stability,\n             false => self.root.per_def.stability.get(self, id).map(|stab| stab.decode(self)),\n         }\n     }"}, {"sha": "8ad92ce75a851645a6a690c5a0b4c8bfda8ff4fd", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -504,7 +504,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             },\n             proc_macro_data,\n             proc_macro_stability: if is_proc_macro {\n-                tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).map(|stab| stab.clone())\n+                tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).map(|stab| *stab)\n             } else {\n                 None\n             },"}, {"sha": "9d5cf3ec4bec0e8c2f962d85123fc020f6654dd8", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -200,8 +200,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n                 region,\n                 reserve_location: location,\n                 activation_location: TwoPhaseActivation::NotTwoPhase,\n-                borrowed_place: borrowed_place.clone(),\n-                assigned_place: assigned_place.clone(),\n+                borrowed_place: *borrowed_place,\n+                assigned_place: *assigned_place,\n             };\n             let idx = self.idx_vec.push(borrow);\n             self.location_map.insert(location, idx);"}, {"sha": "0bcdf9ae3c1f20866644e42a44dbfb534a32c90a", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -580,10 +580,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n                 Ok((layout.size, layout.align.abi))\n             }\n-            Some(GlobalAlloc::Memory(alloc)) =>\n-            // Need to duplicate the logic here, because the global allocations have\n-            // different associated types than the interpreter-local ones.\n-            {\n+            Some(GlobalAlloc::Memory(alloc)) => {\n+                // Need to duplicate the logic here, because the global allocations have\n+                // different associated types than the interpreter-local ones.\n                 Ok((alloc.size, alloc.align))\n             }\n             Some(GlobalAlloc::Function(_)) => bug!(\"We already checked function pointers above\"),"}, {"sha": "d1c08da6cbee55da6b4c287974897bdcb9ad121b", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -684,16 +684,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             let variant_index = variants_start\n                                 .checked_add(variant_index_relative)\n                                 .expect(\"oveflow computing absolute variant idx\");\n-                            assert!(\n-                                (variant_index as usize)\n-                                    < rval\n-                                        .layout\n-                                        .ty\n-                                        .ty_adt_def()\n-                                        .expect(\"tagged layout for non adt\")\n-                                        .variants\n-                                        .len()\n-                            );\n+                            let variants_len = rval\n+                                .layout\n+                                .ty\n+                                .ty_adt_def()\n+                                .expect(\"tagged layout for non adt\")\n+                                .variants\n+                                .len();\n+                            assert!((variant_index as usize) < variants_len);\n                             (u128::from(variant_index), VariantIdx::from_u32(variant_index))\n                         } else {\n                             (u128::from(dataful_variant.as_u32()), dataful_variant)"}, {"sha": "4f96cb698915d25146c45e2bff6d9528bf49e772", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -432,12 +432,11 @@ where\n             // happens at run-time so that's okay.\n             let align = match self.size_and_align_of(base.meta, field_layout)? {\n                 Some((_, align)) => align,\n-                None if offset == Size::ZERO =>\n-                // An extern type at offset 0, we fall back to its static alignment.\n-                // FIXME: Once we have made decisions for how to handle size and alignment\n-                // of `extern type`, this should be adapted.  It is just a temporary hack\n-                // to get some code to work that probably ought to work.\n-                {\n+                None if offset == Size::ZERO => {\n+                    // An extern type at offset 0, we fall back to its static alignment.\n+                    // FIXME: Once we have made decisions for how to handle size and alignment\n+                    // of `extern type`, this should be adapted.  It is just a temporary hack\n+                    // to get some code to work that probably ought to work.\n                     field_layout.align.abi\n                 }\n                 None => bug!(\"Cannot compute offset for extern type field at non-0 offset\"),"}, {"sha": "aa2b3040a716f49a757207d8c33b88d1bd3386e5", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -114,14 +114,11 @@ fn write_path(out: &mut String, path: &Vec<PathElem>) {\n             ClosureVar(name) => write!(out, \".<closure-var({})>\", name),\n             TupleElem(idx) => write!(out, \".{}\", idx),\n             ArrayElem(idx) => write!(out, \"[{}]\", idx),\n-            Deref =>\n-            // This does not match Rust syntax, but it is more readable for long paths -- and\n+            // `.<deref>` does not match Rust syntax, but it is more readable for long paths -- and\n             // some of the other items here also are not Rust syntax.  Actually we can't\n             // even use the usual syntax because we are just showing the projections,\n             // not the root.\n-            {\n-                write!(out, \".<deref>\")\n-            }\n+            Deref => write!(out, \".<deref>\"),\n             Tag => write!(out, \".<enum-tag>\"),\n             DynDowncast => write!(out, \".<dyn-downcast>\"),\n         }\n@@ -206,9 +203,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n             ty::Adt(def, ..) if def.is_enum() => {\n                 // we might be projecting *to* a variant, or to a field *in*a variant.\n                 match layout.variants {\n-                    layout::Variants::Single { index } =>\n-                    // Inside a variant\n-                    {\n+                    layout::Variants::Single { index } => {\n+                        // Inside a variant\n                         PathElem::Field(def.variants[index].fields[field].ident.name)\n                     }\n                     _ => bug!(),"}, {"sha": "44ff493b5b4f0370f99bc1047e2af32b8521f2ea", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -65,7 +65,7 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n         } else if cx.body_owner_kind.is_fn_or_closure() {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n-            let fn_sig = cx.tables().liberated_fn_sigs()[id].clone();\n+            let fn_sig = cx.tables().liberated_fn_sigs()[id];\n             let fn_def_id = tcx.hir().local_def_id(id);\n \n             let ty = tcx.type_of(fn_def_id);"}, {"sha": "5ec7e73f873e0f0e8247cdd630a22a34d1bda241", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 // deprecated_since and its reason.\n                 if let Some(parent_stab) = self.parent_stab {\n                     if parent_stab.rustc_depr.is_some() && stab.rustc_depr.is_none() {\n-                        stab.rustc_depr = parent_stab.rustc_depr.clone()\n+                        stab.rustc_depr = parent_stab.rustc_depr\n                     }\n                 }\n "}, {"sha": "a433ae8ed676a5f26aee53da29efed1482b7ec1c", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 160, "deletions": 2, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -8,7 +8,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n-use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n+use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::SourceMap;\n@@ -20,8 +20,9 @@ use syntax::util::lev_distance::find_best_match_for_name;\n \n use crate::imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n use crate::path_names_to_string;\n-use crate::VisResolutionError;\n+use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n+use crate::{NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n use rustc_error_codes::*;\n@@ -802,6 +803,163 @@ impl<'a> Resolver<'a> {\n         }\n         false\n     }\n+\n+    fn binding_description(&self, b: &NameBinding<'_>, ident: Ident, from_prelude: bool) -> String {\n+        let res = b.res();\n+        if b.span.is_dummy() {\n+            let add_built_in = match b.res() {\n+                // These already contain the \"built-in\" prefix or look bad with it.\n+                Res::NonMacroAttr(..) | Res::PrimTy(..) | Res::ToolMod => false,\n+                _ => true,\n+            };\n+            let (built_in, from) = if from_prelude {\n+                (\"\", \" from prelude\")\n+            } else if b.is_extern_crate()\n+                && !b.is_import()\n+                && self.session.opts.externs.get(&ident.as_str()).is_some()\n+            {\n+                (\"\", \" passed with `--extern`\")\n+            } else if add_built_in {\n+                (\" built-in\", \"\")\n+            } else {\n+                (\"\", \"\")\n+            };\n+\n+            let article = if built_in.is_empty() { res.article() } else { \"a\" };\n+            format!(\n+                \"{a}{built_in} {thing}{from}\",\n+                a = article,\n+                thing = res.descr(),\n+                built_in = built_in,\n+                from = from\n+            )\n+        } else {\n+            let introduced = if b.is_import() { \"imported\" } else { \"defined\" };\n+            format!(\"the {thing} {introduced} here\", thing = res.descr(), introduced = introduced)\n+        }\n+    }\n+\n+    crate fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError<'_>) {\n+        let AmbiguityError { kind, ident, b1, b2, misc1, misc2 } = *ambiguity_error;\n+        let (b1, b2, misc1, misc2, swapped) = if b2.span.is_dummy() && !b1.span.is_dummy() {\n+            // We have to print the span-less alternative first, otherwise formatting looks bad.\n+            (b2, b1, misc2, misc1, true)\n+        } else {\n+            (b1, b2, misc1, misc2, false)\n+        };\n+\n+        let mut err = struct_span_err!(\n+            self.session,\n+            ident.span,\n+            E0659,\n+            \"`{ident}` is ambiguous ({why})\",\n+            ident = ident,\n+            why = kind.descr()\n+        );\n+        err.span_label(ident.span, \"ambiguous name\");\n+\n+        let mut could_refer_to = |b: &NameBinding<'_>, misc: AmbiguityErrorMisc, also: &str| {\n+            let what = self.binding_description(b, ident, misc == AmbiguityErrorMisc::FromPrelude);\n+            let note_msg = format!(\n+                \"`{ident}` could{also} refer to {what}\",\n+                ident = ident,\n+                also = also,\n+                what = what\n+            );\n+\n+            let thing = b.res().descr();\n+            let mut help_msgs = Vec::new();\n+            if b.is_glob_import()\n+                && (kind == AmbiguityKind::GlobVsGlob\n+                    || kind == AmbiguityKind::GlobVsExpanded\n+                    || kind == AmbiguityKind::GlobVsOuter && swapped != also.is_empty())\n+            {\n+                help_msgs.push(format!(\n+                    \"consider adding an explicit import of \\\n+                     `{ident}` to disambiguate\",\n+                    ident = ident\n+                ))\n+            }\n+            if b.is_extern_crate() && ident.span.rust_2018() {\n+                help_msgs.push(format!(\n+                    \"use `::{ident}` to refer to this {thing} unambiguously\",\n+                    ident = ident,\n+                    thing = thing,\n+                ))\n+            }\n+            if misc == AmbiguityErrorMisc::SuggestCrate {\n+                help_msgs.push(format!(\n+                    \"use `crate::{ident}` to refer to this {thing} unambiguously\",\n+                    ident = ident,\n+                    thing = thing,\n+                ))\n+            } else if misc == AmbiguityErrorMisc::SuggestSelf {\n+                help_msgs.push(format!(\n+                    \"use `self::{ident}` to refer to this {thing} unambiguously\",\n+                    ident = ident,\n+                    thing = thing,\n+                ))\n+            }\n+\n+            err.span_note(b.span, &note_msg);\n+            for (i, help_msg) in help_msgs.iter().enumerate() {\n+                let or = if i == 0 { \"\" } else { \"or \" };\n+                err.help(&format!(\"{}{}\", or, help_msg));\n+            }\n+        };\n+\n+        could_refer_to(b1, misc1, \"\");\n+        could_refer_to(b2, misc2, \" also\");\n+        err.emit();\n+    }\n+\n+    crate fn report_privacy_error(&self, privacy_error: &PrivacyError<'_>) {\n+        let PrivacyError { ident, binding, .. } = *privacy_error;\n+        let session = &self.session;\n+        let mk_struct_span_error = |is_constructor| {\n+            let mut descr = binding.res().descr().to_string();\n+            if is_constructor {\n+                descr += \" constructor\";\n+            }\n+            if binding.is_import() {\n+                descr += \" import\";\n+            }\n+\n+            let mut err =\n+                struct_span_err!(session, ident.span, E0603, \"{} `{}` is private\", descr, ident);\n+\n+            err.span_label(ident.span, &format!(\"this {} is private\", descr));\n+            err.span_note(\n+                session.source_map().def_span(binding.span),\n+                &format!(\"the {} `{}` is defined here\", descr, ident),\n+            );\n+\n+            err\n+        };\n+\n+        let mut err = if let NameBindingKind::Res(\n+            Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), ctor_def_id),\n+            _,\n+        ) = binding.kind\n+        {\n+            let def_id = (&*self).parent(ctor_def_id).expect(\"no parent for a constructor\");\n+            if let Some(fields) = self.field_names.get(&def_id) {\n+                let mut err = mk_struct_span_error(true);\n+                let first_field = fields.first().expect(\"empty field list in the map\");\n+                err.span_label(\n+                    fields.iter().fold(first_field.span, |acc, field| acc.to(field.span)),\n+                    \"a constructor is private if any of the fields is private\",\n+                );\n+                err\n+            } else {\n+                mk_struct_span_error(false)\n+            }\n+        } else {\n+            mk_struct_span_error(false)\n+        };\n+\n+        err.emit();\n+    }\n }\n \n impl<'a, 'b> ImportResolver<'a, 'b> {"}, {"sha": "9f459834175c126a2584b81db962baefae7de960", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -319,7 +319,11 @@ impl<'a> Resolver<'a> {\n                        // Remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n                        !(self.last_import_segment && binding.is_extern_crate())\n                         {\n-                            self.privacy_errors.push(PrivacyError(path_span, ident, binding));\n+                            self.privacy_errors.push(PrivacyError {\n+                                ident,\n+                                binding,\n+                                dedup_span: path_span,\n+                            });\n                         }\n \n                         Ok(binding)"}, {"sha": "60a0049f5da379c29d990ca6913dc4fcb4e20c11", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 10, "deletions": 152, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,12 +2,9 @@\n //!\n //! Module structure of the crate is built here.\n //! Paths in macros, imports, expressions, types, patterns are resolved here.\n-//! Label names are resolved here as well.\n+//! Label and lifetime names are resolved here as well.\n //!\n //! Type-relative name resolution (methods, fields, associated items) happens in `librustc_typeck`.\n-//! Lifetime names are resolved in `librustc/middle/resolve_lifetime.rs`.\n-\n-// ignore-tidy-filelength\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(bool_to_option)]\n@@ -33,7 +30,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def::Namespace::*;\n-use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n+use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy::{self, Bool, Char, Float, Int, Str, Uint};\n use rustc_hir::{GlobMap, TraitMap};\n@@ -604,7 +601,11 @@ impl<'a> NameBindingKind<'a> {\n     }\n }\n \n-struct PrivacyError<'a>(Span, Ident, &'a NameBinding<'a>);\n+struct PrivacyError<'a> {\n+    ident: Ident,\n+    binding: &'a NameBinding<'a>,\n+    dedup_span: Span,\n+}\n \n struct UseError<'a> {\n     err: DiagnosticBuilder<'a>,\n@@ -2446,115 +2447,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn binding_description(&self, b: &NameBinding<'_>, ident: Ident, from_prelude: bool) -> String {\n-        let res = b.res();\n-        if b.span.is_dummy() {\n-            let add_built_in = match b.res() {\n-                // These already contain the \"built-in\" prefix or look bad with it.\n-                Res::NonMacroAttr(..) | Res::PrimTy(..) | Res::ToolMod => false,\n-                _ => true,\n-            };\n-            let (built_in, from) = if from_prelude {\n-                (\"\", \" from prelude\")\n-            } else if b.is_extern_crate()\n-                && !b.is_import()\n-                && self.session.opts.externs.get(&ident.as_str()).is_some()\n-            {\n-                (\"\", \" passed with `--extern`\")\n-            } else if add_built_in {\n-                (\" built-in\", \"\")\n-            } else {\n-                (\"\", \"\")\n-            };\n-\n-            let article = if built_in.is_empty() { res.article() } else { \"a\" };\n-            format!(\n-                \"{a}{built_in} {thing}{from}\",\n-                a = article,\n-                thing = res.descr(),\n-                built_in = built_in,\n-                from = from\n-            )\n-        } else {\n-            let introduced = if b.is_import() { \"imported\" } else { \"defined\" };\n-            format!(\"the {thing} {introduced} here\", thing = res.descr(), introduced = introduced)\n-        }\n-    }\n-\n-    fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError<'_>) {\n-        let AmbiguityError { kind, ident, b1, b2, misc1, misc2 } = *ambiguity_error;\n-        let (b1, b2, misc1, misc2, swapped) = if b2.span.is_dummy() && !b1.span.is_dummy() {\n-            // We have to print the span-less alternative first, otherwise formatting looks bad.\n-            (b2, b1, misc2, misc1, true)\n-        } else {\n-            (b1, b2, misc1, misc2, false)\n-        };\n-\n-        let mut err = struct_span_err!(\n-            self.session,\n-            ident.span,\n-            E0659,\n-            \"`{ident}` is ambiguous ({why})\",\n-            ident = ident,\n-            why = kind.descr()\n-        );\n-        err.span_label(ident.span, \"ambiguous name\");\n-\n-        let mut could_refer_to = |b: &NameBinding<'_>, misc: AmbiguityErrorMisc, also: &str| {\n-            let what = self.binding_description(b, ident, misc == AmbiguityErrorMisc::FromPrelude);\n-            let note_msg = format!(\n-                \"`{ident}` could{also} refer to {what}\",\n-                ident = ident,\n-                also = also,\n-                what = what\n-            );\n-\n-            let thing = b.res().descr();\n-            let mut help_msgs = Vec::new();\n-            if b.is_glob_import()\n-                && (kind == AmbiguityKind::GlobVsGlob\n-                    || kind == AmbiguityKind::GlobVsExpanded\n-                    || kind == AmbiguityKind::GlobVsOuter && swapped != also.is_empty())\n-            {\n-                help_msgs.push(format!(\n-                    \"consider adding an explicit import of \\\n-                     `{ident}` to disambiguate\",\n-                    ident = ident\n-                ))\n-            }\n-            if b.is_extern_crate() && ident.span.rust_2018() {\n-                help_msgs.push(format!(\n-                    \"use `::{ident}` to refer to this {thing} unambiguously\",\n-                    ident = ident,\n-                    thing = thing,\n-                ))\n-            }\n-            if misc == AmbiguityErrorMisc::SuggestCrate {\n-                help_msgs.push(format!(\n-                    \"use `crate::{ident}` to refer to this {thing} unambiguously\",\n-                    ident = ident,\n-                    thing = thing,\n-                ))\n-            } else if misc == AmbiguityErrorMisc::SuggestSelf {\n-                help_msgs.push(format!(\n-                    \"use `self::{ident}` to refer to this {thing} unambiguously\",\n-                    ident = ident,\n-                    thing = thing,\n-                ))\n-            }\n-\n-            err.span_note(b.span, &note_msg);\n-            for (i, help_msg) in help_msgs.iter().enumerate() {\n-                let or = if i == 0 { \"\" } else { \"or \" };\n-                err.help(&format!(\"{}{}\", or, help_msg));\n-            }\n-        };\n-\n-        could_refer_to(b1, misc1, \"\");\n-        could_refer_to(b2, misc2, \" also\");\n-        err.emit();\n-    }\n-\n     fn report_errors(&mut self, krate: &Crate) {\n         self.report_with_use_injections(krate);\n \n@@ -2575,43 +2467,9 @@ impl<'a> Resolver<'a> {\n         }\n \n         let mut reported_spans = FxHashSet::default();\n-        for &PrivacyError(dedup_span, ident, binding) in &self.privacy_errors {\n-            if reported_spans.insert(dedup_span) {\n-                let session = &self.session;\n-                let mk_struct_span_error = |is_constructor| {\n-                    struct_span_err!(\n-                        session,\n-                        ident.span,\n-                        E0603,\n-                        \"{}{} `{}` is private\",\n-                        binding.res().descr(),\n-                        if is_constructor { \" constructor\" } else { \"\" },\n-                        ident.name,\n-                    )\n-                };\n-\n-                let mut err = if let NameBindingKind::Res(\n-                    Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), ctor_def_id),\n-                    _,\n-                ) = binding.kind\n-                {\n-                    let def_id = (&*self).parent(ctor_def_id).expect(\"no parent for a constructor\");\n-                    if let Some(fields) = self.field_names.get(&def_id) {\n-                        let mut err = mk_struct_span_error(true);\n-                        let first_field = fields.first().expect(\"empty field list in the map\");\n-                        err.span_label(\n-                            fields.iter().fold(first_field.span, |acc, field| acc.to(field.span)),\n-                            \"a constructor is private if any of the fields is private\",\n-                        );\n-                        err\n-                    } else {\n-                        mk_struct_span_error(false)\n-                    }\n-                } else {\n-                    mk_struct_span_error(false)\n-                };\n-\n-                err.emit();\n+        for error in &self.privacy_errors {\n+            if reported_spans.insert(error.dedup_span) {\n+                self.report_privacy_error(error);\n             }\n         }\n     }"}, {"sha": "0b18352df330764c0d37dd468494b300e8e3c1df", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -400,7 +400,7 @@ impl context::UnificationOps<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n         &mut self,\n         value: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n     ) -> (Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>, UniverseMap) {\n-        (value.clone(), UniverseMap)\n+        (*value, UniverseMap)\n     }\n \n     fn invert_goal("}, {"sha": "084e6c8d083c5be9999ec2f02e17d1dfc1ab238b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n             ty::FnPtr(sig) => {\n-                let expected_sig = ExpectedSig { cause_span: None, sig: sig.skip_binder().clone() };\n+                let expected_sig = ExpectedSig { cause_span: None, sig: *sig.skip_binder() };\n                 (Some(expected_sig), Some(ty::ClosureKind::Fn))\n             }\n             _ => (None, None),"}, {"sha": "a32fbff7bfe2df233b19dffc9c691a88395687ac", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 99, "deletions": 10, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -50,10 +50,12 @@\n //! sort of a minor point so I've opted to leave it for later -- after all,\n //! we may want to adjust precisely when coercions occur.\n \n+use crate::astconv::AstConv;\n use crate::check::{FnCtxt, Needs};\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::infer::{Coercion, InferOk, InferResult};\n use rustc::session::parse::feature_err;\n+use rustc::traits::object_safety_violations;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -67,8 +69,8 @@ use rustc_error_codes::*;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_span;\n use rustc_span::symbol::sym;\n+use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n@@ -1222,6 +1224,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 };\n \n                 let mut err;\n+                let mut unsized_return = false;\n                 match cause.code {\n                     ObligationCauseCode::ReturnNoExpression => {\n                         err = struct_span_err!(\n@@ -1243,6 +1246,9 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                             parent_id,\n                             expression.map(|expr| (expr, blk_id)),\n                         );\n+                        if !fcx.tcx.features().unsized_locals {\n+                            unsized_return = self.is_return_ty_unsized(fcx, blk_id);\n+                        }\n                     }\n                     ObligationCauseCode::ReturnValue(id) => {\n                         err = self.report_return_mismatched_types(\n@@ -1254,6 +1260,10 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                             id,\n                             None,\n                         );\n+                        if !fcx.tcx.features().unsized_locals {\n+                            let id = fcx.tcx.hir().get_parent_node(id);\n+                            unsized_return = self.is_return_ty_unsized(fcx, id);\n+                        }\n                     }\n                     _ => {\n                         err = fcx.report_mismatched_types(cause, expected, found, coercion_error);\n@@ -1282,7 +1292,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     .filter(|e| fcx.is_assign_to_bool(e, self.expected_ty()))\n                     .is_some();\n \n-                err.emit_unless(assign_to_bool);\n+                err.emit_unless(assign_to_bool || unsized_return);\n \n                 self.final_ty = Some(fcx.tcx.types.err);\n             }\n@@ -1302,7 +1312,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         let mut err = fcx.report_mismatched_types(cause, expected, found, ty_err);\n \n         let mut pointing_at_return_type = false;\n-        let mut return_sp = None;\n+        let mut fn_output = None;\n \n         // Verify that this is a tail expression of a function, otherwise the\n         // label pointing out the cause for the type coercion will be wrong\n@@ -1339,19 +1349,98 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 );\n             }\n             if !pointing_at_return_type {\n-                return_sp = Some(fn_decl.output.span()); // `impl Trait` return type\n+                fn_output = Some(&fn_decl.output); // `impl Trait` return type\n             }\n         }\n-        if let (Some(sp), Some(return_sp)) = (fcx.ret_coercion_span.borrow().as_ref(), return_sp) {\n-            err.span_label(return_sp, \"expected because this return type...\");\n-            err.span_label( *sp, format!(\n-                \"...is found to be `{}` here\",\n-                fcx.resolve_vars_with_obligations(expected),\n-            ));\n+        if let (Some(sp), Some(fn_output)) = (fcx.ret_coercion_span.borrow().as_ref(), fn_output) {\n+            self.add_impl_trait_explanation(&mut err, fcx, expected, *sp, fn_output);\n         }\n         err\n     }\n \n+    fn add_impl_trait_explanation<'a>(\n+        &self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        expected: Ty<'tcx>,\n+        sp: Span,\n+        fn_output: &hir::FunctionRetTy<'_>,\n+    ) {\n+        let return_sp = fn_output.span();\n+        err.span_label(return_sp, \"expected because this return type...\");\n+        err.span_label(\n+            sp,\n+            format!(\"...is found to be `{}` here\", fcx.resolve_vars_with_obligations(expected)),\n+        );\n+        let impl_trait_msg = \"for information on `impl Trait`, see \\\n+                <https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                #returning-types-that-implement-traits>\";\n+        let trait_obj_msg = \"for information on trait objects, see \\\n+                <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n+                #using-trait-objects-that-allow-for-values-of-different-types>\";\n+        err.note(\"to return `impl Trait`, all returned values must be of the same type\");\n+        err.note(impl_trait_msg);\n+        let snippet = fcx\n+            .tcx\n+            .sess\n+            .source_map()\n+            .span_to_snippet(return_sp)\n+            .unwrap_or_else(|_| \"dyn Trait\".to_string());\n+        let mut snippet_iter = snippet.split_whitespace();\n+        let has_impl = snippet_iter.next().map_or(false, |s| s == \"impl\");\n+        // Only suggest `Box<dyn Trait>` if `Trait` in `impl Trait` is object safe.\n+        let mut is_object_safe = false;\n+        if let hir::FunctionRetTy::Return(ty) = fn_output {\n+            // Get the return type.\n+            if let hir::TyKind::Def(..) = ty.kind {\n+                let ty = AstConv::ast_ty_to_ty(fcx, ty);\n+                // Get the `impl Trait`'s `DefId`.\n+                if let ty::Opaque(def_id, _) = ty.kind {\n+                    let hir_id = fcx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n+                    // get the `Trait`'s `DefId`.\n+                    if let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) =\n+                        fcx.tcx.hir().expect_item(hir_id).kind\n+                    {\n+                        // Are of this `impl Trait`'s traits object safe?\n+                        is_object_safe = bounds.iter().all(|bound| {\n+                            bound.trait_def_id().map_or(false, |def_id| {\n+                                object_safety_violations(fcx.tcx, def_id).is_empty()\n+                            })\n+                        })\n+                    }\n+                }\n+            }\n+        };\n+        if has_impl {\n+            if is_object_safe {\n+                err.help(&format!(\n+                    \"you can instead return a boxed trait object using `Box<dyn {}>`\",\n+                    &snippet[5..]\n+                ));\n+            } else {\n+                err.help(&format!(\n+                    \"if the trait `{}` were object safe, you could return a boxed trait object\",\n+                    &snippet[5..]\n+                ));\n+            }\n+            err.note(trait_obj_msg);\n+        }\n+        err.help(\"alternatively, create a new `enum` with a variant for each returned type\");\n+    }\n+\n+    fn is_return_ty_unsized(&self, fcx: &FnCtxt<'a, 'tcx>, blk_id: hir::HirId) -> bool {\n+        if let Some((fn_decl, _)) = fcx.get_fn_decl(blk_id) {\n+            if let hir::FunctionRetTy::Return(ty) = fn_decl.output {\n+                let ty = AstConv::ast_ty_to_ty(fcx, ty);\n+                if let ty::Dynamic(..) = ty.kind {\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n     pub fn complete<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         if let Some(final_ty) = self.final_ty {\n             final_ty"}, {"sha": "dff68b9986cc99d228e247ae731ccef9d69be863", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 62, "deletions": 25, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -122,7 +122,7 @@ use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::{ExprKind, GenericArg, HirIdMap, ItemKind, Node, PatKind, QPath};\n+use rustc_hir::{ExprKind, GenericArg, HirIdMap, Item, ItemKind, Node, PatKind, QPath};\n use rustc_index::vec::Idx;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{original_sp, DUMMY_SP};\n@@ -2312,44 +2312,81 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n                 \"type has conflicting packed and align representation hints\"\n             )\n             .emit();\n-        } else if check_packed_inner(tcx, def_id, &mut Vec::new()) {\n-            struct_span_err!(\n-                tcx.sess,\n-                sp,\n-                E0588,\n-                \"packed type cannot transitively contain a `[repr(align)]` type\"\n-            )\n-            .emit();\n+        } else {\n+            if let Some(def_spans) = check_packed_inner(tcx, def_id, &mut vec![]) {\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    sp,\n+                    E0588,\n+                    \"packed type cannot transitively contain a `#[repr(align)]` type\"\n+                );\n+\n+                let hir = tcx.hir();\n+                if let Some(hir_id) = hir.as_local_hir_id(def_spans[0].0) {\n+                    if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n+                        err.span_note(\n+                            tcx.def_span(def_spans[0].0),\n+                            &format!(\"`{}` has a `#[repr(align)]` attribute\", ident),\n+                        );\n+                    }\n+                }\n+\n+                if def_spans.len() > 2 {\n+                    let mut first = true;\n+                    for (adt_def, span) in def_spans.iter().skip(1).rev() {\n+                        if let Some(hir_id) = hir.as_local_hir_id(*adt_def) {\n+                            if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n+                                err.span_note(\n+                                    *span,\n+                                    &if first {\n+                                        format!(\n+                                            \"`{}` contains a field of type `{}`\",\n+                                            tcx.type_of(def_id),\n+                                            ident\n+                                        )\n+                                    } else {\n+                                        format!(\"...which contains a field of type `{}`\", ident)\n+                                    },\n+                                );\n+                                first = false;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                err.emit();\n+            }\n         }\n     }\n }\n \n-fn check_packed_inner(tcx: TyCtxt<'_>, def_id: DefId, stack: &mut Vec<DefId>) -> bool {\n-    let t = tcx.type_of(def_id);\n-    if stack.contains(&def_id) {\n-        debug!(\"check_packed_inner: {:?} is recursive\", t);\n-        return false;\n-    }\n-    if let ty::Adt(def, substs) = t.kind {\n+fn check_packed_inner(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+    stack: &mut Vec<DefId>,\n+) -> Option<Vec<(DefId, Span)>> {\n+    if let ty::Adt(def, substs) = tcx.type_of(def_id).kind {\n         if def.is_struct() || def.is_union() {\n-            if tcx.adt_def(def.did).repr.align.is_some() {\n-                return true;\n+            if def.repr.align.is_some() {\n+                return Some(vec![(def.did, DUMMY_SP)]);\n             }\n-            // push struct def_id before checking fields\n+\n             stack.push(def_id);\n             for field in &def.non_enum_variant().fields {\n-                let f = field.ty(tcx, substs);\n-                if let ty::Adt(def, _) = f.kind {\n-                    if check_packed_inner(tcx, def.did, stack) {\n-                        return true;\n+                if let ty::Adt(def, _) = field.ty(tcx, substs).kind {\n+                    if !stack.contains(&def.did) {\n+                        if let Some(mut defs) = check_packed_inner(tcx, def.did, stack) {\n+                            defs.push((def.did, field.ident.span));\n+                            return Some(defs);\n+                        }\n                     }\n                 }\n             }\n-            // only need to pop if not early out\n             stack.pop();\n         }\n     }\n-    false\n+\n+    None\n }\n \n /// Emit an error when encountering more or less than one variant in a transparent enum."}, {"sha": "f37f6921cebaf4f5c3a1360237be99c8a0cf4136", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         //  constraint, and add it to our list. Since we make sure to never re-add\n         //  deleted items, this process will always finish.\n         while !vid_map.is_empty() {\n-            let target = vid_map.keys().next().expect(\"Keys somehow empty\").clone();\n+            let target = *vid_map.keys().next().expect(\"Keys somehow empty\");\n             let deps = vid_map.remove(&target).expect(\"Entry somehow missing\");\n \n             for smaller in deps.smaller.iter() {"}, {"sha": "e99473177e8384ce3603c32138358fd29db661da", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -153,12 +153,13 @@ pub fn test_main_static_abort(tests: &[&TestDescAndFn]) {\n     // If we're being run in SpawnedSecondary mode, run the test here. run_test\n     // will then exit the process.\n     if let Ok(name) = env::var(SECONDARY_TEST_INVOKER_VAR) {\n+        env::remove_var(SECONDARY_TEST_INVOKER_VAR);\n         let test = tests\n             .iter()\n             .filter(|test| test.desc.name.as_slice() == name)\n             .map(make_owned_test)\n             .next()\n-            .expect(\"couldn't find a test with the provided name\");\n+            .expect(&format!(\"couldn't find a test with the provided name '{}'\", name));\n         let TestDescAndFn { desc, testfn } = test;\n         let testfn = match testfn {\n             StaticTestFn(f) => f,\n@@ -485,9 +486,7 @@ pub fn run_test(\n         }\n         StaticBenchFn(benchfn) => {\n             // Benchmarks aren't expected to panic, so we run them all in-process.\n-            crate::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n-                (benchfn.clone())(harness)\n-            });\n+            crate::bench::benchmark(desc, monitor_ch, opts.nocapture, benchfn);\n         }\n         DynTestFn(f) => {\n             match strategy {"}, {"sha": "f59dbc263840077dbb02bb71b9717ec71494230f", "filename": "src/test/ui/async-await/issue-64130-4-async-move.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -1,8 +1,17 @@\n error: future cannot be sent between threads safely\n   --> $DIR/issue-64130-4-async-move.rs:15:17\n    |\n-LL | pub fn foo() -> impl Future + Send {\n-   |                 ^^^^^^^^^^^^^^^^^^ future returned by `foo` is not `Send`\n+LL |   pub fn foo() -> impl Future + Send {\n+   |                   ^^^^^^^^^^^^^^^^^^ future returned by `foo` is not `Send`\n+...\n+LL | /     async move {\n+LL | |         match client.status() {\n+LL | |             200 => {\n+LL | |                 let _x = get().await;\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____- this returned value is of type `impl std::future::Future`\n    |\n    = help: the trait `std::marker::Sync` is not implemented for `(dyn std::any::Any + std::marker::Send + 'static)`\n note: future is not `Send` as this value is used across an await"}, {"sha": "44e5c6a99f7278afa26185f706b35b6134521964", "filename": "src/test/ui/coercion/coerce-expect-unsized-ascribed.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-expect-unsized-ascribed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-expect-unsized-ascribed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-expect-unsized-ascribed.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -29,7 +29,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:13:13\n    |\n LL |     let _ = box { |x| (x as u8) }: Box<dyn Fn(i32) -> _>;\n-   |             ^^^^^^^^^^^^^^^^^^^^^ expected trait `std::ops::Fn`, found closure\n+   |             ^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::ops::Fn`, found closure\n    |\n    = note: expected struct `std::boxed::Box<dyn std::ops::Fn(i32) -> u8>`\n               found struct `std::boxed::Box<[closure@$DIR/coerce-expect-unsized-ascribed.rs:13:19: 13:32]>`\n@@ -38,7 +38,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:14:13\n    |\n LL |     let _ = box if true { false } else { true }: Box<dyn Debug>;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait `std::fmt::Debug`, found `bool`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::fmt::Debug`, found `bool`\n    |\n    = note: expected struct `std::boxed::Box<dyn std::fmt::Debug>`\n               found struct `std::boxed::Box<bool>`\n@@ -47,7 +47,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:15:13\n    |\n LL |     let _ = box match true { true => 'a', false => 'b' }: Box<dyn Debug>;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait `std::fmt::Debug`, found `char`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::fmt::Debug`, found `char`\n    |\n    = note: expected struct `std::boxed::Box<dyn std::fmt::Debug>`\n               found struct `std::boxed::Box<char>`\n@@ -83,7 +83,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:21:13\n    |\n LL |     let _ = &{ |x| (x as u8) }: &dyn Fn(i32) -> _;\n-   |             ^^^^^^^^^^^^^^^^^^ expected trait `std::ops::Fn`, found closure\n+   |             ^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::ops::Fn`, found closure\n    |\n    = note: expected reference `&dyn std::ops::Fn(i32) -> u8`\n               found reference `&[closure@$DIR/coerce-expect-unsized-ascribed.rs:21:16: 21:29]`\n@@ -92,7 +92,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:22:13\n    |\n LL |     let _ = &if true { false } else { true }: &dyn Debug;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait `std::fmt::Debug`, found `bool`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::fmt::Debug`, found `bool`\n    |\n    = note: expected reference `&dyn std::fmt::Debug`\n               found reference `&bool`\n@@ -101,7 +101,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:23:13\n    |\n LL |     let _ = &match true { true => 'a', false => 'b' }: &dyn Debug;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait `std::fmt::Debug`, found `char`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::fmt::Debug`, found `char`\n    |\n    = note: expected reference `&dyn std::fmt::Debug`\n               found reference `&char`\n@@ -119,7 +119,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:26:13\n    |\n LL |     let _ = Box::new(|x| (x as u8)): Box<dyn Fn(i32) -> _>;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ expected trait `std::ops::Fn`, found closure\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::ops::Fn`, found closure\n    |\n    = note: expected struct `std::boxed::Box<dyn std::ops::Fn(i32) -> _>`\n               found struct `std::boxed::Box<[closure@$DIR/coerce-expect-unsized-ascribed.rs:26:22: 26:35]>`"}, {"sha": "6e5afcdb8bb68ce650dbba5ccee012f483c950f7", "filename": "src/test/ui/const-generics/array-impls/alloc-traits-no-impls-length-33.stderr", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-traits-no-impls-length-33.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-traits-no-impls-length-33.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-traits-no-impls-length-33.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -3,6 +3,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_vec_partial_eq_array<A, B>() -> impl PartialEq<[B; 33]>\n    |                                           ^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[B; 33]`\n+...\n+LL |     Vec::<A>::new()\n+   |     --------------- this returned value is of type `std::vec::Vec<A>`\n    |\n    = note: required because of the requirements on the impl of `std::cmp::PartialEq<[B; 33]>` for `std::vec::Vec<A>`\n    = note: the return type of a function must have a statically known size\n@@ -12,6 +15,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_vec_partial_eq_ref_array<'a, A, B>() -> impl PartialEq<&'a [B; 33]>\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[B; 33]`\n+...\n+LL |     Vec::<A>::new()\n+   |     --------------- this returned value is of type `std::vec::Vec<A>`\n    |\n    = note: required because of the requirements on the impl of `std::cmp::PartialEq<&'a [B; 33]>` for `std::vec::Vec<A>`\n    = note: the return type of a function must have a statically known size\n@@ -21,6 +27,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_vecdeque_partial_eq_array<A, B>() -> impl PartialEq<[B; 33]>\n    |                                                ^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[B; 33]`\n+...\n+LL |     VecDeque::<A>::new()\n+   |     -------------------- this returned value is of type `std::collections::VecDeque<A>`\n    |\n    = note: required because of the requirements on the impl of `std::cmp::PartialEq<[B; 33]>` for `std::collections::VecDeque<A>`\n    = note: the return type of a function must have a statically known size\n@@ -30,6 +39,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_vecdeque_partial_eq_ref_array<'a, A, B>() -> impl PartialEq<&'a [B; 33]>\n    |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[B; 33]`\n+...\n+LL |     VecDeque::<A>::new()\n+   |     -------------------- this returned value is of type `std::collections::VecDeque<A>`\n    |\n    = note: required because of the requirements on the impl of `std::cmp::PartialEq<&'a [B; 33]>` for `std::collections::VecDeque<A>`\n    = note: the return type of a function must have a statically known size\n@@ -39,6 +51,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_vecdeque_partial_eq_ref_mut_array<'a, A, B>() -> impl PartialEq<&'a mut [B; 33]>\n    |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[B; 33]`\n+...\n+LL |     VecDeque::<A>::new()\n+   |     -------------------- this returned value is of type `std::collections::VecDeque<A>`\n    |\n    = note: required because of the requirements on the impl of `std::cmp::PartialEq<&'a mut [B; 33]>` for `std::collections::VecDeque<A>`\n    = note: the return type of a function must have a statically known size"}, {"sha": "4869f48363447db0fc0bbbb4aecc566a91860d86", "filename": "src/test/ui/const-generics/array-impls/into-iter-no-impls-length-33.stderr", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -11,6 +11,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_iterator() -> impl Iterator<Item = i32> {\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size\n@@ -28,6 +31,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_double_ended_iterator() -> impl DoubleEndedIterator {\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::iter::DoubleEndedIterator` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size\n@@ -45,6 +51,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_exact_size_iterator() -> impl ExactSizeIterator {\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::iter::ExactSizeIterator` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size\n@@ -62,6 +71,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_fused_iterator() -> impl FusedIterator {\n    |                               ^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::iter::FusedIterator` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size\n@@ -79,6 +91,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_trusted_len() -> impl TrustedLen {\n    |                            ^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::iter::TrustedLen` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size\n@@ -96,6 +111,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_clone() -> impl Clone {\n    |                      ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::clone::Clone` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size\n@@ -113,6 +131,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_debug() -> impl Debug {\n    |                      ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::fmt::Debug` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size"}, {"sha": "34e7cad935aebafe29533ad710a429872f05fb11", "filename": "src/test/ui/destructure-trait-ref.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fdestructure-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fdestructure-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructure-trait-ref.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -33,12 +33,10 @@ fn main() {\n     //~^ ERROR mismatched types\n     //~| expected trait object `dyn T`\n     //~| found reference `&_`\n-    //~| expected trait `T`, found reference\n     let &&&x = &(&1isize as &dyn T);\n     //~^ ERROR mismatched types\n     //~| expected trait object `dyn T`\n     //~| found reference `&_`\n-    //~| expected trait `T`, found reference\n     let box box x = box 1isize as Box<dyn T>;\n     //~^ ERROR mismatched types\n     //~| expected trait object `dyn T`"}, {"sha": "f99bf2ffdc9d45dc85d7915d7776762ed0a5e6f2", "filename": "src/test/ui/destructure-trait-ref.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -22,31 +22,31 @@ error[E0308]: mismatched types\n LL |     let &&x = &1isize as &dyn T;\n    |          ^^\n    |          |\n-   |          expected trait `T`, found reference\n+   |          expected trait object `dyn T`, found reference\n    |          help: you can probably remove the explicit borrow: `x`\n    |\n    = note: expected trait object `dyn T`\n                  found reference `&_`\n \n error[E0308]: mismatched types\n-  --> $DIR/destructure-trait-ref.rs:37:11\n+  --> $DIR/destructure-trait-ref.rs:36:11\n    |\n LL |     let &&&x = &(&1isize as &dyn T);\n    |           ^^\n    |           |\n-   |           expected trait `T`, found reference\n+   |           expected trait object `dyn T`, found reference\n    |           help: you can probably remove the explicit borrow: `x`\n    |\n    = note: expected trait object `dyn T`\n                  found reference `&_`\n \n error[E0308]: mismatched types\n-  --> $DIR/destructure-trait-ref.rs:42:13\n+  --> $DIR/destructure-trait-ref.rs:40:13\n    |\n LL |     let box box x = box 1isize as Box<dyn T>;\n    |             ^^^^^   ------------------------ this expression has type `std::boxed::Box<dyn T>`\n    |             |\n-   |             expected trait `T`, found struct `std::boxed::Box`\n+   |             expected trait object `dyn T`, found struct `std::boxed::Box`\n    |\n    = note: expected trait object `dyn T`\n                     found struct `std::boxed::Box<_>`"}, {"sha": "d05b3937c998ccfaec6541d8347cda5ce09a0fa7", "filename": "src/test/ui/dst/dst-bad-assign-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign-3.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -32,7 +32,7 @@ pub fn main() {\n     let z: Box<dyn ToBar> = Box::new(Bar1 {f: 36});\n     f5.2 = Bar1 {f: 36};\n     //~^ ERROR mismatched types\n-    //~| expected trait `ToBar`, found struct `Bar1`\n+    //~| expected trait object `dyn ToBar`, found struct `Bar1`\n     //~| expected trait object `dyn ToBar`\n     //~| found struct `Bar1`\n     //~| ERROR the size for values of type"}, {"sha": "0b6f9df2d83ee367656f58eef7faa62cea479631", "filename": "src/test/ui/dst/dst-bad-assign-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign-3.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/dst-bad-assign-3.rs:33:12\n    |\n LL |     f5.2 = Bar1 {f: 36};\n-   |            ^^^^^^^^^^^^ expected trait `ToBar`, found struct `Bar1`\n+   |            ^^^^^^^^^^^^ expected trait object `dyn ToBar`, found struct `Bar1`\n    |\n    = note: expected trait object `dyn ToBar`\n                     found struct `Bar1`"}, {"sha": "496e01ae005326748fd9f162e8642ed0ff1b1d4c", "filename": "src/test/ui/dst/dst-bad-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -34,7 +34,7 @@ pub fn main() {\n     let z: Box<dyn ToBar> = Box::new(Bar1 {f: 36});\n     f5.ptr = Bar1 {f: 36};\n     //~^ ERROR mismatched types\n-    //~| expected trait `ToBar`, found struct `Bar1`\n+    //~| expected trait object `dyn ToBar`, found struct `Bar1`\n     //~| expected trait object `dyn ToBar`\n     //~| found struct `Bar1`\n     //~| ERROR the size for values of type"}, {"sha": "434c460759fb4c4192d54e31d09e7add449e9db2", "filename": "src/test/ui/dst/dst-bad-assign.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/dst-bad-assign.rs:35:14\n    |\n LL |     f5.ptr = Bar1 {f: 36};\n-   |              ^^^^^^^^^^^^ expected trait `ToBar`, found struct `Bar1`\n+   |              ^^^^^^^^^^^^ expected trait object `dyn ToBar`, found struct `Bar1`\n    |\n    = note: expected trait object `dyn ToBar`\n                     found struct `Bar1`"}, {"sha": "724d04954a3c7da1a2926c17d78a364691e17172", "filename": "src/test/ui/error-codes/E0603.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ferror-codes%2FE0603.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ferror-codes%2FE0603.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0603.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: constant `PRIVATE` is private\n   --> $DIR/E0603.rs:6:17\n    |\n LL |     SomeModule::PRIVATE;\n-   |                 ^^^^^^^\n+   |                 ^^^^^^^ this constant is private\n+   |\n+note: the constant `PRIVATE` is defined here\n+  --> $DIR/E0603.rs:2:5\n+   |\n+LL |     const PRIVATE: u32 = 0x_a_bad_1dea_u32;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ca8319aa020dceea3f35a462540de4f30b896ec1", "filename": "src/test/ui/error-codes/E0746.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ferror-codes%2FE0746.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ferror-codes%2FE0746.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0746.fixed?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+struct Struct;\n+trait Trait {}\n+impl Trait for Struct {}\n+impl Trait for u32 {}\n+\n+fn foo() -> impl Trait { Struct }\n+//~^ ERROR E0746\n+\n+fn bar() -> impl Trait { //~ ERROR E0746\n+    if true {\n+        return 0;\n+    }\n+    42\n+}\n+\n+fn main() {}"}, {"sha": "bf5ba8fff562a81ef091917b380e301f5255cac2", "filename": "src/test/ui/error-codes/E0746.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ferror-codes%2FE0746.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ferror-codes%2FE0746.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0746.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+struct Struct;\n+trait Trait {}\n+impl Trait for Struct {}\n+impl Trait for u32 {}\n+\n+fn foo() -> dyn Trait { Struct }\n+//~^ ERROR E0746\n+\n+fn bar() -> dyn Trait { //~ ERROR E0746\n+    if true {\n+        return 0;\n+    }\n+    42\n+}\n+\n+fn main() {}"}, {"sha": "e7a8fd304cabee33798925753507c153e2a49965", "filename": "src/test/ui/error-codes/E0746.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ferror-codes%2FE0746.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ferror-codes%2FE0746.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0746.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -0,0 +1,27 @@\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/E0746.rs:8:13\n+   |\n+LL | fn foo() -> dyn Trait { Struct }\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: return `impl Trait` instead, as all return paths are of type `Struct`, which implements `Trait`\n+   |\n+LL | fn foo() -> impl Trait { Struct }\n+   |             ^^^^^^^^^^\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/E0746.rs:11:13\n+   |\n+LL | fn bar() -> dyn Trait {\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: return `impl Trait` instead, as all return paths are of type `{integer}`, which implements `Trait`\n+   |\n+LL | fn bar() -> impl Trait {\n+   |             ^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0746`."}, {"sha": "9b69b3733642b4aac6d6505073c0b0f164c4e181", "filename": "src/test/ui/error-festival.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ferror-festival.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ferror-festival.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-festival.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -8,7 +8,13 @@ error[E0603]: constant `FOO` is private\n   --> $DIR/error-festival.rs:22:10\n    |\n LL |     foo::FOO;\n-   |          ^^^\n+   |          ^^^ this constant is private\n+   |\n+note: the constant `FOO` is defined here\n+  --> $DIR/error-festival.rs:7:5\n+   |\n+LL |     const FOO: u32 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^\n \n error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n   --> $DIR/error-festival.rs:12:5"}, {"sha": "8160775ab589eeebe1e4598a4eb7a5abc1316dfa", "filename": "src/test/ui/export-import.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fexport-import.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fexport-import.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexport-import.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: function `unexported` is private\n   --> $DIR/export-import.rs:1:8\n    |\n LL | use m::unexported;\n-   |        ^^^^^^^^^^\n+   |        ^^^^^^^^^^ this function is private\n+   |\n+note: the function `unexported` is defined here\n+  --> $DIR/export-import.rs:7:5\n+   |\n+LL |     fn unexported() { }\n+   |     ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "f4537a2fb6fae35648298003403e659b365cf1d4", "filename": "src/test/ui/export-tag-variant.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fexport-tag-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fexport-tag-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexport-tag-variant.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: enum `Y` is private\n   --> $DIR/export-tag-variant.rs:7:26\n    |\n LL | fn main() { let z = foo::Y::Y1; }\n-   |                          ^\n+   |                          ^ this enum is private\n+   |\n+note: the enum `Y` is defined here\n+  --> $DIR/export-tag-variant.rs:4:5\n+   |\n+LL |     enum Y { Y1 }\n+   |     ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "107f531c09a3a458d1be7724527578aa61ed5f9e", "filename": "src/test/ui/export.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fexport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fexport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexport.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -26,7 +26,13 @@ error[E0603]: function `z` is private\n   --> $DIR/export.rs:10:18\n    |\n LL | fn main() { foo::z(10); }\n-   |                  ^\n+   |                  ^ this function is private\n+   |\n+note: the function `z` is defined here\n+  --> $DIR/export.rs:5:5\n+   |\n+LL |     fn z(y: isize) { log(debug, y); }\n+   |     ^^^^^^^^^^^^^^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "cda1227cc8e924e0210eff954ca5299a261813ab", "filename": "src/test/ui/extern/extern-crate-visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fextern%2Fextern-crate-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fextern%2Fextern-crate-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-crate-visibility.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -3,10 +3,10 @@ mod foo {\n }\n \n // Check that private crates can be used from outside their modules, albeit with warnings\n-use foo::core::cell; //~ ERROR crate `core` is private\n+use foo::core::cell; //~ ERROR crate import `core` is private\n \n fn f() {\n-    foo::core::cell::Cell::new(0); //~ ERROR crate `core` is private\n+    foo::core::cell::Cell::new(0); //~ ERROR crate import `core` is private\n \n     use foo::*;\n     mod core {} // Check that private crates are not glob imported"}, {"sha": "d0c073d67a4ee22e77a816c9979775aa2538fb59", "filename": "src/test/ui/extern/extern-crate-visibility.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fextern%2Fextern-crate-visibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fextern%2Fextern-crate-visibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-crate-visibility.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -1,14 +1,26 @@\n-error[E0603]: crate `core` is private\n+error[E0603]: crate import `core` is private\n   --> $DIR/extern-crate-visibility.rs:6:10\n    |\n LL | use foo::core::cell;\n-   |          ^^^^\n+   |          ^^^^ this crate import is private\n+   |\n+note: the crate import `core` is defined here\n+  --> $DIR/extern-crate-visibility.rs:2:5\n+   |\n+LL |     extern crate core;\n+   |     ^^^^^^^^^^^^^^^^^^\n \n-error[E0603]: crate `core` is private\n+error[E0603]: crate import `core` is private\n   --> $DIR/extern-crate-visibility.rs:9:10\n    |\n LL |     foo::core::cell::Cell::new(0);\n-   |          ^^^^\n+   |          ^^^^ this crate import is private\n+   |\n+note: the crate import `core` is defined here\n+  --> $DIR/extern-crate-visibility.rs:2:5\n+   |\n+LL |     extern crate core;\n+   |     ^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ca2350ff7577f113e0da014c6e12ed49b7a595e8", "filename": "src/test/ui/generic-associated-types/impl_bounds.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -38,7 +38,7 @@ LL |     type C where Self: Copy = String;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n    |\n    = note: required because of the requirements on the impl of `std::marker::Copy` for `Fooy<T>`\n-   = note: the requirement `Fooy<T>: std::marker::Copy` appears on the associated impl typebut not on the corresponding associated trait type\n+   = note: the requirement `Fooy<T>: std::marker::Copy` appears on the associated impl type but not on the corresponding associated trait type\n \n error: aborting due to 3 previous errors\n "}, {"sha": "0649dc0ec58366f015b782d6cdc1f116ee46d406", "filename": "src/test/ui/hygiene/privacy.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fhygiene%2Fprivacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fhygiene%2Fprivacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fprivacy.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: function `f` is private\n   --> $DIR/privacy.rs:16:14\n    |\n LL |         foo::f()\n-   |              ^\n+   |              ^ this function is private\n+   |\n+note: the function `f` is defined here\n+  --> $DIR/privacy.rs:4:5\n+   |\n+LL |     fn f() {}\n+   |     ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b70a51dc82511d649f1e07ddf65811affa8ec938", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -0,0 +1,34 @@\n+#![allow(bare_trait_objects)]\n+struct Struct;\n+trait Trait {}\n+impl Trait for Struct {}\n+impl Trait for u32 {}\n+\n+fn fuz() -> (usize, Trait) { (42, Struct) }\n+//~^ ERROR E0277\n+//~| ERROR E0308\n+fn bar() -> (usize, dyn Trait) { (42, Struct) }\n+//~^ ERROR E0277\n+//~| ERROR E0308\n+fn bap() -> Trait { Struct }\n+//~^ ERROR E0746\n+fn ban() -> dyn Trait { Struct }\n+//~^ ERROR E0746\n+fn bak() -> dyn Trait { unimplemented!() } //~ ERROR E0277\n+// Suggest using `Box<dyn Trait>`\n+fn bal() -> dyn Trait { //~ ERROR E0746\n+    if true {\n+        return Struct;\n+    }\n+    42\n+}\n+\n+// Suggest using `impl Trait`\n+fn bat() -> dyn Trait { //~ ERROR E0746\n+    if true {\n+        return 0;\n+    }\n+    42\n+}\n+\n+fn main() {}"}, {"sha": "977a7ef0e024464c30d9b037bc9c7b6170c16009", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.stderr", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -0,0 +1,113 @@\n+error[E0308]: mismatched types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:7:35\n+   |\n+LL | fn fuz() -> (usize, Trait) { (42, Struct) }\n+   |                                   ^^^^^^ expected trait object `dyn Trait`, found struct `Struct`\n+   |\n+   = note: expected trait object `(dyn Trait + 'static)`\n+                    found struct `Struct`\n+\n+error[E0277]: the size for values of type `(dyn Trait + 'static)` cannot be known at compilation time\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:7:13\n+   |\n+LL | fn fuz() -> (usize, Trait) { (42, Struct) }\n+   |             ^^^^^^^^^^^^^^   ------------ this returned value is of type `(usize, (dyn Trait + 'static))`\n+   |             |\n+   |             doesn't have a size known at compile-time\n+   |\n+   = help: within `(usize, (dyn Trait + 'static))`, the trait `std::marker::Sized` is not implemented for `(dyn Trait + 'static)`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required because it appears within the type `(usize, (dyn Trait + 'static))`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:10:39\n+   |\n+LL | fn bar() -> (usize, dyn Trait) { (42, Struct) }\n+   |                                       ^^^^^^ expected trait object `dyn Trait`, found struct `Struct`\n+   |\n+   = note: expected trait object `(dyn Trait + 'static)`\n+                    found struct `Struct`\n+\n+error[E0277]: the size for values of type `(dyn Trait + 'static)` cannot be known at compilation time\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:10:13\n+   |\n+LL | fn bar() -> (usize, dyn Trait) { (42, Struct) }\n+   |             ^^^^^^^^^^^^^^^^^^   ------------ this returned value is of type `(usize, (dyn Trait + 'static))`\n+   |             |\n+   |             doesn't have a size known at compile-time\n+   |\n+   = help: within `(usize, (dyn Trait + 'static))`, the trait `std::marker::Sized` is not implemented for `(dyn Trait + 'static)`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required because it appears within the type `(usize, (dyn Trait + 'static))`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:13:13\n+   |\n+LL | fn bap() -> Trait { Struct }\n+   |             ^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: return `impl Trait` instead, as all return paths are of type `Struct`, which implements `Trait`\n+   |\n+LL | fn bap() -> impl Trait { Struct }\n+   |             ^^^^^^^^^^\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:15:13\n+   |\n+LL | fn ban() -> dyn Trait { Struct }\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: return `impl Trait` instead, as all return paths are of type `Struct`, which implements `Trait`\n+   |\n+LL | fn ban() -> impl Trait { Struct }\n+   |             ^^^^^^^^^^\n+\n+error[E0277]: the size for values of type `(dyn Trait + 'static)` cannot be known at compilation time\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:17:13\n+   |\n+LL | fn bak() -> dyn Trait { unimplemented!() }\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `(dyn Trait + 'static)`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:19:13\n+   |\n+LL | fn bal() -> dyn Trait {\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = note: if all the returned values were of the same type you could use `impl Trait` as the return type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: you can create a new `enum` with a variant for each returned type\n+help: return a boxed trait object instead\n+   |\n+LL | fn bal() -> Box<dyn Trait> {\n+LL |     if true {\n+LL |         return Box::new(Struct);\n+LL |     }\n+LL |     Box::new(42)\n+   |\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:27:13\n+   |\n+LL | fn bat() -> dyn Trait {\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: return `impl Trait` instead, as all return paths are of type `{integer}`, which implements `Trait`\n+   |\n+LL | fn bat() -> impl Trait {\n+   |             ^^^^^^^^^^\n+\n+error: aborting due to 9 previous errors\n+\n+Some errors have detailed explanations: E0277, E0308, E0746.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "9178358b60a9c140a8f19870d3ac1f5225898865", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -9,6 +9,12 @@ LL |         return 1_i32;\n LL |     }\n LL |     0_u32\n    |     ^^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: if the trait `Foo` were object safe, you could return a boxed trait object\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0277]: cannot add `impl Foo` to `u32`\n   --> $DIR/equality.rs:24:11"}, {"sha": "ab3086c78b3a1a9139a5960b01510b2f5bee0ef4", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-dyn-trait.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -0,0 +1,35 @@\n+#![allow(bare_trait_objects)]\n+trait NotObjectSafe {\n+    fn foo() -> Self;\n+}\n+\n+struct A;\n+struct B;\n+\n+impl NotObjectSafe for A {\n+    fn foo() -> Self {\n+        A\n+    }\n+}\n+\n+impl NotObjectSafe for B {\n+    fn foo() -> Self {\n+        B\n+    }\n+}\n+\n+fn car() -> dyn NotObjectSafe { //~ ERROR the trait `NotObjectSafe` cannot be made into an object\n+    if true {\n+        return A;\n+    }\n+    B\n+}\n+\n+fn cat() -> Box<dyn NotObjectSafe> { //~ ERROR the trait `NotObjectSafe` cannot be made into an\n+    if true {\n+        return Box::new(A);\n+    }\n+    Box::new(B)\n+}\n+\n+fn main() {}"}, {"sha": "0c8d267c13434b0628fd29c7e114b0bdfbc36849", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-dyn-trait.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -0,0 +1,21 @@\n+error[E0038]: the trait `NotObjectSafe` cannot be made into an object\n+  --> $DIR/object-unsafe-trait-in-return-position-dyn-trait.rs:21:1\n+   |\n+LL |     fn foo() -> Self;\n+   |        --- associated function `foo` has no `self` parameter\n+...\n+LL | fn car() -> dyn NotObjectSafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `NotObjectSafe` cannot be made into an object\n+\n+error[E0038]: the trait `NotObjectSafe` cannot be made into an object\n+  --> $DIR/object-unsafe-trait-in-return-position-dyn-trait.rs:28:1\n+   |\n+LL |     fn foo() -> Self;\n+   |        --- associated function `foo` has no `self` parameter\n+...\n+LL | fn cat() -> Box<dyn NotObjectSafe> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `NotObjectSafe` cannot be made into an object\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "503515013b9ab2579a8d7053b0d9b559d56107c5", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-impl-trait.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -0,0 +1,46 @@\n+trait NotObjectSafe {\n+    fn foo() -> Self;\n+}\n+\n+trait ObjectSafe {\n+    fn bar(&self);\n+}\n+\n+struct A;\n+struct B;\n+\n+impl NotObjectSafe for A {\n+    fn foo() -> Self {\n+        A\n+    }\n+}\n+\n+impl NotObjectSafe for B {\n+    fn foo() -> Self {\n+        B\n+    }\n+}\n+\n+impl ObjectSafe for A {\n+    fn bar(&self) {}\n+}\n+\n+impl ObjectSafe for B {\n+    fn bar(&self) {}\n+}\n+\n+fn can() -> impl NotObjectSafe {\n+    if true {\n+        return A;\n+    }\n+    B //~ ERROR mismatched types\n+}\n+\n+fn cat() -> impl ObjectSafe {\n+    if true {\n+        return A;\n+    }\n+    B //~ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "dd4260fbe4f911b0cfc15f57e73b7958833146d0", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-impl-trait.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -0,0 +1,39 @@\n+error[E0308]: mismatched types\n+  --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:36:5\n+   |\n+LL | fn can() -> impl NotObjectSafe {\n+   |             ------------------ expected because this return type...\n+LL |     if true {\n+LL |         return A;\n+   |                - ...is found to be `A` here\n+LL |     }\n+LL |     B\n+   |     ^ expected struct `A`, found struct `B`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: if the trait `NotObjectSafe` were object safe, you could return a boxed trait object\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n+\n+error[E0308]: mismatched types\n+  --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:43:5\n+   |\n+LL | fn cat() -> impl ObjectSafe {\n+   |             --------------- expected because this return type...\n+LL |     if true {\n+LL |         return A;\n+   |                - ...is found to be `A` here\n+LL |     }\n+LL |     B\n+   |     ^ expected struct `A`, found struct `B`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn ObjectSafe>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "5219ffacd15c077e8a015623488adf92664f8f5c", "filename": "src/test/ui/import.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimport.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -13,11 +13,17 @@ error[E0432]: unresolved import `foo`\n LL |     use foo;\n    |         ^^^ no `foo` in the root\n \n-error[E0603]: unresolved item `foo` is private\n+error[E0603]: unresolved item import `foo` is private\n   --> $DIR/import.rs:15:10\n    |\n LL |     zed::foo();\n-   |          ^^^\n+   |          ^^^ this unresolved item import is private\n+   |\n+note: the unresolved item import `foo` is defined here\n+  --> $DIR/import.rs:10:9\n+   |\n+LL |     use foo;\n+   |         ^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "75bb4206f97d6642b271a9fba70ea6e0aa9eb4da", "filename": "src/test/ui/imports/issue-55884-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -9,6 +9,6 @@ mod parser {\n     use ParseOptions;\n }\n \n-pub use parser::ParseOptions; //~ ERROR struct `ParseOptions` is private\n+pub use parser::ParseOptions; //~ ERROR struct import `ParseOptions` is private\n \n fn main() {}"}, {"sha": "f16d2adb3656e9f155437d852d43ef8d68adf179", "filename": "src/test/ui/imports/issue-55884-2.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-55884-2.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -1,8 +1,14 @@\n-error[E0603]: struct `ParseOptions` is private\n+error[E0603]: struct import `ParseOptions` is private\n   --> $DIR/issue-55884-2.rs:12:17\n    |\n LL | pub use parser::ParseOptions;\n-   |                 ^^^^^^^^^^^^\n+   |                 ^^^^^^^^^^^^ this struct import is private\n+   |\n+note: the struct import `ParseOptions` is defined here\n+  --> $DIR/issue-55884-2.rs:9:9\n+   |\n+LL |     use ParseOptions;\n+   |         ^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b173884080f8092af94d014350a758cd175f3bbb", "filename": "src/test/ui/imports/reexports.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimports%2Freexports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimports%2Freexports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Freexports.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -10,17 +10,29 @@ note: consider marking `foo` as `pub` in the imported module\n LL |         pub use super::foo;\n    |                 ^^^^^^^^^^\n \n-error[E0603]: module `foo` is private\n+error[E0603]: module import `foo` is private\n   --> $DIR/reexports.rs:33:15\n    |\n LL |     use b::a::foo::S;\n-   |               ^^^\n+   |               ^^^ this module import is private\n+   |\n+note: the module import `foo` is defined here\n+  --> $DIR/reexports.rs:21:17\n+   |\n+LL |         pub use super::foo; // This is OK since the value `foo` is visible enough.\n+   |                 ^^^^^^^^^^\n \n-error[E0603]: module `foo` is private\n+error[E0603]: module import `foo` is private\n   --> $DIR/reexports.rs:34:15\n    |\n LL |     use b::b::foo::S as T;\n-   |               ^^^\n+   |               ^^^ this module import is private\n+   |\n+note: the module import `foo` is defined here\n+  --> $DIR/reexports.rs:26:17\n+   |\n+LL |         pub use super::*; // This is also OK since the value `foo` is visible enough.\n+   |                 ^^^^^^^^\n \n warning: glob import doesn't reexport anything because no candidate is public enough\n   --> $DIR/reexports.rs:9:17"}, {"sha": "d7280d2583a7697d0cc7c66c5ba2cee4bcdc9210", "filename": "src/test/ui/imports/unresolved-imports-used.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimports%2Funresolved-imports-used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fimports%2Funresolved-imports-used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Funresolved-imports-used.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -38,7 +38,13 @@ error[E0603]: function `quz` is private\n   --> $DIR/unresolved-imports-used.rs:9:10\n    |\n LL | use qux::quz;\n-   |          ^^^\n+   |          ^^^ this function is private\n+   |\n+note: the function `quz` is defined here\n+  --> $DIR/unresolved-imports-used.rs:5:4\n+   |\n+LL |    fn quz() {}\n+   |    ^^^^^^^^\n \n error: unused import: `qux::quy`\n   --> $DIR/unresolved-imports-used.rs:16:5"}, {"sha": "4ed7028c0a06b550c436b25cecf4a51d6863f8b9", "filename": "src/test/ui/issues/issue-10545.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-10545.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-10545.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10545.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: struct `S` is private\n   --> $DIR/issue-10545.rs:6:14\n    |\n LL | fn foo(_: a::S) {\n-   |              ^\n+   |              ^ this struct is private\n+   |\n+note: the struct `S` is defined here\n+  --> $DIR/issue-10545.rs:2:5\n+   |\n+LL |     struct S;\n+   |     ^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "bfb4d31323b13c1ca85653e698ff8bdf6314b958", "filename": "src/test/ui/issues/issue-11593.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-11593.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-11593.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11593.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: trait `Foo` is private\n   --> $DIR/issue-11593.rs:7:24\n    |\n LL | impl private_trait_xc::Foo for Bar {}\n-   |                        ^^^\n+   |                        ^^^ this trait is private\n+   |\n+note: the trait `Foo` is defined here\n+  --> $DIR/auxiliary/private-trait-xc.rs:1:1\n+   |\n+LL | trait Foo {}\n+   | ^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "898ac10f7d9a92587f28812df1247ba695bcb686", "filename": "src/test/ui/issues/issue-11680.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-11680.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-11680.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11680.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,13 +2,25 @@ error[E0603]: enum `Foo` is private\n   --> $DIR/issue-11680.rs:6:21\n    |\n LL |     let _b = other::Foo::Bar(1);\n-   |                     ^^^\n+   |                     ^^^ this enum is private\n+   |\n+note: the enum `Foo` is defined here\n+  --> $DIR/auxiliary/issue-11680.rs:1:1\n+   |\n+LL | enum Foo {\n+   | ^^^^^^^^\n \n error[E0603]: enum `Foo` is private\n   --> $DIR/issue-11680.rs:9:27\n    |\n LL |     let _b = other::test::Foo::Bar(1);\n-   |                           ^^^\n+   |                           ^^^ this enum is private\n+   |\n+note: the enum `Foo` is defined here\n+  --> $DIR/auxiliary/issue-11680.rs:6:5\n+   |\n+LL |     enum Foo {\n+   |     ^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f211d623ab12bd4a975c279c392048207740c1b2", "filename": "src/test/ui/issues/issue-13407.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-13407.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-13407.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13407.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: unit struct `C` is private\n   --> $DIR/issue-13407.rs:6:8\n    |\n LL |     A::C = 1;\n-   |        ^\n+   |        ^ this unit struct is private\n+   |\n+note: the unit struct `C` is defined here\n+  --> $DIR/issue-13407.rs:2:5\n+   |\n+LL |     struct C;\n+   |     ^^^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/issue-13407.rs:6:12"}, {"sha": "f90cb18b6fc9d0d7e91a374369fc0c21b9282732", "filename": "src/test/ui/issues/issue-13641.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-13641.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-13641.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13641.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,13 +2,25 @@ error[E0603]: struct `Foo` is private\n   --> $DIR/issue-13641.rs:9:8\n    |\n LL |     a::Foo::new();\n-   |        ^^^\n+   |        ^^^ this struct is private\n+   |\n+note: the struct `Foo` is defined here\n+  --> $DIR/issue-13641.rs:2:5\n+   |\n+LL |     struct Foo;\n+   |     ^^^^^^^^^^^\n \n error[E0603]: enum `Bar` is private\n   --> $DIR/issue-13641.rs:11:8\n    |\n LL |     a::Bar::new();\n-   |        ^^^\n+   |        ^^^ this enum is private\n+   |\n+note: the enum `Bar` is defined here\n+  --> $DIR/issue-13641.rs:4:5\n+   |\n+LL |     enum Bar {}\n+   |     ^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e0a1ca8a5ac319347fcae50dcf6c9b8ff7234449", "filename": "src/test/ui/issues/issue-16725.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-16725.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-16725.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16725.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: function `bar` is private\n   --> $DIR/issue-16725.rs:6:19\n    |\n LL |     unsafe { foo::bar(); }\n-   |                   ^^^\n+   |                   ^^^ this function is private\n+   |\n+note: the function `bar` is defined here\n+  --> $DIR/auxiliary/issue-16725.rs:2:5\n+   |\n+LL |     fn bar();\n+   |     ^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "07d825ba9cb3b2c490b8bee72e5a806f56b7563a", "filename": "src/test/ui/issues/issue-17718-const-privacy.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-privacy.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,13 +2,25 @@ error[E0603]: constant `B` is private\n   --> $DIR/issue-17718-const-privacy.rs:5:8\n    |\n LL | use a::B;\n-   |        ^\n+   |        ^ this constant is private\n+   |\n+note: the constant `B` is defined here\n+  --> $DIR/issue-17718-const-privacy.rs:13:5\n+   |\n+LL |     const B: usize = 3;\n+   |     ^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: constant `BAR` is private\n   --> $DIR/issue-17718-const-privacy.rs:8:5\n    |\n LL |     BAR,\n-   |     ^^^\n+   |     ^^^ this constant is private\n+   |\n+note: the constant `BAR` is defined here\n+  --> $DIR/auxiliary/issue-17718-const-privacy.rs:4:1\n+   |\n+LL | const BAR: usize = 3;\n+   | ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "58bd775f295fc61a1e6e9126cade57d32e3e683b", "filename": "src/test/ui/issues/issue-28388-2.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-28388-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-28388-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28388-2.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: module `n` is private\n   --> $DIR/issue-28388-2.rs:7:8\n    |\n LL | use m::n::{};\n-   |        ^\n+   |        ^ this module is private\n+   |\n+note: the module `n` is defined here\n+  --> $DIR/issue-28388-2.rs:4:5\n+   |\n+LL |     mod n {}\n+   |     ^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "1bfa211ef796263cda34427c9677ed953b982cf2", "filename": "src/test/ui/issues/issue-29161.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-29161.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-29161.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29161.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -8,7 +8,13 @@ error[E0603]: struct `A` is private\n   --> $DIR/issue-29161.rs:13:8\n    |\n LL |     a::A::default();\n-   |        ^\n+   |        ^ this struct is private\n+   |\n+note: the struct `A` is defined here\n+  --> $DIR/issue-29161.rs:2:5\n+   |\n+LL |     struct A;\n+   |     ^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c0695f8216512209097f7eb3c8fb684b6e38ff59", "filename": "src/test/ui/issues/issue-38857.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-38857.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-38857.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38857.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n fn main() {\n     let a = std::sys::imp::process::process_common::StdioPipes { ..panic!() };\n     //~^ ERROR failed to resolve: could not find `imp` in `sys` [E0433]"}, {"sha": "ba0f1336ff09d79c0fc20142d11d6e6a22d2bd6d", "filename": "src/test/ui/issues/issue-38857.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-38857.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-38857.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38857.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -1,14 +1,20 @@\n error[E0433]: failed to resolve: could not find `imp` in `sys`\n-  --> $DIR/issue-38857.rs:2:23\n+  --> $DIR/issue-38857.rs:7:23\n    |\n LL |     let a = std::sys::imp::process::process_common::StdioPipes { ..panic!() };\n    |                       ^^^ could not find `imp` in `sys`\n \n error[E0603]: module `sys` is private\n-  --> $DIR/issue-38857.rs:2:18\n+  --> $DIR/issue-38857.rs:7:18\n    |\n LL |     let a = std::sys::imp::process::process_common::StdioPipes { ..panic!() };\n-   |                  ^^^\n+   |                  ^^^ this module is private\n+   |\n+note: the module `sys` is defined here\n+  --> $SRC_DIR/libstd/lib.rs:LL:COL\n+   |\n+LL | mod sys;\n+   | ^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3fa8ed4af28fa3b43a8ffdd3256f0f5ee54d033c", "filename": "src/test/ui/issues/issue-3993.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-3993.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-3993.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3993.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: function `fly` is private\n   --> $DIR/issue-3993.rs:1:10\n    |\n LL | use zoo::fly;\n-   |          ^^^\n+   |          ^^^ this function is private\n+   |\n+note: the function `fly` is defined here\n+  --> $DIR/issue-3993.rs:4:5\n+   |\n+LL |     fn fly() {}\n+   |     ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "e0c196e518ba34b16df02161d597ad84f1b7461e", "filename": "src/test/ui/issues/issue-58344.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -3,6 +3,9 @@ error[E0277]: the trait bound `impl Trait<<u32 as std::ops::Add>::Output>: Trait\n    |\n LL | ) -> Either<impl Trait<<u32 as Add<u32>>::Output>, impl Trait<<u32 as Add<u32>>::Output>> {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<u32>` is not implemented for `impl Trait<<u32 as std::ops::Add>::Output>`\n+...\n+LL |     add_generic(value, 1u32)\n+   |     ------------------------ this returned value is of type `Either<impl Trait<<u32 as std::ops::Add>::Output>, impl Trait<<u32 as std::ops::Add>::Output>>`\n    |\n    = note: the return type of a function must have a statically known size\n \n@@ -11,6 +14,9 @@ error[E0277]: the trait bound `impl Trait<<u32 as std::ops::Add>::Output>: Trait\n    |\n LL | ) -> Either<impl Trait<<u32 as Add<u32>>::Output>, impl Trait<<u32 as Add<u32>>::Output>> {\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<u32>` is not implemented for `impl Trait<<u32 as std::ops::Add>::Output>`\n+...\n+LL |     add_generic(value, 1u32)\n+   |     ------------------------ this returned value is of type `Either<impl Trait<<u32 as std::ops::Add>::Output>, impl Trait<<u32 as std::ops::Add>::Output>>`\n    |\n    = note: the return type of a function must have a statically known size\n "}, {"sha": "d886ecc11d17b6abb726ae9ace156011e29c69f1", "filename": "src/test/ui/issues/issue-5883.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -14,6 +14,9 @@ error[E0277]: the size for values of type `(dyn A + 'static)` cannot be known at\n    |\n LL |     -> Struct {\n    |        ^^^^^^ doesn't have a size known at compile-time\n+LL |\n+LL |     Struct { r: r }\n+   |     --------------- this returned value is of type `Struct`\n    |\n    = help: within `Struct`, the trait `std::marker::Sized` is not implemented for `(dyn A + 'static)`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>"}, {"sha": "e43fb6d0edfb9e730892d6cb0a3eef0fb090b8d2", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -3,6 +3,9 @@ error[E0277]: the trait bound `std::result::Result<(), _>: Future` is not satisf\n    |\n LL | fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Future` is not implemented for `std::result::Result<(), _>`\n+LL |\n+LL |     Ok(())\n+   |     ------ this returned value is of type `std::result::Result<(), _>`\n    |\n    = note: the return type of a function must have a statically known size\n "}, {"sha": "72994d1652cd0d8c702d35ae15825820a5c26ac9", "filename": "src/test/ui/macros/macro-local-data-key-priv.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fmacros%2Fmacro-local-data-key-priv.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fmacros%2Fmacro-local-data-key-priv.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-local-data-key-priv.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,14 @@ error[E0603]: constant `baz` is private\n   --> $DIR/macro-local-data-key-priv.rs:8:10\n    |\n LL |     bar::baz.with(|_| ());\n-   |          ^^^\n+   |          ^^^ this constant is private\n+   |\n+note: the constant `baz` is defined here\n+  --> $DIR/macro-local-data-key-priv.rs:4:5\n+   |\n+LL |     thread_local!(static baz: f64 = 0.0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "77288f1badac5e572484c0b817e360f6c953d9c3", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -3,8 +3,12 @@ error[E0277]: the trait bound `(): T` is not satisfied\n    |\n LL | fn should_ret_unit() -> impl T {\n    |                         ^^^^^^ the trait `T` is not implemented for `()`\n+LL |\n+LL |     panic!()\n+   |     -------- this returned value is of type `()`\n    |\n    = note: the return type of a function must have a statically known size\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "ae981ac4cbee3d578edd41def5c0a0b0e620fb36", "filename": "src/test/ui/parser/macro/pub-item-macro.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -13,7 +13,16 @@ error[E0603]: static `x` is private\n   --> $DIR/pub-item-macro.rs:17:23\n    |\n LL |     let y: u32 = foo::x;\n-   |                       ^\n+   |                       ^ this static is private\n+   |\n+note: the static `x` is defined here\n+  --> $DIR/pub-item-macro.rs:4:5\n+   |\n+LL |     static x: u32 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^\n+...\n+LL |     pub_x!();\n+   |     --------- in this macro invocation\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b663cccbeef0f192da5e7d6b530a45f3bd974925", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -9,6 +9,12 @@ LL |         return 0i32;\n LL |     }\n LL |     1u32\n    |     ^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:13:16\n@@ -21,6 +27,12 @@ LL |         return 0i32;\n LL |     } else {\n LL |         return 1u32;\n    |                ^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:22:9\n@@ -33,6 +45,12 @@ LL |         return 0i32;\n LL |     } else {\n LL |         1u32\n    |         ^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:31:9\n@@ -57,6 +75,12 @@ LL |         0 => return 0i32,\n    |                     ---- ...is found to be `i32` here\n LL |         _ => 1u32,\n    |              ^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:45:5\n@@ -71,6 +95,12 @@ LL | |         1 => 1u32,\n LL | |         _ => 2u32,\n LL | |     }\n    | |_____^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:59:13\n@@ -83,6 +113,12 @@ LL |             return 0i32;\n ...\n LL |             1u32\n    |             ^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error: aborting due to 7 previous errors\n "}, {"sha": "ae2e1b4b644a384b38348d48d90fd2b43f6cae60", "filename": "src/test/ui/privacy/decl-macro.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: macro `mac` is private\n   --> $DIR/decl-macro.rs:8:8\n    |\n LL |     m::mac!();\n-   |        ^^^\n+   |        ^^^ this macro is private\n+   |\n+note: the macro `mac` is defined here\n+  --> $DIR/decl-macro.rs:4:5\n+   |\n+LL |     macro mac() {}\n+   |     ^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "8860d8f15f7488a2e3e1a5f77db6cdc63e8e51c0", "filename": "src/test/ui/privacy/privacy-in-paths.stderr", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-in-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-in-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-in-paths.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,19 +2,37 @@ error[E0603]: module `bar` is private\n   --> $DIR/privacy-in-paths.rs:24:16\n    |\n LL |         ::foo::bar::baz::f();\n-   |                ^^^\n+   |                ^^^ this module is private\n+   |\n+note: the module `bar` is defined here\n+  --> $DIR/privacy-in-paths.rs:3:5\n+   |\n+LL |     mod bar {\n+   |     ^^^^^^^\n \n error[E0603]: module `bar` is private\n   --> $DIR/privacy-in-paths.rs:25:16\n    |\n LL |         ::foo::bar::S::f();\n-   |                ^^^\n+   |                ^^^ this module is private\n+   |\n+note: the module `bar` is defined here\n+  --> $DIR/privacy-in-paths.rs:3:5\n+   |\n+LL |     mod bar {\n+   |     ^^^^^^^\n \n error[E0603]: trait `T` is private\n   --> $DIR/privacy-in-paths.rs:26:23\n    |\n LL |         <() as ::foo::T>::Assoc::f();\n-   |                       ^\n+   |                       ^ this trait is private\n+   |\n+note: the trait `T` is defined here\n+  --> $DIR/privacy-in-paths.rs:8:5\n+   |\n+LL |     trait T {\n+   |     ^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "8b12109b3730747f5ca7c548fd1422ad550072c2", "filename": "src/test/ui/privacy/privacy-ns2.stderr", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -58,19 +58,37 @@ error[E0603]: trait `Bar` is private\n   --> $DIR/privacy-ns2.rs:63:15\n    |\n LL |     use foo3::Bar;\n-   |               ^^^\n+   |               ^^^ this trait is private\n+   |\n+note: the trait `Bar` is defined here\n+  --> $DIR/privacy-ns2.rs:55:5\n+   |\n+LL |     trait Bar {\n+   |     ^^^^^^^^^\n \n error[E0603]: trait `Bar` is private\n   --> $DIR/privacy-ns2.rs:67:15\n    |\n LL |     use foo3::Bar;\n-   |               ^^^\n+   |               ^^^ this trait is private\n+   |\n+note: the trait `Bar` is defined here\n+  --> $DIR/privacy-ns2.rs:55:5\n+   |\n+LL |     trait Bar {\n+   |     ^^^^^^^^^\n \n error[E0603]: trait `Bar` is private\n   --> $DIR/privacy-ns2.rs:74:16\n    |\n LL |     use foo3::{Bar,Baz};\n-   |                ^^^\n+   |                ^^^ this trait is private\n+   |\n+note: the trait `Bar` is defined here\n+  --> $DIR/privacy-ns2.rs:55:5\n+   |\n+LL |     trait Bar {\n+   |     ^^^^^^^^^\n \n error[E0107]: wrong number of const arguments: expected 0, found 1\n   --> $DIR/privacy-ns2.rs:41:18"}, {"sha": "08640b802a244990320ef68fe24cf75d80ed217f", "filename": "src/test/ui/privacy/privacy-ufcs.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ufcs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ufcs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ufcs.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: trait `Bar` is private\n   --> $DIR/privacy-ufcs.rs:12:20\n    |\n LL |     <i32 as ::foo::Bar>::baz();\n-   |                    ^^^\n+   |                    ^^^ this trait is private\n+   |\n+note: the trait `Bar` is defined here\n+  --> $DIR/privacy-ufcs.rs:4:5\n+   |\n+LL |     trait Bar {\n+   |     ^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "215df0dc754410997470dbc1b78447d5b1b2efd2", "filename": "src/test/ui/privacy/privacy1.stderr", "status": "modified", "additions": 91, "deletions": 13, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy1.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,79 +2,157 @@ error[E0603]: module `baz` is private\n   --> $DIR/privacy1.rs:132:18\n    |\n LL |         use bar::baz::{foo, bar};\n-   |                  ^^^\n+   |                  ^^^ this module is private\n+   |\n+note: the module `baz` is defined here\n+  --> $DIR/privacy1.rs:50:5\n+   |\n+LL |     mod baz {\n+   |     ^^^^^^^\n \n error[E0603]: module `baz` is private\n   --> $DIR/privacy1.rs:132:18\n    |\n LL |         use bar::baz::{foo, bar};\n-   |                  ^^^\n+   |                  ^^^ this module is private\n+   |\n+note: the module `baz` is defined here\n+  --> $DIR/privacy1.rs:50:5\n+   |\n+LL |     mod baz {\n+   |     ^^^^^^^\n \n error[E0603]: module `baz` is private\n   --> $DIR/privacy1.rs:141:18\n    |\n LL |         use bar::baz;\n-   |                  ^^^\n+   |                  ^^^ this module is private\n+   |\n+note: the module `baz` is defined here\n+  --> $DIR/privacy1.rs:50:5\n+   |\n+LL |     mod baz {\n+   |     ^^^^^^^\n \n error[E0603]: module `i` is private\n   --> $DIR/privacy1.rs:165:20\n    |\n LL |     use self::foo::i::A;\n-   |                    ^\n+   |                    ^ this module is private\n+   |\n+note: the module `i` is defined here\n+  --> $DIR/privacy1.rs:170:9\n+   |\n+LL |         mod i {\n+   |         ^^^^^\n \n error[E0603]: module `baz` is private\n   --> $DIR/privacy1.rs:104:16\n    |\n LL |         ::bar::baz::A::foo();\n-   |                ^^^\n+   |                ^^^ this module is private\n+   |\n+note: the module `baz` is defined here\n+  --> $DIR/privacy1.rs:50:5\n+   |\n+LL |     mod baz {\n+   |     ^^^^^^^\n \n error[E0603]: module `baz` is private\n   --> $DIR/privacy1.rs:105:16\n    |\n LL |         ::bar::baz::A::bar();\n-   |                ^^^\n+   |                ^^^ this module is private\n+   |\n+note: the module `baz` is defined here\n+  --> $DIR/privacy1.rs:50:5\n+   |\n+LL |     mod baz {\n+   |     ^^^^^^^\n \n error[E0603]: module `baz` is private\n   --> $DIR/privacy1.rs:107:16\n    |\n LL |         ::bar::baz::A.foo2();\n-   |                ^^^\n+   |                ^^^ this module is private\n+   |\n+note: the module `baz` is defined here\n+  --> $DIR/privacy1.rs:50:5\n+   |\n+LL |     mod baz {\n+   |     ^^^^^^^\n \n error[E0603]: module `baz` is private\n   --> $DIR/privacy1.rs:108:16\n    |\n LL |         ::bar::baz::A.bar2();\n-   |                ^^^\n+   |                ^^^ this module is private\n+   |\n+note: the module `baz` is defined here\n+  --> $DIR/privacy1.rs:50:5\n+   |\n+LL |     mod baz {\n+   |     ^^^^^^^\n \n error[E0603]: trait `B` is private\n   --> $DIR/privacy1.rs:112:16\n    |\n LL |         ::bar::B::foo();\n-   |                ^\n+   |                ^ this trait is private\n+   |\n+note: the trait `B` is defined here\n+  --> $DIR/privacy1.rs:40:5\n+   |\n+LL |     trait B {\n+   |     ^^^^^^^\n \n error[E0603]: function `epriv` is private\n   --> $DIR/privacy1.rs:118:20\n    |\n LL |             ::bar::epriv();\n-   |                    ^^^^^\n+   |                    ^^^^^ this function is private\n+   |\n+note: the function `epriv` is defined here\n+  --> $DIR/privacy1.rs:65:9\n+   |\n+LL |         fn epriv();\n+   |         ^^^^^^^^^^^\n \n error[E0603]: module `baz` is private\n   --> $DIR/privacy1.rs:127:16\n    |\n LL |         ::bar::baz::foo();\n-   |                ^^^\n+   |                ^^^ this module is private\n+   |\n+note: the module `baz` is defined here\n+  --> $DIR/privacy1.rs:50:5\n+   |\n+LL |     mod baz {\n+   |     ^^^^^^^\n \n error[E0603]: module `baz` is private\n   --> $DIR/privacy1.rs:128:16\n    |\n LL |         ::bar::baz::bar();\n-   |                ^^^\n+   |                ^^^ this module is private\n+   |\n+note: the module `baz` is defined here\n+  --> $DIR/privacy1.rs:50:5\n+   |\n+LL |     mod baz {\n+   |     ^^^^^^^\n \n error[E0603]: trait `B` is private\n   --> $DIR/privacy1.rs:157:17\n    |\n LL |     impl ::bar::B for f32 { fn foo() -> f32 { 1.0 } }\n-   |                 ^\n+   |                 ^ this trait is private\n+   |\n+note: the trait `B` is defined here\n+  --> $DIR/privacy1.rs:40:5\n+   |\n+LL |     trait B {\n+   |     ^^^^^^^\n \n error[E0624]: method `bar` is private\n   --> $DIR/privacy1.rs:77:9"}, {"sha": "719dc27ccf4d6bddbded7ff6e8917d8890d7762c", "filename": "src/test/ui/privacy/privacy2.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy2.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -4,11 +4,17 @@ error[E0432]: unresolved import `bar::foo`\n LL |     use bar::foo;\n    |         ^^^^^^^^ no `foo` in `bar`\n \n-error[E0603]: function `foo` is private\n+error[E0603]: function import `foo` is private\n   --> $DIR/privacy2.rs:23:20\n    |\n LL |     use bar::glob::foo;\n-   |                    ^^^\n+   |                    ^^^ this function import is private\n+   |\n+note: the function import `foo` is defined here\n+  --> $DIR/privacy2.rs:10:13\n+   |\n+LL |         use foo;\n+   |             ^^^\n \n error: requires `sized` lang_item\n "}, {"sha": "e34b2d5049b9ef960d8315f21cbf30aaaa13e91c", "filename": "src/test/ui/privacy/privacy4.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy4.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: module `glob` is private\n   --> $DIR/privacy4.rs:21:14\n    |\n LL |     use bar::glob::gpriv;\n-   |              ^^^^\n+   |              ^^^^ this module is private\n+   |\n+note: the module `glob` is defined here\n+  --> $DIR/privacy4.rs:13:5\n+   |\n+LL |     mod glob {\n+   |     ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "197a857cc3dc435bbc8d6e033378a769bd0d1430", "filename": "src/test/ui/privacy/privacy5.stderr", "status": "modified", "additions": 336, "deletions": 48, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -5,7 +5,13 @@ LL |     pub struct A(());\n    |                  -- a constructor is private if any of the fields is private\n ...\n LL |     let a = a::A(());\n-   |                ^\n+   |                ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `A` is defined here\n+  --> $DIR/privacy5.rs:6:5\n+   |\n+LL |     pub struct A(());\n+   |     ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:52:16\n@@ -14,7 +20,13 @@ LL |     pub struct B(isize);\n    |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     let b = a::B(2);\n-   |                ^\n+   |                ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/privacy5.rs:7:5\n+   |\n+LL |     pub struct B(isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:53:16\n@@ -23,7 +35,13 @@ LL |     pub struct C(pub isize, isize);\n    |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     let c = a::C(2, 3);\n-   |                ^\n+   |                ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/privacy5.rs:8:5\n+   |\n+LL |     pub struct C(pub isize, isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:56:12\n@@ -32,7 +50,13 @@ LL |     pub struct A(());\n    |                  -- a constructor is private if any of the fields is private\n ...\n LL |     let a::A(()) = a;\n-   |            ^\n+   |            ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `A` is defined here\n+  --> $DIR/privacy5.rs:6:5\n+   |\n+LL |     pub struct A(());\n+   |     ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:57:12\n@@ -41,7 +65,13 @@ LL |     pub struct A(());\n    |                  -- a constructor is private if any of the fields is private\n ...\n LL |     let a::A(_) = a;\n-   |            ^\n+   |            ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `A` is defined here\n+  --> $DIR/privacy5.rs:6:5\n+   |\n+LL |     pub struct A(());\n+   |     ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:58:18\n@@ -50,7 +80,13 @@ LL |     pub struct A(());\n    |                  -- a constructor is private if any of the fields is private\n ...\n LL |     match a { a::A(()) => {} }\n-   |                  ^\n+   |                  ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `A` is defined here\n+  --> $DIR/privacy5.rs:6:5\n+   |\n+LL |     pub struct A(());\n+   |     ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:59:18\n@@ -59,7 +95,13 @@ LL |     pub struct A(());\n    |                  -- a constructor is private if any of the fields is private\n ...\n LL |     match a { a::A(_) => {} }\n-   |                  ^\n+   |                  ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `A` is defined here\n+  --> $DIR/privacy5.rs:6:5\n+   |\n+LL |     pub struct A(());\n+   |     ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:61:12\n@@ -68,7 +110,13 @@ LL |     pub struct B(isize);\n    |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     let a::B(_) = b;\n-   |            ^\n+   |            ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/privacy5.rs:7:5\n+   |\n+LL |     pub struct B(isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:62:12\n@@ -77,7 +125,13 @@ LL |     pub struct B(isize);\n    |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     let a::B(_b) = b;\n-   |            ^\n+   |            ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/privacy5.rs:7:5\n+   |\n+LL |     pub struct B(isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:63:18\n@@ -86,7 +140,13 @@ LL |     pub struct B(isize);\n    |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     match b { a::B(_) => {} }\n-   |                  ^\n+   |                  ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/privacy5.rs:7:5\n+   |\n+LL |     pub struct B(isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:64:18\n@@ -95,7 +155,13 @@ LL |     pub struct B(isize);\n    |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     match b { a::B(_b) => {} }\n-   |                  ^\n+   |                  ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/privacy5.rs:7:5\n+   |\n+LL |     pub struct B(isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:65:18\n@@ -104,7 +170,13 @@ LL |     pub struct B(isize);\n    |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     match b { a::B(1) => {} a::B(_) => {} }\n-   |                  ^\n+   |                  ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/privacy5.rs:7:5\n+   |\n+LL |     pub struct B(isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:65:32\n@@ -113,7 +185,13 @@ LL |     pub struct B(isize);\n    |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     match b { a::B(1) => {} a::B(_) => {} }\n-   |                                ^\n+   |                                ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/privacy5.rs:7:5\n+   |\n+LL |     pub struct B(isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:68:12\n@@ -122,7 +200,13 @@ LL |     pub struct C(pub isize, isize);\n    |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     let a::C(_, _) = c;\n-   |            ^\n+   |            ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/privacy5.rs:8:5\n+   |\n+LL |     pub struct C(pub isize, isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:69:12\n@@ -131,7 +215,13 @@ LL |     pub struct C(pub isize, isize);\n    |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     let a::C(_a, _) = c;\n-   |            ^\n+   |            ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/privacy5.rs:8:5\n+   |\n+LL |     pub struct C(pub isize, isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:70:12\n@@ -140,7 +230,13 @@ LL |     pub struct C(pub isize, isize);\n    |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     let a::C(_, _b) = c;\n-   |            ^\n+   |            ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/privacy5.rs:8:5\n+   |\n+LL |     pub struct C(pub isize, isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:71:12\n@@ -149,7 +245,13 @@ LL |     pub struct C(pub isize, isize);\n    |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     let a::C(_a, _b) = c;\n-   |            ^\n+   |            ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/privacy5.rs:8:5\n+   |\n+LL |     pub struct C(pub isize, isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:72:18\n@@ -158,7 +260,13 @@ LL |     pub struct C(pub isize, isize);\n    |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     match c { a::C(_, _) => {} }\n-   |                  ^\n+   |                  ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/privacy5.rs:8:5\n+   |\n+LL |     pub struct C(pub isize, isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:73:18\n@@ -167,7 +275,13 @@ LL |     pub struct C(pub isize, isize);\n    |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     match c { a::C(_a, _) => {} }\n-   |                  ^\n+   |                  ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/privacy5.rs:8:5\n+   |\n+LL |     pub struct C(pub isize, isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:74:18\n@@ -176,7 +290,13 @@ LL |     pub struct C(pub isize, isize);\n    |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     match c { a::C(_, _b) => {} }\n-   |                  ^\n+   |                  ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/privacy5.rs:8:5\n+   |\n+LL |     pub struct C(pub isize, isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:75:18\n@@ -185,7 +305,13 @@ LL |     pub struct C(pub isize, isize);\n    |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     match c { a::C(_a, _b) => {} }\n-   |                  ^\n+   |                  ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/privacy5.rs:8:5\n+   |\n+LL |     pub struct C(pub isize, isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:83:17\n@@ -194,7 +320,13 @@ LL |     pub struct A(());\n    |                  -- a constructor is private if any of the fields is private\n ...\n LL |     let a2 = a::A;\n-   |                 ^\n+   |                 ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `A` is defined here\n+  --> $DIR/privacy5.rs:6:5\n+   |\n+LL |     pub struct A(());\n+   |     ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:84:17\n@@ -203,7 +335,13 @@ LL |     pub struct B(isize);\n    |                  ----- a constructor is private if any of the fields is private\n ...\n LL |     let b2 = a::B;\n-   |                 ^\n+   |                 ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/privacy5.rs:7:5\n+   |\n+LL |     pub struct B(isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:85:17\n@@ -212,271 +350,421 @@ LL |     pub struct C(pub isize, isize);\n    |                  ---------------- a constructor is private if any of the fields is private\n ...\n LL |     let c2 = a::C;\n-   |                 ^\n+   |                 ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/privacy5.rs:8:5\n+   |\n+LL |     pub struct C(pub isize, isize);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:90:20\n    |\n LL |     let a = other::A(());\n-   |                    ^\n+   |                    ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:1:14\n    |\n LL | pub struct A(());\n    |              -- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `A` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:1:1\n+   |\n+LL | pub struct A(());\n+   | ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:91:20\n    |\n LL |     let b = other::B(2);\n-   |                    ^\n+   |                    ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n    |              ----- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:2:1\n+   |\n+LL | pub struct B(isize);\n+   | ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:92:20\n    |\n LL |     let c = other::C(2, 3);\n-   |                    ^\n+   |                    ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n    |              ---------------- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:3:1\n+   |\n+LL | pub struct C(pub isize, isize);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:95:16\n    |\n LL |     let other::A(()) = a;\n-   |                ^\n+   |                ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:1:14\n    |\n LL | pub struct A(());\n    |              -- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `A` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:1:1\n+   |\n+LL | pub struct A(());\n+   | ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:96:16\n    |\n LL |     let other::A(_) = a;\n-   |                ^\n+   |                ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:1:14\n    |\n LL | pub struct A(());\n    |              -- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `A` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:1:1\n+   |\n+LL | pub struct A(());\n+   | ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:97:22\n    |\n LL |     match a { other::A(()) => {} }\n-   |                      ^\n+   |                      ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:1:14\n    |\n LL | pub struct A(());\n    |              -- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `A` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:1:1\n+   |\n+LL | pub struct A(());\n+   | ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:98:22\n    |\n LL |     match a { other::A(_) => {} }\n-   |                      ^\n+   |                      ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:1:14\n    |\n LL | pub struct A(());\n    |              -- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `A` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:1:1\n+   |\n+LL | pub struct A(());\n+   | ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:100:16\n    |\n LL |     let other::B(_) = b;\n-   |                ^\n+   |                ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n    |              ----- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:2:1\n+   |\n+LL | pub struct B(isize);\n+   | ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:101:16\n    |\n LL |     let other::B(_b) = b;\n-   |                ^\n+   |                ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n    |              ----- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:2:1\n+   |\n+LL | pub struct B(isize);\n+   | ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:102:22\n    |\n LL |     match b { other::B(_) => {} }\n-   |                      ^\n+   |                      ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n    |              ----- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:2:1\n+   |\n+LL | pub struct B(isize);\n+   | ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:103:22\n    |\n LL |     match b { other::B(_b) => {} }\n-   |                      ^\n+   |                      ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n    |              ----- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:2:1\n+   |\n+LL | pub struct B(isize);\n+   | ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:104:22\n    |\n LL |     match b { other::B(1) => {}\n-   |                      ^\n+   |                      ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n    |              ----- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:2:1\n+   |\n+LL | pub struct B(isize);\n+   | ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:105:16\n    |\n LL |         other::B(_) => {} }\n-   |                ^\n+   |                ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n    |              ----- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:2:1\n+   |\n+LL | pub struct B(isize);\n+   | ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:107:16\n    |\n LL |     let other::C(_, _) = c;\n-   |                ^\n+   |                ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n    |              ---------------- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:3:1\n+   |\n+LL | pub struct C(pub isize, isize);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:108:16\n    |\n LL |     let other::C(_a, _) = c;\n-   |                ^\n+   |                ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n    |              ---------------- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:3:1\n+   |\n+LL | pub struct C(pub isize, isize);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:109:16\n    |\n LL |     let other::C(_, _b) = c;\n-   |                ^\n+   |                ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n    |              ---------------- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:3:1\n+   |\n+LL | pub struct C(pub isize, isize);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:110:16\n    |\n LL |     let other::C(_a, _b) = c;\n-   |                ^\n+   |                ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n    |              ---------------- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:3:1\n+   |\n+LL | pub struct C(pub isize, isize);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:111:22\n    |\n LL |     match c { other::C(_, _) => {} }\n-   |                      ^\n+   |                      ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n    |              ---------------- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:3:1\n+   |\n+LL | pub struct C(pub isize, isize);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:112:22\n    |\n LL |     match c { other::C(_a, _) => {} }\n-   |                      ^\n+   |                      ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n    |              ---------------- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:3:1\n+   |\n+LL | pub struct C(pub isize, isize);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:113:22\n    |\n LL |     match c { other::C(_, _b) => {} }\n-   |                      ^\n+   |                      ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n    |              ---------------- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:3:1\n+   |\n+LL | pub struct C(pub isize, isize);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:114:22\n    |\n LL |     match c { other::C(_a, _b) => {} }\n-   |                      ^\n+   |                      ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n    |              ---------------- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:3:1\n+   |\n+LL | pub struct C(pub isize, isize);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `A` is private\n   --> $DIR/privacy5.rs:122:21\n    |\n LL |     let a2 = other::A;\n-   |                     ^\n+   |                     ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:1:14\n    |\n LL | pub struct A(());\n    |              -- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `A` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:1:1\n+   |\n+LL | pub struct A(());\n+   | ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `B` is private\n   --> $DIR/privacy5.rs:123:21\n    |\n LL |     let b2 = other::B;\n-   |                     ^\n+   |                     ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:2:14\n    |\n LL | pub struct B(isize);\n    |              ----- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `B` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:2:1\n+   |\n+LL | pub struct B(isize);\n+   | ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `C` is private\n   --> $DIR/privacy5.rs:124:21\n    |\n LL |     let c2 = other::C;\n-   |                     ^\n+   |                     ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy_tuple_struct.rs:3:14\n    |\n LL | pub struct C(pub isize, isize);\n    |              ---------------- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `C` is defined here\n+  --> $DIR/auxiliary/privacy_tuple_struct.rs:3:1\n+   |\n+LL | pub struct C(pub isize, isize);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 48 previous errors\n "}, {"sha": "f51b74f6cb53b343d1f56357537a92f4eca7ff1d", "filename": "src/test/ui/privacy/private-item-simple.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivate-item-simple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Fprivate-item-simple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-item-simple.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: function `f` is private\n   --> $DIR/private-item-simple.rs:6:8\n    |\n LL |     a::f();\n-   |        ^\n+   |        ^ this function is private\n+   |\n+note: the function `f` is defined here\n+  --> $DIR/private-item-simple.rs:2:5\n+   |\n+LL |     fn f() {}\n+   |     ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "aac444b8e3c98054f67a1a7dad6f368682ef72d1", "filename": "src/test/ui/privacy/restricted/test.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -26,13 +26,25 @@ error[E0603]: struct `Crate` is private\n   --> $DIR/test.rs:38:25\n    |\n LL |     use pub_restricted::Crate;\n-   |                         ^^^^^\n+   |                         ^^^^^ this struct is private\n+   |\n+note: the struct `Crate` is defined here\n+  --> $DIR/auxiliary/pub_restricted.rs:3:1\n+   |\n+LL | pub(crate) struct Crate;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: function `f` is private\n   --> $DIR/test.rs:30:19\n    |\n LL |     use foo::bar::f;\n-   |                   ^\n+   |                   ^ this function is private\n+   |\n+note: the function `f` is defined here\n+  --> $DIR/test.rs:8:9\n+   |\n+LL |         pub(super) fn f() {}\n+   |         ^^^^^^^^^^^^^^^^^\n \n error[E0616]: field `x` of struct `foo::bar::S` is private\n   --> $DIR/test.rs:31:5"}, {"sha": "50f04b1eae1506649ef2f0196c7b9e015a0272af", "filename": "src/test/ui/proc-macro/disappearing-resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fproc-macro%2Fdisappearing-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fproc-macro%2Fdisappearing-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdisappearing-resolution.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -8,7 +8,7 @@ extern crate test_macros;\n mod m {\n     use test_macros::Empty;\n }\n-use m::Empty; //~ ERROR derive macro `Empty` is private\n+use m::Empty; //~ ERROR derive macro import `Empty` is private\n \n // To resolve `empty_helper` we need to resolve `Empty`.\n // During initial resolution `use m::Empty` introduces no entries, so we proceed to `macro_use`,"}, {"sha": "3beaedf61d73a722be48a20e30a7d152e69722f6", "filename": "src/test/ui/proc-macro/disappearing-resolution.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fproc-macro%2Fdisappearing-resolution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fproc-macro%2Fdisappearing-resolution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdisappearing-resolution.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -4,11 +4,17 @@ error: cannot find attribute `empty_helper` in this scope\n LL | #[empty_helper]\n    |   ^^^^^^^^^^^^\n \n-error[E0603]: derive macro `Empty` is private\n+error[E0603]: derive macro import `Empty` is private\n   --> $DIR/disappearing-resolution.rs:11:8\n    |\n LL | use m::Empty;\n-   |        ^^^^^\n+   |        ^^^^^ this derive macro import is private\n+   |\n+note: the derive macro import `Empty` is defined here\n+  --> $DIR/disappearing-resolution.rs:9:9\n+   |\n+LL |     use test_macros::Empty;\n+   |         ^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c2e1d774e28ac469a07e02fd8e7428707fbfc08c", "filename": "src/test/ui/reachable/unreachable-variant.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Freachable%2Funreachable-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Freachable%2Funreachable-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Funreachable-variant.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,7 +2,13 @@ error[E0603]: module `super_sekrit` is private\n   --> $DIR/unreachable-variant.rs:6:21\n    |\n LL |     let _x = other::super_sekrit::sooper_sekrit::baz;\n-   |                     ^^^^^^^^^^^^\n+   |                     ^^^^^^^^^^^^ this module is private\n+   |\n+note: the module `super_sekrit` is defined here\n+  --> $DIR/auxiliary/unreachable_variant.rs:1:1\n+   |\n+LL | mod super_sekrit {\n+   | ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "67d87eb5cd520077ade2237ccdc81e1a8409952b", "filename": "src/test/ui/repr/repr-packed-contains-align.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Frepr%2Frepr-packed-contains-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Frepr%2Frepr-packed-contains-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Frepr-packed-contains-align.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -16,34 +16,34 @@ union UB {\n }\n \n #[repr(packed)]\n-struct SC(SA); //~ ERROR: packed type cannot transitively contain a `[repr(align)]` type\n+struct SC(SA); //~ ERROR: packed type cannot transitively contain a `#[repr(align)]` type\n \n #[repr(packed)]\n-struct SD(SB); //~ ERROR: packed type cannot transitively contain a `[repr(align)]` type\n+struct SD(SB); //~ ERROR: packed type cannot transitively contain a `#[repr(align)]` type\n \n #[repr(packed)]\n-struct SE(UA); //~ ERROR: packed type cannot transitively contain a `[repr(align)]` type\n+struct SE(UA); //~ ERROR: packed type cannot transitively contain a `#[repr(align)]` type\n \n #[repr(packed)]\n-struct SF(UB); //~ ERROR: packed type cannot transitively contain a `[repr(align)]` type\n+struct SF(UB); //~ ERROR: packed type cannot transitively contain a `#[repr(align)]` type\n \n #[repr(packed)]\n-union UC { //~ ERROR: packed type cannot transitively contain a `[repr(align)]` type\n+union UC { //~ ERROR: packed type cannot transitively contain a `#[repr(align)]` type\n     a: UA\n }\n \n #[repr(packed)]\n-union UD { //~ ERROR: packed type cannot transitively contain a `[repr(align)]` type\n+union UD { //~ ERROR: packed type cannot transitively contain a `#[repr(align)]` type\n     n: UB\n }\n \n #[repr(packed)]\n-union UE { //~ ERROR: packed type cannot transitively contain a `[repr(align)]` type\n+union UE { //~ ERROR: packed type cannot transitively contain a `#[repr(align)]` type\n     a: SA\n }\n \n #[repr(packed)]\n-union UF { //~ ERROR: packed type cannot transitively contain a `[repr(align)]` type\n+union UF { //~ ERROR: packed type cannot transitively contain a `#[repr(align)]` type\n     n: SB\n }\n "}, {"sha": "32f9bb8bf33d9705ebc2bc018fd4b4d7661e279f", "filename": "src/test/ui/repr/repr-packed-contains-align.stderr", "status": "modified", "additions": 104, "deletions": 8, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Frepr%2Frepr-packed-contains-align.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Frepr%2Frepr-packed-contains-align.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Frepr-packed-contains-align.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -1,58 +1,154 @@\n-error[E0588]: packed type cannot transitively contain a `[repr(align)]` type\n+error[E0588]: packed type cannot transitively contain a `#[repr(align)]` type\n   --> $DIR/repr-packed-contains-align.rs:19:1\n    |\n LL | struct SC(SA);\n    | ^^^^^^^^^^^^^^\n+   |\n+note: `SA` has a `#[repr(align)]` attribute\n+  --> $DIR/repr-packed-contains-align.rs:5:1\n+   |\n+LL | struct SA(i32);\n+   | ^^^^^^^^^^^^^^^\n \n-error[E0588]: packed type cannot transitively contain a `[repr(align)]` type\n+error[E0588]: packed type cannot transitively contain a `#[repr(align)]` type\n   --> $DIR/repr-packed-contains-align.rs:22:1\n    |\n LL | struct SD(SB);\n    | ^^^^^^^^^^^^^^\n+   |\n+note: `SA` has a `#[repr(align)]` attribute\n+  --> $DIR/repr-packed-contains-align.rs:5:1\n+   |\n+LL | struct SA(i32);\n+   | ^^^^^^^^^^^^^^^\n+note: `SD` contains a field of type `SB`\n+  --> $DIR/repr-packed-contains-align.rs:22:11\n+   |\n+LL | struct SD(SB);\n+   |           ^^\n+note: ...which contains a field of type `SA`\n+  --> $DIR/repr-packed-contains-align.rs:7:11\n+   |\n+LL | struct SB(SA);\n+   |           ^^\n \n-error[E0588]: packed type cannot transitively contain a `[repr(align)]` type\n+error[E0588]: packed type cannot transitively contain a `#[repr(align)]` type\n   --> $DIR/repr-packed-contains-align.rs:25:1\n    |\n LL | struct SE(UA);\n    | ^^^^^^^^^^^^^^\n+   |\n+note: `UA` has a `#[repr(align)]` attribute\n+  --> $DIR/repr-packed-contains-align.rs:10:1\n+   |\n+LL | / union UA {\n+LL | |     i: i32\n+LL | | }\n+   | |_^\n \n-error[E0588]: packed type cannot transitively contain a `[repr(align)]` type\n+error[E0588]: packed type cannot transitively contain a `#[repr(align)]` type\n   --> $DIR/repr-packed-contains-align.rs:28:1\n    |\n LL | struct SF(UB);\n    | ^^^^^^^^^^^^^^\n+   |\n+note: `UA` has a `#[repr(align)]` attribute\n+  --> $DIR/repr-packed-contains-align.rs:10:1\n+   |\n+LL | / union UA {\n+LL | |     i: i32\n+LL | | }\n+   | |_^\n+note: `SF` contains a field of type `UB`\n+  --> $DIR/repr-packed-contains-align.rs:28:11\n+   |\n+LL | struct SF(UB);\n+   |           ^^\n+note: ...which contains a field of type `UA`\n+  --> $DIR/repr-packed-contains-align.rs:15:5\n+   |\n+LL |     a: UA\n+   |     ^\n \n-error[E0588]: packed type cannot transitively contain a `[repr(align)]` type\n+error[E0588]: packed type cannot transitively contain a `#[repr(align)]` type\n   --> $DIR/repr-packed-contains-align.rs:31:1\n    |\n LL | / union UC {\n LL | |     a: UA\n+LL | | }\n+   | |_^\n+   |\n+note: `UA` has a `#[repr(align)]` attribute\n+  --> $DIR/repr-packed-contains-align.rs:10:1\n+   |\n+LL | / union UA {\n+LL | |     i: i32\n LL | | }\n    | |_^\n \n-error[E0588]: packed type cannot transitively contain a `[repr(align)]` type\n+error[E0588]: packed type cannot transitively contain a `#[repr(align)]` type\n   --> $DIR/repr-packed-contains-align.rs:36:1\n    |\n LL | / union UD {\n LL | |     n: UB\n LL | | }\n    | |_^\n+   |\n+note: `UA` has a `#[repr(align)]` attribute\n+  --> $DIR/repr-packed-contains-align.rs:10:1\n+   |\n+LL | / union UA {\n+LL | |     i: i32\n+LL | | }\n+   | |_^\n+note: `UD` contains a field of type `UB`\n+  --> $DIR/repr-packed-contains-align.rs:37:5\n+   |\n+LL |     n: UB\n+   |     ^\n+note: ...which contains a field of type `UA`\n+  --> $DIR/repr-packed-contains-align.rs:15:5\n+   |\n+LL |     a: UA\n+   |     ^\n \n-error[E0588]: packed type cannot transitively contain a `[repr(align)]` type\n+error[E0588]: packed type cannot transitively contain a `#[repr(align)]` type\n   --> $DIR/repr-packed-contains-align.rs:41:1\n    |\n LL | / union UE {\n LL | |     a: SA\n LL | | }\n    | |_^\n+   |\n+note: `SA` has a `#[repr(align)]` attribute\n+  --> $DIR/repr-packed-contains-align.rs:5:1\n+   |\n+LL | struct SA(i32);\n+   | ^^^^^^^^^^^^^^^\n \n-error[E0588]: packed type cannot transitively contain a `[repr(align)]` type\n+error[E0588]: packed type cannot transitively contain a `#[repr(align)]` type\n   --> $DIR/repr-packed-contains-align.rs:46:1\n    |\n LL | / union UF {\n LL | |     n: SB\n LL | | }\n    | |_^\n+   |\n+note: `SA` has a `#[repr(align)]` attribute\n+  --> $DIR/repr-packed-contains-align.rs:5:1\n+   |\n+LL | struct SA(i32);\n+   | ^^^^^^^^^^^^^^^\n+note: `UF` contains a field of type `SB`\n+  --> $DIR/repr-packed-contains-align.rs:47:5\n+   |\n+LL |     n: SB\n+   |     ^\n+note: ...which contains a field of type `SA`\n+  --> $DIR/repr-packed-contains-align.rs:7:11\n+   |\n+LL | struct SB(SA);\n+   |           ^^\n \n error: aborting due to 8 previous errors\n "}, {"sha": "08a1d790197a6384740304397043239d0d97aa95", "filename": "src/test/ui/resolve/privacy-enum-ctor.stderr", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -253,25 +253,49 @@ error[E0603]: enum `Z` is private\n   --> $DIR/privacy-enum-ctor.rs:57:22\n    |\n LL |     let _: Z = m::n::Z;\n-   |                      ^\n+   |                      ^ this enum is private\n+   |\n+note: the enum `Z` is defined here\n+  --> $DIR/privacy-enum-ctor.rs:11:9\n+   |\n+LL |         pub(in m) enum Z {\n+   |         ^^^^^^^^^^^^^^^^\n \n error[E0603]: enum `Z` is private\n   --> $DIR/privacy-enum-ctor.rs:61:22\n    |\n LL |     let _: Z = m::n::Z::Fn;\n-   |                      ^\n+   |                      ^ this enum is private\n+   |\n+note: the enum `Z` is defined here\n+  --> $DIR/privacy-enum-ctor.rs:11:9\n+   |\n+LL |         pub(in m) enum Z {\n+   |         ^^^^^^^^^^^^^^^^\n \n error[E0603]: enum `Z` is private\n   --> $DIR/privacy-enum-ctor.rs:64:22\n    |\n LL |     let _: Z = m::n::Z::Struct;\n-   |                      ^\n+   |                      ^ this enum is private\n+   |\n+note: the enum `Z` is defined here\n+  --> $DIR/privacy-enum-ctor.rs:11:9\n+   |\n+LL |         pub(in m) enum Z {\n+   |         ^^^^^^^^^^^^^^^^\n \n error[E0603]: enum `Z` is private\n   --> $DIR/privacy-enum-ctor.rs:68:22\n    |\n LL |     let _: Z = m::n::Z::Unit {};\n-   |                      ^\n+   |                      ^ this enum is private\n+   |\n+note: the enum `Z` is defined here\n+  --> $DIR/privacy-enum-ctor.rs:11:9\n+   |\n+LL |         pub(in m) enum Z {\n+   |         ^^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/privacy-enum-ctor.rs:27:20"}, {"sha": "1673ec46ba488c7260acc7468a318e7f14b3874e", "filename": "src/test/ui/resolve/privacy-struct-ctor.stderr", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -45,7 +45,13 @@ LL |         pub(in m) struct Z(pub(in m::n) u8);\n    |                            --------------- a constructor is private if any of the fields is private\n ...\n LL |         n::Z;\n-   |            ^\n+   |            ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `Z` is defined here\n+  --> $DIR/privacy-struct-ctor.rs:12:9\n+   |\n+LL |         pub(in m) struct Z(pub(in m::n) u8);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `S` is private\n   --> $DIR/privacy-struct-ctor.rs:29:8\n@@ -54,7 +60,13 @@ LL |     pub struct S(u8);\n    |                  -- a constructor is private if any of the fields is private\n ...\n LL |     m::S;\n-   |        ^\n+   |        ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `S` is defined here\n+  --> $DIR/privacy-struct-ctor.rs:6:5\n+   |\n+LL |     pub struct S(u8);\n+   |     ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `S` is private\n   --> $DIR/privacy-struct-ctor.rs:31:19\n@@ -63,7 +75,13 @@ LL |     pub struct S(u8);\n    |                  -- a constructor is private if any of the fields is private\n ...\n LL |     let _: S = m::S(2);\n-   |                   ^\n+   |                   ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `S` is defined here\n+  --> $DIR/privacy-struct-ctor.rs:6:5\n+   |\n+LL |     pub struct S(u8);\n+   |     ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `Z` is private\n   --> $DIR/privacy-struct-ctor.rs:35:11\n@@ -72,29 +90,47 @@ LL |         pub(in m) struct Z(pub(in m::n) u8);\n    |                            --------------- a constructor is private if any of the fields is private\n ...\n LL |     m::n::Z;\n-   |           ^\n+   |           ^ this tuple struct constructor is private\n+   |\n+note: the tuple struct constructor `Z` is defined here\n+  --> $DIR/privacy-struct-ctor.rs:12:9\n+   |\n+LL |         pub(in m) struct Z(pub(in m::n) u8);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `S` is private\n   --> $DIR/privacy-struct-ctor.rs:41:16\n    |\n LL |     xcrate::m::S;\n-   |                ^\n+   |                ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy-struct-ctor.rs:2:18\n    |\n LL |     pub struct S(u8);\n    |                  -- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `S` is defined here\n+  --> $DIR/auxiliary/privacy-struct-ctor.rs:2:5\n+   |\n+LL |     pub struct S(u8);\n+   |     ^^^^^^^^^^^^^^^^^\n \n error[E0603]: tuple struct constructor `Z` is private\n   --> $DIR/privacy-struct-ctor.rs:45:19\n    |\n LL |     xcrate::m::n::Z;\n-   |                   ^\n+   |                   ^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/privacy-struct-ctor.rs:5:28\n    |\n LL |         pub(in m) struct Z(pub(in m::n) u8);\n    |                            --------------- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `Z` is defined here\n+  --> $DIR/auxiliary/privacy-struct-ctor.rs:5:9\n+   |\n+LL |         pub(in m) struct Z(pub(in m::n) u8);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 10 previous errors\n "}, {"sha": "f992988c93fcc502972030e0adb401823930ba9a", "filename": "src/test/ui/rfc-2008-non-exhaustive/struct.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -14,18 +14,30 @@ error[E0603]: tuple struct constructor `TupleStruct` is private\n   --> $DIR/struct.rs:23:32\n    |\n LL |     let ts_explicit = structs::TupleStruct(640, 480);\n-   |                                ^^^^^^^^^^^\n+   |                                ^^^^^^^^^^^ this tuple struct constructor is private\n    | \n   ::: $DIR/auxiliary/structs.rs:11:24\n    |\n LL | pub struct TupleStruct(pub u16, pub u16);\n    |                        ---------------- a constructor is private if any of the fields is private\n+   |\n+note: the tuple struct constructor `TupleStruct` is defined here\n+  --> $DIR/auxiliary/structs.rs:11:1\n+   |\n+LL | pub struct TupleStruct(pub u16, pub u16);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: unit struct `UnitStruct` is private\n   --> $DIR/struct.rs:32:32\n    |\n LL |     let us_explicit = structs::UnitStruct;\n-   |                                ^^^^^^^^^^\n+   |                                ^^^^^^^^^^ this unit struct is private\n+   |\n+note: the unit struct `UnitStruct` is defined here\n+  --> $DIR/auxiliary/structs.rs:8:1\n+   |\n+LL | pub struct UnitStruct;\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0639]: cannot create non-exhaustive struct using struct expression\n   --> $DIR/struct.rs:7:14"}, {"sha": "2a438753a2c70148ee734037a7b4fb1a1922840a", "filename": "src/test/ui/rfc-2008-non-exhaustive/variant.stderr", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,31 +2,61 @@ error[E0603]: tuple variant `Tuple` is private\n   --> $DIR/variant.rs:11:48\n    |\n LL |     let variant_tuple = NonExhaustiveVariants::Tuple(640);\n-   |                                                ^^^^^\n+   |                                                ^^^^^ this tuple variant is private\n+   |\n+note: the tuple variant `Tuple` is defined here\n+  --> $DIR/auxiliary/variants.rs:5:23\n+   |\n+LL |     #[non_exhaustive] Tuple(u32),\n+   |                       ^^^^^^^^^^\n \n error[E0603]: unit variant `Unit` is private\n   --> $DIR/variant.rs:14:47\n    |\n LL |     let variant_unit = NonExhaustiveVariants::Unit;\n-   |                                               ^^^^\n+   |                                               ^^^^ this unit variant is private\n+   |\n+note: the unit variant `Unit` is defined here\n+  --> $DIR/auxiliary/variants.rs:4:23\n+   |\n+LL |     #[non_exhaustive] Unit,\n+   |                       ^^^^\n \n error[E0603]: unit variant `Unit` is private\n   --> $DIR/variant.rs:18:32\n    |\n LL |         NonExhaustiveVariants::Unit => \"\",\n-   |                                ^^^^\n+   |                                ^^^^ this unit variant is private\n+   |\n+note: the unit variant `Unit` is defined here\n+  --> $DIR/auxiliary/variants.rs:4:23\n+   |\n+LL |     #[non_exhaustive] Unit,\n+   |                       ^^^^\n \n error[E0603]: tuple variant `Tuple` is private\n   --> $DIR/variant.rs:20:32\n    |\n LL |         NonExhaustiveVariants::Tuple(fe_tpl) => \"\",\n-   |                                ^^^^^\n+   |                                ^^^^^ this tuple variant is private\n+   |\n+note: the tuple variant `Tuple` is defined here\n+  --> $DIR/auxiliary/variants.rs:5:23\n+   |\n+LL |     #[non_exhaustive] Tuple(u32),\n+   |                       ^^^^^^^^^^\n \n error[E0603]: tuple variant `Tuple` is private\n   --> $DIR/variant.rs:26:35\n    |\n LL |     if let NonExhaustiveVariants::Tuple(fe_tpl) = variant_struct {\n-   |                                   ^^^^^\n+   |                                   ^^^^^ this tuple variant is private\n+   |\n+note: the tuple variant `Tuple` is defined here\n+  --> $DIR/auxiliary/variants.rs:5:23\n+   |\n+LL |     #[non_exhaustive] Tuple(u32),\n+   |                       ^^^^^^^^^^\n \n error[E0639]: cannot create non-exhaustive variant using struct expression\n   --> $DIR/variant.rs:8:26"}, {"sha": "6b801972f4179bd5002c5d3594e0c44cfafa3942", "filename": "src/test/ui/shadowed/shadowed-use-visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-use-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-use-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-use-visibility.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -6,11 +6,11 @@ mod foo {\n }\n \n mod bar {\n-    use foo::bar::f as g; //~ ERROR module `bar` is private\n+    use foo::bar::f as g; //~ ERROR module import `bar` is private\n \n     use foo as f;\n     pub use foo::*;\n }\n \n-use bar::f::f; //~ ERROR module `f` is private\n+use bar::f::f; //~ ERROR module import `f` is private\n fn main() {}"}, {"sha": "cd8ec13794c6f13d6abe6df2c78bb1ea10c76d0a", "filename": "src/test/ui/shadowed/shadowed-use-visibility.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-use-visibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-use-visibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-use-visibility.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -1,14 +1,26 @@\n-error[E0603]: module `bar` is private\n+error[E0603]: module import `bar` is private\n   --> $DIR/shadowed-use-visibility.rs:9:14\n    |\n LL |     use foo::bar::f as g;\n-   |              ^^^\n+   |              ^^^ this module import is private\n+   |\n+note: the module import `bar` is defined here\n+  --> $DIR/shadowed-use-visibility.rs:4:9\n+   |\n+LL |     use foo as bar;\n+   |         ^^^^^^^^^^\n \n-error[E0603]: module `f` is private\n+error[E0603]: module import `f` is private\n   --> $DIR/shadowed-use-visibility.rs:15:10\n    |\n LL | use bar::f::f;\n-   |          ^\n+   |          ^ this module import is private\n+   |\n+note: the module import `f` is defined here\n+  --> $DIR/shadowed-use-visibility.rs:11:9\n+   |\n+LL |     use foo as f;\n+   |         ^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1815897f17a60ee22708c17f1fa3d3fb79969b4b", "filename": "src/test/ui/stability-in-private-module.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fstability-in-private-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fstability-in-private-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-in-private-module.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n fn main() {\n     let _ = std::thread::thread_info::current_thread();\n     //~^ERROR module `thread_info` is private"}, {"sha": "3a974164f94734f7634bd330bf2681527f05b3f3", "filename": "src/test/ui/stability-in-private-module.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fstability-in-private-module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fstability-in-private-module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-in-private-module.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -1,8 +1,14 @@\n error[E0603]: module `thread_info` is private\n-  --> $DIR/stability-in-private-module.rs:2:26\n+  --> $DIR/stability-in-private-module.rs:7:26\n    |\n LL |     let _ = std::thread::thread_info::current_thread();\n-   |                          ^^^^^^^^^^^\n+   |                          ^^^^^^^^^^^ this module is private\n+   |\n+note: the module `thread_info` is defined here\n+  --> $SRC_DIR/libstd/thread/mod.rs:LL:COL\n+   |\n+LL | use crate::sys_common::thread_info;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "f6cd40412dd843f635931d69f235f16b241adcca", "filename": "src/test/ui/static/static-priv-by-default2.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fstatic%2Fstatic-priv-by-default2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fstatic%2Fstatic-priv-by-default2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-priv-by-default2.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,13 +2,25 @@ error[E0603]: static `private` is private\n   --> $DIR/static-priv-by-default2.rs:15:30\n    |\n LL |     use child::childs_child::private;\n-   |                              ^^^^^^^\n+   |                              ^^^^^^^ this static is private\n+   |\n+note: the static `private` is defined here\n+  --> $DIR/static-priv-by-default2.rs:7:9\n+   |\n+LL |         static private: isize = 0;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: static `private` is private\n   --> $DIR/static-priv-by-default2.rs:23:33\n    |\n LL |     use static_priv_by_default::private;\n-   |                                 ^^^^^^^\n+   |                                 ^^^^^^^ this static is private\n+   |\n+note: the static `private` is defined here\n+  --> $DIR/auxiliary/static_priv_by_default.rs:3:1\n+   |\n+LL | static private: isize = 0;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0203b7b5242e5187f18357ad74343796ec96ee4b", "filename": "src/test/ui/structs/struct-variant-privacy-xc.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fstructs%2Fstruct-variant-privacy-xc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fstructs%2Fstruct-variant-privacy-xc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-variant-privacy-xc.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,13 +2,25 @@ error[E0603]: enum `Bar` is private\n   --> $DIR/struct-variant-privacy-xc.rs:4:33\n    |\n LL | fn f(b: struct_variant_privacy::Bar) {\n-   |                                 ^^^\n+   |                                 ^^^ this enum is private\n+   |\n+note: the enum `Bar` is defined here\n+  --> $DIR/auxiliary/struct_variant_privacy.rs:1:1\n+   |\n+LL | enum Bar {\n+   | ^^^^^^^^\n \n error[E0603]: enum `Bar` is private\n   --> $DIR/struct-variant-privacy-xc.rs:6:33\n    |\n LL |         struct_variant_privacy::Bar::Baz { a: _a } => {}\n-   |                                 ^^^\n+   |                                 ^^^ this enum is private\n+   |\n+note: the enum `Bar` is defined here\n+  --> $DIR/auxiliary/struct_variant_privacy.rs:1:1\n+   |\n+LL | enum Bar {\n+   | ^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d1b603f9d46fc027afc9eec22501c0e07d505160", "filename": "src/test/ui/structs/struct-variant-privacy.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fstructs%2Fstruct-variant-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fstructs%2Fstruct-variant-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-variant-privacy.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,13 +2,25 @@ error[E0603]: enum `Bar` is private\n   --> $DIR/struct-variant-privacy.rs:7:14\n    |\n LL | fn f(b: foo::Bar) {\n-   |              ^^^\n+   |              ^^^ this enum is private\n+   |\n+note: the enum `Bar` is defined here\n+  --> $DIR/struct-variant-privacy.rs:2:5\n+   |\n+LL |     enum Bar {\n+   |     ^^^^^^^^\n \n error[E0603]: enum `Bar` is private\n   --> $DIR/struct-variant-privacy.rs:9:14\n    |\n LL |         foo::Bar::Baz { a: _a } => {}\n-   |              ^^^\n+   |              ^^^ this enum is private\n+   |\n+note: the enum `Bar` is defined here\n+  --> $DIR/struct-variant-privacy.rs:2:5\n+   |\n+LL |     enum Bar {\n+   |     ^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b7bf5a150ea8ba90eaf29dcbfadeb1d993ee490a", "filename": "src/test/ui/test-panic-abort.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ftest-panic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ftest-panic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-panic-abort.rs?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -11,6 +11,7 @@\n #![cfg(test)]\n \n use std::io::Write;\n+use std::env;\n \n #[test]\n fn it_works() {\n@@ -35,3 +36,13 @@ fn it_fails() {\n fn it_exits() {\n     std::process::exit(123);\n }\n+\n+#[test]\n+fn no_residual_environment() {\n+    for (key, _) in env::vars() {\n+        // Look for keys like __RUST_TEST_INVOKE.\n+        if key.contains(\"TEST_INVOKE\") {\n+            panic!(\"shouldn't have '{}' in environment\", key);\n+        }\n+    }\n+}"}, {"sha": "2f4bc32ed6a1f3de8ac5c7cfc967fb10415d3d0e", "filename": "src/test/ui/test-panic-abort.run.stdout", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ftest-panic-abort.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ftest-panic-abort.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-panic-abort.run.stdout?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -1,9 +1,10 @@\n \n-running 4 tests\n+running 5 tests\n test it_exits ... FAILED\n test it_fails ... FAILED\n test it_panics ... ok\n test it_works ... ok\n+test no_residual_environment ... ok\n \n failures:\n \n@@ -17,13 +18,13 @@ testing123\n testing321\n thread 'main' panicked at 'assertion failed: `(left == right)`\n   left: `2`,\n- right: `5`', $DIR/test-panic-abort.rs:31:5\n+ right: `5`', $DIR/test-panic-abort.rs:32:5\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n \n \n failures:\n     it_exits\n     it_fails\n \n-test result: FAILED. 2 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out\n+test result: FAILED. 3 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out\n "}, {"sha": "9e8414f9c15febcbefaf8bc19d018a87e3ea50a6", "filename": "src/test/ui/type-alias-impl-trait/generic_underconstrained2.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -18,6 +18,8 @@ LL | type Underconstrained<T: std::fmt::Debug> = impl 'static;\n ...\n LL | fn underconstrained<U>(_: U) -> Underconstrained<U> {\n    |                     - help: consider restricting this bound: `U: std::fmt::Debug`\n+LL |     5u32\n+   |     ---- this returned value is of type `u32`\n    |\n    = help: the trait `std::fmt::Debug` is not implemented for `U`\n    = note: the return type of a function must have a statically known size\n@@ -30,6 +32,8 @@ LL | type Underconstrained2<T: std::fmt::Debug> = impl 'static;\n ...\n LL | fn underconstrained2<U, V>(_: U, _: V) -> Underconstrained2<V> {\n    |                         - help: consider restricting this bound: `V: std::fmt::Debug`\n+LL |     5u32\n+   |     ---- this returned value is of type `u32`\n    |\n    = help: the trait `std::fmt::Debug` is not implemented for `V`\n    = note: the return type of a function must have a statically known size"}, {"sha": "a656b20c23ec3a6f249367ea3560836f650b7d70", "filename": "src/test/ui/typeck/issue-57673-ice-on-deref-of-boxed-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ftypeck%2Fissue-57673-ice-on-deref-of-boxed-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Ftypeck%2Fissue-57673-ice-on-deref-of-boxed-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-57673-ice-on-deref-of-boxed-trait.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn ice(x: Box<dyn Iterator<Item=()>>) {\n    |                                       - possibly return type missing here?\n LL |     *x\n-   |     ^^ expected `()`, found trait `std::iter::Iterator`\n+   |     ^^ expected `()`, found trait object `dyn std::iter::Iterator`\n    |\n    = note: expected unit type `()`\n            found trait object `(dyn std::iter::Iterator<Item = ()> + 'static)`"}, {"sha": "3f38a6cae7b819055e7ca742b419b2763dc86e31", "filename": "src/test/ui/use/use-from-trait-xc.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait-xc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait-xc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait-xc.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -44,13 +44,25 @@ error[E0603]: struct `Foo` is private\n   --> $DIR/use-from-trait-xc.rs:14:24\n    |\n LL | use use_from_trait_xc::Foo::new;\n-   |                        ^^^\n+   |                        ^^^ this struct is private\n+   |\n+note: the struct `Foo` is defined here\n+  --> $DIR/auxiliary/use-from-trait-xc.rs:9:1\n+   |\n+LL | struct Foo;\n+   | ^^^^^^^^^^^\n \n error[E0603]: struct `Foo` is private\n   --> $DIR/use-from-trait-xc.rs:17:24\n    |\n LL | use use_from_trait_xc::Foo::C;\n-   |                        ^^^\n+   |                        ^^^ this struct is private\n+   |\n+note: the struct `Foo` is defined here\n+  --> $DIR/auxiliary/use-from-trait-xc.rs:9:1\n+   |\n+LL | struct Foo;\n+   | ^^^^^^^^^^^\n \n error: aborting due to 9 previous errors\n "}, {"sha": "4852759286ae632fee1fa9bba6dd25f849c157e3", "filename": "src/test/ui/use/use-mod/use-mod-3.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fuse%2Fuse-mod%2Fuse-mod-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fuse%2Fuse-mod%2Fuse-mod-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-mod%2Fuse-mod-3.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,13 +2,25 @@ error[E0603]: module `bar` is private\n   --> $DIR/use-mod-3.rs:1:10\n    |\n LL | use foo::bar::{\n-   |          ^^^\n+   |          ^^^ this module is private\n+   |\n+note: the module `bar` is defined here\n+  --> $DIR/use-mod-3.rs:9:5\n+   |\n+LL |     mod bar { pub type Bar = isize; }\n+   |     ^^^^^^^\n \n error[E0603]: module `bar` is private\n   --> $DIR/use-mod-3.rs:4:10\n    |\n LL | use foo::bar::{\n-   |          ^^^\n+   |          ^^^ this module is private\n+   |\n+note: the module `bar` is defined here\n+  --> $DIR/use-mod-3.rs:9:5\n+   |\n+LL |     mod bar { pub type Bar = isize; }\n+   |     ^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "842069d6135cbeba743ebd75c0c94da2fd55b5f9", "filename": "src/test/ui/xcrate/xcrate-private-by-default.stderr", "status": "modified", "additions": 70, "deletions": 10, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fxcrate%2Fxcrate-private-by-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2480c9eac15608591f58730aed27caac9c30b4c2/src%2Ftest%2Fui%2Fxcrate%2Fxcrate-private-by-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fxcrate%2Fxcrate-private-by-default.stderr?ref=2480c9eac15608591f58730aed27caac9c30b4c2", "patch": "@@ -2,61 +2,121 @@ error[E0603]: static `j` is private\n   --> $DIR/xcrate-private-by-default.rs:23:29\n    |\n LL |     static_priv_by_default::j;\n-   |                             ^\n+   |                             ^ this static is private\n+   |\n+note: the static `j` is defined here\n+  --> $DIR/auxiliary/static_priv_by_default.rs:47:1\n+   |\n+LL | static j: isize = 0;\n+   | ^^^^^^^^^^^^^^^^^^^^\n \n error[E0603]: function `k` is private\n   --> $DIR/xcrate-private-by-default.rs:25:29\n    |\n LL |     static_priv_by_default::k;\n-   |                             ^\n+   |                             ^ this function is private\n+   |\n+note: the function `k` is defined here\n+  --> $DIR/auxiliary/static_priv_by_default.rs:48:1\n+   |\n+LL | fn k() {}\n+   | ^^^^^^\n \n error[E0603]: unit struct `l` is private\n   --> $DIR/xcrate-private-by-default.rs:27:29\n    |\n LL |     static_priv_by_default::l;\n-   |                             ^\n+   |                             ^ this unit struct is private\n+   |\n+note: the unit struct `l` is defined here\n+  --> $DIR/auxiliary/static_priv_by_default.rs:49:1\n+   |\n+LL | struct l;\n+   | ^^^^^^^^^\n \n error[E0603]: enum `m` is private\n   --> $DIR/xcrate-private-by-default.rs:29:35\n    |\n LL |     foo::<static_priv_by_default::m>();\n-   |                                   ^\n+   |                                   ^ this enum is private\n+   |\n+note: the enum `m` is defined here\n+  --> $DIR/auxiliary/static_priv_by_default.rs:50:1\n+   |\n+LL | enum m {}\n+   | ^^^^^^\n \n error[E0603]: type alias `n` is private\n   --> $DIR/xcrate-private-by-default.rs:31:35\n    |\n LL |     foo::<static_priv_by_default::n>();\n-   |                                   ^\n+   |                                   ^ this type alias is private\n+   |\n+note: the type alias `n` is defined here\n+  --> $DIR/auxiliary/static_priv_by_default.rs:51:1\n+   |\n+LL | type n = isize;\n+   | ^^^^^^^^^^^^^^^\n \n error[E0603]: module `foo` is private\n   --> $DIR/xcrate-private-by-default.rs:35:29\n    |\n LL |     static_priv_by_default::foo::a;\n-   |                             ^^^\n+   |                             ^^^ this module is private\n+   |\n+note: the module `foo` is defined here\n+  --> $DIR/auxiliary/static_priv_by_default.rs:12:1\n+   |\n+LL | mod foo {\n+   | ^^^^^^^\n \n error[E0603]: module `foo` is private\n   --> $DIR/xcrate-private-by-default.rs:37:29\n    |\n LL |     static_priv_by_default::foo::b;\n-   |                             ^^^\n+   |                             ^^^ this module is private\n+   |\n+note: the module `foo` is defined here\n+  --> $DIR/auxiliary/static_priv_by_default.rs:12:1\n+   |\n+LL | mod foo {\n+   | ^^^^^^^\n \n error[E0603]: module `foo` is private\n   --> $DIR/xcrate-private-by-default.rs:39:29\n    |\n LL |     static_priv_by_default::foo::c;\n-   |                             ^^^\n+   |                             ^^^ this module is private\n+   |\n+note: the module `foo` is defined here\n+  --> $DIR/auxiliary/static_priv_by_default.rs:12:1\n+   |\n+LL | mod foo {\n+   | ^^^^^^^\n \n error[E0603]: module `foo` is private\n   --> $DIR/xcrate-private-by-default.rs:41:35\n    |\n LL |     foo::<static_priv_by_default::foo::d>();\n-   |                                   ^^^\n+   |                                   ^^^ this module is private\n+   |\n+note: the module `foo` is defined here\n+  --> $DIR/auxiliary/static_priv_by_default.rs:12:1\n+   |\n+LL | mod foo {\n+   | ^^^^^^^\n \n error[E0603]: module `foo` is private\n   --> $DIR/xcrate-private-by-default.rs:43:35\n    |\n LL |     foo::<static_priv_by_default::foo::e>();\n-   |                                   ^^^\n+   |                                   ^^^ this module is private\n+   |\n+note: the module `foo` is defined here\n+  --> $DIR/auxiliary/static_priv_by_default.rs:12:1\n+   |\n+LL | mod foo {\n+   | ^^^^^^^\n \n error: aborting due to 10 previous errors\n "}]}