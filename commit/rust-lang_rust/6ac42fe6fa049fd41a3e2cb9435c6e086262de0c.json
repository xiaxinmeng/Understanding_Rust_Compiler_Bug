{"sha": "6ac42fe6fa049fd41a3e2cb9435c6e086262de0c", "node_id": "C_kwDOAAsO6NoAKDZhYzQyZmU2ZmEwNDlmZDQxYTNlMmNiOTQzNWM2ZTA4NjI2MmRlMGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-17T16:01:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-17T16:01:55Z"}, "message": "Auto merge of #7971 - togami2864:fix/option-map-or-none, r=llogiq\n\nfix suggestion in option_map_or_none\n\nfix: #7960\nchangelog: change suggestion in the lint rule `option_map_or_none`", "tree": {"sha": "0b66bc2d873864486b2dab205623f438d44bc8e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b66bc2d873864486b2dab205623f438d44bc8e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c", "html_url": "https://github.com/rust-lang/rust/commit/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d550e5f5e6ae26500105aa139537c4a16e1f463e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d550e5f5e6ae26500105aa139537c4a16e1f463e", "html_url": "https://github.com/rust-lang/rust/commit/d550e5f5e6ae26500105aa139537c4a16e1f463e"}, {"sha": "8e317f5283969aa775552e659d4219bb2641954a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e317f5283969aa775552e659d4219bb2641954a", "html_url": "https://github.com/rust-lang/rust/commit/8e317f5283969aa775552e659d4219bb2641954a"}], "stats": {"total": 210, "additions": 141, "deletions": 69}, "files": [{"sha": "5e5c1038e829e76ddfe9a7007f19ca54328f9412", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 89, "deletions": 50, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=6ac42fe6fa049fd41a3e2cb9435c6e086262de0c", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_lang_ctor, single_segment_path};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -11,6 +11,28 @@ use rustc_span::symbol::sym;\n use super::OPTION_MAP_OR_NONE;\n use super::RESULT_MAP_OR_INTO_OPTION;\n \n+// The expression inside a closure may or may not have surrounding braces\n+// which causes problems when generating a suggestion.\n+fn reduce_unit_expression<'a>(\n+    cx: &LateContext<'_>,\n+    expr: &'a hir::Expr<'_>,\n+) -> Option<(&'a hir::Expr<'a>, &'a [hir::Expr<'a>])> {\n+    match expr.kind {\n+        hir::ExprKind::Call(func, arg_char) => Some((func, arg_char)),\n+        hir::ExprKind::Block(block, _) => {\n+            match (block.stmts, block.expr) {\n+                (&[], Some(inner_expr)) => {\n+                    // If block only contains an expression,\n+                    // reduce `|x| { x + 1 }` to `|x| x + 1`\n+                    reduce_unit_expression(cx, inner_expr)\n+                },\n+                _ => None,\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n /// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n@@ -31,58 +53,75 @@ pub(super) fn check<'tcx>(\n         return;\n     }\n \n-    let (lint_name, msg, instead, hint) = {\n-        let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n-            is_lang_ctor(cx, qpath, OptionNone)\n-        } else {\n-            return;\n-        };\n+    let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n+        is_lang_ctor(cx, qpath, OptionNone)\n+    } else {\n+        return;\n+    };\n \n-        if !default_arg_is_none {\n-            // nothing to lint!\n-            return;\n-        }\n+    if !default_arg_is_none {\n+        // nothing to lint!\n+        return;\n+    }\n \n-        let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n-            is_lang_ctor(cx, qpath, OptionSome)\n-        } else {\n-            false\n-        };\n+    let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n+        is_lang_ctor(cx, qpath, OptionSome)\n+    } else {\n+        false\n+    };\n+\n+    if is_option {\n+        let self_snippet = snippet(cx, recv.span, \"..\");\n+        if_chain! {\n+        if let hir::ExprKind::Closure(_, _, id, span, _) = map_arg.kind;\n+            let arg_snippet = snippet(cx, span, \"..\");\n+            let body = cx.tcx.hir().body(id);\n+                if let Some((func, arg_char)) = reduce_unit_expression(cx, &body.value);\n+                if arg_char.len() == 1;\n+                if let hir::ExprKind::Path(ref qpath) = func.kind;\n+                if let Some(segment) = single_segment_path(qpath);\n+                if segment.ident.name == sym::Some;\n+                then {\n+                    let func_snippet = snippet(cx, arg_char[0].span, \"..\");\n+                    let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n+                       `map(..)` instead\";\n+                    return span_lint_and_sugg(\n+                        cx,\n+                        OPTION_MAP_OR_NONE,\n+                        expr.span,\n+                        msg,\n+                        \"try using `map` instead\",\n+                        format!(\"{0}.map({1} {2})\", self_snippet, arg_snippet,func_snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n \n-        if is_option {\n-            let self_snippet = snippet(cx, recv.span, \"..\");\n-            let func_snippet = snippet(cx, map_arg.span, \"..\");\n-            let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n-                       `and_then(..)` instead\";\n-            (\n-                OPTION_MAP_OR_NONE,\n-                msg,\n-                \"try using `and_then` instead\",\n-                format!(\"{0}.and_then({1})\", self_snippet, func_snippet),\n-            )\n-        } else if f_arg_is_some {\n-            let msg = \"called `map_or(None, Some)` on a `Result` value. This can be done more directly by calling \\\n-                       `ok()` instead\";\n-            let self_snippet = snippet(cx, recv.span, \"..\");\n-            (\n-                RESULT_MAP_OR_INTO_OPTION,\n-                msg,\n-                \"try using `ok` instead\",\n-                format!(\"{0}.ok()\", self_snippet),\n-            )\n-        } else {\n-            // nothing to lint!\n-            return;\n         }\n-    };\n \n-    span_lint_and_sugg(\n-        cx,\n-        lint_name,\n-        expr.span,\n-        msg,\n-        instead,\n-        hint,\n-        Applicability::MachineApplicable,\n-    );\n+        let func_snippet = snippet(cx, map_arg.span, \"..\");\n+        let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n+                       `and_then(..)` instead\";\n+        return span_lint_and_sugg(\n+            cx,\n+            OPTION_MAP_OR_NONE,\n+            expr.span,\n+            msg,\n+            \"try using `and_then` instead\",\n+            format!(\"{0}.and_then({1})\", self_snippet, func_snippet),\n+            Applicability::MachineApplicable,\n+        );\n+    } else if f_arg_is_some {\n+        let msg = \"called `map_or(None, Some)` on a `Result` value. This can be done more directly by calling \\\n+                       `ok()` instead\";\n+        let self_snippet = snippet(cx, recv.span, \"..\");\n+        return span_lint_and_sugg(\n+            cx,\n+            RESULT_MAP_OR_INTO_OPTION,\n+            expr.span,\n+            msg,\n+            \"try using `ok` instead\",\n+            format!(\"{0}.ok()\", self_snippet),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n }"}, {"sha": "177054f763b276937e6770ef695e54d8e4279faf", "filename": "tests/ui/option_map_or_none.fixed", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c/tests%2Fui%2Foption_map_or_none.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c/tests%2Fui%2Foption_map_or_none.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_or_none.fixed?ref=6ac42fe6fa049fd41a3e2cb9435c6e086262de0c", "patch": "@@ -4,13 +4,19 @@\n \n fn main() {\n     let opt = Some(1);\n+    let bar = |_| Some(1);\n \n     // Check `OPTION_MAP_OR_NONE`.\n     // Single line case.\n-    let _ = opt.and_then(|x| Some(x + 1));\n+    let _: Option<i32> = opt.map(|x| x + 1);\n     // Multi-line case.\n     #[rustfmt::skip]\n-    let _ = opt.and_then(|x| {\n-                        Some(x + 1)\n-                       });\n+    let _: Option<i32> = opt.map(|x| x + 1);\n+    // function returning `Option`\n+    let _: Option<i32> = opt.and_then(bar);\n+    let _: Option<i32> = opt.and_then(|x| {\n+        let offset = 0;\n+        let height = x;\n+        Some(offset + height)\n+    });\n }"}, {"sha": "6908546d32507e91e7b47ba5a6b19a554c1077d7", "filename": "tests/ui/option_map_or_none.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c/tests%2Fui%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c/tests%2Fui%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_or_none.rs?ref=6ac42fe6fa049fd41a3e2cb9435c6e086262de0c", "patch": "@@ -4,13 +4,21 @@\n \n fn main() {\n     let opt = Some(1);\n+    let bar = |_| Some(1);\n \n     // Check `OPTION_MAP_OR_NONE`.\n     // Single line case.\n-    let _ = opt.map_or(None, |x| Some(x + 1));\n+    let _: Option<i32> = opt.map_or(None, |x| Some(x + 1));\n     // Multi-line case.\n     #[rustfmt::skip]\n-    let _ = opt.map_or(None, |x| {\n+    let _: Option<i32> = opt.map_or(None, |x| {\n                         Some(x + 1)\n                        });\n+    // function returning `Option`\n+    let _: Option<i32> = opt.map_or(None, bar);\n+    let _: Option<i32> = opt.map_or(None, |x| {\n+        let offset = 0;\n+        let height = x;\n+        Some(offset + height)\n+    });\n }"}, {"sha": "11bdd887b6d3bc6d3966179ee225052462106bf7", "filename": "tests/ui/option_map_or_none.stderr", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c/tests%2Fui%2Foption_map_or_none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c/tests%2Fui%2Foption_map_or_none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_or_none.stderr?ref=6ac42fe6fa049fd41a3e2cb9435c6e086262de0c", "patch": "@@ -1,26 +1,45 @@\n-error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `and_then(..)` instead\n-  --> $DIR/option_map_or_none.rs:10:13\n+error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `map(..)` instead\n+  --> $DIR/option_map_or_none.rs:11:26\n    |\n-LL |     let _ = opt.map_or(None, |x| Some(x + 1));\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `opt.and_then(|x| Some(x + 1))`\n+LL |     let _: Option<i32> = opt.map_or(None, |x| Some(x + 1));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `map` instead: `opt.map(|x| x + 1)`\n    |\n    = note: `-D clippy::option-map-or-none` implied by `-D warnings`\n \n-error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `and_then(..)` instead\n-  --> $DIR/option_map_or_none.rs:13:13\n+error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `map(..)` instead\n+  --> $DIR/option_map_or_none.rs:14:26\n    |\n-LL |       let _ = opt.map_or(None, |x| {\n-   |  _____________^\n+LL |       let _: Option<i32> = opt.map_or(None, |x| {\n+   |  __________________________^\n LL | |                         Some(x + 1)\n LL | |                        });\n-   | |_________________________^\n+   | |_________________________^ help: try using `map` instead: `opt.map(|x| x + 1)`\n+\n+error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `and_then(..)` instead\n+  --> $DIR/option_map_or_none.rs:18:26\n+   |\n+LL |     let _: Option<i32> = opt.map_or(None, bar);\n+   |                          ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `opt.and_then(bar)`\n+\n+error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `and_then(..)` instead\n+  --> $DIR/option_map_or_none.rs:19:26\n+   |\n+LL |       let _: Option<i32> = opt.map_or(None, |x| {\n+   |  __________________________^\n+LL | |         let offset = 0;\n+LL | |         let height = x;\n+LL | |         Some(offset + height)\n+LL | |     });\n+   | |______^\n    |\n help: try using `and_then` instead\n    |\n-LL ~     let _ = opt.and_then(|x| {\n-LL +                         Some(x + 1)\n-LL ~                        });\n+LL ~     let _: Option<i32> = opt.and_then(|x| {\n+LL +         let offset = 0;\n+LL +         let height = x;\n+LL +         Some(offset + height)\n+LL ~     });\n    |\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n "}]}