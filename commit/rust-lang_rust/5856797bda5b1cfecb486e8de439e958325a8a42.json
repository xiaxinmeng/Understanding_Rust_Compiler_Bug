{"sha": "5856797bda5b1cfecb486e8de439e958325a8a42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NTY3OTdiZGE1YjFjZmVjYjQ4NmU4ZGU0MzllOTU4MzI1YThhNDI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-11-13T22:50:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-11-14T15:21:01Z"}, "message": "Revert \"Fixes #46775 -- don't mutate the process's environment in Command::exec\"\n\nThis reverts commit 36fe3b605a7a7143a14565272140ba1b43c1b041.", "tree": {"sha": "f99a1665487cc3a04016af162dea4007ca01fdd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f99a1665487cc3a04016af162dea4007ca01fdd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5856797bda5b1cfecb486e8de439e958325a8a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5856797bda5b1cfecb486e8de439e958325a8a42", "html_url": "https://github.com/rust-lang/rust/commit/5856797bda5b1cfecb486e8de439e958325a8a42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5856797bda5b1cfecb486e8de439e958325a8a42/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f244c9011eb01ae4d167b631ba5e3e163bafa72", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f244c9011eb01ae4d167b631ba5e3e163bafa72", "html_url": "https://github.com/rust-lang/rust/commit/6f244c9011eb01ae4d167b631ba5e3e163bafa72"}], "stats": {"total": 119, "additions": 8, "deletions": 111}, "files": [{"sha": "77f125f3c5b569b2b9597592f09a53a116149cd9", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5856797bda5b1cfecb486e8de439e958325a8a42/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5856797bda5b1cfecb486e8de439e958325a8a42/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=5856797bda5b1cfecb486e8de439e958325a8a42", "patch": "@@ -141,10 +141,6 @@ impl Command {\n     pub fn get_argv(&self) -> &Vec<*const c_char> {\n         &self.argv.0\n     }\n-    #[cfg(not(target_os = \"fuchsia\"))]\n-    pub fn get_program(&self) -> &CString {\n-        return &self.program;\n-    }\n \n     #[allow(dead_code)]\n     pub fn get_cwd(&self) -> &Option<CString> {\n@@ -248,10 +244,6 @@ impl CStringArray {\n     pub fn as_ptr(&self) -> *const *const c_char {\n         self.ptrs.as_ptr()\n     }\n-    #[cfg(not(target_os = \"fuchsia\"))]\n-    pub fn get_items(&self) -> &[CString] {\n-        return &self.items;\n-    }\n }\n \n fn construct_envp(env: BTreeMap<DefaultEnvKey, OsString>, saw_nul: &mut bool) -> CStringArray {"}, {"sha": "7f1f9353c6d09613e6f406aa018e6d2d160d1bc1", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 8, "deletions": 91, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/5856797bda5b1cfecb486e8de439e958325a8a42/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5856797bda5b1cfecb486e8de439e958325a8a42/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=5856797bda5b1cfecb486e8de439e958325a8a42", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use env;\n-use ffi::CString;\n use io::{self, Error, ErrorKind};\n use libc::{self, c_int, gid_t, pid_t, uid_t};\n use ptr;\n@@ -41,15 +39,13 @@ impl Command {\n             return Ok((ret, ours))\n         }\n \n-        let possible_paths = self.compute_possible_paths(envp.as_ref());\n-\n         let (input, output) = sys::pipe::anon_pipe()?;\n \n         let pid = unsafe {\n             match cvt(libc::fork())? {\n                 0 => {\n                     drop(input);\n-                    let err = self.do_exec(theirs, envp.as_ref(), possible_paths);\n+                    let err = self.do_exec(theirs, envp.as_ref());\n                     let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n                     let bytes = [\n                         (errno >> 24) as u8,\n@@ -117,48 +113,12 @@ impl Command {\n                                   \"nul byte found in provided data\")\n         }\n \n-        let possible_paths = self.compute_possible_paths(envp.as_ref());\n         match self.setup_io(default, true) {\n-            Ok((_, theirs)) => unsafe { self.do_exec(theirs, envp.as_ref(), possible_paths) },\n+            Ok((_, theirs)) => unsafe { self.do_exec(theirs, envp.as_ref()) },\n             Err(e) => e,\n         }\n     }\n \n-    fn compute_possible_paths(&self, maybe_envp: Option<&CStringArray>) -> Option<Vec<CString>> {\n-        let program = self.get_program().as_bytes();\n-        if program.contains(&b'/') {\n-            return None;\n-        }\n-        // Outside the match so we can borrow it for the lifetime of the function.\n-        let parent_path = env::var(\"PATH\").ok();\n-        let paths = match maybe_envp {\n-            Some(envp) => {\n-                match envp.get_items().iter().find(|var| var.as_bytes().starts_with(b\"PATH=\")) {\n-                    Some(p) => &p.as_bytes()[5..],\n-                    None => return None,\n-                }\n-            },\n-            // maybe_envp is None if the process isn't changing the parent's env at all.\n-            None => {\n-                match parent_path.as_ref() {\n-                    Some(p) => p.as_bytes(),\n-                    None => return None,\n-                }\n-            },\n-        };\n-\n-        let mut possible_paths = vec![];\n-        for path in paths.split(|p| *p == b':') {\n-            let mut binary_path = Vec::with_capacity(program.len() + path.len() + 1);\n-            binary_path.extend_from_slice(path);\n-            binary_path.push(b'/');\n-            binary_path.extend_from_slice(program);\n-            let c_binary_path = CString::new(binary_path).unwrap();\n-            possible_paths.push(c_binary_path);\n-        }\n-        return Some(possible_paths);\n-    }\n-\n     // And at this point we've reached a special time in the life of the\n     // child. The child must now be considered hamstrung and unable to\n     // do anything other than syscalls really. Consider the following\n@@ -192,8 +152,7 @@ impl Command {\n     unsafe fn do_exec(\n         &mut self,\n         stdio: ChildPipes,\n-        maybe_envp: Option<&CStringArray>,\n-        maybe_possible_paths: Option<Vec<CString>>,\n+        maybe_envp: Option<&CStringArray>\n     ) -> io::Error {\n         use sys::{self, cvt_r};\n \n@@ -234,6 +193,9 @@ impl Command {\n         if let Some(ref cwd) = *self.get_cwd() {\n             t!(cvt(libc::chdir(cwd.as_ptr())));\n         }\n+        if let Some(envp) = maybe_envp {\n+            *sys::os::environ() = envp.as_ptr();\n+        }\n \n         // emscripten has no signal support.\n         #[cfg(not(any(target_os = \"emscripten\")))]\n@@ -269,53 +231,8 @@ impl Command {\n             t!(callback());\n         }\n \n-        // If the program isn't an absolute path, and our environment contains a PATH var, then we\n-        // implement the PATH traversal ourselves so that it honors the child's PATH instead of the\n-        // parent's. This mirrors the logic that exists in glibc's execvpe, except using the\n-        // child's env to fetch PATH.\n-        match maybe_possible_paths {\n-            Some(possible_paths) => {\n-                let mut pending_error = None;\n-                for path in possible_paths {\n-                    libc::execve(\n-                        path.as_ptr(),\n-                        self.get_argv().as_ptr(),\n-                        maybe_envp.map(|envp| envp.as_ptr()).unwrap_or_else(|| *sys::os::environ())\n-                    );\n-                    let err = io::Error::last_os_error();\n-                    match err.kind() {\n-                        io::ErrorKind::PermissionDenied => {\n-                            // If we saw a PermissionDenied, and none of the other entries in\n-                            // $PATH are successful, then we'll return the first EACCESS we see.\n-                            if pending_error.is_none() {\n-                                pending_error = Some(err);\n-                            }\n-                        },\n-                        // Errors which indicate we failed to find a file are ignored and we try\n-                        // the next entry in the path.\n-                        io::ErrorKind::NotFound | io::ErrorKind::TimedOut => {\n-                            continue\n-                        },\n-                        // Any other error means we found a file and couldn't execute it.\n-                        _ => {\n-                            return err;\n-                        }\n-                    }\n-                }\n-                if let Some(err) = pending_error {\n-                    return err;\n-                }\n-                return io::Error::from_raw_os_error(libc::ENOENT);\n-            },\n-            _ => {\n-                libc::execve(\n-                    self.get_argv()[0],\n-                    self.get_argv().as_ptr(),\n-                    maybe_envp.map(|envp| envp.as_ptr()).unwrap_or_else(|| *sys::os::environ())\n-                );\n-                return io::Error::last_os_error()\n-            }\n-        }\n+        libc::execvp(self.get_argv()[0], self.get_argv().as_ptr());\n+        io::Error::last_os_error()\n     }\n \n     #[cfg(not(any(target_os = \"macos\", target_os = \"freebsd\","}, {"sha": "46b409fb13a84bc94763e528af8a0bc5dc43e6cb", "filename": "src/test/run-pass/command-exec.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5856797bda5b1cfecb486e8de439e958325a8a42/src%2Ftest%2Frun-pass%2Fcommand-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5856797bda5b1cfecb486e8de439e958325a8a42/src%2Ftest%2Frun-pass%2Fcommand-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-exec.rs?ref=5856797bda5b1cfecb486e8de439e958325a8a42", "patch": "@@ -48,13 +48,6 @@ fn main() {\n                 println!(\"passed\");\n             }\n \n-            \"exec-test5\" => {\n-                env::set_var(\"VARIABLE\", \"ABC\");\n-                Command::new(\"definitely-not-a-real-binary\").env(\"VARIABLE\", \"XYZ\").exec();\n-                assert_eq!(env::var(\"VARIABLE\").unwrap(), \"ABC\");\n-                println!(\"passed\");\n-            }\n-\n             _ => panic!(\"unknown argument: {}\", arg),\n         }\n         return\n@@ -79,9 +72,4 @@ fn main() {\n     assert!(output.status.success());\n     assert!(output.stderr.is_empty());\n     assert_eq!(output.stdout, b\"passed\\n\");\n-\n-    let output = Command::new(&me).arg(\"exec-test5\").output().unwrap();\n-    assert!(output.status.success());\n-    assert!(output.stderr.is_empty());\n-    assert_eq!(output.stdout, b\"passed\\n\");\n }"}]}