{"sha": "fa6a61c68930b390407d73e0ba71f2af5555f0f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNmE2MWM2ODkzMGIzOTA0MDdkNzNlMGJhNzFmMmFmNTU1NWYwZjA=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-06-11T17:48:46Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-06-26T20:28:09Z"}, "message": "Explain move errors that occur due to method calls involving `self`\n\nThis is a re-attempt of #72389 (which was reverted in #73594)\nInstead of using `ExpnKind::Desugaring` to represent operators, this PR\nchecks the lang item directly.", "tree": {"sha": "9d1ad6feeb72a826ca906a1a25a5271f5242a9b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d1ad6feeb72a826ca906a1a25a5271f5242a9b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa6a61c68930b390407d73e0ba71f2af5555f0f0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl72WloACgkQtAh+UQ6Y\nsWT7rRAAn4azvfoo7Pdl6sW9+ZUaG1OKIykkynBfEqT734AitySb1nLpBDoYI0PR\nh6qnCYTkc66kzqe8zE8gptsXU2DCIrqzFzXZPSoYgFZnbNCqNNqVR4XPP790WypF\nqiE62L1sAZxruUUZcxhW3p1I3Ex97877JheNQny1xfi1DgjYD/q7Mpc/hvw5uMyz\n0HLoBITMf7zJO69SKbgPDTtr14cive73iafP7TyYrrxRk7rUjP4hcIm0xkob8f1A\nohFLrAo0JS5P4dkxzqMeUJUTq3AlOM+UaRjKPQxLkfJtVH2OMeHiToXcK4R2udDk\n78dLYhZCCKoDpBfMxF0baosOOdehqn36qXkLUlBLukr8rtXlwwEFVWO5Xd3XOeJ7\nSsZ3rBxguv+UM+oZKtRmNY9jZLg2F6OkbSA02/A0TCU3M0+sLOeskKsVlQcAxGI2\nppmbemDrqMX40pZBBXzFOxuE2Dt9SYxybwrV02zuEETKMu+nleFoBxS21fl+2tNd\nZi+fRPwJad4PNqWPShhgnJZ454TAvB0tUZP21PvedPm4e09K/5br5YlD9l2k/xb4\n6elkf22ppLEnt0c7zAALAC3jhPLuK1yGU3pCY9h1RmLMpw1ILScot7jSsmgqRpAI\nK9lI7WV2Ezr4vlrtqGYjulgNAhhIUB2RHgUbfCFtRYyOvWEM/sc=\n=ttsJ\n-----END PGP SIGNATURE-----", "payload": "tree 9d1ad6feeb72a826ca906a1a25a5271f5242a9b7\nparent 36ac08e2643dc5cc035031007a8a36f4c87d3543\nauthor Aaron Hill <aa1ronham@gmail.com> 1591897726 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1593203289 -0400\n\nExplain move errors that occur due to method calls involving `self`\n\nThis is a re-attempt of #72389 (which was reverted in #73594)\nInstead of using `ExpnKind::Desugaring` to represent operators, this PR\nchecks the lang item directly.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa6a61c68930b390407d73e0ba71f2af5555f0f0", "html_url": "https://github.com/rust-lang/rust/commit/fa6a61c68930b390407d73e0ba71f2af5555f0f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa6a61c68930b390407d73e0ba71f2af5555f0f0/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36ac08e2643dc5cc035031007a8a36f4c87d3543", "url": "https://api.github.com/repos/rust-lang/rust/commits/36ac08e2643dc5cc035031007a8a36f4c87d3543", "html_url": "https://github.com/rust-lang/rust/commit/36ac08e2643dc5cc035031007a8a36f4c87d3543"}], "stats": {"total": 847, "additions": 745, "deletions": 102}, "files": [{"sha": "90a3a5ec64e0e56ba973720bc30932a8e9ffd267", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -9,7 +9,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n+use rustc_span::source_map::{respan, DesugaringKind, ForLoopLoc, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_target::asm;\n use std::collections::hash_map::Entry;\n@@ -1361,9 +1361,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: &Block,\n         opt_label: Option<Label>,\n     ) -> hir::Expr<'hir> {\n+        let orig_head_span = head.span;\n         // expand <head>\n         let mut head = self.lower_expr_mut(head);\n-        let desugared_span = self.mark_span_with_reason(DesugaringKind::ForLoop, head.span, None);\n+        let desugared_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop(ForLoopLoc::Head),\n+            orig_head_span,\n+            None,\n+        );\n         head.span = desugared_span;\n \n         let iter = Ident::with_dummy_span(sym::iter);\n@@ -1458,10 +1463,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `mut iter => { ... }`\n         let iter_arm = self.arm(iter_pat, loop_expr);\n \n+        let into_iter_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop(ForLoopLoc::IntoIter),\n+            orig_head_span,\n+            None,\n+        );\n+\n         // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n         let into_iter_expr = {\n             let into_iter_path = &[sym::iter, sym::IntoIterator, sym::into_iter];\n-            self.expr_call_std_path(desugared_span, into_iter_path, arena_vec![self; head])\n+            self.expr_call_std_path(into_iter_span, into_iter_path, arena_vec![self; head])\n         };\n \n         let match_expr = self.arena.alloc(self.expr_match("}, {"sha": "5aaf219b315bdc22b69dca21de23531cc104c681", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 55, "deletions": 25, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -21,11 +21,26 @@ use rustc_span::Span;\n \n use lazy_static::lazy_static;\n \n+pub enum LangItemGroup {\n+    Op,\n+}\n+\n+const NUM_GROUPS: usize = 1;\n+\n+macro_rules! expand_group {\n+    () => {\n+        None\n+    };\n+    ($group:expr) => {\n+        Some($group)\n+    };\n+}\n+\n // The actual lang items defined come at the end of this file in one handy table.\n // So you probably just want to nip down to the end.\n macro_rules! language_item_table {\n     (\n-        $( $variant:ident, $name:expr, $method:ident, $target:expr; )*\n+        $( $variant:ident $($group:expr)?, $name:expr, $method:ident, $target:expr; )*\n     ) => {\n \n         enum_from_u32! {\n@@ -45,6 +60,13 @@ macro_rules! language_item_table {\n                     $( $variant => $name, )*\n                 }\n             }\n+\n+            pub fn group(self) -> Option<LangItemGroup> {\n+                use LangItemGroup::*;\n+                match self {\n+                    $( $variant => expand_group!($($group)*), )*\n+                }\n+            }\n         }\n \n         #[derive(HashStable_Generic)]\n@@ -54,6 +76,9 @@ macro_rules! language_item_table {\n             pub items: Vec<Option<DefId>>,\n             /// Lang items that were not found during collection.\n             pub missing: Vec<LangItem>,\n+            /// Mapping from `LangItemGroup` discriminants to all\n+            /// `DefId`s of lang items in that group.\n+            pub groups: [Vec<DefId>; NUM_GROUPS],\n         }\n \n         impl LanguageItems {\n@@ -64,6 +89,7 @@ macro_rules! language_item_table {\n                 Self {\n                     items: vec![$(init_none($variant)),*],\n                     missing: Vec::new(),\n+                    groups: [vec![]; NUM_GROUPS],\n                 }\n             }\n \n@@ -79,6 +105,10 @@ macro_rules! language_item_table {\n                 self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n             }\n \n+            pub fn group(&self, group: LangItemGroup) -> &[DefId] {\n+                self.groups[group as usize].as_ref()\n+            }\n+\n             $(\n                 /// Returns the corresponding `DefId` for the lang item\n                 #[doc = $name]\n@@ -171,30 +201,30 @@ language_item_table! {\n     CoerceUnsizedTraitLangItem,  \"coerce_unsized\",     coerce_unsized_trait,    Target::Trait;\n     DispatchFromDynTraitLangItem,\"dispatch_from_dyn\",  dispatch_from_dyn_trait, Target::Trait;\n \n-    AddTraitLangItem,            \"add\",                add_trait,               Target::Trait;\n-    SubTraitLangItem,            \"sub\",                sub_trait,               Target::Trait;\n-    MulTraitLangItem,            \"mul\",                mul_trait,               Target::Trait;\n-    DivTraitLangItem,            \"div\",                div_trait,               Target::Trait;\n-    RemTraitLangItem,            \"rem\",                rem_trait,               Target::Trait;\n-    NegTraitLangItem,            \"neg\",                neg_trait,               Target::Trait;\n-    NotTraitLangItem,            \"not\",                not_trait,               Target::Trait;\n-    BitXorTraitLangItem,         \"bitxor\",             bitxor_trait,            Target::Trait;\n-    BitAndTraitLangItem,         \"bitand\",             bitand_trait,            Target::Trait;\n-    BitOrTraitLangItem,          \"bitor\",              bitor_trait,             Target::Trait;\n-    ShlTraitLangItem,            \"shl\",                shl_trait,               Target::Trait;\n-    ShrTraitLangItem,            \"shr\",                shr_trait,               Target::Trait;\n-    AddAssignTraitLangItem,      \"add_assign\",         add_assign_trait,        Target::Trait;\n-    SubAssignTraitLangItem,      \"sub_assign\",         sub_assign_trait,        Target::Trait;\n-    MulAssignTraitLangItem,      \"mul_assign\",         mul_assign_trait,        Target::Trait;\n-    DivAssignTraitLangItem,      \"div_assign\",         div_assign_trait,        Target::Trait;\n-    RemAssignTraitLangItem,      \"rem_assign\",         rem_assign_trait,        Target::Trait;\n-    BitXorAssignTraitLangItem,   \"bitxor_assign\",      bitxor_assign_trait,     Target::Trait;\n-    BitAndAssignTraitLangItem,   \"bitand_assign\",      bitand_assign_trait,     Target::Trait;\n-    BitOrAssignTraitLangItem,    \"bitor_assign\",       bitor_assign_trait,      Target::Trait;\n-    ShlAssignTraitLangItem,      \"shl_assign\",         shl_assign_trait,        Target::Trait;\n-    ShrAssignTraitLangItem,      \"shr_assign\",         shr_assign_trait,        Target::Trait;\n-    IndexTraitLangItem,          \"index\",              index_trait,             Target::Trait;\n-    IndexMutTraitLangItem,       \"index_mut\",          index_mut_trait,         Target::Trait;\n+    AddTraitLangItem(Op),        \"add\",                add_trait,               Target::Trait;\n+    SubTraitLangItem(Op),        \"sub\",                sub_trait,               Target::Trait;\n+    MulTraitLangItem(Op),        \"mul\",                mul_trait,               Target::Trait;\n+    DivTraitLangItem(Op),        \"div\",                div_trait,               Target::Trait;\n+    RemTraitLangItem(Op),        \"rem\",                rem_trait,               Target::Trait;\n+    NegTraitLangItem(Op),        \"neg\",                neg_trait,               Target::Trait;\n+    NotTraitLangItem(Op),        \"not\",                not_trait,               Target::Trait;\n+    BitXorTraitLangItem(Op),     \"bitxor\",             bitxor_trait,            Target::Trait;\n+    BitAndTraitLangItem(Op),     \"bitand\",             bitand_trait,            Target::Trait;\n+    BitOrTraitLangItem(Op),      \"bitor\",              bitor_trait,             Target::Trait;\n+    ShlTraitLangItem(Op),        \"shl\",                shl_trait,               Target::Trait;\n+    ShrTraitLangItem(Op),        \"shr\",                shr_trait,               Target::Trait;\n+    AddAssignTraitLangItem(Op),  \"add_assign\",         add_assign_trait,        Target::Trait;\n+    SubAssignTraitLangItem(Op),  \"sub_assign\",         sub_assign_trait,        Target::Trait;\n+    MulAssignTraitLangItem(Op),  \"mul_assign\",         mul_assign_trait,        Target::Trait;\n+    DivAssignTraitLangItem(Op),  \"div_assign\",         div_assign_trait,        Target::Trait;\n+    RemAssignTraitLangItem(Op),  \"rem_assign\",         rem_assign_trait,        Target::Trait;\n+    BitXorAssignTraitLangItem(Op),\"bitxor_assign\",     bitxor_assign_trait,     Target::Trait;\n+    BitAndAssignTraitLangItem(Op),\"bitand_assign\",     bitand_assign_trait,     Target::Trait;\n+    BitOrAssignTraitLangItem(Op),\"bitor_assign\",       bitor_assign_trait,      Target::Trait;\n+    ShlAssignTraitLangItem(Op),  \"shl_assign\",         shl_assign_trait,        Target::Trait;\n+    ShrAssignTraitLangItem(Op),  \"shr_assign\",         shr_assign_trait,        Target::Trait;\n+    IndexTraitLangItem(Op),      \"index\",              index_trait,             Target::Trait;\n+    IndexMutTraitLangItem(Op),   \"index_mut\",          index_mut_trait,         Target::Trait;\n \n     UnsafeCellTypeLangItem,      \"unsafe_cell\",        unsafe_cell_type,        Target::Struct;\n     VaListTypeLangItem,          \"va_list\",            va_list,                 Target::Struct;"}, {"sha": "1687bcc1556367900976f3ce64074720feceabba", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -468,7 +468,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let msg = if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.desugaring_kind() {\n                     None => format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                    Some(DesugaringKind::ForLoop) => {\n+                    Some(DesugaringKind::ForLoop(_)) => {\n                         \"the element type for this iterator is not specified\".to_string()\n                     }\n                     _ => format!(\"this needs {}\", suffix),"}, {"sha": "bb62c1bb82428d2bd19dcce8419e393d1d4433f5", "filename": "src/librustc_middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_middle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_middle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flint.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -339,7 +339,7 @@ pub fn struct_lint_level<'s, 'd>(\n pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n     let expn_data = span.ctxt().outer_expn_data();\n     match expn_data.kind {\n-        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n+        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop(_)) => false,\n         ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n             // Dummy span for the `def_site` means it's an external macro."}, {"sha": "e85f69554d0c831cf3ba0bf18180ff8c3bb7af89", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -24,7 +24,8 @@ use crate::borrow_check::{\n };\n \n use super::{\n-    explain_borrow::BorrowExplanation, IncludingDowncast, RegionName, RegionNameSource, UseSpans,\n+    explain_borrow::BorrowExplanation, FnSelfUseKind, IncludingDowncast, RegionName,\n+    RegionNameSource, UseSpans,\n };\n \n #[derive(Debug)]\n@@ -150,11 +151,68 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         format!(\"value moved{} here, in previous iteration of loop\", move_msg),\n                     );\n                 } else {\n-                    err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n-                    move_spans.var_span_label(\n-                        &mut err,\n-                        format!(\"variable moved due to use{}\", move_spans.describe()),\n-                    );\n+                    if let UseSpans::FnSelfUse { var_span, fn_call_span, fn_span, kind } =\n+                        move_spans\n+                    {\n+                        let place_name = self\n+                            .describe_place(moved_place.as_ref())\n+                            .map(|n| format!(\"`{}`\", n))\n+                            .unwrap_or_else(|| \"value\".to_owned());\n+                        match kind {\n+                            FnSelfUseKind::FnOnceCall => {\n+                                err.span_label(\n+                                    fn_call_span,\n+                                    &format!(\"{} moved due to this call\", place_name),\n+                                );\n+                                err.span_note(\n+                                    var_span,\n+                                    \"this value implements `FnOnce`, which causes it to be moved when called\",\n+                                );\n+                            }\n+                            FnSelfUseKind::Operator { self_arg } => {\n+                                err.span_label(\n+                                    fn_call_span,\n+                                    &format!(\"{} moved due to usage in operator\", place_name),\n+                                );\n+                                if self.fn_self_span_reported.insert(fn_span) {\n+                                    err.span_note(\n+                                        self_arg.span,\n+                                        \"calling this operator moves the left-hand side\",\n+                                    );\n+                                }\n+                            }\n+                            FnSelfUseKind::Normal { self_arg, implicit_into_iter } => {\n+                                if implicit_into_iter {\n+                                    err.span_label(\n+                                        fn_call_span,\n+                                        &format!(\n+                                            \"{} moved due to this implicit call to `.into_iter()`\",\n+                                            place_name\n+                                        ),\n+                                    );\n+                                } else {\n+                                    err.span_label(\n+                                        fn_call_span,\n+                                        &format!(\"{} moved due to this method call\", place_name),\n+                                    );\n+                                }\n+                                // Avoid pointing to the same function in multiple different\n+                                // error messages\n+                                if self.fn_self_span_reported.insert(self_arg.span) {\n+                                    err.span_note(\n+                                        self_arg.span,\n+                                        &format!(\"this function consumes the receiver `self` by taking ownership of it, which moves {}\", place_name)\n+                                    );\n+                                }\n+                            }\n+                        }\n+                    } else {\n+                        err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n+                        move_spans.var_span_label(\n+                            &mut err,\n+                            format!(\"variable moved due to use{}\", move_spans.describe()),\n+                        );\n+                    }\n                 }\n                 if let UseSpans::PatUse(span) = move_spans {\n                     err.span_suggestion_verbose(\n@@ -170,7 +228,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     );\n                 }\n \n-                if Some(DesugaringKind::ForLoop) == move_span.desugaring_kind() {\n+                if let Some(DesugaringKind::ForLoop(_)) = move_span.desugaring_kind() {\n                     let sess = self.infcx.tcx.sess;\n                     if let Ok(snippet) = sess.source_map().span_to_snippet(move_span) {\n                         err.span_suggestion("}, {"sha": "b591b938b5ac32efb41f8f391decc77879cff34d", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -509,7 +509,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // Used in a closure.\n                 (LaterUseKind::ClosureCapture, var_span)\n             }\n-            UseSpans::PatUse(span) | UseSpans::OtherUse(span) => {\n+            UseSpans::PatUse(span)\n+            | UseSpans::OtherUse(span)\n+            | UseSpans::FnSelfUse { var_span: span, .. } => {\n                 let block = &self.body.basic_blocks()[location.block];\n \n                 let kind = if let Some(&Statement {"}, {"sha": "e94952e1c543cd6ee92ee7b7cdfb189bbdc3aa06", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 137, "deletions": 20, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -4,14 +4,19 @@ use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItemGroup;\n use rustc_hir::GeneratorKind;\n use rustc_middle::mir::{\n     AggregateKind, Constant, Field, Local, LocalInfo, LocalKind, Location, Operand, Place,\n     PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n-use rustc_span::{symbol::sym, Span};\n+use rustc_span::{\n+    hygiene::{DesugaringKind, ForLoopLoc},\n+    symbol::sym,\n+    Span,\n+};\n use rustc_target::abi::VariantIdx;\n \n use super::borrow_set::BorrowData;\n@@ -33,6 +38,7 @@ crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n crate use region_name::{RegionName, RegionNameSource};\n+use rustc_span::symbol::Ident;\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n \n@@ -529,30 +535,52 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n }\n \n-// The span(s) associated to a use of a place.\n+/// The span(s) associated to a use of a place.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub(super) enum UseSpans {\n-    // The access is caused by capturing a variable for a closure.\n+    /// The access is caused by capturing a variable for a closure.\n     ClosureUse {\n-        // This is true if the captured variable was from a generator.\n+        /// This is true if the captured variable was from a generator.\n         generator_kind: Option<GeneratorKind>,\n-        // The span of the args of the closure, including the `move` keyword if\n-        // it's present.\n+        /// The span of the args of the closure, including the `move` keyword if\n+        /// it's present.\n         args_span: Span,\n-        // The span of the first use of the captured variable inside the closure.\n+        /// The span of the first use of the captured variable inside the closure.\n+        var_span: Span,\n+    },\n+    /// The access is caused by using a variable as the receiver of a method\n+    /// that takes 'self'\n+    FnSelfUse {\n+        /// The span of the variable being moved\n         var_span: Span,\n+        /// The span of the method call on the variable\n+        fn_call_span: Span,\n+        /// The definition span of the method being called\n+        fn_span: Span,\n+        kind: FnSelfUseKind,\n     },\n     /// This access is caused by a `match` or `if let` pattern.\n     PatUse(Span),\n     /// This access has a single span associated to it: common case.\n     OtherUse(Span),\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub(super) enum FnSelfUseKind {\n+    /// A normal method call of the form `receiver.foo(a, b, c)`\n+    Normal { self_arg: Ident, implicit_into_iter: bool },\n+    /// A call to `FnOnce::call_once`, desugared from `my_closure(a, b, c)`\n+    FnOnceCall,\n+    /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n+    Operator { self_arg: Ident },\n+}\n+\n impl UseSpans {\n     pub(super) fn args_or_use(self) -> Span {\n         match self {\n             UseSpans::ClosureUse { args_span: span, .. }\n             | UseSpans::PatUse(span)\n+            | UseSpans::FnSelfUse { var_span: span, .. }\n             | UseSpans::OtherUse(span) => span,\n         }\n     }\n@@ -561,6 +589,7 @@ impl UseSpans {\n         match self {\n             UseSpans::ClosureUse { var_span: span, .. }\n             | UseSpans::PatUse(span)\n+            | UseSpans::FnSelfUse { var_span: span, .. }\n             | UseSpans::OtherUse(span) => span,\n         }\n     }\n@@ -631,6 +660,7 @@ impl UseSpans {\n         match self {\n             closure @ UseSpans::ClosureUse { .. } => closure,\n             UseSpans::PatUse(_) | UseSpans::OtherUse(_) => if_other(),\n+            fn_self @ UseSpans::FnSelfUse { .. } => fn_self,\n         }\n     }\n }\n@@ -733,25 +763,112 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n         if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) = stmt.kind {\n-            let def_id = match kind {\n+            match kind {\n                 box AggregateKind::Closure(def_id, _)\n-                | box AggregateKind::Generator(def_id, _, _) => def_id,\n-                _ => return OtherUse(stmt.source_info.span),\n+                | box AggregateKind::Generator(def_id, _, _) => {\n+                    debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n+                    if let Some((args_span, generator_kind, var_span)) =\n+                        self.closure_span(*def_id, moved_place, places)\n+                    {\n+                        return ClosureUse { generator_kind, args_span, var_span };\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        let normal_ret =\n+            if moved_place.projection.iter().any(|p| matches!(p, ProjectionElem::Downcast(..))) {\n+                PatUse(stmt.source_info.span)\n+            } else {\n+                OtherUse(stmt.source_info.span)\n             };\n \n-            debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n-            if let Some((args_span, generator_kind, var_span)) =\n-                self.closure_span(*def_id, moved_place, places)\n-            {\n-                return ClosureUse { generator_kind, args_span, var_span };\n+        // We are trying to find MIR of the form:\n+        // ```\n+        // _temp = _moved_val;\n+        // ...\n+        // FnSelfCall(_temp, ...)\n+        // ```\n+        //\n+        // where `_moved_val` is the place we generated the move error for,\n+        // `_temp` is some other local, and `FnSelfCall` is a function\n+        // that has a `self` parameter.\n+\n+        let target_temp = match stmt.kind {\n+            StatementKind::Assign(box (temp, _)) if temp.as_local().is_some() => {\n+                temp.as_local().unwrap()\n             }\n-        }\n+            _ => return normal_ret,\n+        };\n \n-        if moved_place.projection.iter().any(|p| matches!(p, ProjectionElem::Downcast(..))) {\n-            PatUse(stmt.source_info.span)\n-        } else {\n-            OtherUse(stmt.source_info.span)\n+        debug!(\"move_spans: target_temp = {:?}\", target_temp);\n+\n+        if let Some(Terminator {\n+            kind: TerminatorKind::Call { func, args, fn_span, from_hir_call, .. },\n+            ..\n+        }) = &self.body[location.block].terminator\n+        {\n+            let mut method_did = None;\n+            if let Operand::Constant(box Constant { literal: ty::Const { ty, .. }, .. }) = func {\n+                if let ty::FnDef(def_id, _) = ty.kind {\n+                    debug!(\"move_spans: fn = {:?}\", def_id);\n+                    if let Some(ty::AssocItem { fn_has_self_parameter, .. }) =\n+                        self.infcx.tcx.opt_associated_item(def_id)\n+                    {\n+                        if *fn_has_self_parameter {\n+                            method_did = Some(def_id);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            let tcx = self.infcx.tcx;\n+            let method_did = if let Some(did) = method_did { did } else { return normal_ret };\n+\n+            if let [Operand::Move(self_place), ..] = **args {\n+                if self_place.as_local() == Some(target_temp) {\n+                    let parent = tcx.parent(method_did);\n+                    let is_fn_once = parent == tcx.lang_items().fn_once_trait();\n+                    let is_operator = !from_hir_call\n+                        && parent.map_or(false, |p| {\n+                            tcx.lang_items().group(LangItemGroup::Op).contains(&p)\n+                        });\n+                    let fn_call_span = *fn_span;\n+\n+                    let self_arg = tcx.fn_arg_names(method_did)[0];\n+\n+                    let kind = if is_fn_once {\n+                        FnSelfUseKind::FnOnceCall\n+                    } else if is_operator {\n+                        FnSelfUseKind::Operator { self_arg }\n+                    } else {\n+                        debug!(\n+                            \"move_spans: method_did={:?}, fn_call_span={:?}\",\n+                            method_did, fn_call_span\n+                        );\n+                        let implicit_into_iter = matches!(\n+                            fn_call_span.desugaring_kind(),\n+                            Some(DesugaringKind::ForLoop(ForLoopLoc::IntoIter))\n+                        );\n+                        FnSelfUseKind::Normal { self_arg, implicit_into_iter }\n+                    };\n+\n+                    return FnSelfUse {\n+                        var_span: stmt.source_info.span,\n+                        fn_call_span,\n+                        fn_span: self\n+                            .infcx\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .guess_head_span(self.infcx.tcx.def_span(method_did)),\n+                        kind,\n+                    };\n+                }\n+            }\n         }\n+        return normal_ret;\n     }\n \n     /// Finds the span of arguments of a closure (within `maybe_closure_span`)"}, {"sha": "4883b08e424423a71265093c884a7d3e069d3476", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -408,7 +408,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     format!(\"{}.as_ref()\", snippet),\n                     Applicability::MaybeIncorrect,\n                 );\n-            } else if span.is_desugaring(DesugaringKind::ForLoop)\n+            } else if matches!(span.desugaring_kind(), Some(DesugaringKind::ForLoop(_)))\n                 && self.infcx.tcx.is_diagnostic_item(Symbol::intern(\"vec_type\"), def_id)\n             {\n                 // FIXME: suggest for anything that implements `IntoIterator`."}, {"sha": "b4bc89e827daa7010b7608ab5b68ee73abb8a98b", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -365,7 +365,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     opt_assignment_rhs_span.and_then(|span| span.desugaring_kind());\n                                 match opt_desugaring_kind {\n                                     // on for loops, RHS points to the iterator part\n-                                    Some(DesugaringKind::ForLoop) => Some((\n+                                    Some(DesugaringKind::ForLoop(_)) => Some((\n                                         false,\n                                         opt_assignment_rhs_span.unwrap(),\n                                         format!("}, {"sha": "83691d439eb81c983dc1af5da94f01eb310ce4c2", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -278,6 +278,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n                 move_data: &move_data,\n                 location_table: &LocationTable::new(promoted_body),\n                 movable_generator,\n+                fn_self_span_reported: Default::default(),\n                 locals_are_invalidated_at_exit,\n                 access_place_error_reported: Default::default(),\n                 reservation_error_reported: Default::default(),\n@@ -311,6 +312,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         location_table,\n         movable_generator,\n         locals_are_invalidated_at_exit,\n+        fn_self_span_reported: Default::default(),\n         access_place_error_reported: Default::default(),\n         reservation_error_reported: Default::default(),\n         reservation_warnings: Default::default(),\n@@ -487,6 +489,10 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     // but it is currently inconvenient to track down the `BorrowIndex`\n     // at the time we detect and report a reservation error.\n     reservation_error_reported: FxHashSet<Place<'tcx>>,\n+    /// This fields keeps track of the `Span`s that we have\n+    /// used to report extra information for `FnSelfUse`, to avoid\n+    /// unnecessarily verbose errors.\n+    fn_self_span_reported: FxHashSet<Span>,\n     /// Migration warnings to be reported for #56254. We delay reporting these\n     /// so that we can suppress the warning if there's a corresponding error\n     /// for the activation of the borrow."}, {"sha": "ba538803468d97bd05a0855b2c059d3bd1d3b9f2", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -506,6 +506,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // This is basically `force_bits`.\n             let r_bits = r_bits.and_then(|r| r.to_bits_or_ptr(right_size, &self.tcx).ok());\n             if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n+                debug!(\"check_binary_op: reporting assert for {:?}\", source_info);\n                 self.report_assert_as_lint(\n                     lint::builtin::ARITHMETIC_OVERFLOW,\n                     source_info,"}, {"sha": "0be37cb096038a7ddb6a6db6cc9c3b8c72fec94c", "filename": "src/librustc_passes/lang_items.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_passes%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_passes%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flang_items.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -102,7 +102,8 @@ impl LanguageItemCollector<'tcx> {\n         // Check for duplicates.\n         if let Some(original_def_id) = self.items.items[item_index] {\n             if original_def_id != item_def_id {\n-                let name = LangItem::from_u32(item_index as u32).unwrap().name();\n+                let lang_item = LangItem::from_u32(item_index as u32).unwrap();\n+                let name = lang_item.name();\n                 let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n                     Some(span) => struct_span_err!(\n                         self.tcx.sess,\n@@ -152,6 +153,9 @@ impl LanguageItemCollector<'tcx> {\n \n         // Matched.\n         self.items.items[item_index] = Some(item_def_id);\n+        if let Some(group) = LangItem::from_u32(item_index as u32).unwrap().group() {\n+            self.items.groups[group as usize].push(item_def_id);\n+        }\n     }\n }\n "}, {"sha": "60bbdd0495cc4f9d0af6cbd745c38051ca5f9f06", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -822,7 +822,14 @@ pub enum DesugaringKind {\n     OpaqueTy,\n     Async,\n     Await,\n-    ForLoop,\n+    ForLoop(ForLoopLoc),\n+}\n+\n+/// A location in the desugaring of a `for` loop\n+#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+pub enum ForLoopLoc {\n+    Head,\n+    IntoIter,\n }\n \n impl DesugaringKind {\n@@ -835,7 +842,7 @@ impl DesugaringKind {\n             DesugaringKind::QuestionMark => \"operator `?`\",\n             DesugaringKind::TryBlock => \"`try` block\",\n             DesugaringKind::OpaqueTy => \"`impl Trait`\",\n-            DesugaringKind::ForLoop => \"`for` loop\",\n+            DesugaringKind::ForLoop(_) => \"`for` loop\",\n         }\n     }\n }"}, {"sha": "dcd2e83b747133f85db9ae6c7593024851c08fd0", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -30,8 +30,9 @@ use source_map::SourceMap;\n pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n+pub use hygiene::SyntaxContext;\n use hygiene::Transparency;\n-pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, MacroKind, SyntaxContext};\n+pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, ForLoopLoc, MacroKind};\n pub mod def_id;\n use def_id::{CrateNum, DefId, LOCAL_CRATE};\n mod span_encoding;"}, {"sha": "addc8a0efe1aa51c0cc1b9521507b2571a2a25ee", "filename": "src/test/ui/binop/binop-consume-args.stderr", "status": "modified", "additions": 60, "deletions": 10, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -4,10 +4,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn add<A: Add<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs + rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn add(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn add<A: Add<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -35,10 +40,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn sub<A: Sub<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs - rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn sub(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn sub<A: Sub<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -66,10 +76,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn mul<A: Mul<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs * rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn mul(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn mul<A: Mul<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -97,10 +112,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn div<A: Div<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs / rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn div(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn div<A: Div<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -128,10 +148,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn rem<A: Rem<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs % rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn rem(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn rem<A: Rem<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -159,10 +184,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitand<A: BitAnd<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs & rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn bitand(self, rhs: Rhs) -> Self::Output;\n+   |               ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitand<A: BitAnd<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -190,10 +220,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitor<A: BitOr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                     --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs | rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn bitor(self, rhs: Rhs) -> Self::Output;\n+   |              ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitor<A: BitOr<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -221,10 +256,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitxor<A: BitXor<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs ^ rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn bitxor(self, rhs: Rhs) -> Self::Output;\n+   |               ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitxor<A: BitXor<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -252,10 +292,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn shl<A: Shl<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs << rhs;\n-   |     --- value moved here\n+   |     ---------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn shl(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn shl<A: Shl<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -283,10 +328,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn shr<A: Shr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs >> rhs;\n-   |     --- value moved here\n+   |     ---------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn shr(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn shr<A: Shr<B, Output=()> + Copy, B>(lhs: A, rhs: B) {"}, {"sha": "97b70efe20e79d25d468c52c36e2f011b92e92cc", "filename": "src/test/ui/binop/binop-move-semantics.stderr", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -1,14 +1,21 @@\n error[E0382]: use of moved value: `x`\n   --> $DIR/binop-move-semantics.rs:8:5\n    |\n-LL | fn double_move<T: Add<Output=()>>(x: T) {\n-   |                                   - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n-LL |     x\n-   |     - value moved here\n-LL |     +\n-LL |     x;\n-   |     ^ value used here after move\n+LL |   fn double_move<T: Add<Output=()>>(x: T) {\n+   |                                     - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n+LL | /     x\n+LL | |     +\n+LL | |     x;\n+   | |     ^\n+   | |     |\n+   | |_____value used here after move\n+   |       `x` moved due to usage in operator\n+   |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n    |\n+LL |     fn add(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn double_move<T: Add<Output=()> + Copy>(x: T) {"}, {"sha": "bc1721944fbbb6de8b7b1da9112928d3782de7fe", "filename": "src/test/ui/borrowck/borrowck-unboxed-closures.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -22,10 +22,15 @@ error[E0382]: use of moved value: `f`\n LL | fn c<F:FnOnce(isize, isize) -> isize>(f: F) {\n    |                                       - move occurs because `f` has type `F`, which does not implement the `Copy` trait\n LL |     f(1, 2);\n-   |     - value moved here\n+   |     ------- `f` moved due to this call\n LL |     f(1, 2);\n    |     ^ value used here after move\n    |\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/borrowck-unboxed-closures.rs:11:5\n+   |\n+LL |     f(1, 2);\n+   |     ^\n help: consider further restricting this bound\n    |\n LL | fn c<F:FnOnce(isize, isize) -> isize + Copy>(f: F) {"}, {"sha": "896bb6dc6bee8a8cfca5c73ef4d84479b85f5bc6", "filename": "src/test/ui/closure_context/issue-42065.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `debug_dump_dict`\n   --> $DIR/issue-42065.rs:11:5\n    |\n LL |     debug_dump_dict();\n-   |     --------------- value moved here\n+   |     ----------------- `debug_dump_dict` moved due to this call\n LL |     debug_dump_dict();\n    |     ^^^^^^^^^^^^^^^ value used here after move\n    |\n@@ -11,6 +11,11 @@ note: closure cannot be invoked more than once because it moves the variable `di\n    |\n LL |         for (key, value) in dict {\n    |                             ^^^^\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/issue-42065.rs:10:5\n+   |\n+LL |     debug_dump_dict();\n+   |     ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "614e69e89f6ec539a91349c44ddefc6371fd082e", "filename": "src/test/ui/codemap_tests/tab_3.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -4,10 +4,16 @@ error[E0382]: borrow of moved value: `some_vec`\n LL |     let some_vec = vec![\"hi\"];\n    |         -------- move occurs because `some_vec` has type `std::vec::Vec<&str>`, which does not implement the `Copy` trait\n LL |     some_vec.into_iter();\n-   |     -------- value moved here\n+   |              ----------- `some_vec` moved due to this method call\n LL |     {\n LL |         println!(\"{:?}\", some_vec);\n    |                          ^^^^^^^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `some_vec`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b759aa45e3eb707d2a8074447cb22038cf2980bf", "filename": "src/test/ui/issues/issue-12127.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fissues%2Fissue-12127.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fissues%2Fissue-12127.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12127.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -2,10 +2,15 @@ error[E0382]: use of moved value: `f`\n   --> $DIR/issue-12127.rs:11:9\n    |\n LL |         f();\n-   |         - value moved here\n+   |         --- `f` moved due to this call\n LL |         f();\n    |         ^ value used here after move\n    |\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/issue-12127.rs:10:9\n+   |\n+LL |         f();\n+   |         ^\n    = note: move occurs because `f` has type `[closure@$DIR/issue-12127.rs:8:24: 8:41 x:std::boxed::Box<isize>]`, which does not implement the `Copy` trait\n \n error: aborting due to previous error"}, {"sha": "4fb805b37e03f02330f2bc77637b0a231b539b80", "filename": "src/test/ui/issues/issue-33941.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -3,4 +3,5 @@ use std::collections::HashMap;\n fn main() {\n     for _ in HashMap::new().iter().cloned() {} //~ ERROR type mismatch\n     //~^ ERROR type mismatch\n+    //~| ERROR type mismatch\n }"}, {"sha": "20335d2cdd684c6b6d681ce29790b4106a22c2fc", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -17,6 +17,16 @@ LL |     for _ in HashMap::new().iter().cloned() {}\n            found reference `&_`\n    = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::iter::Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n \n-error: aborting due to 2 previous errors\n+error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as std::iter::Iterator>::Item == &_`\n+  --> $DIR/issue-33941.rs:4:14\n+   |\n+LL |     for _ in HashMap::new().iter().cloned() {}\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found reference\n+   |\n+   = note:  expected tuple `(&_, &_)`\n+           found reference `&_`\n+   = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::iter::Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0271`."}, {"sha": "b4cc1a0aa7eb2bf5dd8fbdbc2c02d74094b714ce", "filename": "src/test/ui/issues/issue-34721.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -5,14 +5,19 @@ LL |     pub fn baz<T: Foo>(x: T) -> T {\n    |                        - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n LL |         if 0 == 1 {\n LL |             bar::bar(x.zero())\n-   |                      - value moved here\n+   |                        ------ `x` moved due to this method call\n LL |         } else {\n LL |             x.zero()\n-   |             - value moved here\n+   |               ------ `x` moved due to this method call\n LL |         };\n LL |         x.zero()\n    |         ^ value used here after move\n    |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $DIR/issue-34721.rs:4:13\n+   |\n+LL |     fn zero(self) -> Self;\n+   |             ^^^^\n help: consider further restricting this bound\n    |\n LL |     pub fn baz<T: Foo + Copy>(x: T) -> T {"}, {"sha": "ba43f2d33ee4463058c536652a9dab4aed06fa2e", "filename": "src/test/ui/issues/issue-61108.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -6,11 +6,17 @@ LL |     let mut bad_letters = vec!['e', 't', 'o', 'i'];\n LL |     for l in bad_letters {\n    |              -----------\n    |              |\n-   |              value moved here\n+   |              `bad_letters` moved due to this implicit call to `.into_iter()`\n    |              help: consider borrowing to avoid moving into the for loop: `&bad_letters`\n ...\n LL |     bad_letters.push('s');\n    |     ^^^^^^^^^^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `bad_letters`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "2c337bae130171454088824186eee57106c70202", "filename": "src/test/ui/issues/issue-64559.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -6,12 +6,18 @@ LL |     let orig = vec![true];\n LL |     for _val in orig {}\n    |                 ----\n    |                 |\n-   |                 value moved here\n+   |                 `orig` moved due to this implicit call to `.into_iter()`\n    |                 help: consider borrowing to avoid moving into the for loop: `&orig`\n LL |     let _closure = || orig;\n    |                    ^^ ---- use occurs due to use in closure\n    |                    |\n    |                    value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `orig`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "6107f53fa19606b20fcfa967a3401fb4cf2310f1", "filename": "src/test/ui/moves/move-fn-self-receiver.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.rs?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -0,0 +1,74 @@\n+use std::pin::Pin;\n+use std::rc::Rc;\n+use std::ops::Add;\n+\n+struct Foo;\n+\n+impl Add for Foo {\n+    type Output = ();\n+    fn add(self, _rhs: Self) -> () {}\n+}\n+\n+impl Foo {\n+    fn use_self(self) {}\n+    fn use_box_self(self: Box<Self>) {}\n+    fn use_pin_box_self(self: Pin<Box<Self>>) {}\n+    fn use_rc_self(self: Rc<Self>) {}\n+    fn use_mut_self(&mut self) -> &mut Self { self }\n+}\n+\n+struct Container(Vec<bool>);\n+\n+impl Container {\n+    fn custom_into_iter(self) -> impl Iterator<Item = bool> {\n+        self.0.into_iter()\n+    }\n+}\n+\n+fn move_out(val: Container) {\n+    val.0.into_iter().next();\n+    val.0; //~ ERROR use of moved\n+\n+    let foo = Foo;\n+    foo.use_self();\n+    foo; //~ ERROR use of moved\n+\n+    let second_foo = Foo;\n+    second_foo.use_self();\n+    second_foo; //~ ERROR use of moved\n+\n+    let boxed_foo = Box::new(Foo);\n+    boxed_foo.use_box_self();\n+    boxed_foo; //~ ERROR use of moved\n+\n+    let pin_box_foo = Box::pin(Foo);\n+    pin_box_foo.use_pin_box_self();\n+    pin_box_foo; //~ ERROR use of moved\n+\n+    let mut mut_foo = Foo;\n+    let ret = mut_foo.use_mut_self();\n+    mut_foo; //~ ERROR cannot move out\n+    ret;\n+\n+    let rc_foo = Rc::new(Foo);\n+    rc_foo.use_rc_self();\n+    rc_foo; //~ ERROR use of moved\n+\n+    let foo_add = Foo;\n+    foo_add + Foo;\n+    foo_add; //~ ERROR use of moved\n+\n+    let implicit_into_iter = vec![true];\n+    for _val in implicit_into_iter {}\n+    implicit_into_iter; //~ ERROR use of moved\n+\n+    let explicit_into_iter = vec![true];\n+    for _val in explicit_into_iter.into_iter() {}\n+    explicit_into_iter; //~ ERROR use of moved\n+\n+    let container = Container(vec![]);\n+    for _val in container.custom_into_iter() {}\n+    container; //~ ERROR use of moved\n+}\n+\n+fn main() {}"}, {"sha": "4333e8a23e866f408cbcbfab35992f4dd7bea440", "filename": "src/test/ui/moves/move-fn-self-receiver.stderr", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -0,0 +1,158 @@\n+error[E0382]: use of moved value: `val.0`\n+  --> $DIR/move-fn-self-receiver.rs:30:5\n+   |\n+LL |     val.0.into_iter().next();\n+   |           ----------- `val.0` moved due to this method call\n+LL |     val.0;\n+   |     ^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `val.0`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n+   = note: move occurs because `val.0` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `foo`\n+  --> $DIR/move-fn-self-receiver.rs:34:5\n+   |\n+LL |     let foo = Foo;\n+   |         --- move occurs because `foo` has type `Foo`, which does not implement the `Copy` trait\n+LL |     foo.use_self();\n+   |         ---------- `foo` moved due to this method call\n+LL |     foo;\n+   |     ^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `foo`\n+  --> $DIR/move-fn-self-receiver.rs:13:17\n+   |\n+LL |     fn use_self(self) {}\n+   |                 ^^^^\n+\n+error[E0382]: use of moved value: `second_foo`\n+  --> $DIR/move-fn-self-receiver.rs:38:5\n+   |\n+LL |     let second_foo = Foo;\n+   |         ---------- move occurs because `second_foo` has type `Foo`, which does not implement the `Copy` trait\n+LL |     second_foo.use_self();\n+   |                ---------- `second_foo` moved due to this method call\n+LL |     second_foo;\n+   |     ^^^^^^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `boxed_foo`\n+  --> $DIR/move-fn-self-receiver.rs:42:5\n+   |\n+LL |     let boxed_foo = Box::new(Foo);\n+   |         --------- move occurs because `boxed_foo` has type `std::boxed::Box<Foo>`, which does not implement the `Copy` trait\n+LL |     boxed_foo.use_box_self();\n+   |               -------------- `boxed_foo` moved due to this method call\n+LL |     boxed_foo;\n+   |     ^^^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `boxed_foo`\n+  --> $DIR/move-fn-self-receiver.rs:14:21\n+   |\n+LL |     fn use_box_self(self: Box<Self>) {}\n+   |                     ^^^^\n+\n+error[E0382]: use of moved value: `pin_box_foo`\n+  --> $DIR/move-fn-self-receiver.rs:46:5\n+   |\n+LL |     let pin_box_foo = Box::pin(Foo);\n+   |         ----------- move occurs because `pin_box_foo` has type `std::pin::Pin<std::boxed::Box<Foo>>`, which does not implement the `Copy` trait\n+LL |     pin_box_foo.use_pin_box_self();\n+   |                 ------------------ `pin_box_foo` moved due to this method call\n+LL |     pin_box_foo;\n+   |     ^^^^^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `pin_box_foo`\n+  --> $DIR/move-fn-self-receiver.rs:15:25\n+   |\n+LL |     fn use_pin_box_self(self: Pin<Box<Self>>) {}\n+   |                         ^^^^\n+\n+error[E0505]: cannot move out of `mut_foo` because it is borrowed\n+  --> $DIR/move-fn-self-receiver.rs:50:5\n+   |\n+LL |     let ret = mut_foo.use_mut_self();\n+   |               ------- borrow of `mut_foo` occurs here\n+LL |     mut_foo;\n+   |     ^^^^^^^ move out of `mut_foo` occurs here\n+LL |     ret;\n+   |     --- borrow later used here\n+\n+error[E0382]: use of moved value: `rc_foo`\n+  --> $DIR/move-fn-self-receiver.rs:55:5\n+   |\n+LL |     let rc_foo = Rc::new(Foo);\n+   |         ------ move occurs because `rc_foo` has type `std::rc::Rc<Foo>`, which does not implement the `Copy` trait\n+LL |     rc_foo.use_rc_self();\n+   |            ------------- `rc_foo` moved due to this method call\n+LL |     rc_foo;\n+   |     ^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `rc_foo`\n+  --> $DIR/move-fn-self-receiver.rs:16:20\n+   |\n+LL |     fn use_rc_self(self: Rc<Self>) {}\n+   |                    ^^^^\n+\n+error[E0382]: use of moved value: `foo_add`\n+  --> $DIR/move-fn-self-receiver.rs:59:5\n+   |\n+LL |     let foo_add = Foo;\n+   |         ------- move occurs because `foo_add` has type `Foo`, which does not implement the `Copy` trait\n+LL |     foo_add + Foo;\n+   |     ------------- `foo_add` moved due to usage in operator\n+LL |     foo_add;\n+   |     ^^^^^^^ value used here after move\n+   |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn add(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n+\n+error[E0382]: use of moved value: `implicit_into_iter`\n+  --> $DIR/move-fn-self-receiver.rs:63:5\n+   |\n+LL |     let implicit_into_iter = vec![true];\n+   |         ------------------ move occurs because `implicit_into_iter` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+LL |     for _val in implicit_into_iter {}\n+   |                 ------------------\n+   |                 |\n+   |                 `implicit_into_iter` moved due to this implicit call to `.into_iter()`\n+   |                 help: consider borrowing to avoid moving into the for loop: `&implicit_into_iter`\n+LL |     implicit_into_iter;\n+   |     ^^^^^^^^^^^^^^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `explicit_into_iter`\n+  --> $DIR/move-fn-self-receiver.rs:67:5\n+   |\n+LL |     let explicit_into_iter = vec![true];\n+   |         ------------------ move occurs because `explicit_into_iter` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+LL |     for _val in explicit_into_iter.into_iter() {}\n+   |                                    ----------- `explicit_into_iter` moved due to this method call\n+LL |     explicit_into_iter;\n+   |     ^^^^^^^^^^^^^^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `container`\n+  --> $DIR/move-fn-self-receiver.rs:71:5\n+   |\n+LL |     let container = Container(vec![]);\n+   |         --------- move occurs because `container` has type `Container`, which does not implement the `Copy` trait\n+LL |     for _val in container.custom_into_iter() {}\n+   |                           ------------------ `container` moved due to this method call\n+LL |     container;\n+   |     ^^^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `container`\n+  --> $DIR/move-fn-self-receiver.rs:23:25\n+   |\n+LL |     fn custom_into_iter(self) -> impl Iterator<Item = bool> {\n+   |                         ^^^^\n+\n+error: aborting due to 11 previous errors\n+\n+Some errors have detailed explanations: E0382, E0505.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "142feb280d153be2b8a94061d803d5e3cd5805e5", "filename": "src/test/ui/moves/moves-based-on-type-access-to-field.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -4,9 +4,15 @@ error[E0382]: borrow of moved value: `x`\n LL |     let x = vec![\"hi\".to_string()];\n    |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     consume(x.into_iter().next().unwrap());\n-   |             - value moved here\n+   |               ----------- `x` moved due to this method call\n LL |     touch(&x[0]);\n    |            ^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ff98aab50c9f82ec0bebf89288f1eeb8a2425973", "filename": "src/test/ui/moves/moves-based-on-type-exprs.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -104,19 +104,31 @@ error[E0382]: borrow of moved value: `x`\n LL |     let x = vec![\"hi\".to_string()];\n    |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     let _y = x.into_iter().next().unwrap();\n-   |              - value moved here\n+   |                ----------- `x` moved due to this method call\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:83:11\n    |\n LL |     let x = vec![\"hi\".to_string()];\n    |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     let _y = [x.into_iter().next().unwrap(); 1];\n-   |               - value moved here\n+   |                 ----------- `x` moved due to this method call\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to 11 previous errors\n "}, {"sha": "8761b5261d51bab1ebf7b6a2fd2cedcd6680df98", "filename": "src/test/ui/once-cant-call-twice-on-heap.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -4,10 +4,15 @@ error[E0382]: use of moved value: `blk`\n LL | fn foo<F:FnOnce()>(blk: F) {\n    |                    --- move occurs because `blk` has type `F`, which does not implement the `Copy` trait\n LL |     blk();\n-   |     --- value moved here\n+   |     ----- `blk` moved due to this call\n LL |     blk();\n    |     ^^^ value used here after move\n    |\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/once-cant-call-twice-on-heap.rs:8:5\n+   |\n+LL |     blk();\n+   |     ^^^\n help: consider further restricting this bound\n    |\n LL | fn foo<F:FnOnce() + Copy>(blk: F) {"}, {"sha": "ab6f06518467c9bacaa471e69fb0562f96a987b9", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fnonce-call-twice.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `tick`\n   --> $DIR/unboxed-closures-infer-fnonce-call-twice.rs:10:5\n    |\n LL |     tick();\n-   |     ---- value moved here\n+   |     ------ `tick` moved due to this call\n LL |     tick();\n    |     ^^^^ value used here after move\n    |\n@@ -11,6 +11,11 @@ note: closure cannot be invoked more than once because it moves the variable `co\n    |\n LL |     let tick = || mem::drop(counter);\n    |                             ^^^^^^^\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/unboxed-closures-infer-fnonce-call-twice.rs:9:5\n+   |\n+LL |     tick();\n+   |     ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "8d70a2b17602b1508e8018239048f850a07bf7a2", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fnonce-move-call-twice.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `tick`\n   --> $DIR/unboxed-closures-infer-fnonce-move-call-twice.rs:10:5\n    |\n LL |     tick();\n-   |     ---- value moved here\n+   |     ------ `tick` moved due to this call\n LL |     tick();\n    |     ^^^^ value used here after move\n    |\n@@ -11,6 +11,11 @@ note: closure cannot be invoked more than once because it moves the variable `co\n    |\n LL |     let tick = move || mem::drop(counter);\n    |                                  ^^^^^^^\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/unboxed-closures-infer-fnonce-move-call-twice.rs:9:5\n+   |\n+LL |     tick();\n+   |     ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "dd54c222f64bbb0a548f93473e83f2f46e3d61ef", "filename": "src/test/ui/unop-move-semantics.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funop-move-semantics.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -4,11 +4,16 @@ error[E0382]: borrow of moved value: `x`\n LL | fn move_then_borrow<T: Not<Output=T> + Clone>(x: T) {\n    |                                               - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n LL |     !x;\n-   |      - value moved here\n+   |     -- `x` moved due to usage in operator\n LL | \n LL |     x.clone();\n    |     ^ value borrowed here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn not(self) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn move_then_borrow<T: Not<Output=T> + Clone + Copy>(x: T) {"}, {"sha": "906b543e421229e20a3f67af6201b2dd4118193f", "filename": "src/test/ui/unsized-locals/borrow-after-move.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -37,10 +37,16 @@ error[E0382]: borrow of moved value: `y`\n LL |         let y = *x;\n    |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n LL |         y.foo();\n-   |         - value moved here\n+   |           ----- `y` moved due to this method call\n ...\n LL |         println!(\"{}\", &y);\n    |                        ^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `y`\n+  --> $DIR/borrow-after-move.rs:4:12\n+   |\n+LL |     fn foo(self) -> String;\n+   |            ^^^^\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/borrow-after-move.rs:39:24"}, {"sha": "49b2031c6b9d969a12b82b603d77b3629920697c", "filename": "src/test/ui/unsized-locals/double-move.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -34,9 +34,15 @@ error[E0382]: use of moved value: `y`\n LL |         let y = *x;\n    |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n LL |         y.foo();\n-   |         - value moved here\n+   |           ----- `y` moved due to this method call\n LL |         y.foo();\n    |         ^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `y`\n+  --> $DIR/double-move.rs:4:12\n+   |\n+LL |     fn foo(self) -> String;\n+   |            ^^^^\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/double-move.rs:45:9"}, {"sha": "b9440f4de07a9e9a38075d6f93a7769de37c4a6d", "filename": "src/test/ui/use/use-after-move-self-based-on-type.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -4,9 +4,15 @@ error[E0382]: use of moved value: `self`\n LL |     pub fn foo(self) -> isize {\n    |                ---- move occurs because `self` has type `S`, which does not implement the `Copy` trait\n LL |         self.bar();\n-   |         ---- value moved here\n+   |              ----- `self` moved due to this method call\n LL |         return self.x;\n    |                ^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `self`\n+  --> $DIR/use-after-move-self-based-on-type.rs:15:16\n+   |\n+LL |     pub fn bar(self) {}\n+   |                ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "3da53b024db440506d518511fb2c20f4f870da71", "filename": "src/test/ui/use/use-after-move-self.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -4,9 +4,15 @@ error[E0382]: use of moved value: `self`\n LL |     pub fn foo(self) -> isize {\n    |                ---- move occurs because `self` has type `S`, which does not implement the `Copy` trait\n LL |         self.bar();\n-   |         ---- value moved here\n+   |              ----- `self` moved due to this method call\n LL |         return *self.x;\n    |                ^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `self`\n+  --> $DIR/use-after-move-self.rs:13:16\n+   |\n+LL |     pub fn bar(self) {}\n+   |                ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ece63a2b8194745d2be6b0b7b9f66aeef1a986c3", "filename": "src/test/ui/walk-struct-literal-with.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fwalk-struct-literal-with.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa6a61c68930b390407d73e0ba71f2af5555f0f0/src%2Ftest%2Fui%2Fwalk-struct-literal-with.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwalk-struct-literal-with.stderr?ref=fa6a61c68930b390407d73e0ba71f2af5555f0f0", "patch": "@@ -4,9 +4,15 @@ error[E0382]: borrow of moved value: `start`\n LL |     let start = Mine{test:\"Foo\".to_string(), other_val:0};\n    |         ----- move occurs because `start` has type `Mine`, which does not implement the `Copy` trait\n LL |     let end = Mine{other_val:1, ..start.make_string_bar()};\n-   |                                   ----- value moved here\n+   |                                         ----------------- `start` moved due to this method call\n LL |     println!(\"{}\", start.test);\n    |                    ^^^^^^^^^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `start`\n+  --> $DIR/walk-struct-literal-with.rs:7:28\n+   |\n+LL |     fn make_string_bar(mut self) -> Mine{\n+   |                            ^^^^\n \n error: aborting due to previous error\n "}]}