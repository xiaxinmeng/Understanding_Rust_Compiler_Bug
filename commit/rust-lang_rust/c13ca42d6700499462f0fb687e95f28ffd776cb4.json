{"sha": "c13ca42d6700499462f0fb687e95f28ffd776cb4", "node_id": "C_kwDOAAsO6NoAKGMxM2NhNDJkNjcwMDQ5OTQ2MmYwZmI2ODdlOTVmMjhmZmQ3NzZjYjQ", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-09T03:34:24Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-11T03:10:21Z"}, "message": "Move `eof_items` handling entirely within `inner_parse_loop`.\n\nAlso rename `inner_parse_loop` as `parse_tt_inner`, because it's no\nlonger just a loop.", "tree": {"sha": "36dda1009088daa91e3ca12ce5fecdff127db4c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36dda1009088daa91e3ca12ce5fecdff127db4c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c13ca42d6700499462f0fb687e95f28ffd776cb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c13ca42d6700499462f0fb687e95f28ffd776cb4", "html_url": "https://github.com/rust-lang/rust/commit/c13ca42d6700499462f0fb687e95f28ffd776cb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c13ca42d6700499462f0fb687e95f28ffd776cb4/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f0798b2eb9da741ce7ee7e427aa4b9ea5a08662", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f0798b2eb9da741ce7ee7e427aa4b9ea5a08662", "html_url": "https://github.com/rust-lang/rust/commit/9f0798b2eb9da741ce7ee7e427aa4b9ea5a08662"}], "stats": {"total": 90, "additions": 40, "deletions": 50}, "files": [{"sha": "d986c5b078d4c3edb9c996f9c9b0492862c94d46", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 40, "deletions": 50, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/c13ca42d6700499462f0fb687e95f28ffd776cb4/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13ca42d6700499462f0fb687e95f28ffd776cb4/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=c13ca42d6700499462f0fb687e95f28ffd776cb4", "patch": "@@ -122,7 +122,7 @@ impl<'tt> TokenTreeOrTokenTreeSlice<'tt> {\n \n /// An unzipping of `TokenTree`s... see the `stack` field of `MatcherPos`.\n ///\n-/// This is used by `inner_parse_loop` to keep track of delimited submatchers that we have\n+/// This is used by `parse_tt_inner` to keep track of delimited submatchers that we have\n /// descended into.\n #[derive(Clone)]\n struct MatcherTtFrame<'tt> {\n@@ -480,21 +480,24 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n ///   successful execution of this function.\n /// - `next_items`: the set of newly generated items. These are used to replenish `cur_items` in\n ///   the function `parse`.\n-/// - `eof_items`: the set of items that would be valid if this was the EOF.\n /// - `bb_items`: the set of items that are waiting for the black-box parser.\n /// - `token`: the current token of the parser.\n ///\n /// # Returns\n ///\n-/// A `ParseResult`. Note that matches are kept track of through the items generated.\n-fn inner_parse_loop<'root, 'tt>(\n+/// `Some(result)` if everything is finished, `None` otherwise. Note that matches are kept track of\n+/// through the items generated.\n+fn parse_tt_inner<'root, 'tt>(\n     sess: &ParseSess,\n+    ms: &[TokenTree],\n     cur_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n     next_items: &mut Vec<MatcherPosHandle<'root, 'tt>>,\n     bb_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n-    eof_items: &mut EofItems<'root, 'tt>,\n     token: &Token,\n-) -> Result<(), (rustc_span::Span, String)> {\n+) -> Option<NamedParseResult> {\n+    // Matcher positions that would be valid if the macro invocation was over now\n+    let mut eof_items = EofItems::None;\n+\n     // Pop items from `cur_items` until it is empty.\n     while let Some(mut item) = cur_items.pop() {\n         // When unzipped trees end, remove them. This corresponds to backtracking out of a\n@@ -566,7 +569,7 @@ fn inner_parse_loop<'root, 'tt>(\n             } else {\n                 // If we are not in a repetition, then being at the end of a matcher means that we\n                 // have reached the potential end of the input.\n-                *eof_items = match eof_items {\n+                eof_items = match eof_items {\n                     EofItems::None => EofItems::One(item),\n                     EofItems::One(_) | EofItems::Multiple => EofItems::Multiple,\n                 }\n@@ -614,7 +617,7 @@ fn inner_parse_loop<'root, 'tt>(\n                 // We need to match a metavar (but the identifier is invalid)... this is an error\n                 TokenTree::MetaVarDecl(span, _, None) => {\n                     if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n-                        return Err((span, \"missing fragment specifier\".to_string()));\n+                        return Some(Error(span, \"missing fragment specifier\".to_string()));\n                     }\n                 }\n \n@@ -663,8 +666,29 @@ fn inner_parse_loop<'root, 'tt>(\n         }\n     }\n \n-    // Yay a successful parse (so far)!\n-    Ok(())\n+    // If we reached the EOF, check that there is EXACTLY ONE possible matcher. Otherwise,\n+    // either the parse is ambiguous (which should never happen) or there is a syntax error.\n+    if *token == token::Eof {\n+        Some(match eof_items {\n+            EofItems::One(mut eof_item) => {\n+                let matches =\n+                    eof_item.matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n+                nameize(sess, ms, matches)\n+            }\n+            EofItems::Multiple => {\n+                Error(token.span, \"ambiguity: multiple successful parses\".to_string())\n+            }\n+            EofItems::None => Failure(\n+                Token::new(\n+                    token::Eof,\n+                    if token.span.is_dummy() { token.span } else { token.span.shrink_to_hi() },\n+                ),\n+                \"missing tokens in macro arguments\",\n+            ),\n+        })\n+    } else {\n+        None\n+    }\n }\n \n /// Use the given sequence of token trees (`ms`) as a matcher. Match the token\n@@ -675,7 +699,7 @@ pub(super) fn parse_tt(\n     macro_name: Ident,\n ) -> NamedParseResult {\n     // A queue of possible matcher positions. We initialize it with the matcher position in which\n-    // the \"dot\" is before the first token of the first token tree in `ms`. `inner_parse_loop` then\n+    // the \"dot\" is before the first token of the first token tree in `ms`. `parse_tt_inner` then\n     // processes all of these possible matcher positions and produces possible next positions into\n     // `next_items`. After some post-processing, the contents of `next_items` replenish `cur_items`\n     // and we start over again.\n@@ -692,61 +716,27 @@ pub(super) fn parse_tt(\n         // Matcher positions black-box parsed by parser.rs (`parser`)\n         let mut bb_items = SmallVec::new();\n \n-        // Matcher positions that would be valid if the macro invocation was over now\n-        let mut eof_items = EofItems::None;\n-\n         // Process `cur_items` until either we have finished the input or we need to get some\n         // parsing from the black-box parser done. The result is that `next_items` will contain a\n         // bunch of possible next matcher positions in `next_items`.\n-        match inner_parse_loop(\n+        if let Some(result) = parse_tt_inner(\n             parser.sess,\n+            ms,\n             &mut cur_items,\n             &mut next_items,\n             &mut bb_items,\n-            &mut eof_items,\n             &parser.token,\n         ) {\n-            Ok(()) => {}\n-            Err((sp, msg)) => return Error(sp, msg),\n+            return result;\n         }\n \n-        // inner parse loop handled all cur_items, so it's empty\n+        // `parse_tt_inner` handled all cur_items, so it's empty.\n         assert!(cur_items.is_empty());\n \n-        // We need to do some post processing after the `inner_parse_loop`.\n+        // We need to do some post processing after the `parse_tt_inner`.\n         //\n         // Error messages here could be improved with links to original rules.\n \n-        // If we reached the EOF, check that there is EXACTLY ONE possible matcher. Otherwise,\n-        // either the parse is ambiguous (which should never happen) or there is a syntax error.\n-        if parser.token == token::Eof {\n-            return match eof_items {\n-                EofItems::One(mut eof_item) => {\n-                    let matches =\n-                        eof_item.matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n-                    nameize(parser.sess, ms, matches)\n-                }\n-                EofItems::Multiple => {\n-                    Error(parser.token.span, \"ambiguity: multiple successful parses\".to_string())\n-                }\n-                EofItems::None => Failure(\n-                    Token::new(\n-                        token::Eof,\n-                        if parser.token.span.is_dummy() {\n-                            parser.token.span\n-                        } else {\n-                            parser.token.span.shrink_to_hi()\n-                        },\n-                    ),\n-                    \"missing tokens in macro arguments\",\n-                ),\n-            };\n-        }\n-        // Performance hack: `eof_items` may share matchers via `Rc` with other things that we want\n-        // to modify. Dropping `eof_items` now may drop these refcounts to 1, preventing an\n-        // unnecessary implicit clone later in `Rc::make_mut`.\n-        drop(eof_items);\n-\n         match (next_items.len(), bb_items.len()) {\n             (0, 0) => {\n                 // There are no possible next positions AND we aren't waiting for the black-box"}]}