{"sha": "fab899640002eb67d9b55156f447bd435f959568", "node_id": "C_kwDOAAsO6NoAKGZhYjg5OTY0MDAwMmViNjdkOWI1NTE1NmY0NDdiZDQzNWY5NTk1Njg", "commit": {"author": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2022-08-08T04:26:13Z"}, "committer": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2022-08-08T06:22:28Z"}, "message": "compiletest: use precise cfg matching instead of hard-coded tables", "tree": {"sha": "f0bb1a549047f30b11cbfcb30590740aba4d0ed5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0bb1a549047f30b11cbfcb30590740aba4d0ed5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fab899640002eb67d9b55156f447bd435f959568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fab899640002eb67d9b55156f447bd435f959568", "html_url": "https://github.com/rust-lang/rust/commit/fab899640002eb67d9b55156f447bd435f959568", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fab899640002eb67d9b55156f447bd435f959568/comments", "author": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ee22ff7e82a0a806de72516a6a942bad2202dca", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ee22ff7e82a0a806de72516a6a942bad2202dca", "html_url": "https://github.com/rust-lang/rust/commit/9ee22ff7e82a0a806de72516a6a942bad2202dca"}], "stats": {"total": 510, "additions": 302, "deletions": 208}, "files": [{"sha": "1d2b1e68e1f371663352d704d005996f498ae782", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fab899640002eb67d9b55156f447bd435f959568/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fab899640002eb67d9b55156f447bd435f959568/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fab899640002eb67d9b55156f447bd435f959568", "patch": "@@ -816,6 +816,7 @@ dependencies = [\n  \"getopts\",\n  \"glob\",\n  \"lazy_static\",\n+ \"lazycell\",\n  \"libc\",\n  \"miow\",\n  \"regex\","}, {"sha": "41f97e4326a901b37ff80f00c6f700205ee61700", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=fab899640002eb67d9b55156f447bd435f959568", "patch": "@@ -17,6 +17,7 @@ rustfix = \"0.6.0\"\n lazy_static = \"1.0\"\n walkdir = \"2\"\n glob = \"0.3.0\"\n+lazycell = \"1.3.0\"\n \n [target.'cfg(unix)'.dependencies]\n libc = \"0.2\""}, {"sha": "470bcc6551f0419b170c2209f86e69258215da94", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=fab899640002eb67d9b55156f447bd435f959568", "patch": "@@ -3,9 +3,11 @@ pub use self::Mode::*;\n use std::ffi::OsString;\n use std::fmt;\n use std::path::{Path, PathBuf};\n+use std::process::Command;\n use std::str::FromStr;\n \n use crate::util::PathBufExt;\n+use lazycell::LazyCell;\n use test::ColorConfig;\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n@@ -371,6 +373,8 @@ pub struct Config {\n \n     /// Whether to rerun tests even if the inputs are unchanged.\n     pub force_rerun: bool,\n+\n+    pub target_cfg: LazyCell<TargetCfg>,\n }\n \n impl Config {\n@@ -380,6 +384,123 @@ impl Config {\n             !self.target.ends_with(\"-fuchsia\")\n         })\n     }\n+\n+    fn target_cfg(&self) -> &TargetCfg {\n+        self.target_cfg.borrow_with(|| TargetCfg::new(&self.rustc_path, &self.target))\n+    }\n+\n+    pub fn matches_arch(&self, arch: &str) -> bool {\n+        self.target_cfg().arch == arch ||\n+        // Shorthand for convenience. The arch for\n+        // asmjs-unknown-emscripten is actually wasm32.\n+        (arch == \"asmjs\" && self.target.starts_with(\"asmjs\")) ||\n+        // Matching all the thumb variants as one can be convenient.\n+        // (thumbv6m, thumbv7em, thumbv7m, etc.)\n+        (arch == \"thumb\" && self.target.starts_with(\"thumb\"))\n+    }\n+\n+    pub fn matches_os(&self, os: &str) -> bool {\n+        self.target_cfg().os == os\n+    }\n+\n+    pub fn matches_env(&self, env: &str) -> bool {\n+        self.target_cfg().env == env\n+    }\n+\n+    pub fn matches_abi(&self, abi: &str) -> bool {\n+        self.target_cfg().abi == abi\n+    }\n+\n+    pub fn is_big_endian(&self) -> bool {\n+        self.target_cfg().endian == Endian::Big\n+    }\n+\n+    pub fn get_pointer_width(&self) -> u32 {\n+        *&self.target_cfg().pointer_width\n+    }\n+\n+    pub fn has_asm_support(&self) -> bool {\n+        static ASM_SUPPORTED_ARCHS: &[&str] = &[\n+            \"x86\", \"x86_64\", \"arm\", \"aarch64\", \"riscv32\",\n+            \"riscv64\",\n+            // These targets require an additional asm_experimental_arch feature.\n+            // \"nvptx64\", \"hexagon\", \"mips\", \"mips64\", \"spirv\", \"wasm32\",\n+        ];\n+        ASM_SUPPORTED_ARCHS.contains(&self.target_cfg().arch.as_str())\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct TargetCfg {\n+    arch: String,\n+    os: String,\n+    env: String,\n+    abi: String,\n+    pointer_width: u32,\n+    endian: Endian,\n+}\n+\n+#[derive(Eq, PartialEq, Clone, Debug)]\n+pub enum Endian {\n+    Little,\n+    Big,\n+}\n+\n+impl TargetCfg {\n+    fn new(rustc_path: &Path, target: &str) -> TargetCfg {\n+        let output = match Command::new(rustc_path)\n+            .arg(\"--print=cfg\")\n+            .arg(\"--target\")\n+            .arg(target)\n+            .output()\n+        {\n+            Ok(output) => output,\n+            Err(e) => panic!(\"error: failed to get cfg info from {:?}: {e}\", rustc_path),\n+        };\n+        if !output.status.success() {\n+            panic!(\n+                \"error: failed to get cfg info from {:?}\\n--- stdout\\n{}\\n--- stderr\\n{}\",\n+                rustc_path,\n+                String::from_utf8(output.stdout).unwrap(),\n+                String::from_utf8(output.stderr).unwrap(),\n+            );\n+        }\n+        let print_cfg = String::from_utf8(output.stdout).unwrap();\n+        let mut arch = None;\n+        let mut os = None;\n+        let mut env = None;\n+        let mut abi = None;\n+        let mut pointer_width = None;\n+        let mut endian = None;\n+        for line in print_cfg.lines() {\n+            if let Some((name, value)) = line.split_once('=') {\n+                let value = value.trim_matches('\"');\n+                match name {\n+                    \"target_arch\" => arch = Some(value),\n+                    \"target_os\" => os = Some(value),\n+                    \"target_env\" => env = Some(value),\n+                    \"target_abi\" => abi = Some(value),\n+                    \"target_pointer_width\" => pointer_width = Some(value.parse().unwrap()),\n+                    \"target_endian\" => {\n+                        endian = Some(match value {\n+                            \"little\" => Endian::Little,\n+                            \"big\" => Endian::Big,\n+                            s => panic!(\"unexpected {s}\"),\n+                        })\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        TargetCfg {\n+            arch: arch.unwrap().to_string(),\n+            os: os.unwrap().to_string(),\n+            env: env.unwrap().to_string(),\n+            abi: abi.unwrap().to_string(),\n+            pointer_width: pointer_width.unwrap(),\n+            endian: endian.unwrap(),\n+        }\n+    }\n }\n \n #[derive(Debug, Clone)]"}, {"sha": "c50dd3cc09df5d8db026ae0e4fac73eb3e194ce2", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=fab899640002eb67d9b55156f447bd435f959568", "patch": "@@ -661,17 +661,35 @@ impl Config {\n \n         let name = line[prefix.len() + 1..].split(&[':', ' '][..]).next().unwrap();\n \n+        let matches_pointer_width = || {\n+            name.strip_suffix(\"bit\")\n+                .and_then(|width| width.parse::<u32>().ok())\n+                .map(|width| self.get_pointer_width() == width)\n+                .unwrap_or(false)\n+        };\n+\n+        // If something is ignored for emscripten, it likely also needs to be\n+        // ignored for wasm32-unknown-unknown.\n+        // `wasm32-bare` is an alias to refer to just wasm32-unknown-unknown\n+        // (in contrast to `wasm32` which also matches non-bare targets like\n+        // asmjs-unknown-emscripten).\n+        let matches_wasm32_alias = || {\n+            self.target == \"wasm32-unknown-unknown\" && matches!(name, \"emscripten\" | \"wasm32-bare\")\n+        };\n+\n         let is_match = name == \"test\" ||\n             self.target == name ||                              // triple\n-            util::matches_os(&self.target, name) ||             // target\n-            util::matches_env(&self.target, name) ||            // env\n+            self.matches_os(name) ||\n+            self.matches_env(name) ||\n+            self.matches_abi(name) ||\n             self.target.ends_with(name) ||                      // target and env\n-            name == util::get_arch(&self.target) ||             // architecture\n-            name == util::get_pointer_width(&self.target) ||    // pointer width\n+            self.matches_arch(name) ||\n+            matches_wasm32_alias() ||\n+            matches_pointer_width() ||\n             name == self.stage_id.split('-').next().unwrap() || // stage\n             name == self.channel ||                             // channel\n             (self.target != self.host && name == \"cross-compile\") ||\n-            (name == \"endian-big\" && util::is_big_endian(&self.target)) ||\n+            (name == \"endian-big\" && self.is_big_endian()) ||\n             (self.remote_test_client.is_some() && name == \"remote\") ||\n             match self.compare_mode {\n                 Some(CompareMode::Polonius) => name == \"compare-mode-polonius\",\n@@ -869,7 +887,7 @@ pub fn make_test_description<R: Read>(\n \n     let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();\n     let rustc_has_sanitizer_support = env::var_os(\"RUSTC_SANITIZER_SUPPORT\").is_some();\n-    let has_asm_support = util::has_asm_support(&config.target);\n+    let has_asm_support = config.has_asm_support();\n     let has_asan = util::ASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n     let has_cfi = util::CFI_SUPPORTED_TARGETS.contains(&&*config.target);\n     let has_lsan = util::LSAN_SUPPORTED_TARGETS.contains(&&*config.target);"}, {"sha": "21523cc13e6fcd0b247e2a7c8a1fcc69df7af8df", "filename": "src/tools/compiletest/src/header/tests.rs", "status": "modified", "additions": 149, "deletions": 9, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs?ref=fab899640002eb67d9b55156f447bd435f959568", "patch": "@@ -42,7 +42,6 @@ fn config() -> Config {\n         \"--suite=ui\",\n         \"--compile-lib-path=\",\n         \"--run-lib-path=\",\n-        \"--rustc-path=\",\n         \"--python=\",\n         \"--jsondocck-path=\",\n         \"--src-base=\",\n@@ -57,7 +56,9 @@ fn config() -> Config {\n         \"--target=x86_64-unknown-linux-gnu\",\n         \"--channel=nightly\",\n     ];\n-    let args = args.iter().map(ToString::to_string).collect();\n+    let mut args: Vec<String> = args.iter().map(ToString::to_string).collect();\n+    args.push(\"--rustc-path\".to_string());\n+    args.push(std::env::var(\"RUSTC\").unwrap_or_else(|_| \"rustc\".to_string()));\n     crate::parse_config(args)\n }\n \n@@ -237,13 +238,20 @@ fn sanitizers() {\n \n #[test]\n fn asm_support() {\n-    let mut config = config();\n-\n-    config.target = \"avr-unknown-gnu-atmega328\".to_owned();\n-    assert!(check_ignore(&config, \"// needs-asm-support\"));\n-\n-    config.target = \"i686-unknown-netbsd\".to_owned();\n-    assert!(!check_ignore(&config, \"// needs-asm-support\"));\n+    let asms = [\n+        (\"avr-unknown-gnu-atmega328\", false),\n+        (\"i686-unknown-netbsd\", true),\n+        (\"riscv32gc-unknown-linux-gnu\", true),\n+        (\"riscv64imac-unknown-none-elf\", true),\n+        (\"x86_64-unknown-linux-gnu\", true),\n+        (\"i686-unknown-netbsd\", true),\n+    ];\n+    for (target, has_asm) in asms {\n+        let mut config = config();\n+        config.target = target.to_string();\n+        assert_eq!(config.has_asm_support(), has_asm);\n+        assert_eq!(check_ignore(&config, \"// needs-asm-support\"), !has_asm)\n+    }\n }\n \n #[test]\n@@ -281,3 +289,135 @@ fn test_duplicate_revisions() {\n     let config = config();\n     parse_rs(&config, \"// revisions: rpass1 rpass1\");\n }\n+\n+#[test]\n+fn ignore_arch() {\n+    let archs = [\n+        (\"x86_64-unknown-linux-gnu\", \"x86_64\"),\n+        (\"i686-unknown-linux-gnu\", \"x86\"),\n+        (\"nvptx64-nvidia-cuda\", \"nvptx64\"),\n+        (\"asmjs-unknown-emscripten\", \"wasm32\"),\n+        (\"asmjs-unknown-emscripten\", \"asmjs\"),\n+        (\"thumbv7m-none-eabi\", \"thumb\"),\n+    ];\n+    for (target, arch) in archs {\n+        let mut config = config();\n+        config.target = target.to_string();\n+        assert!(config.matches_arch(arch), \"{target} {arch}\");\n+        assert!(check_ignore(&config, &format!(\"// ignore-{arch}\")));\n+    }\n+}\n+\n+#[test]\n+fn matches_os() {\n+    let oss = [\n+        (\"x86_64-unknown-linux-gnu\", \"linux\"),\n+        (\"x86_64-fortanix-unknown-sgx\", \"unknown\"),\n+        (\"wasm32-unknown-unknown\", \"unknown\"),\n+        (\"x86_64-unknown-none\", \"none\"),\n+    ];\n+    for (target, os) in oss {\n+        let mut config = config();\n+        config.target = target.to_string();\n+        assert!(config.matches_os(os), \"{target} {os}\");\n+        assert!(check_ignore(&config, &format!(\"// ignore-{os}\")));\n+    }\n+}\n+\n+#[test]\n+fn matches_env() {\n+    let envs = [\n+        (\"x86_64-unknown-linux-gnu\", \"gnu\"),\n+        (\"x86_64-fortanix-unknown-sgx\", \"sgx\"),\n+        (\"arm-unknown-linux-musleabi\", \"musl\"),\n+    ];\n+    for (target, env) in envs {\n+        let mut config = config();\n+        config.target = target.to_string();\n+        assert!(config.matches_env(env), \"{target} {env}\");\n+        assert!(check_ignore(&config, &format!(\"// ignore-{env}\")));\n+    }\n+}\n+\n+#[test]\n+fn matches_abi() {\n+    let abis = [\n+        (\"aarch64-apple-ios-macabi\", \"macabi\"),\n+        (\"x86_64-unknown-linux-gnux32\", \"x32\"),\n+        (\"arm-unknown-linux-gnueabi\", \"eabi\"),\n+    ];\n+    for (target, abi) in abis {\n+        let mut config = config();\n+        config.target = target.to_string();\n+        assert!(config.matches_abi(abi), \"{target} {abi}\");\n+        assert!(check_ignore(&config, &format!(\"// ignore-{abi}\")));\n+    }\n+}\n+\n+#[test]\n+fn is_big_endian() {\n+    let endians = [\n+        (\"x86_64-unknown-linux-gnu\", false),\n+        (\"bpfeb-unknown-none\", true),\n+        (\"m68k-unknown-linux-gnu\", true),\n+        (\"aarch64_be-unknown-linux-gnu\", true),\n+        (\"powerpc64-unknown-linux-gnu\", true),\n+    ];\n+    for (target, is_big) in endians {\n+        let mut config = config();\n+        config.target = target.to_string();\n+        assert_eq!(config.is_big_endian(), is_big, \"{target} {is_big}\");\n+        assert_eq!(check_ignore(&config, \"// ignore-endian-big\"), is_big);\n+    }\n+}\n+\n+#[test]\n+fn pointer_width() {\n+    let widths = [\n+        (\"x86_64-unknown-linux-gnu\", 64),\n+        (\"i686-unknown-linux-gnu\", 32),\n+        (\"arm64_32-apple-watchos\", 32),\n+        (\"msp430-none-elf\", 16),\n+    ];\n+    for (target, width) in widths {\n+        let mut config = config();\n+        config.target = target.to_string();\n+        assert_eq!(config.get_pointer_width(), width, \"{target} {width}\");\n+        assert_eq!(check_ignore(&config, \"// ignore-16bit\"), width == 16);\n+        assert_eq!(check_ignore(&config, \"// ignore-32bit\"), width == 32);\n+        assert_eq!(check_ignore(&config, \"// ignore-64bit\"), width == 64);\n+    }\n+}\n+\n+#[test]\n+fn wasm_special() {\n+    let ignores = [\n+        (\"wasm32-unknown-unknown\", \"emscripten\", true),\n+        (\"wasm32-unknown-unknown\", \"wasm32\", true),\n+        (\"wasm32-unknown-unknown\", \"wasm32-bare\", true),\n+        (\"wasm32-unknown-unknown\", \"wasm64\", false),\n+        (\"asmjs-unknown-emscripten\", \"emscripten\", true),\n+        (\"asmjs-unknown-emscripten\", \"wasm32\", true),\n+        (\"asmjs-unknown-emscripten\", \"wasm32-bare\", false),\n+        (\"wasm32-unknown-emscripten\", \"emscripten\", true),\n+        (\"wasm32-unknown-emscripten\", \"wasm32\", true),\n+        (\"wasm32-unknown-emscripten\", \"wasm32-bare\", false),\n+        (\"wasm32-wasi\", \"emscripten\", false),\n+        (\"wasm32-wasi\", \"wasm32\", true),\n+        (\"wasm32-wasi\", \"wasm32-bare\", false),\n+        (\"wasm32-wasi\", \"wasi\", true),\n+        (\"wasm64-unknown-unknown\", \"emscripten\", false),\n+        (\"wasm64-unknown-unknown\", \"wasm32\", false),\n+        (\"wasm64-unknown-unknown\", \"wasm32-bare\", false),\n+        (\"wasm64-unknown-unknown\", \"wasm64\", true),\n+    ];\n+    for (target, pattern, ignore) in ignores {\n+        let mut config = config();\n+        config.target = target.to_string();\n+        assert_eq!(\n+            check_ignore(&config, &format!(\"// ignore-{pattern}\")),\n+            ignore,\n+            \"{target} {pattern}\"\n+        );\n+    }\n+}"}, {"sha": "ac6d80bb439b3b99e5931639ca9f9e110eaca689", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=fab899640002eb67d9b55156f447bd435f959568", "patch": "@@ -11,6 +11,7 @@ use crate::common::{\n use crate::common::{CompareMode, Config, Debugger, Mode, PassMode, TestPaths};\n use crate::util::logv;\n use getopts::Options;\n+use lazycell::LazyCell;\n use std::env;\n use std::ffi::OsString;\n use std::fs;\n@@ -299,6 +300,8 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         npm: matches.opt_str(\"npm\"),\n \n         force_rerun: matches.opt_present(\"force-rerun\"),\n+\n+        target_cfg: LazyCell::new(),\n     }\n }\n \n@@ -441,7 +444,7 @@ fn configure_cdb(config: &Config) -> Option<Config> {\n fn configure_gdb(config: &Config) -> Option<Config> {\n     config.gdb_version?;\n \n-    if util::matches_env(&config.target, \"msvc\") {\n+    if config.matches_env(\"msvc\") {\n         return None;\n     }\n "}, {"sha": "47f2a2d34821c737a6a2daab7baecc9241e09e96", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=fab899640002eb67d9b55156f447bd435f959568", "patch": "@@ -13,7 +13,6 @@ use crate::errors::{self, Error, ErrorKind};\n use crate::header::TestProps;\n use crate::json;\n use crate::read2::read2_abbreviated;\n-use crate::util::get_pointer_width;\n use crate::util::{logv, PathBufExt};\n use crate::ColorConfig;\n use regex::{Captures, Regex};\n@@ -3127,7 +3126,7 @@ impl<'test> TestCx<'test> {\n         output_kind: TestOutput,\n         explicit_format: bool,\n     ) -> usize {\n-        let stderr_bits = format!(\"{}.stderr\", get_pointer_width(&self.config.target));\n+        let stderr_bits = format!(\"{}bit.stderr\", self.config.get_pointer_width());\n         let (stderr_kind, stdout_kind) = match output_kind {\n             TestOutput::Compile => (\n                 {\n@@ -3402,7 +3401,7 @@ impl<'test> TestCx<'test> {\n \n         let mut bit_width = String::new();\n         if test_file_contents.lines().any(|l| l == \"// EMIT_MIR_FOR_EACH_BIT_WIDTH\") {\n-            bit_width = format!(\".{}\", get_pointer_width(&self.config.target));\n+            bit_width = format!(\".{}bit\", self.config.get_pointer_width());\n         }\n \n         if self.config.bless {"}, {"sha": "9d047b63c859397d8ffb7d9b4ed317b1c697045f", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=fab899640002eb67d9b55156f447bd435f959568", "patch": "@@ -8,84 +8,6 @@ use tracing::*;\n #[cfg(test)]\n mod tests;\n \n-/// Conversion table from triple OS name to Rust SYSNAME\n-const OS_TABLE: &[(&str, &str)] = &[\n-    (\"android\", \"android\"),\n-    (\"androideabi\", \"android\"),\n-    (\"cuda\", \"cuda\"),\n-    (\"darwin\", \"macos\"),\n-    (\"dragonfly\", \"dragonfly\"),\n-    (\"emscripten\", \"emscripten\"),\n-    (\"freebsd\", \"freebsd\"),\n-    (\"fuchsia\", \"fuchsia\"),\n-    (\"haiku\", \"haiku\"),\n-    (\"hermit\", \"hermit\"),\n-    (\"illumos\", \"illumos\"),\n-    (\"ios\", \"ios\"),\n-    (\"l4re\", \"l4re\"),\n-    (\"linux\", \"linux\"),\n-    (\"mingw32\", \"windows\"),\n-    (\"none\", \"none\"),\n-    (\"netbsd\", \"netbsd\"),\n-    (\"openbsd\", \"openbsd\"),\n-    (\"redox\", \"redox\"),\n-    (\"sgx\", \"sgx\"),\n-    (\"solaris\", \"solaris\"),\n-    (\"watchos\", \"watchos\"),\n-    (\"win32\", \"windows\"),\n-    (\"windows\", \"windows\"),\n-    (\"vxworks\", \"vxworks\"),\n-];\n-\n-const ARCH_TABLE: &[(&str, &str)] = &[\n-    (\"aarch64\", \"aarch64\"),\n-    (\"aarch64_be\", \"aarch64\"),\n-    (\"amd64\", \"x86_64\"),\n-    (\"arm\", \"arm\"),\n-    (\"arm64\", \"aarch64\"),\n-    (\"armv4t\", \"arm\"),\n-    (\"armv5te\", \"arm\"),\n-    (\"armv7\", \"arm\"),\n-    (\"armv7s\", \"arm\"),\n-    (\"asmjs\", \"asmjs\"),\n-    (\"avr\", \"avr\"),\n-    (\"bpfeb\", \"bpf\"),\n-    (\"bpfel\", \"bpf\"),\n-    (\"hexagon\", \"hexagon\"),\n-    (\"i386\", \"x86\"),\n-    (\"i586\", \"x86\"),\n-    (\"i686\", \"x86\"),\n-    (\"m68k\", \"m68k\"),\n-    (\"mips\", \"mips\"),\n-    (\"mips64\", \"mips64\"),\n-    (\"mips64el\", \"mips64\"),\n-    (\"mipsisa32r6\", \"mips\"),\n-    (\"mipsisa32r6el\", \"mips\"),\n-    (\"mipsisa64r6\", \"mips64\"),\n-    (\"mipsisa64r6el\", \"mips64\"),\n-    (\"mipsel\", \"mips\"),\n-    (\"mipsisa32r6\", \"mips\"),\n-    (\"mipsisa32r6el\", \"mips\"),\n-    (\"mipsisa64r6\", \"mips64\"),\n-    (\"mipsisa64r6el\", \"mips64\"),\n-    (\"msp430\", \"msp430\"),\n-    (\"nvptx64\", \"nvptx64\"),\n-    (\"powerpc\", \"powerpc\"),\n-    (\"powerpc64\", \"powerpc64\"),\n-    (\"powerpc64le\", \"powerpc64\"),\n-    (\"riscv64gc\", \"riscv64\"),\n-    (\"s390x\", \"s390x\"),\n-    (\"sparc\", \"sparc\"),\n-    (\"sparc64\", \"sparc64\"),\n-    (\"sparcv9\", \"sparc64\"),\n-    (\"thumbv6m\", \"thumb\"),\n-    (\"thumbv7em\", \"thumb\"),\n-    (\"thumbv7m\", \"thumb\"),\n-    (\"wasm32\", \"wasm32\"),\n-    (\"x86_64\", \"x86_64\"),\n-    (\"xcore\", \"xcore\"),\n-];\n-\n pub const ASAN_SUPPORTED_TARGETS: &[&str] = &[\n     \"aarch64-apple-darwin\",\n     \"aarch64-fuchsia\",\n@@ -140,80 +62,6 @@ pub const MEMTAG_SUPPORTED_TARGETS: &[&str] =\n \n pub const SHADOWCALLSTACK_SUPPORTED_TARGETS: &[&str] = &[\"aarch64-linux-android\"];\n \n-const BIG_ENDIAN: &[&str] = &[\n-    \"aarch64_be\",\n-    \"armebv7r\",\n-    \"mips\",\n-    \"mips64\",\n-    \"mipsisa32r6\",\n-    \"mipsisa64r6\",\n-    \"powerpc\",\n-    \"powerpc64\",\n-    \"s390x\",\n-    \"sparc\",\n-    \"sparc64\",\n-    \"sparcv9\",\n-];\n-\n-static ASM_SUPPORTED_ARCHS: &[&str] = &[\n-    \"x86\", \"x86_64\", \"arm\", \"aarch64\", \"riscv32\",\n-    \"riscv64\",\n-    // These targets require an additional asm_experimental_arch feature.\n-    // \"nvptx64\", \"hexagon\", \"mips\", \"mips64\", \"spirv\", \"wasm32\",\n-];\n-\n-pub fn has_asm_support(triple: &str) -> bool {\n-    ASM_SUPPORTED_ARCHS.contains(&get_arch(triple))\n-}\n-\n-pub fn matches_os(triple: &str, name: &str) -> bool {\n-    // For the wasm32 bare target we ignore anything also ignored on emscripten\n-    // and then we also recognize `wasm32-bare` as the os for the target\n-    if triple == \"wasm32-unknown-unknown\" {\n-        return name == \"emscripten\" || name == \"wasm32-bare\";\n-    }\n-    let triple: Vec<_> = triple.split('-').collect();\n-    for &(triple_os, os) in OS_TABLE {\n-        if triple.contains(&triple_os) {\n-            return os == name;\n-        }\n-    }\n-    panic!(\"Cannot determine OS from triple\");\n-}\n-\n-/// Determine the architecture from `triple`\n-pub fn get_arch(triple: &str) -> &'static str {\n-    let triple: Vec<_> = triple.split('-').collect();\n-    for &(triple_arch, arch) in ARCH_TABLE {\n-        if triple.contains(&triple_arch) {\n-            return arch;\n-        }\n-    }\n-    panic!(\"Cannot determine Architecture from triple\");\n-}\n-\n-/// Determine the endianness from `triple`\n-pub fn is_big_endian(triple: &str) -> bool {\n-    let triple_arch = triple.split('-').next().unwrap();\n-    BIG_ENDIAN.contains(&triple_arch)\n-}\n-\n-pub fn matches_env(triple: &str, name: &str) -> bool {\n-    if let Some(env) = triple.split('-').nth(3) { env.starts_with(name) } else { false }\n-}\n-\n-pub fn get_pointer_width(triple: &str) -> &'static str {\n-    if (triple.contains(\"64\") && !triple.ends_with(\"gnux32\") && !triple.ends_with(\"gnu_ilp32\"))\n-        || triple.starts_with(\"s390x\")\n-    {\n-        \"64bit\"\n-    } else if triple.starts_with(\"avr\") {\n-        \"16bit\"\n-    } else {\n-        \"32bit\"\n-    }\n-}\n-\n pub fn make_new_path(path: &str) -> String {\n     assert!(cfg!(windows));\n     // Windows just uses PATH as the library search path, so we have to"}, {"sha": "b09a183b14e6a263ca93ca6ae389279c0ef5602e", "filename": "src/tools/compiletest/src/util/tests.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Futil%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab899640002eb67d9b55156f447bd435f959568/src%2Ftools%2Fcompiletest%2Fsrc%2Futil%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil%2Ftests.rs?ref=fab899640002eb67d9b55156f447bd435f959568", "patch": "@@ -1,42 +1,5 @@\n use super::*;\n \n-#[test]\n-#[should_panic(expected = \"Cannot determine Architecture from triple\")]\n-fn test_get_arch_failure() {\n-    get_arch(\"abc\");\n-}\n-\n-#[test]\n-fn test_get_arch() {\n-    assert_eq!(\"x86_64\", get_arch(\"x86_64-unknown-linux-gnu\"));\n-    assert_eq!(\"x86_64\", get_arch(\"amd64\"));\n-    assert_eq!(\"nvptx64\", get_arch(\"nvptx64-nvidia-cuda\"));\n-}\n-\n-#[test]\n-#[should_panic(expected = \"Cannot determine OS from triple\")]\n-fn test_matches_os_failure() {\n-    matches_os(\"abc\", \"abc\");\n-}\n-\n-#[test]\n-fn test_matches_os() {\n-    assert!(matches_os(\"x86_64-unknown-linux-gnu\", \"linux\"));\n-    assert!(matches_os(\"wasm32-unknown-unknown\", \"emscripten\"));\n-    assert!(matches_os(\"wasm32-unknown-unknown\", \"wasm32-bare\"));\n-    assert!(!matches_os(\"wasm32-unknown-unknown\", \"windows\"));\n-    assert!(matches_os(\"thumbv6m0-none-eabi\", \"none\"));\n-    assert!(matches_os(\"riscv32imc-unknown-none-elf\", \"none\"));\n-    assert!(matches_os(\"nvptx64-nvidia-cuda\", \"cuda\"));\n-    assert!(matches_os(\"x86_64-fortanix-unknown-sgx\", \"sgx\"));\n-}\n-\n-#[test]\n-fn is_big_endian_test() {\n-    assert!(!is_big_endian(\"no\"));\n-    assert!(is_big_endian(\"sparc-unknown-unknown\"));\n-}\n-\n #[test]\n fn path_buf_with_extra_extension_test() {\n     assert_eq!("}]}