{"sha": "5d3559e6455757c5508bba5b5add69477ebac53e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMzU1OWU2NDU1NzU3YzU1MDhiYmE1YjVhZGQ2OTQ3N2ViYWM1M2U=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-10T22:15:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-12T23:35:18Z"}, "message": "librustc: Make `self` and `static` into keywords", "tree": {"sha": "71e166364df7f828c4c98c5853597d2c62c37fac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71e166364df7f828c4c98c5853597d2c62c37fac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d3559e6455757c5508bba5b5add69477ebac53e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d3559e6455757c5508bba5b5add69477ebac53e", "html_url": "https://github.com/rust-lang/rust/commit/5d3559e6455757c5508bba5b5add69477ebac53e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d3559e6455757c5508bba5b5add69477ebac53e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06ef889cdc77db862d526bf6a607ecdf3ee80beb", "url": "https://api.github.com/repos/rust-lang/rust/commits/06ef889cdc77db862d526bf6a607ecdf3ee80beb", "html_url": "https://github.com/rust-lang/rust/commit/06ef889cdc77db862d526bf6a607ecdf3ee80beb"}], "stats": {"total": 1310, "additions": 700, "deletions": 610}, "files": [{"sha": "6f0e03fb895012d3be7786bc355048653e0bfe5a", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -44,21 +44,21 @@ pub fn empty_cell<T>() -> Cell<T> {\n pub impl<T> Cell<T> {\n     /// Yields the value, failing if the cell is empty.\n     fn take(&self) -> T {\n-        let self = unsafe { transmute_mut(self) };\n-        if self.is_empty() {\n+        let this = unsafe { transmute_mut(self) };\n+        if this.is_empty() {\n             fail!(~\"attempt to take an empty cell\");\n         }\n \n-        replace(&mut self.value, None).unwrap()\n+        replace(&mut this.value, None).unwrap()\n     }\n \n     /// Returns the value, failing if the cell is full.\n     fn put_back(&self, value: T) {\n-        let self = unsafe { transmute_mut(self) };\n-        if !self.is_empty() {\n+        let this = unsafe { transmute_mut(self) };\n+        if !this.is_empty() {\n             fail!(~\"attempt to put a value back into a full cell\");\n         }\n-        self.value = Some(value);\n+        this.value = Some(value);\n     }\n \n     /// Returns true if the cell is empty and false if the cell is full."}, {"sha": "95bc8872c91c7971536bb7250cf6057d3037a187", "filename": "src/libcore/old_iter.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibcore%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibcore%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fold_iter.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -116,10 +116,12 @@ pub trait Buildable<A> {\n }\n \n #[inline(always)]\n-pub fn _eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n+pub fn _eachi<A,IA:BaseIter<A>>(this: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n     let mut i = 0;\n-    for self.each |a| {\n-        if !blk(i, a) { return false; }\n+    for this.each |a| {\n+        if !blk(i, a) {\n+            return false;\n+        }\n         i += 1;\n     }\n     return true;\n@@ -135,47 +137,47 @@ pub fn eachi<A,IA:BaseIter<A>>(self: &IA, blk: &fn(uint, &A) -> bool) -> bool {\n }\n \n #[inline(always)]\n-pub fn all<A,IA:BaseIter<A>>(self: &IA, blk: &fn(&A) -> bool) -> bool {\n-    for self.each |a| {\n+pub fn all<A,IA:BaseIter<A>>(this: &IA, blk: &fn(&A) -> bool) -> bool {\n+    for this.each |a| {\n         if !blk(a) { return false; }\n     }\n     return true;\n }\n \n #[inline(always)]\n-pub fn any<A,IA:BaseIter<A>>(self: &IA, blk: &fn(&A) -> bool) -> bool {\n-    for self.each |a| {\n+pub fn any<A,IA:BaseIter<A>>(this: &IA, blk: &fn(&A) -> bool) -> bool {\n+    for this.each |a| {\n         if blk(a) { return true; }\n     }\n     return false;\n }\n \n #[inline(always)]\n-pub fn filter_to_vec<A:Copy,IA:BaseIter<A>>(self: &IA,\n+pub fn filter_to_vec<A:Copy,IA:BaseIter<A>>(this: &IA,\n                                             prd: &fn(&A) -> bool)\n                                          -> ~[A] {\n-    do vec::build_sized_opt(self.size_hint()) |push| {\n-        for self.each |a| {\n+    do vec::build_sized_opt(this.size_hint()) |push| {\n+        for this.each |a| {\n             if prd(a) { push(*a); }\n         }\n     }\n }\n \n #[inline(always)]\n-pub fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA, op: &fn(&A) -> B) -> ~[B] {\n-    do vec::build_sized_opt(self.size_hint()) |push| {\n-        for self.each |a| {\n+pub fn map_to_vec<A,B,IA:BaseIter<A>>(this: &IA, op: &fn(&A) -> B) -> ~[B] {\n+    do vec::build_sized_opt(this.size_hint()) |push| {\n+        for this.each |a| {\n             push(op(a));\n         }\n     }\n }\n \n #[inline(always)]\n-pub fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(self: &IA,\n+pub fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(this: &IA,\n                                                           op: &fn(&A) -> IB)\n                                                        -> ~[B] {\n     do vec::build |push| {\n-        for self.each |a| {\n+        for this.each |a| {\n             for op(a).each |&b| {\n                 push(b);\n             }\n@@ -184,31 +186,31 @@ pub fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(self: &IA,\n }\n \n #[inline(always)]\n-pub fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B, blk: &fn(&B, &A) -> B)\n+pub fn foldl<A,B,IA:BaseIter<A>>(this: &IA, b0: B, blk: &fn(&B, &A) -> B)\n                               -> B {\n     let mut b = b0;\n-    for self.each |a| {\n+    for this.each |a| {\n         b = blk(&b, a);\n     }\n     b\n }\n \n #[inline(always)]\n-pub fn to_vec<A:Copy,IA:BaseIter<A>>(self: &IA) -> ~[A] {\n-    map_to_vec(self, |&x| x)\n+pub fn to_vec<A:Copy,IA:BaseIter<A>>(this: &IA) -> ~[A] {\n+    map_to_vec(this, |&x| x)\n }\n \n #[inline(always)]\n-pub fn contains<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> bool {\n-    for self.each |a| {\n+pub fn contains<A:Eq,IA:BaseIter<A>>(this: &IA, x: &A) -> bool {\n+    for this.each |a| {\n         if *a == *x { return true; }\n     }\n     return false;\n }\n \n #[inline(always)]\n-pub fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n-    do foldl(self, 0) |count, value| {\n+pub fn count<A:Eq,IA:BaseIter<A>>(this: &IA, x: &A) -> uint {\n+    do foldl(this, 0) |count, value| {\n         if *value == *x {\n             *count + 1\n         } else {\n@@ -218,10 +220,10 @@ pub fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n }\n \n #[inline(always)]\n-pub fn position<A,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n+pub fn position<A,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n                                -> Option<uint> {\n     let mut i = 0;\n-    for self.each |a| {\n+    for this.each |a| {\n         if f(a) { return Some(i); }\n         i += 1;\n     }\n@@ -253,8 +255,8 @@ pub fn repeat(times: uint, blk: &fn() -> bool) -> bool {\n }\n \n #[inline(always)]\n-pub fn min<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n-    match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n+pub fn min<A:Copy + Ord,IA:BaseIter<A>>(this: &IA) -> A {\n+    match do foldl::<A,Option<A>,IA>(this, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ < *b => {\n              *(a)\n@@ -268,8 +270,8 @@ pub fn min<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n }\n \n #[inline(always)]\n-pub fn max<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n-    match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n+pub fn max<A:Copy + Ord,IA:BaseIter<A>>(this: &IA) -> A {\n+    match do foldl::<A,Option<A>,IA>(this, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ > *b => {\n               *(a)\n@@ -283,9 +285,9 @@ pub fn max<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n }\n \n #[inline(always)]\n-pub fn find<A:Copy,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n+pub fn find<A:Copy,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n                                 -> Option<A> {\n-    for self.each |i| {\n+    for this.each |i| {\n         if f(i) { return Some(*i) }\n     }\n     return None;"}, {"sha": "ba057254583b0280e0fc25a2127da2edb6a08f3d", "filename": "src/libcore/rt/sched/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -118,15 +118,15 @@ pub impl Scheduler {\n     fn resume_task_from_queue(~self) -> bool {\n         assert!(!self.in_task_context());\n \n-        let mut self = self;\n-        match self.task_queue.pop_front() {\n+        let mut this = self;\n+        match this.task_queue.pop_front() {\n             Some(task) => {\n-                self.resume_task_immediately(task);\n+                this.resume_task_immediately(task);\n                 return true;\n             }\n             None => {\n                 rtdebug!(\"no tasks in queue\");\n-                local_sched::put(self);\n+                local_sched::put(this);\n                 return false;\n             }\n         }\n@@ -165,16 +165,16 @@ pub impl Scheduler {\n     // Core scheduling ops\n \n     fn resume_task_immediately(~self, task: ~Task) {\n-        let mut self = self;\n-        assert!(!self.in_task_context());\n+        let mut this = self;\n+        assert!(!this.in_task_context());\n \n         rtdebug!(\"scheduling a task\");\n \n         // Store the task in the scheduler so it can be grabbed later\n-        self.current_task = Some(task);\n-        self.enqueue_cleanup_job(DoNothing);\n+        this.current_task = Some(task);\n+        this.enqueue_cleanup_job(DoNothing);\n \n-        local_sched::put(self);\n+        local_sched::put(this);\n \n         // Take pointers to both the task and scheduler's saved registers.\n         unsafe {\n@@ -203,17 +203,17 @@ pub impl Scheduler {\n     /// running task.  It gets transmuted to the scheduler's lifetime\n     /// and called while the task is blocked.\n     fn deschedule_running_task_and_then(~self, f: &fn(~Task)) {\n-        let mut self = self;\n-        assert!(self.in_task_context());\n+        let mut this = self;\n+        assert!(this.in_task_context());\n \n         rtdebug!(\"blocking task\");\n \n-        let blocked_task = self.current_task.swap_unwrap();\n+        let blocked_task = this.current_task.swap_unwrap();\n         let f_fake_region = unsafe { transmute::<&fn(~Task), &fn(~Task)>(f) };\n         let f_opaque = ClosureConverter::from_fn(f_fake_region);\n-        self.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n+        this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n \n-        local_sched::put(self);\n+        local_sched::put(this);\n \n         let sched = unsafe { local_sched::unsafe_borrow() };\n         let (sched_context, last_task_context, _) = sched.get_contexts();\n@@ -229,18 +229,18 @@ pub impl Scheduler {\n     /// You would want to think hard about doing this, e.g. if there are\n     /// pending I/O events it would be a bad idea.\n     fn switch_running_tasks_and_then(~self, next_task: ~Task, f: &fn(~Task)) {\n-        let mut self = self;\n-        assert!(self.in_task_context());\n+        let mut this = self;\n+        assert!(this.in_task_context());\n \n         rtdebug!(\"switching tasks\");\n \n-        let old_running_task = self.current_task.swap_unwrap();\n+        let old_running_task = this.current_task.swap_unwrap();\n         let f_fake_region = unsafe { transmute::<&fn(~Task), &fn(~Task)>(f) };\n         let f_opaque = ClosureConverter::from_fn(f_fake_region);\n-        self.enqueue_cleanup_job(GiveTask(old_running_task, f_opaque));\n-        self.current_task = Some(next_task);\n+        this.enqueue_cleanup_job(GiveTask(old_running_task, f_opaque));\n+        this.current_task = Some(next_task);\n \n-        local_sched::put(self);\n+        local_sched::put(this);\n \n         unsafe {\n             let sched = local_sched::unsafe_borrow();"}, {"sha": "376231e3b27c53eead7c9f87883e118f96253e4a", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -141,8 +141,8 @@ pub impl StreamWatcher {\n \n     fn close(self, cb: NullCallback) {\n         {\n-            let mut self = self;\n-            let data = get_watcher_data(&mut self);\n+            let mut this = self;\n+            let data = get_watcher_data(&mut this);\n             assert!(data.close_cb.is_none());\n             data.close_cb = Some(cb);\n         }"}, {"sha": "8f1a6ea0d34c1a17b19f6d4a2cd3057c7612a6b6", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -43,10 +43,10 @@ pub impl UvEventLoop {\n impl Drop for UvEventLoop {\n     fn finalize(&self) {\n         // XXX: Need mutable finalizer\n-        let self = unsafe {\n+        let this = unsafe {\n             transmute::<&UvEventLoop, &mut UvEventLoop>(self)\n         };\n-        self.uvio.uv_loop().close();\n+        this.uvio.uv_loop().close();\n     }\n }\n "}, {"sha": "f54879b36bdb371a35bfde61c030463a2e59649d", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -632,7 +632,7 @@ pub fn build_session_options(binary: @~str,\n     let extra_debuginfo = debugging_opts & session::extra_debug_info != 0;\n     let debuginfo = debugging_opts & session::debug_info != 0 ||\n         extra_debuginfo;\n-    let static = debugging_opts & session::static != 0;\n+    let statik = debugging_opts & session::statik != 0;\n     let target =\n         match target_opt {\n             None => host_triple(),\n@@ -660,7 +660,7 @@ pub fn build_session_options(binary: @~str,\n \n     let sopts = @session::options {\n         crate_type: crate_type,\n-        is_static: static,\n+        is_static: statik,\n         gc: gc,\n         optimize: opt_level,\n         debuginfo: debuginfo,"}, {"sha": "16eec0b10dea7410e60cda379aef2b048a8348c9", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -62,7 +62,7 @@ pub static gc: uint = 1 << 18;\n pub static jit: uint = 1 << 19;\n pub static debug_info: uint = 1 << 20;\n pub static extra_debug_info: uint = 1 << 21;\n-pub static static: uint = 1 << 22;\n+pub static statik: uint = 1 << 22;\n pub static print_link_args: uint = 1 << 23;\n \n pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n@@ -98,7 +98,7 @@ pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n       extra_debug_info),\n      (~\"debug-info\", ~\"Produce debug info (experimental)\", debug_info),\n      (~\"static\", ~\"Use or produce static libraries or binaries \" +\n-      \"(experimental)\", static)\n+      \"(experimental)\", statik)\n     ]\n }\n "}, {"sha": "2f24a8ceb24654a407a1b9c736f6dd2eff9693b7", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 49, "deletions": 48, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -359,7 +359,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n                 self, expr, cmt);\n         }\n \n-        fn mark_variable_as_used_mut(self: &CheckLoanCtxt,\n+        fn mark_variable_as_used_mut(this: &CheckLoanCtxt,\n                                      cmt: mc::cmt) {\n             //! If the mutability of the `cmt` being written is inherited\n             //! from a local variable, liveness will\n@@ -370,12 +370,12 @@ pub impl<'self> CheckLoanCtxt<'self> {\n             let mut cmt = cmt;\n             loop {\n                 debug!(\"mark_writes_through_upvars_as_used_mut(cmt=%s)\",\n-                       cmt.repr(self.tcx()));\n+                       cmt.repr(this.tcx()));\n                 match cmt.cat {\n                     mc::cat_local(id) |\n                     mc::cat_arg(id) |\n                     mc::cat_self(id) => {\n-                        self.tcx().used_mut_nodes.insert(id);\n+                        this.tcx().used_mut_nodes.insert(id);\n                         return;\n                     }\n \n@@ -411,22 +411,22 @@ pub impl<'self> CheckLoanCtxt<'self> {\n             }\n         }\n \n-        fn check_for_aliasable_mutable_writes(self: &CheckLoanCtxt,\n+        fn check_for_aliasable_mutable_writes(this: &CheckLoanCtxt,\n                                               expr: @ast::expr,\n                                               cmt: mc::cmt) -> bool {\n             //! Safety checks related to writes to aliasable, mutable locations\n \n             let guarantor = cmt.guarantor();\n             debug!(\"check_for_aliasable_mutable_writes(cmt=%s, guarantor=%s)\",\n-                   cmt.repr(self.tcx()), guarantor.repr(self.tcx()));\n+                   cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n             match guarantor.cat {\n                 mc::cat_deref(b, _, mc::region_ptr(m_mutbl, _)) => {\n                     // Statically prohibit writes to `&mut` when aliasable\n \n                     match b.freely_aliasable() {\n                         None => {}\n                         Some(cause) => {\n-                            self.bccx.report_aliasability_violation(\n+                            this.bccx.report_aliasability_violation(\n                                 expr.span,\n                                 MutabilityViolation,\n                                 cause);\n@@ -442,7 +442,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n                         derefs: deref_count\n                     };\n                     debug!(\"Inserting write guard at %?\", key);\n-                    self.bccx.write_guard_map.insert(key);\n+                    this.bccx.write_guard_map.insert(key);\n                 }\n \n                 _ => {}\n@@ -452,7 +452,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         }\n \n         fn check_for_assignment_to_restricted_or_frozen_location(\n-            self: &CheckLoanCtxt,\n+            this: &CheckLoanCtxt,\n             expr: @ast::expr,\n             cmt: mc::cmt) -> bool\n         {\n@@ -494,11 +494,11 @@ pub impl<'self> CheckLoanCtxt<'self> {\n             // `RESTR_MUTATE` restriction whenever the contents of an\n             // owned pointer are borrowed, and hence while `v[*]` is not\n             // restricted from being written, `v` is.\n-            for self.each_in_scope_restriction(expr.id, loan_path)\n+            for this.each_in_scope_restriction(expr.id, loan_path)\n                 |loan, restr|\n             {\n                 if restr.set.intersects(RESTR_MUTATE) {\n-                    self.report_illegal_mutation(expr, loan_path, loan);\n+                    this.report_illegal_mutation(expr, loan_path, loan);\n                     return false;\n                 }\n             }\n@@ -557,9 +557,9 @@ pub impl<'self> CheckLoanCtxt<'self> {\n                 }\n \n                 // Check for a non-const loan of `loan_path`\n-                for self.each_in_scope_loan(expr.id) |loan| {\n+                for this.each_in_scope_loan(expr.id) |loan| {\n                     if loan.loan_path == loan_path && loan.mutbl != m_const {\n-                        self.report_illegal_mutation(expr, full_loan_path, loan);\n+                        this.report_illegal_mutation(expr, full_loan_path, loan);\n                         return false;\n                     }\n                 }\n@@ -674,7 +674,7 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n                          body: &ast::blk,\n                          sp: span,\n                          id: ast::node_id,\n-                         self: @mut CheckLoanCtxt<'a>,\n+                         this: @mut CheckLoanCtxt<'a>,\n                          visitor: visit::vt<@mut CheckLoanCtxt<'a>>) {\n     match *fk {\n         visit::fk_item_fn(*) |\n@@ -685,48 +685,48 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n \n         visit::fk_anon(*) |\n         visit::fk_fn_block(*) => {\n-            let fty = ty::node_id_to_type(self.tcx(), id);\n+            let fty = ty::node_id_to_type(this.tcx(), id);\n             let fty_sigil = ty::ty_closure_sigil(fty);\n-            check_moves_from_captured_variables(self, id, fty_sigil);\n+            check_moves_from_captured_variables(this, id, fty_sigil);\n         }\n     }\n \n-    visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n+    visit::visit_fn(fk, decl, body, sp, id, this, visitor);\n \n-    fn check_moves_from_captured_variables(self: @mut CheckLoanCtxt,\n+    fn check_moves_from_captured_variables(this: @mut CheckLoanCtxt,\n                                            id: ast::node_id,\n                                            fty_sigil: ast::Sigil) {\n         match fty_sigil {\n             ast::ManagedSigil | ast::OwnedSigil => {\n-                let cap_vars = self.bccx.capture_map.get(&id);\n+                let cap_vars = this.bccx.capture_map.get(&id);\n                 for cap_vars.each |cap_var| {\n                     match cap_var.mode {\n                         moves::CapRef | moves::CapCopy => { loop; }\n                         moves::CapMove => { }\n                     }\n                     let def_id = ast_util::def_id_of_def(cap_var.def).node;\n-                    let ty = ty::node_id_to_type(self.tcx(), def_id);\n-                    let cmt = self.bccx.cat_def(id, cap_var.span,\n+                    let ty = ty::node_id_to_type(this.tcx(), def_id);\n+                    let cmt = this.bccx.cat_def(id, cap_var.span,\n                                                 ty, cap_var.def);\n-                    let move_err = self.analyze_move_out_from_cmt(cmt);\n+                    let move_err = this.analyze_move_out_from_cmt(cmt);\n                     match move_err {\n                         MoveOk => {}\n                         MoveFromIllegalCmt(move_cmt) => {\n-                            self.bccx.span_err(\n+                            this.bccx.span_err(\n                                 cap_var.span,\n                                 fmt!(\"illegal by-move capture of %s\",\n-                                     self.bccx.cmt_to_str(move_cmt)));\n+                                     this.bccx.cmt_to_str(move_cmt)));\n                         }\n                         MoveWhileBorrowed(loan_path, loan_span) => {\n-                            self.bccx.span_err(\n+                            this.bccx.span_err(\n                                 cap_var.span,\n                                 fmt!(\"cannot move `%s` into closure \\\n                                       because it is borrowed\",\n-                                     self.bccx.loan_path_to_str(loan_path)));\n-                            self.bccx.span_note(\n+                                     this.bccx.loan_path_to_str(loan_path)));\n+                            this.bccx.span_note(\n                                 loan_span,\n                                 fmt!(\"borrow of `%s` occurs here\",\n-                                     self.bccx.loan_path_to_str(loan_path)));\n+                                     this.bccx.loan_path_to_str(loan_path)));\n                         }\n                     }\n                 }\n@@ -738,48 +738,48 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n }\n \n fn check_loans_in_local<'a>(local: @ast::local,\n-                            self: @mut CheckLoanCtxt<'a>,\n+                            this: @mut CheckLoanCtxt<'a>,\n                             vt: visit::vt<@mut CheckLoanCtxt<'a>>) {\n-    visit::visit_local(local, self, vt);\n+    visit::visit_local(local, this, vt);\n }\n \n fn check_loans_in_expr<'a>(expr: @ast::expr,\n-                           self: @mut CheckLoanCtxt<'a>,\n+                           this: @mut CheckLoanCtxt<'a>,\n                            vt: visit::vt<@mut CheckLoanCtxt<'a>>) {\n     debug!(\"check_loans_in_expr(expr=%s)\",\n-           expr.repr(self.tcx()));\n+           expr.repr(this.tcx()));\n \n-    visit::visit_expr(expr, self, vt);\n+    visit::visit_expr(expr, this, vt);\n \n-    self.check_for_conflicting_loans(expr.id);\n+    this.check_for_conflicting_loans(expr.id);\n \n-    if self.bccx.moves_map.contains(&expr.id) {\n-        self.check_move_out_from_expr(expr);\n+    if this.bccx.moves_map.contains(&expr.id) {\n+        this.check_move_out_from_expr(expr);\n     }\n \n     match expr.node {\n       ast::expr_assign(dest, _) |\n       ast::expr_assign_op(_, dest, _) => {\n-        self.check_assignment(dest);\n+        this.check_assignment(dest);\n       }\n       ast::expr_call(f, ref args, _) => {\n-        self.check_call(expr, Some(f), f.id, f.span, *args);\n+        this.check_call(expr, Some(f), f.id, f.span, *args);\n       }\n       ast::expr_method_call(_, _, _, ref args, _) => {\n-        self.check_call(expr, None, expr.callee_id, expr.span, *args);\n+        this.check_call(expr, None, expr.callee_id, expr.span, *args);\n       }\n       ast::expr_index(_, rval) |\n       ast::expr_binary(_, _, rval)\n-      if self.bccx.method_map.contains_key(&expr.id) => {\n-        self.check_call(expr,\n+      if this.bccx.method_map.contains_key(&expr.id) => {\n+        this.check_call(expr,\n                         None,\n                         expr.callee_id,\n                         expr.span,\n                         ~[rval]);\n       }\n       ast::expr_unary(*) | ast::expr_index(*)\n-      if self.bccx.method_map.contains_key(&expr.id) => {\n-        self.check_call(expr,\n+      if this.bccx.method_map.contains_key(&expr.id) => {\n+        this.check_call(expr,\n                         None,\n                         expr.callee_id,\n                         expr.span,\n@@ -790,10 +790,10 @@ fn check_loans_in_expr<'a>(expr: @ast::expr,\n }\n \n fn check_loans_in_pat<'a>(pat: @ast::pat,\n-                          self: @mut CheckLoanCtxt<'a>,\n+                          this: @mut CheckLoanCtxt<'a>,\n                           vt: visit::vt<@mut CheckLoanCtxt<'a>>)\n {\n-    self.check_for_conflicting_loans(pat.id);\n+    this.check_for_conflicting_loans(pat.id);\n \n     // Note: moves out of pattern bindings are not checked by\n     // the borrow checker, at least not directly.  What happens\n@@ -806,13 +806,14 @@ fn check_loans_in_pat<'a>(pat: @ast::pat,\n     // rewalk the patterns and rebuild the pattern\n     // categorizations.\n \n-    visit::visit_pat(pat, self, vt);\n+    visit::visit_pat(pat, this, vt);\n }\n \n fn check_loans_in_block<'a>(blk: &ast::blk,\n-                            self: @mut CheckLoanCtxt<'a>,\n+                            this: @mut CheckLoanCtxt<'a>,\n                             vt: visit::vt<@mut CheckLoanCtxt<'a>>)\n {\n-    visit::visit_block(blk, self, vt);\n-    self.check_for_conflicting_loans(blk.node.id);\n+    visit::visit_block(blk, this, vt);\n+    this.check_for_conflicting_loans(blk.node.id);\n }\n+"}, {"sha": "64d32d713d0da39778d44632060d8a37ba78b6ea", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -90,22 +90,22 @@ pub fn gather_loans(bccx: @BorrowckCtxt,\n }\n \n fn add_pat_to_id_range(p: @ast::pat,\n-                       self: @mut GatherLoanCtxt,\n+                       this: @mut GatherLoanCtxt,\n                        v: visit::vt<@mut GatherLoanCtxt>) {\n     // NB: This visitor function just adds the pat ids into the id\n     // range. We gather loans that occur in patterns using the\n     // `gather_pat()` method below. Eventually these two should be\n     // brought together.\n-    self.id_range.add(p.id);\n-    visit::visit_pat(p, self, v);\n+    this.id_range.add(p.id);\n+    visit::visit_pat(p, this, v);\n }\n \n fn gather_loans_in_fn(fk: &visit::fn_kind,\n                       decl: &ast::fn_decl,\n                       body: &ast::blk,\n                       sp: span,\n                       id: ast::node_id,\n-                      self: @mut GatherLoanCtxt,\n+                      this: @mut GatherLoanCtxt,\n                       v: visit::vt<@mut GatherLoanCtxt>) {\n     match fk {\n         // Do not visit items here, the outer loop in borrowck/mod\n@@ -116,95 +116,95 @@ fn gather_loans_in_fn(fk: &visit::fn_kind,\n \n         // Visit closures as part of the containing item.\n         &visit::fk_anon(*) | &visit::fk_fn_block(*) => {\n-            self.push_repeating_id(body.node.id);\n-            visit::visit_fn(fk, decl, body, sp, id, self, v);\n-            self.pop_repeating_id(body.node.id);\n+            this.push_repeating_id(body.node.id);\n+            visit::visit_fn(fk, decl, body, sp, id, this, v);\n+            this.pop_repeating_id(body.node.id);\n         }\n     }\n }\n \n fn gather_loans_in_block(blk: &ast::blk,\n-                         self: @mut GatherLoanCtxt,\n+                         this: @mut GatherLoanCtxt,\n                          vt: visit::vt<@mut GatherLoanCtxt>) {\n-    self.id_range.add(blk.node.id);\n-    visit::visit_block(blk, self, vt);\n+    this.id_range.add(blk.node.id);\n+    visit::visit_block(blk, this, vt);\n }\n \n fn gather_loans_in_expr(ex: @ast::expr,\n-                        self: @mut GatherLoanCtxt,\n+                        this: @mut GatherLoanCtxt,\n                         vt: visit::vt<@mut GatherLoanCtxt>) {\n-    let bccx = self.bccx;\n+    let bccx = this.bccx;\n     let tcx = bccx.tcx;\n \n     debug!(\"gather_loans_in_expr(expr=%?/%s)\",\n            ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n \n-    self.id_range.add(ex.id);\n-    self.id_range.add(ex.callee_id);\n+    this.id_range.add(ex.id);\n+    this.id_range.add(ex.callee_id);\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     for tcx.adjustments.find(&ex.id).each |&adjustments| {\n-        self.guarantee_adjustments(ex, *adjustments);\n+        this.guarantee_adjustments(ex, *adjustments);\n     }\n \n     // Special checks for various kinds of expressions:\n     match ex.node {\n       ast::expr_addr_of(mutbl, base) => {\n-        let base_cmt = self.bccx.cat_expr(base);\n+        let base_cmt = this.bccx.cat_expr(base);\n \n         // make sure that the thing we are pointing out stays valid\n         // for the lifetime `scope_r` of the resulting ptr:\n         let scope_r = ty_region(tcx, ex.span, ty::expr_ty(tcx, ex));\n-        self.guarantee_valid(ex.id, ex.span, base_cmt, mutbl, scope_r);\n-        visit::visit_expr(ex, self, vt);\n+        this.guarantee_valid(ex.id, ex.span, base_cmt, mutbl, scope_r);\n+        visit::visit_expr(ex, this, vt);\n       }\n \n       ast::expr_match(ex_v, ref arms) => {\n-        let cmt = self.bccx.cat_expr(ex_v);\n+        let cmt = this.bccx.cat_expr(ex_v);\n         for arms.each |arm| {\n             for arm.pats.each |pat| {\n-                self.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n+                this.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n             }\n         }\n-        visit::visit_expr(ex, self, vt);\n+        visit::visit_expr(ex, this, vt);\n       }\n \n       ast::expr_index(_, arg) |\n       ast::expr_binary(_, _, arg)\n-      if self.bccx.method_map.contains_key(&ex.id) => {\n+      if this.bccx.method_map.contains_key(&ex.id) => {\n           // Arguments in method calls are always passed by ref.\n           //\n           // Currently these do not use adjustments, so we have to\n           // hardcode this check here (note that the receiver DOES use\n           // adjustments).\n           let scope_r = ty::re_scope(ex.id);\n-          let arg_cmt = self.bccx.cat_expr(arg);\n-          self.guarantee_valid(arg.id, arg.span, arg_cmt, m_imm, scope_r);\n-          visit::visit_expr(ex, self, vt);\n+          let arg_cmt = this.bccx.cat_expr(arg);\n+          this.guarantee_valid(arg.id, arg.span, arg_cmt, m_imm, scope_r);\n+          visit::visit_expr(ex, this, vt);\n       }\n \n       // see explanation attached to the `root_ub` field:\n       ast::expr_while(cond, ref body) => {\n           // during the condition, can only root for the condition\n-          self.push_repeating_id(cond.id);\n-          (vt.visit_expr)(cond, self, vt);\n-          self.pop_repeating_id(cond.id);\n+          this.push_repeating_id(cond.id);\n+          (vt.visit_expr)(cond, this, vt);\n+          this.pop_repeating_id(cond.id);\n \n           // during body, can only root for the body\n-          self.push_repeating_id(body.node.id);\n-          (vt.visit_block)(body, self, vt);\n-          self.pop_repeating_id(body.node.id);\n+          this.push_repeating_id(body.node.id);\n+          (vt.visit_block)(body, this, vt);\n+          this.pop_repeating_id(body.node.id);\n       }\n \n       // see explanation attached to the `root_ub` field:\n       ast::expr_loop(ref body, _) => {\n-          self.push_repeating_id(body.node.id);\n-          visit::visit_expr(ex, self, vt);\n-          self.pop_repeating_id(body.node.id);\n+          this.push_repeating_id(body.node.id);\n+          visit::visit_expr(ex, this, vt);\n+          this.pop_repeating_id(body.node.id);\n       }\n \n       _ => {\n-        visit::visit_expr(ex, self, vt);\n+        visit::visit_expr(ex, this, vt);\n       }\n     }\n }\n@@ -624,13 +624,14 @@ pub impl GatherLoanCtxt {\n // Setting up info that preserve needs.\n // This is just the most convenient place to do it.\n fn add_stmt_to_map(stmt: @ast::stmt,\n-                   self: @mut GatherLoanCtxt,\n+                   this: @mut GatherLoanCtxt,\n                    vt: visit::vt<@mut GatherLoanCtxt>) {\n     match stmt.node {\n         ast::stmt_expr(_, id) | ast::stmt_semi(_, id) => {\n-            self.bccx.stmt_map.insert(id);\n+            this.bccx.stmt_map.insert(id);\n         }\n         _ => ()\n     }\n-    visit::visit_stmt(stmt, self, vt);\n+    visit::visit_stmt(stmt, this, vt);\n }\n+"}, {"sha": "0f01b2b1e418e384e98cb0b8e464a3003e2e8e6f", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -110,7 +110,7 @@ fn borrowck_fn(fk: &visit::fn_kind,\n                body: &ast::blk,\n                sp: span,\n                id: ast::node_id,\n-               self: @BorrowckCtxt,\n+               this: @BorrowckCtxt,\n                v: visit::vt<@BorrowckCtxt>) {\n     match fk {\n         &visit::fk_anon(*) |\n@@ -124,11 +124,11 @@ fn borrowck_fn(fk: &visit::fn_kind,\n \n             // Check the body of fn items.\n             let (id_range, all_loans) =\n-                gather_loans::gather_loans(self, body);\n+                gather_loans::gather_loans(this, body);\n             let all_loans: &~[Loan] = &*all_loans; // FIXME(#5074)\n             let mut dfcx =\n-                DataFlowContext::new(self.tcx,\n-                                     self.method_map,\n+                DataFlowContext::new(this.tcx,\n+                                     this.method_map,\n                                      LoanDataFlowOperator,\n                                      id_range,\n                                      all_loans.len());\n@@ -137,11 +137,11 @@ fn borrowck_fn(fk: &visit::fn_kind,\n                 dfcx.add_kill(loan.kill_scope, loan_idx);\n             }\n             dfcx.propagate(body);\n-            check_loans::check_loans(self, &dfcx, *all_loans, body);\n+            check_loans::check_loans(this, &dfcx, *all_loans, body);\n         }\n     }\n \n-    visit::visit_fn(fk, decl, body, sp, id, self, v);\n+    visit::visit_fn(fk, decl, body, sp, id, this, v);\n }\n \n // ----------------------------------------------------------------------"}, {"sha": "31d22b76800c1c6373c76e87048ec229bf464225", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -753,7 +753,8 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_lit(*) |\n-            ast::expr_path(*) => {\n+            ast::expr_path(*) |\n+            ast::expr_self => {\n             }\n \n             ast::expr_addr_of(_, e) |"}, {"sha": "98cc8cc014fb60a983707ccc6496b522312610c0", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -45,7 +45,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n         |expr, depth, v| {\n             match expr.node {\n               ast::expr_fn_block(*) => visit::visit_expr(expr, depth + 1, v),\n-              ast::expr_path(*) => {\n+              ast::expr_path(*) | ast::expr_self => {\n                   let mut i = 0;\n                   match def_map.find(&expr.id) {\n                     None => fail!(~\"path not found\"),"}, {"sha": "171048eac5575c932468cbca509ac623043d2888", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -341,44 +341,44 @@ pub impl IrMaps {\n     }\n }\n \n-fn visit_item(item: @item, self: @mut IrMaps, v: vt<@mut IrMaps>) {\n-    let old_cur_item = self.cur_item;\n-    self.cur_item = item.id;\n-    visit::visit_item(item, self, v);\n-    self.cur_item = old_cur_item;\n+fn visit_item(item: @item, this: @mut IrMaps, v: vt<@mut IrMaps>) {\n+    let old_cur_item = this.cur_item;\n+    this.cur_item = item.id;\n+    visit::visit_item(item, this, v);\n+    this.cur_item = old_cur_item;\n }\n \n fn visit_fn(fk: &visit::fn_kind,\n             decl: &fn_decl,\n             body: &blk,\n             sp: span,\n             id: node_id,\n-            self: @mut IrMaps,\n+            this: @mut IrMaps,\n             v: vt<@mut IrMaps>) {\n     debug!(\"visit_fn: id=%d\", id);\n     let _i = ::util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n-    let fn_maps = @mut IrMaps(self.tcx,\n-                              self.method_map,\n-                              self.variable_moves_map,\n-                              self.capture_map,\n-                              self.cur_item);\n+    let fn_maps = @mut IrMaps(this.tcx,\n+                              this.method_map,\n+                              this.variable_moves_map,\n+                              this.capture_map,\n+                              this.cur_item);\n \n     unsafe {\n         debug!(\"creating fn_maps: %x\", transmute(&*fn_maps));\n     }\n \n     for decl.inputs.each |arg| {\n-        do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n+        do pat_util::pat_bindings(this.tcx.def_map, arg.pat)\n                 |_bm, arg_id, _x, path| {\n             debug!(\"adding argument %d\", arg_id);\n             let ident = ast_util::path_to_ident(path);\n             fn_maps.add_variable(Arg(arg_id, ident));\n         }\n     };\n \n-    // Add `self`, whether explicit or implicit.\n+    // Add `this`, whether explicit or implicit.\n     match *fk {\n         fk_method(_, _, method) => {\n             match method.self_ty.node {\n@@ -423,71 +423,71 @@ fn visit_fn(fk: &visit::fn_kind,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(local: @local, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n-    let def_map = self.tcx.def_map;\n+fn visit_local(local: @local, this: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+    let def_map = this.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.node.pat) |_bm, p_id, sp, path| {\n         debug!(\"adding local variable %d\", p_id);\n         let name = ast_util::path_to_ident(path);\n-        self.add_live_node_for_node(p_id, VarDefNode(sp));\n+        this.add_live_node_for_node(p_id, VarDefNode(sp));\n         let kind = match local.node.init {\n           Some(_) => FromLetWithInitializer,\n           None => FromLetNoInitializer\n         };\n-        self.add_variable(Local(LocalInfo {\n+        this.add_variable(Local(LocalInfo {\n           id: p_id,\n           ident: name,\n           is_mutbl: local.node.is_mutbl,\n           kind: kind\n         }));\n     }\n-    visit::visit_local(local, self, vt);\n+    visit::visit_local(local, this, vt);\n }\n \n-fn visit_arm(arm: &arm, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n-    let def_map = self.tcx.def_map;\n+fn visit_arm(arm: &arm, this: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+    let def_map = this.tcx.def_map;\n     for arm.pats.each |pat| {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n             debug!(\"adding local variable %d from match with bm %?\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n-            self.add_live_node_for_node(p_id, VarDefNode(sp));\n-            self.add_variable(Local(LocalInfo {\n+            this.add_live_node_for_node(p_id, VarDefNode(sp));\n+            this.add_variable(Local(LocalInfo {\n                 id: p_id,\n                 ident: name,\n                 is_mutbl: false,\n                 kind: FromMatch(bm)\n             }));\n         }\n     }\n-    visit::visit_arm(arm, self, vt);\n+    visit::visit_arm(arm, this, vt);\n }\n \n-fn visit_expr(expr: @expr, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+fn visit_expr(expr: @expr, this: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      expr_path(_) => {\n-        let def = self.tcx.def_map.get_copy(&expr.id);\n+      expr_path(_) | expr_self => {\n+        let def = this.tcx.def_map.get_copy(&expr.id);\n         debug!(\"expr %d: path that leads to %?\", expr.id, def);\n         if moves::moved_variable_node_id_from_def(def).is_some() {\n-            self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+            this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n-        visit::visit_expr(expr, self, vt);\n+        visit::visit_expr(expr, this, vt);\n       }\n       expr_fn_block(*) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n-        self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n \n         // Make a live_node for each captured variable, with the span\n         // being the location that the variable is used.  This results\n         // in better error messages than just pointing at the closure\n         // construction site.\n-        let cvs = self.capture_map.get(&expr.id);\n+        let cvs = this.capture_map.get(&expr.id);\n         let mut call_caps = ~[];\n         for cvs.each |cv| {\n             match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n-                let cv_ln = self.add_live_node(FreeVarNode(cv.span));\n+                let cv_ln = this.add_live_node(FreeVarNode(cv.span));\n                 let is_move = match cv.mode {\n                     // var must be dead afterwards\n                     moves::CapMove => true,\n@@ -502,19 +502,19 @@ fn visit_expr(expr: @expr, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n               None => {}\n             }\n         }\n-        self.set_captures(expr.id, call_caps);\n+        this.set_captures(expr.id, call_caps);\n \n-        visit::visit_expr(expr, self, vt);\n+        visit::visit_expr(expr, this, vt);\n       }\n \n       // live nodes required for interesting control flow:\n       expr_if(*) | expr_match(*) | expr_while(*) | expr_loop(*) => {\n-        self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::visit_expr(expr, self, vt);\n+        this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        visit::visit_expr(expr, this, vt);\n       }\n       expr_binary(op, _, _) if ast_util::lazy_binop(op) => {\n-        self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::visit_expr(expr, self, vt);\n+        this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        visit::visit_expr(expr, this, vt);\n       }\n \n       // otherwise, live nodes are not required:\n@@ -526,7 +526,7 @@ fn visit_expr(expr: @expr, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n       expr_assign(*) | expr_assign_op(*) | expr_mac(*) |\n       expr_struct(*) | expr_repeat(*) | expr_paren(*) |\n       expr_inline_asm(*) => {\n-          visit::visit_expr(expr, self, vt);\n+          visit::visit_expr(expr, this, vt);\n       }\n     }\n }\n@@ -1006,7 +1006,7 @@ pub impl Liveness {\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n-          expr_path(_) => {\n+          expr_path(_) | expr_self => {\n               self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n@@ -1409,13 +1409,13 @@ pub impl Liveness {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(local: @local, self: @Liveness, vt: vt<@Liveness>) {\n+fn check_local(local: @local, this: @Liveness, vt: vt<@Liveness>) {\n     match local.node.init {\n       Some(_) => {\n \n         // Initializer:\n-        self.warn_about_unused_or_dead_vars_in_pat(local.node.pat);\n-        self.check_for_reassignments_in_pat(local.node.pat,\n+        this.warn_about_unused_or_dead_vars_in_pat(local.node.pat);\n+        this.check_for_reassignments_in_pat(local.node.pat,\n                                             local.node.is_mutbl);\n       }\n       None => {\n@@ -1424,12 +1424,12 @@ fn check_local(local: @local, self: @Liveness, vt: vt<@Liveness>) {\n         // should not be live at this point.\n \n         debug!(\"check_local() with no initializer\");\n-        do self.pat_bindings(local.node.pat) |ln, var, sp, id| {\n-            if !self.warn_about_unused(sp, id, ln, var) {\n-                match self.live_on_exit(ln, var) {\n+        do this.pat_bindings(local.node.pat) |ln, var, sp, id| {\n+            if !this.warn_about_unused(sp, id, ln, var) {\n+                match this.live_on_exit(ln, var) {\n                   None => { /* not live: good */ }\n                   Some(lnk) => {\n-                    self.report_illegal_read(\n+                    this.report_illegal_read(\n                         local.span, lnk, var,\n                         PossiblyUninitializedVariable);\n                   }\n@@ -1439,77 +1439,77 @@ fn check_local(local: @local, self: @Liveness, vt: vt<@Liveness>) {\n       }\n     }\n \n-    visit::visit_local(local, self, vt);\n+    visit::visit_local(local, this, vt);\n }\n \n-fn check_arm(arm: &arm, self: @Liveness, vt: vt<@Liveness>) {\n-    do self.arm_pats_bindings(arm.pats) |ln, var, sp, id| {\n-        self.warn_about_unused(sp, id, ln, var);\n+fn check_arm(arm: &arm, this: @Liveness, vt: vt<@Liveness>) {\n+    do this.arm_pats_bindings(arm.pats) |ln, var, sp, id| {\n+        this.warn_about_unused(sp, id, ln, var);\n     }\n-    visit::visit_arm(arm, self, vt);\n+    visit::visit_arm(arm, this, vt);\n }\n \n-fn check_expr(expr: @expr, self: @Liveness, vt: vt<@Liveness>) {\n+fn check_expr(expr: @expr, this: @Liveness, vt: vt<@Liveness>) {\n     match expr.node {\n-      expr_path(_) => {\n-        for self.variable_from_def_map(expr.id, expr.span).each |var| {\n-            let ln = self.live_node(expr.id, expr.span);\n+      expr_path(_) | expr_self => {\n+        for this.variable_from_def_map(expr.id, expr.span).each |var| {\n+            let ln = this.live_node(expr.id, expr.span);\n \n-            match self.ir.variable_moves_map.find(&expr.id) {\n+            match this.ir.variable_moves_map.find(&expr.id) {\n                 None => {}\n                 Some(&entire_expr) => {\n                     debug!(\"(checking expr) is a move: `%s`\",\n-                           expr_to_str(expr, self.tcx.sess.intr()));\n-                    self.check_move_from_var(ln, *var, entire_expr);\n+                           expr_to_str(expr, this.tcx.sess.intr()));\n+                    this.check_move_from_var(ln, *var, entire_expr);\n                 }\n             }\n         }\n \n-        visit::visit_expr(expr, self, vt);\n+        visit::visit_expr(expr, this, vt);\n       }\n \n       expr_fn_block(*) => {\n-        let caps = self.ir.captures(expr);\n+        let caps = this.ir.captures(expr);\n         for caps.each |cap| {\n-            let var = self.variable(cap.var_nid, expr.span);\n+            let var = this.variable(cap.var_nid, expr.span);\n             if cap.is_move {\n-                self.check_move_from_var(cap.ln, var, expr);\n+                this.check_move_from_var(cap.ln, var, expr);\n             }\n         }\n \n-        visit::visit_expr(expr, self, vt);\n+        visit::visit_expr(expr, this, vt);\n       }\n \n       expr_assign(l, r) => {\n-        self.check_lvalue(l, vt);\n-        (vt.visit_expr)(r, self, vt);\n+        this.check_lvalue(l, vt);\n+        (vt.visit_expr)(r, this, vt);\n \n-        visit::visit_expr(expr, self, vt);\n+        visit::visit_expr(expr, this, vt);\n       }\n \n       expr_assign_op(_, l, _) => {\n-        self.check_lvalue(l, vt);\n+        this.check_lvalue(l, vt);\n \n-        visit::visit_expr(expr, self, vt);\n+        visit::visit_expr(expr, this, vt);\n       }\n \n       expr_inline_asm(ref ia) => {\n         for ia.inputs.each |&(_, in)| {\n-          (vt.visit_expr)(in, self, vt);\n+          (vt.visit_expr)(in, this, vt);\n         }\n \n         // Output operands must be lvalues\n         for ia.outputs.each |&(_, out)| {\n           match out.node {\n             expr_addr_of(_, inner) => {\n-              self.check_lvalue(inner, vt);\n+              this.check_lvalue(inner, vt);\n             }\n             _ => {}\n           }\n-          (vt.visit_expr)(out, self, vt);\n+          (vt.visit_expr)(out, this, vt);\n         }\n \n-        visit::visit_expr(expr, self, vt);\n+        visit::visit_expr(expr, this, vt);\n       }\n \n       // no correctness conditions related to liveness\n@@ -1521,7 +1521,7 @@ fn check_expr(expr: @expr, self: @Liveness, vt: vt<@Liveness>) {\n       expr_again(*) | expr_lit(_) | expr_block(*) |\n       expr_mac(*) | expr_addr_of(*) | expr_struct(*) | expr_repeat(*) |\n       expr_paren(*) => {\n-        visit::visit_expr(expr, self, vt);\n+        visit::visit_expr(expr, this, vt);\n       }\n     }\n }"}, {"sha": "95ed7fe8efcd598790d0854ebbbd1b67d87c562c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -406,7 +406,7 @@ pub impl mem_categorization_ctxt {\n             self.cat_index(expr, base_cmt, 0)\n           }\n \n-          ast::expr_path(_) => {\n+          ast::expr_path(_) | ast::expr_self => {\n             let def = self.tcx.def_map.get_copy(&expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }"}, {"sha": "3a2fb654006ecef6662c75c57bcd4770a7d75510", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -435,7 +435,7 @@ pub impl VisitContext {\n         debug!(\"comp_mode = %?\", comp_mode);\n \n         match expr.node {\n-            expr_path(*) => {\n+            expr_path(*) | expr_self => {\n                 match comp_mode {\n                     MoveInPart(entire_expr) => {\n                         self.move_maps.variable_moves_map.insert("}, {"sha": "74082c02f6d0411804fd31cfaf6b4e2f86d18594", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -310,14 +310,14 @@ pub impl RegionMaps {\n             }\n         }\n \n-        fn ancestors_of(self: &RegionMaps, scope: ast::node_id)\n+        fn ancestors_of(this: &RegionMaps, scope: ast::node_id)\n             -> ~[ast::node_id]\n         {\n             // debug!(\"ancestors_of(scope=%d)\", scope);\n             let mut result = ~[scope];\n             let mut scope = scope;\n             loop {\n-                match self.scope_map.find(&scope) {\n+                match this.scope_map.find(&scope) {\n                     None => return result,\n                     Some(&superscope) => {\n                         result.push(superscope);\n@@ -685,7 +685,7 @@ pub impl DetermineRpCtxt {\n             None => {\n                 self.anon_implies_rp\n             }\n-            Some(ref l) if l.ident == special_idents::static => {\n+            Some(ref l) if l.ident == special_idents::statik => {\n                 false\n             }\n             Some(ref l) if l.ident == special_idents::self_ => {"}, {"sha": "9a37f65f47053082522285dfa81adaf295bd041b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -35,7 +35,7 @@ use syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n use syntax::ast::{def_upvar, def_use, def_variant, div, eq};\n use syntax::ast::{expr, expr_again, expr_assign_op};\n use syntax::ast::{expr_index, expr_loop};\n-use syntax::ast::{expr_path, expr_struct, expr_unary, fn_decl};\n+use syntax::ast::{expr_path, expr_self, expr_struct, expr_unary, fn_decl};\n use syntax::ast::{foreign_item, foreign_item_const, foreign_item_fn, ge};\n use syntax::ast::Generics;\n use syntax::ast::{gt, ident, inherited, item, item_struct};\n@@ -326,12 +326,14 @@ pub fn namespace_for_duplicate_checking_mode(mode: DuplicateCheckingMode)\n /// One local scope.\n pub struct Rib {\n     bindings: @mut HashMap<ident,def_like>,\n+    self_binding: @mut Option<def_like>,\n     kind: RibKind,\n }\n \n pub fn Rib(kind: RibKind) -> Rib {\n     Rib {\n         bindings: @mut HashMap::new(),\n+        self_binding: @mut None,\n         kind: kind\n     }\n }\n@@ -762,7 +764,7 @@ pub fn Resolver(session: Session,\n \n     let current_module = graph_root.get_module();\n \n-    let self = Resolver {\n+    let this = Resolver {\n         session: @session,\n         lang_items: copy lang_items,\n         crate: crate,\n@@ -800,7 +802,7 @@ pub fn Resolver(session: Session,\n         intr: session.intr()\n     };\n \n-    self\n+    this\n }\n \n /// The main resolver class.\n@@ -3655,8 +3657,7 @@ pub impl Resolver {\n                 HasSelfBinding(self_node_id, is_implicit) => {\n                     let def_like = dl_def(def_self(self_node_id,\n                                                    is_implicit));\n-                    (*function_value_rib).bindings.insert(self.self_ident,\n-                                                          def_like);\n+                    *function_value_rib.self_binding = Some(def_like);\n                 }\n             }\n \n@@ -4562,7 +4563,7 @@ pub impl Resolver {\n                                         ident: ident,\n                                         namespace: Namespace,\n                                         span: span)\n-                                     -> Option<def> {\n+                                        -> Option<def> {\n         // Check the local set of ribs.\n         let search_result;\n         match namespace {\n@@ -4591,6 +4592,35 @@ pub impl Resolver {\n         }\n     }\n \n+    fn resolve_self_value_in_local_ribs(@mut self, span: span)\n+                                        -> Option<def> {\n+        // FIXME #4950: This should not use a while loop.\n+        let ribs = &mut self.value_ribs;\n+        let mut i = ribs.len();\n+        while i != 0 {\n+            i -= 1;\n+            match *ribs[i].self_binding {\n+                Some(def_like) => {\n+                    match self.upvarify(*ribs,\n+                                        i,\n+                                        def_like,\n+                                        span,\n+                                        DontAllowCapturingSelf) {\n+                        Some(dl_def(def)) => return Some(def),\n+                        _ => {\n+                            self.session.span_bug(span,\n+                                                  ~\"self wasn't mapped to a \\\n+                                                    def?!\")\n+                        }\n+                    }\n+                }\n+                None => {}\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn resolve_item_by_identifier_in_lexical_scope(@mut self,\n                                                    ident: ident,\n                                                    namespace: Namespace)\n@@ -4805,12 +4835,25 @@ pub impl Resolver {\n                                                    `%s`\",\n                                                    *self.session.str_of(\n                                                        label))),\n-                    Some(dl_def(def @ def_label(_))) =>\n-                        self.record_def(expr.id, def),\n-                    Some(_) =>\n+                    Some(dl_def(def @ def_label(_))) => {\n+                        self.record_def(expr.id, def)\n+                    }\n+                    Some(_) => {\n                         self.session.span_bug(expr.span,\n                                               ~\"label wasn't mapped to a \\\n                                                 label def!\")\n+                    }\n+                }\n+            }\n+\n+            expr_self => {\n+                match self.resolve_self_value_in_local_ribs(expr.span) {\n+                    None => {\n+                        self.session.span_err(expr.span,\n+                                              ~\"`self` is not allowed in \\\n+                                                this context\")\n+                    }\n+                    Some(def) => self.record_def(expr.id, def),\n                 }\n             }\n "}, {"sha": "de6a4452da1da329043bc2eb9e83e1ebbad02e85", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -36,7 +36,7 @@ use syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n use syntax::ast::{def_upvar, def_use, def_variant, div, eq};\n use syntax::ast::{expr, expr_again, expr_assign_op};\n use syntax::ast::{expr_index, expr_loop};\n-use syntax::ast::{expr_path, expr_struct, expr_unary, fn_decl};\n+use syntax::ast::{expr_path, expr_self, expr_struct, expr_unary, fn_decl};\n use syntax::ast::{foreign_item, foreign_item_const, foreign_item_fn, ge};\n use syntax::ast::Generics;\n use syntax::ast::{gt, ident, inherited, item, item_struct};\n@@ -327,12 +327,14 @@ pub fn namespace_for_duplicate_checking_mode(mode: DuplicateCheckingMode)\n /// One local scope.\n pub struct Rib {\n     bindings: @mut HashMap<ident,def_like>,\n+    self_binding: @mut Option<def_like>,\n     kind: RibKind,\n }\n \n pub fn Rib(kind: RibKind) -> Rib {\n     Rib {\n         bindings: @mut HashMap::new(),\n+        self_binding: @mut None,\n         kind: kind\n     }\n }\n@@ -763,7 +765,7 @@ pub fn Resolver(session: Session,\n \n     let current_module = graph_root.get_module();\n \n-    let self = Resolver {\n+    let this = Resolver {\n         session: @session,\n         lang_items: copy lang_items,\n         crate: crate,\n@@ -806,7 +808,7 @@ pub fn Resolver(session: Session,\n         intr: session.intr()\n     };\n \n-    self\n+    this\n }\n \n /// The main resolver class.\n@@ -3695,8 +3697,7 @@ pub impl Resolver {\n                 HasSelfBinding(self_node_id, is_implicit) => {\n                     let def_like = dl_def(def_self(self_node_id,\n                                                    is_implicit));\n-                    (*function_value_rib).bindings.insert(self.self_ident,\n-                                                          def_like);\n+                    *function_value_rib.self_binding = Some(def_like);\n                 }\n             }\n \n@@ -4603,7 +4604,7 @@ pub impl Resolver {\n                                         ident: ident,\n                                         namespace: Namespace,\n                                         span: span)\n-                                     -> Option<def> {\n+                                        -> Option<def> {\n         // Check the local set of ribs.\n         let search_result;\n         match namespace {\n@@ -4632,6 +4633,35 @@ pub impl Resolver {\n         }\n     }\n \n+    fn resolve_self_value_in_local_ribs(@mut self, span: span)\n+                                        -> Option<def> {\n+        // FIXME #4950: This should not use a while loop.\n+        let ribs = &mut self.value_ribs;\n+        let mut i = ribs.len();\n+        while i != 0 {\n+            i -= 1;\n+            match *ribs[i].self_binding {\n+                Some(def_like) => {\n+                    match self.upvarify(ribs,\n+                                        i,\n+                                        def_like,\n+                                        span,\n+                                        DontAllowCapturingSelf) {\n+                        Some(dl_def(def)) => return Some(def),\n+                        _ => {\n+                            self.session.span_bug(span,\n+                                                  ~\"self wasn't mapped to a \\\n+                                                    def?!\")\n+                        }\n+                    }\n+                }\n+                None => {}\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn resolve_item_by_identifier_in_lexical_scope(@mut self,\n                                                    ident: ident,\n                                                    namespace: Namespace)\n@@ -4845,12 +4875,25 @@ pub impl Resolver {\n                                                    `%s`\",\n                                                    *self.session.str_of(\n                                                        label))),\n-                    Some(dl_def(def @ def_label(_))) =>\n-                        self.record_def(expr.id, def),\n-                    Some(_) =>\n+                    Some(dl_def(def @ def_label(_))) => {\n+                        self.record_def(expr.id, def)\n+                    }\n+                    Some(_) => {\n                         self.session.span_bug(expr.span,\n                                               ~\"label wasn't mapped to a \\\n                                                 label def!\")\n+                    }\n+                }\n+            }\n+\n+            expr_self => {\n+                match self.resolve_self_value_in_local_ribs(expr.span) {\n+                    None => {\n+                        self.session.span_err(expr.span,\n+                                              ~\"`self` is not allowed in \\\n+                                                this context\")\n+                    }\n+                    Some(def) => self.record_def(expr.id, def),\n                 }\n             }\n "}, {"sha": "b24e88698af8814aee656b9f60a8c579d4cd1137", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -426,10 +426,10 @@ pub fn enter_match<'r>(bcx: block,\n                         vec::append(sub, vec::slice(br.pats, 0u, col)),\n                         vec::slice(br.pats, col + 1u, br.pats.len()));\n \n-                let self = br.pats[col];\n-                match self.node {\n+                let this = br.pats[col];\n+                match this.node {\n                     ast::pat_ident(_, path, None) => {\n-                        if pat_is_binding(dm, self) {\n+                        if pat_is_binding(dm, this) {\n                             let binding_info =\n                                 br.data.bindings_map.get(\n                                     &path_to_ident(path));"}, {"sha": "8000484c0550fc0f22246ea77af380065a7d8beb", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -256,13 +256,11 @@ pub impl param_substs {\n     }\n }\n \n-fn param_substs_to_str(self: &param_substs,\n-                       tcx: ty::ctxt) -> ~str\n-{\n+fn param_substs_to_str(this: &param_substs, tcx: ty::ctxt) -> ~str {\n     fmt!(\"param_substs {tys:%s, vtables:%s, type_param_defs:%s}\",\n-         self.tys.repr(tcx),\n-         self.vtables.repr(tcx),\n-         self.type_param_defs.repr(tcx))\n+         this.tys.repr(tcx),\n+         this.vtables.repr(tcx),\n+         this.type_param_defs.repr(tcx))\n }\n \n impl Repr for param_substs {"}, {"sha": "59526ffbe498d43f2f3d32b54d61afe2ca3c5f2a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -451,7 +451,7 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     trace_span!(bcx, expr.span, @shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n-        ast::expr_path(_) => {\n+        ast::expr_path(_) | ast::expr_self => {\n             return trans_def_datum_unadjusted(bcx, expr, bcx.def(expr.id));\n         }\n         ast::expr_vstore(contents, ast::expr_vstore_box) |\n@@ -558,7 +558,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_paren(e) => {\n             return trans_rvalue_dps_unadjusted(bcx, e, dest);\n         }\n-        ast::expr_path(_) => {\n+        ast::expr_path(_) | ast::expr_self => {\n             return trans_def_dps_unadjusted(bcx, expr,\n                                             bcx.def(expr.id), dest);\n         }\n@@ -810,7 +810,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         ast::expr_paren(e) => {\n             trans_lvalue_unadjusted(bcx, e)\n         }\n-        ast::expr_path(_) => {\n+        ast::expr_path(_) | ast::expr_self => {\n             trans_def_lvalue(bcx, expr, bcx.def(expr.id))\n         }\n         ast::expr_field(base, ident, _) => {"}, {"sha": "02afbbdb11f7e1205fbc4e8c2b497f35657678d2", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -174,14 +174,15 @@ pub fn trans_self_arg(bcx: block,\n \n pub fn trans_method_callee(bcx: block,\n                            callee_id: ast::node_id,\n-                           self: @ast::expr,\n+                           this: @ast::expr,\n                            mentry: typeck::method_map_entry)\n-                        -> Callee {\n+                           -> Callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n     let tcx = bcx.tcx();\n \n-    debug!(\"trans_method_callee(callee_id=%?, self=%s, mentry=%s)\",\n-           callee_id, bcx.expr_to_str(self),\n+    debug!(\"trans_method_callee(callee_id=%?, this=%s, mentry=%s)\",\n+           callee_id,\n+           bcx.expr_to_str(this),\n            mentry.repr(bcx.tcx()));\n \n     // Replace method_self with method_static here.\n@@ -202,7 +203,7 @@ pub fn trans_method_callee(bcx: block,\n         }\n         typeck::method_super(trait_id, method_index) => {\n             // <self_ty> is the self type for this method call\n-            let self_ty = node_id_type(bcx, self.id);\n+            let self_ty = node_id_type(bcx, this.id);\n             // <impl_id> is the ID of the implementation of\n             // trait <trait_id> for type <self_ty>\n             let impl_id = ty::get_impl_id(tcx, trait_id, self_ty);\n@@ -232,13 +233,13 @@ pub fn trans_method_callee(bcx: block,\n     match origin {\n         typeck::method_static(did) => {\n             let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n-            let Result {bcx, val} = trans_self_arg(bcx, self, mentry);\n+            let Result {bcx, val} = trans_self_arg(bcx, this, mentry);\n             Callee {\n                 bcx: bcx,\n                 data: Method(MethodData {\n                     llfn: callee_fn.llfn,\n                     llself: val,\n-                    self_ty: node_id_type(bcx, self.id),\n+                    self_ty: node_id_type(bcx, this.id),\n                     self_mode: mentry.self_mode,\n                 })\n             }\n@@ -252,7 +253,7 @@ pub fn trans_method_callee(bcx: block,\n             match bcx.fcx.param_substs {\n                 Some(substs) => {\n                     let vtbl = find_vtable(bcx.tcx(), substs, p, b);\n-                    trans_monomorphized_callee(bcx, callee_id, self, mentry,\n+                    trans_monomorphized_callee(bcx, callee_id, this, mentry,\n                                                trait_id, off, vtbl)\n                 }\n                 // how to get rid of this?\n@@ -263,7 +264,7 @@ pub fn trans_method_callee(bcx: block,\n             trans_trait_callee(bcx,\n                                callee_id,\n                                off,\n-                               self,\n+                               this,\n                                store,\n                                mentry.explicit_self)\n         }"}, {"sha": "cd1b89d7ffa65a7bf9f2f7ce283a028756f66659", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -293,7 +293,7 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n           _ => ()\n         }\n       }\n-      expr_path(_) => {\n+      expr_path(_) | expr_self => {\n         let opt_ts = cx.ccx.tcx.node_type_substs.find_copy(&e.id);\n         for opt_ts.each |ts| {\n             let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get_copy(&e.id));"}, {"sha": "5eaa6478ecfb64c6c9bdf8bf5237c2765b3e0ee6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -3383,7 +3383,7 @@ pub fn expr_kind(tcx: ctxt,\n     }\n \n     match expr.node {\n-        ast::expr_path(*) => {\n+        ast::expr_path(*) | ast::expr_self => {\n             match resolve_expr(tcx, expr) {\n                 ast::def_variant(*) | ast::def_struct(*) => RvalueDpsExpr,\n "}, {"sha": "469e31d0c49cc2a02eca180665600f3a1cdb3d41", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -102,7 +102,7 @@ pub fn get_region_reporting_err(\n }\n \n pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + 'static>(\n-    self: &AC,\n+    this: &AC,\n     rscope: &RS,\n     default_span: span,\n     opt_lifetime: Option<@ast::Lifetime>) -> ty::Region\n@@ -111,7 +111,7 @@ pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + 'static>(\n         None => {\n             (default_span, rscope.anon_region(default_span))\n         }\n-        Some(ref lifetime) if lifetime.ident == special_idents::static => {\n+        Some(ref lifetime) if lifetime.ident == special_idents::statik => {\n             (lifetime.span, Ok(ty::re_static))\n         }\n         Some(ref lifetime) if lifetime.ident == special_idents::self_ => {\n@@ -123,11 +123,11 @@ pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + 'static>(\n         }\n     };\n \n-    get_region_reporting_err(self.tcx(), span, opt_lifetime, res)\n+    get_region_reporting_err(this.tcx(), span, opt_lifetime, res)\n }\n \n fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n-    self: &AC,\n+    this: &AC,\n     rscope: &RS,\n     def_id: ast::def_id,\n     decl_generics: &ty::Generics,\n@@ -141,9 +141,9 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n      * set of substitutions for this particular reference to `I`.\n      */\n \n-    let tcx = self.tcx();\n+    let tcx = this.tcx();\n \n-    // If the type is parameterized by the self region, then replace self\n+    // If the type is parameterized by the this region, then replace this\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n     let self_r = match (&decl_generics.region_param, &path.rp) {\n@@ -160,55 +160,55 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n       }\n       (&Some(_), &None) => {\n         let res = rscope.anon_region(path.span);\n-        let r = get_region_reporting_err(self.tcx(), path.span, None, res);\n+        let r = get_region_reporting_err(this.tcx(), path.span, None, res);\n         Some(r)\n       }\n       (&Some(_), &Some(_)) => {\n-        Some(ast_region_to_region(self, rscope, path.span, path.rp))\n+        Some(ast_region_to_region(this, rscope, path.span, path.rp))\n       }\n     };\n \n     // Convert the type parameters supplied by the user.\n     if !vec::same_length(*decl_generics.type_param_defs, path.types) {\n-        self.tcx().sess.span_fatal(\n+        this.tcx().sess.span_fatal(\n             path.span,\n             fmt!(\"wrong number of type arguments: expected %u but found %u\",\n                  decl_generics.type_param_defs.len(), path.types.len()));\n     }\n-    let tps = path.types.map(|a_t| ast_ty_to_ty(self, rscope, *a_t));\n+    let tps = path.types.map(|a_t| ast_ty_to_ty(this, rscope, *a_t));\n \n     substs {self_r:self_r, self_ty:self_ty, tps:tps}\n }\n \n pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n-    self: &AC,\n+    this: &AC,\n     rscope: &RS,\n     did: ast::def_id,\n     path: @ast::Path) -> ty_param_substs_and_ty\n {\n-    let tcx = self.tcx();\n+    let tcx = this.tcx();\n     let ty::ty_param_bounds_and_ty {\n         generics: generics,\n         ty: decl_ty\n-    } = self.get_item_ty(did);\n+    } = this.get_item_ty(did);\n \n-    let substs = ast_path_substs(self, rscope, did, &generics, None, path);\n+    let substs = ast_path_substs(this, rscope, did, &generics, None, path);\n     let ty = ty::subst(tcx, &substs, decl_ty);\n     ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n \n pub fn ast_path_to_trait_ref<AC:AstConv,RS:region_scope + Copy + 'static>(\n-    self: &AC,\n+    this: &AC,\n     rscope: &RS,\n     trait_def_id: ast::def_id,\n     self_ty: Option<ty::t>,\n     path: @ast::Path) -> @ty::TraitRef\n {\n     let trait_def =\n-        self.get_trait_def(trait_def_id);\n+        this.get_trait_def(trait_def_id);\n     let substs =\n         ast_path_substs(\n-            self,\n+            this,\n             rscope,\n             trait_def.trait_ref.def_id,\n             &trait_def.generics,\n@@ -222,7 +222,7 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:region_scope + Copy + 'static>(\n \n \n pub fn ast_path_to_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n-        self: &AC,\n+        this: &AC,\n         rscope: &RS,\n         did: ast::def_id,\n         path: @ast::Path)\n@@ -233,7 +233,7 @@ pub fn ast_path_to_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n     let ty::ty_param_substs_and_ty {\n         substs: substs,\n         ty: ty\n-    } = ast_path_to_substs_and_ty(self, rscope, did, path);\n+    } = ast_path_to_substs_and_ty(this, rscope, did, path);\n     ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n \n@@ -244,29 +244,29 @@ pub static NO_TPS: uint = 2;\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n-    self: &AC, rscope: &RS, ast_ty: @ast::Ty) -> ty::t {\n+    this: &AC, rscope: &RS, ast_ty: @ast::Ty) -> ty::t {\n \n     fn ast_mt_to_mt<AC:AstConv, RS:region_scope + Copy + 'static>(\n-        self: &AC, rscope: &RS, mt: &ast::mt) -> ty::mt {\n+        this: &AC, rscope: &RS, mt: &ast::mt) -> ty::mt {\n \n-        ty::mt {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl}\n+        ty::mt {ty: ast_ty_to_ty(this, rscope, mt.ty), mutbl: mt.mutbl}\n     }\n \n     // Handle @, ~, and & being able to mean estrs and evecs.\n     // If a_seq_ty is a str or a vec, make it an estr/evec.\n     // Also handle first-class trait types.\n     fn mk_pointer<AC:AstConv,RS:region_scope + Copy + 'static>(\n-        self: &AC,\n+        this: &AC,\n         rscope: &RS,\n         a_seq_ty: &ast::mt,\n         vst: ty::vstore,\n         constr: &fn(ty::mt) -> ty::t) -> ty::t\n     {\n-        let tcx = self.tcx();\n+        let tcx = this.tcx();\n \n         match a_seq_ty.ty.node {\n             ast::ty_vec(ref mt) => {\n-                let mut mt = ast_mt_to_mt(self, rscope, mt);\n+                let mut mt = ast_mt_to_mt(this, rscope, mt);\n                 if a_seq_ty.mutbl == ast::m_mutbl ||\n                         a_seq_ty.mutbl == ast::m_const {\n                     mt = ty::mt { ty: mt.ty, mutbl: a_seq_ty.mutbl };\n@@ -281,7 +281,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                     }\n                     Some(&ast::def_trait(trait_def_id)) => {\n                         let result = ast_path_to_trait_ref(\n-                            self, rscope, trait_def_id, None, path);\n+                            this, rscope, trait_def_id, None, path);\n                         let trait_store = match vst {\n                             ty::vstore_box => ty::BoxTraitStore,\n                             ty::vstore_uniq => ty::UniqTraitStore,\n@@ -308,7 +308,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n             _ => {}\n         }\n \n-        let seq_ty = ast_mt_to_mt(self, rscope, a_seq_ty);\n+        let seq_ty = ast_mt_to_mt(this, rscope, a_seq_ty);\n         return constr(seq_ty);\n     }\n \n@@ -332,7 +332,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n         }\n     }\n \n-    let tcx = self.tcx();\n+    let tcx = this.tcx();\n \n     match tcx.ast_ty_to_ty_cache.find(&ast_ty.id) {\n       Some(&ty::atttce_resolved(ty)) => return ty,\n@@ -348,36 +348,36 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n       ast::ty_nil => ty::mk_nil(),\n       ast::ty_bot => ty::mk_bot(),\n       ast::ty_box(ref mt) => {\n-        mk_pointer(self, rscope, mt, ty::vstore_box,\n+        mk_pointer(this, rscope, mt, ty::vstore_box,\n                    |tmt| ty::mk_box(tcx, tmt))\n       }\n       ast::ty_uniq(ref mt) => {\n-        mk_pointer(self, rscope, mt, ty::vstore_uniq,\n+        mk_pointer(this, rscope, mt, ty::vstore_uniq,\n                    |tmt| ty::mk_uniq(tcx, tmt))\n       }\n       ast::ty_vec(ref mt) => {\n         tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n         // return /something/ so they can at least get more errors\n-        ty::mk_evec(tcx, ast_mt_to_mt(self, rscope, mt), ty::vstore_uniq)\n+        ty::mk_evec(tcx, ast_mt_to_mt(this, rscope, mt), ty::vstore_uniq)\n       }\n       ast::ty_ptr(ref mt) => {\n-        ty::mk_ptr(tcx, ast_mt_to_mt(self, rscope, mt))\n+        ty::mk_ptr(tcx, ast_mt_to_mt(this, rscope, mt))\n       }\n       ast::ty_rptr(region, ref mt) => {\n-        let r = ast_region_to_region(self, rscope, ast_ty.span, region);\n-        mk_pointer(self, rscope, mt, ty::vstore_slice(r),\n+        let r = ast_region_to_region(this, rscope, ast_ty.span, region);\n+        mk_pointer(this, rscope, mt, ty::vstore_slice(r),\n                    |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n       ast::ty_tup(ref fields) => {\n-        let flds = fields.map(|t| ast_ty_to_ty(self, rscope, *t));\n+        let flds = fields.map(|t| ast_ty_to_ty(this, rscope, *t));\n         ty::mk_tup(tcx, flds)\n       }\n       ast::ty_bare_fn(ref bf) => {\n-          ty::mk_bare_fn(tcx, ty_of_bare_fn(self, rscope, bf.purity,\n+          ty::mk_bare_fn(tcx, ty_of_bare_fn(this, rscope, bf.purity,\n                                             bf.abis, &bf.lifetimes, &bf.decl))\n       }\n       ast::ty_closure(ref f) => {\n-          let fn_decl = ty_of_closure(self,\n+          let fn_decl = ty_of_closure(this,\n                                       rscope,\n                                       f.sigil,\n                                       f.purity,\n@@ -407,7 +407,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n               ty::mk_err()\n           }\n           ast::def_ty(did) | ast::def_struct(did) => {\n-            ast_path_to_ty(self, rscope, did, path).ty\n+            ast_path_to_ty(this, rscope, did, path).ty\n           }\n           ast::def_prim_ty(nty) => {\n             match nty {\n@@ -440,7 +440,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n             ty::mk_param(tcx, n, id)\n           }\n           ast::def_self_ty(id) => {\n-            // n.b.: resolve guarantees that the self type only appears in a\n+            // n.b.: resolve guarantees that the this type only appears in a\n             // trait, which we rely upon in various places when creating\n             // substs\n             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n@@ -458,10 +458,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n           Ok(ref r) => {\n             match *r {\n               const_eval::const_int(i) =>\n-                ty::mk_evec(tcx, ast_mt_to_mt(self, rscope, a_mt),\n+                ty::mk_evec(tcx, ast_mt_to_mt(this, rscope, a_mt),\n                             ty::vstore_fixed(i as uint)),\n               const_eval::const_uint(i) =>\n-                ty::mk_evec(tcx, ast_mt_to_mt(self, rscope, a_mt),\n+                ty::mk_evec(tcx, ast_mt_to_mt(this, rscope, a_mt),\n                             ty::vstore_fixed(i as uint)),\n               _ => {\n                 tcx.sess.span_fatal(\n@@ -482,7 +482,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n         // values in a fn_expr, or as the type of local variables.  Both of\n         // these cases are handled specially and should not descend into this\n         // routine.\n-        self.tcx().sess.span_bug(\n+        this.tcx().sess.span_bug(\n             ast_ty.span,\n             \"found `ty_infer` in unexpected place\");\n       }\n@@ -498,15 +498,15 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n \n pub fn ty_of_arg<AC:AstConv,\n                  RS:region_scope + Copy + 'static>(\n-                 self: &AC,\n+                 this: &AC,\n                  rscope: &RS,\n                  a: ast::arg,\n                  expected_ty: Option<ty::arg>)\n                  -> ty::arg {\n     let ty = match a.ty.node {\n         ast::ty_infer if expected_ty.is_some() => expected_ty.get().ty,\n-        ast::ty_infer => self.ty_infer(a.ty.span),\n-        _ => ast_ty_to_ty(self, rscope, a.ty),\n+        ast::ty_infer => this.ty_infer(a.ty.span),\n+        _ => ast_ty_to_ty(this, rscope, a.ty),\n     };\n \n     arg {\n@@ -515,28 +515,28 @@ pub fn ty_of_arg<AC:AstConv,\n }\n \n pub fn bound_lifetimes<AC:AstConv>(\n-    self: &AC,\n+    this: &AC,\n     ast_lifetimes: &OptVec<ast::Lifetime>) -> OptVec<ast::ident>\n {\n     /*!\n      *\n      * Converts a list of lifetimes into a list of bound identifier\n-     * names.  Does not permit special names like 'static or 'self to\n+     * names.  Does not permit special names like 'static or 'this to\n      * be bound.  Note that this function is for use in closures,\n-     * methods, and fn definitions.  It is legal to bind 'self in a\n+     * methods, and fn definitions.  It is legal to bind 'this in a\n      * type.  Eventually this distinction should go away and the same\n-     * rules should apply everywhere ('self would not be a special name\n+     * rules should apply everywhere ('this would not be a special name\n      * at that point).\n      */\n \n-    let special_idents = [special_idents::static, special_idents::self_];\n+    let special_idents = [special_idents::statik, special_idents::self_];\n     let mut bound_lifetime_names = opt_vec::Empty;\n     ast_lifetimes.map_to_vec(|ast_lifetime| {\n         if special_idents.any(|&i| i == ast_lifetime.ident) {\n-            self.tcx().sess.span_err(\n+            this.tcx().sess.span_err(\n                 ast_lifetime.span,\n                 fmt!(\"illegal lifetime parameter name: `%s`\",\n-                     lifetime_to_str(ast_lifetime, self.tcx().sess.intr())));\n+                     lifetime_to_str(ast_lifetime, this.tcx().sess.intr())));\n         } else {\n             bound_lifetime_names.push(ast_lifetime.ident);\n         }\n@@ -550,7 +550,7 @@ struct SelfInfo {\n }\n \n pub fn ty_of_method<AC:AstConv,RS:region_scope + Copy + 'static>(\n-    self: &AC,\n+    this: &AC,\n     rscope: &RS,\n     purity: ast::purity,\n     lifetimes: &OptVec<ast::Lifetime>,\n@@ -563,25 +563,25 @@ pub fn ty_of_method<AC:AstConv,RS:region_scope + Copy + 'static>(\n         self_transform: self_transform\n     };\n     let (a, b) = ty_of_method_or_bare_fn(\n-        self, rscope, purity, AbiSet::Rust(), lifetimes, Some(&self_info), decl);\n+        this, rscope, purity, AbiSet::Rust(), lifetimes, Some(&self_info), decl);\n     (a.get(), b)\n }\n \n pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n-    self: &AC,\n+    this: &AC,\n     rscope: &RS,\n     purity: ast::purity,\n     abi: AbiSet,\n     lifetimes: &OptVec<ast::Lifetime>,\n     decl: &ast::fn_decl) -> ty::BareFnTy\n {\n     let (_, b) = ty_of_method_or_bare_fn(\n-        self, rscope, purity, abi, lifetimes, None, decl);\n+        this, rscope, purity, abi, lifetimes, None, decl);\n     b\n }\n \n fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n-    self: &AC,\n+    this: &AC,\n     rscope: &RS,\n     purity: ast::purity,\n     abi: AbiSet,\n@@ -593,18 +593,18 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n-    let bound_lifetime_names = bound_lifetimes(self, lifetimes);\n+    let bound_lifetime_names = bound_lifetimes(this, lifetimes);\n     let rb = in_binding_rscope(rscope, RegionParamNames(copy bound_lifetime_names));\n \n     let opt_transformed_self_ty = opt_self_info.map(|&self_info| {\n-        transform_self_ty(self, &rb, self_info)\n+        transform_self_ty(this, &rb, self_info)\n     });\n \n-    let input_tys = decl.inputs.map(|a| ty_of_arg(self, &rb, *a, None));\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(this, &rb, *a, None));\n \n     let output_ty = match decl.output.node {\n-        ast::ty_infer => self.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(self, &rb, decl.output)\n+        ast::ty_infer => this.ty_infer(decl.output.span),\n+        _ => ast_ty_to_ty(this, &rb, decl.output)\n     };\n \n     return (opt_transformed_self_ty,\n@@ -617,7 +617,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n             });\n \n     fn transform_self_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n-        self: &AC,\n+        this: &AC,\n         rscope: &RS,\n         self_info: &SelfInfo) -> Option<ty::t>\n     {\n@@ -628,20 +628,20 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n             }\n             ast::sty_region(lifetime, mutability) => {\n                 let region =\n-                    ast_region_to_region(self, rscope,\n+                    ast_region_to_region(this, rscope,\n                                          self_info.self_transform.span,\n                                          lifetime);\n-                Some(ty::mk_rptr(self.tcx(), region,\n+                Some(ty::mk_rptr(this.tcx(), region,\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: mutability}))\n             }\n             ast::sty_box(mutability) => {\n-                Some(ty::mk_box(self.tcx(),\n+                Some(ty::mk_box(this.tcx(),\n                                 ty::mt {ty: self_info.untransformed_self_ty,\n                                         mutbl: mutability}))\n             }\n             ast::sty_uniq(mutability) => {\n-                Some(ty::mk_uniq(self.tcx(),\n+                Some(ty::mk_uniq(this.tcx(),\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: mutability}))\n             }\n@@ -650,7 +650,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n }\n \n pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n-        self: &AC,\n+        this: &AC,\n         rscope: &RS,\n         sigil: ast::Sigil,\n         purity: ast::purity,\n@@ -674,7 +674,7 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n     // scope `rscope`, not the scope of the function parameters\n     let bound_region = match opt_lifetime {\n         Some(_) => {\n-            ast_region_to_region(self, rscope, span, opt_lifetime)\n+            ast_region_to_region(this, rscope, span, opt_lifetime)\n         }\n         None => {\n             match sigil {\n@@ -685,15 +685,15 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n                 }\n                 ast::BorrowedSigil => {\n                     // &fn() defaults as normal for an omitted lifetime:\n-                    ast_region_to_region(self, rscope, span, opt_lifetime)\n+                    ast_region_to_region(this, rscope, span, opt_lifetime)\n                 }\n             }\n         }\n     };\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n-    let bound_lifetime_names = bound_lifetimes(self, lifetimes);\n+    let bound_lifetime_names = bound_lifetimes(this, lifetimes);\n     let rb = in_binding_rscope(rscope, RegionParamNames(copy bound_lifetime_names));\n \n     let input_tys = do decl.inputs.mapi |i, a| {\n@@ -702,14 +702,14 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n             // were supplied\n             if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n         };\n-        ty_of_arg(self, &rb, *a, expected_arg_ty)\n+        ty_of_arg(this, &rb, *a, expected_arg_ty)\n     };\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n     let output_ty = match decl.output.node {\n         ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.get(),\n-        ast::ty_infer => self.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(self, &rb, decl.output)\n+        ast::ty_infer => this.ty_infer(decl.output.span),\n+        _ => ast_ty_to_ty(this, &rb, decl.output)\n     };\n \n     ty::ClosureTy {"}, {"sha": "498e5c9d2007dd9fc1414b28f023fc66997fe094", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -2391,6 +2391,12 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n         instantiate_path(fcx, pth, tpt, expr.span, expr.id);\n       }\n+      ast::expr_self => {\n+        let definition = lookup_def(fcx, expr.span, id);\n+        let ty_param_bounds_and_ty =\n+            ty_param_bounds_and_ty_for_def(fcx, expr.span, definition);\n+        fcx.write_ty(id, ty_param_bounds_and_ty.ty);\n+      }\n       ast::expr_inline_asm(ref ia) => {\n           fcx.require_unsafe(expr.span, ~\"use of inline assembly\");\n "}, {"sha": "ecec07ec51287de3476977c599269379b9c2215b", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -993,7 +993,7 @@ pub mod guarantor {\n                 guarantor(rcx, e)\n             }\n \n-            ast::expr_path(*) => {\n+            ast::expr_path(*) | ast::expr_self => {\n                 // Either a variable or constant and hence resides\n                 // in constant memory or on the stack frame.  Either way,\n                 // not guaranteed by a region pointer."}, {"sha": "03601a716c020ed3f659c564fdafd7293fba3b59", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -370,7 +370,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                           });\n     }\n \n-    fn ty_method_of_trait_method(self: &CrateCtxt,\n+    fn ty_method_of_trait_method(this: &CrateCtxt,\n                                  trait_id: ast::node_id,\n                                  trait_rp: Option<ty::region_variance>,\n                                  trait_generics: &ast::Generics,\n@@ -381,15 +381,15 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                  m_purity: &ast::purity,\n                                  m_decl: &ast::fn_decl) -> ty::method\n     {\n-        let trait_self_ty = ty::mk_self(self.tcx, local_def(trait_id));\n+        let trait_self_ty = ty::mk_self(this.tcx, local_def(trait_id));\n         let rscope = MethodRscope::new(m_self_ty.node, trait_rp, trait_generics);\n         let (transformed_self_ty, fty) =\n-            astconv::ty_of_method(self, &rscope, *m_purity, &m_generics.lifetimes,\n+            astconv::ty_of_method(this, &rscope, *m_purity, &m_generics.lifetimes,\n                                   trait_self_ty, *m_self_ty, m_decl);\n         let num_trait_type_params = trait_generics.ty_params.len();\n         ty::method {\n             ident: *m_ident,\n-            generics: ty_generics(self, None, m_generics, num_trait_type_params),\n+            generics: ty_generics(this, None, m_generics, num_trait_type_params),\n             transformed_self_ty: transformed_self_ty,\n             fty: fty,\n             self_ty: m_self_ty.node,"}, {"sha": "a845d6fe9d0fd76b04f1154a6346a86a44341948", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 103, "deletions": 103, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -120,31 +120,31 @@ pub struct CombineFields {\n }\n \n pub fn expected_found<C:Combine,T>(\n-        self: &C, a: T, b: T) -> ty::expected_found<T> {\n-    if self.a_is_expected() {\n+        this: &C, a: T, b: T) -> ty::expected_found<T> {\n+    if this.a_is_expected() {\n         ty::expected_found {expected: a, found: b}\n     } else {\n         ty::expected_found {expected: b, found: a}\n     }\n }\n \n-pub fn eq_tys<C:Combine>(self: &C, a: ty::t, b: ty::t) -> ures {\n-    let suber = self.sub();\n-    do self.infcx().try {\n+pub fn eq_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> ures {\n+    let suber = this.sub();\n+    do this.infcx().try {\n         do suber.tys(a, b).chain |_ok| {\n             suber.contratys(a, b)\n         }.to_ures()\n     }\n }\n \n-pub fn eq_regions<C:Combine>(self: &C, a: ty::Region, b: ty::Region)\n+pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n                           -> ures {\n     debug!(\"eq_regions(%s, %s)\",\n-           a.inf_str(self.infcx()),\n-           b.inf_str(self.infcx()));\n-    let sub = self.sub();\n+           a.inf_str(this.infcx()),\n+           b.inf_str(this.infcx()));\n+    let sub = this.sub();\n     do indent {\n-        self.infcx().try(|| {\n+        this.infcx().try(|| {\n             do sub.regions(a, b).chain |_r| {\n                 sub.contraregions(a, b)\n             }\n@@ -161,7 +161,7 @@ pub fn eq_regions<C:Combine>(self: &C, a: ty::Region, b: ty::Region)\n }\n \n pub fn eq_opt_regions<C:Combine>(\n-    self: &C,\n+    this: &C,\n     a: Option<ty::Region>,\n     b: Option<ty::Region>) -> cres<Option<ty::Region>> {\n \n@@ -170,7 +170,7 @@ pub fn eq_opt_regions<C:Combine>(\n         Ok(None)\n       }\n       (Some(a), Some(b)) => {\n-        do eq_regions(self, a, b).then {\n+        do eq_regions(this, a, b).then {\n             Ok(Some(a))\n         }\n       }\n@@ -179,21 +179,21 @@ pub fn eq_opt_regions<C:Combine>(\n         // they should be), then the type should either\n         // consistently have a region parameter or not have a\n         // region parameter.\n-        self.infcx().tcx.sess.bug(\n+        this.infcx().tcx.sess.bug(\n             fmt!(\"substitution a had opt_region %s and \\\n                   b had opt_region %s\",\n-                 a.inf_str(self.infcx()),\n-                 b.inf_str(self.infcx())));\n+                 a.inf_str(this.infcx()),\n+                 b.inf_str(this.infcx())));\n       }\n     }\n }\n \n pub fn super_substs<C:Combine>(\n-    self: &C, generics: &ty::Generics,\n+    this: &C, generics: &ty::Generics,\n     a: &ty::substs, b: &ty::substs) -> cres<ty::substs> {\n \n     fn relate_region_param<C:Combine>(\n-        self: &C,\n+        this: &C,\n         generics: &ty::Generics,\n         a: Option<ty::Region>,\n         b: Option<ty::Region>)\n@@ -204,17 +204,17 @@ pub fn super_substs<C:Combine>(\n             Ok(None)\n           }\n           (&Some(ty::rv_invariant), &Some(a), &Some(b)) => {\n-            do eq_regions(self, a, b).then {\n+            do eq_regions(this, a, b).then {\n                 Ok(Some(a))\n             }\n           }\n           (&Some(ty::rv_covariant), &Some(a), &Some(b)) => {\n-            do self.regions(a, b).chain |r| {\n+            do this.regions(a, b).chain |r| {\n                 Ok(Some(r))\n             }\n           }\n           (&Some(ty::rv_contravariant), &Some(a), &Some(b)) => {\n-            do self.contraregions(a, b).chain |r| {\n+            do this.contraregions(a, b).chain |r| {\n                 Ok(Some(r))\n             }\n           }\n@@ -224,19 +224,19 @@ pub fn super_substs<C:Combine>(\n             // consistently have a region parameter or not have a\n             // region parameter, and that should match with the\n             // polytype.\n-            self.infcx().tcx.sess.bug(\n+            this.infcx().tcx.sess.bug(\n                 fmt!(\"substitution a had opt_region %s and \\\n                       b had opt_region %s with variance %?\",\n-                      a.inf_str(self.infcx()),\n-                      b.inf_str(self.infcx()),\n+                      a.inf_str(this.infcx()),\n+                      b.inf_str(this.infcx()),\n                      generics.region_param));\n           }\n         }\n     }\n \n-    do self.tps(a.tps, b.tps).chain |tps| {\n-        do self.self_tys(a.self_ty, b.self_ty).chain |self_ty| {\n-            do relate_region_param(self, generics,\n+    do this.tps(a.tps, b.tps).chain |tps| {\n+        do this.self_tys(a.self_ty, b.self_ty).chain |self_ty| {\n+            do relate_region_param(this, generics,\n                                    a.self_r, b.self_r).chain |self_r|\n             {\n                 Ok(substs {\n@@ -250,7 +250,7 @@ pub fn super_substs<C:Combine>(\n }\n \n pub fn super_tps<C:Combine>(\n-    self: &C, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n+    this: &C, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n \n     // Note: type parameters are always treated as *invariant*\n     // (otherwise the type system would be unsound).  In the\n@@ -259,25 +259,25 @@ pub fn super_tps<C:Combine>(\n \n     if vec::same_length(as_, bs) {\n         iter_vec2(as_, bs, |a, b| {\n-            eq_tys(self, *a, *b)\n+            eq_tys(this, *a, *b)\n         }).then(|| Ok(as_.to_vec()) )\n     } else {\n         Err(ty::terr_ty_param_size(\n-            expected_found(self, as_.len(), bs.len())))\n+            expected_found(this, as_.len(), bs.len())))\n     }\n }\n \n pub fn super_self_tys<C:Combine>(\n-    self: &C, a: Option<ty::t>, b: Option<ty::t>) -> cres<Option<ty::t>> {\n+    this: &C, a: Option<ty::t>, b: Option<ty::t>) -> cres<Option<ty::t>> {\n \n     match (a, b) {\n       (None, None) => {\n         Ok(None)\n       }\n       (Some(a), Some(b)) => {\n           // FIXME(#5781) this should be eq_tys\n-          // eq_tys(self, a, b).then(|| Ok(Some(a)) )\n-          self.contratys(a, b).chain(|t| Ok(Some(t)))\n+          // eq_tys(this, a, b).then(|| Ok(Some(a)) )\n+          this.contratys(a, b).chain(|t| Ok(Some(t)))\n       }\n       (None, Some(_)) |\n       (Some(_), None) => {\n@@ -290,46 +290,46 @@ pub fn super_self_tys<C:Combine>(\n }\n \n pub fn super_sigils<C:Combine>(\n-    self: &C, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n+    this: &C, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n     if p1 == p2 {\n         Ok(p1)\n     } else {\n-        Err(ty::terr_sigil_mismatch(expected_found(self, p1, p2)))\n+        Err(ty::terr_sigil_mismatch(expected_found(this, p1, p2)))\n     }\n }\n \n pub fn super_flds<C:Combine>(\n-    self: &C, a: ty::field, b: ty::field) -> cres<ty::field> {\n+    this: &C, a: ty::field, b: ty::field) -> cres<ty::field> {\n \n     if a.ident == b.ident {\n-        self.mts(&a.mt, &b.mt)\n+        this.mts(&a.mt, &b.mt)\n             .chain(|mt| Ok(ty::field {ident: a.ident, mt: mt}) )\n             .chain_err(|e| Err(ty::terr_in_field(@e, a.ident)) )\n     } else {\n         Err(ty::terr_record_fields(\n-            expected_found(self, a.ident, b.ident)))\n+            expected_found(this, a.ident, b.ident)))\n     }\n }\n \n-pub fn super_args<C:Combine>(self: &C, a: ty::arg, b: ty::arg)\n+pub fn super_args<C:Combine>(this: &C, a: ty::arg, b: ty::arg)\n                              -> cres<ty::arg> {\n-    do self.contratys(a.ty, b.ty).chain |t| {\n+    do this.contratys(a.ty, b.ty).chain |t| {\n         Ok(arg {\n             ty: t\n         })\n     }\n }\n \n-pub fn super_vstores<C:Combine>(self: &C,\n+pub fn super_vstores<C:Combine>(this: &C,\n                                 vk: ty::terr_vstore_kind,\n                                 a: ty::vstore,\n                                 b: ty::vstore)\n                                 -> cres<ty::vstore> {\n-    debug!(\"%s.super_vstores(a=%?, b=%?)\", self.tag(), a, b);\n+    debug!(\"%s.super_vstores(a=%?, b=%?)\", this.tag(), a, b);\n \n     match (a, b) {\n       (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) => {\n-        do self.contraregions(a_r, b_r).chain |r| {\n+        do this.contraregions(a_r, b_r).chain |r| {\n             Ok(ty::vstore_slice(r))\n         }\n       }\n@@ -339,21 +339,21 @@ pub fn super_vstores<C:Combine>(self: &C,\n       }\n \n       _ => {\n-        Err(ty::terr_vstores_differ(vk, expected_found(self, a, b)))\n+        Err(ty::terr_vstores_differ(vk, expected_found(this, a, b)))\n       }\n     }\n }\n \n-pub fn super_trait_stores<C:Combine>(self: &C,\n+pub fn super_trait_stores<C:Combine>(this: &C,\n                                      vk: ty::terr_vstore_kind,\n                                      a: ty::TraitStore,\n                                      b: ty::TraitStore)\n                                   -> cres<ty::TraitStore> {\n-    debug!(\"%s.super_vstores(a=%?, b=%?)\", self.tag(), a, b);\n+    debug!(\"%s.super_vstores(a=%?, b=%?)\", this.tag(), a, b);\n \n     match (a, b) {\n       (ty::RegionTraitStore(a_r), ty::RegionTraitStore(b_r)) => {\n-        do self.contraregions(a_r, b_r).chain |r| {\n+        do this.contraregions(a_r, b_r).chain |r| {\n             Ok(ty::RegionTraitStore(r))\n         }\n       }\n@@ -363,19 +363,19 @@ pub fn super_trait_stores<C:Combine>(self: &C,\n       }\n \n       _ => {\n-        Err(ty::terr_trait_stores_differ(vk, expected_found(self, a, b)))\n+        Err(ty::terr_trait_stores_differ(vk, expected_found(this, a, b)))\n       }\n     }\n }\n \n pub fn super_closure_tys<C:Combine>(\n-    self: &C, a_f: &ty::ClosureTy, b_f: &ty::ClosureTy) -> cres<ty::ClosureTy>\n+    this: &C, a_f: &ty::ClosureTy, b_f: &ty::ClosureTy) -> cres<ty::ClosureTy>\n {\n-    let p = if_ok!(self.sigils(a_f.sigil, b_f.sigil));\n-    let r = if_ok!(self.contraregions(a_f.region, b_f.region));\n-    let purity = if_ok!(self.purities(a_f.purity, b_f.purity));\n-    let onceness = if_ok!(self.oncenesses(a_f.onceness, b_f.onceness));\n-    let sig = if_ok!(self.fn_sigs(&a_f.sig, &b_f.sig));\n+    let p = if_ok!(this.sigils(a_f.sigil, b_f.sigil));\n+    let r = if_ok!(this.contraregions(a_f.region, b_f.region));\n+    let purity = if_ok!(this.purities(a_f.purity, b_f.purity));\n+    let onceness = if_ok!(this.oncenesses(a_f.onceness, b_f.onceness));\n+    let sig = if_ok!(this.fn_sigs(&a_f.sig, &b_f.sig));\n     Ok(ty::ClosureTy {purity: purity,\n                       sigil: p,\n                       onceness: onceness,\n@@ -384,43 +384,43 @@ pub fn super_closure_tys<C:Combine>(\n }\n \n pub fn super_abis<C:Combine>(\n-    self: &C, a: AbiSet, b: AbiSet) -> cres<AbiSet>\n+    this: &C, a: AbiSet, b: AbiSet) -> cres<AbiSet>\n {\n     if a == b {\n         Ok(a)\n     } else {\n-        Err(ty::terr_abi_mismatch(expected_found(self, a, b)))\n+        Err(ty::terr_abi_mismatch(expected_found(this, a, b)))\n     }\n }\n \n pub fn super_bare_fn_tys<C:Combine>(\n-    self: &C, a_f: &ty::BareFnTy, b_f: &ty::BareFnTy) -> cres<ty::BareFnTy>\n+    this: &C, a_f: &ty::BareFnTy, b_f: &ty::BareFnTy) -> cres<ty::BareFnTy>\n {\n-    let purity = if_ok!(self.purities(a_f.purity, b_f.purity));\n-    let abi = if_ok!(self.abis(a_f.abis, b_f.abis));\n-    let sig = if_ok!(self.fn_sigs(&a_f.sig, &b_f.sig));\n+    let purity = if_ok!(this.purities(a_f.purity, b_f.purity));\n+    let abi = if_ok!(this.abis(a_f.abis, b_f.abis));\n+    let sig = if_ok!(this.fn_sigs(&a_f.sig, &b_f.sig));\n     Ok(ty::BareFnTy {purity: purity,\n                      abis: abi,\n                      sig: sig})\n }\n \n pub fn super_fn_sigs<C:Combine>(\n-    self: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig>\n+    this: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig>\n {\n-    fn argvecs<C:Combine>(self: &C,\n+    fn argvecs<C:Combine>(this: &C,\n                           a_args: &[ty::arg],\n                           b_args: &[ty::arg]) -> cres<~[ty::arg]>\n     {\n         if vec::same_length(a_args, b_args) {\n-            map_vec2(a_args, b_args, |a, b| self.args(*a, *b))\n+            map_vec2(a_args, b_args, |a, b| this.args(*a, *b))\n         } else {\n             Err(ty::terr_arg_count)\n         }\n     }\n \n-    do argvecs(self, a_f.inputs, b_f.inputs)\n+    do argvecs(this, a_f.inputs, b_f.inputs)\n             .chain |inputs| {\n-        do self.tys(a_f.output, b_f.output).chain |output| {\n+        do this.tys(a_f.output, b_f.output).chain |output| {\n             Ok(FnSig {bound_lifetime_names: opt_vec::Empty, // FIXME(#4846)\n                       inputs: /*bad*/copy inputs,\n                       output: output})\n@@ -429,8 +429,8 @@ pub fn super_fn_sigs<C:Combine>(\n }\n \n pub fn super_tys<C:Combine>(\n-    self: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n-    let tcx = self.infcx().tcx;\n+    this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n+    let tcx = this.infcx().tcx;\n     return match (/*bad*/copy ty::get(a).sty, /*bad*/copy ty::get(b).sty) {\n       // The \"subtype\" ought to be handling cases involving bot or var:\n       (ty::ty_bot, _) |\n@@ -439,45 +439,45 @@ pub fn super_tys<C:Combine>(\n       (_, ty::ty_infer(TyVar(_))) => {\n         tcx.sess.bug(\n             fmt!(\"%s: bot and var types should have been handled (%s,%s)\",\n-                 self.tag(),\n-                 a.inf_str(self.infcx()),\n-                 b.inf_str(self.infcx())));\n+                 this.tag(),\n+                 a.inf_str(this.infcx()),\n+                 b.inf_str(this.infcx())));\n       }\n \n         // Relate integral variables to other types\n         (ty::ty_infer(IntVar(a_id)), ty::ty_infer(IntVar(b_id))) => {\n-            if_ok!(self.infcx().simple_vars(self.a_is_expected(),\n+            if_ok!(this.infcx().simple_vars(this.a_is_expected(),\n                                             a_id, b_id));\n             Ok(a)\n         }\n         (ty::ty_infer(IntVar(v_id)), ty::ty_int(v)) => {\n-            unify_integral_variable(self, self.a_is_expected(),\n+            unify_integral_variable(this, this.a_is_expected(),\n                                     v_id, IntType(v))\n         }\n         (ty::ty_int(v), ty::ty_infer(IntVar(v_id))) => {\n-            unify_integral_variable(self, !self.a_is_expected(),\n+            unify_integral_variable(this, !this.a_is_expected(),\n                                     v_id, IntType(v))\n         }\n         (ty::ty_infer(IntVar(v_id)), ty::ty_uint(v)) => {\n-            unify_integral_variable(self, self.a_is_expected(),\n+            unify_integral_variable(this, this.a_is_expected(),\n                                     v_id, UintType(v))\n         }\n         (ty::ty_uint(v), ty::ty_infer(IntVar(v_id))) => {\n-            unify_integral_variable(self, !self.a_is_expected(),\n+            unify_integral_variable(this, !this.a_is_expected(),\n                                     v_id, UintType(v))\n         }\n \n         // Relate floating-point variables to other types\n         (ty::ty_infer(FloatVar(a_id)), ty::ty_infer(FloatVar(b_id))) => {\n-            if_ok!(self.infcx().simple_vars(self.a_is_expected(),\n+            if_ok!(this.infcx().simple_vars(this.a_is_expected(),\n                                             a_id, b_id));\n             Ok(a)\n         }\n         (ty::ty_infer(FloatVar(v_id)), ty::ty_float(v)) => {\n-            unify_float_variable(self, self.a_is_expected(), v_id, v)\n+            unify_float_variable(this, this.a_is_expected(), v_id, v)\n         }\n         (ty::ty_float(v), ty::ty_infer(FloatVar(v_id))) => {\n-            unify_float_variable(self, !self.a_is_expected(), v_id, v)\n+            unify_float_variable(this, !this.a_is_expected(), v_id, v)\n         }\n \n       (ty::ty_nil, _) |\n@@ -488,7 +488,7 @@ pub fn super_tys<C:Combine>(\n         if ty::get(a).sty == ty::get(b).sty {\n             Ok(a)\n         } else {\n-            Err(ty::terr_sorts(expected_found(self, a, b)))\n+            Err(ty::terr_sorts(expected_found(this, a, b)))\n         }\n       }\n \n@@ -500,7 +500,7 @@ pub fn super_tys<C:Combine>(\n        ty::ty_enum(b_id, ref b_substs))\n       if a_id == b_id => {\n           let type_def = ty::lookup_item_type(tcx, a_id);\n-          do self.substs(&type_def.generics, a_substs, b_substs).chain |substs| {\n+          do this.substs(&type_def.generics, a_substs, b_substs).chain |substs| {\n               Ok(ty::mk_enum(tcx, a_id, substs))\n           }\n       }\n@@ -509,8 +509,8 @@ pub fn super_tys<C:Combine>(\n        ty::ty_trait(b_id, ref b_substs, b_store, b_mutbl))\n       if a_id == b_id && a_mutbl == b_mutbl => {\n           let trait_def = ty::lookup_trait_def(tcx, a_id);\n-          do self.substs(&trait_def.generics, a_substs, b_substs).chain |substs| {\n-              do self.trait_stores(ty::terr_trait, a_store, b_store).chain |s| {\n+          do this.substs(&trait_def.generics, a_substs, b_substs).chain |substs| {\n+              do this.trait_stores(ty::terr_trait, a_store, b_store).chain |s| {\n                   Ok(ty::mk_trait(tcx, a_id, /*bad*/copy substs, s, a_mutbl))\n               }\n           }\n@@ -519,84 +519,84 @@ pub fn super_tys<C:Combine>(\n       (ty::ty_struct(a_id, ref a_substs), ty::ty_struct(b_id, ref b_substs))\n       if a_id == b_id => {\n           let type_def = ty::lookup_item_type(tcx, a_id);\n-          do self.substs(&type_def.generics, a_substs, b_substs).chain |substs| {\n+          do this.substs(&type_def.generics, a_substs, b_substs).chain |substs| {\n               Ok(ty::mk_struct(tcx, a_id, substs))\n           }\n       }\n \n       (ty::ty_box(ref a_mt), ty::ty_box(ref b_mt)) => {\n-        do self.mts(a_mt, b_mt).chain |mt| {\n+        do this.mts(a_mt, b_mt).chain |mt| {\n             Ok(ty::mk_box(tcx, mt))\n         }\n       }\n \n       (ty::ty_uniq(ref a_mt), ty::ty_uniq(ref b_mt)) => {\n-        do self.mts(a_mt, b_mt).chain |mt| {\n+        do this.mts(a_mt, b_mt).chain |mt| {\n             Ok(ty::mk_uniq(tcx, mt))\n         }\n       }\n \n       (ty::ty_ptr(ref a_mt), ty::ty_ptr(ref b_mt)) => {\n-        do self.mts(a_mt, b_mt).chain |mt| {\n+        do this.mts(a_mt, b_mt).chain |mt| {\n             Ok(ty::mk_ptr(tcx, mt))\n         }\n       }\n \n       (ty::ty_rptr(a_r, ref a_mt), ty::ty_rptr(b_r, ref b_mt)) => {\n-          let r = if_ok!(self.contraregions(a_r, b_r));\n-          let mt = if_ok!(self.mts(a_mt, b_mt));\n+          let r = if_ok!(this.contraregions(a_r, b_r));\n+          let mt = if_ok!(this.mts(a_mt, b_mt));\n           Ok(ty::mk_rptr(tcx, r, mt))\n       }\n \n       (ty::ty_evec(ref a_mt, vs_a), ty::ty_evec(ref b_mt, vs_b)) => {\n-        do self.mts(a_mt, b_mt).chain |mt| {\n-            do self.vstores(ty::terr_vec, vs_a, vs_b).chain |vs| {\n+        do this.mts(a_mt, b_mt).chain |mt| {\n+            do this.vstores(ty::terr_vec, vs_a, vs_b).chain |vs| {\n                 Ok(ty::mk_evec(tcx, mt, vs))\n             }\n         }\n       }\n \n       (ty::ty_estr(vs_a), ty::ty_estr(vs_b)) => {\n-        do self.vstores(ty::terr_str, vs_a, vs_b).chain |vs| {\n+        do this.vstores(ty::terr_str, vs_a, vs_b).chain |vs| {\n             Ok(ty::mk_estr(tcx,vs))\n         }\n       }\n \n       (ty::ty_tup(ref as_), ty::ty_tup(ref bs)) => {\n         if as_.len() == bs.len() {\n-            map_vec2(*as_, *bs, |a, b| self.tys(*a, *b) )\n+            map_vec2(*as_, *bs, |a, b| this.tys(*a, *b) )\n                 .chain(|ts| Ok(ty::mk_tup(tcx, ts)) )\n         } else {\n             Err(ty::terr_tuple_size(\n-                expected_found(self, as_.len(), bs.len())))\n+                expected_found(this, as_.len(), bs.len())))\n         }\n       }\n \n       (ty::ty_bare_fn(ref a_fty), ty::ty_bare_fn(ref b_fty)) => {\n-        do self.bare_fn_tys(a_fty, b_fty).chain |fty| {\n+        do this.bare_fn_tys(a_fty, b_fty).chain |fty| {\n             Ok(ty::mk_bare_fn(tcx, fty))\n         }\n       }\n \n       (ty::ty_closure(ref a_fty), ty::ty_closure(ref b_fty)) => {\n-        do self.closure_tys(a_fty, b_fty).chain |fty| {\n+        do this.closure_tys(a_fty, b_fty).chain |fty| {\n             Ok(ty::mk_closure(tcx, fty))\n         }\n       }\n \n-      _ => Err(ty::terr_sorts(expected_found(self, a, b)))\n+      _ => Err(ty::terr_sorts(expected_found(this, a, b)))\n     };\n \n     fn unify_integral_variable<C:Combine>(\n-        self: &C,\n+        this: &C,\n         vid_is_expected: bool,\n         vid: ty::IntVid,\n         val: ty::IntVarValue) -> cres<ty::t>\n     {\n         if val == IntType(ast::ty_char) {\n             Err(ty::terr_integer_as_char)\n         } else {\n-            if_ok!(self.infcx().simple_var_t(vid_is_expected, vid, val));\n+            if_ok!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n             match val {\n                 IntType(v) => Ok(ty::mk_mach_int(v)),\n                 UintType(v) => Ok(ty::mk_mach_uint(v))\n@@ -605,30 +605,30 @@ pub fn super_tys<C:Combine>(\n     }\n \n     fn unify_float_variable<C:Combine>(\n-        self: &C,\n+        this: &C,\n         vid_is_expected: bool,\n         vid: ty::FloatVid,\n         val: ast::float_ty) -> cres<ty::t>\n     {\n-        if_ok!(self.infcx().simple_var_t(vid_is_expected, vid, val));\n+        if_ok!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         Ok(ty::mk_mach_float(val))\n     }\n }\n \n pub fn super_trait_refs<C:Combine>(\n-    self: &C, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef>\n+    this: &C, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef>\n {\n     // Different traits cannot be related\n \n     // - NOTE in the future, expand out subtraits!\n \n     if a.def_id != b.def_id {\n         Err(ty::terr_traits(\n-            expected_found(self, a.def_id, b.def_id)))\n+            expected_found(this, a.def_id, b.def_id)))\n     } else {\n-        let tcx = self.infcx().tcx;\n+        let tcx = this.infcx().tcx;\n         let trait_def = ty::lookup_trait_def(tcx, a.def_id);\n-        let substs = if_ok!(self.substs(&trait_def.generics, &a.substs, &b.substs));\n+        let substs = if_ok!(this.substs(&trait_def.generics, &a.substs, &b.substs));\n         Ok(ty::TraitRef {\n             def_id: a.def_id,\n             substs: substs"}, {"sha": "462d7a003f40599f57d803344b0d9c9b76117ad5", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -198,7 +198,7 @@ impl Combine for Glb {\n         debug!(\"sig1 = %s\", sig1.inf_str(self.infcx));\n         return Ok(sig1);\n \n-        fn generalize_region(self: &Glb,\n+        fn generalize_region(this: &Glb,\n                              snapshot: uint,\n                              new_vars: &[RegionVid],\n                              a_isr: isr_alist,\n@@ -209,19 +209,19 @@ impl Combine for Glb {\n                 return r0;\n             }\n \n-            let tainted = self.infcx.region_vars.tainted(snapshot, r0);\n+            let tainted = this.infcx.region_vars.tainted(snapshot, r0);\n \n             let mut a_r = None, b_r = None, only_new_vars = true;\n             for tainted.each |r| {\n                 if is_var_in_set(a_vars, *r) {\n                     if a_r.is_some() {\n-                        return fresh_bound_variable(self);\n+                        return fresh_bound_variable(this);\n                     } else {\n                         a_r = Some(*r);\n                     }\n                 } else if is_var_in_set(b_vars, *r) {\n                     if b_r.is_some() {\n-                        return fresh_bound_variable(self);\n+                        return fresh_bound_variable(this);\n                     } else {\n                         b_r = Some(*r);\n                     }\n@@ -246,17 +246,17 @@ impl Combine for Glb {\n \n             if a_r.is_some() && b_r.is_some() && only_new_vars {\n                 // Related to exactly one bound variable from each fn:\n-                return rev_lookup(self, a_isr, a_r.get());\n+                return rev_lookup(this, a_isr, a_r.get());\n             } else if a_r.is_none() && b_r.is_none() {\n                 // Not related to bound variables from either fn:\n                 return r0;\n             } else {\n                 // Other:\n-                return fresh_bound_variable(self);\n+                return fresh_bound_variable(this);\n             }\n         }\n \n-        fn rev_lookup(self: &Glb,\n+        fn rev_lookup(this: &Glb,\n                       a_isr: isr_alist,\n                       r: ty::Region) -> ty::Region\n         {\n@@ -267,13 +267,13 @@ impl Combine for Glb {\n                 }\n             }\n \n-            self.infcx.tcx.sess.span_bug(\n-                self.span,\n+            this.infcx.tcx.sess.span_bug(\n+                this.span,\n                 fmt!(\"could not find original bound region for %?\", r));\n         }\n \n-        fn fresh_bound_variable(self: &Glb) -> ty::Region {\n-            self.infcx.region_vars.new_bound()\n+        fn fresh_bound_variable(this: &Glb) -> ty::Region {\n+            this.infcx.region_vars.new_bound()\n         }\n     }\n "}, {"sha": "3c48e09c057470739a8587367ca40751893b9ef8", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -330,45 +330,45 @@ impl TyLatticeDir for Glb {\n }\n \n pub fn super_lattice_tys<L:LatticeDir + TyLatticeDir + Combine>(\n-    self: &L,\n+    this: &L,\n     a: ty::t,\n     b: ty::t) -> cres<ty::t> {\n-    debug!(\"%s.lattice_tys(%s, %s)\", self.tag(),\n-           a.inf_str(self.infcx()),\n-           b.inf_str(self.infcx()));\n+    debug!(\"%s.lattice_tys(%s, %s)\", this.tag(),\n+           a.inf_str(this.infcx()),\n+           b.inf_str(this.infcx()));\n     let _r = indenter();\n \n     if a == b {\n         return Ok(a);\n     }\n \n-    let tcx = self.infcx().tcx;\n+    let tcx = this.infcx().tcx;\n \n     match (&ty::get(a).sty, &ty::get(b).sty) {\n-        (&ty::ty_bot, _) => { return self.ty_bot(b); }\n-        (_, &ty::ty_bot) => { return self.ty_bot(a); }\n+        (&ty::ty_bot, _) => { return this.ty_bot(b); }\n+        (_, &ty::ty_bot) => { return this.ty_bot(a); }\n \n         (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n-            let r = if_ok!(lattice_vars(self, a_id, b_id,\n-                                        |x, y| self.tys(*x, *y)));\n+            let r = if_ok!(lattice_vars(this, a_id, b_id,\n+                                        |x, y| this.tys(*x, *y)));\n             return match r {\n                 VarResult(v) => Ok(ty::mk_var(tcx, v)),\n                 ValueResult(t) => Ok(t)\n             };\n         }\n \n         (&ty::ty_infer(TyVar(a_id)), _) => {\n-            return lattice_var_and_t(self, a_id, &b,\n-                                     |x, y| self.tys(*x, *y));\n+            return lattice_var_and_t(this, a_id, &b,\n+                                     |x, y| this.tys(*x, *y));\n         }\n \n         (_, &ty::ty_infer(TyVar(b_id))) => {\n-            return lattice_var_and_t(self, b_id, &a,\n-                                     |x, y| self.tys(*x, *y));\n+            return lattice_var_and_t(this, b_id, &a,\n+                                     |x, y| this.tys(*x, *y));\n         }\n \n         _ => {\n-            return super_tys(self, a, b);\n+            return super_tys(this, a, b);\n         }\n     }\n }\n@@ -398,22 +398,22 @@ pub enum LatticeVarResult<V,T> {\n pub fn lattice_vars<L:LatticeDir + Combine,\n                     T:Copy + InferStr + LatticeValue,\n                     V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n-    self: &L,                           // defines whether we want LUB or GLB\n+    this: &L,                           // defines whether we want LUB or GLB\n     a_vid: V,                          // first variable\n     b_vid: V,                          // second variable\n     lattice_dir_op: LatticeDirOp<T>)    // LUB or GLB operation on types\n     -> cres<LatticeVarResult<V,T>> {\n-    let nde_a = self.infcx().get(a_vid);\n-    let nde_b = self.infcx().get(b_vid);\n+    let nde_a = this.infcx().get(a_vid);\n+    let nde_b = this.infcx().get(b_vid);\n     let a_vid = nde_a.root;\n     let b_vid = nde_b.root;\n     let a_bounds = &nde_a.possible_types;\n     let b_bounds = &nde_b.possible_types;\n \n     debug!(\"%s.lattice_vars(%s=%s <: %s=%s)\",\n-           self.tag(),\n-           a_vid.to_str(), a_bounds.inf_str(self.infcx()),\n-           b_vid.to_str(), b_bounds.inf_str(self.infcx()));\n+           this.tag(),\n+           a_vid.to_str(), a_bounds.inf_str(this.infcx()),\n+           b_vid.to_str(), b_bounds.inf_str(this.infcx()));\n \n     // Same variable: the easy case.\n     if a_vid == b_vid {\n@@ -422,10 +422,10 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n \n     // If both A and B have an UB type, then we can just compute the\n     // LUB of those types:\n-    let a_bnd = self.bnd(a_bounds), b_bnd = self.bnd(b_bounds);\n+    let a_bnd = this.bnd(a_bounds), b_bnd = this.bnd(b_bounds);\n     match (a_bnd, b_bnd) {\n         (Some(ref a_ty), Some(ref b_ty)) => {\n-            match self.infcx().try(|| lattice_dir_op(a_ty, b_ty) ) {\n+            match this.infcx().try(|| lattice_dir_op(a_ty, b_ty) ) {\n                 Ok(t) => return Ok(ValueResult(t)),\n                 Err(_) => { /*fallthrough */ }\n             }\n@@ -435,7 +435,7 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n \n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n-    let cf = self.combine_fields();\n+    let cf = this.combine_fields();\n     do cf.var_sub_var(a_vid, b_vid).then {\n         Ok(VarResult(a_vid))\n     }\n@@ -444,37 +444,37 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n pub fn lattice_var_and_t<L:LatticeDir + Combine,\n                          T:Copy + InferStr + LatticeValue,\n                          V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n-    self: &L,\n+    this: &L,\n     a_id: V,\n     b: &T,\n     lattice_dir_op: LatticeDirOp<T>)\n     -> cres<T> {\n-    let nde_a = self.infcx().get(a_id);\n+    let nde_a = this.infcx().get(a_id);\n     let a_id = nde_a.root;\n     let a_bounds = &nde_a.possible_types;\n \n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n \n     debug!(\"%s.lattice_var_and_t(%s=%s <: %s)\",\n-           self.tag(),\n+           this.tag(),\n            a_id.to_str(),\n-           a_bounds.inf_str(self.infcx()),\n-           b.inf_str(self.infcx()));\n+           a_bounds.inf_str(this.infcx()),\n+           b.inf_str(this.infcx()));\n \n-    match self.bnd(a_bounds) {\n+    match this.bnd(a_bounds) {\n         Some(ref a_bnd) => {\n             // If a has an upper bound, return the LUB(a.ub, b)\n-            debug!(\"bnd=Some(%s)\", a_bnd.inf_str(self.infcx()));\n+            debug!(\"bnd=Some(%s)\", a_bnd.inf_str(this.infcx()));\n             lattice_dir_op(a_bnd, b)\n         }\n         None => {\n             // If a does not have an upper bound, make b the upper bound of a\n             // and then return b.\n             debug!(\"bnd=None\");\n-            let a_bounds = self.with_bnd(a_bounds, *b);\n-            do self.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then {\n-                self.infcx().set(a_id, Root(a_bounds, nde_a.rank));\n+            let a_bounds = this.with_bnd(a_bounds, *b);\n+            do this.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then {\n+                this.infcx().set(a_id, Root(a_bounds, nde_a.rank));\n                 Ok(*b)\n             }\n         }\n@@ -485,14 +485,14 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n // Random utility functions used by LUB/GLB when computing LUB/GLB of\n // fn types\n \n-pub fn var_ids<T:Combine>(self: &T, isr: isr_alist) -> ~[RegionVid] {\n+pub fn var_ids<T:Combine>(this: &T, isr: isr_alist) -> ~[RegionVid] {\n     let mut result = ~[];\n     for list::each(isr) |pair| {\n         match pair.second() {\n             ty::re_infer(ty::ReVar(r)) => { result.push(r); }\n             r => {\n-                self.infcx().tcx.sess.span_bug(\n-                    self.span(),\n+                this.infcx().tcx.sess.span_bug(\n+                    this.span(),\n                     fmt!(\"Found non-region-vid: %?\", r));\n             }\n         }"}, {"sha": "bd5821873d2cb1bfbd9e5748b34ec25f4f04fc42", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -149,7 +149,7 @@ impl Combine for Lub {\n                                               a_isr, r));\n         return Ok(sig1);\n \n-        fn generalize_region(self: &Lub,\n+        fn generalize_region(this: &Lub,\n                              snapshot: uint,\n                              new_vars: &[RegionVid],\n                              a_isr: isr_alist,\n@@ -160,7 +160,7 @@ impl Combine for Lub {\n                 return r0;\n             }\n \n-            let tainted = self.infcx.region_vars.tainted(snapshot, r0);\n+            let tainted = this.infcx.region_vars.tainted(snapshot, r0);\n \n             // Variables created during LUB computation which are\n             // *related* to regions that pre-date the LUB computation\n@@ -187,8 +187,8 @@ impl Combine for Lub {\n                 }\n             }\n \n-            self.infcx.tcx.sess.span_bug(\n-                self.span,\n+            this.infcx.tcx.sess.span_bug(\n+                this.span,\n                 fmt!(\"Region %? is not associated with \\\n                       any bound region from A!\", r0));\n         }"}, {"sha": "a5e8b42dee5ac9d0de56c8069487fc2d527b59b6", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -876,7 +876,7 @@ pub impl RegionVarBindings {\n                     a: Region,\n                     b: Region,\n                     span: span,\n-                    relate: &fn(self: &mut RegionVarBindings,\n+                    relate: &fn(this: &mut RegionVarBindings,\n                                 old_r: Region,\n                                 new_r: Region) -> cres<()>)\n                  -> cres<Region> {\n@@ -1103,11 +1103,11 @@ priv impl RegionVarBindings {\n             Equal => ty::re_free(*a)\n         };\n \n-        fn helper(self: &RegionVarBindings,\n+        fn helper(this: &RegionVarBindings,\n                   a: &FreeRegion,\n                   b: &FreeRegion) -> ty::Region\n         {\n-            let rm = self.tcx.region_maps;\n+            let rm = this.tcx.region_maps;\n             if rm.sub_free_region(*a, *b) {\n                 ty::re_free(*b)\n             } else if rm.sub_free_region(*b, *a) {\n@@ -1198,17 +1198,17 @@ priv impl RegionVarBindings {\n             Equal => Ok(ty::re_free(*a))\n         };\n \n-        fn helper(self: &RegionVarBindings,\n+        fn helper(this: &RegionVarBindings,\n                   a: &FreeRegion,\n                   b: &FreeRegion) -> cres<ty::Region>\n         {\n-            let rm = self.tcx.region_maps;\n+            let rm = this.tcx.region_maps;\n             if rm.sub_free_region(*a, *b) {\n                 Ok(ty::re_free(*a))\n             } else if rm.sub_free_region(*b, *a) {\n                 Ok(ty::re_free(*b))\n             } else {\n-                self.intersect_scopes(ty::re_free(*a), ty::re_free(*b),\n+                this.intersect_scopes(ty::re_free(*a), ty::re_free(*b),\n                                       a.scope_id, b.scope_id)\n             }\n         }\n@@ -1461,27 +1461,27 @@ pub impl RegionVarBindings {\n             }\n         };\n \n-        fn check_node(self: &mut RegionVarBindings,\n+        fn check_node(this: &mut RegionVarBindings,\n                       a_vid: RegionVid,\n                       a_node: &mut GraphNode,\n                       a_region: Region,\n                       b_region: Region)\n                    -> bool {\n-            if !self.is_subregion_of(a_region, b_region) {\n+            if !this.is_subregion_of(a_region, b_region) {\n                 debug!(\"Setting %? to ErrorValue: %? not subregion of %?\",\n                        a_vid, a_region, b_region);\n                 a_node.value = ErrorValue;\n             }\n             false\n         }\n \n-        fn adjust_node(self: &mut RegionVarBindings,\n+        fn adjust_node(this: &mut RegionVarBindings,\n                        a_vid: RegionVid,\n                        a_node: &mut GraphNode,\n                        a_region: Region,\n                        b_region: Region)\n                     -> bool {\n-            match self.glb_concrete_regions(a_region, b_region) {\n+            match this.glb_concrete_regions(a_region, b_region) {\n                 Ok(glb) => {\n                     if glb == a_region {\n                         false\n@@ -1744,14 +1744,14 @@ pub impl RegionVarBindings {\n         let WalkState {result, dup_found, _} = state;\n         return (result, dup_found);\n \n-        fn process_edges(self: &mut RegionVarBindings,\n+        fn process_edges(this: &mut RegionVarBindings,\n                          state: &mut WalkState,\n                          graph: &Graph,\n                          source_vid: RegionVid,\n                          dir: Direction) {\n             debug!(\"process_edges(source_vid=%?, dir=%?)\", source_vid, dir);\n \n-            for self.each_edge(graph, source_vid, dir) |edge| {\n+            for this.each_edge(graph, source_vid, dir) |edge| {\n                 match edge.constraint {\n                     ConstrainVarSubVar(from_vid, to_vid) => {\n                         let opp_vid ="}, {"sha": "e5ed2efa4c26356675cb81d95d01a68472cab783", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -267,10 +267,10 @@ pub struct binding_rscope {\n }\n \n pub fn in_binding_rscope<RS:region_scope + Copy + 'static>(\n-        self: &RS,\n+        this: &RS,\n         region_param_names: RegionParamNames)\n      -> binding_rscope {\n-    let base = @copy *self;\n+    let base = @copy *this;\n     let base = base as @region_scope;\n     binding_rscope {\n         base: base,"}, {"sha": "f98cbe2e5b9964391534c432c0f9dfed1fa6c0a8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -572,6 +572,9 @@ pub enum expr_ {\n     expr_field(@expr, ident, ~[@Ty]),\n     expr_index(@expr, @expr),\n     expr_path(@Path),\n+\n+    /// The special identifier `self`.\n+    expr_self,\n     expr_addr_of(mutability, @expr),\n     expr_break(Option<ident>),\n     expr_again(Option<ident>),"}, {"sha": "e1416230720fc5aab729d9c423277f8c55223098", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -245,6 +245,7 @@ trait ExtCtxtMethods {\n     fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n     fn expr_path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n     fn expr_var(&self, span: span, var: &str) -> @ast::expr;\n+    fn expr_self(&self, span: span) -> @ast::expr;\n     fn expr_field(&self, span: span, expr: @ast::expr, ident: ast::ident)\n                   -> @ast::expr;\n     fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr])\n@@ -450,6 +451,10 @@ impl ExtCtxtMethods for @ext_ctxt {\n         self.expr_path(span, ~[self.ident_of(var)])\n     }\n \n+    fn expr_self(&self, span: span) -> @ast::expr {\n+        self.expr(span, ast::expr_self)\n+    }\n+\n     fn expr_field(\n         &self,\n         span: span,\n@@ -790,12 +795,8 @@ fn mk_struct_ser_impl(\n         let expr_lambda = cx.lambda_expr_1(\n             cx.expr_method_call(\n                 span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_var(span, \"self\"),\n-                    field.ident\n-                ),\n-                cx.ident_of(\"encode\"),\n+                cx.expr_field(span, cx.expr_self(span), field.ident),\n+                cx.ident_of(~\"encode\"),\n                 ~[cx.expr_var(span, \"__s\")]\n             ),\n             cx.ident_of(\"__s\")\n@@ -1062,13 +1063,10 @@ fn mk_enum_ser_body(\n     // ast for `match *self { $(arms) }`\n     let match_expr = cx.expr(\n         span,\n-        ast::expr_match(\n-            cx.expr(\n-                span,\n-                ast::expr_unary(ast::deref, cx.expr_var(span, \"self\"))\n-            ),\n-            arms\n-        )\n+        ast::expr_match(cx.expr(span,\n+                                ast::expr_unary(ast::deref,\n+                                                cx.expr_self(span))),\n+                        arms)\n     );\n \n     // ast for `__s.emit_enum($(name), || $(match_expr))`"}, {"sha": "3f90fd6267bfb0b57c4a526e44a087cf85d36086", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -518,6 +518,10 @@ pub fn mk_unreachable_arm(cx: @ext_ctxt, span: span) -> ast::arm {\n     mk_arm(cx, span, ~[mk_pat_wild(cx, span)], mk_unreachable(cx, span))\n }\n \n+pub fn make_self(cx: @ext_ctxt, span: span) -> @ast::expr {\n+    build::mk_expr(cx, span, ast::expr_self)\n+}\n+\n //\n // Duplication functions\n //"}, {"sha": "a5edd92022f78a169a1c18f051f9c6d99a32d3e1", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -204,21 +204,17 @@ fn expand_deriving_encodable_struct_method(\n     type_ident: ident,\n     struct_def: &struct_def\n ) -> @method {\n-    let self_ident = cx.ident_of(\"self\");\n-\n     // Create the body of the method.\n     let mut idx = 0;\n     let mut statements = ~[];\n     for struct_def.fields.each |struct_field| {\n         match struct_field.node.kind {\n             named_field(ident, _) => {\n                 // Create the accessor for this field.\n-                let self_field = build::mk_access(\n-                    cx,\n-                    span,\n-                    ~[self_ident],\n-                    ident\n-                );\n+                let self_field = build::mk_access_(cx,\n+                                                   span,\n+                                                   build::make_self(cx, span),\n+                                                   ident);\n \n                 // Call the substructure method.\n                 let encode_expr = call_substructure_encode_method("}, {"sha": "3b94a95dfe032518afbf8adfc7db25dd782f46b1", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -371,8 +371,7 @@ pub fn expand_enum_or_struct_match(cx: @ext_ctxt,\n                                span: span,\n                                arms: ~[ ast::arm ])\n                             -> @expr {\n-    let self_ident = cx.ident_of(\"self\");\n-    let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n+    let self_expr = build::make_self(cx, span);\n     let self_expr = build::mk_unary(cx, span, ast::deref, self_expr);\n     let self_match_expr = ast::expr_match(self_expr, arms);\n     build::mk_expr(cx, span, self_match_expr)"}, {"sha": "0bb88dae26b2afb5fd3c94381cf7bbf451bc32c7", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -191,7 +191,7 @@ fn mk_generics(lifetimes: ~[ast::Lifetime],  ty_params: ~[ast::TyParam]) -> Gene\n     }\n }\n \n-/// Lifetimes and bounds on type paramers\n+/// Lifetimes and bounds on type parameters\n pub struct LifetimeBounds {\n     lifetimes: ~[~str],\n     bounds: ~[(~str, ~[Path])]\n@@ -218,7 +218,7 @@ pub impl LifetimeBounds {\n \n pub fn get_explicit_self(cx: @ext_ctxt, span: span, self_ptr: Option<PtrTy>)\n     -> (@expr, ast::self_ty) {\n-    let self_path = build::mk_path(cx, span, ~[cx.ident_of(\"self\")]);\n+    let self_path = build::make_self(cx, span);\n     match self_ptr {\n         None => {\n             (self_path, respan(span, ast::sty_value))"}, {"sha": "5c99ddc9040ab03ceb803d2b87cf92218a105946", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -32,7 +32,7 @@ impl proto_parser for parser::Parser {\n                 sep: None,\n                 trailing_sep_allowed: false,\n             },\n-            |self| self.parse_state(proto)\n+            |this| this.parse_state(proto)\n         );\n \n         return proto;\n@@ -70,7 +70,7 @@ impl proto_parser for parser::Parser {\n                 sep: Some(token::COMMA),\n                 trailing_sep_allowed: true,\n             },\n-            |self| self.parse_message(state)\n+            |this| this.parse_message(state)\n         );\n     }\n "}, {"sha": "842f9e9ab33795e6cd35b0f9726bc0d6893caaeb", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -524,6 +524,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n             expr_index(fld.fold_expr(el), fld.fold_expr(er))\n         }\n         expr_path(pth) => expr_path(fld.fold_path(pth)),\n+        expr_self => expr_self,\n         expr_break(ref opt_ident) => {\n             expr_break(opt_ident.map(|x| fld.fold_ident(*x)))\n         }"}, {"sha": "322f294836b04e12dbbaf1d452d0c9a8ea3982f2", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -222,7 +222,8 @@ pub impl Parser {\n     // signal an error if the given string is a strict keyword\n     fn check_strict_keywords_(&self, w: &~str) {\n         if self.is_strict_keyword(w) {\n-            self.fatal(fmt!(\"found `%s` in ident position\", *w));\n+            self.span_err(*self.last_span,\n+                          fmt!(\"found `%s` in ident position\", *w));\n         }\n     }\n "}, {"sha": "bbd93b71d36d08a4290a9fed6afc8e21f85cda82", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -475,10 +475,12 @@ mod test {\n                               span:sp(0,6)})\n     }\n \n-    #[should_fail]\n+    // FIXME (#6416): For some reason, this fails and causes a test failure, even though it's\n+    // marked as `#[should_fail]`.\n+    /*#[should_fail]\n     #[test] fn bad_path_expr_1() {\n         string_to_expr(@~\"::abc::def::return\");\n-    }\n+    }*/\n \n     #[test] fn string_to_tts_1 () {\n         let (tts,ps) = string_to_tts_t(@~\"fn a (b : int) { b; }\");"}, {"sha": "a8870eeee22da8bf78b90d6531631f5405e93b70", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -26,7 +26,7 @@ use ast::{expr_break, expr_call, expr_cast, expr_copy, expr_do_body};\n use ast::{expr_field, expr_fn_block, expr_if, expr_index};\n use ast::{expr_lit, expr_log, expr_loop, expr_loop_body, expr_mac};\n use ast::{expr_method_call, expr_paren, expr_path, expr_repeat};\n-use ast::{expr_ret, expr_struct, expr_tup, expr_unary};\n+use ast::{expr_ret, expr_self, expr_struct, expr_tup, expr_unary};\n use ast::{expr_vec, expr_vstore, expr_vstore_mut_box};\n use ast::{expr_vstore_slice, expr_vstore_box};\n use ast::{expr_vstore_mut_slice, expr_while, extern_fn, field, fn_decl};\n@@ -430,8 +430,12 @@ pub impl Parser {\n             lifetimes: lifetimes,\n         });\n \n-        fn parse_onceness(self: &Parser) -> Onceness {\n-            if self.eat_keyword(&~\"once\") { Once } else { Many }\n+        fn parse_onceness(this: &Parser) -> Onceness {\n+            if this.eat_keyword(&~\"once\") {\n+                Once\n+            } else {\n+                Many\n+            }\n         }\n     }\n \n@@ -1224,6 +1228,9 @@ pub impl Parser {\n                                  expr_block(blk));\n         } else if token::is_bar(&*self.token) {\n             return self.parse_lambda_expr();\n+        } else if self.eat_keyword(&~\"self\") {\n+            ex = expr_self;\n+            hi = self.span.hi;\n         } else if self.eat_keyword(&~\"if\") {\n             return self.parse_if_expr();\n         } else if self.eat_keyword(&~\"for\") {\n@@ -2984,9 +2991,7 @@ pub impl Parser {\n             }\n         }\n \n-        fn maybe_parse_borrowed_self_ty(\n-            self: &Parser\n-        ) -> ast::self_ty_ {\n+        fn maybe_parse_borrowed_self_ty(this: &Parser) -> ast::self_ty_ {\n             // The following things are possible to see here:\n             //\n             //     fn(&self)\n@@ -2996,37 +3001,29 @@ pub impl Parser {\n             //\n             // We already know that the current token is `&`.\n \n-            if (\n-                self.token_is_keyword(&~\"self\", &self.look_ahead(1)))\n-            {\n-                self.bump();\n-                self.expect_self_ident();\n+            if (this.token_is_keyword(&~\"self\", &this.look_ahead(1))) {\n+                this.bump();\n+                this.expect_self_ident();\n                 sty_region(None, m_imm)\n-            } else if (\n-                self.token_is_mutability(&self.look_ahead(1)) &&\n-                self.token_is_keyword(&~\"self\", &self.look_ahead(2)))\n-            {\n-                self.bump();\n-                let mutability = self.parse_mutability();\n-                self.expect_self_ident();\n+            } else if (this.token_is_mutability(&this.look_ahead(1)) &&\n+                       this.token_is_keyword(&~\"self\", &this.look_ahead(2))) {\n+                this.bump();\n+                let mutability = this.parse_mutability();\n+                this.expect_self_ident();\n                 sty_region(None, mutability)\n-            } else if (\n-                self.token_is_lifetime(&self.look_ahead(1)) &&\n-                self.token_is_keyword(&~\"self\", &self.look_ahead(2)))\n-            {\n-                self.bump();\n-                let lifetime = @self.parse_lifetime();\n-                self.expect_self_ident();\n+            } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n+                       this.token_is_keyword(&~\"self\", &this.look_ahead(2))) {\n+                this.bump();\n+                let lifetime = @this.parse_lifetime();\n+                this.expect_self_ident();\n                 sty_region(Some(lifetime), m_imm)\n-            } else if (\n-                self.token_is_lifetime(&self.look_ahead(1)) &&\n-                self.token_is_mutability(&self.look_ahead(2)) &&\n-                self.token_is_keyword(&~\"self\", &self.look_ahead(3)))\n-            {\n-                self.bump();\n-                let lifetime = @self.parse_lifetime();\n-                let mutability = self.parse_mutability();\n-                self.expect_self_ident();\n+            } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n+                       this.token_is_mutability(&this.look_ahead(2)) &&\n+                       this.token_is_keyword(&~\"self\", &this.look_ahead(3))) {\n+                this.bump();\n+                let lifetime = @this.parse_lifetime();\n+                let mutability = this.parse_mutability();\n+                this.expect_self_ident();\n                 sty_region(Some(lifetime), mutability)\n             } else {\n                 sty_static"}, {"sha": "fde383b445c9525962dec0c571a30313dd59bcca", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -340,7 +340,7 @@ pub mod special_idents {\n     pub static main : ident = ident { repr: 26, ctxt: 0};\n     pub static opaque : ident = ident { repr: 27, ctxt: 0};\n     pub static blk : ident = ident { repr: 28, ctxt: 0};\n-    pub static static : ident = ident { repr: 29, ctxt: 0};\n+    pub static statik : ident = ident { repr: 29, ctxt: 0};\n     pub static intrinsic : ident = ident { repr: 30, ctxt: 0};\n     pub static clownshoes_foreign_mod: ident = ident { repr: 31, ctxt: 0};\n     pub static unnamed_field: ident = ident { repr: 32, ctxt: 0};\n@@ -504,26 +504,17 @@ pub fn mk_fake_ident_interner() -> @ident_interner {\n  */\n pub fn keyword_table() -> HashSet<~str> {\n     let mut keywords = HashSet::new();\n-    let mut tmp = temporary_keyword_table();\n     let mut strict = strict_keyword_table();\n     let mut reserved = reserved_keyword_table();\n \n-    do tmp.consume |word|      { keywords.insert(word); }\n-    do strict.consume |word|   { keywords.insert(word); }\n-    do reserved.consume |word| { keywords.insert(word); }\n-    return keywords;\n-}\n-\n-/// Keywords that may be used as identifiers\n-pub fn temporary_keyword_table() -> HashSet<~str> {\n-    let mut words = HashSet::new();\n-    let keys = ~[\n-        ~\"self\", ~\"static\",\n-    ];\n-    do vec::consume(keys) |_, s| {\n-        words.insert(s);\n+    do strict.consume |word| {\n+        keywords.insert(word);\n     }\n-    return words;\n+    do reserved.consume |word| {\n+        keywords.insert(word);\n+    }\n+\n+    keywords\n }\n \n /// Full keywords. May not appear anywhere else.\n@@ -542,7 +533,7 @@ pub fn strict_keyword_table() -> HashSet<~str> {\n         ~\"once\",\n         ~\"priv\", ~\"pub\", ~\"pure\",\n         ~\"ref\", ~\"return\",\n-        ~\"struct\", ~\"super\",\n+        ~\"static\", ~\"self\", ~\"struct\", ~\"super\",\n         ~\"true\", ~\"trait\", ~\"type\",\n         ~\"unsafe\", ~\"use\",\n         ~\"while\""}, {"sha": "2e7c35807e5b1166c3892f65e067740f19a5c54c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -1352,6 +1352,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         word(s.s, ~\"]\");\n       }\n       ast::expr_path(path) => print_path(s, path, true),\n+      ast::expr_self => word(s.s, ~\"self\"),\n       ast::expr_break(opt_ident) => {\n         word(s.s, ~\"break\");\n         space(s.s);"}, {"sha": "ea02d84ddaca1fc87d0ff3b80ac4fc82a63400ee", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -529,6 +529,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, e: E, v: vt<E>) {\n             (v.visit_expr)(b, e, v);\n         }\n         expr_path(p) => visit_path(p, e, v),\n+        expr_self => (),\n         expr_break(_) => (),\n         expr_again(_) => (),\n         expr_ret(eo) => visit_expr_opt(eo, e, v),"}, {"sha": "c2e1fc615cca3c29b43b9d73d4563c70273dd0d5", "filename": "src/test/compile-fail/issue-5099.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Ftest%2Fcompile-fail%2Fissue-5099.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Ftest%2Fcompile-fail%2Fissue-5099.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5099.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n \n-trait B < A > { fn a() -> A { self.a} } //~ ERROR unresolved name\n+trait B < A > { fn a() -> A { this.a } } //~ ERROR unresolved name\n \n fn main() {}"}, {"sha": "d19b4dfbd57d0ce0db875d28028241728f2ec405", "filename": "src/test/compile-fail/use-after-move-self-based-on-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -9,7 +9,7 @@ impl Drop for S {\n pub impl S {\n     fn foo(self) -> int {\n         self.bar();\n-        return self.x;  //~ ERROR use of moved value\n+        return self.x;  //~ ERROR use of partially moved value\n     }\n \n     fn bar(self) {}"}, {"sha": "b2eaffdd06605ce434ec56526680e9b74e59a3bb", "filename": "src/test/compile-fail/use-after-move-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3559e6455757c5508bba5b5add69477ebac53e/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs?ref=5d3559e6455757c5508bba5b5add69477ebac53e", "patch": "@@ -5,7 +5,7 @@ struct S {\n pub impl S {\n     fn foo(self) -> int {\n         self.bar();\n-        return *self.x;  //~ ERROR use of moved value\n+        return *self.x;  //~ ERROR use of partially moved value\n     }\n \n     fn bar(self) {}"}]}