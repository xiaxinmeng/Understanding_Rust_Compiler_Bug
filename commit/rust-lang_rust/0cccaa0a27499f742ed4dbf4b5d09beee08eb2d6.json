{"sha": "0cccaa0a27499f742ed4dbf4b5d09beee08eb2d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjY2NhYTBhMjc0OTlmNzQyZWQ0ZGJmNGI1ZDA5YmVlZTA4ZWIyZDY=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-06-12T13:11:45Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-06-19T10:16:14Z"}, "message": "lint: unify enum variant, union and struct logic\n\nThis commit applies the changes introduced in #72890 to both enum\nvariants and unions - where the logic prior to #72890 was duplicated.\n\nSigned-off-by: David Wood <david@davidtw.co>", "tree": {"sha": "05a382c74256901beec74b8da13153535bf57992", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05a382c74256901beec74b8da13153535bf57992"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cccaa0a27499f742ed4dbf4b5d09beee08eb2d6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEfgm2/wUjk9OnjxlyJZLnbIc4H9kFAl7skG4ACgkQJZLnbIc4\nH9ngyA/9Hg/GMqgzH02taAYCbWvqd6dE/5aQXcP3uqlU7dIgOiGE0dyknM2MctzQ\nbpv+QF8g5oO3Fv5K39s0WDF1G8Dt4g8fL5lx5nxU/njohP2scwQtLjCuuJE1PyaZ\nqCdSzSKx80keXAiyAeqdVzs9dpsPWZiqybtTKKLkXWo/2hzYj9JyBqDMXElAhl6b\nmxtMo9P5NaW+p4nJ1SbIEQqpPMzawofWGAthkkc3ljVI+Yhc+5Lk1GYUiLiJqNW+\nPzGI0LtMe8z67fEF8MdlkdQ7NBw1r+/CnVYkKa6Lpul9wS/CRl9l4JxrQ7LuGMQX\nEwHiboravfBBWP7PjPGxMOzIdbNjC6wHaa5CcfyfiUY0xcmETAvXx0Gr74SNIvGJ\nWALeWbJD1Frf1N1KLGJhTi+BucwNeGIWHfubdb4HGDL/xkQirmEdVe7bnjYSlgQ3\n1C4H+ARguELY8rJCMvnR0H31Bb7hqmEeKjV0BlQnHgQ13hXcVnW7/+zUCPCQCd2A\nMghC8intX3MYkPibx+iN73ua6NrEXn5yGvSabHMa5DUneRaNEQg5I81XYo1L5d3j\nkNsL9e095ely+6lMqFy9an8XgVab8DRdG8eMXdpRJR7IWUkOq6iMaI8VP10KSBq7\nz6sae1mC+43uxojkqepAX2g1MV/1MSU1y5XmABiiYRrkS6XTUAQ=\n=iOEH\n-----END PGP SIGNATURE-----", "payload": "tree 05a382c74256901beec74b8da13153535bf57992\nparent 76ad38d992835292f60f5f09b04b2b0886e312d9\nauthor David Wood <david@davidtw.co> 1591967505 +0100\ncommitter David Wood <david@davidtw.co> 1592561774 +0100\n\nlint: unify enum variant, union and struct logic\n\nThis commit applies the changes introduced in #72890 to both enum\nvariants and unions - where the logic prior to #72890 was duplicated.\n\nSigned-off-by: David Wood <david@davidtw.co>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cccaa0a27499f742ed4dbf4b5d09beee08eb2d6", "html_url": "https://github.com/rust-lang/rust/commit/0cccaa0a27499f742ed4dbf4b5d09beee08eb2d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cccaa0a27499f742ed4dbf4b5d09beee08eb2d6/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76ad38d992835292f60f5f09b04b2b0886e312d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/76ad38d992835292f60f5f09b04b2b0886e312d9", "html_url": "https://github.com/rust-lang/rust/commit/76ad38d992835292f60f5f09b04b2b0886e312d9"}], "stats": {"total": 259, "additions": 107, "deletions": 152}, "files": [{"sha": "b20bf432614746d24cde3f1f030b7728b9314a45", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 82, "deletions": 125, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/0cccaa0a27499f742ed4dbf4b5d09beee08eb2d6/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cccaa0a27499f742ed4dbf4b5d09beee08eb2d6/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=0cccaa0a27499f742ed4dbf4b5d09beee08eb2d6", "patch": "@@ -507,7 +507,7 @@ struct ImproperCTypesVisitor<'a, 'tcx> {\n enum FfiResult<'tcx> {\n     FfiSafe,\n     FfiPhantom(Ty<'tcx>),\n-    FfiUnsafe { ty: Ty<'tcx>, reason: &'static str, help: Option<&'static str> },\n+    FfiUnsafe { ty: Ty<'tcx>, reason: String, help: Option<String> },\n }\n \n fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -613,6 +613,50 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n+    /// Checks if the given `VariantDef`'s field types are \"ffi-safe\".\n+    fn check_variant_for_ffi(\n+        &self,\n+        cache: &mut FxHashSet<Ty<'tcx>>,\n+        ty: Ty<'tcx>,\n+        def: &ty::AdtDef,\n+        variant: &ty::VariantDef,\n+        substs: SubstsRef<'tcx>,\n+    ) -> FfiResult<'tcx> {\n+        use FfiResult::*;\n+\n+        if def.repr.transparent() {\n+            // Can assume that only one field is not a ZST, so only check\n+            // that field's type for FFI-safety.\n+            if let Some(field) = variant.transparent_newtype_field(self.cx.tcx, self.cx.param_env) {\n+                self.check_field_type_for_ffi(cache, field, substs)\n+            } else {\n+                bug!(\"malformed transparent type\");\n+            }\n+        } else {\n+            // We can't completely trust repr(C) markings; make sure the fields are\n+            // actually safe.\n+            let mut all_phantom = !variant.fields.is_empty();\n+            for field in &variant.fields {\n+                match self.check_field_type_for_ffi(cache, &field, substs) {\n+                    FfiSafe => {\n+                        all_phantom = false;\n+                    }\n+                    FfiPhantom(..) if def.is_enum() => {\n+                        return FfiUnsafe {\n+                            ty,\n+                            reason: \"this enum contains a PhantomData field\".into(),\n+                            help: None,\n+                        };\n+                    }\n+                    FfiPhantom(..) => {}\n+                    r => return r,\n+                }\n+            }\n+\n+            if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n+        }\n+    }\n+\n     /// Checks if the given type is \"ffi-safe\" (has a stable, well-defined\n     /// representation which can be exported to C code).\n     fn check_type_for_ffi(&self, cache: &mut FxHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult<'tcx> {\n@@ -634,15 +678,18 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     return FfiPhantom(ty);\n                 }\n                 match def.adt_kind() {\n-                    AdtKind::Struct => {\n+                    AdtKind::Struct | AdtKind::Union => {\n+                        let kind = if def.is_struct() { \"struct\" } else { \"union\" };\n+\n                         if !def.repr.c() && !def.repr.transparent() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: \"this struct has unspecified layout\",\n-                                help: Some(\n+                                reason: format!(\"this {} has unspecified layout\", kind),\n+                                help: Some(format!(\n                                     \"consider adding a `#[repr(C)]` or \\\n-                                            `#[repr(transparent)]` attribute to this struct\",\n-                                ),\n+                                             `#[repr(transparent)]` attribute to this {}\",\n+                                    kind\n+                                )),\n                             };\n                         }\n \n@@ -651,93 +698,20 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         if is_non_exhaustive && !def.did.is_local() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: \"this struct is non-exhaustive\",\n+                                reason: format!(\"this {} is non-exhaustive\", kind),\n                                 help: None,\n                             };\n                         }\n \n                         if def.non_enum_variant().fields.is_empty() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: \"this struct has no fields\",\n-                                help: Some(\"consider adding a member to this struct\"),\n+                                reason: format!(\"this {} has no fields\", kind),\n+                                help: Some(format!(\"consider adding a member to this {}\", kind)),\n                             };\n                         }\n \n-                        if def.repr.transparent() {\n-                            // Can assume that only one field is not a ZST, so only check\n-                            // that field's type for FFI-safety.\n-                            if let Some(field) =\n-                                def.transparent_newtype_field(cx, self.cx.param_env)\n-                            {\n-                                self.check_field_type_for_ffi(cache, field, substs)\n-                            } else {\n-                                FfiSafe\n-                            }\n-                        } else {\n-                            // We can't completely trust repr(C) markings; make sure the fields are\n-                            // actually safe.\n-                            let mut all_phantom = true;\n-                            for field in &def.non_enum_variant().fields {\n-                                let r = self.check_field_type_for_ffi(cache, field, substs);\n-                                match r {\n-                                    FfiSafe => {\n-                                        all_phantom = false;\n-                                    }\n-                                    FfiPhantom(..) => {}\n-                                    FfiUnsafe { .. } => {\n-                                        return r;\n-                                    }\n-                                }\n-                            }\n-\n-                            if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n-                        }\n-                    }\n-                    AdtKind::Union => {\n-                        if !def.repr.c() && !def.repr.transparent() {\n-                            return FfiUnsafe {\n-                                ty,\n-                                reason: \"this union has unspecified layout\",\n-                                help: Some(\n-                                    \"consider adding a `#[repr(C)]` or \\\n-                                            `#[repr(transparent)]` attribute to this union\",\n-                                ),\n-                            };\n-                        }\n-\n-                        if def.non_enum_variant().fields.is_empty() {\n-                            return FfiUnsafe {\n-                                ty,\n-                                reason: \"this union has no fields\",\n-                                help: Some(\"consider adding a field to this union\"),\n-                            };\n-                        }\n-\n-                        let mut all_phantom = true;\n-                        for field in &def.non_enum_variant().fields {\n-                            let field_ty = cx.normalize_erasing_regions(\n-                                ParamEnv::reveal_all(),\n-                                field.ty(cx, substs),\n-                            );\n-                            // repr(transparent) types are allowed to have arbitrary ZSTs, not just\n-                            // PhantomData -- skip checking all ZST fields.\n-                            if def.repr.transparent() && field_ty.is_zst(cx, field.did) {\n-                                continue;\n-                            }\n-                            let r = self.check_type_for_ffi(cache, field_ty);\n-                            match r {\n-                                FfiSafe => {\n-                                    all_phantom = false;\n-                                }\n-                                FfiPhantom(..) => {}\n-                                FfiUnsafe { .. } => {\n-                                    return r;\n-                                }\n-                            }\n-                        }\n-\n-                        if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n+                        self.check_variant_for_ffi(cache, ty, def, def.non_enum_variant(), substs)\n                     }\n                     AdtKind::Enum => {\n                         if def.variants.is_empty() {\n@@ -752,11 +726,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             if !is_repr_nullable_ptr(cx, ty, def, substs) {\n                                 return FfiUnsafe {\n                                     ty,\n-                                    reason: \"enum has no representation hint\",\n+                                    reason: \"enum has no representation hint\".into(),\n                                     help: Some(\n                                         \"consider adding a `#[repr(C)]`, \\\n                                                 `#[repr(transparent)]`, or integer `#[repr(...)]` \\\n-                                                attribute to this enum\",\n+                                                attribute to this enum\"\n+                                            .into(),\n                                     ),\n                                 };\n                             }\n@@ -765,7 +740,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         if def.is_variant_list_non_exhaustive() && !def.did.is_local() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: \"this enum is non-exhaustive\",\n+                                reason: \"this enum is non-exhaustive\".into(),\n                                 help: None,\n                             };\n                         }\n@@ -776,51 +751,31 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             if is_non_exhaustive && !variant.def_id.is_local() {\n                                 return FfiUnsafe {\n                                     ty,\n-                                    reason: \"this enum has non-exhaustive variants\",\n+                                    reason: \"this enum has non-exhaustive variants\".into(),\n                                     help: None,\n                                 };\n                             }\n \n-                            for field in &variant.fields {\n-                                let field_ty = cx.normalize_erasing_regions(\n-                                    ParamEnv::reveal_all(),\n-                                    field.ty(cx, substs),\n-                                );\n-                                // repr(transparent) types are allowed to have arbitrary ZSTs, not\n-                                // just PhantomData -- skip checking all ZST fields.\n-                                if def.repr.transparent() && field_ty.is_zst(cx, field.did) {\n-                                    continue;\n-                                }\n-                                let r = self.check_type_for_ffi(cache, field_ty);\n-                                match r {\n-                                    FfiSafe => {}\n-                                    FfiUnsafe { .. } => {\n-                                        return r;\n-                                    }\n-                                    FfiPhantom(..) => {\n-                                        return FfiUnsafe {\n-                                            ty,\n-                                            reason: \"this enum contains a PhantomData field\",\n-                                            help: None,\n-                                        };\n-                                    }\n-                                }\n+                            match self.check_variant_for_ffi(cache, ty, def, variant, substs) {\n+                                FfiSafe => (),\n+                                r => return r,\n                             }\n                         }\n+\n                         FfiSafe\n                     }\n                 }\n             }\n \n             ty::Char => FfiUnsafe {\n                 ty,\n-                reason: \"the `char` type has no C equivalent\",\n-                help: Some(\"consider using `u32` or `libc::wchar_t` instead\"),\n+                reason: \"the `char` type has no C equivalent\".into(),\n+                help: Some(\"consider using `u32` or `libc::wchar_t` instead\".into()),\n             },\n \n             ty::Int(ast::IntTy::I128) | ty::Uint(ast::UintTy::U128) => FfiUnsafe {\n                 ty,\n-                reason: \"128-bit integers don't currently have a known stable ABI\",\n+                reason: \"128-bit integers don't currently have a known stable ABI\".into(),\n                 help: None,\n             },\n \n@@ -829,24 +784,24 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::Slice(_) => FfiUnsafe {\n                 ty,\n-                reason: \"slices have no C equivalent\",\n-                help: Some(\"consider using a raw pointer instead\"),\n+                reason: \"slices have no C equivalent\".into(),\n+                help: Some(\"consider using a raw pointer instead\".into()),\n             },\n \n             ty::Dynamic(..) => {\n-                FfiUnsafe { ty, reason: \"trait objects have no C equivalent\", help: None }\n+                FfiUnsafe { ty, reason: \"trait objects have no C equivalent\".into(), help: None }\n             }\n \n             ty::Str => FfiUnsafe {\n                 ty,\n-                reason: \"string slices have no C equivalent\",\n-                help: Some(\"consider using `*const u8` and a length instead\"),\n+                reason: \"string slices have no C equivalent\".into(),\n+                help: Some(\"consider using `*const u8` and a length instead\".into()),\n             },\n \n             ty::Tuple(..) => FfiUnsafe {\n                 ty,\n-                reason: \"tuples have unspecified layout\",\n-                help: Some(\"consider using a struct instead\"),\n+                reason: \"tuples have unspecified layout\".into(),\n+                help: Some(\"consider using a struct instead\".into()),\n             },\n \n             ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => {\n@@ -860,10 +815,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic | Abi::RustCall => {\n                         return FfiUnsafe {\n                             ty,\n-                            reason: \"this function pointer has Rust-specific calling convention\",\n+                            reason: \"this function pointer has Rust-specific calling convention\"\n+                                .into(),\n                             help: Some(\n                                 \"consider using an `extern fn(...) -> ...` \\\n-                                        function pointer instead\",\n+                                        function pointer instead\"\n+                                    .into(),\n                             ),\n                         };\n                     }\n@@ -897,7 +854,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             // While opaque types are checked for earlier, if a projection in a struct field\n             // normalizes to an opaque type, then it will reach this branch.\n             ty::Opaque(..) => {\n-                FfiUnsafe { ty, reason: \"opaque types have no C equivalent\", help: None }\n+                FfiUnsafe { ty, reason: \"opaque types have no C equivalent\".into(), help: None }\n             }\n \n             ty::Param(..)\n@@ -1004,7 +961,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             // argument, which after substitution, is `()`, then this branch can be hit.\n             FfiResult::FfiUnsafe { ty, .. } if is_return_type && ty.is_unit() => return,\n             FfiResult::FfiUnsafe { ty, reason, help } => {\n-                self.emit_ffi_unsafe_type_lint(ty, sp, reason, help);\n+                self.emit_ffi_unsafe_type_lint(ty, sp, &reason, help.as_deref());\n             }\n         }\n     }"}, {"sha": "30643165ce9cc927f8d7f32359240618ff60f573", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0cccaa0a27499f742ed4dbf4b5d09beee08eb2d6/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cccaa0a27499f742ed4dbf4b5d09beee08eb2d6/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=0cccaa0a27499f742ed4dbf4b5d09beee08eb2d6", "patch": "@@ -1807,6 +1807,31 @@ impl<'tcx> VariantDef {\n     pub fn is_field_list_non_exhaustive(&self) -> bool {\n         self.flags.intersects(VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE)\n     }\n+\n+    /// `repr(transparent)` structs can have a single non-ZST field, this function returns that\n+    /// field.\n+    pub fn transparent_newtype_field(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+    ) -> Option<&FieldDef> {\n+        for field in &self.fields {\n+            let field_ty = field.ty(tcx, InternalSubsts::identity_for_item(tcx, self.def_id));\n+\n+            // `normalize_erasing_regions` will fail for projections that contain generic\n+            // parameters, so check these before normalizing.\n+            if field_ty.has_projections() && field_ty.needs_subst() {\n+                return Some(field);\n+            }\n+\n+            let field_ty = tcx.normalize_erasing_regions(param_env, field_ty);\n+            if !field_ty.is_zst(tcx, self.def_id) {\n+                return Some(field);\n+            }\n+        }\n+\n+        None\n+    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n@@ -2376,33 +2401,6 @@ impl<'tcx> AdtDef {\n     pub fn sized_constraint(&self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n         tcx.adt_sized_constraint(self.did).0\n     }\n-\n-    /// `repr(transparent)` structs can have a single non-ZST field, this function returns that\n-    /// field.\n-    pub fn transparent_newtype_field(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ParamEnv<'tcx>,\n-    ) -> Option<&FieldDef> {\n-        assert!(self.is_struct() && self.repr.transparent());\n-\n-        for field in &self.non_enum_variant().fields {\n-            let field_ty = field.ty(tcx, InternalSubsts::identity_for_item(tcx, self.did));\n-\n-            // `normalize_erasing_regions` will fail for projections that contain generic\n-            // parameters, so check these before normalizing.\n-            if field_ty.has_projections() && field_ty.needs_subst() {\n-                return Some(field);\n-            }\n-\n-            let field_ty = tcx.normalize_erasing_regions(param_env, field_ty);\n-            if !field_ty.is_zst(tcx, self.did) {\n-                return Some(field);\n-            }\n-        }\n-\n-        None\n-    }\n }\n \n impl<'tcx> FieldDef {"}]}