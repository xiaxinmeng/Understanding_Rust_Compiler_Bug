{"sha": "780b3853d13280ae67d1e196b54e80c47d63e88c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MGIzODUzZDEzMjgwYWU2N2QxZTE5NmI1NGU4MGM0N2Q2M2U4OGM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-09T01:50:19Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-09T02:27:20Z"}, "message": "rustc: Remove some uses of impl_map", "tree": {"sha": "1d1931341c2a25942faf22600f3e1f9c4c4b78e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d1931341c2a25942faf22600f3e1f9c4c4b78e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/780b3853d13280ae67d1e196b54e80c47d63e88c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/780b3853d13280ae67d1e196b54e80c47d63e88c", "html_url": "https://github.com/rust-lang/rust/commit/780b3853d13280ae67d1e196b54e80c47d63e88c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/780b3853d13280ae67d1e196b54e80c47d63e88c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71bc2673edc7ba52c012392266ed7b9480e0f6ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/71bc2673edc7ba52c012392266ed7b9480e0f6ec", "html_url": "https://github.com/rust-lang/rust/commit/71bc2673edc7ba52c012392266ed7b9480e0f6ec"}], "stats": {"total": 122, "additions": 3, "deletions": 119}, "files": [{"sha": "fefbb2bcc5f8c510e5fe67345080c3c9357482a4", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/780b3853d13280ae67d1e196b54e80c47d63e88c/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780b3853d13280ae67d1e196b54e80c47d63e88c/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=780b3853d13280ae67d1e196b54e80c47d63e88c", "patch": "@@ -195,7 +195,6 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n \n     let (method_map, vtable_map) = time(time_passes, ~\"typechecking\", ||\n                                         typeck::check_crate(ty_cx,\n-                                                            impl_map,\n                                                             trait_map,\n                                                             crate));\n     // These next two const passes can probably be merged"}, {"sha": "c4c563162d55682ae87a49e7a4b6e5c213a7c0c2", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 1, "deletions": 78, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/780b3853d13280ae67d1e196b54e80c47d63e88c/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780b3853d13280ae67d1e196b54e80c47d63e88c/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=780b3853d13280ae67d1e196b54e80c47d63e88c", "patch": "@@ -1,5 +1,5 @@\n import driver::session::session;\n-import metadata::csearch::{each_path, get_impls_for_mod};\n+import metadata::csearch::{each_path};\n import metadata::csearch::{get_method_names_if_trait, lookup_defs};\n import metadata::cstore::find_use_stmt_cnum;\n import metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n@@ -1565,83 +1565,6 @@ class Resolver {\n                 }\n             }\n         }\n-\n-        // Create nodes for all the impls.\n-        self.build_reduced_graph_for_impls_in_external_module_subtree(root);\n-    }\n-\n-    fn build_reduced_graph_for_impls_in_external_module_subtree(module_:\n-                                                                @Module) {\n-        self.build_reduced_graph_for_impls_in_external_module(module_);\n-\n-        for module_.children.each |_name, child_node| {\n-            match (*child_node).get_module_if_available() {\n-                none => {\n-                    // Nothing to do.\n-                }\n-                some(child_module) => {\n-                    self.\n-                    build_reduced_graph_for_impls_in_external_module_subtree\n-                        (child_module);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn build_reduced_graph_for_impls_in_external_module(module_: @Module) {\n-        // XXX: This is really unfortunate. decoder::each_path can produce\n-        // false positives, since, in the crate metadata, a trait named 'bar'\n-        // in module 'foo' defining a method named 'baz' will result in the\n-        // creation of a (bogus) path entry named 'foo::bar::baz', and we will\n-        // create a module node for \"bar\". We can identify these fake modules\n-        // by the fact that they have no def ID, which we do here in order to\n-        // skip them.\n-\n-        debug!{\"(building reduced graph for impls in external crate) looking \\\n-                for impls in `%s` (%?)\",\n-               self.module_to_str(module_),\n-               copy module_.def_id};\n-\n-        match module_.def_id {\n-            none => {\n-                debug!{\"(building reduced graph for impls in external \\\n-                        module) no def ID for `%s`, skipping\",\n-                       self.module_to_str(module_)};\n-                return;\n-            }\n-            some(_) => {\n-                // Continue.\n-            }\n-        }\n-\n-        let impls_in_module = get_impls_for_mod(self.session.cstore,\n-                                                get(module_.def_id),\n-                                                none);\n-\n-        // Intern def IDs to prevent duplicates.\n-        let def_ids = new_def_hash();\n-\n-        for (*impls_in_module).each |implementation| {\n-            if def_ids.contains_key(implementation.did) {\n-                again;\n-            }\n-            def_ids.insert(implementation.did, ());\n-\n-            debug!{\"(building reduced graph for impls in external module) \\\n-                    added impl `%s` (%?) to `%s`\",\n-                   *implementation.ident,\n-                   implementation.did,\n-                   self.module_to_str(module_)};\n-\n-            let name = (*self.atom_table).intern(implementation.ident);\n-\n-            let (name_bindings, _) =\n-                    // Might want a better span\n-                self.add_child(name, ModuleReducedGraphParent(module_),\n-                              ~[ImplNS], dummy_sp());\n-\n-            name_bindings.impl_defs += ~[implementation];\n-        }\n     }\n \n     /// Creates and adds an import directive to the given module."}, {"sha": "f19685d8ee9fcc9890232b5cd299ade06084b2fa", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/780b3853d13280ae67d1e196b54e80c47d63e88c/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780b3853d13280ae67d1e196b54e80c47d63e88c/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=780b3853d13280ae67d1e196b54e80c47d63e88c", "patch": "@@ -158,9 +158,7 @@ type provided_methods_map = hashmap<ast::node_id,\n \n type ty_param_substs_and_ty = {substs: ty::substs, ty: ty::t};\n \n-type crate_ctxt_ = {impl_map: resolve3::ImplMap,\n-\n-                    // A mapping from method call sites to traits that have\n+type crate_ctxt_ = {// A mapping from method call sites to traits that have\n                     // that method.\n                     trait_map: resolve3::TraitMap,\n                     method_map: method_map,\n@@ -299,13 +297,11 @@ fn check_for_main_fn(ccx: @crate_ctxt) {\n }\n \n fn check_crate(tcx: ty::ctxt,\n-               impl_map: resolve3::ImplMap,\n                trait_map: resolve3::TraitMap,\n                crate: @ast::crate)\n             -> (method_map, vtable_map) {\n \n-    let ccx = @crate_ctxt_({impl_map: impl_map,\n-                            trait_map: trait_map,\n+    let ccx = @crate_ctxt_({trait_map: trait_map,\n                             method_map: std::map::int_hash(),\n                             vtable_map: std::map::int_hash(),\n                             coherence_info: @coherence::CoherenceInfo(),"}, {"sha": "a552b4201e6919f7eb4babd0c69e925eca3b85e8", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/780b3853d13280ae67d1e196b54e80c47d63e88c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780b3853d13280ae67d1e196b54e80c47d63e88c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=780b3853d13280ae67d1e196b54e80c47d63e88c", "patch": "@@ -138,20 +138,13 @@ class lookup {\n             // it.\n             if self.candidates.len() > 0u { break; }\n \n-            // now look for impls in scope, but don't look for impls that\n-            // would require doing an implicit borrow of the lhs.\n-            self.add_candidates_from_scope(false);\n-\n             // Look for inherent methods.\n             self.add_inherent_and_extension_candidates\n                 (optional_inherent_methods, false);\n \n             // if we found anything, stop before trying borrows\n             if self.candidates.len() > 0u { break; }\n \n-            // now look for impls in scope that might require a borrow\n-            self.add_candidates_from_scope(true);\n-\n             // Again, look for inherent methods.\n             self.add_inherent_and_extension_candidates\n                 (optional_inherent_methods, true);\n@@ -364,33 +357,6 @@ class lookup {\n         */\n     }\n \n-    fn add_candidates_from_scope(use_assignability: bool) {\n-\n-        // If we're using coherence and this is one of the method invocation\n-        // forms it supports, don't use this method; it'll result in lots of\n-        // multiple-methods-in-scope errors.\n-        if self.fcx.ccx.trait_map.contains_key(self.expr.id) {\n-            return;\n-        }\n-\n-        let impls_vecs = self.fcx.ccx.impl_map.get(self.expr.id);\n-        let mut added_any = false;\n-\n-        debug!{\"method_from_scope\"};\n-\n-        for list::each(impls_vecs) |impls| {\n-            for vec::each(*impls) |im| {\n-                if self.add_candidates_from_impl(im, use_assignability) {\n-                    added_any = true;\n-                }\n-            }\n-\n-            // we want to find the innermost scope that has any\n-            // matches and then ignore outer scopes\n-            if added_any {return;}\n-        }\n-    }\n-\n     // Returns true if any were added and false otherwise.\n     fn add_candidates_from_impl(im: @resolve3::Impl,\n                                 use_assignability: bool) -> bool {"}]}