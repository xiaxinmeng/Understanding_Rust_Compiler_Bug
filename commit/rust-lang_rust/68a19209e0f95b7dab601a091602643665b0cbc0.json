{"sha": "68a19209e0f95b7dab601a091602643665b0cbc0", "node_id": "C_kwDOAAsO6NoAKDY4YTE5MjA5ZTBmOTViN2RhYjYwMWEwOTE2MDI2NDM2NjViMGNiYzA", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-12-08T02:59:29Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-12-08T02:59:29Z"}, "message": "Inline and remove `place_contents_drop_state_cannot_differ`.\n\nIt has a single call site and is hot enough to be worth inlining. And\nmake sure `is_terminal_path` is inlined, too.", "tree": {"sha": "c6e56315c9287fa6df044cdc82d9d6dfba1d76da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6e56315c9287fa6df044cdc82d9d6dfba1d76da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68a19209e0f95b7dab601a091602643665b0cbc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68a19209e0f95b7dab601a091602643665b0cbc0", "html_url": "https://github.com/rust-lang/rust/commit/68a19209e0f95b7dab601a091602643665b0cbc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68a19209e0f95b7dab601a091602643665b0cbc0/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e491d2b24da8c11c902bb836d189590600f26caf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e491d2b24da8c11c902bb836d189590600f26caf", "html_url": "https://github.com/rust-lang/rust/commit/e491d2b24da8c11c902bb836d189590600f26caf"}], "stats": {"total": 97, "additions": 46, "deletions": 51}, "files": [{"sha": "3224e13f7af4bfe9da8c9fd3b045edadee2b5496", "filename": "compiler/rustc_mir_dataflow/src/drop_flag_effects.rs", "status": "modified", "additions": 46, "deletions": 51, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/68a19209e0f95b7dab601a091602643665b0cbc0/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a19209e0f95b7dab601a091602643665b0cbc0/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs?ref=68a19209e0f95b7dab601a091602643665b0cbc0", "patch": "@@ -29,56 +29,6 @@ where\n     None\n }\n \n-/// When enumerating the child fragments of a path, don't recurse into\n-/// paths (1.) past arrays, slices, and pointers, nor (2.) into a type\n-/// that implements `Drop`.\n-///\n-/// Places behind references or arrays are not tracked by elaboration\n-/// and are always assumed to be initialized when accessible. As\n-/// references and indexes can be reseated, trying to track them can\n-/// only lead to trouble.\n-///\n-/// Places behind ADT's with a Drop impl are not tracked by\n-/// elaboration since they can never have a drop-flag state that\n-/// differs from that of the parent with the Drop impl.\n-///\n-/// In both cases, the contents can only be accessed if and only if\n-/// their parents are initialized. This implies for example that there\n-/// is no need to maintain separate drop flags to track such state.\n-//\n-// FIXME: we have to do something for moving slice patterns.\n-fn place_contents_drop_state_cannot_differ<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n-    place: mir::Place<'tcx>,\n-) -> bool {\n-    let ty = place.ty(body, tcx).ty;\n-    match ty.kind() {\n-        ty::Array(..) => {\n-            debug!(\n-                \"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} => false\",\n-                place, ty\n-            );\n-            false\n-        }\n-        ty::Slice(..) | ty::Ref(..) | ty::RawPtr(..) => {\n-            debug!(\n-                \"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} refd => true\",\n-                place, ty\n-            );\n-            true\n-        }\n-        ty::Adt(def, _) if (def.has_dtor(tcx) && !def.is_box()) || def.is_union() => {\n-            debug!(\n-                \"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} Drop => true\",\n-                place, ty\n-            );\n-            true\n-        }\n-        _ => false,\n-    }\n-}\n-\n pub fn on_lookup_result_bits<'tcx, F>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n@@ -105,13 +55,58 @@ pub fn on_all_children_bits<'tcx, F>(\n ) where\n     F: FnMut(MovePathIndex),\n {\n+    #[inline]\n     fn is_terminal_path<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n         path: MovePathIndex,\n     ) -> bool {\n-        place_contents_drop_state_cannot_differ(tcx, body, move_data.move_paths[path].place)\n+        let place = move_data.move_paths[path].place;\n+\n+        // When enumerating the child fragments of a path, don't recurse into\n+        // paths (1.) past arrays, slices, and pointers, nor (2.) into a type\n+        // that implements `Drop`.\n+        //\n+        // Places behind references or arrays are not tracked by elaboration\n+        // and are always assumed to be initialized when accessible. As\n+        // references and indexes can be reseated, trying to track them can\n+        // only lead to trouble.\n+        //\n+        // Places behind ADT's with a Drop impl are not tracked by\n+        // elaboration since they can never have a drop-flag state that\n+        // differs from that of the parent with the Drop impl.\n+        //\n+        // In both cases, the contents can only be accessed if and only if\n+        // their parents are initialized. This implies for example that there\n+        // is no need to maintain separate drop flags to track such state.\n+        //\n+        // FIXME: we have to do something for moving slice patterns.\n+        let ty = place.ty(body, tcx).ty;\n+        match ty.kind() {\n+            ty::Adt(def, _) if (def.has_dtor(tcx) && !def.is_box()) || def.is_union() => {\n+                debug!(\n+                    \"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} Drop => true\",\n+                    place, ty\n+                );\n+                true\n+            }\n+            ty::Array(..) => {\n+                debug!(\n+                    \"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} => false\",\n+                    place, ty\n+                );\n+                false\n+            }\n+            ty::Slice(..) | ty::Ref(..) | ty::RawPtr(..) => {\n+                debug!(\n+                    \"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} refd => true\",\n+                    place, ty\n+                );\n+                true\n+            }\n+            _ => false,\n+        }\n     }\n \n     fn on_all_children_bits<'tcx, F>("}]}