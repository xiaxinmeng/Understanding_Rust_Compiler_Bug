{"sha": "9d20ed7bf97e533e0cc5d7be2c3ec5d5dfd30e98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMjBlZDdiZjk3ZTUzM2UwY2M1ZDdiZTJjM2VjNWQ1ZGZkMzBlOTg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-21T16:02:02Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-21T16:08:14Z"}, "message": "Clean up unification code", "tree": {"sha": "3d71c5f084d1e84374cf532ad9dfe257c899ba96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d71c5f084d1e84374cf532ad9dfe257c899ba96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d20ed7bf97e533e0cc5d7be2c3ec5d5dfd30e98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d20ed7bf97e533e0cc5d7be2c3ec5d5dfd30e98", "html_url": "https://github.com/rust-lang/rust/commit/9d20ed7bf97e533e0cc5d7be2c3ec5d5dfd30e98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d20ed7bf97e533e0cc5d7be2c3ec5d5dfd30e98/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff927f18f5b118bd26ba8a0826b317c27daba70d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff927f18f5b118bd26ba8a0826b317c27daba70d", "html_url": "https://github.com/rust-lang/rust/commit/ff927f18f5b118bd26ba8a0826b317c27daba70d"}], "stats": {"total": 444, "additions": 116, "deletions": 328}, "files": [{"sha": "6b0c6f5d1dcc572ca16eea68365c4e50118c77a5", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 116, "deletions": 328, "changes": 444, "blob_url": "https://github.com/rust-lang/rust/blob/9d20ed7bf97e533e0cc5d7be2c3ec5d5dfd30e98/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d20ed7bf97e533e0cc5d7be2c3ec5d5dfd30e98/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=9d20ed7bf97e533e0cc5d7be2c3ec5d5dfd30e98", "patch": "@@ -258,6 +258,7 @@ enum type_err {\n     terr_mismatch,\n     terr_ret_style_mismatch(ast::ret_style, ast::ret_style),\n     terr_box_mutability,\n+    terr_ptr_mutability,\n     terr_vec_mutability,\n     terr_tuple_size(uint, uint),\n     terr_record_size(uint, uint),\n@@ -1557,26 +1558,9 @@ mod unify {\n         }\n     }\n \n-    fn record_var_binding_for_expected(\n-        cx: @uctxt, key: int, typ: t, variance: variance) -> result {\n-        record_var_binding(\n-            cx, key, typ, variance_transform(variance, covariant))\n-    }\n-\n-    fn record_var_binding_for_actual(\n-        cx: @uctxt, key: int, typ: t, variance: variance) -> result {\n-        // Unifying in 'the other direction' so flip the variance\n-        record_var_binding(\n-            cx, key, typ, variance_transform(variance, contravariant))\n-    }\n-\n-    fn record_var_binding(\n-        cx: @uctxt, key: int, typ: t, variance: variance) -> result {\n-\n-        let vb = alt cx.st { in_bindings(vb) { vb }\n-            _ { cx.tcx.sess.bug(\"Someone forgot to document an invariant \\\n-                 in record_var_binding\");  }\n-        };\n+    fn record_var_binding(cx: @uctxt, key: int, typ: t, variance: variance)\n+        -> result {\n+        let vb = alt check cx.st { in_bindings(vb) { vb } };\n         ufind::grow(vb.sets, (key as uint) + 1u);\n         let root = ufind::find(vb.sets, key as uint);\n         let result_type = typ;\n@@ -1589,8 +1573,8 @@ mod unify {\n           }\n           none {/* fall through */ }\n         }\n-        smallintmap::insert::<t>(vb.types, root, result_type);\n-        ret ures_ok(typ);\n+        smallintmap::insert(vb.types, root, result_type);\n+        ret ures_ok(mk_var(cx.tcx, key));\n     }\n \n     // Simple structural type comparison.\n@@ -1837,7 +1821,7 @@ mod unify {\n     }\n \n     fn unify_tps(cx: @uctxt, expected_tps: [t], actual_tps: [t],\n-                 variance: variance, finish: fn([t]) -> result) -> result {\n+                 variance: variance, finish: fn([t]) -> t) -> result {\n         let result_tps = [], i = 0u;\n         for exp in expected_tps {\n             let act = actual_tps[i];\n@@ -1848,345 +1832,148 @@ mod unify {\n               _ { ret result; }\n             }\n         }\n-        finish(result_tps)\n+        ures_ok(finish(result_tps))\n+    }\n+    fn unify_mt(cx: @uctxt, e_mt: mt, a_mt: mt, variance: variance,\n+                mut_err: type_err, finish: fn(ctxt, mt) -> t) -> result {\n+        alt unify_mut(e_mt.mutbl, a_mt.mutbl, variance) {\n+          none { ures_err(mut_err) }\n+          some((mutt, var)) {\n+            alt unify_step(cx, e_mt.ty, a_mt.ty, var) {\n+              ures_ok(result_sub) {\n+                ures_ok(finish(cx.tcx, {ty: result_sub, mutbl: mutt}))\n+              }\n+              err { err }\n+            }\n+          }\n+        }\n     }\n+\n     fn unify_step(cx: @uctxt, expected: t, actual: t,\n                   variance: variance) -> result {\n-        // FIXME: rewrite this using tuple pattern matching when available, to\n-        // avoid all this rightward drift and spikiness.\n-        // NOTE: we have tuple matching now, but that involves copying the\n-        // matched elements into a tuple first, which is expensive, since sty\n-        // holds vectors, which are currently unique\n-\n         // Fast path.\n         if expected == actual { ret ures_ok(expected); }\n \n-        // Stage 1: Handle the cases in which one side or another is a type\n-        // variable\n-\n-        alt get(actual).struct {\n-          // If the RHS is a variable type, then just do the\n-          // appropriate binding.\n-          ty_var(actual_id) {\n-            let actual_n = actual_id as uint;\n-            alt get(expected).struct {\n-              ty_var(expected_id) {\n-                let expected_n = expected_id as uint;\n-                alt union(cx, expected_n, actual_n, variance) {\n-                  unres_ok {/* fall through */ }\n-                  unres_err(t_e) { ret ures_err(t_e); }\n-                }\n-              }\n-              _ {\n-                // Just bind the type variable to the expected type.\n-                alt record_var_binding_for_actual(\n-                    cx, actual_id, expected, variance) {\n-                  ures_ok(_) {/* fall through */ }\n-                  rs { ret rs; }\n-                }\n-              }\n+        alt (get(expected).struct, get(actual).struct) {\n+          (ty_var(e_id), ty_var(a_id)) {\n+            alt union(cx, e_id as uint, a_id as uint, variance) {\n+              unres_ok { ures_ok(actual) }\n+              unres_err(err) { ures_err(err) }\n             }\n-            ret ures_ok(mk_var(cx.tcx, actual_id));\n           }\n-          _ {/* empty */ }\n-        }\n-        alt get(expected).struct {\n-          ty_var(expected_id) {\n-            // Add a binding. (`actual` can't actually be a var here.)\n-            alt record_var_binding_for_expected(\n-                cx, expected_id, actual,\n-                variance) {\n-              ures_ok(_) {/* fall through */ }\n-              rs { ret rs; }\n-            }\n-            ret ures_ok(mk_var(cx.tcx, expected_id));\n+          (_, ty_var(a_id)) {\n+            let v = variance_transform(variance, contravariant);\n+            record_var_binding(cx, a_id, expected, v)\n           }\n-          _ {/* fall through */ }\n-        }\n-        // Stage 2: Handle all other cases.\n-\n-        alt get(actual).struct {\n-          ty_bot { ret ures_ok(expected); }\n-          _ {/* fall through */ }\n-        }\n-        alt get(expected).struct {\n-          ty_nil { ret struct_cmp(cx, expected, actual); }\n-          // _|_ unifies with anything\n-          ty_bot {\n-            ret ures_ok(actual);\n+          (ty_var(e_id), _) {\n+            let v = variance_transform(variance, covariant);\n+            record_var_binding(cx, e_id, actual, v)\n           }\n-          ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-          ty_str | ty_send_type {\n-            ret struct_cmp(cx, expected, actual);\n+          (_, ty_bot) { ures_ok(expected) }\n+          (ty_bot, _) { ures_ok(actual) }\n+          (ty_nil, _) | (ty_bool, _) | (ty_int(_), _) | (ty_uint(_), _) |\n+          (ty_float(_), _) | (ty_str, _) | (ty_send_type, _) {\n+            struct_cmp(cx, expected, actual)\n           }\n-          ty_param(expected_n, _) {\n-            alt get(actual).struct {\n-              ty_param(actual_n, _) if expected_n == actual_n {\n-                ret ures_ok(expected);\n-              }\n-              _ { ret ures_err(terr_mismatch); }\n-            }\n+          (ty_param(e_n, _), ty_param(a_n, _)) if e_n == a_n {\n+            ures_ok(expected)\n           }\n-          ty_enum(expected_id, expected_tps) {\n-            alt get(actual).struct {\n-              ty_enum(actual_id, actual_tps) {\n-                if expected_id != actual_id {\n-                    ret ures_err(terr_mismatch);\n-                }\n-                ret unify_tps(cx, expected_tps, actual_tps, variance, {|tps|\n-                    ures_ok(mk_enum(cx.tcx, expected_id, tps))\n-                });\n-              }\n-              _ {/* fall through */ }\n-            }\n-            ret ures_err(terr_mismatch);\n+          (ty_enum(e_id, e_tps), ty_enum(a_id, a_tps)) if e_id == a_id {\n+            unify_tps(cx, e_tps, a_tps, variance, {|tps|\n+                mk_enum(cx.tcx, e_id, tps)\n+            })\n           }\n-          ty_iface(expected_id, expected_tps) {\n-            alt get(actual).struct {\n-              ty_iface(actual_id, actual_tps) {\n-                if expected_id != actual_id {\n-                    ret ures_err(terr_mismatch);\n-                }\n-                ret unify_tps(cx, expected_tps, actual_tps, variance, {|tps|\n-                    ures_ok(mk_iface(cx.tcx, expected_id, tps))\n-                });\n-              }\n-              _ {}\n-            }\n-            ret ures_err(terr_mismatch);\n+          (ty_iface(e_id, e_tps), ty_iface(a_id, a_tps)) if e_id == a_id {\n+            unify_tps(cx, e_tps, a_tps, variance, {|tps|\n+                mk_iface(cx.tcx, e_id, tps)\n+            })\n           }\n-          ty_box(expected_mt) {\n-            alt get(actual).struct {\n-              ty_box(actual_mt) {\n-                let (mutt, var) = alt unify_mut(\n-                    expected_mt.mutbl, actual_mt.mutbl, variance) {\n-                  none { ret ures_err(terr_box_mutability); }\n-                  some(mv) { mv }\n-                };\n-                let result = unify_step(\n-                    cx, expected_mt.ty, actual_mt.ty, var);\n-                alt result {\n-                  ures_ok(result_sub) {\n-                    let mt = {ty: result_sub, mutbl: mutt};\n-                    ret ures_ok(mk_box(cx.tcx, mt));\n-                  }\n-                  _ { ret result; }\n-                }\n-              }\n-              _ { ret ures_err(terr_mismatch); }\n-            }\n+          (ty_class(e_id, e_tps), ty_class(a_id, a_tps)) if e_id == a_id {\n+            unify_tps(cx, e_tps, a_tps, variance, {|tps|\n+                mk_class(cx.tcx, e_id, tps)\n+            })\n           }\n-          ty_uniq(expected_mt) {\n-            alt get(actual).struct {\n-              ty_uniq(actual_mt) {\n-                let (mutt, var) = alt unify_mut(\n-                    expected_mt.mutbl, actual_mt.mutbl, variance) {\n-                  none { ret ures_err(terr_box_mutability); }\n-                  some(mv) { mv }\n-                };\n-                let result = unify_step(\n-                    cx, expected_mt.ty, actual_mt.ty, var);\n-                alt result {\n-                  ures_ok(result_mt) {\n-                    let mt = {ty: result_mt, mutbl: mutt};\n-                    ret ures_ok(mk_uniq(cx.tcx, mt));\n-                  }\n-                  _ { ret result; }\n-                }\n-              }\n-              _ { ret ures_err(terr_mismatch); }\n-            }\n+          (ty_box(e_mt), ty_box(a_mt)) {\n+            unify_mt(cx, e_mt, a_mt, variance, terr_box_mutability, mk_box)\n           }\n-          ty_vec(expected_mt) {\n-            alt get(actual).struct {\n-              ty_vec(actual_mt) {\n-                let (mutt, var) = alt unify_mut(\n-                    expected_mt.mutbl, actual_mt.mutbl, variance) {\n-                  none { ret ures_err(terr_vec_mutability); }\n-                  some(mv) { mv }\n-                };\n-                let result = unify_step(\n-                    cx, expected_mt.ty, actual_mt.ty, var);\n-                alt result {\n-                  ures_ok(result_sub) {\n-                    let mt = {ty: result_sub, mutbl: mutt};\n-                    ret ures_ok(mk_vec(cx.tcx, mt));\n-                  }\n-                  _ { ret result; }\n-                }\n-              }\n-              _ { ret ures_err(terr_mismatch); }\n-            }\n+          (ty_uniq(e_mt), ty_uniq(a_mt)) {\n+            unify_mt(cx, e_mt, a_mt, variance, terr_box_mutability, mk_uniq)\n           }\n-          ty_ptr(expected_mt) {\n-            alt get(actual).struct {\n-              ty_ptr(actual_mt) {\n-                let (mutt, var) = alt unify_mut(\n-                    expected_mt.mutbl, actual_mt.mutbl, variance) {\n-                  none { ret ures_err(terr_vec_mutability); }\n-                  some(mv) { mv }\n-                };\n-                let result = unify_step(\n-                    cx, expected_mt.ty, actual_mt.ty, var);\n-                alt result {\n-                  ures_ok(result_sub) {\n-                    let mt = {ty: result_sub, mutbl: mutt};\n-                    ret ures_ok(mk_ptr(cx.tcx, mt));\n-                  }\n-                  _ { ret result; }\n-                }\n-              }\n-              _ { ret ures_err(terr_mismatch); }\n-            }\n+          (ty_vec(e_mt), ty_vec(a_mt)) {\n+            unify_mt(cx, e_mt, a_mt, variance, terr_vec_mutability, mk_vec)\n           }\n-          ty_res(ex_id, ex_inner, ex_tps) {\n-            alt get(actual).struct {\n-              ty_res(act_id, act_inner, act_tps) {\n-                if ex_id.crate != act_id.crate || ex_id.node != act_id.node {\n-                    ret ures_err(terr_mismatch);\n-                }\n-                let result = unify_step(\n-                    cx, ex_inner, act_inner, variance);\n-                alt result {\n-                  ures_ok(res_inner) {\n-                    let i = 0u;\n-                    let res_tps = [];\n-                    for ex_tp: t in ex_tps {\n-                        let result = unify_step(\n-                            cx, ex_tp, act_tps[i], variance);\n-                        alt result {\n-                          ures_ok(rty) { res_tps += [rty]; }\n-                          _ { ret result; }\n-                        }\n-                        i += 1u;\n-                    }\n-                    ret ures_ok(mk_res(cx.tcx, act_id, res_inner, res_tps));\n-                  }\n-                  _ { ret result; }\n-                }\n+          (ty_ptr(e_mt), ty_ptr(a_mt)) {\n+            unify_mt(cx, e_mt, a_mt, variance, terr_ptr_mutability, mk_ptr)\n+          }\n+          (ty_res(e_id, e_inner, e_tps), ty_res(a_id, a_inner, a_tps))\n+          if e_id == a_id {\n+            alt unify_step(cx, e_inner, a_inner, variance) {\n+              ures_ok(res_inner) {\n+                unify_tps(cx, e_tps, a_tps, variance, {|tps|\n+                    mk_res(cx.tcx, a_id, res_inner, tps)\n+                })\n               }\n-              _ { ret ures_err(terr_mismatch); }\n+              err { err }\n             }\n           }\n-          ty_rec(expected_fields) {\n-            alt get(actual).struct {\n-              ty_rec(actual_fields) {\n-                let expected_len = vec::len::<field>(expected_fields);\n-                let actual_len = vec::len::<field>(actual_fields);\n-                if expected_len != actual_len {\n-                    let err = terr_record_size(expected_len, actual_len);\n-                    ret ures_err(err);\n+          (ty_rec(e_fields), ty_rec(a_fields)) {\n+            let e_len = e_fields.len(), a_len = a_fields.len();\n+            if e_len != a_len {\n+                ret ures_err(terr_record_size(e_len, a_len));\n+            }\n+            let result_fields = [], i = 0u;\n+            while i < a_len {\n+                let e_field = e_fields[i], a_field = a_fields[i];\n+                if e_field.ident != a_field.ident {\n+                    ret ures_err(terr_record_fields(e_field.ident,\n+                                                    a_field.ident));\n                 }\n-\n-                let result_fields = [], i = 0u;\n-                while i < actual_len {\n-                    let expected_field = expected_fields[i],\n-                        actual_field = actual_fields[i];\n-                    let u_mut = unify_mut(expected_field.mt.mutbl,\n-                                          actual_field.mt.mutbl,\n-                                          variance);\n-                    let (mutt, var) = alt u_mut {\n-                      none { ret ures_err(terr_record_mutability); }\n-                      some(mv) { mv }\n-                    };\n-                    if !str::eq(expected_field.ident, actual_field.ident) {\n-                        let err =\n-                            terr_record_fields(expected_field.ident,\n-                                               actual_field.ident);\n-                        ret ures_err(err);\n-                    }\n-                    let result =\n-                        unify_step(cx, expected_field.mt.ty,\n-                                   actual_field.mt.ty, var);\n-                    alt result {\n-                      ures_ok(rty) {\n-                        let mt = {ty: rty, mutbl: mutt};\n-                        result_fields += [{mt: mt with expected_field}];\n-                      }\n-                      _ { ret result; }\n-                    }\n-                    i += 1u;\n+                alt unify_mt(cx, e_field.mt, a_field.mt, variance,\n+                             terr_record_mutability, {|cx, mt|\n+                    result_fields += [{mt: mt with e_field}];\n+                    mk_nil(cx)\n+                }) {\n+                  ures_ok(_) {}\n+                  err { ret err; }\n                 }\n-                ret ures_ok(mk_rec(cx.tcx, result_fields));\n-              }\n-              _ { ret ures_err(terr_mismatch); }\n+                i += 1u;\n             }\n+            ures_ok(mk_rec(cx.tcx, result_fields))\n           }\n-          ty_tup(expected_elems) {\n-            alt get(actual).struct {\n-              ty_tup(actual_elems) {\n-                let expected_len = vec::len(expected_elems);\n-                let actual_len = vec::len(actual_elems);\n-                if expected_len != actual_len {\n-                    let err = terr_tuple_size(expected_len, actual_len);\n-                    ret ures_err(err);\n+          (ty_tup(e_elems), ty_tup(a_elems)) {\n+            let e_len = e_elems.len(), a_len = a_elems.len();\n+            if e_len != a_len { ret ures_err(terr_tuple_size(e_len, a_len)); }\n+            let result_elems = [], i = 0u;\n+            while i < a_len {\n+                alt unify_step(cx, e_elems[i], a_elems[i], variance) {\n+                  ures_ok(rty) { result_elems += [rty]; }\n+                  err { ret err; }\n                 }\n-\n-                let result_elems = [], i = 0u;\n-                while i < actual_len {\n-                    alt unify_step(cx, expected_elems[i], actual_elems[i],\n-                                   variance) {\n-                      ures_ok(rty) { result_elems += [rty]; }\n-                      r { ret r; }\n-                    }\n-                    i += 1u;\n-                }\n-                ret ures_ok(mk_tup(cx.tcx, result_elems));\n-              }\n-              _ { ret ures_err(terr_mismatch); }\n+                i += 1u;\n             }\n+            ures_ok(mk_tup(cx.tcx, result_elems))\n           }\n-          ty_fn(expected_f) {\n-            alt get(actual).struct {\n-              ty_fn(actual_f) {\n-                ret unify_fn(cx, expected_f, actual_f, variance);\n-              }\n-              _ { ret ures_err(terr_mismatch); }\n-            }\n+          (ty_fn(e_fty), ty_fn(a_fty)) {\n+            unify_fn(cx, e_fty, a_fty, variance)\n           }\n-          ty_constr(expected_t, expected_constrs) {\n-\n+          (ty_constr(e_t, e_constrs), ty_constr(a_t, a_constrs)) {\n             // unify the base types...\n-            alt get(actual).struct {\n-              ty_constr(actual_t, actual_constrs) {\n-                let rslt = unify_step(\n-                    cx, expected_t, actual_t, variance);\n-                alt rslt {\n-                  ures_ok(rty) {\n-                    // FIXME: probably too restrictive --\n-                    // requires the constraints to be\n-                    // syntactically equal\n-                    ret unify_constrs(expected, expected_constrs,\n-                                      actual_constrs);\n-                  }\n-                  _ { ret rslt; }\n-                }\n-              }\n-              _ {\n-                // If the actual type is *not* a constrained type,\n-                // then we go ahead and just ignore the constraints on\n-                // the expected type. typestate handles the rest.\n-                ret unify_step(\n-                    cx, expected_t, actual, variance);\n+            alt unify_step(cx, e_t, a_t, variance) {\n+              ures_ok(rty) {\n+                // FIXME: probably too restrictive --\n+                // requires the constraints to be syntactically equal\n+                unify_constrs(expected, e_constrs, a_constrs)\n               }\n+              err { err }\n             }\n           }\n-          ty_class(expected_class, expected_tys) {\n-              alt get(actual).struct {\n-                ty_class(actual_class, actual_tys) {\n-                    if expected_class != actual_class {\n-                        ret ures_err(terr_mismatch);\n-                    }\n-                    ret unify_tps(cx, expected_tys, actual_tys, variance,\n-                           {|tps|\n-                            ures_ok(mk_class(cx.tcx, expected_class, tps))});\n-                }\n-                _ {\n-                    ret ures_err(terr_mismatch);\n-                }\n-              }\n+          (ty_constr(e_t, _), _) {\n+            // If the actual type is *not* a constrained type,\n+            // then we go ahead and just ignore the constraints on\n+            // the expected type. typestate handles the rest.\n+            unify_step(cx, e_t, actual, variance)\n           }\n-          _ { cx.tcx.sess.bug(\"unify: unexpected type\"); }\n+          _ { ures_err(terr_mismatch) }\n         }\n     }\n     fn unify(expected: t, actual: t, st: unify_style,\n@@ -2293,6 +2080,7 @@ fn type_err_to_str(err: type_err) -> str {\n       }\n       terr_box_mutability { ret \"boxed values differ in mutability\"; }\n       terr_vec_mutability { ret \"vectors differ in mutability\"; }\n+      terr_ptr_mutability { ret \"pointers differ in mutability\"; }\n       terr_tuple_size(e_sz, a_sz) {\n         ret \"expected a tuple with \" + uint::to_str(e_sz, 10u) +\n                 \" elements but found one with \" + uint::to_str(a_sz, 10u) +"}]}