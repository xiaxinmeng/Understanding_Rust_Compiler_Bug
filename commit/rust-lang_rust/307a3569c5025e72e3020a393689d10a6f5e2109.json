{"sha": "307a3569c5025e72e3020a393689d10a6f5e2109", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwN2EzNTY5YzUwMjVlNzJlMzAyMGEzOTM2ODlkMTBhNmY1ZTIxMDk=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-10-10T08:29:03Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-10-14T09:06:20Z"}, "message": "Sort long error code explanation by error code", "tree": {"sha": "b824250ae39b0667ca20291c4584ffef37dd8373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b824250ae39b0667ca20291c4584ffef37dd8373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/307a3569c5025e72e3020a393689d10a6f5e2109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/307a3569c5025e72e3020a393689d10a6f5e2109", "html_url": "https://github.com/rust-lang/rust/commit/307a3569c5025e72e3020a393689d10a6f5e2109", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/307a3569c5025e72e3020a393689d10a6f5e2109/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d28a9c38fe14396e86ae274c7847e20ee0f78ca9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d28a9c38fe14396e86ae274c7847e20ee0f78ca9", "html_url": "https://github.com/rust-lang/rust/commit/d28a9c38fe14396e86ae274c7847e20ee0f78ca9"}], "stats": {"total": 406, "additions": 203, "deletions": 203}, "files": [{"sha": "b2d7bc6a30661675ddf4d443cf8ada0f20844f7f", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 203, "deletions": 203, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/307a3569c5025e72e3020a393689d10a6f5e2109/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307a3569c5025e72e3020a393689d10a6f5e2109/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=307a3569c5025e72e3020a393689d10a6f5e2109", "patch": "@@ -208,6 +208,124 @@ match x {\n ```\n \"##,\n \n+E0010: r##\"\n+The value of statics and constants must be known at compile time, and they live\n+for the entire lifetime of a program. Creating a boxed value allocates memory on\n+the heap at runtime, and therefore cannot be done at compile time. Erroneous\n+code example:\n+\n+```compile_fail,E0010\n+#![feature(box_syntax)]\n+\n+const CON : Box<i32> = box 0;\n+```\n+\"##,\n+\n+E0013: r##\"\n+Static and const variables can refer to other const variables. But a const\n+variable cannot refer to a static variable. For example, `Y` cannot refer to\n+`X` here:\n+\n+```compile_fail,E0013\n+static X: i32 = 42;\n+const Y: i32 = X;\n+```\n+\n+To fix this, the value can be extracted as a const and then used:\n+\n+```\n+const A: i32 = 42;\n+static X: i32 = A;\n+const Y: i32 = A;\n+```\n+\"##,\n+\n+// FIXME(#57563) Change the language here when const fn stabilizes\n+E0015: r##\"\n+The only functions that can be called in static or constant expressions are\n+`const` functions, and struct/enum constructors. `const` functions are only\n+available on a nightly compiler. Rust currently does not support more general\n+compile-time function execution.\n+\n+```\n+const FOO: Option<u8> = Some(1); // enum constructor\n+struct Bar {x: u8}\n+const BAR: Bar = Bar {x: 1}; // struct constructor\n+```\n+\n+See [RFC 911] for more details on the design of `const fn`s.\n+\n+[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n+\"##,\n+\n+E0017: r##\"\n+References in statics and constants may only refer to immutable values.\n+Erroneous code example:\n+\n+```compile_fail,E0017\n+static X: i32 = 1;\n+const C: i32 = 2;\n+\n+// these three are not allowed:\n+const CR: &mut i32 = &mut C;\n+static STATIC_REF: &'static mut i32 = &mut X;\n+static CONST_REF: &'static mut i32 = &mut C;\n+```\n+\n+Statics are shared everywhere, and if they refer to mutable data one might\n+violate memory safety since holding multiple mutable references to shared data\n+is not allowed.\n+\n+If you really want global mutable state, try using `static mut` or a global\n+`UnsafeCell`.\n+\"##,\n+\n+E0019: r##\"\n+A function call isn't allowed in the const's initialization expression\n+because the expression's value must be known at compile-time. Erroneous code\n+example:\n+\n+```compile_fail\n+enum Test {\n+    V1\n+}\n+\n+impl Test {\n+    fn test(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+fn main() {\n+    const FOO: Test = Test::V1;\n+\n+    const A: i32 = FOO.test(); // You can't call Test::func() here!\n+}\n+```\n+\n+Remember: you can't use a function call inside a const's initialization\n+expression! However, you can totally use it anywhere else:\n+\n+```\n+enum Test {\n+    V1\n+}\n+\n+impl Test {\n+    fn func(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+fn main() {\n+    const FOO: Test = Test::V1;\n+\n+    FOO.func(); // here is good\n+    let x = FOO.func(); // or even here!\n+}\n+```\n+\"##,\n+\n E0030: r##\"\n When matching against a range, the compiler verifies that the range is\n non-empty.  Range patterns include both end-points, so this is equivalent to\n@@ -226,6 +344,40 @@ match 5u32 {\n ```\n \"##,\n \n+E0133: r##\"\n+Unsafe code was used outside of an unsafe function or block.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0133\n+unsafe fn f() { return; } // This is the unsafe code\n+\n+fn main() {\n+    f(); // error: call to unsafe function requires unsafe function or block\n+}\n+```\n+\n+Using unsafe functionality is potentially dangerous and disallowed by safety\n+checks. Examples:\n+\n+* Dereferencing raw pointers\n+* Calling functions via FFI\n+* Calling functions marked unsafe\n+\n+These safety checks can be relaxed for a section of the code by wrapping the\n+unsafe instructions with an `unsafe` block. For instance:\n+\n+```\n+unsafe fn f() { return; }\n+\n+fn main() {\n+    unsafe { f(); } // ok!\n+}\n+```\n+\n+See also https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n+\"##,\n+\n E0158: r##\"\n `const` and `static` mean different things. A `const` is a compile-time\n constant, an alias for a literal value. This property means you can match it\n@@ -247,6 +399,39 @@ match Some(42) {\n ```\n \"##,\n \n+E0161: r##\"\n+A value was moved. However, its size was not known at compile time, and only\n+values of a known size can be moved.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<[isize]> = box *array;\n+    // error: cannot move a value of type [isize]: the size of [isize] cannot\n+    //        be statically determined\n+}\n+```\n+\n+In Rust, you can only move a value when its size is known at compile time.\n+\n+To work around this restriction, consider \"hiding\" the value behind a reference:\n+either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n+it around as usual. Example:\n+\n+```\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<&[isize]> = box array; // ok!\n+}\n+```\n+\"##,\n+\n E0162: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n \n@@ -468,158 +653,6 @@ The `op_string_ref` binding has type `&Option<&String>` in both cases.\n See also https://github.com/rust-lang/rust/issues/14587\n \"##,\n \n-E0010: r##\"\n-The value of statics and constants must be known at compile time, and they live\n-for the entire lifetime of a program. Creating a boxed value allocates memory on\n-the heap at runtime, and therefore cannot be done at compile time. Erroneous\n-code example:\n-\n-```compile_fail,E0010\n-#![feature(box_syntax)]\n-\n-const CON : Box<i32> = box 0;\n-```\n-\"##,\n-\n-E0013: r##\"\n-Static and const variables can refer to other const variables. But a const\n-variable cannot refer to a static variable. For example, `Y` cannot refer to\n-`X` here:\n-\n-```compile_fail,E0013\n-static X: i32 = 42;\n-const Y: i32 = X;\n-```\n-\n-To fix this, the value can be extracted as a const and then used:\n-\n-```\n-const A: i32 = 42;\n-static X: i32 = A;\n-const Y: i32 = A;\n-```\n-\"##,\n-\n-// FIXME(#57563) Change the language here when const fn stabilizes\n-E0015: r##\"\n-The only functions that can be called in static or constant expressions are\n-`const` functions, and struct/enum constructors. `const` functions are only\n-available on a nightly compiler. Rust currently does not support more general\n-compile-time function execution.\n-\n-```\n-const FOO: Option<u8> = Some(1); // enum constructor\n-struct Bar {x: u8}\n-const BAR: Bar = Bar {x: 1}; // struct constructor\n-```\n-\n-See [RFC 911] for more details on the design of `const fn`s.\n-\n-[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n-\"##,\n-\n-E0017: r##\"\n-References in statics and constants may only refer to immutable values.\n-Erroneous code example:\n-\n-```compile_fail,E0017\n-static X: i32 = 1;\n-const C: i32 = 2;\n-\n-// these three are not allowed:\n-const CR: &mut i32 = &mut C;\n-static STATIC_REF: &'static mut i32 = &mut X;\n-static CONST_REF: &'static mut i32 = &mut C;\n-```\n-\n-Statics are shared everywhere, and if they refer to mutable data one might\n-violate memory safety since holding multiple mutable references to shared data\n-is not allowed.\n-\n-If you really want global mutable state, try using `static mut` or a global\n-`UnsafeCell`.\n-\"##,\n-\n-E0019: r##\"\n-A function call isn't allowed in the const's initialization expression\n-because the expression's value must be known at compile-time. Erroneous code\n-example:\n-\n-```compile_fail\n-enum Test {\n-    V1\n-}\n-\n-impl Test {\n-    fn test(&self) -> i32 {\n-        12\n-    }\n-}\n-\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    const A: i32 = FOO.test(); // You can't call Test::func() here!\n-}\n-```\n-\n-Remember: you can't use a function call inside a const's initialization\n-expression! However, you can totally use it anywhere else:\n-\n-```\n-enum Test {\n-    V1\n-}\n-\n-impl Test {\n-    fn func(&self) -> i32 {\n-        12\n-    }\n-}\n-\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    FOO.func(); // here is good\n-    let x = FOO.func(); // or even here!\n-}\n-```\n-\"##,\n-\n-E0133: r##\"\n-Unsafe code was used outside of an unsafe function or block.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0133\n-unsafe fn f() { return; } // This is the unsafe code\n-\n-fn main() {\n-    f(); // error: call to unsafe function requires unsafe function or block\n-}\n-```\n-\n-Using unsafe functionality is potentially dangerous and disallowed by safety\n-checks. Examples:\n-\n-* Dereferencing raw pointers\n-* Calling functions via FFI\n-* Calling functions marked unsafe\n-\n-These safety checks can be relaxed for a section of the code by wrapping the\n-unsafe instructions with an `unsafe` block. For instance:\n-\n-```\n-unsafe fn f() { return; }\n-\n-fn main() {\n-    unsafe { f(); } // ok!\n-}\n-```\n-\n-See also https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n-\"##,\n-\n E0373: r##\"\n This error occurs when an attempt is made to use data captured by a closure,\n when that data may no longer exist. It's most commonly seen when attempting to\n@@ -1022,39 +1055,6 @@ fn main() {\n ```\n \"##,\n \n-E0161: r##\"\n-A value was moved. However, its size was not known at compile time, and only\n-values of a known size can be moved.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<[isize]> = box *array;\n-    // error: cannot move a value of type [isize]: the size of [isize] cannot\n-    //        be statically determined\n-}\n-```\n-\n-In Rust, you can only move a value when its size is known at compile time.\n-\n-To work around this restriction, consider \"hiding\" the value behind a reference:\n-either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n-it around as usual. Example:\n-\n-```\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<&[isize]> = box array; // ok!\n-}\n-```\n-\"##,\n-\n E0492: r##\"\n A borrow of a constant containing interior mutability was attempted. Erroneous\n code example:\n@@ -1982,24 +1982,6 @@ Here executing `x = None` would modify the value being matched and require us\n to go \"back in time\" to the `None` arm.\n \"##,\n \n-E0579: r##\"\n-When matching against an exclusive range, the compiler verifies that the range\n-is non-empty. Exclusive range patterns include the start point but not the end\n-point, so this is equivalent to requiring the start of the range to be less\n-than the end of the range.\n-\n-For example:\n-\n-```compile_fail\n-match 5u32 {\n-    // This range is ok, albeit pointless.\n-    1 .. 2 => {}\n-    // This range is empty, and the compiler can tell.\n-    5 .. 5 => {}\n-}\n-```\n-\"##,\n-\n E0515: r##\"\n Cannot return value that references local variable\n \n@@ -2101,6 +2083,24 @@ fn dragoooon(x: &mut isize) {\n ```\n \"##,\n \n+E0579: r##\"\n+When matching against an exclusive range, the compiler verifies that the range\n+is non-empty. Exclusive range patterns include the start point but not the end\n+point, so this is equivalent to requiring the start of the range to be less\n+than the end of the range.\n+\n+For example:\n+\n+```compile_fail\n+match 5u32 {\n+    // This range is ok, albeit pointless.\n+    1 .. 2 => {}\n+    // This range is empty, and the compiler can tell.\n+    5 .. 5 => {}\n+}\n+```\n+\"##,\n+\n E0595: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n "}]}