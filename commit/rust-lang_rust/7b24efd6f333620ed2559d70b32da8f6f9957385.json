{"sha": "7b24efd6f333620ed2559d70b32da8f6f9957385", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMjRlZmQ2ZjMzMzYyMGVkMjU1OWQ3MGIzMmRhOGY2Zjk5NTczODU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-22T06:25:48Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-22T16:51:15Z"}, "message": "rustdoc: Out with the old, in with the new\n\nRemoves old rustdoc, moves rustdoc_ng into its place instead (plus drops the _ng\nsuffix). Also shreds all reference to rustdoc_ng from the Makefile rules.", "tree": {"sha": "08d3f597068a37adfc0893d3913fc9f0b1fc276f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08d3f597068a37adfc0893d3913fc9f0b1fc276f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b24efd6f333620ed2559d70b32da8f6f9957385", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b24efd6f333620ed2559d70b32da8f6f9957385", "html_url": "https://github.com/rust-lang/rust/commit/7b24efd6f333620ed2559d70b32da8f6f9957385", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b24efd6f333620ed2559d70b32da8f6f9957385/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f6a8ae96617081cbef81f0f336e706ad6d341e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f6a8ae96617081cbef81f0f336e706ad6d341e9", "html_url": "https://github.com/rust-lang/rust/commit/5f6a8ae96617081cbef81f0f336e706ad6d341e9"}], "stats": {"total": 7259, "additions": 281, "deletions": 6978}, "files": [{"sha": "eca5c3453e69180a121c26f73586a93779a6fdba", "filename": "Makefile.in", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "patch": "@@ -214,7 +214,6 @@ CFG_LIBRUSTC_$(1) :=$(call CFG_LIB_NAME_$(1),rustc)\n CFG_LIBSYNTAX_$(1) :=$(call CFG_LIB_NAME_$(1),syntax)\n CFG_LIBRUSTPKG_$(1) :=$(call CFG_LIB_NAME_$(1),rustpkg)\n CFG_LIBRUSTDOC_$(1) :=$(call CFG_LIB_NAME_$(1),rustdoc)\n-CFG_LIBRUSTDOCNG_$(1) :=$(call CFG_LIB_NAME_$(1),rustdoc_ng)\n CFG_LIBRUSTI_$(1) :=$(call CFG_LIB_NAME_$(1),rusti)\n CFG_LIBRUST_$(1) :=$(call CFG_LIB_NAME_$(1),rust)\n \n@@ -224,7 +223,6 @@ LIBRUSTC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustc)\n LIBSYNTAX_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),syntax)\n LIBRUSTPKG_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustpkg)\n LIBRUSTDOC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustdoc)\n-LIBRUSTDOCNG_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustdoc_ng)\n LIBRUSTI_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rusti)\n LIBRUST_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rust)\n EXTRALIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),extra)\n@@ -233,7 +231,6 @@ LIBRUSTC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustc)\n LIBSYNTAX_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),syntax)\n LIBRUSTPKG_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustpkg)\n LIBRUSTDOC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustdoc)\n-LIBRUSTDOCNG_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustdoc_ng)\n LIBRUSTI_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rusti)\n LIBRUST_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rust)\n \n@@ -442,12 +439,10 @@ CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/rustpkg$$(X_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n-\t$$(HBIN$(1)_H_$(3))/rustdoc_ng$$(X_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/rusti$$(X_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/rust$$(X_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTPKG_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTDOC_$(3)) \\\n-\t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTDOCNG_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTI_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUST_$(3)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2)) \\\n@@ -456,7 +451,6 @@ CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOCNG_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTI_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUST_$(2))\n "}, {"sha": "63080fe65284c7574d499771fdfdef6ae39f6174", "filename": "RELEASES.txt", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "patch": "@@ -143,7 +143,8 @@ Version 0.8 (October 2013)\n       * The runtime uses jemalloc for allocations.\n       * Segmented stacks are temporarily disabled as part of the transition to\n         the new runtime. Stack overflows are possible!\n-      * A new documentation backend, rustdoc_ng, is available for use\n+      * A new documentation backend, rustdoc_ng, is available for use. It is\n+        still invoked through the normal `rustdoc` command.\n \n Version 0.7 (July 2013)\n -----------------------"}, {"sha": "cb8861f659761982d20d3d1a3b583b4ef5c12982", "filename": "mk/clean.mk", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "patch": "@@ -68,12 +68,10 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustpkg$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/serializer$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustdoc$(X_$(2))\n-\t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustdoc_ng$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rusti$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rust$(X_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTPKG_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTDOC_$(2))\n-\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTDOCNG_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_RUNTIME_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_STDLIB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_EXTRALIB_$(2))\n@@ -87,7 +85,6 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBSYNTAX_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTPKG_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTDOC_GLOB_$(2))\n-\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTDOCNG_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTI_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUST_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_RUSTLLVM_$(2))\n@@ -106,12 +103,10 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustpkg$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/serializer$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustdoc$(X_$(2))\n-\t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustdoc_ng$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rusti$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rust$(X_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2))\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOCNG_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUNTIME_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2))\n@@ -125,7 +120,6 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBSYNTAX_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTPKG_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTDOC_GLOB_$(2))\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTDOCNG_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTI_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUST_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUSTLLVM_$(2))"}, {"sha": "4a980edf7673141df16ae7895f9c14c37e9b5f7e", "filename": "mk/dist.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "patch": "@@ -39,7 +39,6 @@ PKG_FILES := \\\n       libsyntax                                \\\n       rt                                       \\\n       librustdoc                               \\\n-      rustdoc_ng                               \\\n       rustllvm                                 \\\n       snapshots.txt                            \\\n       test)                                    \\"}, {"sha": "b89bf3483fce7d51e53f285d63e4b18c35dd6925", "filename": "mk/docs.mk", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "patch": "@@ -213,40 +213,21 @@ else\n \n # The rustdoc executable\n RUSTDOC = $(HBIN2_H_$(CFG_BUILD_TRIPLE))/rustdoc$(X_$(CFG_BUILD_TRIPLE))\n-RUSTDOC_NG = $(HBIN2_H_$(CFG_BUILD_TRIPLE))/rustdoc_ng$(X_$(CFG_BUILD_TRIPLE))\n \n # The library documenting macro\n-# $(1) - The output directory\n+# $(1) - The crate name (std/extra)\n # $(2) - The crate file\n-# $(3) - The crate soruce files\n+# $(3) - The relevant host build triple (to depend on libstd)\n define libdoc\n-doc/$(1)/index.html: $(2) $(3) $$(RUSTDOC) doc/$(1)/rust.css\n+doc/$(1)/index.html: $$(RUSTDOC) $$(TLIB2_T_$(3)_H_$(3))/$(CFG_STDLIB_$(3))\n \t@$$(call E, rustdoc: $$@)\n-\t$(Q)$(RUSTDOC) $(2) --output-dir=doc/$(1)\n-\n-doc/$(1)/rust.css: rust.css\n-\t@$$(call E, cp: $$@)\n-\t$(Q)cp $$< $$@\n+\t$(Q)$(RUSTDOC) html $(2)\n \n DOCS += doc/$(1)/index.html\n endef\n \n-# The \"next generation\" library documenting macro\n-# $(1) - The crate name (std/extra)\n-# $(2) - The crate file\n-# $(3) - The relevant host build triple (to depend on libstd)\n-define libdocng\n-doc/ng/$(1)/index.html: $$(RUSTDOC_NG) $$(TLIB2_T_$(3)_H_$(3))/$(CFG_STDLIB_$(3))\n-\t@$$(call E, rustdoc_ng: $$@)\n-\t$(Q)$(RUSTDOC_NG) html $(2) -o doc/ng\n-\n-DOCS += doc/ng/$(1)/index.html\n-endef\n-\n-$(eval $(call libdoc,std,$(STDLIB_CRATE),$(STDLIB_INPUTS)))\n-$(eval $(call libdoc,extra,$(EXTRALIB_CRATE),$(EXTRALIB_INPUTS)))\n-$(eval $(call libdocng,std,$(STDLIB_CRATE),$(CFG_BUILD_TRIPLE)))\n-$(eval $(call libdocng,extra,$(EXTRALIB_CRATE),$(CFG_BUILD_TRIPLE)))\n+$(eval $(call libdoc,std,$(STDLIB_CRATE),$(CFG_BUILD_TRIPLE)))\n+$(eval $(call libdoc,extra,$(EXTRALIB_CRATE),$(CFG_BUILD_TRIPLE)))\n endif\n \n "}, {"sha": "4b50c5aa7963f2d3ddea4107a5bd800913a183e9", "filename": "mk/install.mk", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "patch": "@@ -104,7 +104,6 @@ install-target-$(1)-host-$(2): $$(CSREQ$$(ISTAGE)_T_$(1)_H_$(2))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBSYNTAX_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTPKG_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTDOC_GLOB_$(1)))\n-\t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTDOCNG_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTI_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUST_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,libmorestack.a)\n@@ -140,7 +139,6 @@ install-host: $(CSREQ$(ISTAGE)_T_$(CFG_BUILD_TRIPLE)_H_$(CFG_BUILD_TRIPLE))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rustc$(X_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rustpkg$(X_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rustdoc$(X_$(CFG_BUILD_TRIPLE)))\n-\t$(Q)$(call INSTALL,$(HB2),$(PHB),rustdoc_ng$(X_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rusti$(X_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rust$(X_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(STDLIB_GLOB_$(CFG_BUILD_TRIPLE)))\n@@ -151,7 +149,6 @@ install-host: $(CSREQ$(ISTAGE)_T_$(CFG_BUILD_TRIPLE)_H_$(CFG_BUILD_TRIPLE))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUST_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTPKG_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTDOC_GLOB_$(CFG_BUILD_TRIPLE)))\n-\t$(Q)$(call INSTALL_LIB,$(LIBRUSTDOCNG_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_RUNTIME_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_RUSTLLVM_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(S)/man, $(PREFIX_ROOT)/share/man/man1,rust.1)\n@@ -172,7 +169,6 @@ uninstall:\n \t$(Q)rm -f $(PHB)/rusti$(X_$(CFG_BUILD_TRIPLE))\n \t$(Q)rm -f $(PHB)/rust$(X_$(CFG_BUILD_TRIPLE))\n \t$(Q)rm -f $(PHB)/rustdoc$(X_$(CFG_BUILD_TRIPLE))\n-\t$(Q)rm -f $(PHB)/rustdoc_ng$(X_$(CFG_BUILD_TRIPLE))\n \t$(Q)rm -f $(PHL)/$(CFG_RUSTLLVM_$(CFG_BUILD_TRIPLE))\n \t$(Q)rm -f $(PHL)/$(CFG_RUNTIME_$(CFG_BUILD_TRIPLE))\n \t$(Q)for i in \\\n@@ -182,7 +178,6 @@ uninstall:\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBSYNTAX_GLOB_$(CFG_BUILD_TRIPLE))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTPKG_GLOB_$(CFG_BUILD_TRIPLE))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTDOC_GLOB_$(CFG_BUILD_TRIPLE))) \\\n-          $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTDOCNG_GLOB_$(CFG_BUILD_TRIPLE))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTI_GLOB_$(CFG_BUILD_TRIPLE))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUST_GLOB_$(CFG_BUILD_TRIPLE))) \\\n         ; \\"}, {"sha": "9fe163e509b5e627abcee457c5bc7a3a0f05b7c6", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "patch": "@@ -15,7 +15,7 @@\n \n # The names of crates that must be tested\n TEST_TARGET_CRATES = std extra\n-TEST_HOST_CRATES = rust rusti rustpkg rustc rustdoc rustdocng syntax\n+TEST_HOST_CRATES = rust rusti rustpkg rustc rustdoc syntax\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n \n # Markdown files under doc/ that should have their code extracted and run\n@@ -393,14 +393,6 @@ $(3)/stage$(1)/test/rustdoctest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n \n-$(3)/stage$(1)/test/rustdocngtest-$(2)$$(X_$(2)):\t\t\t    \\\n-\t\t$$(RUSTDOCNG_LIB) $$(RUSTDOCNG_INPUTS)\t\t\\\n-\t\t$$(SREQ$(1)_T_$(2)_H_$(3)) \\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBSYNTAX_$(2)) \\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC_$(2))\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n-\n endef\n \n $(foreach host,$(CFG_HOST_TRIPLES), \\"}, {"sha": "09c3de014782d3b0f1e1e4dd3d2265ca27f01e86", "filename": "mk/tools.mk", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "patch": "@@ -23,11 +23,6 @@ RUSTPKG_INPUTS := $(wildcard $(S)src/librustpkg/*.rs)\n RUSTDOC_LIB := $(S)src/librustdoc/rustdoc.rs\n RUSTDOC_INPUTS := $(wildcard $(S)src/librustdoc/*.rs)\n \n-# rustdoc_ng, the next generation documentation tool\n-\n-RUSTDOCNG_LIB := $(S)src/rustdoc_ng/rustdoc_ng.rs\n-RUSTDOCNG_INPUTS := $(wildcard $(S)src/rustdoc_ng/*.rs)\n-\n # Rusti, the JIT REPL\n RUSTI_LIB := $(S)src/librusti/rusti.rs\n RUSTI_INPUTS := $(wildcard $(S)src/librusti/*.rs)\n@@ -83,24 +78,6 @@ $$(TBIN$(1)_T_$(4)_H_$(3))/rustdoc$$(X_$(4)):\t\t\t\\\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(4)_H_$(3)) --cfg rustdoc -o $$@ $$<\n \n-$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTDOCNG_$(4)):\t\t\\\n-\t\t$$(RUSTDOCNG_LIB) $$(RUSTDOCNG_INPUTS)\t\t\t\\\n-\t\t$$(SREQ$(1)_T_$(4)_H_$(3))\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTC_$(4)) \\\n-\t\t| $$(TLIB$(1)_T_$(4)_H_$(3))/\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTDOCNG_GLOB_$(4)),$$(notdir $$@))\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) --out-dir $$(@D) $$< && touch $$@\n-\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTDOCNG_GLOB_$(4)),$$(notdir $$@))\n-\n-$$(TBIN$(1)_T_$(4)_H_$(3))/rustdoc_ng$$(X_$(4)):\t\t\t\\\n-\t\t$$(DRIVER_CRATE) \t\t\t\t\t\t\t\\\n-\t\t$$(TSREQ$(1)_T_$(4)_H_$(3))\t\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTDOCNG_$(4))\t\t\t\\\n-\t\t| $$(TBIN$(1)_T_$(4)_H_$(3))/\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) --cfg rustdoc_ng -o $$@ $$<\n-\n $$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTI_$(4)):\t\t\\\n \t\t$$(RUSTI_LIB) $$(RUSTI_INPUTS)\t\t\t\\\n \t\t$$(SREQ$(1)_T_$(4)_H_$(3))\t\t\t\\\n@@ -125,7 +102,6 @@ $$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUST_$(4)):\t\t\\\n \t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTPKG_$(4))\t\\\n \t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTI_$(4))\t\t\\\n \t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTDOC_$(4))\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTDOCNG_$(4))\t\\\n \t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTC_$(4))\t\t\\\n \t\t| $$(TLIB$(1)_T_$(4)_H_$(3))/\n \t@$$(call E, compile_and_link: $$@)\n@@ -195,27 +171,6 @@ $$(HBIN$(2)_H_$(4))/rustdoc$$(X_$(4)):\t\t\t\t\\\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n-$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTDOCNG_$(4)):\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTDOCNG_$(4))\t\\\n-\t\t$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTC_$(4))\t\t\t\\\n-\t\t$$(HSREQ$(2)_H_$(4)) \\\n-\t\t| $$(HLIB$(2)_H_$(4))/\n-\t@$$(call E, cp: $$@)\n-\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTDOCNG_GLOB_$(4)),$$(notdir $$@))\n-\t$$(Q)cp $$< $$@\n-\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTDOCNG_GLOB_$(4)),$$(notdir $$@))\n-\t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBRUSTDOCNG_GLOB_$(4)) \\\n-\t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBRUSTDOCNG_DSYM_GLOB_$(4))) \\\n-\t        $$(HLIB$(2)_H_$(4))\n-\n-$$(HBIN$(2)_H_$(4))/rustdoc_ng$$(X_$(4)):\t\t\t\t\\\n-\t\t$$(TBIN$(1)_T_$(4)_H_$(3))/rustdoc_ng$$(X_$(4))\t\\\n-\t\t$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTDOCNG_$(4))\t\\\n-\t\t$$(HSREQ$(2)_H_$(4))\t\t\t\t\\\n-\t\t| $$(HBIN$(2)_H_$(4))/\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n $$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTI_$(4)):\t\t\t\t\t\\\n \t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTI_$(4))\t\\\n \t\t$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTC_$(4))\t\t\t\\"}, {"sha": "eb82cfcc0b2e24b85bbfae2d5ab5894058de7feb", "filename": "src/librust/rust.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "patch": "@@ -92,7 +92,7 @@ static COMMANDS: &'static [Command<'static>] = &'static [\n         cmd: \"doc\",\n         action: CallMain(\"rustdoc\", rustdoc::main_args),\n         usage_line: \"generate documentation from doc comments\",\n-        usage_full: UsgCall(rustdoc::config::usage),\n+        usage_full: UsgCall(rustdoc_help),\n     },\n     Command {\n         cmd: \"pkg\",\n@@ -122,6 +122,10 @@ fn rustc_help() {\n     rustc::usage(os::args()[0].clone())\n }\n \n+fn rustdoc_help() {\n+    rustdoc::usage(os::args()[0].clone())\n+}\n+\n fn find_cmd(command_string: &str) -> Option<Command> {\n     do COMMANDS.iter().find |command| {\n         command.cmd == command_string"}, {"sha": "b2b7599aae3a79704c124f2991a3be36d0561f68", "filename": "src/librustdoc/astsrv.rs", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,186 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Provides all access to AST-related, non-sendable info\n-\n-Rustdoc is intended to be parallel, and the rustc AST is filled with\n-shared boxes. The AST service attempts to provide a single place to\n-query AST-related information, shielding the rest of Rustdoc from its\n-non-sendableness.\n-*/\n-\n-\n-use parse;\n-\n-use std::cell::Cell;\n-use std::comm::{stream, SharedChan, Port};\n-use std::task;\n-use rustc::driver::driver;\n-use rustc::driver::session::Session;\n-use rustc::driver::session::{basic_options, options};\n-use rustc::front;\n-use syntax::ast;\n-use syntax::ast_map;\n-use syntax::ast_util;\n-use syntax;\n-\n-pub struct Ctxt {\n-    ast: @ast::Crate,\n-    ast_map: ast_map::map\n-}\n-\n-type SrvOwner<'self,T> = &'self fn(srv: Srv) -> T;\n-pub type CtxtHandler<T> = ~fn(ctxt: Ctxt) -> T;\n-type Parser = ~fn(Session, s: @str) -> @ast::Crate;\n-\n-enum Msg {\n-    HandleRequest(~fn(Ctxt)),\n-    Exit\n-}\n-\n-#[deriving(Clone)]\n-pub struct Srv {\n-    ch: SharedChan<Msg>\n-}\n-\n-pub fn from_str<T>(source: ~str, owner: SrvOwner<T>) -> T {\n-    run(owner, source.clone(), parse::from_str_sess)\n-}\n-\n-pub fn from_file<T>(file: ~str, owner: SrvOwner<T>) -> T {\n-    run(owner, file.clone(), |sess, f| parse::from_file_sess(sess, &Path(f)))\n-}\n-\n-fn run<T>(owner: SrvOwner<T>, source: ~str, parse: Parser) -> T {\n-\n-    let (po, ch) = stream();\n-\n-    let source = Cell::new(source);\n-    let parse = Cell::new(parse);\n-    do task::spawn {\n-        act(&po, source.take().to_managed(), parse.take());\n-    }\n-\n-    let srv_ = Srv {\n-        ch: SharedChan::new(ch)\n-    };\n-\n-    let res = owner(srv_.clone());\n-    srv_.ch.send(Exit);\n-    res\n-}\n-\n-fn act(po: &Port<Msg>, source: @str, parse: Parser) {\n-    let sess = build_session();\n-\n-    let ctxt = build_ctxt(\n-        sess,\n-        parse(sess, source)\n-    );\n-\n-    let mut keep_going = true;\n-    while keep_going {\n-        match po.recv() {\n-          HandleRequest(f) => {\n-            f(ctxt);\n-          }\n-          Exit => {\n-            keep_going = false;\n-          }\n-        }\n-    }\n-}\n-\n-pub fn exec<T:Send>(\n-    srv: Srv,\n-    f: ~fn(ctxt: Ctxt) -> T\n-) -> T {\n-    let (po, ch) = stream();\n-    let msg = HandleRequest(|ctxt| ch.send(f(ctxt)));\n-    srv.ch.send(msg);\n-    po.recv()\n-}\n-\n-fn assign_node_ids(crate: @ast::Crate) -> @ast::Crate {\n-    let next_id = @mut 0;\n-    let fold = ast_util::node_id_assigner(|| {\n-            let i = *next_id;\n-            *next_id += 1;\n-            i\n-        });\n-    @fold.fold_crate(crate)\n-}\n-\n-fn build_ctxt(sess: Session,\n-              ast: @ast::Crate) -> Ctxt {\n-\n-    use rustc::front::config;\n-\n-    let ast = syntax::ext::expand::inject_std_macros(sess.parse_sess,\n-                                                     sess.opts.cfg.clone(),\n-                                                     ast);\n-    let ast = config::strip_unconfigured_items(ast);\n-    let ast = syntax::ext::expand::expand_crate(sess.parse_sess,\n-                                                sess.opts.cfg.clone(),\n-                                                ast);\n-    let ast = front::test::modify_for_testing(sess, ast);\n-    let ast = assign_node_ids(ast);\n-    let ast_map = ast_map::map_crate(sess.diagnostic(), ast);\n-\n-    Ctxt {\n-        ast: ast,\n-        ast_map: ast_map,\n-    }\n-}\n-\n-fn build_session() -> Session {\n-    let sopts: @options = basic_options();\n-    let emitter = syntax::diagnostic::emit;\n-\n-    let session = driver::build_session(sopts, emitter);\n-    session\n-}\n-\n-#[test]\n-fn should_prune_unconfigured_items() {\n-    let source = ~\"#[cfg(shut_up_and_leave_me_alone)]fn a() { }\";\n-    do from_str(source) |srv| {\n-        do exec(srv) |ctxt| {\n-            // one item: the __std_macros secret module\n-            assert_eq!(ctxt.ast.module.items.len(), 1);\n-        }\n-    }\n-}\n-\n-#[test]\n-fn srv_should_build_ast_map() {\n-    let source = ~\"fn a() { }\";\n-    do from_str(source) |srv| {\n-        do exec(srv) |ctxt| {\n-            assert!(!ctxt.ast_map.is_empty())\n-        };\n-    }\n-}\n-\n-#[test]\n-fn should_ignore_external_import_paths_that_dont_exist() {\n-    let source = ~\"use forble; use forble::bippy;\";\n-    from_str(source, |_srv| { } )\n-}\n-\n-#[test]\n-fn srv_should_return_request_result() {\n-    let source = ~\"fn a() { }\";\n-    do from_str(source) |srv| {\n-        let result = exec(srv, |_ctxt| 1000 );\n-        assert_eq!(result, 1000);\n-    }\n-}"}, {"sha": "ce8d1977443f81f6ab73189748c7829643589cde", "filename": "src/librustdoc/attr_parser.rs", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,149 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Attribute parsing\n-\n-The attribute parser provides methods for pulling documentation out of\n-an AST's attributes.\n-*/\n-\n-\n-use syntax::ast;\n-use syntax::attr;\n-use syntax::attr::{AttrMetaMethods, AttributeMethods};\n-\n-pub struct CrateAttrs {\n-    name: Option<~str>\n-}\n-\n-fn doc_metas(attrs: ~[ast::Attribute]) -> ~[@ast::MetaItem] {\n-    attrs.iter()\n-        .filter(|at| \"doc\" == at.name())\n-        .map(|at| at.desugar_doc().meta())\n-        .collect()\n-}\n-\n-pub fn parse_crate(attrs: ~[ast::Attribute]) -> CrateAttrs {\n-    let link_metas = attr::find_linkage_metas(attrs);\n-    let name = attr::last_meta_item_value_str_by_name(link_metas, \"name\");\n-\n-    CrateAttrs {\n-        name: name.map(|s| s.to_owned())\n-    }\n-}\n-\n-pub fn parse_desc(attrs: ~[ast::Attribute]) -> Option<~str> {\n-    let doc_strs = do doc_metas(attrs).move_iter().filter_map |meta| {\n-        meta.value_str()\n-    }.collect::<~[@str]>();\n-    if doc_strs.is_empty() {\n-        None\n-    } else {\n-        Some(doc_strs.connect(\"\\n\"))\n-    }\n-}\n-\n-pub fn parse_hidden(attrs: ~[ast::Attribute]) -> bool {\n-    let r = doc_metas(attrs);\n-    do r.iter().any |meta| {\n-        match meta.meta_item_list() {\n-            Some(metas) => attr::contains_name(metas, \"hidden\"),\n-            None => false\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use syntax::ast;\n-    use syntax;\n-    use super::{parse_hidden, parse_crate, parse_desc};\n-\n-    fn parse_attributes(source: @str) -> ~[ast::Attribute] {\n-        use syntax::parse;\n-        use syntax::parse::attr::parser_attr;\n-\n-        let parse_sess = syntax::parse::new_parse_sess(None);\n-        let parser = parse::new_parser_from_source_str(\n-            parse_sess, ~[], @\"-\", source);\n-\n-        parser.parse_outer_attributes()\n-    }\n-\n-\n-    #[test]\n-    fn should_extract_crate_name_from_link_attribute() {\n-        let source = @\"#[link(name = \\\"snuggles\\\")]\";\n-        let attrs = parse_attributes(source);\n-        let attrs = parse_crate(attrs);\n-        assert!(attrs.name == Some(~\"snuggles\"));\n-    }\n-\n-    #[test]\n-    fn should_not_extract_crate_name_if_no_link_attribute() {\n-        let source = @\"\";\n-        let attrs = parse_attributes(source);\n-        let attrs = parse_crate(attrs);\n-        assert!(attrs.name == None);\n-    }\n-\n-    #[test]\n-    fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n-        let source = @\"#[link(whatever)]\";\n-        let attrs = parse_attributes(source);\n-        let attrs = parse_crate(attrs);\n-        assert!(attrs.name == None);\n-    }\n-\n-    #[test]\n-    fn parse_desc_should_handle_undocumented_mods() {\n-        let source = @\"\";\n-        let attrs = parse_attributes(source);\n-        let attrs = parse_desc(attrs);\n-        assert!(attrs == None);\n-    }\n-\n-    #[test]\n-    fn parse_desc_should_parse_simple_doc_attributes() {\n-        let source = @\"#[doc = \\\"basic\\\"]\";\n-        let attrs = parse_attributes(source);\n-        let attrs = parse_desc(attrs);\n-        assert!(attrs == Some(~\"basic\"));\n-    }\n-\n-    #[test]\n-    fn should_parse_hidden_attribute() {\n-        let source = @\"#[doc(hidden)]\";\n-        let attrs = parse_attributes(source);\n-        assert!(parse_hidden(attrs) == true);\n-    }\n-\n-    #[test]\n-    fn should_parse_hidden_attribute_with_other_docs() {\n-        let source = @\"#[doc = \\\"foo\\\"] #[doc(hidden)] #[doc = \\\"foo\\\"]\";\n-        let attrs = parse_attributes(source);\n-        assert!(parse_hidden(attrs) == true);\n-    }\n-\n-    #[test]\n-    fn should_not_parse_non_hidden_attribute() {\n-        let source = @\"#[doc = \\\"\\\"]\";\n-        let attrs = parse_attributes(source);\n-        assert!(parse_hidden(attrs) == false);\n-    }\n-\n-    #[test]\n-    fn should_concatenate_multiple_doc_comments() {\n-        let source = @\"/// foo\\n/// bar\";\n-        let desc = parse_desc(parse_attributes(source));\n-        assert!(desc == Some(~\" foo\\n bar\"));\n-    }\n-}"}, {"sha": "bd8d9a65cd33d666037b54bcf1739ce88966777b", "filename": "src/librustdoc/attr_pass.rs", "status": "removed", "additions": 0, "deletions": 326, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,326 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-The attribute parsing pass\n-\n-Traverses the document tree, pulling relevant documention out of the\n-corresponding AST nodes. The information gathered here is the basis\n-of the natural-language documentation for a crate.\n-*/\n-\n-\n-use astsrv;\n-use attr_parser;\n-use doc::ItemUtils;\n-use doc;\n-use extract::to_str;\n-use fold::Fold;\n-use fold;\n-use pass::Pass;\n-\n-use syntax::ast;\n-use syntax::ast_map;\n-\n-pub fn mk_pass() -> Pass {\n-    Pass {\n-        name: ~\"attr\",\n-        f: run\n-    }\n-}\n-\n-pub fn run(\n-    srv: astsrv::Srv,\n-    doc: doc::Doc\n-) -> doc::Doc {\n-    let fold = Fold {\n-        ctxt: srv.clone(),\n-        fold_crate: fold_crate,\n-        fold_item: fold_item,\n-        fold_enum: fold_enum,\n-        fold_trait: fold_trait,\n-        fold_impl: fold_impl,\n-        .. fold::default_any_fold(srv)\n-    };\n-    (fold.fold_doc)(&fold, doc)\n-}\n-\n-fn fold_crate(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::CrateDoc\n-) -> doc::CrateDoc {\n-\n-    let srv = fold.ctxt.clone();\n-    let doc = fold::default_seq_fold_crate(fold, doc);\n-\n-    let attrs = do astsrv::exec(srv) |ctxt| {\n-        let attrs = ctxt.ast.attrs.clone();\n-        attr_parser::parse_crate(attrs)\n-    };\n-\n-    doc::CrateDoc {\n-        topmod: doc::ModDoc {\n-            item: doc::ItemDoc {\n-                name: attrs.name.clone().unwrap_or(doc.topmod.name_()),\n-                .. doc.topmod.item.clone()\n-            },\n-            .. doc.topmod.clone()\n-        }\n-    }\n-}\n-\n-fn fold_item(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::ItemDoc\n-) -> doc::ItemDoc {\n-\n-    let srv = fold.ctxt.clone();\n-    let doc = fold::default_seq_fold_item(fold, doc);\n-\n-    let desc = if doc.id == ast::CRATE_NODE_ID {\n-        // This is the top-level mod, use the crate attributes\n-        do astsrv::exec(srv) |ctxt| {\n-            attr_parser::parse_desc(ctxt.ast.attrs.clone())\n-        }\n-    } else {\n-        parse_item_attrs(srv, doc.id, attr_parser::parse_desc)\n-    };\n-\n-    doc::ItemDoc {\n-        desc: desc,\n-        .. doc\n-    }\n-}\n-\n-fn parse_item_attrs<T:Send>(\n-    srv: astsrv::Srv,\n-    id: doc::AstId,\n-    parse_attrs: ~fn(a: ~[ast::Attribute]) -> T) -> T {\n-    do astsrv::exec(srv) |ctxt| {\n-        let attrs = match ctxt.ast_map.get_copy(&id) {\n-            ast_map::node_item(item, _) => item.attrs.clone(),\n-            ast_map::node_foreign_item(item, _, _, _) => item.attrs.clone(),\n-            _ => fail!(\"parse_item_attrs: not an item\")\n-        };\n-        parse_attrs(attrs)\n-    }\n-}\n-\n-fn fold_enum(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::EnumDoc\n-) -> doc::EnumDoc {\n-\n-    let srv = fold.ctxt.clone();\n-    let doc_id = doc.id();\n-    let doc = fold::default_seq_fold_enum(fold, doc);\n-\n-    doc::EnumDoc {\n-        variants: do doc.variants.iter().map |variant| {\n-            let variant = (*variant).clone();\n-            let desc = {\n-                let variant = variant.clone();\n-                do astsrv::exec(srv.clone()) |ctxt| {\n-                    match ctxt.ast_map.get_copy(&doc_id) {\n-                        ast_map::node_item(@ast::item {\n-                            node: ast::item_enum(ref enum_definition, _), _\n-                        }, _) => {\n-                            let ast_variant =\n-                                (*enum_definition.variants.iter().find(|v| {\n-                                    to_str(v.node.name) == variant.name\n-                                }).unwrap()).clone();\n-\n-                            attr_parser::parse_desc(\n-                                ast_variant.node.attrs.clone())\n-                        }\n-                        _ => {\n-                            fail!(\"Enum variant %s has id that's not bound to an enum item\",\n-                                  variant.name)\n-                        }\n-                    }\n-                }\n-            };\n-\n-            doc::VariantDoc {\n-                desc: desc,\n-                .. variant\n-            }\n-        }.collect(),\n-        .. doc\n-    }\n-}\n-\n-fn fold_trait(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::TraitDoc\n-) -> doc::TraitDoc {\n-    let srv = fold.ctxt.clone();\n-    let doc = fold::default_seq_fold_trait(fold, doc);\n-\n-    doc::TraitDoc {\n-        methods: merge_method_attrs(srv, doc.id(), doc.methods.clone()),\n-        .. doc\n-    }\n-}\n-\n-fn merge_method_attrs(\n-    srv: astsrv::Srv,\n-    item_id: doc::AstId,\n-    docs: ~[doc::MethodDoc]\n-) -> ~[doc::MethodDoc] {\n-\n-    // Create an assoc list from method name to attributes\n-    let attrs: ~[(~str, Option<~str>)] = do astsrv::exec(srv) |ctxt| {\n-        match ctxt.ast_map.get_copy(&item_id) {\n-            ast_map::node_item(@ast::item {\n-                node: ast::item_trait(_, _, ref methods), _\n-            }, _) => {\n-                methods.iter().map(|method| {\n-                    match (*method).clone() {\n-                        ast::required(ty_m) => {\n-                            (to_str(ty_m.ident),\n-                             attr_parser::parse_desc(ty_m.attrs.clone()))\n-                        }\n-                        ast::provided(m) => {\n-                            (to_str(m.ident), attr_parser::parse_desc(m.attrs.clone()))\n-                        }\n-                    }\n-                }).collect()\n-            }\n-            ast_map::node_item(@ast::item {\n-                node: ast::item_impl(_, _, _, ref methods), _\n-            }, _) => {\n-                methods.iter().map(|method| {\n-                    (to_str(method.ident),\n-                     attr_parser::parse_desc(method.attrs.clone()))\n-                }).collect()\n-            }\n-            _ => fail!(\"unexpected item\")\n-        }\n-    };\n-\n-    do docs.iter().zip(attrs.iter()).map |(doc, attrs)| {\n-        assert!(doc.name == attrs.first());\n-        let desc = attrs.second();\n-\n-        doc::MethodDoc {\n-            desc: desc,\n-            .. (*doc).clone()\n-        }\n-    }.collect()\n-}\n-\n-\n-fn fold_impl(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::ImplDoc\n-) -> doc::ImplDoc {\n-    let srv = fold.ctxt.clone();\n-    let doc = fold::default_seq_fold_impl(fold, doc);\n-\n-    doc::ImplDoc {\n-        methods: merge_method_attrs(srv, doc.id(), doc.methods.clone()),\n-        .. doc\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use astsrv;\n-    use attr_pass::run;\n-    use doc;\n-    use extract;\n-\n-    fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(source.clone()) |srv| {\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            run(srv.clone(), doc)\n-        }\n-    }\n-\n-    #[test]\n-    fn should_replace_top_module_name_with_crate_name() {\n-        let doc = mk_doc(~\"#[link(name = \\\"bond\\\")];\");\n-        assert!(doc.cratemod().name_() == ~\"bond\");\n-    }\n-\n-    #[test]\n-    fn should_should_extract_mod_attributes() {\n-        let doc = mk_doc(~\"#[doc = \\\"test\\\"] mod a { }\");\n-        // hidden __std_macros module at the start.\n-        assert!(doc.cratemod().mods()[1].desc() == Some(~\"test\"));\n-    }\n-\n-    #[test]\n-    fn should_extract_top_mod_attributes() {\n-        let doc = mk_doc(~\"#[doc = \\\"test\\\"];\");\n-        assert!(doc.cratemod().desc() == Some(~\"test\"));\n-    }\n-\n-    #[test]\n-    fn should_extract_foreign_fn_attributes() {\n-        let doc = mk_doc(~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-        assert!(doc.cratemod().nmods()[0].fns[0].desc() == Some(~\"test\"));\n-    }\n-\n-    #[test]\n-    fn should_extract_fn_attributes() {\n-        let doc = mk_doc(~\"#[doc = \\\"test\\\"] fn a() -> int { }\");\n-        assert!(doc.cratemod().fns()[0].desc() == Some(~\"test\"));\n-    }\n-\n-    #[test]\n-    fn should_extract_enum_docs() {\n-        let doc = mk_doc(~\"#[doc = \\\"b\\\"]\\\n-                                 enum a { v }\");\n-        debug!(\"%?\", doc);\n-        assert!(doc.cratemod().enums()[0].desc() == Some(~\"b\"));\n-    }\n-\n-    #[test]\n-    fn should_extract_variant_docs() {\n-        let doc = mk_doc(~\"enum a { #[doc = \\\"c\\\"] v }\");\n-        assert!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"c\"));\n-    }\n-\n-    #[test]\n-    fn should_extract_trait_docs() {\n-        let doc = mk_doc(~\"#[doc = \\\"whatever\\\"] trait i { fn a(); }\");\n-        assert!(doc.cratemod().traits()[0].desc() == Some(~\"whatever\"));\n-    }\n-\n-    #[test]\n-    fn should_extract_trait_method_docs() {\n-        let doc = mk_doc(\n-            ~\"trait i {\\\n-              #[doc = \\\"desc\\\"]\\\n-              fn f(a: bool) -> bool;\\\n-              }\");\n-        assert!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"desc\"));\n-    }\n-\n-    #[test]\n-    fn should_extract_impl_docs() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\"whatever\\\"] impl int { fn a() { } }\");\n-        assert!(doc.cratemod().impls()[0].desc() == Some(~\"whatever\"));\n-    }\n-\n-    #[test]\n-    fn should_extract_impl_method_docs() {\n-        let doc = mk_doc(\n-            ~\"impl int {\\\n-              #[doc = \\\"desc\\\"]\\\n-              fn f(a: bool) -> bool { }\\\n-              }\");\n-        assert!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"desc\"));\n-    }\n-}"}, {"sha": "97a599196e72fc55b57ba605775755a1bd6daf3b", "filename": "src/librustdoc/clean.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/clean.rs"}, {"sha": "71ece1788078266a67ef2e3137f79f87a38b80c3", "filename": "src/librustdoc/config.rs", "status": "removed", "additions": 0, "deletions": 373, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,373 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-use std::cell::Cell;\n-use std::os;\n-use std::result::Result;\n-use std::result;\n-use std::run::ProcessOutput;\n-use std::run;\n-use std::vec;\n-use extra::getopts;\n-\n-/// The type of document to output\n-#[deriving(Clone, Eq)]\n-pub enum OutputFormat {\n-    /// Markdown\n-    Markdown,\n-    /// HTML, via markdown and pandoc\n-    PandocHtml\n-}\n-\n-/// How to organize the output\n-#[deriving(Clone, Eq)]\n-pub enum OutputStyle {\n-    /// All in a single document\n-    DocPerCrate,\n-    /// Each module in its own document\n-    DocPerMod\n-}\n-\n-/// The configuration for a rustdoc session\n-#[deriving(Clone)]\n-pub struct Config {\n-    input_crate: Path,\n-    output_dir: Path,\n-    output_format: OutputFormat,\n-    output_style: OutputStyle,\n-    pandoc_cmd: Option<~str>\n-}\n-\n-fn opt_output_dir() -> ~str { ~\"output-dir\" }\n-fn opt_output_format() -> ~str { ~\"output-format\" }\n-fn opt_output_style() -> ~str { ~\"output-style\" }\n-fn opt_pandoc_cmd() -> ~str { ~\"pandoc-cmd\" }\n-fn opt_help() -> ~str { ~\"h\" }\n-\n-fn opts() -> ~[(getopts::Opt, ~str)] {\n-    ~[\n-        (getopts::optopt(opt_output_dir()),\n-         ~\"--output-dir <val>     Put documents here (default: .)\"),\n-        (getopts::optopt(opt_output_format()),\n-         ~\"--output-format <val>  'markdown' or 'html' (default)\"),\n-        (getopts::optopt(opt_output_style()),\n-         ~\"--output-style <val>   'doc-per-crate' or 'doc-per-mod' (default)\"),\n-        (getopts::optopt(opt_pandoc_cmd()),\n-         ~\"--pandoc-cmd <val>     Command for running pandoc\"),\n-        (getopts::optflag(opt_help()),\n-         ~\"-h, --help             Print help\")\n-    ]\n-}\n-\n-pub fn usage() {\n-    use std::io::println;\n-\n-    println(\"Usage: rustdoc [options] <cratefile>\\n\");\n-    println(\"Options:\\n\");\n-    let r = opts();\n-    for opt in r.iter() {\n-        printfln!(\"    %s\", opt.second());\n-    }\n-    println(\"\");\n-}\n-\n-pub fn default_config(input_crate: &Path) -> Config {\n-    Config {\n-        input_crate: (*input_crate).clone(),\n-        output_dir: Path(\".\"),\n-        output_format: PandocHtml,\n-        output_style: DocPerMod,\n-        pandoc_cmd: None\n-    }\n-}\n-\n-type Process = ~fn((&str), (&[~str])) -> ProcessOutput;\n-\n-pub fn mock_process_output(_prog: &str, _args: &[~str]) -> ProcessOutput {\n-    ProcessOutput {\n-        status: 0,\n-        output: ~[],\n-        error: ~[]\n-    }\n-}\n-\n-pub fn process_output(prog: &str, args: &[~str]) -> ProcessOutput {\n-    run::process_output(prog, args)\n-}\n-\n-pub fn parse_config(args: &[~str]) -> Result<Config, ~str> {\n-    parse_config_(args, process_output)\n-}\n-\n-pub fn parse_config_(\n-    args: &[~str],\n-    process_output: Process\n-) -> Result<Config, ~str> {\n-    let args = args.tail();\n-    let opts = vec::unzip(opts().move_iter()).first();\n-    match getopts::getopts(args, opts) {\n-        Ok(matches) => {\n-            if matches.free.len() == 1 {\n-                let input_crate = Path(*matches.free.head());\n-                config_from_opts(&input_crate, &matches, process_output)\n-            } else if matches.free.is_empty() {\n-                Err(~\"no crates specified\")\n-            } else {\n-                Err(~\"multiple crates specified\")\n-            }\n-        }\n-        Err(f) => {\n-            Err(f.to_err_msg())\n-        }\n-    }\n-}\n-\n-fn config_from_opts(\n-    input_crate: &Path,\n-    matches: &getopts::Matches,\n-    process_output: Process\n-) -> Result<Config, ~str> {\n-\n-    let config = default_config(input_crate);\n-    let result = result::Ok(config);\n-    let result = do result.and_then |config| {\n-        let output_dir = matches.opt_str(opt_output_dir());\n-        let output_dir = output_dir.map_move(|s| Path(s));\n-        result::Ok(Config {\n-            output_dir: output_dir.unwrap_or(config.output_dir.clone()),\n-            .. config\n-        })\n-    };\n-    let result = do result.and_then |config| {\n-        let output_format = matches.opt_str(opt_output_format());\n-        do output_format.map_move_default(result::Ok(config.clone())) |output_format| {\n-            do parse_output_format(output_format).and_then |output_format| {\n-                result::Ok(Config {\n-                    output_format: output_format,\n-                    .. config.clone()\n-                })\n-            }\n-        }\n-    };\n-    let result = do result.and_then |config| {\n-        let output_style =\n-            matches.opt_str(opt_output_style());\n-        do output_style.map_move_default(result::Ok(config.clone())) |output_style| {\n-            do parse_output_style(output_style).and_then |output_style| {\n-                result::Ok(Config {\n-                    output_style: output_style,\n-                    .. config.clone()\n-                })\n-            }\n-        }\n-    };\n-    let process_output = Cell::new(process_output);\n-    let result = do result.and_then |config| {\n-        let pandoc_cmd = matches.opt_str(opt_pandoc_cmd());\n-        let pandoc_cmd = maybe_find_pandoc(\n-            &config, pandoc_cmd, process_output.take());\n-        do pandoc_cmd.and_then |pandoc_cmd| {\n-            result::Ok(Config {\n-                pandoc_cmd: pandoc_cmd,\n-                .. config.clone()\n-            })\n-        }\n-    };\n-    return result;\n-}\n-\n-fn parse_output_format(output_format: &str) -> Result<OutputFormat, ~str> {\n-    match output_format.to_str() {\n-      ~\"markdown\" => result::Ok(Markdown),\n-      ~\"html\" => result::Ok(PandocHtml),\n-      _ => result::Err(fmt!(\"unknown output format '%s'\", output_format))\n-    }\n-}\n-\n-fn parse_output_style(output_style: &str) -> Result<OutputStyle, ~str> {\n-    match output_style.to_str() {\n-      ~\"doc-per-crate\" => result::Ok(DocPerCrate),\n-      ~\"doc-per-mod\" => result::Ok(DocPerMod),\n-      _ => result::Err(fmt!(\"unknown output style '%s'\", output_style))\n-    }\n-}\n-\n-pub fn maybe_find_pandoc(\n-    config: &Config,\n-    maybe_pandoc_cmd: Option<~str>,\n-    process_output: Process\n-) -> Result<Option<~str>, ~str> {\n-    if config.output_format != PandocHtml {\n-        return result::Ok(maybe_pandoc_cmd);\n-    }\n-\n-    let possible_pandocs = match maybe_pandoc_cmd {\n-      Some(pandoc_cmd) => ~[pandoc_cmd],\n-      None => {\n-        ~[~\"pandoc\"] + match os::homedir() {\n-          Some(dir) => {\n-            ~[dir.push_rel(&Path(\".cabal/bin/pandoc\")).to_str()]\n-          }\n-          None => ~[]\n-        }\n-      }\n-    };\n-\n-    let pandoc = do possible_pandocs.iter().find |&pandoc| {\n-        let output = process_output(*pandoc, [~\"--version\"]);\n-        debug!(\"testing pandoc cmd %s: %?\", *pandoc, output);\n-        output.status == 0\n-    };\n-\n-    match pandoc {\n-        Some(x) => Ok(Some((*x).clone())), // ugly, shouldn't be doubly wrapped\n-        None => Err(~\"couldn't find pandoc\")\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use config::*;\n-    use std::result;\n-    use std::run::ProcessOutput;\n-\n-    fn parse_config(args: &[~str]) -> Result<Config, ~str> {\n-        parse_config_(args, mock_process_output)\n-    }\n-\n-    #[test]\n-    fn should_find_pandoc() {\n-        let config = Config {\n-            output_format: PandocHtml,\n-            .. default_config(&Path(\"test\"))\n-        };\n-        let mock_process_output: ~fn(&str, &[~str]) -> ProcessOutput = |_, _| {\n-            ProcessOutput { status: 0, output: \"pandoc 1.8.2.1\".as_bytes().to_owned(), error: ~[] }\n-        };\n-        let result = maybe_find_pandoc(&config, None, mock_process_output);\n-        assert!(result == result::Ok(Some(~\"pandoc\")));\n-    }\n-\n-    #[test]\n-    fn should_error_with_no_pandoc() {\n-        let config = Config {\n-            output_format: PandocHtml,\n-            .. default_config(&Path(\"test\"))\n-        };\n-        let mock_process_output: ~fn(&str, &[~str]) -> ProcessOutput = |_, _| {\n-            ProcessOutput { status: 1, output: ~[], error: ~[] }\n-        };\n-        let result = maybe_find_pandoc(&config, None, mock_process_output);\n-        assert!(result == result::Err(~\"couldn't find pandoc\"));\n-    }\n-\n-    #[test]\n-    fn should_error_with_no_crates() {\n-        let config = parse_config([~\"rustdoc\"]);\n-        assert!(config.unwrap_err() == ~\"no crates specified\");\n-    }\n-\n-    #[test]\n-    fn should_error_with_multiple_crates() {\n-        let config =\n-            parse_config([~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n-        assert!(config.unwrap_err() == ~\"multiple crates specified\");\n-    }\n-\n-    #[test]\n-    fn should_set_output_dir_to_cwd_if_not_provided() {\n-        let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n-        assert!(config.unwrap().output_dir == Path(\".\"));\n-    }\n-\n-    #[test]\n-    fn should_set_output_dir_if_provided() {\n-        let config = parse_config([\n-            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-dir\", ~\"snuggles\"\n-        ]);\n-        assert!(config.unwrap().output_dir == Path(\"snuggles\"));\n-    }\n-\n-    #[test]\n-    fn should_set_output_format_to_pandoc_html_if_not_provided() {\n-        let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n-        assert!(config.unwrap().output_format == PandocHtml);\n-    }\n-\n-    #[test]\n-    fn should_set_output_format_to_markdown_if_requested() {\n-        let config = parse_config([\n-            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"markdown\"\n-        ]);\n-        assert!(config.unwrap().output_format == Markdown);\n-    }\n-\n-    #[test]\n-    fn should_set_output_format_to_pandoc_html_if_requested() {\n-        let config = parse_config([\n-            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"html\"\n-        ]);\n-        assert!(config.unwrap().output_format == PandocHtml);\n-    }\n-\n-    #[test]\n-    fn should_error_on_bogus_format() {\n-        let config = parse_config([\n-            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"bogus\"\n-        ]);\n-        assert!(config.unwrap_err() == ~\"unknown output format 'bogus'\");\n-    }\n-\n-    #[test]\n-    fn should_set_output_style_to_doc_per_mod_by_default() {\n-        let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n-        assert!(config.unwrap().output_style == DocPerMod);\n-    }\n-\n-    #[test]\n-    fn should_set_output_style_to_one_doc_if_requested() {\n-        let config = parse_config([\n-            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-crate\"\n-        ]);\n-        assert!(config.unwrap().output_style == DocPerCrate);\n-    }\n-\n-    #[test]\n-    fn should_set_output_style_to_doc_per_mod_if_requested() {\n-        let config = parse_config([\n-            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-mod\"\n-        ]);\n-        assert!(config.unwrap().output_style == DocPerMod);\n-    }\n-\n-    #[test]\n-    fn should_error_on_bogus_output_style() {\n-        let config = parse_config([\n-            ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"bogus\"\n-        ]);\n-        assert!(config.unwrap_err() == ~\"unknown output style 'bogus'\");\n-    }\n-\n-    #[test]\n-    fn should_set_pandoc_command_if_requested() {\n-        let config = parse_config([\n-            ~\"rustdoc\", ~\"crate.rc\", ~\"--pandoc-cmd\", ~\"panda-bear-doc\"\n-        ]);\n-        assert!(config.unwrap().pandoc_cmd == Some(~\"panda-bear-doc\"));\n-    }\n-\n-    #[test]\n-    fn should_set_pandoc_command_when_using_pandoc() {\n-        let config = parse_config([~\"rustdoc\", ~\"crate.rc\"]);\n-        assert!(config.unwrap().pandoc_cmd == Some(~\"pandoc\"));\n-    }\n-}"}, {"sha": "9fb5e8c04c10e906b57cb7c904559fd4cfe0186e", "filename": "src/librustdoc/core.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/core.rs"}, {"sha": "23c55488332ad77e277188b52d46d4c73fac4a2e", "filename": "src/librustdoc/demo.rs", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdemo.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,199 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// no-reformat\n-\n-/*!\n- * A demonstration module\n- *\n- * Contains documentation in various forms that rustdoc understands,\n- * for testing purposes. It doesn't surve any functional\n- * purpose. This here, for instance, is just some filler text.\n- *\n- * FIXME (#3731): It would be nice if we could run some automated\n- * tests on this file\n- */\n-\n-\n-/// The base price of a muffin on a non-holiday\n-static PRICE_OF_A_MUFFIN: float = 70f;\n-\n-struct WaitPerson {\n-    hair_color: ~str\n-}\n-\n-/// The type of things that produce omnomnom\n-enum OmNomNomy {\n-    /// Delicious sugar cookies\n-    Cookie,\n-    /// It's pizza\n-    PizzaPie(~[uint])\n-}\n-\n-fn take_my_order_please(\n-    _waitperson: WaitPerson,\n-    _order: ~[OmNomNomy]\n-) -> uint {\n-\n-    /*!\n-     * OMG would you take my order already?\n-     *\n-     * # Arguments\n-     *\n-     * * _waitperson - The waitperson that you want to bother\n-     * * _order - The order vector. It should be filled with food\n-     *\n-     * # Return\n-     *\n-     * The price of the order, including tax\n-     *\n-     * Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec\n-     * molestie nisl. Duis massa risus, pharetra a scelerisque a,\n-     * molestie eu velit. Donec mattis ligula at ante imperdiet ut\n-     * dapibus mauris malesuada.\n-     *\n-     * Sed gravida nisi a metus elementum sit amet hendrerit dolor\n-     * bibendum. Aenean sit amet neque massa, sed tempus tortor. Sed ut\n-     * lobortis enim. Proin a mauris quis nunc fermentum ultrices eget a\n-     * erat. Mauris in lectus vitae metus sodales auctor. Morbi nunc\n-     * quam, ultricies at venenatis non, pellentesque ac dui.\n-     *\n-     * # Failure\n-     *\n-     * This function is full of fail\n-     */\n-\n-    fail!();\n-}\n-\n-mod fortress_of_solitude {\n-    /*!\n-     * Superman's vacation home\n-     *\n-     * The fortress of solitude is located in the Arctic and it is\n-     * cold. What you may not know about the fortress of solitude\n-     * though is that it contains two separate bowling alleys. One of\n-     * them features bumper-bowling and is kind of lame.\n-     *\n-     * Really, it's pretty cool.\n-     */\n-\n-}\n-\n-mod blade_runner {\n-    /*!\n-     * Blade Runner is probably the best movie ever\n-     *\n-     * I like that in the world of Blade Runner it is always\n-     * raining, and that it's always night time. And Aliens\n-     * was also a really good movie.\n-     *\n-     * Alien 3 was crap though.\n-     */\n-}\n-\n-/**\n- * Bored\n- *\n- * Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec\n- * molestie nisl. Duis massa risus, pharetra a scelerisque a,\n- * molestie eu velit. Donec mattis ligula at ante imperdiet ut\n- * dapibus mauris malesuada. Sed gravida nisi a metus elementum sit\n- * amet hendrerit dolor bibendum. Aenean sit amet neque massa, sed\n- * tempus tortor. Sed ut lobortis enim. Proin a mauris quis nunc\n- * fermentum ultrices eget a erat. Mauris in lectus vitae metus\n- * sodales auctor. Morbi nunc quam, ultricies at venenatis non,\n- * pellentesque ac dui.\n- *\n- * Quisque vitae est id eros placerat laoreet sit amet eu\n- * nisi. Curabitur suscipit neque porttitor est euismod\n- * lacinia. Curabitur non quam vitae ipsum adipiscing\n- * condimentum. Mauris ut ante eget metus sollicitudin\n- * blandit. Aliquam erat volutpat. Morbi sed nisl mauris. Nulla\n- * facilisi. Phasellus at mollis ipsum. Maecenas sed convallis\n- * sapien. Nullam in ligula turpis. Pellentesque a neque augue. Sed\n- * eget ante feugiat tortor congue auctor ac quis ante. Proin\n- * condimentum lacinia tincidunt.\n- */\n-struct Bored {\n-  bored: bool,\n-}\n-\n-impl Drop for Bored {\n-  fn drop(&mut self) { }\n-}\n-\n-/**\n- * The Shunned House\n- *\n- * From even the greatest of horrors irony is seldom absent. Sometimes it\n- * enters directly into the composition of the events, while sometimes it\n- * relates only to their fortuitous position among persons and\n- * places. The latter sort is splendidly exemplified by a case in the\n- * ancient city of Providence, where in the late forties Edgar Allan Poe\n- * used to sojourn often during his unsuccessful wooing of the gifted\n- * poetess, Mrs.  Whitman. Poe generally stopped at the Mansion House in\n- * Benefit Street--the renamed Golden Ball Inn whose roof has sheltered\n- * Washington, Jefferson, and Lafayette--and his favorite walk led\n- * northward along the same street to Mrs. Whitman's home and the\n- * neighboring hillside churchyard of St. John's, whose hidden expanse of\n- * Eighteenth Century gravestones had for him a peculiar fascination.\n- */\n-trait TheShunnedHouse {\n-    /**\n-     * Now the irony is this. In this walk, so many times repeated, the\n-     * world's greatest master of the terrible and the bizarre was\n-     * obliged to pass a particular house on the eastern side of the\n-     * street; a dingy, antiquated structure perched on the abruptly\n-     * rising side hill, with a great unkempt yard dating from a time\n-     * when the region was partly open country. It does not appear that\n-     * he ever wrote or spoke of it, nor is there any evidence that he\n-     * even noticed it. And yet that house, to the two persons in\n-     * possession of certain information, equals or outranks in horror\n-     * the wildest fantasy of the genius who so often passed it\n-     * unknowingly, and stands starkly leering as a symbol of all that is\n-     * unutterably hideous.\n-     *\n-     * # Arguments\n-     *\n-     * * unkempt_yard - A yard dating from a time when the region was partly\n-     *                  open country\n-     */\n-    fn dingy_house(&self, unkempt_yard: int);\n-\n-    /**\n-     * The house was--and for that matter still is--of a kind to attract\n-     * the attention of the curious. Originally a farm or semi-farm\n-     * building, it followed the average New England colonial lines of\n-     * the middle Eighteenth Century--the prosperous peaked-roof sort,\n-     * with two stories and dormerless attic, and with the Georgian\n-     * doorway and interior panelling dictated by the progress of taste\n-     * at that time. It faced south, with one gable end buried to the\n-     * lower windows in the eastward rising hill, and the other exposed\n-     * to the foundations toward the street. Its construction, over a\n-     * century and a half ago, had followed the grading and straightening\n-     * of the road in that especial vicinity; for Benefit Street--at\n-     * first called Back Street--was laid out as a lane winding amongst\n-     * the graveyards of the first settlers, and straightened only when\n-     * the removal of the bodies to the North Burial Ground made it\n-     * decently possible to cut through the old family plots.\n-     */\n-    fn construct(&self) -> bool;\n-}\n-\n-/// Whatever\n-impl TheShunnedHouse for OmNomNomy {\n-    fn dingy_house(&self, _unkempt_yard: int) {\n-    }\n-\n-    fn construct(&self) -> bool {\n-        fail!();\n-    }\n-}"}, {"sha": "9f8041712eaecdb12d38bb0843ec7edbe675e9c2", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "removed", "additions": 0, "deletions": 288, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,288 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Pulls a brief description out of a long description.\n-\n-If the first paragraph of a long description is short enough then it\n-is interpreted as the brief description.\n-*/\n-\n-\n-use astsrv;\n-use doc::ItemUtils;\n-use doc;\n-use fold::Fold;\n-use fold;\n-use pass::Pass;\n-\n-use std::util;\n-\n-pub fn mk_pass() -> Pass {\n-    Pass {\n-        name: ~\"desc_to_brief\",\n-        f: run\n-    }\n-}\n-\n-pub fn run(\n-    _srv: astsrv::Srv,\n-    doc: doc::Doc\n-) -> doc::Doc {\n-    let fold = Fold {\n-        fold_item: fold_item,\n-        fold_trait: fold_trait,\n-        fold_impl: fold_impl,\n-        .. fold::default_any_fold(())\n-    };\n-    (fold.fold_doc)(&fold, doc)\n-}\n-\n-fn fold_item(fold: &fold::Fold<()>, doc: doc::ItemDoc) -> doc::ItemDoc {\n-    let doc = fold::default_seq_fold_item(fold, doc);\n-\n-    doc::ItemDoc {\n-        brief: extract(doc.desc.clone()),\n-        .. doc\n-    }\n-}\n-\n-fn fold_trait(fold: &fold::Fold<()>, doc: doc::TraitDoc) -> doc::TraitDoc {\n-    let doc =fold::default_seq_fold_trait(fold, doc);\n-\n-    doc::TraitDoc {\n-        methods: doc.methods.map(|doc| doc::MethodDoc {\n-            brief: extract(doc.desc.clone()),\n-            .. (*doc).clone()\n-        }),\n-        .. doc\n-    }\n-}\n-\n-fn fold_impl(fold: &fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n-    let doc =fold::default_seq_fold_impl(fold, doc);\n-\n-    doc::ImplDoc {\n-        methods: doc.methods.map(|doc| doc::MethodDoc {\n-            brief: extract(doc.desc.clone()),\n-            .. (*doc).clone()\n-        }),\n-        .. doc\n-    }\n-}\n-\n-pub fn extract(desc: Option<~str>) -> Option<~str> {\n-    if desc.is_none() {\n-        return None\n-    }\n-\n-    parse_desc(desc.clone().unwrap())\n-}\n-\n-fn parse_desc(desc: ~str) -> Option<~str> {\n-    static MAX_BRIEF_LEN: uint = 120u;\n-\n-    match first_sentence(desc.clone()) {\n-      Some(first_sentence) => {\n-        if first_sentence.len() <= MAX_BRIEF_LEN {\n-            Some(first_sentence)\n-        } else {\n-            None\n-        }\n-      }\n-      None => None\n-    }\n-}\n-\n-fn first_sentence(s: ~str) -> Option<~str> {\n-    let paras = paragraphs(s);\n-    if !paras.is_empty() {\n-        let first_para = paras.head();\n-        Some(first_sentence_(*first_para).replace(\"\\n\", \" \"))\n-    } else {\n-        None\n-    }\n-}\n-\n-fn first_sentence_(s: &str) -> ~str {\n-    let mut dotcount = 0;\n-    // The index of the character following a single dot. This allows\n-    // Things like [0..1) to appear in the brief description\n-    let idx = s.find(|ch: char| {\n-        if ch == '.' {\n-            dotcount += 1;\n-            false\n-        } else if dotcount == 1 {\n-            true\n-        } else {\n-            dotcount = 0;\n-            false\n-        }\n-    });\n-    match idx {\n-        Some(idx) if idx > 2u => s.slice(0, idx - 1).to_owned(),\n-        _ => {\n-            if s.ends_with(\".\") {\n-                s.to_owned()\n-            } else {\n-                s.to_owned()\n-            }\n-        }\n-    }\n-}\n-\n-pub fn paragraphs(s: &str) -> ~[~str] {\n-    let mut whitespace_lines = 0;\n-    let mut accum = ~\"\";\n-    let mut paras = do s.any_line_iter().fold(~[]) |paras, line| {\n-        let mut res = paras;\n-\n-        if line.is_whitespace() {\n-            whitespace_lines += 1;\n-        } else {\n-            if whitespace_lines > 0 {\n-                if !accum.is_empty() {\n-                    let v = util::replace(&mut accum, ~\"\");\n-                    res.push(v);\n-                }\n-            }\n-\n-            whitespace_lines = 0;\n-\n-            accum = if accum.is_empty() {\n-                line.to_owned()\n-            } else {\n-                fmt!(\"%s\\n%s\", accum, line)\n-            }\n-        }\n-\n-        res\n-    };\n-\n-    if !accum.is_empty() { paras.push(accum); }\n-    paras\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use astsrv;\n-    use attr_pass;\n-    use super::{extract, paragraphs, run};\n-    use doc;\n-    use extract;\n-\n-    fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(source.clone()) |srv| {\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n-            run(srv.clone(), doc)\n-        }\n-    }\n-\n-    #[test]\n-    fn should_promote_desc() {\n-        let doc = mk_doc(~\"#[doc = \\\"desc\\\"] mod m { }\");\n-        // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().mods()[1].brief(), Some(~\"desc\"));\n-    }\n-\n-    #[test]\n-    fn should_promote_trait_method_desc() {\n-        let doc = mk_doc(~\"trait i { #[doc = \\\"desc\\\"] fn a(); }\");\n-        assert!(doc.cratemod().traits()[0].methods[0].brief ==\n-                Some(~\"desc\"));\n-    }\n-\n-    #[test]\n-    fn should_promote_impl_method_desc() {\n-        let doc = mk_doc(\n-            ~\"impl int { #[doc = \\\"desc\\\"] fn a() { } }\");\n-        assert!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"desc\"));\n-    }\n-\n-    #[test]\n-    fn test_paragraphs_1() {\n-        let paras = paragraphs(\"1\\n\\n2\");\n-        assert_eq!(paras, ~[~\"1\", ~\"2\"]);\n-    }\n-\n-    #[test]\n-    fn test_paragraphs_2() {\n-        let paras = paragraphs(\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n-        assert_eq!(paras, ~[~\"1\\n1\", ~\"2\"]);\n-    }\n-\n-    #[test]\n-    fn should_promote_short_descs() {\n-        let desc = Some(~\"desc\");\n-        let brief = extract(desc.clone());\n-        assert_eq!(brief, desc);\n-    }\n-\n-    #[test]\n-    fn should_not_promote_long_descs() {\n-        let desc = Some(~\"Warkworth Castle is a ruined medieval building\n-in the town of the same name in the English county of Northumberland,\n-and the town and castle occupy a loop of the River Coquet, less than a mile\n-from England's north-east coast. When the castle was founded is uncertain,\n-but traditionally its construction has been ascribed to Prince Henry of\n-Scotland in the mid 12th century, although it may have been built by\n-King Henry II of England when he took control of England'snorthern\n-counties.\");\n-        let brief = extract(desc);\n-        assert_eq!(brief, None);\n-    }\n-\n-    #[test]\n-    fn should_promote_first_sentence() {\n-        let desc = Some(~\"Warkworth Castle is a ruined medieval building\n-in the town. of the same name in the English county of Northumberland,\n-and the town and castle occupy a loop of the River Coquet, less than a mile\n-from England's north-east coast. When the castle was founded is uncertain,\n-but traditionally its construction has been ascribed to Prince Henry of\n-Scotland in the mid 12th century, although it may have been built by\n-King Henry II of England when he took control of England'snorthern\n-counties.\");\n-        let brief = extract(desc);\n-        assert!(brief == Some(\n-            ~\"Warkworth Castle is a ruined medieval building in the town\"));\n-    }\n-\n-    #[test]\n-    fn should_not_consider_double_period_to_end_sentence() {\n-        let desc = Some(~\"Warkworth..Castle is a ruined medieval building\n-in the town. of the same name in the English county of Northumberland,\n-and the town and castle occupy a loop of the River Coquet, less than a mile\n-from England's north-east coast. When the castle was founded is uncertain,\n-but traditionally its construction has been ascribed to Prince Henry of\n-Scotland in the mid 12th century, although it may have been built by\n-King Henry II of England when he took control of England'snorthern\n-counties.\");\n-        let brief = extract(desc);\n-        assert!(brief == Some(\n-            ~\"Warkworth..Castle is a ruined medieval building in the town\"));\n-    }\n-\n-    #[test]\n-    fn should_not_consider_triple_period_to_end_sentence() {\n-        let desc = Some(~\"Warkworth... Castle is a ruined medieval building\n-in the town. of the same name in the English county of Northumberland,\n-and the town and castle occupy a loop of the River Coquet, less than a mile\n-from England's north-east coast. When the castle was founded is uncertain,\n-but traditionally its construction has been ascribed to Prince Henry of\n-Scotland in the mid 12th century, although it may have been built by\n-King Henry II of England when he took control of England'snorthern\n-counties.\");\n-        let brief = extract(desc);\n-        assert!(brief == Some(\n-            ~\"Warkworth... Castle is a ruined medieval building in the town\"));\n-    }\n-}"}, {"sha": "aba7ea1f0d753f807e7b30021f2f9724ce942533", "filename": "src/librustdoc/doc.rs", "status": "removed", "additions": 0, "deletions": 393, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,393 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The document model\n-\n-\n-use doc;\n-\n-pub type AstId = int;\n-\n-#[deriving(Clone, Eq)]\n-pub struct Doc {\n-    pages: ~[Page]\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub enum Page {\n-    CratePage(CrateDoc),\n-    ItemPage(ItemTag)\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub enum Implementation {\n-    Required,\n-    Provided,\n-}\n-\n-/**\n- * Most rustdocs can be parsed into 'sections' according to their markdown\n- * headers\n- */\n-#[deriving(Clone, Eq)]\n-pub struct Section {\n-    header: ~str,\n-    body: ~str\n-}\n-\n-// FIXME (#2596): We currently give topmod the name of the crate.  There\n-// would probably be fewer special cases if the crate had its own name\n-// and topmod's name was the empty string.\n-#[deriving(Clone, Eq)]\n-pub struct CrateDoc {\n-    topmod: ModDoc\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub enum ItemTag {\n-    ModTag(ModDoc),\n-    NmodTag(NmodDoc),\n-    StaticTag(StaticDoc),\n-    FnTag(FnDoc),\n-    EnumTag(EnumDoc),\n-    TraitTag(TraitDoc),\n-    ImplTag(ImplDoc),\n-    TyTag(TyDoc),\n-    StructTag(StructDoc)\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub struct ItemDoc {\n-    id: AstId,\n-    name: ~str,\n-    path: ~[~str],\n-    brief: Option<~str>,\n-    desc: Option<~str>,\n-    sections: ~[Section],\n-    // Indicates that this node is a reexport of a different item\n-    reexport: bool\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub struct SimpleItemDoc {\n-    item: ItemDoc,\n-    sig: Option<~str>\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub struct ModDoc {\n-    item: ItemDoc,\n-    items: ~[ItemTag],\n-    index: Option<Index>\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub struct NmodDoc {\n-    item: ItemDoc,\n-    fns: ~[FnDoc],\n-    index: Option<Index>\n-}\n-\n-pub type StaticDoc = SimpleItemDoc;\n-\n-pub type FnDoc = SimpleItemDoc;\n-\n-#[deriving(Clone, Eq)]\n-pub struct EnumDoc {\n-    item: ItemDoc,\n-    variants: ~[VariantDoc]\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub struct VariantDoc {\n-    name: ~str,\n-    desc: Option<~str>,\n-    sig: Option<~str>\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub struct TraitDoc {\n-    item: ItemDoc,\n-    methods: ~[MethodDoc]\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub struct MethodDoc {\n-    name: ~str,\n-    brief: Option<~str>,\n-    desc: Option<~str>,\n-    sections: ~[Section],\n-    sig: Option<~str>,\n-    implementation: Implementation,\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub struct ImplDoc {\n-    item: ItemDoc,\n-    bounds_str: Option<~str>,\n-    trait_types: ~[~str],\n-    self_ty: Option<~str>,\n-    methods: ~[MethodDoc]\n-}\n-\n-pub type TyDoc = SimpleItemDoc;\n-\n-#[deriving(Clone, Eq)]\n-pub struct StructDoc {\n-    item: ItemDoc,\n-    fields: ~[~str],\n-    sig: Option<~str>\n-}\n-\n-#[deriving(Clone, Eq)]\n-pub struct Index {\n-    entries: ~[IndexEntry]\n-}\n-\n-/**\n- * A single entry in an index\n- *\n- * Fields:\n- *\n- * * kind - The type of thing being indexed, e.g. 'Module'\n- * * name - The name of the thing\n- * * brief - The brief description\n- * * link - A format-specific string representing the link target\n- */\n-#[deriving(Clone, Eq)]\n-pub struct IndexEntry {\n-    kind: ~str,\n-    name: ~str,\n-    brief: Option<~str>,\n-    link: ~str\n-}\n-\n-impl Doc {\n-    pub fn CrateDoc(&self) -> CrateDoc {\n-        self.pages.iter().fold(None, |_m, page| {\n-            match (*page).clone() {\n-              doc::CratePage(doc) => Some(doc),\n-              _ => None\n-            }\n-        }).unwrap()\n-    }\n-\n-    pub fn cratemod(&self) -> ModDoc {\n-        self.CrateDoc().topmod.clone()\n-    }\n-}\n-\n-macro_rules! filt_mapper {\n-    ($vec:expr, $pat:pat) => {\n-        do ($vec).iter().filter_map |thing| {\n-            match thing {\n-                &$pat => Some((*x).clone()),\n-                _ => None\n-            }\n-        }.collect()\n-    }\n-}\n-\n-macro_rules! md {\n-    ($id:ident) => {\n-        filt_mapper!(self.items, $id(ref x))\n-    }\n-}\n-/// Some helper methods on ModDoc, mostly for testing\n-impl ModDoc {\n-    pub fn mods(&self) -> ~[ModDoc] {\n-        md!(ModTag)\n-    }\n-\n-    pub fn nmods(&self) -> ~[NmodDoc] {\n-        md!(NmodTag)\n-    }\n-\n-    pub fn fns(&self) -> ~[FnDoc] {\n-        md!(FnTag)\n-    }\n-\n-    pub fn statics(&self) -> ~[StaticDoc] {\n-        md!(StaticTag)\n-    }\n-\n-    pub fn enums(&self) -> ~[EnumDoc] {\n-        md!(EnumTag)\n-    }\n-\n-    pub fn traits(&self) -> ~[TraitDoc] {\n-        md!(TraitTag)\n-    }\n-\n-    pub fn impls(&self) -> ~[ImplDoc] {\n-        md!(ImplTag)\n-    }\n-\n-    pub fn types(&self) -> ~[TyDoc] {\n-        md!(TyTag)\n-    }\n-\n-    pub fn structs(&self) -> ~[StructDoc] {\n-        md!(StructTag)\n-    }\n-}\n-\n-macro_rules! pu {\n-    ($id:ident) => {\n-        filt_mapper!(*self, ItemPage($id(ref x)))\n-    }\n-}\n-\n-pub trait PageUtils {\n-    fn mods(&self) -> ~[ModDoc];\n-    fn nmods(&self) -> ~[NmodDoc];\n-    fn fns(&self) -> ~[FnDoc];\n-    fn statics(&self) -> ~[StaticDoc];\n-    fn enums(&self) -> ~[EnumDoc];\n-    fn traits(&self) -> ~[TraitDoc];\n-    fn impls(&self) -> ~[ImplDoc];\n-    fn types(&self) -> ~[TyDoc];\n-}\n-\n-impl PageUtils for ~[Page] {\n-\n-    fn mods(&self) -> ~[ModDoc] {\n-        pu!(ModTag)\n-    }\n-\n-    fn nmods(&self) -> ~[NmodDoc] {\n-        pu!(NmodTag)\n-    }\n-\n-    fn fns(&self) -> ~[FnDoc] {\n-        pu!(FnTag)\n-    }\n-\n-    fn statics(&self) -> ~[StaticDoc] {\n-        pu!(StaticTag)\n-    }\n-\n-    fn enums(&self) -> ~[EnumDoc] {\n-        pu!(EnumTag)\n-    }\n-\n-    fn traits(&self) -> ~[TraitDoc] {\n-        pu!(TraitTag)\n-    }\n-\n-    fn impls(&self) -> ~[ImplDoc] {\n-        pu!(ImplTag)\n-    }\n-\n-    fn types(&self) -> ~[TyDoc] {\n-        pu!(TyTag)\n-    }\n-}\n-\n-pub trait Item {\n-    fn item(&self) -> ItemDoc;\n-}\n-\n-impl Item for ItemTag {\n-    fn item(&self) -> ItemDoc {\n-        match self {\n-          &doc::ModTag(ref doc) => doc.item.clone(),\n-          &doc::NmodTag(ref doc) => doc.item.clone(),\n-          &doc::FnTag(ref doc) => doc.item.clone(),\n-          &doc::StaticTag(ref doc) => doc.item.clone(),\n-          &doc::EnumTag(ref doc) => doc.item.clone(),\n-          &doc::TraitTag(ref doc) => doc.item.clone(),\n-          &doc::ImplTag(ref doc) => doc.item.clone(),\n-          &doc::TyTag(ref doc) => doc.item.clone(),\n-          &doc::StructTag(ref doc) => doc.item.clone(),\n-        }\n-    }\n-}\n-\n-impl Item for SimpleItemDoc {\n-    fn item(&self) -> ItemDoc {\n-        self.item.clone()\n-    }\n-}\n-\n-impl Item for ModDoc {\n-    fn item(&self) -> ItemDoc {\n-        self.item.clone()\n-    }\n-}\n-\n-impl Item for NmodDoc {\n-    fn item(&self) -> ItemDoc {\n-        self.item.clone()\n-    }\n-}\n-\n-impl Item for EnumDoc {\n-    fn item(&self) -> ItemDoc {\n-        self.item.clone()\n-    }\n-}\n-\n-impl Item for TraitDoc {\n-    fn item(&self) -> ItemDoc {\n-        self.item.clone()\n-    }\n-}\n-\n-impl Item for ImplDoc {\n-    fn item(&self) -> ItemDoc {\n-        self.item.clone()\n-    }\n-}\n-\n-impl Item for StructDoc {\n-    fn item(&self) -> ItemDoc {\n-        self.item.clone()\n-    }\n-}\n-\n-pub trait ItemUtils {\n-    fn id(&self) -> AstId;\n-    /// FIXME #5898: This conflicts with\n-    /// syntax::attr::AttrMetaMethods.name; This rustdoc seems to be on\n-    /// the way out so I'm making this one look bad rather than the\n-    /// new methods in attr.\n-    fn name_(&self) -> ~str;\n-    fn path(&self) -> ~[~str];\n-    fn brief(&self) -> Option<~str>;\n-    fn desc(&self) -> Option<~str>;\n-    fn sections(&self) -> ~[Section];\n-}\n-\n-impl<A:Item> ItemUtils for A {\n-    fn id(&self) -> AstId {\n-        self.item().id\n-    }\n-\n-    fn name_(&self) -> ~str {\n-        self.item().name.clone()\n-    }\n-\n-    fn path(&self) -> ~[~str] {\n-        self.item().path.clone()\n-    }\n-\n-    fn brief(&self) -> Option<~str> {\n-        self.item().brief.clone()\n-    }\n-\n-    fn desc(&self) -> Option<~str> {\n-        self.item().desc.clone()\n-    }\n-\n-    fn sections(&self) -> ~[Section] {\n-        self.item().sections.clone()\n-    }\n-}"}, {"sha": "67722b1e1777a6d929baa235fa265b742284bee7", "filename": "src/librustdoc/doctree.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/doctree.rs"}, {"sha": "2f09e0a5ddc55e7d3593b92a4022b65e3beb5258", "filename": "src/librustdoc/escape_pass.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fescape_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fescape_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fescape_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Escapes text sequences\n-\n-use pass::Pass;\n-use text_pass;\n-\n-pub fn mk_pass() -> Pass {\n-    text_pass::mk_pass(~\"escape\", escape)\n-}\n-\n-fn escape(s: &str) -> ~str {\n-    s.replace(\"\\\\\", \"\\\\\\\\\")\n-}\n-\n-#[test]\n-fn should_escape_backslashes() {\n-    let s = ~\"\\\\n\";\n-    let r = escape(s);\n-    assert_eq!(r, ~\"\\\\\\\\n\");\n-}"}, {"sha": "2ab0530ccb3c3b59e580c90fdc2d9d9f84043b48", "filename": "src/librustdoc/extract.rs", "status": "removed", "additions": 0, "deletions": 414, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,414 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Converts the Rust AST to the rustdoc document model\n-\n-\n-use astsrv;\n-use doc::ItemUtils;\n-use doc;\n-\n-use syntax::ast;\n-use syntax::parse::token::{ident_interner, ident_to_str};\n-use syntax::parse::token;\n-\n-// Hack; rather than thread an interner through everywhere, rely on\n-// thread-local data\n-// Hack-Becomes-Feature: using thread-local-state everywhere...\n-pub fn to_str(id: ast::Ident) -> ~str {\n-    /* bad */ ident_to_str(&id).to_owned()\n-}\n-\n-// get rid of this pointless function:\n-pub fn interner() -> @ident_interner {\n-    return token::get_ident_interner();\n-}\n-\n-pub fn from_srv(\n-    srv: astsrv::Srv,\n-    default_name: ~str\n-) -> doc::Doc {\n-\n-    //! Use the AST service to create a document tree\n-\n-    do astsrv::exec(srv) |ctxt| {\n-        extract(ctxt.ast, default_name.clone())\n-    }\n-}\n-\n-pub fn extract(\n-    crate: @ast::Crate,\n-    default_name: ~str\n-) -> doc::Doc {\n-    doc::Doc {\n-        pages: ~[\n-            doc::CratePage(doc::CrateDoc {\n-                topmod: top_moddoc_from_crate(crate, default_name),\n-            })\n-        ]\n-    }\n-}\n-\n-fn top_moddoc_from_crate(\n-    crate: @ast::Crate,\n-    default_name: ~str\n-) -> doc::ModDoc {\n-    moddoc_from_mod(mk_itemdoc(ast::CRATE_NODE_ID, default_name),\n-                    crate.module.clone())\n-}\n-\n-fn mk_itemdoc(id: ast::NodeId, name: ~str) -> doc::ItemDoc {\n-    doc::ItemDoc {\n-        id: id,\n-        name: name,\n-        path: ~[],\n-        brief: None,\n-        desc: None,\n-        sections: ~[],\n-        reexport: false\n-    }\n-}\n-\n-fn moddoc_from_mod(\n-    itemdoc: doc::ItemDoc,\n-    module_: ast::_mod\n-) -> doc::ModDoc {\n-    doc::ModDoc {\n-        item: itemdoc,\n-        items: do module_.items.iter().filter_map |item| {\n-            let ItemDoc = mk_itemdoc(item.id, to_str(item.ident));\n-            match item.node.clone() {\n-              ast::item_mod(m) => {\n-                Some(doc::ModTag(\n-                    moddoc_from_mod(ItemDoc, m)\n-                ))\n-              }\n-              ast::item_foreign_mod(nm) => {\n-                Some(doc::NmodTag(\n-                    nmoddoc_from_mod(ItemDoc, nm)\n-                ))\n-              }\n-              ast::item_fn(*) => {\n-                Some(doc::FnTag(\n-                    fndoc_from_fn(ItemDoc)\n-                ))\n-              }\n-              ast::item_static(*) => {\n-                Some(doc::StaticTag(\n-                    staticdoc_from_static(ItemDoc)\n-                ))\n-              }\n-              ast::item_enum(enum_definition, _) => {\n-                Some(doc::EnumTag(\n-                    enumdoc_from_enum(ItemDoc, enum_definition.variants.clone())\n-                ))\n-              }\n-              ast::item_trait(_, _, methods) => {\n-                Some(doc::TraitTag(\n-                    traitdoc_from_trait(ItemDoc, methods)\n-                ))\n-              }\n-              ast::item_impl(_, _, _, methods) => {\n-                Some(doc::ImplTag(\n-                    impldoc_from_impl(ItemDoc, methods)\n-                ))\n-              }\n-              ast::item_ty(_, _) => {\n-                Some(doc::TyTag(\n-                    tydoc_from_ty(ItemDoc)\n-                ))\n-              }\n-              ast::item_struct(def, _) => {\n-                Some(doc::StructTag(\n-                    structdoc_from_struct(ItemDoc, def)\n-                ))\n-              }\n-              _ => None\n-            }\n-        }.collect(),\n-        index: None\n-    }\n-}\n-\n-fn nmoddoc_from_mod(\n-    itemdoc: doc::ItemDoc,\n-    module_: ast::foreign_mod\n-) -> doc::NmodDoc {\n-    let mut fns = ~[];\n-    for item in module_.items.iter() {\n-        let ItemDoc = mk_itemdoc(item.id, to_str(item.ident));\n-        match item.node {\n-          ast::foreign_item_fn(*) => {\n-            fns.push(fndoc_from_fn(ItemDoc));\n-          }\n-          ast::foreign_item_static(*) => {} // XXX: Not implemented.\n-        }\n-    }\n-    doc::NmodDoc {\n-        item: itemdoc,\n-        fns: fns,\n-        index: None\n-    }\n-}\n-\n-fn fndoc_from_fn(itemdoc: doc::ItemDoc) -> doc::FnDoc {\n-    doc::SimpleItemDoc {\n-        item: itemdoc,\n-        sig: None\n-    }\n-}\n-\n-fn staticdoc_from_static(itemdoc: doc::ItemDoc) -> doc::StaticDoc {\n-    doc::SimpleItemDoc {\n-        item: itemdoc,\n-        sig: None\n-    }\n-}\n-\n-fn enumdoc_from_enum(\n-    itemdoc: doc::ItemDoc,\n-    variants: ~[ast::variant]\n-) -> doc::EnumDoc {\n-    doc::EnumDoc {\n-        item: itemdoc,\n-        variants: variantdocs_from_variants(variants)\n-    }\n-}\n-\n-fn variantdocs_from_variants(\n-    variants: ~[ast::variant]\n-) -> ~[doc::VariantDoc] {\n-    variants.iter().map(variantdoc_from_variant).collect()\n-}\n-\n-fn variantdoc_from_variant(variant: &ast::variant) -> doc::VariantDoc {\n-    doc::VariantDoc {\n-        name: to_str(variant.node.name),\n-        desc: None,\n-        sig: None\n-    }\n-}\n-\n-fn traitdoc_from_trait(\n-    itemdoc: doc::ItemDoc,\n-    methods: ~[ast::trait_method]\n-) -> doc::TraitDoc {\n-    doc::TraitDoc {\n-        item: itemdoc,\n-        methods: do methods.iter().map |method| {\n-            match (*method).clone() {\n-              ast::required(ty_m) => {\n-                doc::MethodDoc {\n-                    name: to_str(ty_m.ident),\n-                    brief: None,\n-                    desc: None,\n-                    sections: ~[],\n-                    sig: None,\n-                    implementation: doc::Required,\n-                }\n-              }\n-              ast::provided(m) => {\n-                doc::MethodDoc {\n-                    name: to_str(m.ident),\n-                    brief: None,\n-                    desc: None,\n-                    sections: ~[],\n-                    sig: None,\n-                    implementation: doc::Provided,\n-                }\n-              }\n-            }\n-        }.collect()\n-    }\n-}\n-\n-fn impldoc_from_impl(\n-    itemdoc: doc::ItemDoc,\n-    methods: ~[@ast::method]\n-) -> doc::ImplDoc {\n-    doc::ImplDoc {\n-        item: itemdoc,\n-        bounds_str: None,\n-        trait_types: ~[],\n-        self_ty: None,\n-        methods: do methods.iter().map |method| {\n-            doc::MethodDoc {\n-                name: to_str(method.ident),\n-                brief: None,\n-                desc: None,\n-                sections: ~[],\n-                sig: None,\n-                implementation: doc::Provided,\n-            }\n-        }.collect()\n-    }\n-}\n-\n-fn tydoc_from_ty(\n-    itemdoc: doc::ItemDoc\n-) -> doc::TyDoc {\n-    doc::SimpleItemDoc {\n-        item: itemdoc,\n-        sig: None\n-    }\n-}\n-\n-fn structdoc_from_struct(\n-    itemdoc: doc::ItemDoc,\n-    struct_def: @ast::struct_def\n-) -> doc::StructDoc {\n-    doc::StructDoc {\n-        item: itemdoc,\n-        fields: do struct_def.fields.map |field| {\n-            match field.node.kind {\n-                ast::named_field(ident, _) => to_str(ident),\n-                ast::unnamed_field => ~\"(unnamed)\",\n-            }\n-        },\n-        sig: None\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use astsrv;\n-    use doc;\n-    use extract::{extract, from_srv};\n-    use parse;\n-\n-    fn mk_doc(source: @str) -> doc::Doc {\n-        let ast = parse::from_str(source);\n-        debug!(\"ast=%?\", ast);\n-        extract(ast, ~\"\")\n-    }\n-\n-    #[test]\n-    fn extract_empty_crate() {\n-        let doc = mk_doc(@\"\");\n-        assert!(doc.cratemod().mods().is_empty());\n-        assert!(doc.cratemod().fns().is_empty());\n-    }\n-\n-    #[test]\n-    fn extract_mods() {\n-        let doc = mk_doc(@\"mod a { mod b { } mod c { } }\");\n-        assert!(doc.cratemod().mods()[0].name_() == ~\"a\");\n-        assert!(doc.cratemod().mods()[0].mods()[0].name_() == ~\"b\");\n-        assert!(doc.cratemod().mods()[0].mods()[1].name_() == ~\"c\");\n-    }\n-\n-    #[test]\n-    fn extract_fns_from_foreign_mods() {\n-        let doc = mk_doc(@\"extern { fn a(); }\");\n-        assert!(doc.cratemod().nmods()[0].fns[0].name_() == ~\"a\");\n-    }\n-\n-    #[test]\n-    fn extract_mods_deep() {\n-        let doc = mk_doc(@\"mod a { mod b { mod c { } } }\");\n-        assert!(doc.cratemod().mods()[0].mods()[0].mods()[0].name_() ==\n-            ~\"c\");\n-    }\n-\n-    #[test]\n-    fn extract_should_set_mod_ast_id() {\n-        let doc = mk_doc(@\"mod a { }\");\n-        assert!(doc.cratemod().mods()[0].id() != 0);\n-    }\n-\n-    #[test]\n-    fn extract_fns() {\n-        let doc = mk_doc(\n-            @\"fn a() { } \\\n-              mod b { fn c() {\n-             } }\");\n-        assert!(doc.cratemod().fns()[0].name_() == ~\"a\");\n-        assert!(doc.cratemod().mods()[0].fns()[0].name_() == ~\"c\");\n-    }\n-\n-    #[test]\n-    fn extract_should_set_fn_ast_id() {\n-        let doc = mk_doc(@\"fn a() { }\");\n-        assert!(doc.cratemod().fns()[0].id() != 0);\n-    }\n-\n-    #[test]\n-    fn extract_should_use_default_crate_name() {\n-        let source = @\"\";\n-        let ast = parse::from_str(source);\n-        let doc = extract(ast, ~\"burp\");\n-        assert!(doc.cratemod().name_() == ~\"burp\");\n-    }\n-\n-    #[test]\n-    fn extract_from_seq_srv() {\n-        let source = ~\"\";\n-        do astsrv::from_str(source) |srv| {\n-            let doc = from_srv(srv, ~\"name\");\n-            assert!(doc.cratemod().name_() == ~\"name\");\n-        }\n-    }\n-\n-    #[test]\n-    fn should_extract_static_name_and_id() {\n-        let doc = mk_doc(@\"static a: int = 0;\");\n-        assert!(doc.cratemod().statics()[0].id() != 0);\n-        assert!(doc.cratemod().statics()[0].name_() == ~\"a\");\n-    }\n-\n-    #[test]\n-    fn should_extract_enums() {\n-        let doc = mk_doc(@\"enum e { v }\");\n-        assert!(doc.cratemod().enums()[0].id() != 0);\n-        assert!(doc.cratemod().enums()[0].name_() == ~\"e\");\n-    }\n-\n-    #[test]\n-    fn should_extract_enum_variants() {\n-        let doc = mk_doc(@\"enum e { v }\");\n-        assert!(doc.cratemod().enums()[0].variants[0].name == ~\"v\");\n-    }\n-\n-    #[test]\n-    fn should_extract_traits() {\n-        let doc = mk_doc(@\"trait i { fn f(); }\");\n-        assert!(doc.cratemod().traits()[0].name_() == ~\"i\");\n-    }\n-\n-    #[test]\n-    fn should_extract_trait_methods() {\n-        let doc = mk_doc(@\"trait i { fn f(); }\");\n-        assert!(doc.cratemod().traits()[0].methods[0].name == ~\"f\");\n-    }\n-\n-    #[test]\n-    fn should_extract_impl_methods() {\n-        let doc = mk_doc(@\"impl int { fn f() { } }\");\n-        assert!(doc.cratemod().impls()[0].methods[0].name == ~\"f\");\n-    }\n-\n-    #[test]\n-    fn should_extract_tys() {\n-        let doc = mk_doc(@\"type a = int;\");\n-        assert!(doc.cratemod().types()[0].name_() == ~\"a\");\n-    }\n-\n-    #[test]\n-    fn should_extract_structs() {\n-        let doc = mk_doc(@\"struct Foo { field: () }\");\n-        assert!(doc.cratemod().structs()[0].name_() == ~\"Foo\");\n-    }\n-\n-    #[test]\n-    fn should_extract_struct_fields() {\n-        let doc = mk_doc(@\"struct Foo { field: () }\");\n-        assert!(doc.cratemod().structs()[0].fields[0] == ~\"field\");\n-    }\n-}"}, {"sha": "ae74f4e37c3c351744386a7ecdc3dd536f98f1f2", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 88, "deletions": 393, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,397 +8,92 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-use doc;\n-#[cfg(test)] use extract;\n-#[cfg(test)] use parse;\n-\n-pub struct Fold<T> {\n-    ctxt: T,\n-    fold_doc: FoldDoc<T>,\n-    fold_crate: FoldCrate<T>,\n-    fold_item: FoldItem<T>,\n-    fold_mod: FoldMod<T>,\n-    fold_nmod: FoldNmod<T>,\n-    fold_fn: FoldFn<T>,\n-    fold_static: FoldStatic<T>,\n-    fold_enum: FoldEnum<T>,\n-    fold_trait: FoldTrait<T>,\n-    fold_impl: FoldImpl<T>,\n-    fold_type: FoldType<T>,\n-    fold_struct: FoldStruct<T>\n-}\n-\n-impl<T:Clone> Clone for Fold<T> {\n-    fn clone(&self) -> Fold<T> {\n-        Fold {\n-            ctxt: self.ctxt.clone(),\n-            fold_doc: self.fold_doc,\n-            fold_crate: self.fold_crate,\n-            fold_item: self.fold_item,\n-            fold_mod: self.fold_mod,\n-            fold_nmod: self.fold_nmod,\n-            fold_fn: self.fold_fn,\n-            fold_static: self.fold_static,\n-            fold_enum: self.fold_enum,\n-            fold_trait: self.fold_trait,\n-            fold_impl: self.fold_impl,\n-            fold_type: self.fold_type,\n-            fold_struct: self.fold_struct\n-        }\n-    }\n-}\n-\n-type FoldDoc<T> = @fn(fold: &Fold<T>, doc: doc::Doc) -> doc::Doc;\n-type FoldCrate<T> = @fn(fold: &Fold<T>, doc: doc::CrateDoc) -> doc::CrateDoc;\n-type FoldItem<T> = @fn(fold: &Fold<T>, doc: doc::ItemDoc) -> doc::ItemDoc;\n-type FoldMod<T> = @fn(fold: &Fold<T>, doc: doc::ModDoc) -> doc::ModDoc;\n-type FoldNmod<T> = @fn(fold: &Fold<T>, doc: doc::NmodDoc) -> doc::NmodDoc;\n-type FoldFn<T> = @fn(fold: &Fold<T>, doc: doc::FnDoc) -> doc::FnDoc;\n-type FoldStatic<T> = @fn(fold: &Fold<T>, doc: doc::StaticDoc) -> doc::StaticDoc;\n-type FoldEnum<T> = @fn(fold: &Fold<T>, doc: doc::EnumDoc) -> doc::EnumDoc;\n-type FoldTrait<T> = @fn(fold: &Fold<T>, doc: doc::TraitDoc) -> doc::TraitDoc;\n-type FoldImpl<T> = @fn(fold: &Fold<T>, doc: doc::ImplDoc) -> doc::ImplDoc;\n-type FoldType<T> = @fn(fold: &Fold<T>, doc: doc::TyDoc) -> doc::TyDoc;\n-type FoldStruct<T> = @fn(fold: &Fold<T>,\n-                         doc: doc::StructDoc) -> doc::StructDoc;\n-\n-// This exists because fn types don't infer correctly as record\n-// initializers, but they do as function arguments\n-fn mk_fold<T>(\n-    ctxt: T,\n-    fold_doc: FoldDoc<T>,\n-    fold_crate: FoldCrate<T>,\n-    fold_item: FoldItem<T>,\n-    fold_mod: FoldMod<T>,\n-    fold_nmod: FoldNmod<T>,\n-    fold_fn: FoldFn<T>,\n-    fold_static: FoldStatic<T>,\n-    fold_enum: FoldEnum<T>,\n-    fold_trait: FoldTrait<T>,\n-    fold_impl: FoldImpl<T>,\n-    fold_type: FoldType<T>,\n-    fold_struct: FoldStruct<T>\n-) -> Fold<T> {\n-    Fold {\n-        ctxt: ctxt,\n-        fold_doc: fold_doc,\n-        fold_crate: fold_crate,\n-        fold_item: fold_item,\n-        fold_mod: fold_mod,\n-        fold_nmod: fold_nmod,\n-        fold_fn: fold_fn,\n-        fold_static: fold_static,\n-        fold_enum: fold_enum,\n-        fold_trait: fold_trait,\n-        fold_impl: fold_impl,\n-        fold_type: fold_type,\n-        fold_struct: fold_struct\n-    }\n-}\n-\n-pub fn default_any_fold<T:Clone>(ctxt: T) -> Fold<T> {\n-    mk_fold(\n-        ctxt,\n-        |f, d| default_seq_fold_doc(f, d),\n-        |f, d| default_seq_fold_crate(f, d),\n-        |f, d| default_seq_fold_item(f, d),\n-        |f, d| default_any_fold_mod(f, d),\n-        |f, d| default_any_fold_nmod(f, d),\n-        |f, d| default_seq_fold_fn(f, d),\n-        |f, d| default_seq_fold_static(f, d),\n-        |f, d| default_seq_fold_enum(f, d),\n-        |f, d| default_seq_fold_trait(f, d),\n-        |f, d| default_seq_fold_impl(f, d),\n-        |f, d| default_seq_fold_type(f, d),\n-        |f, d| default_seq_fold_struct(f, d)\n-    )\n-}\n-\n-pub fn default_seq_fold<T:Clone>(ctxt: T) -> Fold<T> {\n-    mk_fold(\n-        ctxt,\n-        |f, d| default_seq_fold_doc(f, d),\n-        |f, d| default_seq_fold_crate(f, d),\n-        |f, d| default_seq_fold_item(f, d),\n-        |f, d| default_seq_fold_mod(f, d),\n-        |f, d| default_seq_fold_nmod(f, d),\n-        |f, d| default_seq_fold_fn(f, d),\n-        |f, d| default_seq_fold_static(f, d),\n-        |f, d| default_seq_fold_enum(f, d),\n-        |f, d| default_seq_fold_trait(f, d),\n-        |f, d| default_seq_fold_impl(f, d),\n-        |f, d| default_seq_fold_type(f, d),\n-        |f, d| default_seq_fold_struct(f, d)\n-    )\n-}\n-\n-pub fn default_par_fold<T:Clone>(ctxt: T) -> Fold<T> {\n-    mk_fold(\n-        ctxt,\n-        |f, d| default_seq_fold_doc(f, d),\n-        |f, d| default_seq_fold_crate(f, d),\n-        |f, d| default_seq_fold_item(f, d),\n-        |f, d| default_par_fold_mod(f, d),\n-        |f, d| default_par_fold_nmod(f, d),\n-        |f, d| default_seq_fold_fn(f, d),\n-        |f, d| default_seq_fold_static(f, d),\n-        |f, d| default_seq_fold_enum(f, d),\n-        |f, d| default_seq_fold_trait(f, d),\n-        |f, d| default_seq_fold_impl(f, d),\n-        |f, d| default_seq_fold_type(f, d),\n-        |f, d| default_seq_fold_struct(f, d)\n-    )\n-}\n-\n-pub fn default_seq_fold_doc<T>(fold: &Fold<T>, doc: doc::Doc) -> doc::Doc {\n-    doc::Doc {\n-        pages: do doc.pages.iter().map |page| {\n-            match (*page).clone() {\n-              doc::CratePage(doc) => {\n-                doc::CratePage((fold.fold_crate)(fold, doc))\n-              }\n-              doc::ItemPage(doc) => {\n-                doc::ItemPage(fold_ItemTag(fold, doc))\n-              }\n-            }\n-        }.collect(),\n-        .. doc\n-    }\n-}\n-\n-pub fn default_seq_fold_crate<T>(\n-    fold: &Fold<T>,\n-    doc: doc::CrateDoc\n-) -> doc::CrateDoc {\n-    doc::CrateDoc {\n-        topmod: (fold.fold_mod)(fold, doc.topmod.clone())\n-    }\n-}\n-\n-pub fn default_seq_fold_item<T>(\n-    _fold: &Fold<T>,\n-    doc: doc::ItemDoc\n-) -> doc::ItemDoc {\n-    doc\n-}\n-\n-pub fn default_any_fold_mod<T:Clone>(\n-    fold: &Fold<T>,\n-    doc: doc::ModDoc\n-) -> doc::ModDoc {\n-    doc::ModDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        items: doc.items.iter().map(|ItemTag| {\n-            fold_ItemTag(fold, (*ItemTag).clone())\n-        }).collect(),\n-        .. doc\n-    }\n-}\n-\n-pub fn default_seq_fold_mod<T>(\n-    fold: &Fold<T>,\n-    doc: doc::ModDoc\n-) -> doc::ModDoc {\n-    doc::ModDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        items: doc.items.iter().map(|ItemTag| {\n-            fold_ItemTag(fold, (*ItemTag).clone())\n-        }).collect(),\n-        .. doc\n-    }\n-}\n-\n-pub fn default_par_fold_mod<T:Clone>(\n-    fold: &Fold<T>,\n-    doc: doc::ModDoc\n-) -> doc::ModDoc {\n-    doc::ModDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        items: doc.items.iter().map(|ItemTag| {\n-            fold_ItemTag(fold, (*ItemTag).clone())\n-        }).collect(),\n-        .. doc\n-    }\n-}\n-\n-pub fn default_any_fold_nmod<T:Clone>(\n-    fold: &Fold<T>,\n-    doc: doc::NmodDoc\n-) -> doc::NmodDoc {\n-    doc::NmodDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        fns: doc.fns.iter().map(|FnDoc| {\n-            (fold.fold_fn)(fold, (*FnDoc).clone())\n-        }).collect(),\n-        .. doc\n-    }\n-}\n-\n-pub fn default_seq_fold_nmod<T>(\n-    fold: &Fold<T>,\n-    doc: doc::NmodDoc\n-) -> doc::NmodDoc {\n-    doc::NmodDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        fns: doc.fns.iter().map(|FnDoc| {\n-            (fold.fold_fn)(fold, (*FnDoc).clone())\n-        }).collect(),\n-        .. doc\n-    }\n-}\n-\n-pub fn default_par_fold_nmod<T:Clone>(\n-    fold: &Fold<T>,\n-    doc: doc::NmodDoc\n-) -> doc::NmodDoc {\n-    doc::NmodDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        fns: doc.fns.iter().map(|FnDoc| {\n-            (fold.fold_fn)(fold, (*FnDoc).clone())\n-        }).collect(),\n-        .. doc\n-    }\n-}\n-\n-pub fn fold_ItemTag<T>(fold: &Fold<T>, doc: doc::ItemTag) -> doc::ItemTag {\n-    match doc {\n-      doc::ModTag(ModDoc) => {\n-        doc::ModTag((fold.fold_mod)(fold, ModDoc))\n-      }\n-      doc::NmodTag(nModDoc) => {\n-        doc::NmodTag((fold.fold_nmod)(fold, nModDoc))\n-      }\n-      doc::FnTag(FnDoc) => {\n-        doc::FnTag((fold.fold_fn)(fold, FnDoc))\n-      }\n-      doc::StaticTag(StaticDoc) => {\n-        doc::StaticTag((fold.fold_static)(fold, StaticDoc))\n-      }\n-      doc::EnumTag(EnumDoc) => {\n-        doc::EnumTag((fold.fold_enum)(fold, EnumDoc))\n-      }\n-      doc::TraitTag(TraitDoc) => {\n-        doc::TraitTag((fold.fold_trait)(fold, TraitDoc))\n-      }\n-      doc::ImplTag(ImplDoc) => {\n-        doc::ImplTag((fold.fold_impl)(fold, ImplDoc))\n-      }\n-      doc::TyTag(TyDoc) => {\n-        doc::TyTag((fold.fold_type)(fold, TyDoc))\n-      }\n-      doc::StructTag(StructDoc) => {\n-        doc::StructTag((fold.fold_struct)(fold, StructDoc))\n-      }\n-    }\n-}\n-\n-pub fn default_seq_fold_fn<T>(\n-    fold: &Fold<T>,\n-    doc: doc::FnDoc\n-) -> doc::FnDoc {\n-    doc::SimpleItemDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        .. doc\n-    }\n-}\n-\n-pub fn default_seq_fold_static<T>(\n-    fold: &Fold<T>,\n-    doc: doc::StaticDoc\n-) -> doc::StaticDoc {\n-    doc::SimpleItemDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        .. doc\n-    }\n-}\n-\n-pub fn default_seq_fold_enum<T>(\n-    fold: &Fold<T>,\n-    doc: doc::EnumDoc\n-) -> doc::EnumDoc {\n-    doc::EnumDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        .. doc\n-    }\n-}\n-\n-pub fn default_seq_fold_trait<T>(\n-    fold: &Fold<T>,\n-    doc: doc::TraitDoc\n-) -> doc::TraitDoc {\n-    doc::TraitDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        .. doc\n-    }\n-}\n-\n-pub fn default_seq_fold_impl<T>(\n-    fold: &Fold<T>,\n-    doc: doc::ImplDoc\n-) -> doc::ImplDoc {\n-    doc::ImplDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        .. doc\n-    }\n-}\n-\n-pub fn default_seq_fold_type<T>(\n-    fold: &Fold<T>,\n-    doc: doc::TyDoc\n-) -> doc::TyDoc {\n-    doc::SimpleItemDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        .. doc\n-    }\n-}\n-\n-pub fn default_seq_fold_struct<T>(\n-    fold: &Fold<T>,\n-    doc: doc::StructDoc\n-) -> doc::StructDoc {\n-    doc::StructDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        .. doc\n+use std;\n+use clean::*;\n+use std::iter::Extendable;\n+\n+pub trait DocFolder {\n+    fn fold_item(&mut self, item: Item) -> Option<Item> {\n+        self.fold_item_recur(item)\n+    }\n+\n+    /// don't override!\n+    fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n+        use std::util::swap;\n+        let Item { attrs, name, source, visibility, id, inner } = item;\n+        let inner = inner;\n+        let c = |x| self.fold_item(x);\n+        let inner = match inner {\n+            StructItem(i) => {\n+                let mut i = i;\n+                let mut foo = ~[]; swap(&mut foo, &mut i.fields);\n+                i.fields.extend(&mut foo.move_iter().filter_map(|x| self.fold_item(x)));\n+                StructItem(i)\n+            },\n+            ModuleItem(i) => {\n+                ModuleItem(self.fold_mod(i))\n+            },\n+            EnumItem(i) => {\n+                let mut i = i;\n+                let mut foo = ~[]; swap(&mut foo, &mut i.variants);\n+                i.variants.extend(&mut foo.move_iter().filter_map(|x| self.fold_item(x)));\n+                EnumItem(i)\n+            },\n+            TraitItem(i) => {\n+                fn vtrm<T: DocFolder>(this: &mut T, trm: TraitMethod) -> Option<TraitMethod> {\n+                    match trm {\n+                        Required(it) => {\n+                            match this.fold_item(it) {\n+                                Some(x) => return Some(Required(x)),\n+                                None => return None,\n+                            }\n+                        },\n+                        Provided(it) => {\n+                            match this.fold_item(it) {\n+                                Some(x) => return Some(Provided(x)),\n+                                None => return None,\n+                            }\n+                        },\n+                    }\n+                }\n+                let mut i = i;\n+                let mut foo = ~[]; swap(&mut foo, &mut i.methods);\n+                i.methods.extend(&mut foo.move_iter().filter_map(|x| vtrm(self, x)));\n+                TraitItem(i)\n+            },\n+            ImplItem(i) => {\n+                let mut i = i;\n+                let mut foo = ~[]; swap(&mut foo, &mut i.methods);\n+                i.methods.extend(&mut foo.move_iter().filter_map(|x| self.fold_item(x)));\n+                ImplItem(i)\n+            },\n+            VariantItem(i) => {\n+                let i2 = i.clone(); // this clone is small\n+                match i.kind {\n+                    StructVariant(j) => {\n+                        let mut j = j;\n+                        let mut foo = ~[]; swap(&mut foo, &mut j.fields);\n+                        j.fields.extend(&mut foo.move_iter().filter_map(c));\n+                        VariantItem(Variant {kind: StructVariant(j), ..i2})\n+                    },\n+                    _ => VariantItem(i2)\n+                }\n+            },\n+            x => x\n+        };\n+\n+        Some(Item { attrs: attrs, name: name, source: source, inner: inner,\n+                    visibility: visibility, id: id })\n+    }\n+\n+    fn fold_mod(&mut self, m: Module) -> Module {\n+        Module { items: m.items.move_iter().filter_map(|i| self.fold_item(i)).collect() }\n+    }\n+\n+    fn fold_crate(&mut self, mut c: Crate) -> Crate {\n+        c.module = match std::util::replace(&mut c.module, None) {\n+            Some(module) => self.fold_item(module), None => None\n+        };\n+        return c;\n     }\n }\n-\n-#[test]\n-fn default_fold_should_produce_same_doc() {\n-    let source = @\"mod a { fn b() { } mod c { fn d() { } } }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract::extract(ast, ~\"\");\n-    let fld = default_seq_fold(());\n-    let folded = (fld.fold_doc)(&fld, doc.clone());\n-    assert_eq!(doc, folded);\n-}\n-\n-#[test]\n-fn default_fold_should_produce_same_statics() {\n-    let source = @\"static a: int = 0;\";\n-    let ast = parse::from_str(source);\n-    let doc = extract::extract(ast, ~\"\");\n-    let fld = default_seq_fold(());\n-    let folded = (fld.fold_doc)(&fld, doc.clone());\n-    assert_eq!(doc, folded);\n-}\n-\n-#[test]\n-fn default_fold_should_produce_same_enums() {\n-    let source = @\"enum a { b }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract::extract(ast, ~\"\");\n-    let fld = default_seq_fold(());\n-    let folded = (fld.fold_doc)(&fld, doc.clone());\n-    assert_eq!(doc, folded);\n-}\n-\n-#[test]\n-fn default_parallel_fold_should_produce_same_doc() {\n-    let source = @\"mod a { fn b() { } mod c { fn d() { } } }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract::extract(ast, ~\"\");\n-    let fld = default_par_fold(());\n-    let folded = (fld.fold_doc)(&fld, doc.clone());\n-    assert_eq!(doc, folded);\n-}"}, {"sha": "4d0f6928d50e3534bf546867aea2c2f74659a37b", "filename": "src/librustdoc/html/format.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/html/format.rs"}, {"sha": "fcf13779389d002c127a3c57012d90c5c890aa14", "filename": "src/librustdoc/html/layout.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/html/layout.rs"}, {"sha": "14e2327550b324d568984c17637aa824d138e129", "filename": "src/librustdoc/html/markdown.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/html/markdown.rs"}, {"sha": "b004061e04a82110604c802fa8874594b1870405", "filename": "src/librustdoc/html/render.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/html/render.rs"}, {"sha": "2be209dd2233ed75612f4afcb6cf8816926a1738", "filename": "src/librustdoc/html/static/jquery-2.0.3.min.js", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjquery-2.0.3.min.js", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjquery-2.0.3.min.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjquery-2.0.3.min.js?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/html/static/jquery-2.0.3.min.js"}, {"sha": "2b9651681295682a83276a5a4aee1246118ad017", "filename": "src/librustdoc/html/static/main.css", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/html/static/main.css"}, {"sha": "b5ae3dadd77b626189b128fad99622ceab4c0a36", "filename": "src/librustdoc/html/static/main.js", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/html/static/main.js"}, {"sha": "6adf56e7985db2c74a60ecd1b3896eabb7fa048a", "filename": "src/librustdoc/html/static/normalize.css", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fnormalize.css", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fnormalize.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fnormalize.css?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/html/static/normalize.css"}, {"sha": "90634770a501eaa0b8869a48ff3aa10bcab69be3", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "removed", "additions": 0, "deletions": 284, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,284 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Build indexes as appropriate for the markdown pass\n-\n-\n-use astsrv;\n-use config;\n-use doc::ItemUtils;\n-use doc;\n-use fold::Fold;\n-use fold;\n-use markdown_pass;\n-use markdown_writer;\n-use pass::Pass;\n-\n-pub fn mk_pass(config: config::Config) -> Pass {\n-    Pass {\n-        name: ~\"markdown_index\",\n-        f: |srv, doc| run(srv, doc, config.clone())\n-    }\n-}\n-\n-pub fn run(\n-    _srv: astsrv::Srv,\n-    doc: doc::Doc,\n-    config: config::Config\n-) -> doc::Doc {\n-    let fold = Fold {\n-        fold_mod: fold_mod,\n-        fold_nmod: fold_nmod,\n-        .. fold::default_any_fold(config)\n-    };\n-    (fold.fold_doc)(&fold, doc)\n-}\n-\n-fn fold_mod(\n-    fold: &fold::Fold<config::Config>,\n-    doc: doc::ModDoc\n-) -> doc::ModDoc {\n-\n-    let doc = fold::default_any_fold_mod(fold, doc);\n-\n-    doc::ModDoc {\n-        index: Some(build_mod_index(doc.clone(), fold.ctxt.clone())),\n-        .. doc\n-    }\n-}\n-\n-fn fold_nmod(\n-    fold: &fold::Fold<config::Config>,\n-    doc: doc::NmodDoc\n-) -> doc::NmodDoc {\n-\n-    let doc = fold::default_any_fold_nmod(fold, doc);\n-\n-    doc::NmodDoc {\n-        index: Some(build_nmod_index(doc.clone(), fold.ctxt.clone())),\n-        .. doc\n-    }\n-}\n-\n-fn build_mod_index(\n-    doc: doc::ModDoc,\n-    config: config::Config\n-) -> doc::Index {\n-    doc::Index {\n-        entries: doc.items.map(|doc| {\n-            item_to_entry((*doc).clone(), &config)\n-        })\n-    }\n-}\n-\n-fn build_nmod_index(\n-    doc: doc::NmodDoc,\n-    config: config::Config\n-) -> doc::Index {\n-    doc::Index {\n-        entries: doc.fns.map(|doc| {\n-            item_to_entry(doc::FnTag((*doc).clone()), &config)\n-        })\n-    }\n-}\n-\n-fn item_to_entry(\n-    doc: doc::ItemTag,\n-    config: &config::Config\n-) -> doc::IndexEntry {\n-    let link = match doc {\n-      doc::ModTag(_) | doc::NmodTag(_)\n-      if config.output_style == config::DocPerMod => {\n-        markdown_writer::make_filename(config,\n-                                       doc::ItemPage(doc.clone())).to_str()\n-      }\n-      _ => {\n-        ~\"#\" + pandoc_header_id(markdown_pass::header_text(doc.clone()))\n-      }\n-    };\n-\n-    doc::IndexEntry {\n-        kind: markdown_pass::header_kind(doc.clone()),\n-        name: markdown_pass::header_name(doc.clone()),\n-        brief: doc.brief(),\n-        link: link\n-    }\n-}\n-\n-pub fn pandoc_header_id(header: &str) -> ~str {\n-\n-    // http://johnmacfarlane.net/pandoc/README.html#headers\n-\n-    let header = remove_formatting(header);\n-    let header = remove_punctuation(header);\n-    let header = replace_with_hyphens(header);\n-    let header = convert_to_lowercase(header);\n-    let header = remove_up_to_first_letter(header);\n-    let header = maybe_use_section_id(header);\n-    return header;\n-\n-    fn remove_formatting(s: &str) -> ~str {\n-        s.replace(\"`\", \"\")\n-    }\n-    fn remove_punctuation(s: &str) -> ~str {\n-        let s = s.replace(\"<\", \"\");\n-        let s = s.replace(\">\", \"\");\n-        let s = s.replace(\"[\", \"\");\n-        let s = s.replace(\"]\", \"\");\n-        let s = s.replace(\"(\", \"\");\n-        let s = s.replace(\")\", \"\");\n-        let s = s.replace(\"@~\", \"\");\n-        let s = s.replace(\"~\", \"\");\n-        let s = s.replace(\"/\", \"\");\n-        let s = s.replace(\":\", \"\");\n-        let s = s.replace(\"&\", \"\");\n-        let s = s.replace(\"^\", \"\");\n-        let s = s.replace(\",\", \"\");\n-        let s = s.replace(\"'\", \"\");\n-        let s = s.replace(\"+\", \"\");\n-        return s;\n-    }\n-    fn replace_with_hyphens(s: &str) -> ~str {\n-        // Collapse sequences of whitespace to a single dash\n-        // XXX: Hacky implementation here that only covers\n-        // one or two spaces.\n-        let s = s.trim();\n-        let s = s.replace(\"  \", \"-\");\n-        let s = s.replace(\" \", \"-\");\n-        return s;\n-    }\n-    // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-    // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n-    fn convert_to_lowercase(s: &str) -> ~str { s.to_ascii().to_lower().to_str_ascii() }\n-    fn remove_up_to_first_letter(s: &str) -> ~str { s.to_str() }\n-    fn maybe_use_section_id(s: &str) -> ~str { s.to_str() }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use astsrv;\n-    use attr_pass;\n-    use config;\n-    use desc_to_brief_pass;\n-    use doc;\n-    use extract;\n-    use markdown_index_pass::run;\n-    use path_pass;\n-    use prune_hidden_pass;\n-    use super::pandoc_header_id;\n-\n-    fn mk_doc(output_style: config::OutputStyle, source: ~str)\n-               -> doc::Doc {\n-        do astsrv::from_str(source) |srv| {\n-            let config = config::Config {\n-                output_style: output_style,\n-                .. config::default_config(&Path(\"whatever\"))\n-            };\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n-            let doc = (prune_hidden_pass::mk_pass().f)(srv.clone(), doc);\n-            let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);\n-            let doc = (path_pass::mk_pass().f)(srv.clone(), doc);\n-\n-            run(srv.clone(), doc, config)\n-        }\n-    }\n-\n-    #[test]\n-    fn should_remove_punctuation_from_headers() {\n-        assert!(pandoc_header_id(\"impl foo of bar<A>\") ==\n-                ~\"impl-foo-of-bara\");\n-        assert!(pandoc_header_id(\"impl of num::num for int\")\n-                == ~\"impl-of-numnum-for-int\");\n-        assert!(pandoc_header_id(\"impl of num::num for int/&\")\n-                == ~\"impl-of-numnum-for-int\");\n-        assert!(pandoc_header_id(\"impl of num::num for ^int\")\n-                == ~\"impl-of-numnum-for-int\");\n-        assert!(pandoc_header_id(\"impl for & condvar\")\n-                == ~\"impl-for-condvar\");\n-        assert!(pandoc_header_id(\"impl of Select<T, U> for (Left, Right)\")\n-                == ~\"impl-of-selectt-u-for-left-right\");\n-        assert!(pandoc_header_id(\"impl of Condition<'self, T, U>\")\n-                == ~\"impl-of-conditionself-t-u\");\n-        assert!(pandoc_header_id(\"impl of Condition<T: Clone>\")\n-                == ~\"impl-of-conditiont-clone\");\n-    }\n-\n-    #[test]\n-    fn should_trim_whitespace_after_removing_punctuation() {\n-        assert_eq!(pandoc_header_id(\"impl foo for ()\"), ~\"impl-foo-for\");\n-    }\n-\n-    #[test]\n-    fn should_index_mod_contents() {\n-        let doc = mk_doc(\n-            config::DocPerCrate,\n-            ~\"mod a { } fn b() { }\"\n-        );\n-        assert!(doc.cratemod().index.unwrap().entries[0] == doc::IndexEntry {\n-            kind: ~\"Module\",\n-            name: ~\"a\",\n-            brief: None,\n-            link: ~\"#module-a\"\n-        });\n-        assert!(doc.cratemod().index.unwrap().entries[1] == doc::IndexEntry {\n-            kind: ~\"Function\",\n-            name: ~\"b\",\n-            brief: None,\n-            link: ~\"#function-b\"\n-        });\n-    }\n-\n-    #[test]\n-    fn should_index_mod_contents_multi_page() {\n-        let doc = mk_doc(\n-            config::DocPerMod,\n-            ~\"mod a { } fn b() { }\"\n-        );\n-        assert_eq!(doc.cratemod().index.unwrap().entries[0], doc::IndexEntry {\n-            kind: ~\"Module\",\n-            name: ~\"a\",\n-            brief: None,\n-            link: ~\"a.html\"\n-        });\n-        assert_eq!(doc.cratemod().index.unwrap().entries[1], doc::IndexEntry {\n-            kind: ~\"Function\",\n-            name: ~\"b\",\n-            brief: None,\n-            link: ~\"#function-b\"\n-        });\n-    }\n-\n-    #[test]\n-    fn should_add_brief_desc_to_index() {\n-        let doc = mk_doc(\n-            config::DocPerMod,\n-            ~\"#[doc = \\\"test\\\"] mod a { }\"\n-        );\n-        assert_eq!(doc.cratemod().index.unwrap().entries[0].brief, Some(~\"test\"));\n-    }\n-\n-    #[test]\n-    fn should_index_foreign_mod_contents() {\n-        let doc = mk_doc(\n-            config::DocPerCrate,\n-            ~\"extern { fn b(); }\"\n-        );\n-        // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().nmods()[0].index.unwrap().entries[0],\n-                   doc::IndexEntry {\n-                       kind: ~\"Function\",\n-                       name: ~\"b\",\n-                       brief: None,\n-                       link: ~\"#function-b\"\n-                   });\n-    }\n-}"}, {"sha": "7d07b4864f50e1b57e6a50e11ef4a51bd0bd238d", "filename": "src/librustdoc/markdown_pass.rs", "status": "removed", "additions": 0, "deletions": 941, "changes": 941, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,941 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Generate markdown from a document tree\n-\n-\n-use astsrv;\n-use doc::ItemUtils;\n-use doc;\n-use markdown_pass;\n-use markdown_writer::Writer;\n-use markdown_writer::WriterUtils;\n-use markdown_writer::WriterFactory;\n-use pass::Pass;\n-use sort_pass;\n-\n-use std::cell::Cell;\n-use std::str;\n-use std::vec;\n-use syntax;\n-\n-pub fn mk_pass(writer_factory: WriterFactory) -> Pass {\n-    let writer_factory = Cell::new(writer_factory);\n-    Pass {\n-        name: ~\"markdown\",\n-        f: |srv, doc| run(srv, doc, writer_factory.take())\n-    }\n-}\n-\n-fn run(\n-    srv: astsrv::Srv,\n-    doc: doc::Doc,\n-    writer_factory: WriterFactory\n-) -> doc::Doc {\n-\n-    fn mods_last(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n-        fn is_mod(item: &doc::ItemTag) -> bool {\n-            match *item {\n-                doc::ModTag(_) => true,\n-                _ => false\n-            }\n-        }\n-\n-        let lteq = !is_mod(item1) || is_mod(item2);\n-        lteq\n-    }\n-\n-    // Sort the items so mods come last. All mods will be\n-    // output at the same header level so sorting mods last\n-    // makes the headers come out nested correctly.\n-    let sorted_doc = (sort_pass::mk_pass(\n-        ~\"mods last\", mods_last\n-    ).f)(srv, doc.clone());\n-\n-    write_markdown(sorted_doc, writer_factory);\n-\n-    return doc;\n-}\n-\n-struct Ctxt {\n-    w: Writer\n-}\n-\n-pub fn write_markdown(\n-    doc: doc::Doc,\n-    writer_factory: WriterFactory\n-) {\n-    // There is easy parallelism to be had here, but\n-    // we don't want to spawn too many pandoc processes.\n-    // (See #2484, which is closed.)\n-    do doc.pages.map |page| {\n-        let ctxt = Ctxt {\n-            w: writer_factory((*page).clone())\n-        };\n-        write_page(&ctxt, page)\n-    };\n-}\n-\n-fn write_page(ctxt: &Ctxt, page: &doc::Page) {\n-    write_title(ctxt, (*page).clone());\n-    match (*page).clone() {\n-        doc::CratePage(doc) => {\n-            write_crate(ctxt, doc);\n-        }\n-        doc::ItemPage(doc) => {\n-            // We don't write a header for item's pages because their\n-            // header in the html output is created by the page title\n-            write_item_no_header(ctxt, doc);\n-        }\n-    }\n-    ctxt.w.put_done();\n-}\n-\n-fn write_title(ctxt: &Ctxt, page: doc::Page) {\n-    ctxt.w.put_line(fmt!(\"%% %s\", make_title(page)));\n-    ctxt.w.put_line(~\"\");\n-}\n-\n-fn make_title(page: doc::Page) -> ~str {\n-    let item = match page {\n-        doc::CratePage(CrateDoc) => {\n-            doc::ModTag(CrateDoc.topmod.clone())\n-        }\n-        doc::ItemPage(ItemTag) => {\n-            ItemTag\n-        }\n-    };\n-    let title = markdown_pass::header_text(item);\n-    let title = title.replace(\"`\", \"\");\n-    return title;\n-}\n-\n-enum Hlvl {\n-    H1 = 1,\n-    H2 = 2,\n-    H3 = 3,\n-    H4 = 4\n-}\n-\n-fn write_header(ctxt: &Ctxt, lvl: Hlvl, doc: doc::ItemTag) {\n-    let text = header_text(doc);\n-    write_header_(ctxt, lvl, text);\n-}\n-\n-fn write_header_(ctxt: &Ctxt, lvl: Hlvl, title: ~str) {\n-    let hashes = str::from_chars(vec::from_elem(lvl as uint, '#'));\n-    ctxt.w.put_line(fmt!(\"%s %s\", hashes, title));\n-    ctxt.w.put_line(~\"\");\n-}\n-\n-pub fn header_kind(doc: doc::ItemTag) -> ~str {\n-    match doc {\n-        doc::ModTag(_) => {\n-            if doc.id() == syntax::ast::CRATE_NODE_ID {\n-                ~\"Crate\"\n-            } else {\n-                ~\"Module\"\n-            }\n-        }\n-        doc::NmodTag(_) => {\n-            ~\"Foreign module\"\n-        }\n-        doc::FnTag(_) => {\n-            ~\"Function\"\n-        }\n-        doc::StaticTag(_) => {\n-            ~\"Static\"\n-        }\n-        doc::EnumTag(_) => {\n-            ~\"Enum\"\n-        }\n-        doc::TraitTag(_) => {\n-            ~\"Trait\"\n-        }\n-        doc::ImplTag(_) => {\n-            ~\"Implementation\"\n-        }\n-        doc::TyTag(_) => {\n-            ~\"Type\"\n-        }\n-        doc::StructTag(_) => {\n-            ~\"Struct\"\n-        }\n-    }\n-}\n-\n-pub fn header_name(doc: doc::ItemTag) -> ~str {\n-    let fullpath = (doc.path() + &[doc.name_()]).connect(\"::\");\n-    match &doc {\n-        &doc::ModTag(_) if doc.id() != syntax::ast::CRATE_NODE_ID => {\n-            fullpath\n-        }\n-        &doc::NmodTag(_) => {\n-            fullpath\n-        }\n-        &doc::ImplTag(ref doc) => {\n-            assert!(doc.self_ty.is_some());\n-            let bounds = if doc.bounds_str.is_some() {\n-                fmt!(\" where %s\", *doc.bounds_str.get_ref())\n-            } else {\n-                ~\"\"\n-            };\n-            let self_ty = doc.self_ty.get_ref();\n-            let mut trait_part = ~\"\";\n-            for (i, trait_type) in doc.trait_types.iter().enumerate() {\n-                if i == 0 {\n-                    trait_part.push_str(\" of \");\n-                } else {\n-                    trait_part.push_str(\", \");\n-                }\n-                trait_part.push_str(*trait_type);\n-            }\n-            fmt!(\"%s for %s%s\", trait_part, *self_ty, bounds)\n-        }\n-        _ => {\n-            doc.name_()\n-        }\n-    }\n-}\n-\n-pub fn header_text(doc: doc::ItemTag) -> ~str {\n-    match &doc {\n-        &doc::ImplTag(ref ImplDoc) => {\n-            let header_kind = header_kind(doc.clone());\n-            let bounds = if ImplDoc.bounds_str.is_some() {\n-                fmt!(\" where `%s`\", *ImplDoc.bounds_str.get_ref())\n-            } else {\n-                ~\"\"\n-            };\n-            let desc = if ImplDoc.trait_types.is_empty() {\n-                fmt!(\"for `%s`%s\", *ImplDoc.self_ty.get_ref(), bounds)\n-            } else {\n-                fmt!(\"of `%s` for `%s`%s\",\n-                     ImplDoc.trait_types[0],\n-                     *ImplDoc.self_ty.get_ref(),\n-                     bounds)\n-            };\n-            return fmt!(\"%s %s\", header_kind, desc);\n-        }\n-        _ => {}\n-    }\n-\n-    header_text_(header_kind(doc.clone()),\n-                 header_name(doc))\n-}\n-\n-fn header_text_(kind: &str, name: &str) -> ~str {\n-    fmt!(\"%s `%s`\", kind, name)\n-}\n-\n-fn write_crate(\n-    ctxt: &Ctxt,\n-    doc: doc::CrateDoc\n-) {\n-    write_top_module(ctxt, doc.topmod.clone());\n-}\n-\n-fn write_top_module(\n-    ctxt: &Ctxt,\n-    ModDoc: doc::ModDoc\n-) {\n-    write_mod_contents(ctxt, ModDoc);\n-}\n-\n-fn write_mod(\n-    ctxt: &Ctxt,\n-    ModDoc: doc::ModDoc\n-) {\n-    write_mod_contents(ctxt, ModDoc);\n-}\n-\n-fn write_common(\n-    ctxt: &Ctxt,\n-    desc: Option<~str>,\n-    sections: &[doc::Section]\n-) {\n-    write_desc(ctxt, desc);\n-    write_sections(ctxt, sections);\n-}\n-\n-fn write_desc(\n-    ctxt: &Ctxt,\n-    desc: Option<~str>\n-) {\n-    match desc {\n-        Some(desc) => {\n-            ctxt.w.put_line(desc);\n-            ctxt.w.put_line(~\"\");\n-        }\n-        None => ()\n-    }\n-}\n-\n-fn write_sections(ctxt: &Ctxt, sections: &[doc::Section]) {\n-    for section in sections.iter() {\n-        write_section(ctxt, (*section).clone());\n-    }\n-}\n-\n-fn write_section(ctxt: &Ctxt, section: doc::Section) {\n-    write_header_(ctxt, H4, section.header.clone());\n-    ctxt.w.put_line(section.body.clone());\n-    ctxt.w.put_line(~\"\");\n-}\n-\n-fn write_mod_contents(\n-    ctxt: &Ctxt,\n-    doc: doc::ModDoc\n-) {\n-    write_common(ctxt, doc.desc(), doc.sections());\n-    if doc.index.is_some() {\n-        write_index(ctxt, doc.index.get_ref());\n-    }\n-\n-    for itemTag in doc.items.iter() {\n-        write_item(ctxt, (*itemTag).clone());\n-    }\n-}\n-\n-fn write_item(ctxt: &Ctxt, doc: doc::ItemTag) {\n-    write_item_(ctxt, doc, true);\n-}\n-\n-fn write_item_no_header(ctxt: &Ctxt, doc: doc::ItemTag) {\n-    write_item_(ctxt, doc, false);\n-}\n-\n-fn write_item_(ctxt: &Ctxt, doc: doc::ItemTag, write_header: bool) {\n-    if write_header {\n-        write_item_header(ctxt, doc.clone());\n-    }\n-\n-    match doc {\n-        doc::ModTag(ModDoc) => write_mod(ctxt, ModDoc),\n-        doc::NmodTag(nModDoc) => write_nmod(ctxt, nModDoc),\n-        doc::FnTag(FnDoc) => write_fn(ctxt, FnDoc),\n-        doc::StaticTag(StaticDoc) => write_static(ctxt, StaticDoc),\n-        doc::EnumTag(EnumDoc) => write_enum(ctxt, EnumDoc),\n-        doc::TraitTag(TraitDoc) => write_trait(ctxt, TraitDoc),\n-        doc::ImplTag(ImplDoc) => write_impl(ctxt, ImplDoc),\n-        doc::TyTag(TyDoc) => write_type(ctxt, TyDoc),\n-        doc::StructTag(StructDoc) => put_struct(ctxt, StructDoc),\n-    }\n-}\n-\n-fn write_item_header(ctxt: &Ctxt, doc: doc::ItemTag) {\n-    write_header(ctxt, item_header_lvl(&doc), doc);\n-}\n-\n-fn item_header_lvl(doc: &doc::ItemTag) -> Hlvl {\n-    match doc {\n-        &doc::ModTag(_) | &doc::NmodTag(_) => H1,\n-        _ => H2\n-    }\n-}\n-\n-fn write_index(ctxt: &Ctxt, index: &doc::Index) {\n-    if index.entries.is_empty() {\n-        return;\n-    }\n-\n-    ctxt.w.put_line(~\"<div class='index'>\");\n-    ctxt.w.put_line(~\"\");\n-\n-    for entry in index.entries.iter() {\n-        let header = header_text_(entry.kind, entry.name);\n-        let id = entry.link.clone();\n-        if entry.brief.is_some() {\n-            ctxt.w.put_line(fmt!(\"* [%s](%s) - %s\",\n-                                 header, id, *entry.brief.get_ref()));\n-        } else {\n-            ctxt.w.put_line(fmt!(\"* [%s](%s)\", header, id));\n-        }\n-    }\n-    ctxt.w.put_line(~\"\");\n-    ctxt.w.put_line(~\"</div>\");\n-    ctxt.w.put_line(~\"\");\n-}\n-\n-fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n-    write_common(ctxt, doc.desc(), doc.sections());\n-    if doc.index.is_some() {\n-        write_index(ctxt, doc.index.get_ref());\n-    }\n-\n-    for FnDoc in doc.fns.iter() {\n-        write_item_header(ctxt, doc::FnTag((*FnDoc).clone()));\n-        write_fn(ctxt, (*FnDoc).clone());\n-    }\n-}\n-\n-fn write_fn(\n-    ctxt: &Ctxt,\n-    doc: doc::FnDoc\n-) {\n-    write_fnlike(ctxt, doc.sig.clone(), doc.desc(), doc.sections());\n-}\n-\n-fn write_fnlike(\n-    ctxt: &Ctxt,\n-    sig: Option<~str>,\n-    desc: Option<~str>,\n-    sections: &[doc::Section]\n-) {\n-    write_sig(ctxt, sig);\n-    write_common(ctxt, desc, sections);\n-}\n-\n-fn write_sig(ctxt: &Ctxt, sig: Option<~str>) {\n-    match sig {\n-        Some(sig) => {\n-            ctxt.w.put_line(code_block(sig));\n-            ctxt.w.put_line(~\"\");\n-        }\n-        None => fail!(\"unimplemented\")\n-    }\n-}\n-\n-fn code_block(s: ~str) -> ~str {\n-    fmt!(\"~~~ {.rust}\n-%s\n-~~~\", s)\n-}\n-\n-fn write_static(\n-    ctxt: &Ctxt,\n-    doc: doc::StaticDoc\n-) {\n-    write_sig(ctxt, doc.sig.clone());\n-    write_common(ctxt, doc.desc(), doc.sections());\n-}\n-\n-fn write_enum(\n-    ctxt: &Ctxt,\n-    doc: doc::EnumDoc\n-) {\n-    write_common(ctxt, doc.desc(), doc.sections());\n-    write_variants(ctxt, doc.variants);\n-}\n-\n-fn write_variants(\n-    ctxt: &Ctxt,\n-    docs: &[doc::VariantDoc]\n-) {\n-    if docs.is_empty() {\n-        return;\n-    }\n-\n-    write_header_(ctxt, H4, ~\"Variants\");\n-\n-    for variant in docs.iter() {\n-        write_variant(ctxt, (*variant).clone());\n-    }\n-\n-    ctxt.w.put_line(~\"\");\n-}\n-\n-fn write_variant(ctxt: &Ctxt, doc: doc::VariantDoc) {\n-    assert!(doc.sig.is_some());\n-    let sig = doc.sig.get_ref();\n-\n-    // space out list items so they all end up within paragraph elements\n-    ctxt.w.put_line(~\"\");\n-\n-    match doc.desc.clone() {\n-        Some(desc) => {\n-            ctxt.w.put_line(list_item_indent(fmt!(\"* `%s` - %s\", *sig, desc)));\n-        }\n-        None => {\n-            ctxt.w.put_line(fmt!(\"* `%s`\", *sig));\n-        }\n-    }\n-}\n-\n-fn list_item_indent(item: &str) -> ~str {\n-    let indented = item.any_line_iter().collect::<~[&str]>();\n-\n-    // separate markdown elements within `*` lists must be indented by four\n-    // spaces, or they will escape the list context. indenting everything\n-    // seems fine though.\n-    indented.connect(\"\\n    \")\n-}\n-\n-fn write_trait(ctxt: &Ctxt, doc: doc::TraitDoc) {\n-    write_common(ctxt, doc.desc(), doc.sections());\n-    write_methods(ctxt, doc.methods);\n-}\n-\n-fn write_methods(ctxt: &Ctxt, docs: &[doc::MethodDoc]) {\n-    for doc in docs.iter() {\n-        write_method(ctxt, (*doc).clone());\n-    }\n-}\n-\n-fn write_method(ctxt: &Ctxt, doc: doc::MethodDoc) {\n-    write_header_(ctxt, H3, header_text_(\"Method\", doc.name));\n-    write_fnlike(ctxt, doc.sig.clone(), doc.desc.clone(), doc.sections);\n-}\n-\n-fn write_impl(ctxt: &Ctxt, doc: doc::ImplDoc) {\n-    write_common(ctxt, doc.desc(), doc.sections());\n-    write_methods(ctxt, doc.methods);\n-}\n-\n-fn write_type(\n-    ctxt: &Ctxt,\n-    doc: doc::TyDoc\n-) {\n-    write_sig(ctxt, doc.sig.clone());\n-    write_common(ctxt, doc.desc(), doc.sections());\n-}\n-\n-fn put_struct(\n-    ctxt: &Ctxt,\n-    doc: doc::StructDoc\n-) {\n-    write_sig(ctxt, doc.sig.clone());\n-    write_common(ctxt, doc.desc(), doc.sections());\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use astsrv;\n-    use attr_pass;\n-    use config;\n-    use desc_to_brief_pass;\n-    use doc;\n-    use extract;\n-    use markdown_index_pass;\n-    use markdown_pass::{mk_pass, write_markdown};\n-    use markdown_writer;\n-    use path_pass;\n-    use page_pass;\n-    use prune_hidden_pass;\n-    use sectionalize_pass;\n-    use trim_pass;\n-    use tystr_pass;\n-    use unindent_pass;\n-\n-    fn render(source: ~str) -> ~str {\n-        let (srv, doc) = create_doc_srv(source);\n-        let markdown = write_markdown_str_srv(srv, doc);\n-        debug!(\"markdown: %s\", markdown);\n-        markdown\n-    }\n-\n-    fn create_doc_srv(source: ~str) -> (astsrv::Srv, doc::Doc) {\n-        do astsrv::from_str(source) |srv| {\n-\n-            let config = config::Config {\n-                output_style: config::DocPerCrate,\n-                .. config::default_config(&Path(\"whatever\"))\n-            };\n-\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            debug!(\"doc (extract): %?\", doc);\n-            let doc = (tystr_pass::mk_pass().f)(srv.clone(), doc);\n-            debug!(\"doc (tystr): %?\", doc);\n-            let doc = (path_pass::mk_pass().f)(srv.clone(), doc);\n-            debug!(\"doc (path): %?\", doc);\n-            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n-            debug!(\"doc (attr): %?\", doc);\n-            let doc = (prune_hidden_pass::mk_pass().f)(srv.clone(), doc);\n-            debug!(\"doc (prune_hidden): %?\", doc);\n-            let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);\n-            debug!(\"doc (desc_to_brief): %?\", doc);\n-            let doc = (unindent_pass::mk_pass().f)(srv.clone(), doc);\n-            debug!(\"doc (unindent): %?\", doc);\n-            let doc = (sectionalize_pass::mk_pass().f)(srv.clone(), doc);\n-            debug!(\"doc (trim): %?\", doc);\n-            let doc = (trim_pass::mk_pass().f)(srv.clone(), doc);\n-            debug!(\"doc (sectionalize): %?\", doc);\n-            let doc = (markdown_index_pass::mk_pass(config).f)(\n-                srv.clone(), doc);\n-            debug!(\"doc (index): %?\", doc);\n-            (srv.clone(), doc)\n-        }\n-    }\n-\n-    fn create_doc(source: ~str) -> doc::Doc {\n-        let (_, doc) = create_doc_srv(source);\n-        doc\n-    }\n-\n-    fn write_markdown_str(\n-        doc: doc::Doc\n-    ) -> ~str {\n-        let (writer_factory, po) = markdown_writer::future_writer_factory();\n-        write_markdown(doc, writer_factory);\n-        return po.recv().second();\n-    }\n-\n-    fn write_markdown_str_srv(\n-        srv: astsrv::Srv,\n-        doc: doc::Doc\n-    ) -> ~str {\n-        let (writer_factory, po) = markdown_writer::future_writer_factory();\n-        let pass = mk_pass(writer_factory);\n-        (pass.f)(srv, doc);\n-        return po.recv().second();\n-    }\n-\n-    #[test]\n-    fn write_markdown_should_write_mod_headers() {\n-        let markdown = render(~\"mod moo { }\");\n-        assert!(markdown.contains(\"# Module `moo`\"));\n-    }\n-\n-    #[test]\n-    fn should_leave_blank_line_after_header() {\n-        let markdown = render(~\"mod morp { }\");\n-        assert!(markdown.contains(\"Module `morp`\\n\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_write_modules_last() {\n-        /*\n-        Because the markdown pass writes all modules at the same level of\n-        indentation (it doesn't 'nest' them), we need to make sure that we\n-        write all of the modules contained in each module after all other\n-        types of items, or else the header nesting will end up wrong, with\n-        modules appearing to contain items that they do not.\n-        */\n-        let markdown = render(\n-            ~\"mod a { }\\\n-              fn b() { }\\\n-              mod c {\n-}\\\n-              fn d() { }\"\n-        );\n-\n-        let idx_a = markdown.find_str(\"# Module `a`\").unwrap();\n-        let idx_b = markdown.find_str(\"## Function `b`\").unwrap();\n-        let idx_c = markdown.find_str(\"# Module `c`\").unwrap();\n-        let idx_d = markdown.find_str(\"## Function `d`\").unwrap();\n-\n-        assert!(idx_b < idx_d);\n-        assert!(idx_d < idx_a);\n-        assert!(idx_a < idx_c);\n-    }\n-\n-    #[test]\n-    fn should_request_new_writer_for_each_page() {\n-        // This port will send us a (page, str) pair for every writer\n-        // that was created\n-        let (writer_factory, po) = markdown_writer::future_writer_factory();\n-        let (srv, doc) = create_doc_srv(~\"mod a { }\");\n-        // Split the document up into pages\n-        let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n-        write_markdown(doc, writer_factory);\n-        // We expect two pages to have been written\n-        for _ in range(0, 2u) {\n-            po.recv();\n-        }\n-    }\n-\n-    #[test]\n-    fn should_write_title_for_each_page() {\n-        let (writer_factory, po) = markdown_writer::future_writer_factory();\n-        let (srv, doc) = create_doc_srv(\n-            ~\"#[link(name = \\\"core\\\")]; mod a { }\");\n-        let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n-        write_markdown(doc, writer_factory);\n-        for _ in range(0, 2u) {\n-            let (page, markdown) = po.recv();\n-            match page {\n-                doc::CratePage(_) => {\n-                    assert!(markdown.contains(\"% Crate core\"));\n-                }\n-                doc::ItemPage(_) => {\n-                    assert!(markdown.contains(\"% Module a\"));\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn should_write_full_path_to_mod() {\n-        let markdown = render(~\"mod a { mod b { mod c { } } }\");\n-        assert!(markdown.contains(\"# Module `a::b::c`\"));\n-    }\n-\n-    #[test]\n-    fn should_write_sections() {\n-        let markdown = render(\n-            ~\"#[doc = \\\"\\\n-              # Header\\n\\\n-              Body\\\"]\\\n-              mod a {\n-}\");\n-        assert!(markdown.contains(\"#### Header\\n\\nBody\\n\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_write_crate_description() {\n-        let markdown = render(~\"#[doc = \\\"this is the crate\\\"];\");\n-        assert!(markdown.contains(\"this is the crate\"));\n-    }\n-\n-\n-    #[test]\n-    fn should_write_index() {\n-        let markdown = render(~\"mod a { } mod b { }\");\n-        assert!(markdown.contains(\n-            \"\\n\\n* [Module `a`](#module-a)\\n\\\n-             * [Module `b`](#module-b)\\n\\n\"\n-        ));\n-    }\n-\n-    #[test]\n-    fn should_write_index_brief() {\n-        let markdown = render(~\"#[doc = \\\"test\\\"] mod a { }\");\n-        assert!(markdown.contains(\"(#module-a) - test\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_not_write_index_if_no_entries() {\n-        let markdown = render(~\"\");\n-        assert!(!markdown.contains(\"\\n\\n\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_write_index_for_foreign_mods() {\n-        let markdown = render(~\"extern { fn a(); }\");\n-        assert!(markdown.contains(\n-            \"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n-        ));\n-    }\n-\n-    #[test]\n-    fn should_write_foreign_fns() {\n-        let markdown = render(\n-            ~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-        assert!(markdown.contains(\"test\"));\n-    }\n-\n-    #[test]\n-    fn should_write_foreign_fn_headers() {\n-        let markdown = render(\n-            ~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-        assert!(markdown.contains(\"## Function `a`\"));\n-    }\n-\n-    #[test]\n-    fn write_markdown_should_write_function_header() {\n-        let markdown = render(~\"fn func() { }\");\n-        assert!(markdown.contains(\"## Function `func`\"));\n-    }\n-\n-    #[test]\n-    fn should_write_the_function_signature() {\n-        let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-        assert!(markdown.contains(\"\\n~~~ {.rust}\\nfn a()\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_insert_blank_line_after_fn_signature() {\n-        let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-        assert!(markdown.contains(\"fn a()\\n~~~\\n\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_correctly_bracket_fn_signature() {\n-        let doc = create_doc(~\"fn a() { }\");\n-        let doc = doc::Doc{\n-            pages: ~[\n-                doc::CratePage(doc::CrateDoc{\n-                    topmod: doc::ModDoc{\n-                        items: ~[doc::FnTag(doc::SimpleItemDoc{\n-                            sig: Some(~\"line 1\\nline 2\"),\n-                            .. (doc.cratemod().fns()[0]).clone()\n-                        })],\n-                        .. doc.cratemod()\n-                    },\n-                    .. doc.CrateDoc()\n-                })\n-            ]\n-        };\n-        let markdown = write_markdown_str(doc);\n-        assert!(markdown.contains(\"~~~ {.rust}\\nline 1\\nline 2\\n~~~\"));\n-    }\n-\n-    #[test]\n-    fn should_leave_blank_line_between_fn_header_and_sig() {\n-        let markdown = render(~\"fn a() { }\");\n-        assert!(markdown.contains(\"Function `a`\\n\\n~~~ {.rust}\\nfn a()\"));\n-    }\n-\n-    #[test]\n-    fn should_write_static_header() {\n-        let markdown = render(~\"static a: bool = true;\");\n-        assert!(markdown.contains(\"## Static `a`\\n\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_write_static_description() {\n-        let markdown = render(\n-            ~\"#[doc = \\\"b\\\"]\\\n-              static a: bool = true;\");\n-        assert!(markdown.contains(\"\\n\\nb\\n\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_write_enum_header() {\n-        let markdown = render(~\"enum a { b }\");\n-        assert!(markdown.contains(\"## Enum `a`\\n\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_write_enum_description() {\n-        let markdown = render(~\"#[doc = \\\"b\\\"] enum a { b }\");\n-        assert!(markdown.contains(\"\\n\\nb\\n\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_write_variant_list() {\n-        let markdown = render(\n-            ~\"enum a { \\\n-              #[doc = \\\"test\\\"] b, \\\n-              #[doc = \\\"test\\\"] c }\");\n-        assert!(markdown.contains(\n-            \"\\n\\n#### Variants\\n\\\n-             \\n\\\n-             \\n* `b` - test\\\n-             \\n\\\n-             \\n* `c` - test\\n\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_write_variant_list_without_descs() {\n-        let markdown = render(~\"enum a { b, c }\");\n-        assert!(markdown.contains(\n-            \"\\n\\n#### Variants\\n\\\n-             \\n\\\n-             \\n* `b`\\\n-             \\n\\\n-             \\n* `c`\\n\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_write_variant_list_with_indent() {\n-        let markdown = render(\n-            ~\"enum a { #[doc = \\\"line 1\\\\n\\\\nline 2\\\"] b, c }\");\n-        assert!(markdown.contains(\n-            \"\\n\\n#### Variants\\n\\\n-             \\n\\\n-             \\n* `b` - line 1\\\n-             \\n    \\\n-             \\n    line 2\\\n-             \\n\\\n-             \\n* `c`\\n\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_write_variant_list_with_signatures() {\n-        let markdown = render(~\"enum a { b(int), #[doc = \\\"a\\\"] c(int) }\");\n-        assert!(markdown.contains(\n-            \"\\n\\n#### Variants\\n\\\n-             \\n\\\n-             \\n* `b(int)`\\\n-             \\n\\\n-             \\n* `c(int)` - a\\n\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_write_trait_header() {\n-        let markdown = render(~\"trait i { fn a(); }\");\n-        assert!(markdown.contains(\"## Trait `i`\"));\n-    }\n-\n-    #[test]\n-    fn should_write_trait_desc() {\n-        let markdown = render(~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n-        assert!(markdown.contains(\"desc\"));\n-    }\n-\n-    #[test]\n-    fn should_write_trait_method_header() {\n-        let markdown = render(~\"trait i { fn a(); }\");\n-        assert!(markdown.contains(\"### Method `a`\"));\n-    }\n-\n-    #[test]\n-    fn should_write_trait_method_signature() {\n-        let markdown = render(~\"trait i { fn a(&self); }\");\n-        assert!(markdown.contains(\"\\n~~~ {.rust}\\nfn a(&self)\"));\n-    }\n-\n-    #[test]\n-    fn should_write_impl_header() {\n-        let markdown = render(~\"impl int { fn a() { } }\");\n-        assert!(markdown.contains(\"## Implementation for `int`\"));\n-    }\n-\n-    #[test]\n-    fn should_write_impl_header_with_bounds() {\n-        let markdown = render(~\"impl <T> int<T> { }\");\n-        assert!(markdown.contains(\"## Implementation for `int<T>` where `<T>`\"));\n-    }\n-\n-    #[test]\n-    fn should_write_impl_header_with_trait() {\n-        let markdown = render(~\"impl j for int { fn a() { } }\");\n-        assert!(markdown.contains(\n-                              \"## Implementation of `j` for `int`\"));\n-    }\n-\n-    #[test]\n-    fn should_write_impl_desc() {\n-        let markdown = render(\n-            ~\"#[doc = \\\"desc\\\"] impl int { fn a() { } }\");\n-        assert!(markdown.contains(\"desc\"));\n-    }\n-\n-    #[test]\n-    fn should_write_impl_method_header() {\n-        let markdown = render(\n-            ~\"impl int { fn a() { } }\");\n-        assert!(markdown.contains(\"### Method `a`\"));\n-    }\n-\n-    #[test]\n-    fn should_write_impl_method_signature() {\n-        let markdown = render(\n-            ~\"impl int { fn a(&mut self) { } }\");\n-        assert!(markdown.contains(\"~~~ {.rust}\\nfn a(&mut self)\"));\n-    }\n-\n-    #[test]\n-    fn should_write_type_header() {\n-        let markdown = render(~\"type t = int;\");\n-        assert!(markdown.contains(\"## Type `t`\"));\n-    }\n-\n-    #[test]\n-    fn should_write_type_desc() {\n-        let markdown = render(\n-            ~\"#[doc = \\\"desc\\\"] type t = int;\");\n-        assert!(markdown.contains(\"\\n\\ndesc\\n\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_write_type_signature() {\n-        let markdown = render(~\"type t = int;\");\n-        assert!(markdown.contains(\"\\n\\n~~~ {.rust}\\ntype t = int\\n~~~\\n\"));\n-    }\n-\n-    #[test]\n-    fn should_put_struct_header() {\n-        let markdown = render(~\"struct S { field: () }\");\n-        assert!(markdown.contains(\"## Struct `S`\\n\\n\"));\n-    }\n-}"}, {"sha": "fb58e5c2bf02dfa76396fee61f31659a80e4e178", "filename": "src/librustdoc/markdown_writer.rs", "status": "removed", "additions": 0, "deletions": 287, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,287 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-use config;\n-use doc::ItemUtils;\n-use doc;\n-\n-use std::comm::*;\n-use std::comm;\n-use std::io;\n-use std::result;\n-use std::run;\n-use std::str;\n-use std::task;\n-use extra::future::Future;\n-\n-#[deriving(Clone)]\n-pub enum WriteInstr {\n-    Write(~str),\n-    Done\n-}\n-\n-pub type Writer = ~fn(v: WriteInstr);\n-pub type WriterFactory = ~fn(page: doc::Page) -> Writer;\n-\n-pub trait WriterUtils {\n-    fn put_str(&self, str: ~str);\n-    fn put_line(&self, str: ~str);\n-    fn put_done(&self);\n-}\n-\n-impl WriterUtils for Writer {\n-    fn put_str(&self, str: ~str) {\n-        (*self)(Write(str));\n-    }\n-\n-    fn put_line(&self, str: ~str) {\n-        self.put_str(str + \"\\n\");\n-    }\n-\n-    fn put_done(&self) {\n-        (*self)(Done)\n-    }\n-}\n-\n-pub fn make_writer_factory(config: config::Config) -> WriterFactory {\n-    match config.output_format {\n-      config::Markdown => {\n-        markdown_writer_factory(config)\n-      }\n-      config::PandocHtml => {\n-        pandoc_writer_factory(config)\n-      }\n-    }\n-}\n-\n-fn markdown_writer_factory(config: config::Config) -> WriterFactory {\n-    let result: ~fn(page: doc::Page) -> Writer = |page| {\n-        markdown_writer(&config, page)\n-    };\n-    result\n-}\n-\n-fn pandoc_writer_factory(config: config::Config) -> WriterFactory {\n-    let result: ~fn(doc::Page) -> Writer = |page| {\n-        pandoc_writer(&config, page)\n-    };\n-    result\n-}\n-\n-fn markdown_writer(\n-    config: &config::Config,\n-    page: doc::Page\n-) -> Writer {\n-    let filename = make_local_filename(config, page);\n-    do generic_writer |markdown| {\n-        write_file(&filename, markdown);\n-    }\n-}\n-\n-fn pandoc_writer(\n-    config: &config::Config,\n-    page: doc::Page\n-) -> Writer {\n-    assert!(config.pandoc_cmd.is_some());\n-    let pandoc_cmd = (*config.pandoc_cmd.get_ref()).clone();\n-    let filename = make_local_filename(config, page);\n-\n-    let pandoc_args = ~[\n-        ~\"--standalone\",\n-        ~\"--section-divs\",\n-        ~\"--from=markdown\",\n-        ~\"--to=html\",\n-        ~\"--css=rust.css\",\n-        ~\"--output=\" + filename.to_str()\n-    ];\n-\n-    do generic_writer |markdown| {\n-        use std::io::WriterUtil;\n-\n-        debug!(\"pandoc cmd: %s\", pandoc_cmd);\n-        debug!(\"pandoc args: %s\", pandoc_args.connect(\" \"));\n-\n-        let mut proc = run::Process::new(pandoc_cmd, pandoc_args, run::ProcessOptions::new());\n-\n-        proc.input().write_str(markdown);\n-        let output = proc.finish_with_output();\n-\n-        debug!(\"pandoc result: %i\", output.status);\n-        if output.status != 0 {\n-            error!(\"pandoc-out: %s\", str::from_utf8(output.output));\n-            error!(\"pandoc-err: %s\", str::from_utf8(output.error));\n-            fail!(\"pandoc failed\");\n-        }\n-    }\n-}\n-\n-fn generic_writer(process: ~fn(markdown: ~str)) -> Writer {\n-    let (po, ch) = stream::<WriteInstr>();\n-    do task::spawn || {\n-        let mut markdown = ~\"\";\n-        let mut keep_going = true;\n-        while keep_going {\n-            match po.recv() {\n-              Write(s) => markdown.push_str(s),\n-              Done => keep_going = false\n-            }\n-        }\n-        process(markdown);\n-    };\n-    let result: ~fn(instr: WriteInstr) = |instr| ch.send(instr);\n-    result\n-}\n-\n-pub fn make_local_filename(\n-    config: &config::Config,\n-    page: doc::Page\n-) -> Path {\n-    let filename = make_filename(config, page);\n-    config.output_dir.push_rel(&filename)\n-}\n-\n-pub fn make_filename(\n-    config: &config::Config,\n-    page: doc::Page\n-) -> Path {\n-    let filename = {\n-        match page {\n-          doc::CratePage(doc) => {\n-            if config.output_format == config::PandocHtml &&\n-                config.output_style == config::DocPerMod {\n-                ~\"index\"\n-            } else {\n-                assert!(doc.topmod.name_() != ~\"\");\n-                doc.topmod.name_()\n-            }\n-          }\n-          doc::ItemPage(doc) => {\n-            (doc.path() + &[doc.name_()]).connect(\"_\")\n-          }\n-        }\n-    };\n-    let ext = match config.output_format {\n-      config::Markdown => ~\"md\",\n-      config::PandocHtml => ~\"html\"\n-    };\n-\n-    Path(filename).with_filetype(ext)\n-}\n-\n-fn write_file(path: &Path, s: ~str) {\n-    use std::io::WriterUtil;\n-\n-    match io::file_writer(path, [io::Create, io::Truncate]) {\n-      result::Ok(writer) => {\n-        writer.write_str(s);\n-      }\n-      result::Err(e) => fail!(e)\n-    }\n-}\n-\n-pub fn future_writer_factory(\n-) -> (WriterFactory, Port<(doc::Page, ~str)>) {\n-    let (markdown_po, markdown_ch) = stream();\n-    let markdown_ch = SharedChan::new(markdown_ch);\n-    let writer_factory: WriterFactory = |page| {\n-        let (writer_po, writer_ch) = comm::stream();\n-        let markdown_ch = markdown_ch.clone();\n-        do task::spawn || {\n-            let (writer, future) = future_writer();\n-            let mut future = future;\n-            writer_ch.send(writer);\n-            let s = future.get();\n-            markdown_ch.send((page.clone(), s));\n-        }\n-        writer_po.recv()\n-    };\n-\n-    (writer_factory, markdown_po)\n-}\n-\n-fn future_writer() -> (Writer, Future<~str>) {\n-    let (port, chan) = comm::stream();\n-    let writer: ~fn(instr: WriteInstr) = |instr| chan.send(instr.clone());\n-    let future = do Future::from_fn || {\n-        let mut res = ~\"\";\n-        loop {\n-            match port.recv() {\n-              Write(s) => res.push_str(s),\n-              Done => break\n-            }\n-        }\n-        res\n-    };\n-    (writer, future)\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use astsrv;\n-    use doc;\n-    use extract;\n-    use path_pass;\n-    use config;\n-    use super::make_local_filename;\n-\n-    fn mk_doc(name: ~str, source: ~str) -> doc::Doc {\n-        do astsrv::from_str(source) |srv| {\n-            let doc = extract::from_srv(srv.clone(), name.clone());\n-            let doc = (path_pass::mk_pass().f)(srv.clone(), doc);\n-            doc\n-        }\n-    }\n-\n-    #[test]\n-    fn should_use_markdown_file_name_based_off_crate() {\n-        let config = config::Config {\n-            output_dir: Path(\"output/dir\"),\n-            output_format: config::Markdown,\n-            output_style: config::DocPerCrate,\n-            .. config::default_config(&Path(\"input/test.rc\"))\n-        };\n-        let doc = mk_doc(~\"test\", ~\"\");\n-        let page = doc::CratePage(doc.CrateDoc());\n-        let filename = make_local_filename(&config, page);\n-        assert_eq!(filename.to_str(), ~\"output/dir/test.md\");\n-    }\n-\n-    #[test]\n-    fn should_name_html_crate_file_name_index_html_when_doc_per_mod() {\n-        let config = config::Config {\n-            output_dir: Path(\"output/dir\"),\n-            output_format: config::PandocHtml,\n-            output_style: config::DocPerMod,\n-            .. config::default_config(&Path(\"input/test.rc\"))\n-        };\n-        let doc = mk_doc(~\"\", ~\"\");\n-        let page = doc::CratePage(doc.CrateDoc());\n-        let filename = make_local_filename(&config, page);\n-        assert_eq!(filename.to_str(), ~\"output/dir/index.html\");\n-    }\n-\n-    #[test]\n-    fn should_name_mod_file_names_by_path() {\n-        let config = config::Config {\n-            output_dir: Path(\"output/dir\"),\n-            output_format: config::PandocHtml,\n-            output_style: config::DocPerMod,\n-            .. config::default_config(&Path(\"input/test.rc\"))\n-        };\n-        let doc = mk_doc(~\"\", ~\"mod a { mod b { } }\");\n-        // hidden __std_macros module at the start.\n-        let modb = doc.cratemod().mods()[1].mods()[0].clone();\n-        let page = doc::ItemPage(doc::ModTag(modb));\n-        let filename = make_local_filename(&config, page);\n-        assert_eq!(filename, Path(\"output/dir/a_b.html\"));\n-    }\n-}"}, {"sha": "342c949e3fc60957ba507c0d7105ae7394117efc", "filename": "src/librustdoc/page_pass.rs", "status": "removed", "additions": 0, "deletions": 185, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,185 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Divides the document tree into pages.\n-\n-Each page corresponds is a logical section. There may be pages for\n-individual modules, pages for the crate, indexes, etc.\n-*/\n-\n-\n-use astsrv;\n-use config;\n-use doc::ItemUtils;\n-use doc;\n-use fold::Fold;\n-use fold;\n-use pass::Pass;\n-\n-use std::comm::*;\n-use std::task;\n-use syntax::ast;\n-\n-#[cfg(test)] use doc::PageUtils;\n-\n-pub fn mk_pass(output_style: config::OutputStyle) -> Pass {\n-    Pass {\n-        name: ~\"page\",\n-        f: |srv, doc| run(srv, doc, output_style)\n-    }\n-}\n-\n-pub fn run(\n-    _srv: astsrv::Srv,\n-    doc: doc::Doc,\n-    output_style: config::OutputStyle\n-) -> doc::Doc {\n-\n-    if output_style == config::DocPerCrate {\n-        return doc;\n-    }\n-\n-    let (result_port, result_chan) = stream();\n-    let (page_port, page_chan) = stream();\n-    let page_chan = SharedChan::new(page_chan);\n-    do task::spawn {\n-        result_chan.send(make_doc_from_pages(&page_port));\n-    };\n-\n-    find_pages(doc, page_chan);\n-    result_port.recv()\n-}\n-\n-type PagePort = Port<Option<doc::Page>>;\n-type PageChan = SharedChan<Option<doc::Page>>;\n-\n-fn make_doc_from_pages(page_port: &PagePort) -> doc::Doc {\n-    let mut pages = ~[];\n-    loop {\n-        let val = page_port.recv();\n-        if val.is_some() {\n-            pages.push(val.unwrap());\n-        } else {\n-            break;\n-        }\n-    }\n-    doc::Doc {\n-        pages: pages\n-    }\n-}\n-\n-fn find_pages(doc: doc::Doc, page_chan: PageChan) {\n-    let fold = Fold {\n-        ctxt: page_chan.clone(),\n-        fold_crate: fold_crate,\n-        fold_mod: fold_mod,\n-        fold_nmod: fold_nmod,\n-        .. fold::default_any_fold(page_chan.clone())\n-    };\n-    (fold.fold_doc)(&fold, doc.clone());\n-\n-    page_chan.send(None);\n-}\n-\n-fn fold_crate(fold: &fold::Fold<PageChan>, doc: doc::CrateDoc)\n-              -> doc::CrateDoc {\n-    let doc = fold::default_seq_fold_crate(fold, doc);\n-\n-    let page = doc::CratePage(doc::CrateDoc {\n-        topmod: strip_mod(doc.topmod.clone()),\n-        .. doc.clone()\n-    });\n-\n-    fold.ctxt.send(Some(page));\n-\n-    doc\n-}\n-\n-fn fold_mod(fold: &fold::Fold<PageChan>, doc: doc::ModDoc) -> doc::ModDoc {\n-    let doc = fold::default_any_fold_mod(fold, doc);\n-\n-    if doc.id() != ast::CRATE_NODE_ID {\n-\n-        let doc = strip_mod(doc.clone());\n-        let page = doc::ItemPage(doc::ModTag(doc));\n-        fold.ctxt.send(Some(page));\n-    }\n-\n-    doc\n-}\n-\n-fn strip_mod(doc: doc::ModDoc) -> doc::ModDoc {\n-    doc::ModDoc {\n-        items: do doc.items.iter().filter |item| {\n-            match **item {\n-              doc::ModTag(_) | doc::NmodTag(_) => false,\n-              _ => true\n-            }\n-        }.map(|x| (*x).clone()).collect::<~[doc::ItemTag]>(),\n-        .. doc.clone()\n-    }\n-}\n-\n-fn fold_nmod(fold: &fold::Fold<PageChan>, doc: doc::NmodDoc) -> doc::NmodDoc {\n-    let doc = fold::default_seq_fold_nmod(fold, doc);\n-    let page = doc::ItemPage(doc::NmodTag(doc.clone()));\n-    fold.ctxt.send(Some(page));\n-    return doc;\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use astsrv;\n-    use config;\n-    use attr_pass;\n-    use doc;\n-    use extract;\n-    use prune_hidden_pass;\n-    use page_pass::run;\n-\n-    fn mk_doc_(\n-        output_style: config::OutputStyle,\n-        source: ~str\n-    ) -> doc::Doc {\n-        do astsrv::from_str(source.clone()) |srv| {\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n-            let doc = (prune_hidden_pass::mk_pass().f)(srv.clone(), doc);\n-            run(srv.clone(), doc, output_style)\n-        }\n-    }\n-\n-    fn mk_doc(source: ~str) -> doc::Doc {\n-        mk_doc_(config::DocPerMod, source.clone())\n-    }\n-\n-    #[test]\n-    fn should_not_split_the_doc_into_pages_for_doc_per_crate() {\n-        let doc = mk_doc_(\n-            config::DocPerCrate,\n-            ~\"mod a { } mod b { mod c { } }\"\n-        );\n-        assert_eq!(doc.pages.len(), 1u);\n-    }\n-\n-    #[test]\n-    fn should_make_a_page_for_every_mod() {\n-        let doc = mk_doc(~\"mod a { }\");\n-        // hidden __std_macros module at the start.\n-        assert_eq!(doc.pages.mods()[0].name_(), ~\"a\");\n-    }\n-\n-    #[test]\n-    fn should_remove_mods_from_containing_mods() {\n-        let doc = mk_doc(~\"mod a { }\");\n-        assert!(doc.cratemod().mods().is_empty());\n-    }\n-}"}, {"sha": "a8321dd95a1594276dbc35195b0af29cb2f855c4", "filename": "src/librustdoc/parse.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fparse.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! AST-parsing helpers\n-\n-use rustc::driver::driver;\n-use rustc::driver::session;\n-use syntax::ast;\n-use syntax::parse;\n-\n-pub fn from_file(file: &Path) -> @ast::Crate {\n-    parse::parse_crate_from_file(\n-        file, ~[], parse::new_parse_sess(None))\n-}\n-\n-pub fn from_str(source: @str) -> @ast::Crate {\n-    parse::parse_crate_from_source_str(\n-        @\"-\", source, ~[], parse::new_parse_sess(None))\n-}\n-\n-pub fn from_file_sess(sess: session::Session, file: &Path) -> @ast::Crate {\n-    parse::parse_crate_from_file(\n-        file, cfg(sess), sess.parse_sess)\n-}\n-\n-pub fn from_str_sess(sess: session::Session, source: @str) -> @ast::Crate {\n-    parse::parse_crate_from_source_str(\n-        @\"-\", source, cfg(sess), sess.parse_sess)\n-}\n-\n-fn cfg(sess: session::Session) -> ast::CrateConfig {\n-    driver::build_configuration(sess)\n-}\n-"}, {"sha": "aadc1b31acc5296323c13e1027117d9c2ebc3a39", "filename": "src/librustdoc/pass.rs", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,96 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-\n-use astsrv;\n-use doc;\n-use time;\n-\n-#[cfg(test)] use extract;\n-\n-/// A single operation on the document model\n-pub struct Pass {\n-    name: ~str,\n-    f: @fn(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc\n-}\n-\n-pub fn run_passes(\n-    srv: astsrv::Srv,\n-    doc: doc::Doc,\n-    passes: ~[Pass]\n-) -> doc::Doc {\n-    let mut passno = 0;\n-    do passes.iter().fold(doc) |doc, pass| {\n-        debug!(\"pass #%d\", passno);\n-        passno += 1;\n-        do time(pass.name.clone()) {\n-            (pass.f)(srv.clone(), doc.clone())\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_run_passes() {\n-    fn pass1(\n-        _srv: astsrv::Srv,\n-        doc: doc::Doc\n-    ) -> doc::Doc {\n-        doc::Doc{\n-            pages: ~[\n-                doc::CratePage(doc::CrateDoc{\n-                    topmod: doc::ModDoc{\n-                        item: doc::ItemDoc {\n-                            name: doc.cratemod().name_() + \"two\",\n-                            .. doc.cratemod().item.clone()\n-                        },\n-                        items: ~[],\n-                        index: None\n-                    }\n-                })\n-            ]\n-        }\n-    }\n-    fn pass2(\n-        _srv: astsrv::Srv,\n-        doc: doc::Doc\n-    ) -> doc::Doc {\n-        doc::Doc{\n-            pages: ~[\n-                doc::CratePage(doc::CrateDoc{\n-                    topmod: doc::ModDoc{\n-                        item: doc::ItemDoc {\n-                            name: doc.cratemod().name_() + \"three\",\n-                            .. doc.cratemod().item.clone()\n-                        },\n-                        items: ~[],\n-                        index: None\n-                    }\n-                })\n-            ]\n-        }\n-    }\n-    let source = ~\"\";\n-    do astsrv::from_str(source) |srv| {\n-        let passes = ~[\n-            Pass {\n-                name: ~\"\",\n-                f: pass1\n-            },\n-            Pass {\n-                name: ~\"\",\n-                f: pass2\n-            }\n-        ];\n-        let doc = extract::from_srv(srv.clone(), ~\"one\");\n-        let doc = run_passes(srv, doc, passes);\n-        assert_eq!(doc.cratemod().name_(), ~\"onetwothree\");\n-    }\n-}"}, {"sha": "e580ab0719c8effc6155ed3c2b9030cf828e46ec", "filename": "src/librustdoc/passes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/passes.rs"}, {"sha": "6e6092a6a3fa359c8947f17de3134e14c7285f71", "filename": "src/librustdoc/path_pass.rs", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,115 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Records the full path to items\n-\n-\n-use astsrv;\n-use doc::ItemUtils;\n-use doc;\n-use fold::Fold;\n-use fold;\n-use pass::Pass;\n-\n-#[cfg(test)] use extract;\n-\n-use syntax::ast;\n-\n-pub fn mk_pass() -> Pass {\n-    Pass {\n-        name: ~\"path\",\n-        f: run\n-    }\n-}\n-\n-struct Ctxt {\n-    srv: astsrv::Srv,\n-    path: @mut ~[~str]\n-}\n-\n-impl Clone for Ctxt {\n-    fn clone(&self) -> Ctxt {\n-        Ctxt {\n-            srv: self.srv.clone(),\n-            path: @mut (*self.path).clone()\n-        }\n-    }\n-}\n-\n-fn run(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n-    let ctxt = Ctxt {\n-        srv: srv,\n-        path: @mut ~[]\n-    };\n-    let fold = Fold {\n-        ctxt: ctxt.clone(),\n-        fold_item: fold_item,\n-        fold_mod: fold_mod,\n-        fold_nmod: fold_nmod,\n-        .. fold::default_any_fold(ctxt)\n-    };\n-    (fold.fold_doc)(&fold, doc)\n-}\n-\n-fn fold_item(fold: &fold::Fold<Ctxt>, doc: doc::ItemDoc) -> doc::ItemDoc {\n-    doc::ItemDoc {\n-        path: (*fold.ctxt.path).clone(),\n-        .. doc\n-    }\n-}\n-\n-fn fold_mod(fold: &fold::Fold<Ctxt>, doc: doc::ModDoc) -> doc::ModDoc {\n-    let is_topmod = doc.id() == ast::CRATE_NODE_ID;\n-\n-    if !is_topmod { fold.ctxt.path.push(doc.name_()); }\n-    let doc = fold::default_any_fold_mod(fold, doc);\n-    if !is_topmod { fold.ctxt.path.pop(); }\n-\n-    doc::ModDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        .. doc\n-    }\n-}\n-\n-fn fold_nmod(fold: &fold::Fold<Ctxt>, doc: doc::NmodDoc) -> doc::NmodDoc {\n-    fold.ctxt.path.push(doc.name_());\n-    let doc = fold::default_seq_fold_nmod(fold, doc);\n-    fold.ctxt.path.pop();\n-\n-    doc::NmodDoc {\n-        item: (fold.fold_item)(fold, doc.item.clone()),\n-        .. doc\n-    }\n-}\n-\n-#[test]\n-fn should_record_mod_paths() {\n-    let source = ~\"mod a { mod b { mod c { } } mod d { mod e { } } }\";\n-    do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv.clone(), ~\"\");\n-        let doc = run(srv.clone(), doc);\n-        // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().mods()[1].mods()[0].mods()[0].path(),\n-                   ~[~\"a\", ~\"b\"]);\n-        assert_eq!(doc.cratemod().mods()[1].mods()[1].mods()[0].path(),\n-                   ~[~\"a\", ~\"d\"]);\n-    }\n-}\n-\n-#[test]\n-fn should_record_fn_paths() {\n-    let source = ~\"mod a { fn b() { } }\";\n-    do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv.clone(), ~\"\");\n-        let doc = run(srv.clone(), doc);\n-        // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().mods()[1].fns()[0].path(), ~[~\"a\"]);\n-    }\n-}"}, {"sha": "4bad87088a129bbd69b689713192f46936c12511", "filename": "src/librustdoc/plugins.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/plugins.rs"}, {"sha": "9dc2f43f7ac92451e98811920fa1141603204f87", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Prunes things with the #[doc(hidden)] attribute\n-\n-use astsrv;\n-use attr_parser;\n-use doc::ItemUtils;\n-use doc;\n-use fold::Fold;\n-use fold;\n-use pass::Pass;\n-\n-pub fn mk_pass() -> Pass {\n-    Pass {\n-        name: ~\"prune_hidden\",\n-        f: run\n-    }\n-}\n-\n-pub fn run(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n-    let fold = Fold {\n-        ctxt: srv.clone(),\n-        fold_mod: fold_mod,\n-        .. fold::default_any_fold(srv)\n-    };\n-    (fold.fold_doc)(&fold, doc)\n-}\n-\n-fn fold_mod(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::ModDoc\n-) -> doc::ModDoc {\n-    let doc = fold::default_any_fold_mod(fold, doc);\n-\n-    doc::ModDoc {\n-        items: do doc.items.iter().filter |item_tag| {\n-            !is_hidden(fold.ctxt.clone(), item_tag.item())\n-        }.map(|x| (*x).clone()).collect(),\n-        .. doc\n-    }\n-}\n-\n-fn is_hidden(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n-    use syntax::ast_map;\n-\n-    let id = doc.id;\n-    do astsrv::exec(srv) |ctxt| {\n-        let attrs = match ctxt.ast_map.get_copy(&id) {\n-          ast_map::node_item(item, _) => item.attrs.clone(),\n-          _ => ~[]\n-        };\n-        attr_parser::parse_hidden(attrs)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use astsrv;\n-    use doc;\n-    use extract;\n-    use prune_hidden_pass::run;\n-\n-    fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(source.clone()) |srv| {\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            run(srv.clone(), doc)\n-        }\n-    }\n-\n-    #[test]\n-    fn should_prune_hidden_items() {\n-        let doc = mk_doc(~\"#[doc(hidden)] mod a { }\");\n-        assert!(doc.cratemod().mods().is_empty())\n-    }\n-}"}, {"sha": "6a2a0ef502c886d7155d109b602f8fedaf1330a4", "filename": "src/librustdoc/prune_private_pass.rs", "status": "removed", "additions": 0, "deletions": 255, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,255 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Prune things that are private\n-\n-\n-use extract;\n-use syntax::ast;\n-use syntax::ast_map;\n-use astsrv;\n-use doc;\n-use fold::Fold;\n-use fold;\n-use pass::Pass;\n-\n-pub fn mk_pass() -> Pass {\n-    Pass {\n-        name: ~\"prune_private\",\n-        f: run\n-    }\n-}\n-\n-pub fn run(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n-    // First strip private methods out of impls\n-    let fold = Fold {\n-        ctxt: srv.clone(),\n-        fold_impl: fold_impl,\n-        .. fold::default_any_fold(srv.clone())\n-    };\n-    let doc = (fold.fold_doc)(&fold, doc);\n-\n-    // Then strip private items and empty impls\n-    let fold = Fold {\n-        ctxt: srv.clone(),\n-        fold_mod: fold_mod,\n-        .. fold::default_any_fold(srv)\n-    };\n-    let doc = (fold.fold_doc)(&fold, doc);\n-\n-    return doc;\n-}\n-\n-fn fold_impl(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::ImplDoc\n-) -> doc::ImplDoc {\n-    let doc = fold::default_seq_fold_impl(fold, doc);\n-\n-    do astsrv::exec(fold.ctxt.clone()) |ctxt| {\n-        match ctxt.ast_map.get_copy(&doc.item.id) {\n-            ast_map::node_item(item, _) => {\n-                match item.node {\n-                    ast::item_impl(_, None, _, ref methods) => {\n-                        // Associated impls have complex rules for method visibility\n-                        strip_priv_methods(doc.clone(), *methods, item.vis)\n-                    }\n-                    ast::item_impl(_, Some(_), _ ,_) => {\n-                        // Trait impls don't\n-                        doc.clone()\n-                    }\n-                    _ => fail!()\n-                }\n-            }\n-            _ => fail!()\n-        }\n-    }\n-}\n-\n-fn strip_priv_methods(\n-    doc: doc::ImplDoc,\n-    methods: &[@ast::method],\n-    item_vis: ast::visibility\n-) -> doc::ImplDoc {\n-    let methods = do doc.methods.iter().filter |method| {\n-        let ast_method = do methods.iter().find |m| {\n-            extract::to_str(m.ident) == method.name\n-        };\n-        assert!(ast_method.is_some());\n-        let ast_method = ast_method.unwrap();\n-        match ast_method.vis {\n-            ast::public => true,\n-            ast::private => false,\n-            ast::inherited => item_vis == ast::public\n-        }\n-    }.map(|x| (*x).clone()).collect();\n-\n-    doc::ImplDoc {\n-        methods: methods,\n-        .. doc\n-    }\n-}\n-\n-fn fold_mod(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::ModDoc\n-) -> doc::ModDoc {\n-    let doc = fold::default_any_fold_mod(fold, doc);\n-\n-    doc::ModDoc {\n-        items: doc.items.iter().filter(|item_tag| {\n-            match item_tag {\n-                & &doc::ImplTag(ref doc) => {\n-                    if doc.trait_types.is_empty() {\n-                        // This is an associated impl. We have already pruned the\n-                        // non-visible methods. If there are any left then\n-                        // retain the impl, otherwise throw it away\n-                        !doc.methods.is_empty()\n-                    } else {\n-                        // This is a trait implementation, make it visible\n-                        // NB: This is not quite right since this could be an impl\n-                        // of a private trait. We can't know that without running\n-                        // resolve though.\n-                        true\n-                    }\n-                }\n-                _ => {\n-                    is_visible(fold.ctxt.clone(), item_tag.item())\n-                }\n-            }\n-        }).map(|x| (*x).clone()).collect(),\n-        .. doc\n-    }\n-}\n-\n-fn is_visible(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n-    let id = doc.id;\n-\n-    do astsrv::exec(srv) |ctxt| {\n-        match ctxt.ast_map.get_copy(&id) {\n-            ast_map::node_item(item, _) => {\n-                match &item.node {\n-                    &ast::item_impl(*) => {\n-                        // Impls handled elsewhere\n-                        fail!()\n-                    }\n-                    _ => {\n-                        // Otherwise just look at the visibility\n-                        item.vis == ast::public\n-                    }\n-                }\n-            }\n-            _ => unreachable!()\n-        }\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod test {\n-    use astsrv;\n-    use doc;\n-    use extract;\n-    use tystr_pass;\n-    use prune_private_pass::run;\n-\n-    fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(source.clone()) |srv| {\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            let doc = tystr_pass::run(srv.clone(), doc);\n-            run(srv.clone(), doc)\n-        }\n-    }\n-\n-    #[test]\n-    fn should_prune_items_without_pub_modifier() {\n-        let doc = mk_doc(~\"mod a { }\");\n-        assert!(doc.cratemod().mods().is_empty());\n-    }\n-\n-    #[test]\n-    fn should_not_prune_trait_impls() {\n-        // Impls are more complicated\n-        let doc = mk_doc(\n-            ~\" \\\n-              trait Foo { } \\\n-              impl Foo for int { } \\\n-              \");\n-        assert!(!doc.cratemod().impls().is_empty());\n-    }\n-\n-    #[test]\n-    fn should_prune_associated_methods_without_vis_modifier_on_impls_without_vis_modifier() {\n-        let doc = mk_doc(\n-            ~\"impl Foo {\\\n-              pub fn bar() { }\\\n-              fn baz() { }\\\n-              }\");\n-        assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n-    }\n-\n-    #[test]\n-    fn should_prune_priv_associated_methods_on_impls_without_vis_modifier() {\n-        let doc = mk_doc(\n-            ~\"impl Foo {\\\n-              pub fn bar() { }\\\n-              fn baz() { }\\\n-              }\");\n-        assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n-    }\n-\n-    #[test]\n-    fn should_prune_priv_associated_methods_on_pub_impls() {\n-        let doc = mk_doc(\n-            ~\"impl Foo {\\\n-              pub fn bar() { }\\\n-              fn baz() { }\\\n-              }\");\n-        assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n-    }\n-\n-    #[test]\n-    fn should_prune_associated_methods_without_vis_modifier_on_priv_impls() {\n-        let doc = mk_doc(\n-            ~\"impl Foo {\\\n-              pub fn bar() { }\\\n-              fn baz() { }\\\n-              }\");\n-        assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n-    }\n-\n-    #[test]\n-    fn should_prune_priv_associated_methods_on_priv_impls() {\n-        let doc = mk_doc(\n-            ~\"impl Foo {\\\n-              pub fn bar() { }\\\n-              fn baz() { }\\\n-              }\");\n-        assert_eq!(doc.cratemod().impls()[0].methods.len(), 1);\n-    }\n-\n-    #[test]\n-    fn should_prune_associated_impls_with_no_pub_methods() {\n-        let doc = mk_doc(\n-            ~\"impl Foo {\\\n-              fn baz() { }\\\n-              }\");\n-        assert!(doc.cratemod().impls().is_empty());\n-    }\n-\n-    #[test]\n-    fn should_not_prune_associated_impls_with_pub_methods() {\n-        let doc = mk_doc(\n-            ~\" \\\n-              impl Foo { pub fn bar() { } } \\\n-              \");\n-        assert!(!doc.cratemod().impls().is_empty());\n-    }\n-}"}, {"sha": "bc7e6c8926db5c04376406d7ba6aaabefe4ef5b4", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 179, "deletions": 110, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "patch": "@@ -8,140 +8,209 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Rustdoc - The Rust documentation generator\n-\n #[link(name = \"rustdoc\",\n        vers = \"0.8\",\n-       uuid = \"f8abd014-b281-484d-a0c3-26e3de8e2412\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/rustdoc\")];\n+       uuid = \"8c6e4598-1596-4aa5-a24c-b811914bbbc6\",\n+       url = \"https://github.com/mozilla/rust/tree/master/src/librustdoc\")];\n \n-#[comment = \"The Rust documentation generator\"];\n+#[desc = \"rustdoc, the Rust documentation extractor\"];\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-extern mod extra;\n-extern mod rustc;\n extern mod syntax;\n+extern mod rustc;\n+extern mod extra;\n \n-use std::os;\n-\n-use config::Config;\n-use doc::Item;\n-use doc::ItemUtils;\n-\n-pub mod pass;\n-pub mod config;\n-pub mod parse;\n-pub mod extract;\n-pub mod attr_parser;\n-pub mod doc;\n-pub mod markdown_index_pass;\n-pub mod markdown_pass;\n-pub mod markdown_writer;\n+use extra::serialize::Encodable;\n+use extra::time;\n+use extra::getopts::groups;\n+use std::cell::Cell;\n+use std::rt::io;\n+use std::rt::io::Writer;\n+use std::rt::io::file::FileInfo;\n+\n+pub mod clean;\n+pub mod core;\n+pub mod doctree;\n pub mod fold;\n-pub mod path_pass;\n-pub mod attr_pass;\n-pub mod tystr_pass;\n-pub mod prune_hidden_pass;\n-pub mod desc_to_brief_pass;\n-pub mod text_pass;\n-pub mod unindent_pass;\n-pub mod trim_pass;\n-pub mod astsrv;\n-pub mod demo;\n-pub mod sort_pass;\n-pub mod sort_item_name_pass;\n-pub mod sort_item_type_pass;\n-pub mod page_pass;\n-pub mod sectionalize_pass;\n-pub mod escape_pass;\n-pub mod prune_private_pass;\n+pub mod html {\n+    pub mod render;\n+    pub mod layout;\n+    pub mod markdown;\n+    pub mod format;\n+}\n+pub mod passes;\n+pub mod plugins;\n+pub mod visit_ast;\n+\n+pub static SCHEMA_VERSION: &'static str = \"0.8.0\";\n+\n+local_data_key!(pub ctxtkey: @core::DocContext)\n+\n+enum OutputFormat {\n+    HTML, JSON\n+}\n \n pub fn main() {\n-    let args = os::args();\n-    main_args(args);\n+    main_args(std::os::args());\n+}\n+\n+pub fn opts() -> ~[groups::OptGroup] {\n+    use extra::getopts::groups::*;\n+    ~[\n+        optmulti(\"L\", \"library-path\", \"directory to add to crate search path\",\n+                 \"DIR\"),\n+        optmulti(\"\", \"plugin-path\", \"directory to load plugins from\", \"DIR\"),\n+        optmulti(\"\", \"passes\", \"space separated list of passes to also run\",\n+                 \"PASSES\"),\n+        optmulti(\"\", \"plugins\", \"space separated list of plugins to also load\",\n+                 \"PLUGINS\"),\n+        optflag(\"h\", \"help\", \"show this help message\"),\n+        optflag(\"\", \"nodefaults\", \"don't run the default passes\"),\n+        optopt(\"o\", \"output\", \"where to place the output\", \"PATH\"),\n+    ]\n+}\n+\n+pub fn usage(argv0: &str) {\n+    println(groups::usage(format!(\"{} [options] [html|json] <crate>\",\n+                                  argv0), opts()));\n }\n \n pub fn main_args(args: &[~str]) {\n-    if args.iter().any(|x| \"-h\" == *x) || args.iter().any(|x| \"--help\" == *x) {\n-        config::usage();\n+    //use extra::getopts::groups::*;\n+\n+    let matches = groups::getopts(args.tail(), opts()).unwrap();\n+\n+    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n+        usage(args[0]);\n         return;\n     }\n \n-    let config = match config::parse_config(args) {\n-      Ok(config) => config,\n-      Err(err) => {\n-        printfln!(\"error: %s\", err);\n-        return;\n-      }\n+    let (format, cratefile) = match matches.free.clone() {\n+        [~\"json\", crate] => (JSON, crate),\n+        [~\"html\", crate] => (HTML, crate),\n+        [s, _] => {\n+            println!(\"Unknown output format: `{}`\", s);\n+            usage(args[0]);\n+            exit(1);\n+        }\n+        [_, .._] => {\n+            println!(\"Expected exactly one crate to process\");\n+            usage(args[0]);\n+            exit(1);\n+        }\n+        _ => {\n+            println!(\"Expected an output format and then one crate\");\n+            usage(args[0]);\n+            exit(1);\n+        }\n     };\n \n-    run(config);\n-}\n+    // First, parse the crate and extract all relevant information.\n+    let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path(*s)));\n+    let cr = Cell::new(Path(cratefile));\n+    info2!(\"starting to run rustc\");\n+    let crate = do std::task::try {\n+        let cr = cr.take();\n+        core::run_core(libs.take(), &cr)\n+    }.unwrap();\n+    info2!(\"finished with rustc\");\n+\n+    // Process all of the crate attributes, extracting plugin metadata along\n+    // with the passes which we are supposed to run.\n+    let mut default_passes = !matches.opt_present(\"nodefaults\");\n+    let mut passes = matches.opt_strs(\"passes\");\n+    let mut plugins = matches.opt_strs(\"plugins\");\n+    match crate.module.get_ref().doc_list() {\n+        Some(nested) => {\n+            for inner in nested.iter() {\n+                match *inner {\n+                    clean::Word(~\"no_default_passes\") => {\n+                        default_passes = false;\n+                    }\n+                    clean::NameValue(~\"passes\", ref value) => {\n+                        for pass in value.word_iter() {\n+                            passes.push(pass.to_owned());\n+                        }\n+                    }\n+                    clean::NameValue(~\"plugins\", ref value) => {\n+                        for p in value.word_iter() {\n+                            plugins.push(p.to_owned());\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        None => {}\n+    }\n+    if default_passes {\n+        passes.unshift(~\"collapse-docs\");\n+        passes.unshift(~\"unindent-comments\");\n+    }\n \n-/// Runs rustdoc over the given file\n-fn run(config: Config) {\n+    // Load all plugins/passes into a PluginManager\n+    let mut pm = plugins::PluginManager::new(Path(\"/tmp/rustdoc_ng/plugins\"));\n+    for pass in passes.iter() {\n+        let plugin = match pass.as_slice() {\n+            \"strip-hidden\" => passes::strip_hidden,\n+            \"unindent-comments\" => passes::unindent_comments,\n+            \"collapse-docs\" => passes::collapse_docs,\n+            \"collapse-privacy\" => passes::collapse_privacy,\n+            s => { error!(\"unknown pass %s, skipping\", s); loop },\n+        };\n+        pm.add_plugin(plugin);\n+    }\n+    info2!(\"loading plugins...\");\n+    for pname in plugins.move_iter() {\n+        pm.load_plugin(pname);\n+    }\n \n-    let source_file = config.input_crate.clone();\n+    // Run everything!\n+    info2!(\"Executing passes/plugins\");\n+    let (crate, res) = pm.run_plugins(crate);\n \n-    // Create an AST service from the source code\n-    do astsrv::from_file(source_file.to_str()) |srv| {\n+    info2!(\"going to format\");\n+    let started = time::precise_time_ns();\n+    let output = matches.opt_str(\"o\").map(|s| Path(*s));\n+    match format {\n+        HTML => { html::render::run(crate, output.unwrap_or(Path(\"doc\"))) }\n+        JSON => { jsonify(crate, res, output.unwrap_or(Path(\"doc.json\"))) }\n+    }\n+    let ended = time::precise_time_ns();\n+    info2!(\"Took {:.03f}s\", (ended as f64 - started as f64) / 1000000000f64);\n+}\n \n-        // Just time how long it takes for the AST to become available\n-        do time(~\"wait_ast\") {\n-            do astsrv::exec(srv.clone()) |_ctxt| { }\n-        };\n+fn jsonify(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n+    // {\n+    //   \"schema\": version,\n+    //   \"crate\": { parsed crate ... },\n+    //   \"plugins\": { output of plugins ... }\n+    // }\n+    let mut json = ~extra::treemap::TreeMap::new();\n+    json.insert(~\"schema\", extra::json::String(SCHEMA_VERSION.to_owned()));\n+    let plugins_json = ~res.move_iter().filter_map(|opt| opt).collect();\n+\n+    // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n+    // straight to the Rust JSON representation.\n+    let crate_json_str = do std::io::with_str_writer |w| {\n+        crate.encode(&mut extra::json::Encoder(w));\n+    };\n+    let crate_json = match extra::json::from_str(crate_json_str) {\n+        Ok(j) => j,\n+        Err(_) => fail!(\"Rust generated JSON is invalid??\")\n+    };\n \n-        // Extract the initial doc tree from the AST. This contains\n-        // just names and node ids.\n-        let doc = time(~\"extract\", || {\n-            let default_name = source_file.clone();\n-            extract::from_srv(srv.clone(), default_name.to_str())\n-        });\n-\n-        // Refine and publish the document\n-        pass::run_passes(srv, doc, ~[\n-            // Generate type and signature strings\n-            tystr_pass::mk_pass(),\n-            // Record the full paths to various nodes\n-            path_pass::mk_pass(),\n-            // Extract the docs attributes and attach them to doc nodes\n-            attr_pass::mk_pass(),\n-            // Perform various text escaping\n-            escape_pass::mk_pass(),\n-            // Remove things marked doc(hidden)\n-            prune_hidden_pass::mk_pass(),\n-            // Remove things that are private\n-            prune_private_pass::mk_pass(),\n-            // Extract brief documentation from the full descriptions\n-            desc_to_brief_pass::mk_pass(),\n-            // Massage the text to remove extra indentation\n-            unindent_pass::mk_pass(),\n-            // Split text into multiple sections according to headers\n-            sectionalize_pass::mk_pass(),\n-            // Trim extra spaces from text\n-            trim_pass::mk_pass(),\n-            // Sort items by name\n-            sort_item_name_pass::mk_pass(),\n-            // Sort items again by kind\n-            sort_item_type_pass::mk_pass(),\n-            // Create indexes appropriate for markdown\n-            markdown_index_pass::mk_pass(config.clone()),\n-            // Break the document into pages if required by the\n-            // output format\n-            page_pass::mk_pass(config.output_style),\n-            // Render\n-            markdown_pass::mk_pass(\n-                markdown_writer::make_writer_factory(config.clone())\n-            )\n-        ]);\n-    }\n+    json.insert(~\"crate\", crate_json);\n+    json.insert(~\"plugins\", extra::json::Object(plugins_json));\n+\n+    let mut file = dst.open_writer(io::Create).unwrap();\n+    let output = extra::json::Object(json).to_str();\n+    file.write(output.as_bytes());\n }\n \n-pub fn time<T>(what: ~str, f: &fn() -> T) -> T {\n-    let start = extra::time::precise_time_s();\n-    let rv = f();\n-    let end = extra::time::precise_time_s();\n-    info!(\"time: %3.3f s    %s\", end - start, what);\n-    rv\n+fn exit(status: int) -> ! {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    use std::libc;\n+    unsafe { libc::exit(status as libc::c_int) }\n }"}, {"sha": "20f3ff3e98d4871b0ec72d4bf7a865c22d55b6f0", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "removed", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,257 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Breaks rustdocs into sections according to their headers\n-\n-\n-use astsrv;\n-use doc::ItemUtils;\n-use doc;\n-use fold::Fold;\n-use fold;\n-use pass::Pass;\n-\n-pub fn mk_pass() -> Pass {\n-    Pass {\n-        name: ~\"sectionalize\",\n-        f: run\n-    }\n-}\n-\n-pub fn run(_srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n-    let fold = Fold {\n-        fold_item: fold_item,\n-        fold_trait: fold_trait,\n-        fold_impl: fold_impl,\n-        .. fold::default_any_fold(())\n-    };\n-    (fold.fold_doc)(&fold, doc)\n-}\n-\n-fn fold_item(fold: &fold::Fold<()>, doc: doc::ItemDoc) -> doc::ItemDoc {\n-    let doc = fold::default_seq_fold_item(fold, doc);\n-    let (desc, sections) = sectionalize(doc.desc.clone());\n-\n-    doc::ItemDoc {\n-        desc: desc,\n-        sections: sections,\n-        .. doc\n-    }\n-}\n-\n-fn fold_trait(fold: &fold::Fold<()>, doc: doc::TraitDoc) -> doc::TraitDoc {\n-    let doc = fold::default_seq_fold_trait(fold, doc);\n-\n-    doc::TraitDoc {\n-        methods: do doc.methods.map |method| {\n-            let (desc, sections) = sectionalize(method.desc.clone());\n-\n-            doc::MethodDoc {\n-                desc: desc,\n-                sections: sections,\n-                .. (*method).clone()\n-            }\n-        },\n-        .. doc\n-    }\n-}\n-\n-fn fold_impl(fold: &fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n-    let doc = fold::default_seq_fold_impl(fold, doc);\n-\n-    doc::ImplDoc {\n-        methods: do doc.methods.map |method| {\n-            let (desc, sections) = sectionalize(method.desc.clone());\n-\n-            doc::MethodDoc {\n-                desc: desc,\n-                sections: sections,\n-                .. (*method).clone()\n-            }\n-        },\n-        .. doc\n-    }\n-}\n-\n-fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n-\n-    /*!\n-     * Take a description of the form\n-     *\n-     *     General text\n-     *\n-     *     # Section header\n-     *\n-     *     Section text\n-     *\n-     *     # Section header\n-     *\n-     *     Section text\n-     *\n-     * and remove each header and accompanying text into section records.\n-     */\n-\n-    if desc.is_none() {\n-        return (None, ~[]);\n-    }\n-\n-    let mut new_desc = None::<~str>;\n-    let mut current_section: Option<doc::Section> = None;\n-    let mut sections = ~[];\n-\n-    for line in desc.get_ref().any_line_iter() {\n-        match parse_header(line) {\n-          Some(header) => {\n-            if current_section.is_some() {\n-                sections.push((*current_section.get_ref()).clone());\n-            }\n-            current_section = Some(doc::Section {\n-                header: header.to_owned(),\n-                body: ~\"\"\n-            });\n-          }\n-          None => {\n-            match current_section.clone() {\n-              Some(section) => {\n-                current_section = Some(doc::Section {\n-                    body: fmt!(\"%s\\n%s\", section.body, line),\n-                    .. section\n-                });\n-              }\n-              None => {\n-                new_desc = match new_desc.clone() {\n-                  Some(desc) => {\n-                    Some(fmt!(\"%s\\n%s\", desc, line))\n-                  }\n-                  None => {\n-                    Some(line.to_owned())\n-                  }\n-                };\n-              }\n-            }\n-          }\n-        }\n-    }\n-\n-    if current_section.is_some() {\n-        sections.push(current_section.unwrap());\n-    }\n-\n-    (new_desc, sections)\n-}\n-\n-fn parse_header<'a>(line: &'a str) -> Option<&'a str> {\n-    if line.starts_with(\"# \") {\n-        Some(line.slice_from(2))\n-    } else {\n-        None\n-    }\n-}\n-\n-\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use astsrv;\n-    use attr_pass;\n-    use doc;\n-    use extract;\n-    use prune_hidden_pass;\n-    use sectionalize_pass::run;\n-\n-    fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(source.clone()) |srv| {\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n-            let doc = (prune_hidden_pass::mk_pass().f)(srv.clone(), doc);\n-            run(srv.clone(), doc)\n-        }\n-    }\n-\n-    #[test]\n-    fn should_create_section_headers() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\"\\\n-              # Header\\n\\\n-              Body\\\"]\\\n-              mod a {\n-}\");\n-        assert!(doc.cratemod().mods()[0].item.sections[0].header.contains(\"Header\"));\n-    }\n-\n-    #[test]\n-    fn should_create_section_bodies() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\"\\\n-              # Header\\n\\\n-              Body\\\"]\\\n-              mod a {\n-}\");\n-        assert!(doc.cratemod().mods()[0].item.sections[0].body.contains(\"Body\"));\n-    }\n-\n-    #[test]\n-    fn should_not_create_sections_from_indented_headers() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\"\\n\\\n-              Text\\n             # Header\\n\\\n-              Body\\\"]\\\n-              mod a {\n-}\");\n-        assert!(doc.cratemod().mods()[0].item.sections.is_empty());\n-    }\n-\n-    #[test]\n-    fn should_remove_section_text_from_main_desc() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\"\\\n-              Description\\n\\n\\\n-              # Header\\n\\\n-              Body\\\"]\\\n-              mod a {\n-}\");\n-        assert!(!doc.cratemod().mods()[0].desc().unwrap().contains(\"Header\"));\n-        assert!(!doc.cratemod().mods()[0].desc().unwrap().contains(\"Body\"));\n-    }\n-\n-    #[test]\n-    fn should_eliminate_desc_if_it_is_just_whitespace() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\"\\\n-              # Header\\n\\\n-              Body\\\"]\\\n-              mod a {\n-}\");\n-        assert_eq!(doc.cratemod().mods()[0].desc(), None);\n-    }\n-\n-    #[test]\n-    fn should_sectionalize_trait_methods() {\n-        let doc = mk_doc(\n-            ~\"trait i {\n-#[doc = \\\"\\\n-              # Header\\n\\\n-              Body\\\"]\\\n-              fn a(); }\");\n-        assert_eq!(doc.cratemod().traits()[0].methods[0].sections.len(), 1u);\n-    }\n-\n-    #[test]\n-    fn should_sectionalize_impl_methods() {\n-        let doc = mk_doc(\n-            ~\"impl bool {\n-#[doc = \\\"\\\n-              # Header\\n\\\n-              Body\\\"]\\\n-              fn a() { } }\");\n-        assert_eq!(doc.cratemod().impls()[0].methods[0].sections.len(), 1u);\n-    }\n-}"}, {"sha": "8c7267e0b21c200f0f9d5ce30274a89f0ab01415", "filename": "src/librustdoc/sort_item_name_pass.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_name_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Sorts items by name\n-\n-use doc::ItemUtils;\n-use doc;\n-use pass::Pass;\n-use sort_pass;\n-\n-pub fn mk_pass() -> Pass {\n-    fn by_item_name(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n-        (*item1).name_() <= (*item2).name_()\n-    }\n-    sort_pass::mk_pass(~\"sort_item_name\", by_item_name)\n-}\n-\n-#[test]\n-fn test() {\n-    use astsrv;\n-    use extract;\n-\n-    let source = ~\"mod z { } fn y() { }\";\n-    do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv.clone(), ~\"\");\n-        let doc = (mk_pass().f)(srv.clone(), doc);\n-        // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().items[1].name_(), ~\"y\");\n-        assert_eq!(doc.cratemod().items[2].name_(), ~\"z\");\n-    }\n-}"}, {"sha": "ba8f37601fd567cb64660ccaf81a635f0c6d995d", "filename": "src/librustdoc/sort_item_type_pass.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_type_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Sorts items by type\n-\n-use doc;\n-use pass::Pass;\n-use sort_pass;\n-\n-pub fn mk_pass() -> Pass {\n-    fn by_score(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n-        fn score(item: &doc::ItemTag) -> int {\n-            match *item {\n-              doc::StaticTag(_) => 0,\n-              doc::TyTag(_) => 1,\n-              doc::EnumTag(_) => 2,\n-              doc::StructTag(_) => 3,\n-              doc::TraitTag(_) => 4,\n-              doc::ImplTag(_) => 5,\n-              doc::FnTag(_) => 6,\n-              doc::ModTag(_) => 7,\n-              doc::NmodTag(_) => 8\n-            }\n-        }\n-\n-        score(item1) <= score(item2)\n-    }\n-\n-    sort_pass::mk_pass(~\"sort_item_type\", by_score)\n-}\n-\n-#[test]\n-fn test() {\n-    use astsrv;\n-    use extract;\n-\n-    let source =\n-        ~\"mod imod { } \\\n-         static istatic: int = 0; \\\n-         fn ifn() { } \\\n-         enum ienum { ivar } \\\n-         trait itrait { fn a(); } \\\n-         impl int { fn a() { } } \\\n-         type itype = int; \\\n-         struct istruct { f: () }\";\n-    do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv.clone(), ~\"\");\n-        let doc = (mk_pass().f)(srv.clone(), doc);\n-        // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().items[0].name_(), ~\"istatic\");\n-        assert_eq!(doc.cratemod().items[1].name_(), ~\"itype\");\n-        assert_eq!(doc.cratemod().items[2].name_(), ~\"ienum\");\n-        assert_eq!(doc.cratemod().items[3].name_(), ~\"istruct\");\n-        assert_eq!(doc.cratemod().items[4].name_(), ~\"itrait\");\n-        assert_eq!(doc.cratemod().items[5].name_(), ~\"__extensions__\");\n-        assert_eq!(doc.cratemod().items[6].name_(), ~\"ifn\");\n-        // hidden __std_macros module fits here.\n-        assert_eq!(doc.cratemod().items[8].name_(), ~\"imod\");\n-    }\n-}"}, {"sha": "a6aa9480f3827145bdb487c2fdd47c5cad8b07fa", "filename": "src/librustdoc/sort_pass.rs", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,103 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A general sorting pass\n-\n-use astsrv;\n-use doc;\n-use fold::Fold;\n-use fold;\n-use pass::Pass;\n-\n-#[cfg(test)] use extract;\n-\n-use extra::sort;\n-use std::clone::Clone;\n-\n-pub type ItemLtEqOp = @fn(v1: &doc::ItemTag, v2:  &doc::ItemTag) -> bool;\n-\n-struct ItemLtEq {\n-    op: ItemLtEqOp,\n-}\n-\n-impl Clone for ItemLtEq {\n-    fn clone(&self) -> ItemLtEq {\n-        ItemLtEq {\n-            op: self.op,\n-        }\n-    }\n-}\n-\n-pub fn mk_pass(name: ~str, lteq: ItemLtEqOp) -> Pass {\n-    Pass {\n-        name: name.clone(),\n-        f: |srv, doc| run(srv, doc, ItemLtEq { op: lteq })\n-    }\n-}\n-\n-fn run(\n-    _srv: astsrv::Srv,\n-    doc: doc::Doc,\n-    lteq: ItemLtEq\n-) -> doc::Doc {\n-    let fold = Fold {\n-        fold_mod: fold_mod,\n-        .. fold::default_any_fold(lteq)\n-    };\n-    (fold.fold_doc)(&fold, doc)\n-}\n-\n-fn fold_mod(\n-    fold: &fold::Fold<ItemLtEq>,\n-    doc: doc::ModDoc\n-) -> doc::ModDoc {\n-    let doc = fold::default_any_fold_mod(fold, doc);\n-    doc::ModDoc {\n-        items: sort::merge_sort(doc.items, fold.ctxt.op),\n-        .. doc\n-    }\n-}\n-\n-#[test]\n-fn test() {\n-    fn name_lteq(item1: &doc::ItemTag, item2: &doc::ItemTag) -> bool {\n-        (*item1).name_() <= (*item2).name_()\n-    }\n-\n-    let source = ~\"mod z { mod y { } fn x() { } } mod w { }\";\n-    do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv.clone(), ~\"\");\n-        let doc = (mk_pass(~\"\", name_lteq).f)(srv.clone(), doc);\n-        // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().mods()[1].name_(), ~\"w\");\n-        assert_eq!(doc.cratemod().mods()[2].items[0].name_(), ~\"x\");\n-        assert_eq!(doc.cratemod().mods()[2].items[1].name_(), ~\"y\");\n-        assert_eq!(doc.cratemod().mods()[2].name_(), ~\"z\");\n-    }\n-}\n-\n-#[test]\n-fn should_be_stable() {\n-    fn always_eq(_item1: &doc::ItemTag, _item2: &doc::ItemTag) -> bool {\n-        true\n-    }\n-\n-    let source = ~\"mod a { mod b { } } mod c { mod d { } }\";\n-    do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv.clone(), ~\"\");\n-        let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n-        // hidden __std_macros module at the start.\n-        assert_eq!(doc.cratemod().mods()[1].items[0].name_(), ~\"b\");\n-        assert_eq!(doc.cratemod().mods()[2].items[0].name_(), ~\"d\");\n-        let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n-        assert_eq!(doc.cratemod().mods()[1].items[0].name_(), ~\"b\");\n-        assert_eq!(doc.cratemod().mods()[2].items[0].name_(), ~\"d\");\n-    }\n-}"}, {"sha": "41c0dcfb6d252b0fbf1f5d907319f99a1f063767", "filename": "src/librustdoc/text_pass.rs", "status": "removed", "additions": 0, "deletions": 313, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,313 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Generic pass for performing an operation on all descriptions\n-\n-\n-use astsrv;\n-use doc::ItemUtils;\n-use doc;\n-use fold::Fold;\n-use fold;\n-use pass::Pass;\n-\n-use std::cell::Cell;\n-\n-pub fn mk_pass(name: ~str, op: @fn(&str) -> ~str) -> Pass {\n-    let op = Cell::new(op);\n-    Pass {\n-        name: name.clone(),\n-        f: |srv: astsrv::Srv, doc: doc::Doc| -> doc::Doc {\n-            run(srv, doc, op.take())\n-        }\n-    }\n-}\n-\n-type Op = @fn(&str) -> ~str;\n-\n-struct WrappedOp {\n-    op: Op,\n-}\n-\n-impl Clone for WrappedOp {\n-    fn clone(&self) -> WrappedOp {\n-        WrappedOp {\n-            op: self.op,\n-        }\n-    }\n-}\n-\n-fn run(\n-    _srv: astsrv::Srv,\n-    doc: doc::Doc,\n-    op: Op\n-) -> doc::Doc {\n-    let op = WrappedOp {\n-        op: op\n-    };\n-    let fold = Fold {\n-        fold_item: fold_item,\n-        fold_enum: fold_enum,\n-        fold_trait: fold_trait,\n-        fold_impl: fold_impl,\n-        .. fold::default_any_fold(op)\n-    };\n-    (fold.fold_doc)(&fold, doc)\n-}\n-\n-fn maybe_apply_op(op: WrappedOp, s: &Option<~str>) -> Option<~str> {\n-    s.map(|s| (op.op)(*s) )\n-}\n-\n-fn fold_item(fold: &fold::Fold<WrappedOp>, doc: doc::ItemDoc)\n-             -> doc::ItemDoc {\n-    let doc = fold::default_seq_fold_item(fold, doc);\n-\n-    doc::ItemDoc {\n-        brief: maybe_apply_op(fold.ctxt, &doc.brief),\n-        desc: maybe_apply_op(fold.ctxt, &doc.desc),\n-        sections: apply_to_sections(fold.ctxt, doc.sections.clone()),\n-        .. doc\n-    }\n-}\n-\n-fn apply_to_sections(op: WrappedOp, sections: ~[doc::Section])\n-                     -> ~[doc::Section] {\n-    sections.map(|section| doc::Section {\n-        header: (op.op)(section.header.clone()),\n-        body: (op.op)(section.body.clone())\n-    })\n-}\n-\n-fn fold_enum(fold: &fold::Fold<WrappedOp>, doc: doc::EnumDoc)\n-             -> doc::EnumDoc {\n-    let doc = fold::default_seq_fold_enum(fold, doc);\n-    let fold_copy = *fold;\n-\n-    doc::EnumDoc {\n-        variants: do doc.variants.map |variant| {\n-            doc::VariantDoc {\n-                desc: maybe_apply_op(fold_copy.ctxt, &variant.desc),\n-                .. (*variant).clone()\n-            }\n-        },\n-        .. doc\n-    }\n-}\n-\n-fn fold_trait(fold: &fold::Fold<WrappedOp>, doc: doc::TraitDoc)\n-              -> doc::TraitDoc {\n-    let doc = fold::default_seq_fold_trait(fold, doc);\n-\n-    doc::TraitDoc {\n-        methods: apply_to_methods(fold.ctxt, doc.methods.clone()),\n-        .. doc\n-    }\n-}\n-\n-fn apply_to_methods(op: WrappedOp, docs: ~[doc::MethodDoc])\n-                    -> ~[doc::MethodDoc] {\n-    do docs.map |doc| {\n-        doc::MethodDoc {\n-            brief: maybe_apply_op(op, &doc.brief),\n-            desc: maybe_apply_op(op, &doc.desc),\n-            sections: apply_to_sections(op, doc.sections.clone()),\n-            .. (*doc).clone()\n-        }\n-    }\n-}\n-\n-fn fold_impl(fold: &fold::Fold<WrappedOp>, doc: doc::ImplDoc)\n-             -> doc::ImplDoc {\n-    let doc = fold::default_seq_fold_impl(fold, doc);\n-\n-    doc::ImplDoc {\n-        methods: apply_to_methods(fold.ctxt, doc.methods.clone()),\n-        .. doc\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use astsrv;\n-    use attr_pass;\n-    use desc_to_brief_pass;\n-    use doc;\n-    use extract;\n-    use sectionalize_pass;\n-    use text_pass::mk_pass;\n-\n-    fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(source.clone()) |srv| {\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n-            let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);\n-            let doc = (sectionalize_pass::mk_pass().f)(srv.clone(), doc);\n-            (mk_pass(~\"\", |s| s.trim().to_owned() ).f)(srv.clone(), doc)\n-        }\n-    }\n-\n-    #[test]\n-    fn should_execute_op_on_enum_brief() {\n-        let doc = mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-        assert_eq!(doc.cratemod().enums()[0].brief(), Some(~\"a\"));\n-    }\n-\n-    #[test]\n-    fn should_execute_op_on_enum_desc() {\n-        let doc = mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-        assert_eq!(doc.cratemod().enums()[0].desc(), Some(~\"a\"));\n-    }\n-\n-    #[test]\n-    fn should_execute_op_on_variant_desc() {\n-        let doc = mk_doc(~\"enum a { #[doc = \\\" a \\\"] b }\");\n-        assert!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"a\"));\n-    }\n-\n-    #[test]\n-    fn should_execute_op_on_trait_brief() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-        assert_eq!(doc.cratemod().traits()[0].brief(), Some(~\"a\"));\n-    }\n-\n-    #[test]\n-    fn should_execute_op_on_trait_desc() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-        assert_eq!(doc.cratemod().traits()[0].desc(), Some(~\"a\"));\n-    }\n-\n-    #[test]\n-    fn should_execute_op_on_trait_method_brief() {\n-        let doc = mk_doc(\n-            ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n-        assert!(doc.cratemod().traits()[0].methods[0].brief == Some(~\"a\"));\n-    }\n-\n-    #[test]\n-    fn should_execute_op_on_trait_method_desc() {\n-        let doc = mk_doc(\n-            ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n-        assert!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"a\"));\n-    }\n-\n-    #[test]\n-    fn should_execute_op_on_impl_brief() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-        assert_eq!(doc.cratemod().impls()[0].brief(), Some(~\"a\"));\n-    }\n-\n-    #[test]\n-    fn should_execute_op_on_impl_desc() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-        assert_eq!(doc.cratemod().impls()[0].desc(), Some(~\"a\"));\n-    }\n-\n-    #[test]\n-    fn should_execute_op_on_impl_method_brief() {\n-        let doc = mk_doc(\n-            ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n-        assert!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"a\"));\n-    }\n-\n-    #[test]\n-    fn should_execute_op_on_impl_method_desc() {\n-        let doc = mk_doc(\n-            ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n-        assert!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"a\"));\n-    }\n-\n-    #[test]\n-    fn should_execute_op_on_type_brief() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\" a \\\"] type t = int;\");\n-        assert_eq!(doc.cratemod().types()[0].brief(), Some(~\"a\"));\n-    }\n-\n-    #[test]\n-    fn should_execute_op_on_type_desc() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\" a \\\"] type t = int;\");\n-        assert_eq!(doc.cratemod().types()[0].desc(), Some(~\"a\"));\n-    }\n-\n-    #[test]\n-    fn should_execute_on_item_section_headers() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\"\\\n-              #    Header    \\n\\\n-              Body\\\"]\\\n-              fn a() { }\");\n-        assert!(doc.cratemod().fns()[0].sections()[0].header == ~\"Header\");\n-    }\n-\n-    #[test]\n-    fn should_execute_on_item_section_bodies() {\n-        let doc = mk_doc(\n-            ~\"#[doc = \\\"\\\n-              # Header\\n\\\n-              Body      \\\"]\\\n-              fn a() { }\");\n-        assert!(doc.cratemod().fns()[0].sections()[0].body == ~\"Body\");\n-    }\n-\n-    #[test]\n-    fn should_execute_on_trait_method_section_headers() {\n-        let doc = mk_doc(\n-            ~\"trait i {\n-#[doc = \\\"\\\n-              # Header    \\n\\\n-              Body\\\"]\\\n-              fn a(); }\");\n-        assert!(doc.cratemod().traits()[0].methods[0].sections[0].header\n-                == ~\"Header\");\n-    }\n-\n-    #[test]\n-    fn should_execute_on_trait_method_section_bodies() {\n-        let doc = mk_doc(\n-            ~\"trait i {\n-#[doc = \\\"\\\n-              # Header\\n\\\n-              Body     \\\"]\\\n-              fn a(); }\");\n-        assert!(doc.cratemod().traits()[0].methods[0].sections[0].body ==\n-                ~\"Body\");\n-    }\n-\n-    #[test]\n-    fn should_execute_on_impl_method_section_headers() {\n-        let doc = mk_doc(\n-            ~\"impl bool {\n-#[doc = \\\"\\\n-              # Header   \\n\\\n-              Body\\\"]\\\n-              fn a() { } }\");\n-        assert!(doc.cratemod().impls()[0].methods[0].sections[0].header\n-                == ~\"Header\");\n-    }\n-\n-    #[test]\n-    fn should_execute_on_impl_method_section_bodies() {\n-        let doc = mk_doc(\n-            ~\"impl bool {\n-#[doc = \\\"\\\n-              # Header\\n\\\n-              Body    \\\"]\\\n-              fn a() { } }\");\n-        assert!(doc.cratemod().impls()[0].methods[0].sections[0].body ==\n-                ~\"Body\");\n-    }\n-}"}, {"sha": "aaba0427b6245684efe097362fa31a96d4758a54", "filename": "src/librustdoc/trim_pass.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftrim_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Pulls a brief description out of a long description.\n-\n-If the first paragraph of a long description is short enough then it\n-is interpreted as the brief description.\n-*/\n-\n-use pass::Pass;\n-use text_pass;\n-\n-pub fn mk_pass() -> Pass {\n-    text_pass::mk_pass(~\"trim\", |s| s.trim().to_owned() )\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use astsrv;\n-    use attr_pass;\n-    use doc;\n-    use extract;\n-    use prune_hidden_pass;\n-    use trim_pass::mk_pass;\n-\n-    fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(source.clone()) |srv| {\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n-            let doc = (prune_hidden_pass::mk_pass().f)(srv.clone(), doc);\n-            (mk_pass().f)(srv.clone(), doc)\n-        }\n-    }\n-\n-    #[test]\n-    fn should_trim_text() {\n-        use std::option::Some;\n-\n-        let doc = mk_doc(~\"#[doc = \\\" desc \\\"] \\\n-                                 mod m {\n-}\");\n-        assert_eq!(doc.cratemod().mods()[0].desc(), Some(~\"desc\"));\n-    }\n-}"}, {"sha": "aa4407af76d2e2ba00bc21d220b6cc6d2d0ae893", "filename": "src/librustdoc/tystr_pass.rs", "status": "removed", "additions": 0, "deletions": 456, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,456 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Pulls type information out of the AST and attaches it to the document\n-\n-\n-use astsrv;\n-use doc::ItemUtils;\n-use doc;\n-use extract::to_str;\n-use extract;\n-use fold::Fold;\n-use fold;\n-use pass::Pass;\n-\n-use syntax::ast;\n-use syntax::print::pprust;\n-use syntax::parse::token;\n-use syntax::ast_map;\n-\n-pub fn mk_pass() -> Pass {\n-    Pass {\n-        name: ~\"tystr\",\n-        f: run\n-    }\n-}\n-\n-pub fn run(\n-    srv: astsrv::Srv,\n-    doc: doc::Doc\n-) -> doc::Doc {\n-    let fold = Fold {\n-        ctxt: srv.clone(),\n-        fold_fn: fold_fn,\n-        fold_static: fold_static,\n-        fold_enum: fold_enum,\n-        fold_trait: fold_trait,\n-        fold_impl: fold_impl,\n-        fold_type: fold_type,\n-        fold_struct: fold_struct,\n-        .. fold::default_any_fold(srv)\n-    };\n-    (fold.fold_doc)(&fold, doc)\n-}\n-\n-fn fold_fn(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::FnDoc\n-) -> doc::FnDoc {\n-\n-    let srv = fold.ctxt.clone();\n-\n-    doc::SimpleItemDoc {\n-        sig: get_fn_sig(srv, doc.id()),\n-        .. doc\n-    }\n-}\n-\n-fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n-    do astsrv::exec(srv) |ctxt| {\n-        match ctxt.ast_map.get_copy(&fn_id) {\n-            ast_map::node_item(@ast::item {\n-                ident: ident,\n-                node: ast::item_fn(ref decl, purity, _, ref tys, _), _\n-            }, _) => {\n-                Some(pprust::fun_to_str(decl,\n-                                        purity,\n-                                        ident,\n-                                        None,\n-                                        tys,\n-                                        token::get_ident_interner()))\n-            }\n-            ast_map::node_foreign_item(@ast::foreign_item {\n-                ident: ident,\n-                node: ast::foreign_item_fn(ref decl, ref tys), _\n-            }, _, _, _) => {\n-                Some(pprust::fun_to_str(decl,\n-                                        ast::impure_fn,\n-                                        ident,\n-                                        None,\n-                                        tys,\n-                                        token::get_ident_interner()))\n-            }\n-            _ => fail!(\"get_fn_sig: fn_id not bound to a fn item\")\n-        }\n-    }\n-}\n-\n-fn fold_static(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::StaticDoc\n-) -> doc::StaticDoc {\n-    let srv = fold.ctxt.clone();\n-\n-    doc::SimpleItemDoc {\n-        sig: Some({\n-            let doc = doc.clone();\n-            do astsrv::exec(srv) |ctxt| {\n-                match ctxt.ast_map.get_copy(&doc.id()) {\n-                    ast_map::node_item(@ast::item {\n-                        node: ast::item_static(ref ty, _, _), _\n-                    }, _) => {\n-                        pprust::ty_to_str(ty, extract::interner())\n-                    }\n-                    _ => fail!(\"fold_static: id not bound to a static item\")\n-                }\n-            }}),\n-        .. doc\n-    }\n-}\n-\n-fn fold_enum(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::EnumDoc\n-) -> doc::EnumDoc {\n-    let doc_id = doc.id();\n-    let srv = fold.ctxt.clone();\n-\n-    doc::EnumDoc {\n-        variants: do doc.variants.iter().map |variant| {\n-            let sig = {\n-                let variant = (*variant).clone();\n-                do astsrv::exec(srv.clone()) |ctxt| {\n-                    match ctxt.ast_map.get_copy(&doc_id) {\n-                        ast_map::node_item(@ast::item {\n-                            node: ast::item_enum(ref enum_definition, _), _\n-                        }, _) => {\n-                            let ast_variant =\n-                                (*do enum_definition.variants.iter().find |v| {\n-                                to_str(v.node.name) == variant.name\n-                            }.unwrap()).clone();\n-\n-                            pprust::variant_to_str(\n-                                &ast_variant, extract::interner())\n-                        }\n-                        _ => fail!(\"enum variant not bound to an enum item\")\n-                    }\n-                }\n-            };\n-\n-            doc::VariantDoc {\n-                sig: Some(sig),\n-                .. (*variant).clone()\n-            }\n-        }.collect(),\n-        .. doc\n-    }\n-}\n-\n-fn fold_trait(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::TraitDoc\n-) -> doc::TraitDoc {\n-    doc::TraitDoc {\n-        methods: merge_methods(fold.ctxt.clone(), doc.id(), doc.methods.clone()),\n-        .. doc\n-    }\n-}\n-\n-fn merge_methods(\n-    srv: astsrv::Srv,\n-    item_id: doc::AstId,\n-    docs: ~[doc::MethodDoc]\n-) -> ~[doc::MethodDoc] {\n-    do docs.iter().map |doc| {\n-        doc::MethodDoc {\n-            sig: get_method_sig(srv.clone(), item_id, doc.name.clone()),\n-            .. (*doc).clone()\n-        }\n-    }.collect()\n-}\n-\n-fn get_method_sig(\n-    srv: astsrv::Srv,\n-    item_id: doc::AstId,\n-    method_name: ~str\n-) -> Option<~str> {\n-    do astsrv::exec(srv) |ctxt| {\n-        match ctxt.ast_map.get_copy(&item_id) {\n-            ast_map::node_item(@ast::item {\n-                node: ast::item_trait(_, _, ref methods), _\n-            }, _) => {\n-                match methods.iter().find(|&method| {\n-                    match (*method).clone() {\n-                        ast::required(ty_m) => to_str(ty_m.ident) == method_name,\n-                        ast::provided(m) => to_str(m.ident) == method_name,\n-                    }\n-                }) {\n-                    Some(method) => {\n-                        match (*method).clone() {\n-                            ast::required(ty_m) => {\n-                                Some(pprust::fun_to_str(\n-                                    &ty_m.decl,\n-                                    ty_m.purity,\n-                                    ty_m.ident,\n-                                    Some(ty_m.explicit_self.node),\n-                                    &ty_m.generics,\n-                                    extract::interner()\n-                                ))\n-                            }\n-                            ast::provided(m) => {\n-                                Some(pprust::fun_to_str(\n-                                    &m.decl,\n-                                    m.purity,\n-                                    m.ident,\n-                                    Some(m.explicit_self.node),\n-                                    &m.generics,\n-                                    extract::interner()\n-                                ))\n-                            }\n-                        }\n-                    }\n-                    _ => fail!(\"method not found\")\n-                }\n-            }\n-            ast_map::node_item(@ast::item {\n-                node: ast::item_impl(_, _, _, ref methods), _\n-            }, _) => {\n-                match methods.iter().find(|method| {\n-                    to_str(method.ident) == method_name\n-                }) {\n-                    Some(method) => {\n-                        Some(pprust::fun_to_str(\n-                            &method.decl,\n-                            method.purity,\n-                            method.ident,\n-                            Some(method.explicit_self.node),\n-                            &method.generics,\n-                            extract::interner()\n-                        ))\n-                    }\n-                    None => fail!(\"method not found\")\n-                }\n-            }\n-            _ => fail!(\"get_method_sig: item ID not bound to trait or impl\")\n-        }\n-    }\n-}\n-\n-fn fold_impl(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::ImplDoc\n-) -> doc::ImplDoc {\n-\n-    let srv = fold.ctxt.clone();\n-\n-    let (bounds, trait_types, self_ty) = {\n-        let doc = doc.clone();\n-        do astsrv::exec(srv) |ctxt| {\n-            match ctxt.ast_map.get_copy(&doc.id()) {\n-                ast_map::node_item(@ast::item {\n-                    node: ast::item_impl(ref generics, ref opt_trait_type, ref self_ty, _), _\n-                }, _) => {\n-                    let bounds = pprust::generics_to_str(generics, extract::interner());\n-                    let bounds = if bounds.is_empty() { None } else { Some(bounds) };\n-                    let trait_types = do opt_trait_type.map_default(~[]) |p| {\n-                        ~[pprust::path_to_str(&p.path, extract::interner())]\n-                    };\n-                    (bounds,\n-                     trait_types,\n-                     Some(pprust::ty_to_str(\n-                         self_ty, extract::interner())))\n-                }\n-                _ => fail!(\"expected impl\")\n-            }\n-        }\n-    };\n-\n-    doc::ImplDoc {\n-        bounds_str: bounds,\n-        trait_types: trait_types,\n-        self_ty: self_ty,\n-        methods: merge_methods(fold.ctxt.clone(), doc.id(), doc.methods.clone()),\n-        .. doc\n-    }\n-}\n-\n-fn fold_type(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::TyDoc\n-) -> doc::TyDoc {\n-\n-    let srv = fold.ctxt.clone();\n-\n-    doc::SimpleItemDoc {\n-        sig: {\n-            let doc = doc.clone();\n-            do astsrv::exec(srv) |ctxt| {\n-                match ctxt.ast_map.get_copy(&doc.id()) {\n-                    ast_map::node_item(@ast::item {\n-                        ident: ident,\n-                        node: ast::item_ty(ref ty, ref params), _\n-                    }, _) => {\n-                        Some(fmt!(\n-                            \"type %s%s = %s\",\n-                            to_str(ident),\n-                            pprust::generics_to_str(params,\n-                                                    extract::interner()),\n-                            pprust::ty_to_str(ty, extract::interner())\n-                        ))\n-                    }\n-                    _ => fail!(\"expected type\")\n-                }\n-            }\n-        },\n-        .. doc\n-    }\n-}\n-\n-fn fold_struct(\n-    fold: &fold::Fold<astsrv::Srv>,\n-    doc: doc::StructDoc\n-) -> doc::StructDoc {\n-    let srv = fold.ctxt.clone();\n-\n-    doc::StructDoc {\n-        sig: {\n-            let doc = doc.clone();\n-            do astsrv::exec(srv) |ctxt| {\n-                match ctxt.ast_map.get_copy(&doc.id()) {\n-                    ast_map::node_item(item, _) => {\n-                        let item = strip_struct_extra_stuff(item);\n-                        Some(pprust::item_to_str(item,\n-                                                 extract::interner()))\n-                    }\n-                    _ => fail!(\"not an item\")\n-                }\n-            }\n-        },\n-        .. doc\n-    }\n-}\n-\n-/// Removes various things from the struct item definition that\n-/// shouldn't be displayed in the struct signature. Probably there\n-/// should be a simple pprust::struct_to_str function that does\n-/// what I actually want\n-fn strip_struct_extra_stuff(item: @ast::item) -> @ast::item {\n-    let node = match item.node.clone() {\n-        ast::item_struct(def, tys) => ast::item_struct(def, tys),\n-        _ => fail!(\"not a struct\")\n-    };\n-\n-    @ast::item {\n-        attrs: ~[], // Remove the attributes\n-        node: node,\n-        .. (*item).clone()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use astsrv;\n-    use doc;\n-    use extract;\n-    use tystr_pass::run;\n-\n-    fn mk_doc(source: ~str) -> doc::Doc {\n-        do astsrv::from_str(source.clone()) |srv| {\n-            let doc = extract::from_srv(srv.clone(), ~\"\");\n-            run(srv.clone(), doc)\n-        }\n-    }\n-\n-    #[test]\n-    fn should_add_fn_sig() {\n-        let doc = mk_doc(~\"fn a<T>() -> int { }\");\n-        assert!(doc.cratemod().fns()[0].sig == Some(~\"fn a<T>() -> int\"));\n-    }\n-\n-    #[test]\n-    fn should_add_foreign_fn_sig() {\n-        let doc = mk_doc(~\"extern { fn a<T>() -> int; }\");\n-        assert!(doc.cratemod().nmods()[0].fns[0].sig ==\n-                Some(~\"fn a<T>() -> int\"));\n-    }\n-\n-    #[test]\n-    fn should_add_static_types() {\n-        let doc = mk_doc(~\"static a: bool = true;\");\n-        assert!(doc.cratemod().statics()[0].sig == Some(~\"bool\"));\n-    }\n-\n-    #[test]\n-    fn should_add_variant_sigs() {\n-        let doc = mk_doc(~\"enum a { b(int) }\");\n-        assert!(doc.cratemod().enums()[0].variants[0].sig ==\n-                Some(~\"b(int)\"));\n-    }\n-\n-    #[test]\n-    fn should_add_trait_method_sigs() {\n-        let doc = mk_doc(~\"trait i { fn a<T>(&mut self) -> int; }\");\n-        assert!(doc.cratemod().traits()[0].methods[0].sig\n-                == Some(~\"fn a<T>(&mut self) -> int\"));\n-    }\n-\n-    #[test]\n-    fn should_add_impl_bounds() {\n-        let doc = mk_doc(~\"impl<T, U, V: Clone> Option<T, U, V> { }\");\n-        assert!(doc.cratemod().impls()[0].bounds_str == Some(~\"<T, U, V: Clone>\"));\n-    }\n-\n-    #[test]\n-    fn should_add_impl_trait_types() {\n-        let doc = mk_doc(~\"impl j for int { fn a<T>() { } }\");\n-        assert!(doc.cratemod().impls()[0].trait_types[0] == ~\"j\");\n-    }\n-\n-    #[test]\n-    fn should_not_add_impl_trait_types_if_none() {\n-        let doc = mk_doc(~\"impl int { fn a() { } }\");\n-        assert!(doc.cratemod().impls()[0].trait_types.len() == 0);\n-    }\n-\n-    #[test]\n-    fn should_add_impl_self_ty() {\n-        let doc = mk_doc(~\"impl int { fn a() { } }\");\n-        assert!(doc.cratemod().impls()[0].self_ty == Some(~\"int\"));\n-    }\n-\n-    #[test]\n-    fn should_add_impl_method_sigs() {\n-        let doc = mk_doc(~\"impl int { fn a<T>(&self) -> int { fail!() } }\");\n-        assert!(doc.cratemod().impls()[0].methods[0].sig\n-                == Some(~\"fn a<T>(&self) -> int\"));\n-    }\n-\n-    #[test]\n-    fn should_add_type_signatures() {\n-        let doc = mk_doc(~\"type t<T> = int;\");\n-        assert!(doc.cratemod().types()[0].sig == Some(~\"type t<T> = int\"));\n-    }\n-\n-    #[test]\n-    fn should_add_struct_defs() {\n-        let doc = mk_doc(~\"struct S { field: () }\");\n-        assert!(doc.cratemod().structs()[0].sig.unwrap().contains(\n-            \"struct S {\"));\n-    }\n-\n-    #[test]\n-    fn should_not_serialize_struct_attrs() {\n-        // All we care about are the fields\n-        let doc = mk_doc(~\"#[wut] struct S { field: () }\");\n-        assert!(!doc.cratemod().structs()[0].sig.unwrap().contains(\"wut\"));\n-    }\n-}"}, {"sha": "4c2464f8b34736d7f217d86abb8fb7cb59238d24", "filename": "src/librustdoc/unindent_pass.rs", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,134 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Removes the common level of indention from description strings. For\n-instance, if an entire doc comment is indented 8 spaces we want to\n-remove those 8 spaces from every line.\n-\n-The first line of a string is allowed to be intend less than\n-subsequent lines in the same paragraph in order to account for\n-instances where the string containing the doc comment is opened in the\n-middle of a line, and each of the following lines is indented.\n-*/\n-\n-\n-use std::num;\n-use std::uint;\n-use pass::Pass;\n-use text_pass;\n-\n-pub fn mk_pass() -> Pass {\n-    text_pass::mk_pass(~\"unindent\", unindent)\n-}\n-\n-fn unindent(s: &str) -> ~str {\n-    let lines = s.any_line_iter().collect::<~[&str]>();\n-    let mut saw_first_line = false;\n-    let mut saw_second_line = false;\n-    let min_indent = do lines.iter().fold(uint::max_value)\n-        |min_indent, line| {\n-\n-        // After we see the first non-whitespace line, look at\n-        // the line we have. If it is not whitespace, and therefore\n-        // part of the first paragraph, then ignore the indentation\n-        // level of the first line\n-        let ignore_previous_indents =\n-            saw_first_line &&\n-            !saw_second_line &&\n-            !line.is_whitespace();\n-\n-        let min_indent = if ignore_previous_indents {\n-            uint::max_value\n-        } else {\n-            min_indent\n-        };\n-\n-        if saw_first_line {\n-            saw_second_line = true;\n-        }\n-\n-        if line.is_whitespace() {\n-            min_indent\n-        } else {\n-            saw_first_line = true;\n-            let mut spaces = 0;\n-            do line.iter().all |char| {\n-                // Only comparing against space because I wouldn't\n-                // know what to do with mixed whitespace chars\n-                if char == ' ' {\n-                    spaces += 1;\n-                    true\n-                } else {\n-                    false\n-                }\n-            };\n-            num::min(min_indent, spaces)\n-        }\n-    };\n-\n-    match lines {\n-        [head, .. tail] => {\n-            let mut unindented = ~[ head.trim() ];\n-            unindented.push_all(do tail.map |&line| {\n-                if line.is_whitespace() {\n-                    line\n-                } else {\n-                    assert!(line.len() >= min_indent);\n-                    line.slice_from(min_indent)\n-                }\n-            });\n-            unindented.connect(\"\\n\")\n-        }\n-        [] => s.to_owned()\n-    }\n-}\n-\n-#[test]\n-fn should_unindent() {\n-    let s = ~\"    line1\\n    line2\";\n-    let r = unindent(s);\n-    assert_eq!(r, ~\"line1\\nline2\");\n-}\n-\n-#[test]\n-fn should_unindent_multiple_paragraphs() {\n-    let s = ~\"    line1\\n\\n    line2\";\n-    let r = unindent(s);\n-    assert_eq!(r, ~\"line1\\n\\nline2\");\n-}\n-\n-#[test]\n-fn should_leave_multiple_indent_levels() {\n-    // Line 2 is indented another level beyond the\n-    // base indentation and should be preserved\n-    let s = ~\"    line1\\n\\n        line2\";\n-    let r = unindent(s);\n-    assert_eq!(r, ~\"line1\\n\\n    line2\");\n-}\n-\n-#[test]\n-fn should_ignore_first_line_indent() {\n-    // Thi first line of the first paragraph may not be indented as\n-    // far due to the way the doc string was written:\n-    //\n-    // #[doc = \"Start way over here\n-    //          and continue here\"]\n-    let s = ~\"line1\\n    line2\";\n-    let r = unindent(s);\n-    assert_eq!(r, ~\"line1\\nline2\");\n-}\n-\n-#[test]\n-fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n-    let s = ~\"line1\\n\\n    line2\";\n-    let r = unindent(s);\n-    assert_eq!(r, ~\"line1\\n\\n    line2\");\n-}"}, {"sha": "14be80f0f15336e89fc85438f7726d237e268001", "filename": "src/librustdoc/visit_ast.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b24efd6f333620ed2559d70b32da8f6f9957385/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=7b24efd6f333620ed2559d70b32da8f6f9957385", "previous_filename": "src/rustdoc_ng/visit_ast.rs"}, {"sha": "62f94a1a44e985ed44164503a675c968be6b473f", "filename": "src/rustdoc_ng/.gitignore", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frustdoc_ng%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frustdoc_ng%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2F.gitignore?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,2 +0,0 @@\n-*.swp\n-main"}, {"sha": "ae74f4e37c3c351744386a7ecdc3dd536f98f1f2", "filename": "src/rustdoc_ng/fold.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frustdoc_ng%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frustdoc_ng%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Ffold.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,99 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std;\n-use clean::*;\n-use std::iter::Extendable;\n-\n-pub trait DocFolder {\n-    fn fold_item(&mut self, item: Item) -> Option<Item> {\n-        self.fold_item_recur(item)\n-    }\n-\n-    /// don't override!\n-    fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n-        use std::util::swap;\n-        let Item { attrs, name, source, visibility, id, inner } = item;\n-        let inner = inner;\n-        let c = |x| self.fold_item(x);\n-        let inner = match inner {\n-            StructItem(i) => {\n-                let mut i = i;\n-                let mut foo = ~[]; swap(&mut foo, &mut i.fields);\n-                i.fields.extend(&mut foo.move_iter().filter_map(|x| self.fold_item(x)));\n-                StructItem(i)\n-            },\n-            ModuleItem(i) => {\n-                ModuleItem(self.fold_mod(i))\n-            },\n-            EnumItem(i) => {\n-                let mut i = i;\n-                let mut foo = ~[]; swap(&mut foo, &mut i.variants);\n-                i.variants.extend(&mut foo.move_iter().filter_map(|x| self.fold_item(x)));\n-                EnumItem(i)\n-            },\n-            TraitItem(i) => {\n-                fn vtrm<T: DocFolder>(this: &mut T, trm: TraitMethod) -> Option<TraitMethod> {\n-                    match trm {\n-                        Required(it) => {\n-                            match this.fold_item(it) {\n-                                Some(x) => return Some(Required(x)),\n-                                None => return None,\n-                            }\n-                        },\n-                        Provided(it) => {\n-                            match this.fold_item(it) {\n-                                Some(x) => return Some(Provided(x)),\n-                                None => return None,\n-                            }\n-                        },\n-                    }\n-                }\n-                let mut i = i;\n-                let mut foo = ~[]; swap(&mut foo, &mut i.methods);\n-                i.methods.extend(&mut foo.move_iter().filter_map(|x| vtrm(self, x)));\n-                TraitItem(i)\n-            },\n-            ImplItem(i) => {\n-                let mut i = i;\n-                let mut foo = ~[]; swap(&mut foo, &mut i.methods);\n-                i.methods.extend(&mut foo.move_iter().filter_map(|x| self.fold_item(x)));\n-                ImplItem(i)\n-            },\n-            VariantItem(i) => {\n-                let i2 = i.clone(); // this clone is small\n-                match i.kind {\n-                    StructVariant(j) => {\n-                        let mut j = j;\n-                        let mut foo = ~[]; swap(&mut foo, &mut j.fields);\n-                        j.fields.extend(&mut foo.move_iter().filter_map(c));\n-                        VariantItem(Variant {kind: StructVariant(j), ..i2})\n-                    },\n-                    _ => VariantItem(i2)\n-                }\n-            },\n-            x => x\n-        };\n-\n-        Some(Item { attrs: attrs, name: name, source: source, inner: inner,\n-                    visibility: visibility, id: id })\n-    }\n-\n-    fn fold_mod(&mut self, m: Module) -> Module {\n-        Module { items: m.items.move_iter().filter_map(|i| self.fold_item(i)).collect() }\n-    }\n-\n-    fn fold_crate(&mut self, mut c: Crate) -> Crate {\n-        c.module = match std::util::replace(&mut c.module, None) {\n-            Some(module) => self.fold_item(module), None => None\n-        };\n-        return c;\n-    }\n-}"}, {"sha": "968e0fb07c0725a25ab436124c88ab80c6030643", "filename": "src/rustdoc_ng/rustdoc_ng.rs", "status": "removed", "additions": 0, "deletions": 211, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frustdoc_ng%2Frustdoc_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6a8ae96617081cbef81f0f336e706ad6d341e9/src%2Frustdoc_ng%2Frustdoc_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Frustdoc_ng.rs?ref=5f6a8ae96617081cbef81f0f336e706ad6d341e9", "patch": "@@ -1,211 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[link(name = \"rustdoc_ng\",\n-       vers = \"0.8\",\n-       uuid = \"8c6e4598-1596-4aa5-a24c-b811914bbbc6\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/rustdoc_ng\")];\n-\n-#[desc = \"rustdoc, the Rust documentation extractor\"];\n-#[license = \"MIT/ASL2\"];\n-#[crate_type = \"lib\"];\n-\n-extern mod syntax;\n-extern mod rustc;\n-extern mod extra;\n-\n-use extra::serialize::Encodable;\n-use extra::time;\n-use std::cell::Cell;\n-use std::rt::io;\n-use std::rt::io::Writer;\n-use std::rt::io::file::FileInfo;\n-\n-pub mod clean;\n-pub mod core;\n-pub mod doctree;\n-pub mod fold;\n-pub mod html {\n-    pub mod render;\n-    pub mod layout;\n-    pub mod markdown;\n-    pub mod format;\n-}\n-pub mod passes;\n-pub mod plugins;\n-pub mod visit_ast;\n-\n-pub static SCHEMA_VERSION: &'static str = \"0.8.0\";\n-\n-local_data_key!(pub ctxtkey: @core::DocContext)\n-\n-enum OutputFormat {\n-    HTML, JSON\n-}\n-\n-pub fn main() {\n-    main_args(std::os::args());\n-}\n-\n-pub fn main_args(args: &[~str]) {\n-    use extra::getopts::groups::*;\n-\n-    let opts = ~[\n-        optmulti(\"L\", \"library-path\", \"directory to add to crate search path\",\n-                 \"DIR\"),\n-        optmulti(\"\", \"plugin-path\", \"directory to load plugins from\", \"DIR\"),\n-        optmulti(\"\", \"passes\", \"space separated list of passes to also run\",\n-                 \"PASSES\"),\n-        optmulti(\"\", \"plugins\", \"space separated list of plugins to also load\",\n-                 \"PLUGINS\"),\n-        optflag(\"h\", \"help\", \"show this help message\"),\n-        optflag(\"\", \"nodefaults\", \"don't run the default passes\"),\n-        optopt(\"o\", \"output\", \"where to place the output\", \"PATH\"),\n-    ];\n-\n-    let matches = getopts(args.tail(), opts).unwrap();\n-\n-    let myusage = || {\n-        println(usage(format!(\"{} [options] [html|json] <crate>\", args[0]), opts));\n-    };\n-\n-    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        myusage();\n-        return;\n-    }\n-\n-    let (format, cratefile) = match matches.free.clone() {\n-        [~\"json\", crate] => (JSON, crate),\n-        [~\"html\", crate] => (HTML, crate),\n-        [s, _] => {\n-            println!(\"Unknown output format: `{}`\", s);\n-            myusage();\n-            exit(1);\n-        }\n-        [_, .._] => {\n-            println!(\"Expected exactly one crate to process\");\n-            myusage();\n-            exit(1);\n-        }\n-        _ => {\n-            println!(\"Expected an output format and then one crate\");\n-            myusage();\n-            exit(1);\n-        }\n-    };\n-\n-    // First, parse the crate and extract all relevant information.\n-    let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path(*s)));\n-    let cr = Cell::new(Path(cratefile));\n-    info2!(\"starting to run rustc\");\n-    let crate = do std::task::try {\n-        let cr = cr.take();\n-        core::run_core(libs.take(), &cr)\n-    }.unwrap();\n-    info2!(\"finished with rustc\");\n-\n-    // Process all of the crate attributes, extracting plugin metadata along\n-    // with the passes which we are supposed to run.\n-    let mut default_passes = !matches.opt_present(\"nodefaults\");\n-    let mut passes = matches.opt_strs(\"passes\");\n-    let mut plugins = matches.opt_strs(\"plugins\");\n-    match crate.module.get_ref().doc_list() {\n-        Some(nested) => {\n-            for inner in nested.iter() {\n-                match *inner {\n-                    clean::Word(~\"no_default_passes\") => {\n-                        default_passes = false;\n-                    }\n-                    clean::NameValue(~\"passes\", ref value) => {\n-                        for pass in value.word_iter() {\n-                            passes.push(pass.to_owned());\n-                        }\n-                    }\n-                    clean::NameValue(~\"plugins\", ref value) => {\n-                        for p in value.word_iter() {\n-                            plugins.push(p.to_owned());\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-        None => {}\n-    }\n-    if default_passes {\n-        passes.unshift(~\"collapse-docs\");\n-        passes.unshift(~\"unindent-comments\");\n-    }\n-\n-    // Load all plugins/passes into a PluginManager\n-    let mut pm = plugins::PluginManager::new(Path(\"/tmp/rustdoc_ng/plugins\"));\n-    for pass in passes.iter() {\n-        let plugin = match pass.as_slice() {\n-            \"strip-hidden\" => passes::strip_hidden,\n-            \"unindent-comments\" => passes::unindent_comments,\n-            \"collapse-docs\" => passes::collapse_docs,\n-            \"collapse-privacy\" => passes::collapse_privacy,\n-            s => { error!(\"unknown pass %s, skipping\", s); loop },\n-        };\n-        pm.add_plugin(plugin);\n-    }\n-    info2!(\"loading plugins...\");\n-    for pname in plugins.move_iter() {\n-        pm.load_plugin(pname);\n-    }\n-\n-    // Run everything!\n-    info2!(\"Executing passes/plugins\");\n-    let (crate, res) = pm.run_plugins(crate);\n-\n-    info2!(\"going to format\");\n-    let started = time::precise_time_ns();\n-    let output = matches.opt_str(\"o\").map(|s| Path(*s));\n-    match format {\n-        HTML => { html::render::run(crate, output.unwrap_or(Path(\"doc\"))) }\n-        JSON => { jsonify(crate, res, output.unwrap_or(Path(\"doc.json\"))) }\n-    }\n-    let ended = time::precise_time_ns();\n-    info2!(\"Took {:.03f}s\", (ended as f64 - started as f64) / 1000000000f64);\n-}\n-\n-fn jsonify(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n-    // {\n-    //   \"schema\": version,\n-    //   \"crate\": { parsed crate ... },\n-    //   \"plugins\": { output of plugins ... }\n-    // }\n-    let mut json = ~extra::treemap::TreeMap::new();\n-    json.insert(~\"schema\", extra::json::String(SCHEMA_VERSION.to_owned()));\n-    let plugins_json = ~res.move_iter().filter_map(|opt| opt).collect();\n-\n-    // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n-    // straight to the Rust JSON representation.\n-    let crate_json_str = do std::io::with_str_writer |w| {\n-        crate.encode(&mut extra::json::Encoder(w));\n-    };\n-    let crate_json = match extra::json::from_str(crate_json_str) {\n-        Ok(j) => j,\n-        Err(_) => fail!(\"Rust generated JSON is invalid??\")\n-    };\n-\n-    json.insert(~\"crate\", crate_json);\n-    json.insert(~\"plugins\", extra::json::Object(plugins_json));\n-\n-    let mut file = dst.open_writer(io::Create).unwrap();\n-    let output = extra::json::Object(json).to_str();\n-    file.write(output.as_bytes());\n-}\n-\n-fn exit(status: int) -> ! {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    use std::libc;\n-    unsafe { libc::exit(status as libc::c_int) }\n-}"}]}