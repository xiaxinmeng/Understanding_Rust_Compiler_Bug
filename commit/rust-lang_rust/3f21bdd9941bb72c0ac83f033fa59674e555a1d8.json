{"sha": "3f21bdd9941bb72c0ac83f033fa59674e555a1d8", "node_id": "C_kwDOAAsO6NoAKDNmMjFiZGQ5OTQxYmI3MmMwYWM4M2YwMzNmYTU5Njc0ZTU1NWExZDg", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-13T12:53:48Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-29T19:17:17Z"}, "message": "rustdoc: Simplify modifications of effective visibility table", "tree": {"sha": "effb2f166e7ff5298457e9a7a57a824b1e4e9f25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/effb2f166e7ff5298457e9a7a57a824b1e4e9f25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f21bdd9941bb72c0ac83f033fa59674e555a1d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f21bdd9941bb72c0ac83f033fa59674e555a1d8", "html_url": "https://github.com/rust-lang/rust/commit/3f21bdd9941bb72c0ac83f033fa59674e555a1d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f21bdd9941bb72c0ac83f033fa59674e555a1d8/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68c836a904e5a421712db311421c5266f9ce71c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/68c836a904e5a421712db311421c5266f9ce71c0", "html_url": "https://github.com/rust-lang/rust/commit/68c836a904e5a421712db311421c5266f9ce71c0"}], "stats": {"total": 111, "additions": 32, "deletions": 79}, "files": [{"sha": "8f3e29a31a0728ce9bb1fb3cd090db8c04cd37c4", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f21bdd9941bb72c0ac83f033fa59674e555a1d8/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f21bdd9941bb72c0ac83f033fa59674e555a1d8/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=3f21bdd9941bb72c0ac83f033fa59674e555a1d8", "patch": "@@ -8,7 +8,6 @@ use crate::clean::{\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n-use crate::visit_lib::LibEmbargoVisitor;\n \n use rustc_ast as ast;\n use rustc_ast::tokenstream::TokenTree;\n@@ -32,7 +31,7 @@ pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n \n     for &cnum in cx.tcx.crates(()) {\n         // Analyze doc-reachability for extern items\n-        LibEmbargoVisitor::new(cx).visit_lib(cnum);\n+        crate::visit_lib::lib_embargo_visit_item(cx, cnum.as_def_id());\n     }\n \n     // Clean the crate, translating the entire librustc_ast AST to one that is"}, {"sha": "7960ab251b79cd0b8d0ec2bcbec46f56594b10dc", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3f21bdd9941bb72c0ac83f033fa59674e555a1d8/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f21bdd9941bb72c0ac83f033fa59674e555a1d8/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=3f21bdd9941bb72c0ac83f033fa59674e555a1d8", "patch": "@@ -7,15 +7,14 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n use rustc_hir::CRATE_HIR_ID;\n-use rustc_middle::middle::privacy::Level;\n-use rustc_middle::ty::{TyCtxt, Visibility};\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n use std::mem;\n \n-use crate::clean::{self, cfg::Cfg, AttributesExt, NestedAttributesExt};\n+use crate::clean::{cfg::Cfg, AttributesExt, NestedAttributesExt};\n use crate::core;\n \n /// This module is used to store stuff from Rust's AST in a more convenient\n@@ -221,23 +220,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront).\n         if !res_did.is_local() && !is_no_inline {\n-            let attrs = clean::inline::load_attrs(self.cx, res_did);\n-            let self_is_hidden = attrs.lists(sym::doc).has_word(sym::hidden);\n-            if !self_is_hidden {\n-                if let Res::Def(kind, did) = res {\n-                    if kind == DefKind::Mod {\n-                        crate::visit_lib::LibEmbargoVisitor::new(self.cx).visit_mod(did)\n-                    } else {\n-                        // All items need to be handled here in case someone wishes to link\n-                        // to them with intra-doc links\n-                        self.cx.cache.effective_visibilities.set_public_at_level(\n-                            did,\n-                            || Visibility::Restricted(CRATE_DEF_ID),\n-                            Level::Direct,\n-                        );\n-                    }\n-                }\n-            }\n+            crate::visit_lib::lib_embargo_visit_item(self.cx, res_did);\n             return false;\n         }\n "}, {"sha": "04a3114556e76be2096674832d62171b4be7a727", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 28, "deletions": 57, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3f21bdd9941bb72c0ac83f033fa59674e555a1d8/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f21bdd9941bb72c0ac83f033fa59674e555a1d8/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=3f21bdd9941bb72c0ac83f033fa59674e555a1d8", "patch": "@@ -1,86 +1,57 @@\n+use crate::core::DocContext;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_ID};\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n use rustc_middle::ty::{TyCtxt, Visibility};\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n+pub(crate) fn lib_embargo_visit_item(cx: &mut DocContext<'_>, def_id: DefId) {\n+    assert!(!def_id.is_local());\n+    LibEmbargoVisitor {\n+        tcx: cx.tcx,\n+        effective_visibilities: &mut cx.cache.effective_visibilities,\n+        visited_mods: FxHashSet::default(),\n+    }\n+    .visit_item(def_id)\n+}\n+\n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n-pub(crate) struct LibEmbargoVisitor<'a, 'tcx> {\n+struct LibEmbargoVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     // Effective visibilities for reachable nodes\n     effective_visibilities: &'a mut EffectiveVisibilities<DefId>,\n-    // Previous level, None means unreachable\n-    prev_level: Option<Level>,\n     // Keeps track of already visited modules, in case a module re-exports its parent\n     visited_mods: FxHashSet<DefId>,\n }\n \n-impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n-    pub(crate) fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n-        LibEmbargoVisitor {\n-            tcx: cx.tcx,\n-            effective_visibilities: &mut cx.cache.effective_visibilities,\n-            prev_level: Some(Level::Direct),\n-            visited_mods: FxHashSet::default(),\n-        }\n-    }\n-\n-    pub(crate) fn visit_lib(&mut self, cnum: CrateNum) {\n-        let did = cnum.as_def_id();\n-        self.update(did, Some(Level::Direct));\n-        self.visit_mod(did);\n-    }\n-\n-    // Updates node level and returns the updated level\n-    fn update(&mut self, did: DefId, level: Option<Level>) -> Option<Level> {\n-        let is_hidden = self.tcx.is_doc_hidden(did);\n-\n-        let old_level = self.effective_visibilities.public_at_level(did);\n-        // Visibility levels can only grow\n-        if level > old_level && !is_hidden {\n-            self.effective_visibilities.set_public_at_level(\n-                did,\n-                || Visibility::Restricted(CRATE_DEF_ID),\n-                level.unwrap(),\n-            );\n-            level\n-        } else {\n-            old_level\n-        }\n-    }\n-\n-    pub(crate) fn visit_mod(&mut self, def_id: DefId) {\n+impl LibEmbargoVisitor<'_, '_> {\n+    fn visit_mod(&mut self, def_id: DefId) {\n         if !self.visited_mods.insert(def_id) {\n             return;\n         }\n \n         for item in self.tcx.module_children(def_id).iter() {\n             if let Some(def_id) = item.res.opt_def_id() {\n-                if self.tcx.def_key(def_id).parent.map_or(false, |d| d == def_id.index)\n-                    || item.vis.is_public()\n-                {\n-                    self.visit_item(item.res);\n+                if item.vis.is_public() {\n+                    self.visit_item(def_id);\n                 }\n             }\n         }\n     }\n \n-    fn visit_item(&mut self, res: Res<!>) {\n-        let def_id = res.def_id();\n-        let vis = self.tcx.visibility(def_id);\n-        let inherited_item_level = if vis.is_public() { self.prev_level } else { None };\n-\n-        let item_level = self.update(def_id, inherited_item_level);\n-\n-        if let Res::Def(DefKind::Mod, _) = res {\n-            let orig_level = self.prev_level;\n-\n-            self.prev_level = item_level;\n-            self.visit_mod(def_id);\n-            self.prev_level = orig_level;\n+    fn visit_item(&mut self, def_id: DefId) {\n+        if !self.tcx.is_doc_hidden(def_id) {\n+            self.effective_visibilities.set_public_at_level(\n+                def_id,\n+                || Visibility::Restricted(CRATE_DEF_ID),\n+                Level::Direct,\n+            );\n+            if self.tcx.def_kind(def_id) == DefKind::Mod {\n+                self.visit_mod(def_id);\n+            }\n         }\n     }\n }"}]}