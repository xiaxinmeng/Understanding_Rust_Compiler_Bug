{"sha": "813a55d89135efb716dd80e96453a091a7cfc631", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxM2E1NWQ4OTEzNWVmYjcxNmRkODBlOTY0NTNhMDkxYTdjZmM2MzE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-31T11:38:22Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-31T12:02:46Z"}, "message": "Move walk_ty to stack closure", "tree": {"sha": "86e4383759d6697f8f7b004fcd8ba8f1a1da97db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86e4383759d6697f8f7b004fcd8ba8f1a1da97db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/813a55d89135efb716dd80e96453a091a7cfc631", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/813a55d89135efb716dd80e96453a091a7cfc631", "html_url": "https://github.com/rust-lang/rust/commit/813a55d89135efb716dd80e96453a091a7cfc631", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/813a55d89135efb716dd80e96453a091a7cfc631/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25d60172d6a66b2a620a228ce6642640e9faa517", "url": "https://api.github.com/repos/rust-lang/rust/commits/25d60172d6a66b2a620a228ce6642640e9faa517", "html_url": "https://github.com/rust-lang/rust/commit/25d60172d6a66b2a620a228ce6642640e9faa517"}], "stats": {"total": 88, "additions": 32, "deletions": 56}, "files": [{"sha": "85c23f4937c7066ac7fe47cb0cb4e9c17f357488", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/813a55d89135efb716dd80e96453a091a7cfc631/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/813a55d89135efb716dd80e96453a091a7cfc631/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=813a55d89135efb716dd80e96453a091a7cfc631", "patch": "@@ -861,28 +861,19 @@ fn field_of_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool, field: int) ->\n // constructing derived tydescs.\n fn linearize_ty_params(cx: @block_ctxt, t: ty::t) ->\n    {params: [uint], descs: [ValueRef]} {\n-    let param_vals: [ValueRef] = [];\n-    let param_defs: [uint] = [];\n-    type rr =\n-        {cx: @block_ctxt, mutable vals: [ValueRef], mutable defs: [uint]};\n-\n-    fn linearizer(r: @rr, t: ty::t) {\n-        alt ty::struct(bcx_tcx(r.cx), t) {\n+    let param_vals = [], param_defs = [];\n+    ty::walk_ty(bcx_tcx(cx), t) {|t|\n+        alt ty::struct(bcx_tcx(cx), t) {\n           ty::ty_param(pid, _) {\n-            let seen: bool = false;\n-            for d: uint in r.defs { if d == pid { seen = true; } }\n-            if !seen {\n-                r.vals += [r.cx.fcx.lltyparams[pid].desc];\n-                r.defs += [pid];\n+            if !vec::any(param_defs, {|d| d == pid}) {\n+                param_vals += [cx.fcx.lltyparams[pid].desc];\n+                param_defs += [pid];\n             }\n           }\n           _ { }\n         }\n     }\n-    let x = @{cx: cx, mutable vals: param_vals, mutable defs: param_defs};\n-    let f = bind linearizer(x, _);\n-    ty::walk_ty(bcx_tcx(cx), f, t);\n-    ret {params: x.defs, descs: x.vals};\n+    ret {params: param_defs, descs: param_vals};\n }\n \n fn trans_stack_local_derived_tydesc(cx: @block_ctxt, llsz: ValueRef,"}, {"sha": "57031e7c6dae83acd7a190fa9201de32dedc6f7c", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 40, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/813a55d89135efb716dd80e96453a091a7cfc631/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/813a55d89135efb716dd80e96453a091a7cfc631/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=813a55d89135efb716dd80e96453a091a7cfc631", "patch": "@@ -655,39 +655,31 @@ pure fn ty_name(cx: ctxt, typ: t) -> option::t<@str> {\n     }\n }\n \n-\n-// Type folds\n-type ty_walk = fn@(t);\n-\n-fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n+fn walk_ty(cx: ctxt, ty: t, f: fn(t)) {\n     alt struct(cx, ty) {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_str | ty_send_type | ty_type | ty_native(_) |\n-      ty_opaque_closure_ptr(_) {\n-        /* no-op */\n-      }\n-      ty_box(tm) | ty_vec(tm) | ty_ptr(tm) { walk_ty(cx, walker, tm.ty); }\n+      ty_opaque_closure_ptr(_) | ty_var(_) | ty_param(_, _) {}\n+      ty_box(tm) | ty_vec(tm) | ty_ptr(tm) { walk_ty(cx, tm.ty, f); }\n       ty_enum(_, subtys) | ty_iface(_, subtys) {\n-        for subty: t in subtys { walk_ty(cx, walker, subty); }\n+        for subty: t in subtys { walk_ty(cx, subty, f); }\n       }\n       ty_rec(fields) {\n-        for fl: field in fields { walk_ty(cx, walker, fl.mt.ty); }\n+        for fl: field in fields { walk_ty(cx, fl.mt.ty, f); }\n       }\n-      ty_tup(ts) { for tt in ts { walk_ty(cx, walker, tt); } }\n-      ty_fn(f) {\n-        for a: arg in f.inputs { walk_ty(cx, walker, a.ty); }\n-        walk_ty(cx, walker, f.output);\n+      ty_tup(ts) { for tt in ts { walk_ty(cx, tt, f); } }\n+      ty_fn(ft) {\n+        for a: arg in ft.inputs { walk_ty(cx, a.ty, f); }\n+        walk_ty(cx, ft.output, f);\n       }\n       ty_res(_, sub, tps) {\n-        walk_ty(cx, walker, sub);\n-        for tp: t in tps { walk_ty(cx, walker, tp); }\n+        walk_ty(cx, sub, f);\n+        for tp: t in tps { walk_ty(cx, tp, f); }\n       }\n-      ty_constr(sub, _) { walk_ty(cx, walker, sub); }\n-      ty_var(_) {/* no-op */ }\n-      ty_param(_, _) {/* no-op */ }\n-      ty_uniq(tm) { walk_ty(cx, walker, tm.ty); }\n+      ty_constr(sub, _) { walk_ty(cx, sub, f); }\n+      ty_uniq(tm) { walk_ty(cx, tm.ty, f); }\n     }\n-    walker(ty);\n+    f(ty);\n }\n \n enum fold_mode {\n@@ -1239,14 +1231,11 @@ fn type_param(cx: ctxt, ty: t) -> option::t<uint> {\n // Returns a vec of all the type variables\n // occurring in t. It may contain duplicates.\n fn vars_in_type(cx: ctxt, ty: t) -> [int] {\n-    fn collect_var(cx: ctxt, vars: @mutable [int], ty: t) {\n-        alt struct(cx, ty) { ty_var(v) { *vars += [v]; } _ { } }\n+    let rslt = [];\n+    walk_ty(cx, ty) {|ty|\n+        alt struct(cx, ty) { ty_var(v) { rslt += [v]; } _ { } }\n     }\n-    let rslt: @mutable [int] = @mutable [];\n-    walk_ty(cx, bind collect_var(cx, rslt, _), ty);\n-    // Works because of a \"convenient\" bug that lets us\n-    // return a mutable vec as if it's immutable\n-    ret *rslt;\n+    rslt\n }\n \n fn type_autoderef(cx: ctxt, t: ty::t) -> ty::t {\n@@ -1450,22 +1439,18 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n \n // Returns the number of distinct type parameters in the given type.\n fn count_ty_params(cx: ctxt, ty: t) -> uint {\n-    fn counter(cx: ctxt, param_indices: @mutable [uint], ty: t) {\n-        alt struct(cx, ty) {\n+    let param_indices = [];\n+    walk_ty(cx, ty) {|t|\n+        alt struct(cx, t) {\n           ty_param(param_idx, _) {\n-            let seen = false;\n-            for other_param_idx: uint in *param_indices {\n-                if param_idx == other_param_idx { seen = true; }\n+            if !vec::any(param_indices, {|i| i == param_idx}) {\n+                param_indices += [param_idx];\n             }\n-            if !seen { *param_indices += [param_idx]; }\n           }\n-          _ {/* fall through */ }\n+          _ {}\n         }\n     }\n-    let param_indices: @mutable [uint] = @mutable [];\n-    let f = bind counter(cx, param_indices, _);\n-    walk_ty(cx, f, ty);\n-    ret vec::len::<uint>(*param_indices);\n+    vec::len(param_indices)\n }\n \n fn type_contains_vars(cx: ctxt, typ: t) -> bool {"}]}