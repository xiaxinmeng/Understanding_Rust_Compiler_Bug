{"sha": "81970852e172c04322cbf8ba23effabeb491c83c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxOTcwODUyZTE3MmMwNDMyMmNiZjhiYTIzZWZmYWJlYjQ5MWM4M2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-29T07:50:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-29T07:50:16Z"}, "message": "Auto merge of #61305 - Centril:rollup-t39m00m, r=Centril\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #58975 (Implement `iter::Sum` and `iter::Product` for `Option`)\n - #60542 (Add Step::sub_usize)\n - #60555 (Implement nth_back for RChunks(Exact)(Mut))\n - #60766 (Weak::into_raw)\n - #61048 (Feature/nth back chunks)\n - #61191 (librustc_errors: Move annotation collection to own impl)\n - #61235 (Stabilize bufreader_buffer feature)\n - #61249 (Rename Place::local to Place::local_or_deref_local)\n - #61291 (Avoid unneeded bug!() call)\n - #61294 (Rename `TraitOrImpl` to `Assoc` and `trait_or_impl` to `assoc`.)\n - #61297 (Remove LLVM instruction stats and other (obsolete) codegen stats.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d5f598d83a91b16339568e1100f0d3aaa131c76c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5f598d83a91b16339568e1100f0d3aaa131c76c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81970852e172c04322cbf8ba23effabeb491c83c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81970852e172c04322cbf8ba23effabeb491c83c", "html_url": "https://github.com/rust-lang/rust/commit/81970852e172c04322cbf8ba23effabeb491c83c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81970852e172c04322cbf8ba23effabeb491c83c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "html_url": "https://github.com/rust-lang/rust/commit/4b9d80325a65b0375eea526409a0f3aaf1cbc23c"}, {"sha": "907f4fd4aec93addd2e00f6c1d8f4b00157e920f", "url": "https://api.github.com/repos/rust-lang/rust/commits/907f4fd4aec93addd2e00f6c1d8f4b00157e920f", "html_url": "https://github.com/rust-lang/rust/commit/907f4fd4aec93addd2e00f6c1d8f4b00157e920f"}], "stats": {"total": 1403, "additions": 900, "deletions": 503}, "files": [{"sha": "1f357a719bb43880725e51309349591dd1777156", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 156, "deletions": 6, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -239,7 +239,7 @@ use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::marker::{self, Unpin, Unsize, PhantomData};\n-use core::mem::{self, align_of_val, forget, size_of_val};\n+use core::mem::{self, align_of, align_of_val, forget, size_of_val};\n use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -416,11 +416,7 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // Align the unsized value to the end of the RcBox.\n-        // Because it is ?Sized, it will always be the last field in memory.\n-        let align = align_of_val(&*ptr);\n-        let layout = Layout::new::<RcBox<()>>();\n-        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+        let offset = data_offset(ptr);\n \n         // Reverse the offset to find the original RcBox.\n         let fake_ptr = ptr as *mut RcBox<T>;\n@@ -1262,6 +1258,143 @@ impl<T> Weak<T> {\n             ptr: NonNull::new(usize::MAX as *mut RcBox<T>).expect(\"MAX is not 0\"),\n         }\n     }\n+\n+    /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n+    ///\n+    /// It is up to the caller to ensure that the object is still alive when accessing it through\n+    /// the pointer.\n+    ///\n+    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    /// use std::ptr;\n+    ///\n+    /// let strong = Rc::new(42);\n+    /// let weak = Rc::downgrade(&strong);\n+    /// // Both point to the same object\n+    /// assert!(ptr::eq(&*strong, Weak::as_raw(&weak)));\n+    /// // The strong here keeps it alive, so we can still access the object.\n+    /// assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    ///\n+    /// drop(strong);\n+    /// // But not any more. We can do Weak::as_raw(&weak), but accessing the pointer would lead to\n+    /// // undefined behaviour.\n+    /// // assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_raw(this: &Self) -> *const T {\n+        match this.inner() {\n+            None => ptr::null(),\n+            Some(inner) => {\n+                let offset = data_offset_sized::<T>();\n+                let ptr = inner as *const RcBox<T>;\n+                // Note: while the pointer we create may already point to dropped value, the\n+                // allocation still lives (it must hold the weak point as long as we are alive).\n+                // Therefore, the offset is OK to do, it won't get out of the allocation.\n+                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n+                ptr as *const T\n+            }\n+        }\n+    }\n+\n+    /// Consumes the `Weak<T>` and turns it into a raw pointer.\n+    ///\n+    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n+    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    ///\n+    /// The same restrictions of accessing the target of the pointer as with\n+    /// [`as_raw`] apply.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let strong = Rc::new(42);\n+    /// let weak = Rc::downgrade(&strong);\n+    /// let raw = Weak::into_raw(weak);\n+    ///\n+    /// assert_eq!(1, Rc::weak_count(&strong));\n+    /// assert_eq!(42, unsafe { *raw });\n+    ///\n+    /// drop(unsafe { Weak::from_raw(raw) });\n+    /// assert_eq!(0, Rc::weak_count(&strong));\n+    /// ```\n+    ///\n+    /// [`from_raw`]: struct.Weak.html#method.from_raw\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn into_raw(this: Self) -> *const T {\n+        let result = Self::as_raw(&this);\n+        mem::forget(this);\n+        result\n+    }\n+\n+    /// Converts a raw pointer previously created by [`into_raw`] back into `Weak<T>`.\n+    ///\n+    /// This can be used to safely get a strong reference (by calling [`upgrade`]\n+    /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n+    ///\n+    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n+    /// returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n+    /// is or *was* managed by an [`Rc`] and the weak count of that [`Rc`] must not have reached\n+    /// 0. It is allowed for the strong count to be 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let strong = Rc::new(42);\n+    ///\n+    /// let raw_1 = Weak::into_raw(Rc::downgrade(&strong));\n+    /// let raw_2 = Weak::into_raw(Rc::downgrade(&strong));\n+    ///\n+    /// assert_eq!(2, Rc::weak_count(&strong));\n+    ///\n+    /// assert_eq!(42, *Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n+    /// assert_eq!(1, Rc::weak_count(&strong));\n+    ///\n+    /// drop(strong);\n+    ///\n+    /// // Decrement the last weak count.\n+    /// assert!(Weak::upgrade(&unsafe { Weak::from_raw(raw_2) }).is_none());\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`into_raw`]: struct.Weak.html#method.into_raw\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`Rc`]: struct.Rc.html\n+    /// [`Weak`]: struct.Weak.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub unsafe fn from_raw(ptr: *const T) -> Self {\n+        if ptr.is_null() {\n+            Self::new()\n+        } else {\n+            // See Rc::from_raw for details\n+            let offset = data_offset(ptr);\n+            let fake_ptr = ptr as *mut RcBox<T>;\n+            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            Weak {\n+                ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\"),\n+            }\n+        }\n+    }\n }\n \n pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n@@ -2007,3 +2140,20 @@ impl<T: ?Sized> AsRef<T> for Rc<T> {\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Rc<T> { }\n+\n+unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n+    // Align the unsized value to the end of the RcBox.\n+    // Because it is ?Sized, it will always be the last field in memory.\n+    let align = align_of_val(&*ptr);\n+    let layout = Layout::new::<RcBox<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}\n+\n+/// Computes the offset of the data field within ArcInner.\n+///\n+/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n+fn data_offset_sized<T>() -> isize {\n+    let align = align_of::<T>();\n+    let layout = Layout::new::<RcBox<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}"}, {"sha": "70865656c510ee7b988d28ad86254a2e6b643f73", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 158, "deletions": 6, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -13,7 +13,7 @@ use core::borrow;\n use core::fmt;\n use core::cmp::{self, Ordering};\n use core::intrinsics::abort;\n-use core::mem::{self, align_of_val, size_of_val};\n+use core::mem::{self, align_of, align_of_val, size_of_val};\n use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -397,11 +397,7 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // Align the unsized value to the end of the ArcInner.\n-        // Because it is ?Sized, it will always be the last field in memory.\n-        let align = align_of_val(&*ptr);\n-        let layout = Layout::new::<ArcInner<()>>();\n-        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+        let offset = data_offset(ptr);\n \n         // Reverse the offset to find the original ArcInner.\n         let fake_ptr = ptr as *mut ArcInner<T>;\n@@ -1071,6 +1067,144 @@ impl<T> Weak<T> {\n             ptr: NonNull::new(usize::MAX as *mut ArcInner<T>).expect(\"MAX is not 0\"),\n         }\n     }\n+\n+    /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n+    ///\n+    /// It is up to the caller to ensure that the object is still alive when accessing it through\n+    /// the pointer.\n+    ///\n+    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    /// use std::ptr;\n+    ///\n+    /// let strong = Arc::new(42);\n+    /// let weak = Arc::downgrade(&strong);\n+    /// // Both point to the same object\n+    /// assert!(ptr::eq(&*strong, Weak::as_raw(&weak)));\n+    /// // The strong here keeps it alive, so we can still access the object.\n+    /// assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    ///\n+    /// drop(strong);\n+    /// // But not any more. We can do Weak::as_raw(&weak), but accessing the pointer would lead to\n+    /// // undefined behaviour.\n+    /// // assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_raw(this: &Self) -> *const T {\n+        match this.inner() {\n+            None => ptr::null(),\n+            Some(inner) => {\n+                let offset = data_offset_sized::<T>();\n+                let ptr = inner as *const ArcInner<T>;\n+                // Note: while the pointer we create may already point to dropped value, the\n+                // allocation still lives (it must hold the weak point as long as we are alive).\n+                // Therefore, the offset is OK to do, it won't get out of the allocation.\n+                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n+                ptr as *const T\n+            }\n+        }\n+    }\n+\n+    /// Consumes the `Weak<T>` and turns it into a raw pointer.\n+    ///\n+    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n+    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    ///\n+    /// The same restrictions of accessing the target of the pointer as with\n+    /// [`as_raw`] apply.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// let strong = Arc::new(42);\n+    /// let weak = Arc::downgrade(&strong);\n+    /// let raw = Weak::into_raw(weak);\n+    ///\n+    /// assert_eq!(1, Arc::weak_count(&strong));\n+    /// assert_eq!(42, unsafe { *raw });\n+    ///\n+    /// drop(unsafe { Weak::from_raw(raw) });\n+    /// assert_eq!(0, Arc::weak_count(&strong));\n+    /// ```\n+    ///\n+    /// [`from_raw`]: struct.Weak.html#method.from_raw\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn into_raw(this: Self) -> *const T {\n+        let result = Self::as_raw(&this);\n+        mem::forget(this);\n+        result\n+    }\n+\n+    /// Converts a raw pointer previously created by [`into_raw`] back into\n+    /// `Weak<T>`.\n+    ///\n+    /// This can be used to safely get a strong reference (by calling [`upgrade`]\n+    /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n+    ///\n+    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n+    /// returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n+    /// is or *was* managed by an [`Arc`] and the weak count of that [`Arc`] must not have reached\n+    /// 0. It is allowed for the strong count to be 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// let strong = Arc::new(42);\n+    ///\n+    /// let raw_1 = Weak::into_raw(Arc::downgrade(&strong));\n+    /// let raw_2 = Weak::into_raw(Arc::downgrade(&strong));\n+    ///\n+    /// assert_eq!(2, Arc::weak_count(&strong));\n+    ///\n+    /// assert_eq!(42, *Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n+    /// assert_eq!(1, Arc::weak_count(&strong));\n+    ///\n+    /// drop(strong);\n+    ///\n+    /// // Decrement the last weak count.\n+    /// assert!(Weak::upgrade(&unsafe { Weak::from_raw(raw_2) }).is_none());\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`into_raw`]: struct.Weak.html#method.into_raw\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`Weak`]: struct.Weak.html\n+    /// [`Arc`]: struct.Arc.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub unsafe fn from_raw(ptr: *const T) -> Self {\n+        if ptr.is_null() {\n+            Self::new()\n+        } else {\n+            // See Arc::from_raw for details\n+            let offset = data_offset(ptr);\n+            let fake_ptr = ptr as *mut ArcInner<T>;\n+            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            Weak {\n+                ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\"),\n+            }\n+        }\n+    }\n }\n \n impl<T: ?Sized> Weak<T> {\n@@ -2150,3 +2284,21 @@ impl<T: ?Sized> AsRef<T> for Arc<T> {\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Arc<T> { }\n+\n+/// Computes the offset of the data field within ArcInner.\n+unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n+    // Align the unsized value to the end of the ArcInner.\n+    // Because it is ?Sized, it will always be the last field in memory.\n+    let align = align_of_val(&*ptr);\n+    let layout = Layout::new::<ArcInner<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}\n+\n+/// Computes the offset of the data field within ArcInner.\n+///\n+/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n+fn data_offset_sized<T>() -> isize {\n+    let align = align_of::<T>();\n+    let layout = Layout::new::<ArcInner<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}"}, {"sha": "6bbf776fb8f17bb7d6f14266e398ad3fc9e029bc", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -34,6 +34,13 @@ pub trait Step: Clone + PartialOrd + Sized {\n \n     /// Adds a `usize`, returning `None` on overflow.\n     fn add_usize(&self, n: usize) -> Option<Self>;\n+\n+    /// Subtracts a `usize`, returning `None` on underflow.\n+    fn sub_usize(&self, n: usize) -> Option<Self> {\n+        // this default implementation makes the addition of `sub_usize` a non-breaking change\n+        let _ = n;\n+        unimplemented!()\n+    }\n }\n \n // These are still macro-generated because the integer literals resolve to different types.\n@@ -85,6 +92,15 @@ macro_rules! step_impl_unsigned {\n                 }\n             }\n \n+            #[inline]\n+            #[allow(unreachable_patterns)]\n+            fn sub_usize(&self, n: usize) -> Option<Self> {\n+                match <$t>::try_from(n) {\n+                    Ok(n_as_t) => self.checked_sub(n_as_t),\n+                    Err(_) => None,\n+                }\n+            }\n+\n             step_identical_methods!();\n         }\n     )*)\n@@ -125,6 +141,25 @@ macro_rules! step_impl_signed {\n                 }\n             }\n \n+            #[inline]\n+            #[allow(unreachable_patterns)]\n+            fn sub_usize(&self, n: usize) -> Option<Self> {\n+                match <$unsigned>::try_from(n) {\n+                    Ok(n_as_unsigned) => {\n+                        // Wrapping in unsigned space handles cases like\n+                        // `80_i8.sub_usize(200) == Some(-120_i8)`,\n+                        // even though 200_usize is out of range for i8.\n+                        let wrapped = (*self as $unsigned).wrapping_sub(n_as_unsigned) as $t;\n+                        if wrapped <= *self {\n+                            Some(wrapped)\n+                        } else {\n+                            None  // Subtraction underflowed\n+                        }\n+                    }\n+                    Err(_) => None,\n+                }\n+            }\n+\n             step_identical_methods!();\n         }\n     )*)"}, {"sha": "4eac5cbc8e6623142563d8e3186994e4ceb3bfe1", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -223,3 +223,113 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n         ResultShunt::process(iter, |i| i.product())\n     }\n }\n+\n+/// An iterator adapter that produces output as long as the underlying\n+/// iterator produces `Option::Some` values.\n+struct OptionShunt<I> {\n+    iter: I,\n+    exited_early: bool,\n+}\n+\n+impl<I, T> OptionShunt<I>\n+where\n+    I: Iterator<Item = Option<T>>,\n+{\n+    /// Process the given iterator as if it yielded a `T` instead of a\n+    /// `Option<T>`. Any `None` value will stop the inner iterator and\n+    /// the overall result will be a `None`.\n+    pub fn process<F, U>(iter: I, mut f: F) -> Option<U>\n+    where\n+        F: FnMut(&mut Self) -> U,\n+    {\n+        let mut shunt = OptionShunt::new(iter);\n+        let value = f(shunt.by_ref());\n+        shunt.reconstruct(value)\n+    }\n+\n+    fn new(iter: I) -> Self {\n+        OptionShunt {\n+            iter,\n+            exited_early: false,\n+        }\n+    }\n+\n+    /// Consume the adapter and rebuild a `Option` value.\n+    fn reconstruct<U>(self, val: U) -> Option<U> {\n+        if self.exited_early {\n+            None\n+        } else {\n+            Some(val)\n+        }\n+    }\n+}\n+\n+impl<I, T> Iterator for OptionShunt<I>\n+where\n+    I: Iterator<Item = Option<T>>,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.iter.next() {\n+            Some(Some(v)) => Some(v),\n+            Some(None) => {\n+                self.exited_early = true;\n+                None\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.exited_early {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_option\", since = \"1.37.0\")]\n+impl<T, U> Sum<Option<U>> for Option<T>\n+where\n+    T: Sum<U>,\n+{\n+    /// Takes each element in the `Iterator`: if it is a `None`, no further\n+    /// elements are taken, and the `None` is returned. Should no `None` occur,\n+    /// the sum of all elements is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This sums up the position of the character 'a' in a vector of strings,\n+    /// if a word did not have the character 'a' the operation returns `None`:\n+    ///\n+    /// ```\n+    /// let words = vec![\"have\", \"a\", \"great\", \"day\"];\n+    /// let total: Option<usize> = words.iter().map(|w| w.find('a')).sum();\n+    /// assert_eq!(total, Some(5));\n+    /// ```\n+    fn sum<I>(iter: I) -> Option<T>\n+    where\n+        I: Iterator<Item = Option<U>>,\n+    {\n+        OptionShunt::process(iter, |i| i.sum())\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_option\", since = \"1.37.0\")]\n+impl<T, U> Product<Option<U>> for Option<T>\n+where\n+    T: Product<U>,\n+{\n+    /// Takes each element in the `Iterator`: if it is a `None`, no further\n+    /// elements are taken, and the `None` is returned. Should no `None` occur,\n+    /// the product of all elements is returned.\n+    fn product<I>(iter: I) -> Option<T>\n+    where\n+        I: Iterator<Item = Option<U>>,\n+    {\n+        OptionShunt::process(iter, |i| i.product())\n+    }\n+}"}, {"sha": "0e782bef39dd8ee6b4dd011f6df94da6369dee3a", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -4158,6 +4158,24 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n             Some(snd)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &[];\n+            None\n+        } else {\n+            let start = (len - 1 - n) * self.chunk_size;\n+            let end = match start.checked_add(self.chunk_size) {\n+                Some(res) => cmp::min(res, self.v.len()),\n+                None => self.v.len(),\n+            };\n+            let nth_back = &self.v[start..end];\n+            self.v = &self.v[..start];\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -4649,6 +4667,23 @@ impl<'a, T> DoubleEndedIterator for RChunks<'a, T> {\n             Some(fst)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &[];\n+            None\n+        } else {\n+            // can't underflow because `n < len`\n+            let offset_from_end = (len - 1 - n) * self.chunk_size;\n+            let end = self.v.len() - offset_from_end;\n+            let start = end.saturating_sub(self.chunk_size);\n+            let nth_back = &self.v[start..end];\n+            self.v = &self.v[end..];\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -4774,6 +4809,24 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n             Some(head)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            // can't underflow because `n < len`\n+            let offset_from_end = (len - 1 - n) * self.chunk_size;\n+            let end = self.v.len() - offset_from_end;\n+            let start = end.saturating_sub(self.chunk_size);\n+            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n+            let (_, nth_back) = tmp.split_at_mut(start);\n+            self.v = tail;\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -4898,6 +4951,24 @@ impl<'a, T> DoubleEndedIterator for RChunksExact<'a, T> {\n             Some(fst)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &[];\n+            None\n+        } else {\n+            // now that we know that `n` corresponds to a chunk,\n+            // none of these operations can underflow/overflow\n+            let offset = (len - n) * self.chunk_size;\n+            let start = self.v.len() - offset;\n+            let end = start + self.chunk_size;\n+            let nth_back = &self.v[start..end];\n+            self.v = &self.v[end..];\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -5016,6 +5087,25 @@ impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n             Some(head)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            // now that we know that `n` corresponds to a chunk,\n+            // none of these operations can underflow/overflow\n+            let offset = (len - n) * self.chunk_size;\n+            let start = self.v.len() - offset;\n+            let end = start + self.chunk_size;\n+            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n+            let (_, nth_back) = tmp.split_at_mut(start);\n+            self.v = tail;\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]"}, {"sha": "bedb9e756129c5a0322e3dbe22bbbbeb74992950", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -1084,6 +1084,14 @@ fn test_iterator_sum_result() {\n     assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Err(()));\n }\n \n+#[test]\n+fn test_iterator_sum_option() {\n+    let v: &[Option<i32>] = &[Some(1), Some(2), Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().sum::<Option<i32>>(), Some(10));\n+    let v: &[Option<i32>] = &[Some(1), None, Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().sum::<Option<i32>>(), None);\n+}\n+\n #[test]\n fn test_iterator_product() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n@@ -1126,6 +1134,14 @@ impl Ord for Mod3 {\n     }\n }\n \n+#[test]\n+fn test_iterator_product_option() {\n+    let v: &[Option<i32>] = &[Some(1), Some(2), Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().product::<Option<i32>>(), Some(24));\n+    let v: &[Option<i32>] = &[Some(1), None, Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().product::<Option<i32>>(), None);\n+}\n+\n #[test]\n fn test_iterator_max() {\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];"}, {"sha": "9710f019f4e4df0ba630cfd6c4a0c0e6bd246345", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -134,6 +134,30 @@ fn test_chunks_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_chunks_nth_back() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.chunks(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+    assert_eq!(c.next(), None);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c2 = v2.chunks(3);\n+    assert_eq!(c2.nth_back(1).unwrap(), &[0, 1, 2]);\n+    assert_eq!(c2.next(), None);\n+    assert_eq!(c2.next_back(), None);\n+\n+    let v3: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c3 = v3.chunks(10);\n+    assert_eq!(c3.nth_back(0).unwrap(), &[0, 1, 2, 3, 4]);\n+    assert_eq!(c3.next(), None);\n+\n+    let v4: &[i32] = &[0, 1, 2];\n+    let mut c4 = v4.chunks(10);\n+    assert_eq!(c4.nth_back(1_000_000_000usize), None);\n+}\n+\n #[test]\n fn test_chunks_last() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n@@ -356,6 +380,19 @@ fn test_rchunks_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_rchunks_nth_back() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c2 = v2.rchunks(3);\n+    assert_eq!(c2.nth_back(1).unwrap(), &[2, 3, 4]);\n+    assert_eq!(c2.next_back(), None);\n+}\n+\n #[test]\n fn test_rchunks_last() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n@@ -407,6 +444,19 @@ fn test_rchunks_mut_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_rchunks_mut_nth_back() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks_mut(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c2 = v2.rchunks_mut(3);\n+    assert_eq!(c2.nth_back(1).unwrap(), &[2, 3, 4]);\n+    assert_eq!(c2.next_back(), None);\n+}\n+\n #[test]\n fn test_rchunks_mut_last() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n@@ -460,6 +510,19 @@ fn test_rchunks_exact_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_rchunks_exact_nth_back() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks_exact(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n+    let mut c2 = v2.rchunks_exact(3);\n+    assert_eq!(c2.nth_back(1).unwrap(), &[4, 5, 6]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n #[test]\n fn test_rchunks_exact_last() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n@@ -518,6 +581,19 @@ fn test_rchunks_exact_mut_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_rchunks_exact_mut_nth_back() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks_exact_mut(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n+    let mut c2 = v2.rchunks_exact_mut(3);\n+    assert_eq!(c2.nth_back(1).unwrap(), &[4, 5, 6]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n #[test]\n fn test_rchunks_exact_mut_last() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];"}, {"sha": "d4ef134728eafe5b6514557a6c570b75aa5603f9", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -2037,7 +2037,7 @@ impl<'tcx> Place<'tcx> {\n     /// a single deref of a local.\n     //\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n-    pub fn local(&self) -> Option<Local> {\n+    pub fn local_or_deref_local(&self) -> Option<Local> {\n         match self {\n             Place::Base(PlaceBase::Local(local)) |\n             Place::Projection(box Projection {"}, {"sha": "ca79bc15358c500fb6f3216af3933ddf43af2e87", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -188,49 +188,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n     }\n }\n \n-#[derive(Clone, Default)]\n-pub struct Stats {\n-    pub n_glues_created: usize,\n-    pub n_null_glues: usize,\n-    pub n_real_glues: usize,\n-    pub n_fns: usize,\n-    pub n_inlines: usize,\n-    pub n_closures: usize,\n-    pub n_llvm_insns: usize,\n-    pub llvm_insns: FxHashMap<String, usize>,\n-    // (ident, llvm-instructions)\n-    pub fn_stats: Vec<(String, usize)>,\n-}\n-\n-impl_stable_hash_for!(struct self::Stats {\n-    n_glues_created,\n-    n_null_glues,\n-    n_real_glues,\n-    n_fns,\n-    n_inlines,\n-    n_closures,\n-    n_llvm_insns,\n-    llvm_insns,\n-    fn_stats\n-});\n-\n-impl Stats {\n-    pub fn extend(&mut self, stats: Stats) {\n-        self.n_glues_created += stats.n_glues_created;\n-        self.n_null_glues += stats.n_null_glues;\n-        self.n_real_glues += stats.n_real_glues;\n-        self.n_fns += stats.n_fns;\n-        self.n_inlines += stats.n_inlines;\n-        self.n_closures += stats.n_closures;\n-        self.n_llvm_insns += stats.n_llvm_insns;\n-\n-        for (k, v) in stats.llvm_insns {\n-            *self.llvm_insns.entry(k).or_insert(0) += v;\n-        }\n-        self.fn_stats.extend(stats.fn_stats);\n-    }\n-}\n-\n pub struct CodegenUnitNameBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     cache: FxHashMap<CrateNum, String>,"}, {"sha": "300d0cbfba55bd3e3f10a1f02bdfa06c2b5b2030", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -1216,21 +1216,12 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"measure time of each rustc pass\"),\n     time: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of rustc processes\"),\n-    count_llvm_insns: bool = (false, parse_bool,\n-        [UNTRACKED_WITH_WARNING(true,\n-        \"The output generated by `-Z count_llvm_insns` might not be reliable \\\n-         when used with incremental compilation\")],\n-        \"count where LLVM instrs originate\"),\n     time_llvm_passes: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n         \"The output of `-Z time-llvm-passes` will only reflect timings of \\\n          re-codegened modules when used with incremental compilation\" )],\n         \"measure time of each LLVM pass\"),\n     input_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather statistics about the input\"),\n-    codegen_stats: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n-        \"The output of `-Z codegen-stats` might not be accurate when incremental \\\n-         compilation is enabled\")],\n-        \"gather codegen statistics\"),\n     asm_comments: bool = (false, parse_bool, [TRACKED],\n         \"generate comments into the assembly (may change behavior)\"),\n     verify_llvm_ir: bool = (false, parse_bool, [TRACKED],\n@@ -3259,14 +3250,10 @@ mod tests {\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.time_passes = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.count_llvm_insns = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.time_llvm_passes = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.input_stats = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.codegen_stats = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.borrowck_stats = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.meta_stats = true;"}, {"sha": "2726a4770c8602b0a8f02e6764bf4fe7ba5955c7", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -519,15 +519,9 @@ impl Session {\n     pub fn instrument_mcount(&self) -> bool {\n         self.opts.debugging_opts.instrument_mcount\n     }\n-    pub fn count_llvm_insns(&self) -> bool {\n-        self.opts.debugging_opts.count_llvm_insns\n-    }\n     pub fn time_llvm_passes(&self) -> bool {\n         self.opts.debugging_opts.time_llvm_passes\n     }\n-    pub fn codegen_stats(&self) -> bool {\n-        self.opts.debugging_opts.codegen_stats\n-    }\n     pub fn meta_stats(&self) -> bool {\n         self.opts.debugging_opts.meta_stats\n     }"}, {"sha": "f8c6087373f1eb9218bd24c475e22bb6a8d417b6", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -24,7 +24,7 @@ use crate::common;\n use crate::context::CodegenCx;\n use crate::monomorphize::partitioning::CodegenUnitExt;\n use rustc::dep_graph;\n-use rustc::mir::mono::{Linkage, Visibility, Stats};\n+use rustc::mir::mono::{Linkage, Visibility};\n use rustc::middle::cstore::{EncodedMetadata};\n use rustc::ty::TyCtxt;\n use rustc::middle::exported_symbols;\n@@ -104,17 +104,17 @@ pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n     }\n }\n \n-pub fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  cgu_name: InternedString)\n-                                  -> Stats {\n+pub fn compile_codegen_unit(tcx: TyCtxt<'a, 'tcx, 'tcx>, cgu_name: InternedString) {\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n-    let ((stats, module), _) = tcx.dep_graph.with_task(dep_node,\n-                                                       tcx,\n-                                                       cgu_name,\n-                                                       module_codegen,\n-                                                       dep_graph::hash_result);\n+    let (module, _) = tcx.dep_graph.with_task(\n+        dep_node,\n+        tcx,\n+        cgu_name,\n+        module_codegen,\n+        dep_graph::hash_result,\n+    );\n     let time_to_codegen = start_time.elapsed();\n \n     // We assume that the cost to run LLVM on a CGU is proportional to\n@@ -123,17 +123,15 @@ pub fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                time_to_codegen.subsec_nanos() as u64;\n \n     submit_codegened_module_to_llvm(&LlvmCodegenBackend(()), tcx, module, cost);\n-    return stats;\n \n     fn module_codegen<'ll, 'tcx>(\n         tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n-        cgu_name: InternedString)\n-        -> (Stats, ModuleCodegen<ModuleLlvm>)\n-    {\n+        cgu_name: InternedString,\n+    ) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);\n         // Instantiate monomorphizations without filling out definitions yet...\n         let llvm_module = ModuleLlvm::new(tcx, &cgu_name.as_str());\n-        let stats = {\n+        {\n             let cx = CodegenCx::new(tcx, cgu, &llvm_module);\n             let mono_items = cx.codegen_unit\n                                .items_in_deterministic_order(cx.tcx);\n@@ -169,15 +167,13 @@ pub fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if cx.sess().opts.debuginfo != DebugInfo::None {\n                 cx.debuginfo_finalize();\n             }\n+        }\n \n-            cx.consume_stats().into_inner()\n-        };\n-\n-        (stats, ModuleCodegen {\n+        ModuleCodegen {\n             name: cgu_name.to_string(),\n             module_llvm: llvm_module,\n             kind: ModuleKind::Regular,\n-        })\n+        }\n     }\n }\n "}, {"sha": "42e7a72c43b217cffdcd9615347bd7a3f0772722", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 3, "deletions": 110, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -147,21 +147,18 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn ret_void(&mut self) {\n-        self.count_insn(\"retvoid\");\n         unsafe {\n             llvm::LLVMBuildRetVoid(self.llbuilder);\n         }\n     }\n \n     fn ret(&mut self, v: &'ll Value) {\n-        self.count_insn(\"ret\");\n         unsafe {\n             llvm::LLVMBuildRet(self.llbuilder, v);\n         }\n     }\n \n     fn br(&mut self, dest: &'ll BasicBlock) {\n-        self.count_insn(\"br\");\n         unsafe {\n             llvm::LLVMBuildBr(self.llbuilder, dest);\n         }\n@@ -173,7 +170,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         then_llbb: &'ll BasicBlock,\n         else_llbb: &'ll BasicBlock,\n     ) {\n-        self.count_insn(\"condbr\");\n         unsafe {\n             llvm::LLVMBuildCondBr(self.llbuilder, cond, then_llbb, else_llbb);\n         }\n@@ -204,7 +200,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         catch: &'ll BasicBlock,\n         funclet: Option<&Funclet<'ll>>,\n     ) -> &'ll Value {\n-        self.count_insn(\"invoke\");\n \n         debug!(\"Invoke {:?} with args ({:?})\",\n                llfn,\n@@ -227,29 +222,25 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn unreachable(&mut self) {\n-        self.count_insn(\"unreachable\");\n         unsafe {\n             llvm::LLVMBuildUnreachable(self.llbuilder);\n         }\n     }\n \n     /* Arithmetic */\n     fn add(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"add\");\n         unsafe {\n             llvm::LLVMBuildAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fadd(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fadd\");\n         unsafe {\n             llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fadd_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fadd\");\n         unsafe {\n             let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -258,21 +249,18 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn sub(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"sub\");\n         unsafe {\n             llvm::LLVMBuildSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fsub(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fsub\");\n         unsafe {\n             llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fsub_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fsub\");\n         unsafe {\n             let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -281,21 +269,18 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn mul(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"mul\");\n         unsafe {\n             llvm::LLVMBuildMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fmul(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fmul\");\n         unsafe {\n             llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fmul_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fmul\");\n         unsafe {\n             let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -305,42 +290,36 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n \n     fn udiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"udiv\");\n         unsafe {\n             llvm::LLVMBuildUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn exactudiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"exactudiv\");\n         unsafe {\n             llvm::LLVMBuildExactUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn sdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"sdiv\");\n         unsafe {\n             llvm::LLVMBuildSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn exactsdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"exactsdiv\");\n         unsafe {\n             llvm::LLVMBuildExactSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fdiv\");\n         unsafe {\n             llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fdiv_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fdiv\");\n         unsafe {\n             let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -349,28 +328,24 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn urem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"urem\");\n         unsafe {\n             llvm::LLVMBuildURem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn srem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"srem\");\n         unsafe {\n             llvm::LLVMBuildSRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn frem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"frem\");\n         unsafe {\n             llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn frem_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"frem\");\n         unsafe {\n             let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -379,63 +354,54 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn shl(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"shl\");\n         unsafe {\n             llvm::LLVMBuildShl(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn lshr(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"lshr\");\n         unsafe {\n             llvm::LLVMBuildLShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn ashr(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"ashr\");\n         unsafe {\n             llvm::LLVMBuildAShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn and(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"and\");\n         unsafe {\n             llvm::LLVMBuildAnd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn or(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"or\");\n         unsafe {\n             llvm::LLVMBuildOr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn xor(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"xor\");\n         unsafe {\n             llvm::LLVMBuildXor(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn neg(&mut self, v: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"neg\");\n         unsafe {\n             llvm::LLVMBuildNeg(self.llbuilder, v, noname())\n         }\n     }\n \n     fn fneg(&mut self, v: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fneg\");\n         unsafe {\n             llvm::LLVMBuildFNeg(self.llbuilder, v, noname())\n         }\n     }\n \n     fn not(&mut self, v: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"not\");\n         unsafe {\n             llvm::LLVMBuildNot(self.llbuilder, v, noname())\n         }\n@@ -524,7 +490,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn dynamic_alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n-        self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty, noname())\n@@ -543,7 +508,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                         len: &'ll Value,\n                         name: &str,\n                         align: Align) -> &'ll Value {\n-        self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n                 llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, noname())\n@@ -558,7 +522,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn load(&mut self, ptr: &'ll Value, align: Align) -> &'ll Value {\n-        self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n             llvm::LLVMSetAlignment(load, align.bytes() as c_uint);\n@@ -567,11 +530,10 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn volatile_load(&mut self, ptr: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"load.volatile\");\n         unsafe {\n-            let insn = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n-            llvm::LLVMSetVolatile(insn, llvm::True);\n-            insn\n+            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n+            llvm::LLVMSetVolatile(load, llvm::True);\n+            load\n         }\n     }\n \n@@ -581,7 +543,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         order: rustc_codegen_ssa::common::AtomicOrdering,\n         size: Size,\n     ) -> &'ll Value {\n-        self.count_insn(\"load.atomic\");\n         unsafe {\n             let load = llvm::LLVMRustBuildAtomicLoad(\n                 self.llbuilder,\n@@ -745,7 +706,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         flags: MemFlags,\n     ) -> &'ll Value {\n         debug!(\"Store {:?} -> {:?} ({:?})\", val, ptr, flags);\n-        self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n@@ -774,7 +734,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n    fn atomic_store(&mut self, val: &'ll Value, ptr: &'ll Value,\n                    order: rustc_codegen_ssa::common::AtomicOrdering, size: Size) {\n         debug!(\"Store {:?} -> {:?}\", val, ptr);\n-        self.count_insn(\"store.atomic\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMRustBuildAtomicStore(\n@@ -789,23 +748,20 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n-        self.count_insn(\"gep\");\n         unsafe {\n             llvm::LLVMBuildGEP(self.llbuilder, ptr, indices.as_ptr(),\n                                indices.len() as c_uint, noname())\n         }\n     }\n \n     fn inbounds_gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n-        self.count_insn(\"inboundsgep\");\n         unsafe {\n             llvm::LLVMBuildInBoundsGEP(\n                 self.llbuilder, ptr, indices.as_ptr(), indices.len() as c_uint, noname())\n         }\n     }\n \n     fn struct_gep(&mut self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n-        self.count_insn(\"structgep\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n@@ -814,108 +770,93 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     /* Casts */\n     fn trunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"trunc\");\n         unsafe {\n             llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn sext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"sext\");\n         unsafe {\n             llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"fptoui\");\n         unsafe {\n             llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"fptosi\");\n         unsafe {\n             llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,noname())\n         }\n     }\n \n     fn uitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"uitofp\");\n         unsafe {\n             llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn sitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"sitofp\");\n         unsafe {\n             llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn fptrunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"fptrunc\");\n         unsafe {\n             llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn fpext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"fpext\");\n         unsafe {\n             llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn ptrtoint(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"ptrtoint\");\n         unsafe {\n             llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn inttoptr(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"inttoptr\");\n         unsafe {\n             llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn bitcast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"bitcast\");\n         unsafe {\n             llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n \n     fn intcast(&mut self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"intcast\");\n         unsafe {\n             llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed)\n         }\n     }\n \n     fn pointercast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"pointercast\");\n         unsafe {\n             llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     /* Comparisons */\n     fn icmp(&mut self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"icmp\");\n         let op = llvm::IntPredicate::from_generic(op);\n         unsafe {\n             llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n     fn fcmp(&mut self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fcmp\");\n         unsafe {\n             llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n@@ -984,22 +925,19 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         then_val: &'ll Value,\n         else_val: &'ll Value,\n     ) -> &'ll Value {\n-        self.count_insn(\"select\");\n         unsafe {\n             llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, noname())\n         }\n     }\n \n     #[allow(dead_code)]\n     fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"vaarg\");\n         unsafe {\n             llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n     }\n \n     fn extract_element(&mut self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"extractelement\");\n         unsafe {\n             llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n         }\n@@ -1016,7 +954,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn extract_value(&mut self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n-        self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n@@ -1025,7 +962,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn insert_value(&mut self, agg_val: &'ll Value, elt: &'ll Value,\n                        idx: u64) -> &'ll Value {\n-        self.count_insn(\"insertvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildInsertValue(self.llbuilder, agg_val, elt, idx as c_uint,\n@@ -1035,22 +971,19 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn landing_pad(&mut self, ty: &'ll Type, pers_fn: &'ll Value,\n                        num_clauses: usize) -> &'ll Value {\n-        self.count_insn(\"landingpad\");\n         unsafe {\n             llvm::LLVMBuildLandingPad(self.llbuilder, ty, pers_fn,\n                                       num_clauses as c_uint, noname())\n         }\n     }\n \n     fn set_cleanup(&mut self, landing_pad: &'ll Value) {\n-        self.count_insn(\"setcleanup\");\n         unsafe {\n             llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }\n     }\n \n     fn resume(&mut self, exn: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"resume\");\n         unsafe {\n             llvm::LLVMBuildResume(self.llbuilder, exn)\n         }\n@@ -1059,7 +992,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn cleanup_pad(&mut self,\n                        parent: Option<&'ll Value>,\n                        args: &[&'ll Value]) -> Funclet<'ll> {\n-        self.count_insn(\"cleanuppad\");\n         let name = const_cstr!(\"cleanuppad\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupPad(self.llbuilder,\n@@ -1075,7 +1007,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         &mut self, funclet: &Funclet<'ll>,\n         unwind: Option<&'ll BasicBlock>,\n     ) -> &'ll Value {\n-        self.count_insn(\"cleanupret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupRet(self.llbuilder, funclet.cleanuppad(), unwind)\n         };\n@@ -1085,7 +1016,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn catch_pad(&mut self,\n                      parent: &'ll Value,\n                      args: &[&'ll Value]) -> Funclet<'ll> {\n-        self.count_insn(\"catchpad\");\n         let name = const_cstr!(\"catchpad\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchPad(self.llbuilder, parent,\n@@ -1101,7 +1031,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unwind: Option<&'ll BasicBlock>,\n         num_handlers: usize,\n     ) -> &'ll Value {\n-        self.count_insn(\"catchswitch\");\n         let name = const_cstr!(\"catchswitch\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchSwitch(self.llbuilder, parent, unwind,\n@@ -1199,7 +1128,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         args: &[&'ll Value],\n         funclet: Option<&Funclet<'ll>>,\n     ) -> &'ll Value {\n-        self.count_insn(\"call\");\n \n         debug!(\"Call {:?} with args ({:?})\",\n                llfn,\n@@ -1221,7 +1149,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn zext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"zext\");\n         unsafe {\n             llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n         }\n@@ -1285,32 +1212,17 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn count_insn(&self, category: &str) {\n-        if self.sess().codegen_stats() {\n-            self.stats.borrow_mut().n_llvm_insns += 1;\n-        }\n-        if self.sess().count_llvm_insns() {\n-            *self.stats\n-                      .borrow_mut()\n-                      .llvm_insns\n-                      .entry(category.to_string())\n-                      .or_insert(0) += 1;\n-        }\n-    }\n-\n     fn position_at_start(&mut self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n         }\n     }\n \n     pub fn minnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"minnum\");\n         unsafe { llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs) }\n     }\n \n     pub fn maxnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"maxnum\");\n         unsafe { llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs) }\n     }\n \n@@ -1319,7 +1231,6 @@ impl Builder<'a, 'll, 'tcx> {\n         elt: &'ll Value,\n         idx: &'ll Value,\n     ) -> &'ll Value {\n-        self.count_insn(\"insertelement\");\n         unsafe {\n             llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n         }\n@@ -1331,14 +1242,12 @@ impl Builder<'a, 'll, 'tcx> {\n         v2: &'ll Value,\n         mask: &'ll Value,\n     ) -> &'ll Value {\n-        self.count_insn(\"shufflevector\");\n         unsafe {\n             llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n         }\n     }\n \n     pub fn vector_reduce_fadd_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fadd_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n             // https://bugs.llvm.org/show_bug.cgi?id=36732\n@@ -1349,7 +1258,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n     pub fn vector_reduce_fmul_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmul_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n             // https://bugs.llvm.org/show_bug.cgi?id=36732\n@@ -1360,55 +1268,44 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n     pub fn vector_reduce_add(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.add\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_mul(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.mul\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_and(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.and\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_or(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.or\");\n         unsafe { llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_xor(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.xor\");\n         unsafe { llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_fmin(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmin\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n     pub fn vector_reduce_fmax(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmax\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n     pub fn vector_reduce_fmin_fast(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmin_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_fmax_fast(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmax_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_min(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.min\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed) }\n     }\n     pub fn vector_reduce_max(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.max\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed) }\n     }\n \n@@ -1419,7 +1316,6 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     pub fn catch_ret(&mut self, funclet: &Funclet<'ll>, unwind: &'ll BasicBlock) -> &'ll Value {\n-        self.count_insn(\"catchret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchRet(self.llbuilder, funclet.cleanuppad(), unwind)\n         };\n@@ -1488,7 +1384,6 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     pub fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"vaarg\");\n         unsafe {\n             llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n@@ -1511,7 +1406,6 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     fn phi(&mut self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n-        self.count_insn(\"addincoming\");\n         assert_eq!(vals.len(), bbs.len());\n         let phi = unsafe {\n             llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n@@ -1525,7 +1419,6 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     fn add_incoming_to_phi(&mut self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n-        self.count_insn(\"addincoming\");\n         unsafe {\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n         }"}, {"sha": "b6b47d047c8b1023e8c7ef843167ff0b3d502257", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -12,7 +12,6 @@ use rustc_codegen_ssa::traits::*;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::small_c_str::SmallCStr;\n-use rustc::mir::mono::Stats;\n use rustc::session::config::{self, DebugInfo};\n use rustc::session::Session;\n use rustc::ty::layout::{\n@@ -44,7 +43,6 @@ pub struct CodegenCx<'ll, 'tcx: 'll> {\n \n     pub llmod: &'ll llvm::Module,\n     pub llcx: &'ll llvm::Context,\n-    pub stats: RefCell<Stats>,\n     pub codegen_unit: Arc<CodegenUnit<'tcx>>,\n \n     /// Cache instances of monomorphic and polymorphic items\n@@ -284,7 +282,6 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n             tls_model,\n             llmod,\n             llcx,\n-            stats: RefCell::new(Stats::default()),\n             codegen_unit,\n             instances: Default::default(),\n             vtables: Default::default(),\n@@ -408,14 +405,6 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         self.check_overflow\n     }\n \n-    fn stats(&self) -> &RefCell<Stats> {\n-        &self.stats\n-    }\n-\n-    fn consume_stats(self) -> RefCell<Stats> {\n-        self.stats\n-    }\n-\n     fn codegen_unit(&self) -> &Arc<CodegenUnit<'tcx>> {\n         &self.codegen_unit\n     }"}, {"sha": "57cffa48163e1d6506a857c38776cb9b4d87d21a", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -52,7 +52,6 @@ use rustc_codegen_ssa::CompiledModule;\n use errors::{FatalError, Handler};\n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::InternedString;\n-use rustc::mir::mono::Stats;\n pub use llvm_util::target_features;\n use std::any::Any;\n use std::sync::{mpsc, Arc};\n@@ -130,8 +129,8 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cgu_name: InternedString,\n-    ) -> Stats {\n-        base::compile_codegen_unit(tcx, cgu_name)\n+    ) {\n+        base::compile_codegen_unit(tcx, cgu_name);\n     }\n     fn target_machine_factory(\n         &self,"}, {"sha": "172b5b39987d43247f137f5039361318c3ebe749", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 72, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -20,15 +20,14 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::weak_lang_items;\n-use rustc::mir::mono::{Stats, CodegenUnitNameBuilder};\n+use rustc::mir::mono::CodegenUnitNameBuilder;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::ty::query::Providers;\n use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, EntryFnType, Lto};\n use rustc::session::Session;\n-use rustc_mir::monomorphize::item::DefPathBasedNames;\n use rustc_mir::monomorphize::Instance;\n use rustc_mir::monomorphize::partitioning::{CodegenUnit, CodegenUnitExt};\n use rustc::util::nodemap::FxHashMap;\n@@ -58,40 +57,6 @@ use rustc::hir;\n \n use crate::mir::operand::OperandValue;\n \n-use std::marker::PhantomData;\n-\n-pub struct StatRecorder<'a, 'tcx, Cx: 'a + CodegenMethods<'tcx>> {\n-    cx: &'a Cx,\n-    name: Option<String>,\n-    istart: usize,\n-    _marker: PhantomData<&'tcx ()>,\n-}\n-\n-impl<'a, 'tcx, Cx: CodegenMethods<'tcx>> StatRecorder<'a, 'tcx, Cx> {\n-    pub fn new(cx: &'a Cx, name: String) -> Self {\n-        let istart = cx.stats().borrow().n_llvm_insns;\n-        StatRecorder {\n-            cx,\n-            name: Some(name),\n-            istart,\n-            _marker: PhantomData,\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, Cx: CodegenMethods<'tcx>> Drop for StatRecorder<'a, 'tcx, Cx> {\n-    fn drop(&mut self) {\n-        if self.cx.sess().codegen_stats() {\n-            let mut stats = self.cx.stats().borrow_mut();\n-            let iend = stats.n_llvm_insns;\n-            stats.fn_stats.push((self.name.take().unwrap(), iend - self.istart));\n-            stats.n_fns += 1;\n-            // Reset LLVM insn count to avoid compound costs.\n-            stats.n_llvm_insns = self.istart;\n-        }\n-    }\n-}\n-\n pub fn bin_op_to_icmp_predicate(op: hir::BinOpKind,\n                                 signed: bool)\n                                 -> IntPredicate {\n@@ -408,15 +373,6 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     instance: Instance<'tcx>,\n ) {\n-    let _s = if cx.sess().codegen_stats() {\n-        let mut instance_name = String::new();\n-        DefPathBasedNames::new(cx.tcx(), true, true)\n-            .push_def_path(instance.def_id(), &mut instance_name);\n-        Some(StatRecorder::new(cx, instance_name))\n-    } else {\n-        None\n-    };\n-\n     // this is an info! to allow collecting monomorphization statistics\n     // and to allow finding the last function before LLVM aborts from\n     // release builds.\n@@ -428,8 +384,6 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     let lldecl = cx.instances().borrow().get(&instance).cloned().unwrap_or_else(||\n         bug!(\"Instance `{:?}` not already declared\", instance));\n \n-    cx.stats().borrow_mut().n_closures += 1;\n-\n     let mir = cx.tcx().instance_mir(instance.def);\n     mir::codegen_mir::<Bx>(cx, lldecl, &mir, instance, sig);\n }\n@@ -653,7 +607,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     };\n \n     let mut total_codegen_time = Duration::new(0, 0);\n-    let mut all_stats = Stats::default();\n \n     for cgu in codegen_units.into_iter() {\n         ongoing_codegen.wait_for_signal_to_codegen_item();\n@@ -666,8 +619,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             CguReuse::No => {\n                 tcx.sess.profiler(|p| p.start_activity(format!(\"codegen {}\", cgu.name())));\n                 let start_time = Instant::now();\n-                let stats = backend.compile_codegen_unit(tcx, *cgu.name());\n-                all_stats.extend(stats);\n+                backend.compile_codegen_unit(tcx, *cgu.name());\n                 total_codegen_time += start_time.elapsed();\n                 tcx.sess.profiler(|p| p.end_activity(format!(\"codegen {}\", cgu.name())));\n                 false\n@@ -701,28 +653,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     symbol_names_test::report_symbol_names(tcx);\n \n-    if tcx.sess.codegen_stats() {\n-        println!(\"--- codegen stats ---\");\n-        println!(\"n_glues_created: {}\", all_stats.n_glues_created);\n-        println!(\"n_null_glues: {}\", all_stats.n_null_glues);\n-        println!(\"n_real_glues: {}\", all_stats.n_real_glues);\n-\n-        println!(\"n_fns: {}\", all_stats.n_fns);\n-        println!(\"n_inlines: {}\", all_stats.n_inlines);\n-        println!(\"n_closures: {}\", all_stats.n_closures);\n-        println!(\"fn stats:\");\n-        all_stats.fn_stats.sort_by_key(|&(_, insns)| insns);\n-        for &(ref name, insns) in all_stats.fn_stats.iter() {\n-            println!(\"{} insns, {}\", insns, *name);\n-        }\n-    }\n-\n-    if tcx.sess.count_llvm_insns() {\n-        for (k, v) in all_stats.llvm_insns.iter() {\n-            println!(\"{:7} {}\", *v, *k);\n-        }\n-    }\n-\n     ongoing_codegen.check_for_errors(tcx.sess);\n \n     assert_and_save_dep_graph(tcx);"}, {"sha": "cd32d6f484d730f671a650f06edb4c284954db8a", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -396,22 +396,20 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let cx = self.cx;\n         let tcx = self.cx.tcx();\n \n-        if let mir::Place::Base(mir::PlaceBase::Local(index)) = *place {\n-            match self.locals[index] {\n-                LocalRef::Place(place) => {\n-                    return place;\n-                }\n-                LocalRef::UnsizedPlace(place) => {\n-                    return bx.load_operand(place).deref(cx);\n-                }\n-                LocalRef::Operand(..) => {\n-                    bug!(\"using operand local {:?} as place\", place);\n+        let result = match *place {\n+            mir::Place::Base(mir::PlaceBase::Local(index)) => {\n+                match self.locals[index] {\n+                    LocalRef::Place(place) => {\n+                        return place;\n+                    }\n+                    LocalRef::UnsizedPlace(place) => {\n+                        return bx.load_operand(place).deref(cx);\n+                    }\n+                    LocalRef::Operand(..) => {\n+                        bug!(\"using operand local {:?} as place\", place);\n+                    }\n                 }\n             }\n-        }\n-\n-        let result = match *place {\n-            mir::Place::Base(mir::PlaceBase::Local(_)) => bug!(), // handled above\n             mir::Place::Base(\n                 mir::PlaceBase::Static(\n                     box mir::Static { ty, kind: mir::StaticKind::Promoted(promoted) }"}, {"sha": "0466b47cf148f8c680d49563ca8948ce58921207", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -5,7 +5,6 @@ use super::write::WriteBackendMethods;\n use super::CodegenObject;\n use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::EncodedMetadata;\n-use rustc::mir::mono::Stats;\n use rustc::session::{Session, config};\n use rustc::ty::TyCtxt;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -49,7 +48,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cgu_name: InternedString,\n-    ) -> Stats;\n+    );\n     // If find_features is true this won't access `sess.crate_types` by assuming\n     // that `is_pie_binary` is false. When we discover LLVM target features\n     // `sess.crate_types` is uninitialized so we cannot access it."}, {"sha": "5ea86df6e9459cc76fcb3e0c5dfb007b65003b84", "filename": "src/librustc_codegen_ssa/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -1,5 +1,4 @@\n use super::BackendTypes;\n-use rustc::mir::mono::Stats;\n use rustc::session::Session;\n use rustc::ty::{self, Instance, Ty};\n use rustc::util::nodemap::FxHashMap;\n@@ -17,8 +16,6 @@ pub trait MiscMethods<'tcx>: BackendTypes {\n     fn eh_personality(&self) -> Self::Value;\n     fn eh_unwind_resume(&self) -> Self::Value;\n     fn sess(&self) -> &Session;\n-    fn stats(&self) -> &RefCell<Stats>;\n-    fn consume_stats(self) -> RefCell<Stats>;\n     fn codegen_unit(&self) -> &Arc<CodegenUnit<'tcx>>;\n     fn used_statics(&self) -> &RefCell<Vec<Self::Value>>;\n     fn set_frame_pointer_elimination(&self, llfn: Self::Value);"}, {"sha": "c7f6e54c3d56b1dd713af054614859256a7721bb", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -212,6 +212,11 @@ macro_rules! newtype_index {\n             fn add_usize(&self, u: usize) -> Option<Self> {\n                 Idx::index(*self).checked_add(u).map(Self::new)\n             }\n+\n+            #[inline]\n+            fn sub_usize(&self, u: usize) -> Option<Self> {\n+                Idx::index(*self).checked_sub(u).map(Self::new)\n+            }\n         }\n \n         impl From<$type> for u32 {"}, {"sha": "e1112a1557771c7e4b7f6fa4c34ba452801ec52f", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 174, "deletions": 167, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -162,6 +162,7 @@ impl ColorConfig {\n     }\n }\n \n+/// Handles the writing of `HumanReadableErrorType::Default` and `HumanReadableErrorType::Short`\n pub struct EmitterWriter {\n     dst: Destination,\n     sm: Option<Lrc<SourceMapperDyn>>,\n@@ -170,7 +171,8 @@ pub struct EmitterWriter {\n     ui_testing: bool,\n }\n \n-struct FileWithAnnotatedLines {\n+#[derive(Debug)]\n+pub struct FileWithAnnotatedLines {\n     file: Lrc<SourceFile>,\n     lines: Vec<Line>,\n     multiline_depth: usize,\n@@ -221,169 +223,6 @@ impl EmitterWriter {\n         }\n     }\n \n-    fn preprocess_annotations(&mut self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n-        fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n-                                  file: Lrc<SourceFile>,\n-                                  line_index: usize,\n-                                  ann: Annotation) {\n-\n-            for slot in file_vec.iter_mut() {\n-                // Look through each of our files for the one we're adding to\n-                if slot.file.name == file.name {\n-                    // See if we already have a line for it\n-                    for line_slot in &mut slot.lines {\n-                        if line_slot.line_index == line_index {\n-                            line_slot.annotations.push(ann);\n-                            return;\n-                        }\n-                    }\n-                    // We don't have a line yet, create one\n-                    slot.lines.push(Line {\n-                        line_index,\n-                        annotations: vec![ann],\n-                    });\n-                    slot.lines.sort();\n-                    return;\n-                }\n-            }\n-            // This is the first time we're seeing the file\n-            file_vec.push(FileWithAnnotatedLines {\n-                file,\n-                lines: vec![Line {\n-                                line_index,\n-                                annotations: vec![ann],\n-                            }],\n-                multiline_depth: 0,\n-            });\n-        }\n-\n-        let mut output = vec![];\n-        let mut multiline_annotations = vec![];\n-\n-        if let Some(ref sm) = self.sm {\n-            for span_label in msp.span_labels() {\n-                if span_label.span.is_dummy() {\n-                    continue;\n-                }\n-\n-                let lo = sm.lookup_char_pos(span_label.span.lo());\n-                let mut hi = sm.lookup_char_pos(span_label.span.hi());\n-\n-                // Watch out for \"empty spans\". If we get a span like 6..6, we\n-                // want to just display a `^` at 6, so convert that to\n-                // 6..7. This is degenerate input, but it's best to degrade\n-                // gracefully -- and the parser likes to supply a span like\n-                // that for EOF, in particular.\n-\n-                if lo.col_display == hi.col_display && lo.line == hi.line {\n-                    hi.col_display += 1;\n-                }\n-\n-                let ann_type = if lo.line != hi.line {\n-                    let ml = MultilineAnnotation {\n-                        depth: 1,\n-                        line_start: lo.line,\n-                        line_end: hi.line,\n-                        start_col: lo.col_display,\n-                        end_col: hi.col_display,\n-                        is_primary: span_label.is_primary,\n-                        label: span_label.label.clone(),\n-                        overlaps_exactly: false,\n-                    };\n-                    multiline_annotations.push((lo.file.clone(), ml.clone()));\n-                    AnnotationType::Multiline(ml)\n-                } else {\n-                    AnnotationType::Singleline\n-                };\n-                let ann = Annotation {\n-                    start_col: lo.col_display,\n-                    end_col: hi.col_display,\n-                    is_primary: span_label.is_primary,\n-                    label: span_label.label.clone(),\n-                    annotation_type: ann_type,\n-                };\n-\n-                if !ann.is_multiline() {\n-                    add_annotation_to_file(&mut output, lo.file, lo.line, ann);\n-                }\n-            }\n-        }\n-\n-        // Find overlapping multiline annotations, put them at different depths\n-        multiline_annotations.sort_by_key(|&(_, ref ml)| (ml.line_start, ml.line_end));\n-        for item in multiline_annotations.clone() {\n-            let ann = item.1;\n-            for item in multiline_annotations.iter_mut() {\n-                let ref mut a = item.1;\n-                // Move all other multiline annotations overlapping with this one\n-                // one level to the right.\n-                if !(ann.same_span(a)) &&\n-                    num_overlap(ann.line_start, ann.line_end, a.line_start, a.line_end, true)\n-                {\n-                    a.increase_depth();\n-                } else if ann.same_span(a) && &ann != a {\n-                    a.overlaps_exactly = true;\n-                } else {\n-                    break;\n-                }\n-            }\n-        }\n-\n-        let mut max_depth = 0;  // max overlapping multiline spans\n-        for (file, ann) in multiline_annotations {\n-            if ann.depth > max_depth {\n-                max_depth = ann.depth;\n-            }\n-            let mut end_ann = ann.as_end();\n-            if !ann.overlaps_exactly {\n-                // avoid output like\n-                //\n-                //  |        foo(\n-                //  |   _____^\n-                //  |  |_____|\n-                //  | ||         bar,\n-                //  | ||     );\n-                //  | ||      ^\n-                //  | ||______|\n-                //  |  |______foo\n-                //  |         baz\n-                //\n-                // and instead get\n-                //\n-                //  |       foo(\n-                //  |  _____^\n-                //  | |         bar,\n-                //  | |     );\n-                //  | |      ^\n-                //  | |      |\n-                //  | |______foo\n-                //  |        baz\n-                add_annotation_to_file(&mut output, file.clone(), ann.line_start, ann.as_start());\n-                // 4 is the minimum vertical length of a multiline span when presented: two lines\n-                // of code and two lines of underline. This is not true for the special case where\n-                // the beginning doesn't have an underline, but the current logic seems to be\n-                // working correctly.\n-                let middle = min(ann.line_start + 4, ann.line_end);\n-                for line in ann.line_start + 1..middle {\n-                    // Every `|` that joins the beginning of the span (`___^`) to the end (`|__^`).\n-                    add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n-                }\n-                if middle < ann.line_end - 1 {\n-                    for line in ann.line_end - 1..ann.line_end {\n-                        add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n-                    }\n-                }\n-            } else {\n-                end_ann.annotation_type = AnnotationType::Singleline;\n-            }\n-            add_annotation_to_file(&mut output, file, ann.line_end, end_ann);\n-        }\n-        for file_vec in output.iter_mut() {\n-            file_vec.multiline_depth = max_depth;\n-        }\n-        output\n-    }\n-\n     fn render_source_line(&self,\n                           buffer: &mut StyledBuffer,\n                           file: Lrc<SourceFile>,\n@@ -1093,9 +932,7 @@ impl EmitterWriter {\n             }\n         }\n \n-        // Preprocess all the annotations so that they are grouped by file and by line number\n-        // This helps us quickly iterate over the whole message (including secondary file spans)\n-        let mut annotated_files = self.preprocess_annotations(msp);\n+        let mut annotated_files = FileWithAnnotatedLines::collect_annotations(msp, &self.sm);\n \n         // Make sure our primary file comes first\n         let (primary_lo, sm) = if let (Some(sm), Some(ref primary_span)) =\n@@ -1503,6 +1340,176 @@ impl EmitterWriter {\n     }\n }\n \n+impl FileWithAnnotatedLines {\n+    /// Preprocess all the annotations so that they are grouped by file and by line number\n+    /// This helps us quickly iterate over the whole message (including secondary file spans)\n+    pub fn collect_annotations(\n+        msp: &MultiSpan,\n+        source_map: &Option<Lrc<SourceMapperDyn>>\n+    ) -> Vec<FileWithAnnotatedLines> {\n+        fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n+                                  file: Lrc<SourceFile>,\n+                                  line_index: usize,\n+                                  ann: Annotation) {\n+\n+            for slot in file_vec.iter_mut() {\n+                // Look through each of our files for the one we're adding to\n+                if slot.file.name == file.name {\n+                    // See if we already have a line for it\n+                    for line_slot in &mut slot.lines {\n+                        if line_slot.line_index == line_index {\n+                            line_slot.annotations.push(ann);\n+                            return;\n+                        }\n+                    }\n+                    // We don't have a line yet, create one\n+                    slot.lines.push(Line {\n+                        line_index,\n+                        annotations: vec![ann],\n+                    });\n+                    slot.lines.sort();\n+                    return;\n+                }\n+            }\n+            // This is the first time we're seeing the file\n+            file_vec.push(FileWithAnnotatedLines {\n+                file,\n+                lines: vec![Line {\n+                                line_index,\n+                                annotations: vec![ann],\n+                            }],\n+                multiline_depth: 0,\n+            });\n+        }\n+\n+        let mut output = vec![];\n+        let mut multiline_annotations = vec![];\n+\n+        if let Some(ref sm) = source_map {\n+            for span_label in msp.span_labels() {\n+                if span_label.span.is_dummy() {\n+                    continue;\n+                }\n+\n+                let lo = sm.lookup_char_pos(span_label.span.lo());\n+                let mut hi = sm.lookup_char_pos(span_label.span.hi());\n+\n+                // Watch out for \"empty spans\". If we get a span like 6..6, we\n+                // want to just display a `^` at 6, so convert that to\n+                // 6..7. This is degenerate input, but it's best to degrade\n+                // gracefully -- and the parser likes to supply a span like\n+                // that for EOF, in particular.\n+\n+                if lo.col_display == hi.col_display && lo.line == hi.line {\n+                    hi.col_display += 1;\n+                }\n+\n+                let ann_type = if lo.line != hi.line {\n+                    let ml = MultilineAnnotation {\n+                        depth: 1,\n+                        line_start: lo.line,\n+                        line_end: hi.line,\n+                        start_col: lo.col_display,\n+                        end_col: hi.col_display,\n+                        is_primary: span_label.is_primary,\n+                        label: span_label.label.clone(),\n+                        overlaps_exactly: false,\n+                    };\n+                    multiline_annotations.push((lo.file.clone(), ml.clone()));\n+                    AnnotationType::Multiline(ml)\n+                } else {\n+                    AnnotationType::Singleline\n+                };\n+                let ann = Annotation {\n+                    start_col: lo.col_display,\n+                    end_col: hi.col_display,\n+                    is_primary: span_label.is_primary,\n+                    label: span_label.label.clone(),\n+                    annotation_type: ann_type,\n+                };\n+\n+                if !ann.is_multiline() {\n+                    add_annotation_to_file(&mut output, lo.file, lo.line, ann);\n+                }\n+            }\n+        }\n+\n+        // Find overlapping multiline annotations, put them at different depths\n+        multiline_annotations.sort_by_key(|&(_, ref ml)| (ml.line_start, ml.line_end));\n+        for item in multiline_annotations.clone() {\n+            let ann = item.1;\n+            for item in multiline_annotations.iter_mut() {\n+                let ref mut a = item.1;\n+                // Move all other multiline annotations overlapping with this one\n+                // one level to the right.\n+                if !(ann.same_span(a)) &&\n+                    num_overlap(ann.line_start, ann.line_end, a.line_start, a.line_end, true)\n+                {\n+                    a.increase_depth();\n+                } else if ann.same_span(a) && &ann != a {\n+                    a.overlaps_exactly = true;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        let mut max_depth = 0;  // max overlapping multiline spans\n+        for (file, ann) in multiline_annotations {\n+            if ann.depth > max_depth {\n+                max_depth = ann.depth;\n+            }\n+            let mut end_ann = ann.as_end();\n+            if !ann.overlaps_exactly {\n+                // avoid output like\n+                //\n+                //  |        foo(\n+                //  |   _____^\n+                //  |  |_____|\n+                //  | ||         bar,\n+                //  | ||     );\n+                //  | ||      ^\n+                //  | ||______|\n+                //  |  |______foo\n+                //  |         baz\n+                //\n+                // and instead get\n+                //\n+                //  |       foo(\n+                //  |  _____^\n+                //  | |         bar,\n+                //  | |     );\n+                //  | |      ^\n+                //  | |      |\n+                //  | |______foo\n+                //  |        baz\n+                add_annotation_to_file(&mut output, file.clone(), ann.line_start, ann.as_start());\n+                // 4 is the minimum vertical length of a multiline span when presented: two lines\n+                // of code and two lines of underline. This is not true for the special case where\n+                // the beginning doesn't have an underline, but the current logic seems to be\n+                // working correctly.\n+                let middle = min(ann.line_start + 4, ann.line_end);\n+                for line in ann.line_start + 1..middle {\n+                    // Every `|` that joins the beginning of the span (`___^`) to the end (`|__^`).\n+                    add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n+                }\n+                if middle < ann.line_end - 1 {\n+                    for line in ann.line_end - 1..ann.line_end {\n+                        add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n+                    }\n+                }\n+            } else {\n+                end_ann.annotation_type = AnnotationType::Singleline;\n+            }\n+            add_annotation_to_file(&mut output, file, ann.line_end, end_ann);\n+        }\n+        for file_vec in output.iter_mut() {\n+            file_vec.multiline_depth = max_depth;\n+        }\n+        output\n+    }\n+}\n+\n fn draw_col_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n     buffer.puts(line, col, \"| \", Style::LineNumber);\n }"}, {"sha": "f464e58e36b15ed11a88b5c2dca0f98673efc119", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -1616,7 +1616,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             );\n \n                             // Find the local from the operand.\n-                            let assigned_from_local = match assigned_from.local() {\n+                            let assigned_from_local = match assigned_from.local_or_deref_local() {\n                                 Some(local) => local,\n                                 None => continue,\n                             };\n@@ -1672,7 +1672,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     );\n \n                     // Find the local from the rvalue.\n-                    let assigned_from_local = match assigned_from.local() {\n+                    let assigned_from_local = match assigned_from.local_or_deref_local() {\n                         Some(local) => local,\n                         None => continue,\n                     };\n@@ -1735,7 +1735,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         assigned_from,\n                     );\n \n-                    if let Some(assigned_from_local) = assigned_from.local() {\n+                    if let Some(assigned_from_local) = assigned_from.local_or_deref_local() {\n                         debug!(\n                             \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n                             assigned_from_local,"}, {"sha": "5a22c81a5d0578f1d83b52458e1c9b279f73b2f0", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -37,15 +37,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         diag: &mut DiagnosticBuilder<'_>,\n     ) {\n         debug!(\"add_moved_or_invoked_closure_note: location={:?} place={:?}\", location, place);\n-        let mut target = place.local();\n+        let mut target = place.local_or_deref_local();\n         for stmt in &self.mir[location.block].statements[location.statement_index..] {\n             debug!(\"add_moved_or_invoked_closure_note: stmt={:?} target={:?}\", stmt, target);\n             if let StatementKind::Assign(into, box Rvalue::Use(from)) = &stmt.kind {\n                 debug!(\"add_fnonce_closure_note: into={:?} from={:?}\", into, from);\n                 match from {\n                     Operand::Copy(ref place) |\n-                    Operand::Move(ref place) if target == place.local() =>\n-                        target = into.local(),\n+                    Operand::Move(ref place) if target == place.local_or_deref_local() =>\n+                        target = into.local_or_deref_local(),\n                     _ => {},\n                 }\n             }\n@@ -69,8 +69,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             if self.infcx.tcx.parent(id) == self.infcx.tcx.lang_items().fn_once_trait() {\n                 let closure = match args.first() {\n                     Some(Operand::Copy(ref place)) |\n-                    Some(Operand::Move(ref place)) if target == place.local() =>\n-                        place.local().unwrap(),\n+                    Some(Operand::Move(ref place)) if target == place.local_or_deref_local() =>\n+                        place.local_or_deref_local().unwrap(),\n                     _ => return,\n                 };\n "}, {"sha": "685db7713cac16dd5f3e713e3b5db6e44d02e74e", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -528,7 +528,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }) => {\n                 // Not projected from the implicit `self` in a closure.\n                 debug_assert!(\n-                    match base.local() {\n+                    match base.local_or_deref_local() {\n                         Some(local) => local == Local::new(1),\n                         None => false,\n                     },"}, {"sha": "0fb66032a171dd085f299a8e860c138289d4083e", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -46,8 +46,10 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n                          sets: &mut BlockSets<'_, Local>,\n                          loc: Location) {\n         match &self.mir[loc.block].terminator().kind {\n-            TerminatorKind::Drop { location, .. } => if let Some(l) = location.local() {\n-                sets.kill(l);\n+            TerminatorKind::Drop { location, .. } => {\n+                if let Some(l) = location.local_or_deref_local() {\n+                    sets.kill(l);\n+                }\n             }\n             _ => (),\n         }"}, {"sha": "a08c028390bf7a86b1184a5a118b8b47ed882111", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -1703,8 +1703,13 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_trait_or_impl_item(&self, hir_id: hir::HirId, assoc_item_kind: AssocItemKind,\n-                                defaultness: hir::Defaultness, vis: ty::Visibility) {\n+    fn check_assoc_item(\n+        &self,\n+        hir_id: hir::HirId,\n+        assoc_item_kind: AssocItemKind,\n+        defaultness: hir::Defaultness,\n+        vis: ty::Visibility,\n+    ) {\n         let mut check = self.check(hir_id, vis);\n \n         let (check_ty, is_assoc_ty) = match assoc_item_kind {\n@@ -1754,8 +1759,12 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for trait_item_ref in trait_item_refs {\n-                    self.check_trait_or_impl_item(trait_item_ref.id.hir_id, trait_item_ref.kind,\n-                                                  trait_item_ref.defaultness, item_visibility);\n+                    self.check_assoc_item(\n+                        trait_item_ref.id.hir_id,\n+                        trait_item_ref.kind,\n+                        trait_item_ref.defaultness,\n+                        item_visibility,\n+                    );\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n@@ -1803,8 +1812,12 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                     } else {\n                         impl_vis\n                     };\n-                    self.check_trait_or_impl_item(impl_item_ref.id.hir_id, impl_item_ref.kind,\n-                                                  impl_item_ref.defaultness, impl_item_vis);\n+                    self.check_assoc_item(\n+                        impl_item_ref.id.hir_id,\n+                        impl_item_ref.kind,\n+                        impl_item_ref.defaultness,\n+                        impl_item_vis,\n+                    );\n                 }\n             }\n         }"}, {"sha": "9b7b44025c13f73043590e2edca2d2dddbeea68a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -860,7 +860,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             FnKind::ItemFn(_, ref header, ..) =>\n                 (FnItemRibKind, &header.asyncness.node),\n             FnKind::Method(_, ref sig, _, _) =>\n-                (TraitOrImplItemRibKind, &sig.header.asyncness.node),\n+                (AssocItemRibKind, &sig.header.asyncness.node),\n             FnKind::Closure(_) =>\n                 // Async closures aren't resolved through `visit_fn`-- they're\n                 // processed separately\n@@ -1033,7 +1033,7 @@ enum RibKind<'a> {\n     /// methods or associated types. Allow references to ty params that impl or trait\n     /// binds. Disallow any other upvars (including other ty params that are\n     /// upvars).\n-    TraitOrImplItemRibKind,\n+    AssocItemRibKind,\n \n     /// We passed through a function definition. Disallow upvars.\n     /// Permit only those const parameters that are specified in the function's generics.\n@@ -2612,7 +2612,7 @@ impl<'a> Resolver<'a> {\n \n                         for trait_item in trait_items {\n                             let generic_params = HasGenericParams(&trait_item.generics,\n-                                                                    TraitOrImplItemRibKind);\n+                                                                    AssocItemRibKind);\n                             this.with_generic_param_rib(generic_params, |this| {\n                                 match trait_item.node {\n                                     TraitItemKind::Const(ref ty, ref default) => {\n@@ -2899,7 +2899,7 @@ impl<'a> Resolver<'a> {\n \n                                     // We also need a new scope for the impl item type parameters.\n                                     let generic_params = HasGenericParams(&impl_item.generics,\n-                                                                          TraitOrImplItemRibKind);\n+                                                                          AssocItemRibKind);\n                                     this.with_generic_param_rib(generic_params, |this| {\n                                         use self::ResolutionError::*;\n                                         match impl_item.node {\n@@ -4074,7 +4074,7 @@ impl<'a> Resolver<'a> {\n                                 seen.insert(node_id, depth);\n                             }\n                         }\n-                        ItemRibKind | FnItemRibKind | TraitOrImplItemRibKind => {\n+                        ItemRibKind | FnItemRibKind | AssocItemRibKind => {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n@@ -4103,7 +4103,7 @@ impl<'a> Resolver<'a> {\n             Res::Def(DefKind::TyParam, _) | Res::SelfTy(..) => {\n                 for rib in ribs {\n                     match rib.kind {\n-                        NormalRibKind | TraitOrImplItemRibKind | ClosureRibKind(..) |\n+                        NormalRibKind | AssocItemRibKind | ClosureRibKind(..) |\n                         ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind |\n                         ConstantItemRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue."}, {"sha": "aaf628e6c260fea2ec16fcbe7cc948d20fa00a2b", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -158,7 +158,6 @@ impl<R> BufReader<R> {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// # #![feature(bufreader_buffer)]\n     /// use std::io::{BufReader, BufRead};\n     /// use std::fs::File;\n     ///\n@@ -173,7 +172,7 @@ impl<R> BufReader<R> {\n     ///     Ok(())\n     /// }\n     /// ```\n-    #[unstable(feature = \"bufreader_buffer\", issue = \"45323\")]\n+    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n     pub fn buffer(&self) -> &[u8] {\n         &self.buf[self.pos..self.cap]\n     }\n@@ -552,7 +551,6 @@ impl<W: Write> BufWriter<W> {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// # #![feature(bufreader_buffer)]\n     /// use std::io::BufWriter;\n     /// use std::net::TcpStream;\n     ///\n@@ -561,7 +559,7 @@ impl<W: Write> BufWriter<W> {\n     /// // See how many bytes are currently buffered\n     /// let bytes_buffered = buf_writer.buffer().len();\n     /// ```\n-    #[unstable(feature = \"bufreader_buffer\", issue = \"45323\")]\n+    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n     pub fn buffer(&self) -> &[u8] {\n         &self.buf\n     }"}, {"sha": "f1b1656745e7c487b8ba1c75c69a3487e34a16db", "filename": "src/test/run-pass/impl-trait/example-calendar.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -180,6 +180,10 @@ impl std::iter::Step for NaiveDate {\n     fn add_usize(&self, _: usize) -> Option<Self> {\n         unimplemented!()\n     }\n+\n+    fn sub_usize(&self, _: usize) -> Option<Self> {\n+        unimplemented!()\n+    }\n }\n \n #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]"}]}