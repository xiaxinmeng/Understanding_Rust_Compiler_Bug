{"sha": "fbdff56f4ba2383c9d4bea58531dea66f5b2afa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZGZmNTZmNGJhMjM4M2M5ZDRiZWE1ODUzMWRlYTY2ZjViMmFmYTY=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-01T03:51:07Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-10T21:48:58Z"}, "message": "Use DataflowResultsConsumer and remove dataflow::for_each_location", "tree": {"sha": "f237220bd72e6d321687d2dd95edb18a0a825e90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f237220bd72e6d321687d2dd95edb18a0a825e90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbdff56f4ba2383c9d4bea58531dea66f5b2afa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbdff56f4ba2383c9d4bea58531dea66f5b2afa6", "html_url": "https://github.com/rust-lang/rust/commit/fbdff56f4ba2383c9d4bea58531dea66f5b2afa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbdff56f4ba2383c9d4bea58531dea66f5b2afa6/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6680d03d14c60e7e7d4b7e0347b8829151855854", "url": "https://api.github.com/repos/rust-lang/rust/commits/6680d03d14c60e7e7d4b7e0347b8829151855854", "html_url": "https://github.com/rust-lang/rust/commit/6680d03d14c60e7e7d4b7e0347b8829151855854"}], "stats": {"total": 187, "additions": 94, "deletions": 93}, "files": [{"sha": "9cba34b425350bbcb8e4e5bb6512eb8bd1b3914c", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbdff56f4ba2383c9d4bea58531dea66f5b2afa6/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdff56f4ba2383c9d4bea58531dea66f5b2afa6/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=fbdff56f4ba2383c9d4bea58531dea66f5b2afa6", "patch": "@@ -131,6 +131,11 @@ where\n         curr_state.subtract(&self.stmt_kill);\n         f(curr_state.iter());\n     }\n+\n+    /// Returns a bitset of the elements present in the current state.\n+    pub fn as_dense(&self) -> &BitSet<BD::Idx> {\n+        &self.curr_state\n+    }\n }\n \n impl<'tcx, BD> FlowsAtLocation for FlowAtLocation<'tcx, BD>"}, {"sha": "8e2068269ceaa883bd72a16ca710f746b406220f", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fbdff56f4ba2383c9d4bea58531dea66f5b2afa6/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdff56f4ba2383c9d4bea58531dea66f5b2afa6/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=fbdff56f4ba2383c9d4bea58531dea66f5b2afa6", "patch": "@@ -380,62 +380,6 @@ pub fn state_for_location<'tcx, T: BitDenotation<'tcx>>(loc: Location,\n     gen_set.to_dense()\n }\n \n-/// Calls `f` with the dataflow state at every location in `mir`.\n-/// Ignores blocks that terminate in `unreachable`.\n-pub fn for_each_location<'tcx, T: BitDenotation<'tcx>>(\n-    mir: &Body<'tcx>,\n-    analysis: &T,\n-    result: &DataflowResults<'tcx, T>,\n-    mut f: impl FnMut(&HybridBitSet<T::Idx>, Location)\n-) {\n-    for (block, bb_data) in mir.basic_blocks().iter_enumerated() {\n-        if bb_data.is_unreachable() {\n-            continue;\n-        }\n-        for_each_block_location(mir, block, bb_data, analysis, result, &mut f);\n-    }\n-}\n-\n-fn for_each_block_location<'tcx, T: BitDenotation<'tcx>>(\n-    mir: &Body<'tcx>,\n-    block: BasicBlock,\n-    bb_data: &BasicBlockData<'tcx>,\n-    analysis: &T,\n-    result: &DataflowResults<'tcx, T>,\n-    f: &mut impl FnMut(&HybridBitSet<T::Idx>, Location)\n-) {\n-    let statements = &bb_data.statements;\n-\n-    let mut on_entry = result.sets().on_entry_set_for(block.index()).to_owned();\n-    let mut kill_set = on_entry.to_hybrid();\n-    let mut gen_set = kill_set.clone();\n-\n-    {\n-        let mut sets = BlockSets {\n-            on_entry: &mut on_entry,\n-            kill_set: &mut kill_set,\n-            gen_set: &mut gen_set,\n-        };\n-        // FIXME: This location is technically wrong, but there isn't a way to\n-        // denote the start of a block.\n-        f(sets.gen_set, Location { block, statement_index: 0 });\n-\n-        for statement_index in 0..statements.len() {\n-            let loc = Location { block, statement_index };\n-            analysis.before_statement_effect(&mut sets, loc);\n-            f(sets.gen_set, loc);\n-            analysis.statement_effect(&mut sets, loc);\n-            f(sets.gen_set, loc);\n-        }\n-\n-        let term_loc = Location { block, statement_index: mir[block].statements.len() };\n-        analysis.before_terminator_effect(&mut sets, term_loc);\n-        f(sets.gen_set, term_loc);\n-        analysis.terminator_effect(&mut sets, term_loc);\n-        f(sets.gen_set, term_loc);\n-    }\n-}\n-\n pub struct DataflowAnalysis<'a, 'tcx: 'a, O> where O: BitDenotation<'tcx>\n {\n     flow_state: DataflowState<'tcx, O>,"}, {"sha": "9dc9f8fdf72a91b79b920d3425950a55038346e7", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 89, "deletions": 37, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/fbdff56f4ba2383c9d4bea58531dea66f5b2afa6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdff56f4ba2383c9d4bea58531dea66f5b2afa6/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=fbdff56f4ba2383c9d4bea58531dea66f5b2afa6", "patch": "@@ -66,8 +66,8 @@ use std::mem;\n use crate::transform::{MirPass, MirSource};\n use crate::transform::simplify;\n use crate::transform::no_landing_pads::no_landing_pads;\n-use crate::dataflow::{DataflowResults};\n-use crate::dataflow::{do_dataflow, DebugFormatted, state_for_location, for_each_location};\n+use crate::dataflow::{DataflowResults, DataflowResultsConsumer, FlowAtLocation};\n+use crate::dataflow::{do_dataflow, DebugFormatted, state_for_location};\n use crate::dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals};\n use crate::util::dump_mir;\n use crate::util::liveness;\n@@ -541,6 +541,25 @@ fn locals_live_across_suspend_points(\n     }\n }\n \n+/// Renumbers the items present in `stored_locals` and applies the renumbering\n+/// to 'input`.\n+///\n+/// For example, if `stored_locals = [1, 3, 5]`, this would be renumbered to\n+/// `[0, 1, 2]`. Thus, if `input = [3, 5]` we would return `[1, 2]`.\n+fn renumber_bitset(input: &BitSet<Local>, stored_locals: &liveness::LiveVarSet)\n+-> BitSet<GeneratorSavedLocal> {\n+    assert!(stored_locals.superset(&input), \"{:?} not a superset of {:?}\", stored_locals, input);\n+    let mut out = BitSet::new_empty(stored_locals.count());\n+    for (idx, local) in stored_locals.iter().enumerate() {\n+        let saved_local = GeneratorSavedLocal::from(idx);\n+        if input.contains(local) {\n+            out.insert(saved_local);\n+        }\n+    }\n+    debug!(\"renumber_bitset({:?}, {:?}) => {:?}\", input, stored_locals, out);\n+    out\n+}\n+\n /// For every saved local, looks for which locals are StorageLive at the same\n /// time. Generates a bitset for every local of all the other locals that may be\n /// StorageLive simultaneously with that local. This is used in the layout\n@@ -550,7 +569,7 @@ fn compute_storage_conflicts(\n     stored_locals: &liveness::LiveVarSet,\n     ignored: &StorageIgnored,\n     storage_live: DataflowResults<'tcx, MaybeStorageLive<'mir, 'tcx>>,\n-    storage_live_analysis: MaybeStorageLive<'mir, 'tcx>,\n+    _storage_live_analysis: MaybeStorageLive<'mir, 'tcx>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n     assert_eq!(body.local_decls.len(), ignored.0.domain_size());\n     assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n@@ -562,26 +581,18 @@ fn compute_storage_conflicts(\n     let mut ineligible_locals = ignored.0.clone();\n     ineligible_locals.intersect(&stored_locals);\n \n-    // Of our remaining candidates, find out if any have overlapping storage\n-    // liveness. Those that do must be in the same variant to remain candidates.\n-    // FIXME(tmandry): Consider using sparse bitsets here once we have good\n-    // benchmarks for generators.\n-    let mut local_conflicts: BitMatrix<Local, Local> =\n-        BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len());\n-\n-    for_each_location(body, &storage_live_analysis, &storage_live, |state, loc| {\n-        let mut eligible_storage_live = state.clone().to_dense();\n-        eligible_storage_live.intersect(&stored_locals);\n-\n-        for local in eligible_storage_live.iter() {\n-            local_conflicts.union_row_with(&eligible_storage_live, local);\n-        }\n-\n-        if eligible_storage_live.count() > 1 {\n-            trace!(\"at {:?}, eligible_storage_live={:?}\", loc, eligible_storage_live);\n-        }\n-    });\n+    // Compute the storage conflicts for all eligible locals.\n+    let mut visitor = StorageConflictVisitor {\n+        body,\n+        stored_locals: &stored_locals,\n+        local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len())\n+    };\n+    let mut state = FlowAtLocation::new(storage_live);\n+    visitor.analyze_results(&mut state);\n+    let local_conflicts = visitor.local_conflicts;\n \n+    // Compress the matrix using only stored locals (Local -> GeneratorSavedLocal).\n+    //\n     // NOTE: Today we store a full conflict bitset for every local. Technically\n     // this is twice as many bits as we need, since the relation is symmetric.\n     // However, in practice these bitsets are not usually large. The layout code\n@@ -606,23 +617,64 @@ fn compute_storage_conflicts(\n     storage_conflicts\n }\n \n-/// Renumbers the items present in `stored_locals` and applies the renumbering\n-/// to 'input`.\n-///\n-/// For example, if `stored_locals = [1, 3, 5]`, this would be renumbered to\n-/// `[0, 1, 2]`. Thus, if `input = [3, 5]` we would return `[1, 2]`.\n-fn renumber_bitset(input: &BitSet<Local>, stored_locals: &liveness::LiveVarSet)\n--> BitSet<GeneratorSavedLocal> {\n-    assert!(stored_locals.superset(&input), \"{:?} not a superset of {:?}\", stored_locals, input);\n-    let mut out = BitSet::new_empty(stored_locals.count());\n-    for (idx, local) in stored_locals.iter().enumerate() {\n-        let saved_local = GeneratorSavedLocal::from(idx);\n-        if input.contains(local) {\n-            out.insert(saved_local);\n+struct StorageConflictVisitor<'body, 'tcx: 'body, 's> {\n+    body: &'body Body<'tcx>,\n+    stored_locals: &'s liveness::LiveVarSet,\n+    // FIXME(tmandry): Consider using sparse bitsets here once we have good\n+    // benchmarks for generators.\n+    local_conflicts: BitMatrix<Local, Local>,\n+}\n+\n+impl<'body, 'tcx: 'body, 's> DataflowResultsConsumer<'body, 'tcx>\n+for StorageConflictVisitor<'body, 'tcx, 's> {\n+    type FlowState = FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>;\n+\n+    fn body(&self) -> &'body Body<'tcx> {\n+        self.body\n+    }\n+\n+    fn visit_block_entry(&mut self,\n+                         block: BasicBlock,\n+                         flow_state: &Self::FlowState) {\n+        // statement_index is only used for logging, so this is fine.\n+        self.apply_state(flow_state, Location { block, statement_index: 0 });\n+    }\n+\n+    fn visit_statement_entry(&mut self,\n+                             loc: Location,\n+                             _stmt: &Statement<'tcx>,\n+                             flow_state: &Self::FlowState) {\n+        self.apply_state(flow_state, loc);\n+    }\n+\n+    fn visit_terminator_entry(&mut self,\n+                              loc: Location,\n+                              _term: &Terminator<'tcx>,\n+                              flow_state: &Self::FlowState) {\n+        self.apply_state(flow_state, loc);\n+    }\n+}\n+\n+impl<'body, 'tcx: 'body, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n+    fn apply_state(&mut self,\n+                   flow_state: &FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>,\n+                   loc: Location) {\n+        // Ignore unreachable blocks.\n+        if self.body.basic_blocks()[loc.block].is_unreachable() {\n+            return;\n+        }\n+\n+        let mut eligible_storage_live = flow_state.as_dense().clone();\n+        eligible_storage_live.intersect(&self.stored_locals);\n+\n+        for local in eligible_storage_live.iter() {\n+            self.local_conflicts.union_row_with(&eligible_storage_live, local);\n+        }\n+\n+        if eligible_storage_live.count() > 1 {\n+            trace!(\"at {:?}, eligible_storage_live={:?}\", loc, eligible_storage_live);\n         }\n     }\n-    debug!(\"renumber_bitset({:?}, {:?}) => {:?}\", input, stored_locals, out);\n-    out\n }\n \n fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}]}