{"sha": "3ac7ca4c197ccbeb8cf666e298afe76f736dd97e", "node_id": "C_kwDOAAsO6NoAKDNhYzdjYTRjMTk3Y2NiZWI4Y2Y2NjZlMjk4YWZlNzZmNzM2ZGQ5N2U", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-21T14:34:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-21T14:34:02Z"}, "message": "Auto merge of #2075 - y86-dev:master, r=RalfJung\n\nAllow to track multiple alloc-ids, call-ids and pointer tags\n\nCloses #2073.", "tree": {"sha": "ad076468e29eba63bd3f88f6cbaf37da0538be0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad076468e29eba63bd3f88f6cbaf37da0538be0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e", "html_url": "https://github.com/rust-lang/rust/commit/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e419e4ff6a4418a1011c1d6abda751310b8574c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e419e4ff6a4418a1011c1d6abda751310b8574c", "html_url": "https://github.com/rust-lang/rust/commit/2e419e4ff6a4418a1011c1d6abda751310b8574c"}, {"sha": "b472ef5bd808a38e808a3ed66f4cf67391829448", "url": "https://api.github.com/repos/rust-lang/rust/commits/b472ef5bd808a38e808a3ed66f4cf67391829448", "html_url": "https://github.com/rust-lang/rust/commit/b472ef5bd808a38e808a3ed66f4cf67391829448"}], "stats": {"total": 150, "additions": 87, "deletions": 63}, "files": [{"sha": "ca14f02d86aef2fc4807b332cac022a058b0cfbc", "filename": "README.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=3ac7ca4c197ccbeb8cf666e298afe76f736dd97e", "patch": "@@ -314,16 +314,20 @@ environment variable:\n   ensure alignment.  (The standard library `align_to` method works fine in both\n   modes; under symbolic alignment it only fills the middle slice when the\n   allocation guarantees sufficient alignment.)\n-* `-Zmiri-track-alloc-id=<id>` shows a backtrace when the given allocation is\n+* `-Zmiri-track-alloc-id=<id1>,<id2>,...` shows a backtrace when the given allocations are\n   being allocated or freed.  This helps in debugging memory leaks and\n-  use after free bugs.\n-* `-Zmiri-track-call-id=<id>` shows a backtrace when the given call id is\n+  use after free bugs. Specifying this argument multiple times does not overwrite the previous\n+  values, instead it appends its values to the list. Listing an id multiple times has no effect.\n+* `-Zmiri-track-call-id=<id1>,<id2>,...` shows a backtrace when the given call ids are\n   assigned to a stack frame.  This helps in debugging UB related to Stacked\n-  Borrows \"protectors\".\n-* `-Zmiri-track-pointer-tag=<tag>` shows a backtrace when the given pointer tag\n+  Borrows \"protectors\". Specifying this argument multiple times does not overwrite the previous\n+  values, instead it appends its values to the list. Listing an id multiple times has no effect.\n+* `-Zmiri-track-pointer-tag=<tag1>,<tag2>,...` shows a backtrace when a given pointer tag\n   is popped from a borrow stack (which is where the tag becomes invalid and any\n   future use of it will error).  This helps you in finding out why UB is\n   happening and where in your code would be a good place to look for it.\n+  Specifying this argument multiple times does not overwrite the previous\n+  values, instead it appends its values to the list. Listing a tag multiple times has no effect.\n * `-Zmiri-tag-raw-pointers` makes Stacked Borrows assign proper tags even for raw pointers. This can\n   make valid code using int-to-ptr casts fail to pass the checks, but also can help identify latent\n   aliasing issues in code that Miri accepts by default. You can recognize false positives by"}, {"sha": "e4d0af4313129a7d32bf98f78d36bec693bdba52", "filename": "src/bin/miri.rs", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=3ac7ca4c197ccbeb8cf666e298afe76f736dd97e", "patch": "@@ -251,6 +251,13 @@ fn run_compiler(\n     std::process::exit(exit_code)\n }\n \n+/// Parses a comma separated list of `T` from the given string:\n+///\n+/// `<value1>,<value2>,<value3>,...`\n+fn parse_comma_list<T: FromStr>(input: &str) -> Result<Vec<T>, T::Err> {\n+    input.split(',').map(str::parse::<T>).collect()\n+}\n+\n fn main() {\n     rustc_driver::install_ice_hook();\n \n@@ -397,46 +404,55 @@ fn main() {\n                         .push(arg.strip_prefix(\"-Zmiri-env-forward=\").unwrap().to_owned());\n                 }\n                 arg if arg.starts_with(\"-Zmiri-track-pointer-tag=\") => {\n-                    let id: u64 =\n-                        match arg.strip_prefix(\"-Zmiri-track-pointer-tag=\").unwrap().parse() {\n-                            Ok(id) => id,\n-                            Err(err) =>\n-                                panic!(\n-                                    \"-Zmiri-track-pointer-tag requires a valid `u64` argument: {}\",\n-                                    err\n-                                ),\n-                        };\n-                    if let Some(id) = miri::PtrId::new(id) {\n-                        miri_config.tracked_pointer_tag = Some(id);\n-                    } else {\n-                        panic!(\"-Zmiri-track-pointer-tag requires a nonzero argument\");\n+                    let ids: Vec<u64> = match parse_comma_list(\n+                        arg.strip_prefix(\"-Zmiri-track-pointer-tag=\").unwrap(),\n+                    ) {\n+                        Ok(ids) => ids,\n+                        Err(err) =>\n+                            panic!(\n+                                \"-Zmiri-track-pointer-tag requires a comma separated list of valid `u64` arguments: {}\",\n+                                err\n+                            ),\n+                    };\n+                    for id in ids.into_iter().map(miri::PtrId::new) {\n+                        if let Some(id) = id {\n+                            miri_config.tracked_pointer_tags.insert(id);\n+                        } else {\n+                            panic!(\"-Zmiri-track-pointer-tag requires nonzero arguments\");\n+                        }\n                     }\n                 }\n                 arg if arg.starts_with(\"-Zmiri-track-call-id=\") => {\n-                    let id: u64 = match arg.strip_prefix(\"-Zmiri-track-call-id=\").unwrap().parse() {\n-                        Ok(id) => id,\n+                    let ids: Vec<u64> = match parse_comma_list(\n+                        arg.strip_prefix(\"-Zmiri-track-call-id=\").unwrap(),\n+                    ) {\n+                        Ok(ids) => ids,\n                         Err(err) =>\n-                            panic!(\"-Zmiri-track-call-id requires a valid `u64` argument: {}\", err),\n+                            panic!(\n+                                \"-Zmiri-track-call-id requires a comma separated list of valid `u64` arguments: {}\",\n+                                err\n+                            ),\n                     };\n-                    if let Some(id) = miri::CallId::new(id) {\n-                        miri_config.tracked_call_id = Some(id);\n-                    } else {\n-                        panic!(\"-Zmiri-track-call-id requires a nonzero argument\");\n+                    for id in ids.into_iter().map(miri::CallId::new) {\n+                        if let Some(id) = id {\n+                            miri_config.tracked_call_ids.insert(id);\n+                        } else {\n+                            panic!(\"-Zmiri-track-call-id requires a nonzero argument\");\n+                        }\n                     }\n                 }\n                 arg if arg.starts_with(\"-Zmiri-track-alloc-id=\") => {\n-                    let id = match arg\n-                        .strip_prefix(\"-Zmiri-track-alloc-id=\")\n-                        .unwrap()\n-                        .parse()\n-                        .ok()\n-                        .and_then(NonZeroU64::new)\n-                    {\n-                        Some(id) => id,\n-                        None =>\n-                            panic!(\"-Zmiri-track-alloc-id requires a valid non-zero `u64` argument\"),\n+                    let ids: Vec<miri::AllocId> = match parse_comma_list::<NonZeroU64>(\n+                        arg.strip_prefix(\"-Zmiri-track-alloc-id=\").unwrap(),\n+                    ) {\n+                        Ok(ids) => ids.into_iter().map(miri::AllocId).collect(),\n+                        Err(err) =>\n+                            panic!(\n+                                \"-Zmiri-track-alloc-id requires a comma separated list of valid non-zero `u64` arguments: {}\",\n+                                err\n+                            ),\n                     };\n-                    miri_config.tracked_alloc_id = Some(miri::AllocId(id));\n+                    miri_config.tracked_alloc_ids.extend(ids);\n                 }\n                 arg if arg.starts_with(\"-Zmiri-compare-exchange-weak-failure-rate=\") => {\n                     let rate = match arg"}, {"sha": "f8d23cb8279cde8ea0736eff82e75bfc628aa048", "filename": "src/eval.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=3ac7ca4c197ccbeb8cf666e298afe76f736dd97e", "patch": "@@ -15,6 +15,8 @@ use rustc_target::spec::abi::Abi;\n \n use rustc_session::config::EntryFnType;\n \n+use std::collections::HashSet;\n+\n use crate::*;\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -91,12 +93,12 @@ pub struct MiriConfig {\n     pub args: Vec<String>,\n     /// The seed to use when non-determinism or randomness are required (e.g. ptr-to-int cast, `getrandom()`).\n     pub seed: Option<u64>,\n-    /// The stacked borrows pointer id to report about\n-    pub tracked_pointer_tag: Option<PtrId>,\n-    /// The stacked borrows call ID to report about\n-    pub tracked_call_id: Option<CallId>,\n-    /// The allocation id to report about.\n-    pub tracked_alloc_id: Option<AllocId>,\n+    /// The stacked borrows pointer ids to report about\n+    pub tracked_pointer_tags: HashSet<PtrId>,\n+    /// The stacked borrows call IDs to report about\n+    pub tracked_call_ids: HashSet<CallId>,\n+    /// The allocation ids to report about.\n+    pub tracked_alloc_ids: HashSet<AllocId>,\n     /// Whether to track raw pointers in stacked borrows.\n     pub tag_raw: bool,\n     /// Determine if data race detection should be enabled\n@@ -130,9 +132,9 @@ impl Default for MiriConfig {\n             forwarded_env_vars: vec![],\n             args: vec![],\n             seed: None,\n-            tracked_pointer_tag: None,\n-            tracked_call_id: None,\n-            tracked_alloc_id: None,\n+            tracked_pointer_tags: HashSet::default(),\n+            tracked_call_ids: HashSet::default(),\n+            tracked_alloc_ids: HashSet::default(),\n             tag_raw: false,\n             data_race_detector: true,\n             cmpxchg_weak_failure_rate: 0.8,"}, {"sha": "c0f833f17610a3a3c01cf42e6dc928afde4d00b2", "filename": "src/machine.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=3ac7ca4c197ccbeb8cf666e298afe76f736dd97e", "patch": "@@ -3,6 +3,7 @@\n \n use std::borrow::Cow;\n use std::cell::RefCell;\n+use std::collections::HashSet;\n use std::fmt;\n use std::num::NonZeroU64;\n use std::time::Instant;\n@@ -281,9 +282,9 @@ pub struct Evaluator<'mir, 'tcx> {\n     /// Needs to be queried by ptr_to_int, hence needs interior mutability.\n     pub(crate) rng: RefCell<StdRng>,\n \n-    /// An allocation ID to report when it is being allocated\n+    /// The allocation IDs to report when they are being allocated\n     /// (helps for debugging memory leaks and use after free bugs).\n-    tracked_alloc_id: Option<AllocId>,\n+    tracked_alloc_ids: HashSet<AllocId>,\n \n     /// Controls whether alignment of memory accesses is being checked.\n     pub(crate) check_alignment: AlignmentCheck,\n@@ -303,8 +304,8 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n         let rng = StdRng::seed_from_u64(config.seed.unwrap_or(0));\n         let stacked_borrows = if config.stacked_borrows {\n             Some(RefCell::new(stacked_borrows::GlobalStateInner::new(\n-                config.tracked_pointer_tag,\n-                config.tracked_call_id,\n+                config.tracked_pointer_tags.clone(),\n+                config.tracked_call_ids.clone(),\n                 config.tag_raw,\n             )))\n         } else {\n@@ -340,7 +341,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             local_crates,\n             extern_statics: FxHashMap::default(),\n             rng: RefCell::new(rng),\n-            tracked_alloc_id: config.tracked_alloc_id,\n+            tracked_alloc_ids: config.tracked_alloc_ids.clone(),\n             check_alignment: config.check_alignment,\n             cmpxchg_weak_failure_rate: config.cmpxchg_weak_failure_rate,\n         }\n@@ -560,7 +561,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n     ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>> {\n-        if Some(id) == ecx.machine.tracked_alloc_id {\n+        if ecx.machine.tracked_alloc_ids.contains(&id) {\n             register_diagnostic(NonHaltingDiagnostic::CreatedAlloc(id));\n         }\n \n@@ -669,7 +670,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         (alloc_id, tag): (AllocId, Self::TagExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n-        if Some(alloc_id) == machine.tracked_alloc_id {\n+        if machine.tracked_alloc_ids.contains(&alloc_id) {\n             register_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {"}, {"sha": "9d175e9c4d1675352eccf4d31ba9a0450f6dfb7b", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac7ca4c197ccbeb8cf666e298afe76f736dd97e/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=3ac7ca4c197ccbeb8cf666e298afe76f736dd97e", "patch": "@@ -15,6 +15,7 @@ use rustc_middle::ty::{\n };\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::Size;\n+use std::collections::HashSet;\n \n use crate::*;\n \n@@ -104,10 +105,10 @@ pub struct GlobalStateInner {\n     next_call_id: CallId,\n     /// Those call IDs corresponding to functions that are still running.\n     active_calls: FxHashSet<CallId>,\n-    /// The pointer id to trace\n-    tracked_pointer_tag: Option<PtrId>,\n-    /// The call id to trace\n-    tracked_call_id: Option<CallId>,\n+    /// The pointer ids to trace\n+    tracked_pointer_tags: HashSet<PtrId>,\n+    /// The call ids to trace\n+    tracked_call_ids: HashSet<CallId>,\n     /// Whether to track raw pointers.\n     tag_raw: bool,\n }\n@@ -158,24 +159,24 @@ impl fmt::Display for RefKind {\n /// Utilities for initialization and ID generation\n impl GlobalStateInner {\n     pub fn new(\n-        tracked_pointer_tag: Option<PtrId>,\n-        tracked_call_id: Option<CallId>,\n+        tracked_pointer_tags: HashSet<PtrId>,\n+        tracked_call_ids: HashSet<CallId>,\n         tag_raw: bool,\n     ) -> Self {\n         GlobalStateInner {\n             next_ptr_id: NonZeroU64::new(1).unwrap(),\n             base_ptr_ids: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n             active_calls: FxHashSet::default(),\n-            tracked_pointer_tag,\n-            tracked_call_id,\n+            tracked_pointer_tags,\n+            tracked_call_ids,\n             tag_raw,\n         }\n     }\n \n     fn new_ptr(&mut self) -> PtrId {\n         let id = self.next_ptr_id;\n-        if Some(id) == self.tracked_pointer_tag {\n+        if self.tracked_pointer_tags.contains(&id) {\n             register_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(id));\n         }\n         self.next_ptr_id = NonZeroU64::new(id.get() + 1).unwrap();\n@@ -185,7 +186,7 @@ impl GlobalStateInner {\n     pub fn new_call(&mut self) -> CallId {\n         let id = self.next_call_id;\n         trace!(\"new_call: Assigning ID {}\", id);\n-        if Some(id) == self.tracked_call_id {\n+        if self.tracked_call_ids.contains(&id) {\n             register_diagnostic(NonHaltingDiagnostic::CreatedCallId(id));\n         }\n         assert!(self.active_calls.insert(id));\n@@ -311,7 +312,7 @@ impl<'tcx> Stack {\n         global: &GlobalStateInner,\n     ) -> InterpResult<'tcx> {\n         if let SbTag::Tagged(id) = item.tag {\n-            if Some(id) == global.tracked_pointer_tag {\n+            if global.tracked_pointer_tags.contains(&id) {\n                 register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n                     item.clone(),\n                     provoking_access,"}]}