{"sha": "d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f", "node_id": "C_kwDOAAsO6NoAKGQzY2ZkN2M1YzlkYmEwMWE4ZjMxYjEwY2VmNGExOTg1YWUxZGM1M2Y", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-06-22T03:17:13Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-10-29T15:53:48Z"}, "message": "Add vectors of pointers", "tree": {"sha": "d1ace429ac815cdb3c1ce0be1c9b87b79ef88083", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1ace429ac815cdb3c1ce0be1c9b87b79ef88083"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f", "html_url": "https://github.com/rust-lang/rust/commit/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c80b6967ace2b669dc921e67d637c0d546318a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c80b6967ace2b669dc921e67d637c0d546318a9", "html_url": "https://github.com/rust-lang/rust/commit/7c80b6967ace2b669dc921e67d637c0d546318a9"}], "stats": {"total": 342, "additions": 339, "deletions": 3}, "files": [{"sha": "e04a9042b1bf327032c581ef86b51b5aaaaffb03", "filename": "crates/core_simd/src/cast.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcast.rs?ref=d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f", "patch": "@@ -0,0 +1,45 @@\n+use crate::simd::SimdElement;\n+\n+/// Supporting trait for `Simd::cast`.  Typically doesn't need to be used directly.\n+pub trait SimdCast<Target: SimdElement>: SimdElement {}\n+\n+macro_rules! into_number {\n+    { $($type:ty),* } => {\n+        $(\n+        impl SimdCast<i8> for $type {}\n+        impl SimdCast<i16> for $type {}\n+        impl SimdCast<i32> for $type {}\n+        impl SimdCast<i64> for $type {}\n+        impl SimdCast<isize> for $type {}\n+\n+        impl SimdCast<u8> for $type {}\n+        impl SimdCast<u16> for $type {}\n+        impl SimdCast<u32> for $type {}\n+        impl SimdCast<u64> for $type {}\n+        impl SimdCast<usize> for $type {}\n+\n+        impl SimdCast<f32> for $type {}\n+        impl SimdCast<f64> for $type {}\n+        )*\n+    }\n+}\n+\n+into_number! { i8, i16, i32, i64, isize, u8, u16, u32, u64, usize, f32, f64 }\n+\n+macro_rules! into_pointer {\n+    { $($type:ty),* } => {\n+        $(\n+        impl<T> SimdCast<$type> for *const T {}\n+        impl<T> SimdCast<$type> for *mut T {}\n+        impl<T> SimdCast<*const T> for $type {}\n+        impl<T> SimdCast<*mut T> for $type {}\n+        )*\n+    }\n+}\n+\n+into_pointer! { i8, i16, i32, i64, isize, u8, u16, u32, u64, usize }\n+\n+impl<T, U> SimdCast<*const T> for *const U {}\n+impl<T, U> SimdCast<*const T> for *mut U {}\n+impl<T, U> SimdCast<*mut T> for *const U {}\n+impl<T, U> SimdCast<*mut T> for *mut U {}"}, {"sha": "dc7f52a4d576cf1d31f4841c60c974791cf1bff8", "filename": "crates/core_simd/src/elements.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Felements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Felements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements.rs?ref=d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f", "patch": "@@ -1,11 +1,15 @@\n+mod const_ptr;\n mod float;\n mod int;\n+mod mut_ptr;\n mod uint;\n \n mod sealed {\n     pub trait Sealed {}\n }\n \n+pub use const_ptr::*;\n pub use float::*;\n pub use int::*;\n+pub use mut_ptr::*;\n pub use uint::*;"}, {"sha": "ab6b5b8b5f4df9111c3907d072db41899ebc665d", "filename": "crates/core_simd/src/elements/const_ptr.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs?ref=d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f", "patch": "@@ -0,0 +1,59 @@\n+use super::sealed::Sealed;\n+use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n+\n+/// Operations on SIMD vectors of constant pointers.\n+pub trait SimdConstPtr: Copy + Sealed {\n+    /// Vector type representing the pointers as bits.\n+    type Bits;\n+\n+    /// Vector of mutable pointers to the same type.\n+    type MutPtr;\n+\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Returns `true` for each lane that is null.\n+    fn is_null(self) -> Self::Mask;\n+\n+    /// Changes constness without changing the type.\n+    fn as_mut(self) -> Self::MutPtr;\n+\n+    /// Cast pointers to raw bits.\n+    fn to_bits(self) -> Self::Bits;\n+\n+    /// Cast raw bits to pointers.\n+    fn from_bits(bits: Self::Bits) -> Self;\n+}\n+\n+impl<T, const LANES: usize> Sealed for Simd<*const T, LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n+\n+impl<T, const LANES: usize> SimdConstPtr for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Bits = Simd<usize, LANES>;\n+    type MutPtr = Simd<*mut T, LANES>;\n+    type Mask = Mask<isize, LANES>;\n+\n+    fn is_null(self) -> Self::Mask {\n+        Simd::splat(core::ptr::null()).simd_eq(self)\n+    }\n+\n+    fn as_mut(self) -> Self::MutPtr {\n+        // Converting between pointers is safe\n+        unsafe { intrinsics::simd_as(self) }\n+    }\n+\n+    fn to_bits(self) -> Self::Bits {\n+        // Casting pointers to usize is safe\n+        unsafe { intrinsics::simd_as(self) }\n+    }\n+\n+    fn from_bits(bits: Self::Bits) -> Self {\n+        // Casting usize to pointers is safe\n+        unsafe { intrinsics::simd_as(bits) }\n+    }\n+}"}, {"sha": "b49f9fda7e44abbf21957afbb395ba2a2403497b", "filename": "crates/core_simd/src/elements/mut_ptr.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs?ref=d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f", "patch": "@@ -0,0 +1,57 @@\n+use super::sealed::Sealed;\n+use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n+\n+/// Operations on SIMD vectors of mutable pointers.\n+pub trait SimdMutPtr: Copy + Sealed {\n+    /// Vector type representing the pointers as bits.\n+    type Bits;\n+\n+    /// Vector of constant pointers to the same type.\n+    type ConstPtr;\n+\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Returns `true` for each lane that is null.\n+    fn is_null(self) -> Self::Mask;\n+\n+    /// Changes constness without changing the type.\n+    fn as_const(self) -> Self::ConstPtr;\n+\n+    /// Cast pointers to raw bits.\n+    fn to_bits(self) -> Self::Bits;\n+\n+    /// Cast raw bits to pointers.\n+    fn from_bits(bits: Self::Bits) -> Self;\n+}\n+\n+impl<T, const LANES: usize> Sealed for Simd<*mut T, LANES> where LaneCount<LANES>: SupportedLaneCount\n+{}\n+\n+impl<T, const LANES: usize> SimdMutPtr for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Bits = Simd<usize, LANES>;\n+    type ConstPtr = Simd<*const T, LANES>;\n+    type Mask = Mask<isize, LANES>;\n+\n+    fn is_null(self) -> Self::Mask {\n+        Simd::splat(core::ptr::null_mut()).simd_eq(self)\n+    }\n+\n+    fn as_const(self) -> Self::ConstPtr {\n+        // Converting between pointers is safe\n+        unsafe { intrinsics::simd_as(self) }\n+    }\n+\n+    fn to_bits(self) -> Self::Bits {\n+        // Casting pointers to usize is safe\n+        unsafe { intrinsics::simd_as(self) }\n+    }\n+\n+    fn from_bits(bits: Self::Bits) -> Self {\n+        // Casting usize to pointers is safe\n+        unsafe { intrinsics::simd_as(bits) }\n+    }\n+}"}, {"sha": "149380746e7130b212299e3906fc921a3f9d121f", "filename": "crates/core_simd/src/eq.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Feq.rs?ref=d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f", "patch": "@@ -71,3 +71,45 @@ macro_rules! impl_mask {\n }\n \n impl_mask! { i8, i16, i32, i64, isize }\n+\n+impl<T, const LANES: usize> SimdPartialEq for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn simd_eq(self, other: Self) -> Self::Mask {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n+    }\n+\n+    #[inline]\n+    fn simd_ne(self, other: Self) -> Self::Mask {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdPartialEq for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn simd_eq(self, other: Self) -> Self::Mask {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n+    }\n+\n+    #[inline]\n+    fn simd_ne(self, other: Self) -> Self::Mask {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n+    }\n+}"}, {"sha": "ece026a448b73e521bbf59dc99c506849a7c4cf0", "filename": "crates/core_simd/src/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmod.rs?ref=d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f", "patch": "@@ -7,6 +7,7 @@ pub(crate) mod intrinsics;\n mod to_bytes;\n \n mod alias;\n+mod cast;\n mod elements;\n mod eq;\n mod fmt;\n@@ -24,6 +25,7 @@ pub mod simd {\n     pub(crate) use crate::core_simd::intrinsics;\n \n     pub use crate::core_simd::alias::*;\n+    pub use crate::core_simd::cast::*;\n     pub use crate::core_simd::elements::*;\n     pub use crate::core_simd::eq::*;\n     pub use crate::core_simd::lane_count::{LaneCount, SupportedLaneCount};"}, {"sha": "95a1ecaeeda75d842732d6630950f5ecb3122705", "filename": "crates/core_simd/src/ord.rs", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ford.rs?ref=d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f", "patch": "@@ -211,3 +211,117 @@ macro_rules! impl_mask {\n }\n \n impl_mask! { i8, i16, i32, i64, isize }\n+\n+impl<T, const LANES: usize> SimdPartialOrd for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_lt(self, other: Self) -> Self::Mask {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n+    }\n+\n+    #[inline]\n+    fn simd_le(self, other: Self) -> Self::Mask {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n+    }\n+\n+    #[inline]\n+    fn simd_gt(self, other: Self) -> Self::Mask {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n+    }\n+\n+    #[inline]\n+    fn simd_ge(self, other: Self) -> Self::Mask {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdOrd for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_max(self, other: Self) -> Self {\n+        self.simd_lt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_min(self, other: Self) -> Self {\n+        self.simd_gt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_clamp(self, min: Self, max: Self) -> Self {\n+        assert!(\n+            min.simd_le(max).all(),\n+            \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+        );\n+        self.simd_max(min).simd_min(max)\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdPartialOrd for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_lt(self, other: Self) -> Self::Mask {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n+    }\n+\n+    #[inline]\n+    fn simd_le(self, other: Self) -> Self::Mask {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n+    }\n+\n+    #[inline]\n+    fn simd_gt(self, other: Self) -> Self::Mask {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n+    }\n+\n+    #[inline]\n+    fn simd_ge(self, other: Self) -> Self::Mask {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n+        unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdOrd for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_max(self, other: Self) -> Self {\n+        self.simd_lt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_min(self, other: Self) -> Self {\n+        self.simd_gt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_clamp(self, min: Self, max: Self) -> Self {\n+        assert!(\n+            min.simd_le(max).all(),\n+            \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+        );\n+        self.simd_max(min).simd_min(max)\n+    }\n+}"}, {"sha": "cbc8ced5a84e849e1d1f6a88d8d8368c772d0045", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=d3cfd7c5c9dba01a8f31b10cef4a1985ae1dc53f", "patch": "@@ -2,7 +2,7 @@\n pub(crate) mod ptr;\n \n use crate::simd::{\n-    intrinsics, LaneCount, Mask, MaskElement, SimdPartialOrd, SupportedLaneCount, Swizzle,\n+    intrinsics, LaneCount, Mask, MaskElement, SimdCast, SimdPartialOrd, SupportedLaneCount, Swizzle,\n };\n \n /// A SIMD vector of `LANES` elements of type `T`. `Simd<T, N>` has the same shape as [`[T; N]`](array), but operates like `T`.\n@@ -211,7 +211,10 @@ where\n     #[must_use]\n     #[inline]\n     #[cfg(not(bootstrap))]\n-    pub fn cast<U: SimdElement>(self) -> Simd<U, LANES> {\n+    pub fn cast<U: SimdElement>(self) -> Simd<U, LANES>\n+    where\n+        T: SimdCast<U>,\n+    {\n         // Safety: The input argument is a vector of a valid SIMD element type.\n         unsafe { intrinsics::simd_as(self) }\n     }\n@@ -234,7 +237,7 @@ where\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub unsafe fn to_int_unchecked<I>(self) -> Simd<I, LANES>\n     where\n-        T: core::convert::FloatToInt<I>,\n+        T: core::convert::FloatToInt<I> + SimdCast<I>,\n         I: SimdElement,\n     {\n         // Safety: `self` is a vector, and `FloatToInt` ensures the type can be casted to\n@@ -739,3 +742,13 @@ impl Sealed for f64 {}\n unsafe impl SimdElement for f64 {\n     type Mask = i64;\n }\n+\n+impl<T> Sealed for *const T {}\n+unsafe impl<T> SimdElement for *const T {\n+    type Mask = isize;\n+}\n+\n+impl<T> Sealed for *mut T {}\n+unsafe impl<T> SimdElement for *mut T {\n+    type Mask = isize;\n+}"}]}