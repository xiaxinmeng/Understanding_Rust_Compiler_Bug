{"sha": "06a02187babfbe5b6a5abdee9b5625bed7a15493", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YTAyMTg3YmFiZmJlNWI2YTVhYmRlZTliNTYyNWJlZDdhMTU0OTM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-02-09T17:12:59Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-02-09T17:12:59Z"}, "message": "move drop code into its own file", "tree": {"sha": "562aeba0da38163bc3a05902131ed7390fb13eb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/562aeba0da38163bc3a05902131ed7390fb13eb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06a02187babfbe5b6a5abdee9b5625bed7a15493", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06a02187babfbe5b6a5abdee9b5625bed7a15493", "html_url": "https://github.com/rust-lang/rust/commit/06a02187babfbe5b6a5abdee9b5625bed7a15493", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06a02187babfbe5b6a5abdee9b5625bed7a15493/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c2832f4192501acb54547641c666b776e6ec90e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c2832f4192501acb54547641c666b776e6ec90e", "html_url": "https://github.com/rust-lang/rust/commit/8c2832f4192501acb54547641c666b776e6ec90e"}], "stats": {"total": 462, "additions": 240, "deletions": 222}, "files": [{"sha": "32c5073421b11a70eae23c6ede5f007ce50ee998", "filename": "src/terminator/drop.rs", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/06a02187babfbe5b6a5abdee9b5625bed7a15493/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06a02187babfbe5b6a5abdee9b5625bed7a15493/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=06a02187babfbe5b6a5abdee9b5625bed7a15493", "patch": "@@ -0,0 +1,236 @@\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::layout::Layout;\n+use rustc::ty::subst::{Substs, Kind};\n+use rustc::ty::{self, Ty};\n+use rustc::mir;\n+use syntax::codemap::Span;\n+\n+use error::{EvalError, EvalResult};\n+use eval_context::{EvalContext, monomorphize_field_ty, StackPopCleanup};\n+use lvalue::{Lvalue, LvalueExtra};\n+use memory::{Pointer, FunctionDefinition};\n+use value::PrimVal;\n+use value::Value;\n+\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+\n+    /// Creates stack frames for all drop impls. See `drop` for the actual content.\n+    pub fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>, span: Span) -> EvalResult<'tcx> {\n+        // add them to the stack in reverse order, because the impl that needs to run the last\n+        // is the one that needs to be at the bottom of the stack\n+        for (drop_def_id, self_arg, substs) in drops.into_iter().rev() {\n+            let mir = self.load_mir(drop_def_id)?;\n+            trace!(\"substs for drop glue: {:?}\", substs);\n+            self.push_stack_frame(\n+                drop_def_id,\n+                span,\n+                mir,\n+                substs,\n+                Lvalue::from_ptr(Pointer::zst_ptr()),\n+                StackPopCleanup::None,\n+                Vec::new(),\n+            )?;\n+            let mut arg_locals = self.frame().mir.args_iter();\n+            let first = arg_locals.next().expect(\"drop impl has self arg\");\n+            assert!(arg_locals.next().is_none(), \"drop impl should have only one arg\");\n+            let dest = self.eval_lvalue(&mir::Lvalue::Local(first))?;\n+            let ty = self.frame().mir.local_decls[first].ty;\n+            self.write_value(self_arg, dest, ty)?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// push DefIds of drop impls and their argument on the given vector\n+    pub fn drop(\n+        &mut self,\n+        lval: Lvalue<'tcx>,\n+        ty: Ty<'tcx>,\n+        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n+    ) -> EvalResult<'tcx> {\n+        if !self.type_needs_drop(ty) {\n+            debug!(\"no need to drop {:?}\", ty);\n+            return Ok(());\n+        }\n+        trace!(\"-need to drop {:?} at {:?}\", ty, lval);\n+\n+        match ty.sty {\n+            // special case `Box` to deallocate the inner allocation\n+            ty::TyAdt(ref def, _) if def.is_box() => {\n+                let contents_ty = ty.boxed_ty();\n+                let val = self.read_lvalue(lval);\n+                // we are going through the read_value path, because that already does all the\n+                // checks for the trait object types. We'd only be repeating ourselves here.\n+                let val = self.follow_by_ref_value(val, ty)?;\n+                trace!(\"box dealloc on {:?}\", val);\n+                match val {\n+                    Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in ByRef\"),\n+                    Value::ByVal(ptr) => {\n+                        assert!(self.type_is_sized(contents_ty));\n+                        let contents_ptr = ptr.to_ptr()?;\n+                        self.drop(Lvalue::from_ptr(contents_ptr), contents_ty, drop)?;\n+                    },\n+                    Value::ByValPair(prim_ptr, extra) => {\n+                        let ptr = prim_ptr.to_ptr()?;\n+                        let extra = match self.tcx.struct_tail(contents_ty).sty {\n+                            ty::TyDynamic(..) => LvalueExtra::Vtable(extra.to_ptr()?),\n+                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.to_u64()?),\n+                            _ => bug!(\"invalid fat pointer type: {}\", ty),\n+                        };\n+                        self.drop(Lvalue::Ptr { ptr, extra }, contents_ty, drop)?;\n+                    },\n+                }\n+                let box_free_fn = self.tcx.lang_items.box_free_fn().expect(\"no box_free lang item\");\n+                let substs = self.tcx.intern_substs(&[Kind::from(contents_ty)]);\n+                // this is somewhat hacky, but hey, there's no representation difference between\n+                // pointers and references, so\n+                // #[lang = \"box_free\"] unsafe fn box_free<T>(ptr: *mut T)\n+                // is the same as\n+                // fn drop(&mut self) if Self is Box<T>\n+                drop.push((box_free_fn, val, substs));\n+            },\n+\n+            ty::TyAdt(adt_def, substs) => {\n+                // FIXME: some structs are represented as ByValPair\n+                let lval = self.force_allocation(lval)?;\n+                let adt_ptr = match lval {\n+                    Lvalue::Ptr { ptr, .. } => ptr,\n+                    _ => bug!(\"force allocation can only yield Lvalue::Ptr\"),\n+                };\n+                // run drop impl before the fields' drop impls\n+                if let Some(drop_def_id) = adt_def.destructor() {\n+                    drop.push((drop_def_id, Value::ByVal(PrimVal::Ptr(adt_ptr)), substs));\n+                }\n+                let layout = self.type_layout(ty)?;\n+                let fields = match *layout {\n+                    Layout::Univariant { ref variant, .. } => {\n+                        adt_def.struct_variant().fields.iter().zip(&variant.offsets)\n+                    },\n+                    Layout::General { ref variants, .. } => {\n+                        let discr_val = self.read_discriminant_value(adt_ptr, ty)? as u128;\n+                        match adt_def.variants.iter().position(|v| discr_val == v.disr_val.to_u128_unchecked()) {\n+                            // start at offset 1, to skip over the discriminant\n+                            Some(i) => adt_def.variants[i].fields.iter().zip(&variants[i].offsets[1..]),\n+                            None => return Err(EvalError::InvalidDiscriminant),\n+                        }\n+                    },\n+                    Layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n+                        let discr = self.read_discriminant_value(adt_ptr, ty)?;\n+                        if discr == nndiscr as u128 {\n+                            assert_eq!(discr as usize as u128, discr);\n+                            adt_def.variants[discr as usize].fields.iter().zip(&nonnull.offsets)\n+                        } else {\n+                            // FIXME: the zst variant might contain zst types that impl Drop\n+                            return Ok(()); // nothing to do, this is zero sized (e.g. `None`)\n+                        }\n+                    },\n+                    Layout::RawNullablePointer { nndiscr, .. } => {\n+                        let discr = self.read_discriminant_value(adt_ptr, ty)?;\n+                        if discr == nndiscr as u128 {\n+                            assert_eq!(discr as usize as u128, discr);\n+                            assert_eq!(adt_def.variants[discr as usize].fields.len(), 1);\n+                            let field_ty = &adt_def.variants[discr as usize].fields[0];\n+                            let field_ty = monomorphize_field_ty(self.tcx, field_ty, substs);\n+                            // FIXME: once read_discriminant_value works with lvalue, don't force\n+                            // alloc in the RawNullablePointer case\n+                            self.drop(lval, field_ty, drop)?;\n+                            return Ok(());\n+                        } else {\n+                            // FIXME: the zst variant might contain zst types that impl Drop\n+                            return Ok(()); // nothing to do, this is zero sized (e.g. `None`)\n+                        }\n+                    },\n+                    Layout::CEnum { .. } => return Ok(()),\n+                    _ => bug!(\"{:?} is not an adt layout\", layout),\n+                };\n+                let tcx = self.tcx;\n+                self.drop_fields(\n+                    fields.map(|(ty, &offset)| (monomorphize_field_ty(tcx, ty, substs), offset)),\n+                    lval,\n+                    drop,\n+                )?;\n+            },\n+            ty::TyTuple(fields, _) => {\n+                let offsets = match *self.type_layout(ty)? {\n+                    Layout::Univariant { ref variant, .. } => &variant.offsets,\n+                    _ => bug!(\"tuples must be univariant\"),\n+                };\n+                self.drop_fields(fields.iter().cloned().zip(offsets.iter().cloned()), lval, drop)?;\n+            },\n+            ty::TyDynamic(..) => {\n+                let (ptr, vtable) = match lval {\n+                    Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => (ptr, vtable),\n+                    _ => bug!(\"expected an lvalue with a vtable\"),\n+                };\n+                let drop_fn = self.memory.read_ptr(vtable)?;\n+                // some values don't need to call a drop impl, so the value is null\n+                if drop_fn != Pointer::from_int(0) {\n+                    let FunctionDefinition {def_id, substs, sig, ..} = self.memory.get_fn(drop_fn.alloc_id)?.expect_drop_glue()?;\n+                    let real_ty = sig.inputs()[0];\n+                    self.drop(Lvalue::from_ptr(ptr), real_ty, drop)?;\n+                    drop.push((def_id, Value::ByVal(PrimVal::Ptr(ptr)), substs));\n+                } else {\n+                    // just a sanity check\n+                    assert_eq!(drop_fn.offset, 0);\n+                }\n+            },\n+            ty::TySlice(elem_ty) => {\n+                let (ptr, len) = match lval {\n+                    Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => (ptr, len),\n+                    _ => bug!(\"expected an lvalue with a length\"),\n+                };\n+                let size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n+                // FIXME: this creates a lot of stack frames if the element type has\n+                // a drop impl\n+                for i in 0..len {\n+                    self.drop(Lvalue::from_ptr(ptr.offset(i * size)), elem_ty, drop)?;\n+                }\n+            },\n+            ty::TyArray(elem_ty, len) => {\n+                let lval = self.force_allocation(lval)?;\n+                let (ptr, extra) = match lval {\n+                    Lvalue::Ptr { ptr, extra } => (ptr, extra),\n+                    _ => bug!(\"expected an lvalue with optional extra data\"),\n+                };\n+                let size = self.type_size(elem_ty)?.expect(\"array element cannot be unsized\");\n+                // FIXME: this creates a lot of stack frames if the element type has\n+                // a drop impl\n+                for i in 0..(len as u64) {\n+                    self.drop(Lvalue::Ptr { ptr: ptr.offset(i * size), extra }, elem_ty, drop)?;\n+                }\n+            },\n+            // FIXME: what about TyClosure and TyAnon?\n+            // other types do not need to process drop\n+            _ => {},\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn drop_fields<I>(\n+        &mut self,\n+        mut fields: I,\n+        lval: Lvalue<'tcx>,\n+        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n+    ) -> EvalResult<'tcx>\n+        where I: Iterator<Item = (Ty<'tcx>, ty::layout::Size)>,\n+    {\n+        // FIXME: some aggregates may be represented by Value::ByValPair\n+        let (adt_ptr, extra) = self.force_allocation(lval)?.to_ptr_and_extra();\n+        // manual iteration, because we need to be careful about the last field if it is unsized\n+        while let Some((field_ty, offset)) = fields.next() {\n+            let ptr = adt_ptr.offset(offset.bytes());\n+            if self.type_is_sized(field_ty) {\n+                self.drop(Lvalue::from_ptr(ptr), field_ty, drop)?;\n+            } else {\n+                self.drop(Lvalue::Ptr { ptr, extra }, field_ty, drop)?;\n+                break; // if it is not sized, then this is the last field anyway\n+            }\n+        }\n+        assert!(fields.next().is_none());\n+        Ok(())\n+    }\n+\n+    fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n+        self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment())\n+    }\n+}"}, {"sha": "e6ed715280e0a35bb03e5d7644a1456beacc5ec0", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 4, "deletions": 222, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/06a02187babfbe5b6a5abdee9b5625bed7a15493/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06a02187babfbe5b6a5abdee9b5625bed7a15493/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=06a02187babfbe5b6a5abdee9b5625bed7a15493", "patch": "@@ -3,19 +3,20 @@ use rustc::mir;\n use rustc::traits::{self, Reveal};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::layout::{Layout, Size};\n-use rustc::ty::subst::{Substs, Kind};\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt, BareFnTy};\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::{ast, attr, abi};\n \n use error::{EvalError, EvalResult};\n-use eval_context::{EvalContext, IntegerExt, StackPopCleanup, monomorphize_field_ty, is_inhabited};\n-use lvalue::{Lvalue, LvalueExtra};\n+use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n+use lvalue::Lvalue;\n use memory::{Pointer, FunctionDefinition, Function};\n use value::PrimVal;\n use value::Value;\n \n mod intrinsic;\n+mod drop;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n@@ -161,31 +162,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>, span: Span) -> EvalResult<'tcx> {\n-        // add them to the stack in reverse order, because the impl that needs to run the last\n-        // is the one that needs to be at the bottom of the stack\n-        for (drop_def_id, self_arg, substs) in drops.into_iter().rev() {\n-            let mir = self.load_mir(drop_def_id)?;\n-            trace!(\"substs for drop glue: {:?}\", substs);\n-            self.push_stack_frame(\n-                drop_def_id,\n-                span,\n-                mir,\n-                substs,\n-                Lvalue::from_ptr(Pointer::zst_ptr()),\n-                StackPopCleanup::None,\n-                Vec::new(),\n-            )?;\n-            let mut arg_locals = self.frame().mir.args_iter();\n-            let first = arg_locals.next().expect(\"drop impl has self arg\");\n-            assert!(arg_locals.next().is_none(), \"drop impl should have only one arg\");\n-            let dest = self.eval_lvalue(&mir::Lvalue::Local(first))?;\n-            let ty = self.frame().mir.local_decls[first].ty;\n-            self.write_value(self_arg, dest, ty)?;\n-        }\n-        Ok(())\n-    }\n-\n     fn eval_fn_call(\n         &mut self,\n         def_id: DefId,\n@@ -699,200 +675,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             vtable => bug!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n         }\n     }\n-\n-    pub(super) fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment())\n-    }\n-\n-    /// push DefIds of drop impls and their argument on the given vector\n-    pub fn drop(\n-        &mut self,\n-        lval: Lvalue<'tcx>,\n-        ty: Ty<'tcx>,\n-        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n-    ) -> EvalResult<'tcx> {\n-        if !self.type_needs_drop(ty) {\n-            debug!(\"no need to drop {:?}\", ty);\n-            return Ok(());\n-        }\n-        trace!(\"-need to drop {:?} at {:?}\", ty, lval);\n-\n-        match ty.sty {\n-            // special case `Box` to deallocate the inner allocation\n-            ty::TyAdt(ref def, _) if def.is_box() => {\n-                let contents_ty = ty.boxed_ty();\n-                let val = self.read_lvalue(lval);\n-                // we are going through the read_value path, because that already does all the\n-                // checks for the trait object types. We'd only be repeating ourselves here.\n-                let val = self.follow_by_ref_value(val, ty)?;\n-                trace!(\"box dealloc on {:?}\", val);\n-                match val {\n-                    Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in ByRef\"),\n-                    Value::ByVal(ptr) => {\n-                        assert!(self.type_is_sized(contents_ty));\n-                        let contents_ptr = ptr.to_ptr()?;\n-                        self.drop(Lvalue::from_ptr(contents_ptr), contents_ty, drop)?;\n-                    },\n-                    Value::ByValPair(prim_ptr, extra) => {\n-                        let ptr = prim_ptr.to_ptr()?;\n-                        let extra = match self.tcx.struct_tail(contents_ty).sty {\n-                            ty::TyDynamic(..) => LvalueExtra::Vtable(extra.to_ptr()?),\n-                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.to_u64()?),\n-                            _ => bug!(\"invalid fat pointer type: {}\", ty),\n-                        };\n-                        self.drop(Lvalue::Ptr { ptr, extra }, contents_ty, drop)?;\n-                    },\n-                }\n-                let box_free_fn = self.tcx.lang_items.box_free_fn().expect(\"no box_free lang item\");\n-                let substs = self.tcx.intern_substs(&[Kind::from(contents_ty)]);\n-                // this is somewhat hacky, but hey, there's no representation difference between\n-                // pointers and references, so\n-                // #[lang = \"box_free\"] unsafe fn box_free<T>(ptr: *mut T)\n-                // is the same as\n-                // fn drop(&mut self) if Self is Box<T>\n-                drop.push((box_free_fn, val, substs));\n-            },\n-\n-            ty::TyAdt(adt_def, substs) => {\n-                // FIXME: some structs are represented as ByValPair\n-                let lval = self.force_allocation(lval)?;\n-                let adt_ptr = match lval {\n-                    Lvalue::Ptr { ptr, .. } => ptr,\n-                    _ => bug!(\"force allocation can only yield Lvalue::Ptr\"),\n-                };\n-                // run drop impl before the fields' drop impls\n-                if let Some(drop_def_id) = adt_def.destructor() {\n-                    drop.push((drop_def_id, Value::ByVal(PrimVal::Ptr(adt_ptr)), substs));\n-                }\n-                let layout = self.type_layout(ty)?;\n-                let fields = match *layout {\n-                    Layout::Univariant { ref variant, .. } => {\n-                        adt_def.struct_variant().fields.iter().zip(&variant.offsets)\n-                    },\n-                    Layout::General { ref variants, .. } => {\n-                        let discr_val = self.read_discriminant_value(adt_ptr, ty)? as u128;\n-                        match adt_def.variants.iter().position(|v| discr_val == v.disr_val.to_u128_unchecked()) {\n-                            // start at offset 1, to skip over the discriminant\n-                            Some(i) => adt_def.variants[i].fields.iter().zip(&variants[i].offsets[1..]),\n-                            None => return Err(EvalError::InvalidDiscriminant),\n-                        }\n-                    },\n-                    Layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n-                        let discr = self.read_discriminant_value(adt_ptr, ty)?;\n-                        if discr == nndiscr as u128 {\n-                            assert_eq!(discr as usize as u128, discr);\n-                            adt_def.variants[discr as usize].fields.iter().zip(&nonnull.offsets)\n-                        } else {\n-                            // FIXME: the zst variant might contain zst types that impl Drop\n-                            return Ok(()); // nothing to do, this is zero sized (e.g. `None`)\n-                        }\n-                    },\n-                    Layout::RawNullablePointer { nndiscr, .. } => {\n-                        let discr = self.read_discriminant_value(adt_ptr, ty)?;\n-                        if discr == nndiscr as u128 {\n-                            assert_eq!(discr as usize as u128, discr);\n-                            assert_eq!(adt_def.variants[discr as usize].fields.len(), 1);\n-                            let field_ty = &adt_def.variants[discr as usize].fields[0];\n-                            let field_ty = monomorphize_field_ty(self.tcx, field_ty, substs);\n-                            // FIXME: once read_discriminant_value works with lvalue, don't force\n-                            // alloc in the RawNullablePointer case\n-                            self.drop(lval, field_ty, drop)?;\n-                            return Ok(());\n-                        } else {\n-                            // FIXME: the zst variant might contain zst types that impl Drop\n-                            return Ok(()); // nothing to do, this is zero sized (e.g. `None`)\n-                        }\n-                    },\n-                    Layout::CEnum { .. } => return Ok(()),\n-                    _ => bug!(\"{:?} is not an adt layout\", layout),\n-                };\n-                let tcx = self.tcx;\n-                self.drop_fields(\n-                    fields.map(|(ty, &offset)| (monomorphize_field_ty(tcx, ty, substs), offset)),\n-                    lval,\n-                    drop,\n-                )?;\n-            },\n-            ty::TyTuple(fields, _) => {\n-                let offsets = match *self.type_layout(ty)? {\n-                    Layout::Univariant { ref variant, .. } => &variant.offsets,\n-                    _ => bug!(\"tuples must be univariant\"),\n-                };\n-                self.drop_fields(fields.iter().cloned().zip(offsets.iter().cloned()), lval, drop)?;\n-            },\n-            ty::TyDynamic(..) => {\n-                let (ptr, vtable) = match lval {\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => (ptr, vtable),\n-                    _ => bug!(\"expected an lvalue with a vtable\"),\n-                };\n-                let drop_fn = self.memory.read_ptr(vtable)?;\n-                // some values don't need to call a drop impl, so the value is null\n-                if drop_fn != Pointer::from_int(0) {\n-                    let FunctionDefinition {def_id, substs, sig, ..} = self.memory.get_fn(drop_fn.alloc_id)?.expect_drop_glue()?;\n-                    let real_ty = sig.inputs()[0];\n-                    self.drop(Lvalue::from_ptr(ptr), real_ty, drop)?;\n-                    drop.push((def_id, Value::ByVal(PrimVal::Ptr(ptr)), substs));\n-                } else {\n-                    // just a sanity check\n-                    assert_eq!(drop_fn.offset, 0);\n-                }\n-            },\n-            ty::TySlice(elem_ty) => {\n-                let (ptr, len) = match lval {\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => (ptr, len),\n-                    _ => bug!(\"expected an lvalue with a length\"),\n-                };\n-                let size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n-                // FIXME: this creates a lot of stack frames if the element type has\n-                // a drop impl\n-                for i in 0..len {\n-                    self.drop(Lvalue::from_ptr(ptr.offset(i * size)), elem_ty, drop)?;\n-                }\n-            },\n-            ty::TyArray(elem_ty, len) => {\n-                let lval = self.force_allocation(lval)?;\n-                let (ptr, extra) = match lval {\n-                    Lvalue::Ptr { ptr, extra } => (ptr, extra),\n-                    _ => bug!(\"expected an lvalue with optional extra data\"),\n-                };\n-                let size = self.type_size(elem_ty)?.expect(\"array element cannot be unsized\");\n-                // FIXME: this creates a lot of stack frames if the element type has\n-                // a drop impl\n-                for i in 0..(len as u64) {\n-                    self.drop(Lvalue::Ptr { ptr: ptr.offset(i * size), extra }, elem_ty, drop)?;\n-                }\n-            },\n-            // FIXME: what about TyClosure and TyAnon?\n-            // other types do not need to process drop\n-            _ => {},\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn drop_fields<I>(\n-        &mut self,\n-        mut fields: I,\n-        lval: Lvalue<'tcx>,\n-        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n-    ) -> EvalResult<'tcx>\n-        where I: Iterator<Item = (Ty<'tcx>, ty::layout::Size)>,\n-    {\n-        // FIXME: some aggregates may be represented by Value::ByValPair\n-        let (adt_ptr, extra) = self.force_allocation(lval)?.to_ptr_and_extra();\n-        // manual iteration, because we need to be careful about the last field if it is unsized\n-        while let Some((field_ty, offset)) = fields.next() {\n-            let ptr = adt_ptr.offset(offset.bytes());\n-            if self.type_is_sized(field_ty) {\n-                self.drop(Lvalue::from_ptr(ptr), field_ty, drop)?;\n-            } else {\n-                self.drop(Lvalue::Ptr { ptr, extra }, field_ty, drop)?;\n-                break; // if it is not sized, then this is the last field anyway\n-            }\n-        }\n-        assert!(fields.next().is_none());\n-        Ok(())\n-    }\n }\n \n #[derive(Debug)]"}]}