{"sha": "79d139ac7056d0102db605715f354689b0214705", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZDEzOWFjNzA1NmQwMTAyZGI2MDU3MTVmMzU0Njg5YjAyMTQ3MDU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-10T14:35:05Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-13T09:40:17Z"}, "message": "parser: simplify ParamCfg -> ReqName", "tree": {"sha": "e489dc5dd7c1e6f1724d69e52b0a6ca177a2f612", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e489dc5dd7c1e6f1724d69e52b0a6ca177a2f612"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79d139ac7056d0102db605715f354689b0214705", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79d139ac7056d0102db605715f354689b0214705", "html_url": "https://github.com/rust-lang/rust/commit/79d139ac7056d0102db605715f354689b0214705", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79d139ac7056d0102db605715f354689b0214705/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05e5530577bf43749186fd56195cffb686f0311e", "url": "https://api.github.com/repos/rust-lang/rust/commits/05e5530577bf43749186fd56195cffb686f0311e", "html_url": "https://github.com/rust-lang/rust/commit/05e5530577bf43749186fd56195cffb686f0311e"}], "stats": {"total": 48, "additions": 18, "deletions": 30}, "files": [{"sha": "d16eb770951e105fcef01942fa022f0ce97ae7d9", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/79d139ac7056d0102db605715f354689b0214705/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d139ac7056d0102db605715f354689b0214705/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=79d139ac7056d0102db605715f354689b0214705", "patch": "@@ -98,8 +98,7 @@ impl<'a> Parser<'a> {\n \n         if self.is_fn_front_matter() {\n             // FUNCTION ITEM\n-            let (ident, sig, generics, body) =\n-                self.parse_fn(&mut false, &mut attrs, &ParamCfg::FREE)?;\n+            let (ident, sig, generics, body) = self.parse_fn(&mut false, &mut attrs, |_| true)?;\n             let kind = ItemKind::Fn(sig, generics, body);\n             return self.mk_item_with_info(attrs, lo, vis, (ident, kind, None));\n         }\n@@ -715,12 +714,12 @@ impl<'a> Parser<'a> {\n     fn parse_assoc_item(\n         &mut self,\n         at_end: &mut bool,\n-        is_name_required: fn(&token::Token) -> bool,\n+        req_name: fn(&token::Token) -> bool,\n     ) -> PResult<'a, P<AssocItem>> {\n         let attrs = self.parse_outer_attributes()?;\n         let mut unclosed_delims = vec![];\n         let (mut item, tokens) = self.collect_tokens(|this| {\n-            let item = this.parse_assoc_item_(at_end, attrs, is_name_required);\n+            let item = this.parse_assoc_item_(at_end, attrs, req_name);\n             unclosed_delims.append(&mut this.unclosed_delims);\n             item\n         })?;\n@@ -736,16 +735,15 @@ impl<'a> Parser<'a> {\n         &mut self,\n         at_end: &mut bool,\n         mut attrs: Vec<Attribute>,\n-        is_name_required: fn(&token::Token) -> bool,\n+        req_name: fn(&token::Token) -> bool,\n     ) -> PResult<'a, AssocItem> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n         let defaultness = self.parse_defaultness();\n         let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n             self.parse_assoc_ty()?\n         } else if self.is_fn_front_matter() {\n-            let cfg = ParamCfg { is_name_required };\n-            let (ident, sig, generics, body) = self.parse_fn(at_end, &mut attrs, &cfg)?;\n+            let (ident, sig, generics, body) = self.parse_fn(at_end, &mut attrs, req_name)?;\n             (ident, AssocItemKind::Fn(sig, body), generics)\n         } else if let Some(mac) = self.parse_assoc_macro_invoc(\"associated\", Some(&vis), at_end)? {\n             (Ident::invalid(), AssocItemKind::Macro(mac), Generics::default())\n@@ -982,8 +980,7 @@ impl<'a> Parser<'a> {\n             self.parse_item_foreign_type(vis, lo, attrs)\n         } else if self.is_fn_front_matter() {\n             // FOREIGN FUNCTION ITEM\n-            let (ident, sig, generics, body) =\n-                self.parse_fn(&mut false, &mut attrs, &ParamCfg::FREE)?;\n+            let (ident, sig, generics, body) = self.parse_fn(&mut false, &mut attrs, |_| true)?;\n             let kind = ForeignItemKind::Fn(sig, generics, body);\n             let span = lo.to(self.prev_span);\n             Ok(P(ast::ForeignItem {\n@@ -1607,16 +1604,9 @@ impl<'a> Parser<'a> {\n }\n \n /// The parsing configuration used to parse a parameter list (see `parse_fn_params`).\n-pub(super) struct ParamCfg {\n-    /// `is_name_required` decides if, per-parameter,\n-    /// the parameter must have a pattern or just a type.\n-    pub is_name_required: fn(&token::Token) -> bool,\n-}\n-\n-impl ParamCfg {\n-    /// Configuration for a free function in the sense that it is not associated.\n-    const FREE: Self = ParamCfg { is_name_required: |_| true };\n-}\n+///\n+/// The function decides if, per-parameter `p`, `p` must have a pattern or just a type.\n+type ReqName = fn(&token::Token) -> bool;\n \n /// Parsing of functions and methods.\n impl<'a> Parser<'a> {\n@@ -1625,12 +1615,12 @@ impl<'a> Parser<'a> {\n         &mut self,\n         at_end: &mut bool,\n         attrs: &mut Vec<Attribute>,\n-        cfg: &ParamCfg,\n+        req_name: ReqName,\n     ) -> PResult<'a, (Ident, FnSig, Generics, Option<P<Block>>)> {\n         let header = self.parse_fn_front_matter()?; // `const ... fn`\n         let ident = self.parse_ident()?; // `foo`\n         let mut generics = self.parse_generics()?; // `<'a, T, ...>`\n-        let decl = self.parse_fn_decl(cfg, AllowPlus::Yes)?; // `(p: u8, ...)`\n+        let decl = self.parse_fn_decl(req_name, AllowPlus::Yes)?; // `(p: u8, ...)`\n         generics.where_clause = self.parse_where_clause()?; // `where T: Ord`\n         let body = self.parse_fn_body(at_end, attrs)?; // `;` or `{ ... }`.\n         Ok((ident, FnSig { header, decl }, generics, body))\n@@ -1732,21 +1722,21 @@ impl<'a> Parser<'a> {\n     /// Parses the parameter list and result type of a function declaration.\n     pub(super) fn parse_fn_decl(\n         &mut self,\n-        cfg: &ParamCfg,\n+        req_name: ReqName,\n         ret_allow_plus: AllowPlus,\n     ) -> PResult<'a, P<FnDecl>> {\n         Ok(P(FnDecl {\n-            inputs: self.parse_fn_params(cfg)?,\n+            inputs: self.parse_fn_params(req_name)?,\n             output: self.parse_ret_ty(ret_allow_plus, RecoverQPath::Yes)?,\n         }))\n     }\n \n     /// Parses the parameter list of a function, including the `(` and `)` delimiters.\n-    fn parse_fn_params(&mut self, cfg: &ParamCfg) -> PResult<'a, Vec<Param>> {\n+    fn parse_fn_params(&mut self, req_name: ReqName) -> PResult<'a, Vec<Param>> {\n         let mut first_param = true;\n         // Parse the arguments, starting out with `self` being allowed...\n         let (mut params, _) = self.parse_paren_comma_seq(|p| {\n-            let param = p.parse_param_general(&cfg, first_param).or_else(|mut e| {\n+            let param = p.parse_param_general(req_name, first_param).or_else(|mut e| {\n                 e.emit();\n                 let lo = p.prev_span;\n                 // Skip every token until next possible arg or end.\n@@ -1766,7 +1756,7 @@ impl<'a> Parser<'a> {\n     /// Parses a single function parameter.\n     ///\n     /// - `self` is syntactically allowed when `first_param` holds.\n-    fn parse_param_general(&mut self, cfg: &ParamCfg, first_param: bool) -> PResult<'a, Param> {\n+    fn parse_param_general(&mut self, req_name: ReqName, first_param: bool) -> PResult<'a, Param> {\n         let lo = self.token.span;\n         let attrs = self.parse_outer_attributes()?;\n \n@@ -1778,7 +1768,7 @@ impl<'a> Parser<'a> {\n \n         let is_name_required = match self.token.kind {\n             token::DotDotDot => false,\n-            _ => (cfg.is_name_required)(&self.token),\n+            _ => req_name(&self.token),\n         };\n         let (pat, ty) = if is_name_required || self.is_named_param() {\n             debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);"}, {"sha": "f56ae65a03d02114824ef0269d638dff424c3576", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79d139ac7056d0102db605715f354689b0214705/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d139ac7056d0102db605715f354689b0214705/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=79d139ac7056d0102db605715f354689b0214705", "patch": "@@ -1,4 +1,3 @@\n-use super::item::ParamCfg;\n use super::{Parser, PathStyle, TokenType};\n \n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n@@ -311,8 +310,7 @@ impl<'a> Parser<'a> {\n         let unsafety = self.parse_unsafety();\n         let ext = self.parse_extern()?;\n         self.expect_keyword(kw::Fn)?;\n-        let cfg = ParamCfg { is_name_required: |_| false };\n-        let decl = self.parse_fn_decl(&cfg, AllowPlus::No)?;\n+        let decl = self.parse_fn_decl(|_| false, AllowPlus::No)?;\n         Ok(TyKind::BareFn(P(BareFnTy { ext, unsafety, generic_params, decl })))\n     }\n "}]}