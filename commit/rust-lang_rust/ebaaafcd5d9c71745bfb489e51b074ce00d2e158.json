{"sha": "ebaaafcd5d9c71745bfb489e51b074ce00d2e158", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViYWFhZmNkNWQ5YzcxNzQ1YmZiNDg5ZTUxYjA3NGNlMDBkMmUxNTg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-14T09:55:20Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-27T06:42:09Z"}, "message": "Peform def id assignment during expansion.", "tree": {"sha": "66acad249eae58152f12db8cb0171f4f22a29037", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66acad249eae58152f12db8cb0171f4f22a29037"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebaaafcd5d9c71745bfb489e51b074ce00d2e158", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebaaafcd5d9c71745bfb489e51b074ce00d2e158", "html_url": "https://github.com/rust-lang/rust/commit/ebaaafcd5d9c71745bfb489e51b074ce00d2e158", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebaaafcd5d9c71745bfb489e51b074ce00d2e158/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0623cf7bda44849ab5df78a06b22f9108cf821a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0623cf7bda44849ab5df78a06b22f9108cf821a", "html_url": "https://github.com/rust-lang/rust/commit/d0623cf7bda44849ab5df78a06b22f9108cf821a"}], "stats": {"total": 159, "additions": 106, "deletions": 53}, "files": [{"sha": "1fb078ec32501b57f49d5e8591c109849f1f117d", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 56, "deletions": 30, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ebaaafcd5d9c71745bfb489e51b074ce00d2e158/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaaafcd5d9c71745bfb489e51b074ce00d2e158/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=ebaaafcd5d9c71745bfb489e51b074ce00d2e158", "patch": "@@ -18,31 +18,33 @@ use middle::cstore::InlinedItem;\n \n use syntax::ast::*;\n use syntax::visit;\n-use syntax::parse::token;\n+use syntax::parse::token::{self, keywords};\n \n /// Creates def ids for nodes in the HIR.\n-pub struct DefCollector<'ast> {\n+pub struct DefCollector<'a> {\n     // If we are walking HIR (c.f., AST), we need to keep a reference to the\n     // crate.\n-    hir_crate: Option<&'ast hir::Crate>,\n-    definitions: &'ast mut Definitions,\n+    hir_crate: Option<&'a hir::Crate>,\n+    definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n+    pub visit_macro_invoc: Option<&'a mut FnMut(NodeId, DefIndex)>,\n }\n \n-impl<'ast> DefCollector<'ast> {\n-    pub fn new(definitions: &'ast mut Definitions) -> DefCollector<'ast> {\n+impl<'a> DefCollector<'a> {\n+    pub fn new(definitions: &'a mut Definitions) -> Self {\n         DefCollector {\n             hir_crate: None,\n             definitions: definitions,\n             parent_def: None,\n+            visit_macro_invoc: None,\n         }\n     }\n \n     pub fn extend(parent_node: NodeId,\n                   parent_def_path: DefPath,\n                   parent_def_id: DefId,\n-                  definitions: &'ast mut Definitions)\n-                  -> DefCollector<'ast> {\n+                  definitions: &'a mut Definitions)\n+                  -> Self {\n         let mut collector = DefCollector::new(definitions);\n \n         assert_eq!(parent_def_path.krate, parent_def_id.krate);\n@@ -65,7 +67,7 @@ impl<'ast> DefCollector<'ast> {\n         self.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n     }\n \n-    pub fn walk_item(&mut self, ii: &'ast InlinedItem, krate: &'ast hir::Crate) {\n+    pub fn walk_item(&mut self, ii: &'a InlinedItem, krate: &'a hir::Crate) {\n         self.hir_crate = Some(krate);\n         ii.visit(self);\n     }\n@@ -84,7 +86,7 @@ impl<'ast> DefCollector<'ast> {\n         self.definitions.create_def_with_parent(parent, node_id, data)\n     }\n \n-    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n+    pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n         let parent = self.parent_def;\n         self.parent_def = Some(parent_def);\n         f(self);\n@@ -106,7 +108,7 @@ impl<'ast> DefCollector<'ast> {\n         self.create_def(expr.id, DefPathData::Initializer);\n     }\n \n-    fn visit_hir_const_integer(&mut self, expr: &'ast hir::Expr) {\n+    fn visit_hir_const_integer(&mut self, expr: &hir::Expr) {\n         // FIXME(eddyb) Closures should have separate\n         // function definition IDs and expression IDs.\n         if let hir::ExprClosure(..) = expr.node {\n@@ -115,9 +117,15 @@ impl<'ast> DefCollector<'ast> {\n \n         self.create_def(expr.id, DefPathData::Initializer);\n     }\n+\n+    fn visit_macro_invoc(&mut self, id: NodeId) {\n+        if let Some(ref mut visit) = self.visit_macro_invoc {\n+            visit(id, self.parent_def.unwrap());\n+        }\n+    }\n }\n \n-impl<'ast> visit::Visitor for DefCollector<'ast> {\n+impl<'a> visit::Visitor for DefCollector<'a> {\n     fn visit_item(&mut self, i: &Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n@@ -129,10 +137,14 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) | ItemKind::Trait(..) |\n             ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n                 DefPathData::TypeNs(i.ident.name.as_str()),\n+            ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n+                return visit::walk_item(self, i);\n+            }\n             ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_str()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n                 DefPathData::ValueNs(i.ident.name.as_str()),\n-            ItemKind::Mac(..) => DefPathData::MacroDef(i.ident.name.as_str()),\n+            ItemKind::Mac(..) if i.id == DUMMY_NODE_ID => return, // Scope placeholder\n+            ItemKind::Mac(..) => return self.visit_macro_invoc(i.id),\n             ItemKind::Use(..) => DefPathData::Misc,\n         };\n         let def = self.create_def(i.id, def_data);\n@@ -198,7 +210,7 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n                 DefPathData::ValueNs(ti.ident.name.as_str()),\n             TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name.as_str()),\n-            TraitItemKind::Macro(..) => DefPathData::MacroDef(ti.ident.name.as_str()),\n+            TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id),\n         };\n \n         let def = self.create_def(ti.id, def_data);\n@@ -216,7 +228,7 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n                 DefPathData::ValueNs(ii.ident.name.as_str()),\n             ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name.as_str()),\n-            ImplItemKind::Macro(..) => DefPathData::MacroDef(ii.ident.name.as_str()),\n+            ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id),\n         };\n \n         let def = self.create_def(ii.id, def_data);\n@@ -232,9 +244,13 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n     fn visit_pat(&mut self, pat: &Pat) {\n         let parent_def = self.parent_def;\n \n-        if let PatKind::Ident(_, id, _) = pat.node {\n-            let def = self.create_def(pat.id, DefPathData::Binding(id.node.name.as_str()));\n-            self.parent_def = Some(def);\n+        match pat.node {\n+            PatKind::Mac(..) => return self.visit_macro_invoc(pat.id),\n+            PatKind::Ident(_, id, _) => {\n+                let def = self.create_def(pat.id, DefPathData::Binding(id.node.name.as_str()));\n+                self.parent_def = Some(def);\n+            }\n+            _ => {}\n         }\n \n         visit::walk_pat(self, pat);\n@@ -244,25 +260,28 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n     fn visit_expr(&mut self, expr: &Expr) {\n         let parent_def = self.parent_def;\n \n-        if let ExprKind::Repeat(_, ref count) = expr.node {\n-            self.visit_ast_const_integer(count);\n-        }\n-\n-        if let ExprKind::Closure(..) = expr.node {\n-            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n-            self.parent_def = Some(def);\n+        match expr.node {\n+            ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id),\n+            ExprKind::Repeat(_, ref count) => self.visit_ast_const_integer(count),\n+            ExprKind::Closure(..) => {\n+                let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n+                self.parent_def = Some(def);\n+            }\n+            _ => {}\n         }\n \n         visit::walk_expr(self, expr);\n         self.parent_def = parent_def;\n     }\n \n     fn visit_ty(&mut self, ty: &Ty) {\n-        if let TyKind::FixedLengthVec(_, ref length) = ty.node {\n-            self.visit_ast_const_integer(length);\n-        }\n-        if let TyKind::ImplTrait(..) = ty.node {\n-            self.create_def(ty.id, DefPathData::ImplTrait);\n+        match ty.node {\n+            TyKind::Mac(..) => return self.visit_macro_invoc(ty.id),\n+            TyKind::FixedLengthVec(_, ref length) => self.visit_ast_const_integer(length),\n+            TyKind::ImplTrait(..) => {\n+                self.create_def(ty.id, DefPathData::ImplTrait);\n+            }\n+            _ => {}\n         }\n         visit::walk_ty(self, ty);\n     }\n@@ -274,6 +293,13 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n     fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n         self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name.as_str()));\n     }\n+\n+    fn visit_stmt(&mut self, stmt: &Stmt) {\n+        match stmt.node {\n+            StmtKind::Mac(..) => self.visit_macro_invoc(stmt.id),\n+            _ => visit::walk_stmt(self, stmt),\n+        }\n+    }\n }\n \n // We walk the HIR rather than the AST when reading items from metadata."}, {"sha": "f87844652cc199e8e6ab0e0e9cd36644ccf7bf9d", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebaaafcd5d9c71745bfb489e51b074ce00d2e158/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaaafcd5d9c71745bfb489e51b074ce00d2e158/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=ebaaafcd5d9c71745bfb489e51b074ce00d2e158", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n-use hir::map::def_collector::DefCollector;\n use rustc_data_structures::fnv::FnvHashMap;\n use std::fmt::Write;\n use std::hash::{Hash, Hasher, SipHasher};\n-use syntax::{ast, visit};\n+use syntax::ast;\n use syntax::parse::token::{self, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n@@ -224,12 +223,6 @@ impl Definitions {\n         }\n     }\n \n-    pub fn collect(&mut self, krate: &ast::Crate) {\n-        let mut def_collector = DefCollector::new(self);\n-        def_collector.collect_root();\n-        visit::walk_crate(&mut def_collector, krate);\n-    }\n-\n     /// Get the number of definitions.\n     pub fn len(&self) -> usize {\n         self.data.len()"}, {"sha": "cd085177ed71a3195634010466f1992472ff64e4", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebaaafcd5d9c71745bfb489e51b074ce00d2e158/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaaafcd5d9c71745bfb489e51b074ce00d2e158/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=ebaaafcd5d9c71745bfb489e51b074ce00d2e158", "patch": "@@ -11,7 +11,7 @@\n pub use self::Node::*;\n use self::MapEntry::*;\n use self::collector::NodeCollector;\n-use self::def_collector::DefCollector;\n+pub use self::def_collector::DefCollector;\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, InlinedRootPath};\n "}, {"sha": "226eb545d2c1a7c66d46d545509d4009bdc261d6", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebaaafcd5d9c71745bfb489e51b074ce00d2e158/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaaafcd5d9c71745bfb489e51b074ce00d2e158/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ebaaafcd5d9c71745bfb489e51b074ce00d2e158", "patch": "@@ -733,9 +733,6 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n         })\n     })?;\n \n-    // Collect defintions for def ids.\n-    time(sess.time_passes(), \"collecting defs\", || resolver.definitions.collect(&krate));\n-\n     time(sess.time_passes(),\n          \"early lint checks\",\n          || lint::check_ast_crate(sess, &krate));"}, {"sha": "467967a4f338288e26d07bdd83dc1ce34aac2066", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ebaaafcd5d9c71745bfb489e51b074ce00d2e158/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaaafcd5d9c71745bfb489e51b074ce00d2e158/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ebaaafcd5d9c71745bfb489e51b074ce00d2e158", "patch": "@@ -42,7 +42,7 @@ use self::RibKind::*;\n use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n \n-use rustc::hir::map::Definitions;\n+use rustc::hir::map::{Definitions, DefCollector};\n use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n use rustc::middle::cstore::CrateLoader;\n use rustc::session::Session;\n@@ -1188,13 +1188,16 @@ impl<'a> Resolver<'a> {\n         let mut module_map = NodeMap();\n         module_map.insert(CRATE_NODE_ID, graph_root);\n \n+        let mut definitions = Definitions::new();\n+        DefCollector::new(&mut definitions).collect_root();\n+\n         let mut expansion_data = FnvHashMap();\n-        expansion_data.insert(0, macros::ExpansionData::default()); // Crate root expansion\n+        expansion_data.insert(0, macros::ExpansionData::root()); // Crate root expansion\n \n         Resolver {\n             session: session,\n \n-            definitions: Definitions::new(),\n+            definitions: definitions,\n             macros_at_scope: FnvHashMap(),\n \n             // The outermost module has def ID 0; this is not reflected in the\n@@ -1264,6 +1267,13 @@ impl<'a> Resolver<'a> {\n \n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n+        // Collect `DefId`s for exported macro defs.\n+        for def in &krate.exported_macros {\n+            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n+                collector.visit_macro_def(def)\n+            })\n+        }\n+\n         self.current_module = self.graph_root;\n         visit::walk_crate(self, krate);\n "}, {"sha": "ebfdc32fabd3c2d27deb8007a81dec8c8c0fb0a9", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ebaaafcd5d9c71745bfb489e51b074ce00d2e158/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebaaafcd5d9c71745bfb489e51b074ce00d2e158/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ebaaafcd5d9c71745bfb489e51b074ce00d2e158", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n use Resolver;\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n+use rustc::hir::map::DefCollector;\n use rustc::middle::cstore::LoadedMacro;\n use rustc::util::nodemap::FnvHashMap;\n use std::cell::RefCell;\n@@ -27,9 +29,19 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n \n-#[derive(Clone, Default)]\n+#[derive(Clone)]\n pub struct ExpansionData {\n     module: Rc<ModuleData>,\n+    def_index: DefIndex,\n+}\n+\n+impl ExpansionData {\n+    pub fn root() -> Self {\n+        ExpansionData {\n+            module: Default::default(),\n+            def_index: CRATE_DEF_INDEX,\n+        }\n+    }\n }\n \n // FIXME(jseyfried): merge with `::ModuleS`.\n@@ -46,10 +58,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n-        expansion.visit_with(&mut ExpansionVisitor {\n-            current_module: self.expansion_data[&mark.as_u32()].module.clone(),\n-            resolver: self,\n-        });\n+        let module = self.expansion_data[&mark.as_u32()].module.clone();\n+        let mut visitor = ExpansionVisitor { current_module: module, resolver: self };\n+        visitor.collect_def_ids(mark, expansion);\n+        expansion.visit_with(&mut visitor);\n     }\n \n     fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef) {\n@@ -166,9 +178,8 @@ struct ExpansionVisitor<'b, 'a: 'b> {\n \n impl<'a, 'b> ExpansionVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) {\n-        self.resolver.expansion_data.insert(id.as_u32(), ExpansionData {\n-            module: self.current_module.clone(),\n-        });\n+        self.resolver.expansion_data.get_mut(&id.as_u32()).unwrap().module =\n+            self.current_module.clone();\n     }\n \n     // does this attribute list contain \"macro_use\"?\n@@ -195,6 +206,22 @@ impl<'a, 'b> ExpansionVisitor<'a, 'b> {\n \n         false\n     }\n+\n+    fn collect_def_ids(&mut self, mark: Mark, expansion: &Expansion) {\n+        let expansion_data = &mut self.resolver.expansion_data;\n+        let module = &self.current_module;\n+        let def_index = expansion_data[&mark.as_u32()].def_index;\n+        let visit_macro_invoc = &mut |id: ast::NodeId, def_index| {\n+            expansion_data.insert(id.as_u32(), ExpansionData {\n+                def_index: def_index,\n+                module: module.clone(),\n+            });\n+        };\n+\n+        let mut def_collector = DefCollector::new(&mut self.resolver.definitions);\n+        def_collector.visit_macro_invoc = Some(visit_macro_invoc);\n+        def_collector.with_parent(def_index, |def_collector| expansion.visit_with(def_collector));\n+    }\n }\n \n macro_rules! method {"}]}