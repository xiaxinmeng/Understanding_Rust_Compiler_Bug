{"sha": "59cb1705d790ac15d336525c4e2aa5bf5c9cf104", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5Y2IxNzA1ZDc5MGFjMTVkMzM2NTI1YzRlMmFhNWJmNWM5Y2YxMDQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-09-12T03:21:50Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-10-25T20:50:51Z"}, "message": "rebasing and reviewer changes\n\nPrimarily refactoring `(Ident, Option<NodeId>)` to `Segment`", "tree": {"sha": "7430280baeb662e438507e5eae84d396d76c33c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7430280baeb662e438507e5eae84d396d76c33c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59cb1705d790ac15d336525c4e2aa5bf5c9cf104", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59cb1705d790ac15d336525c4e2aa5bf5c9cf104", "html_url": "https://github.com/rust-lang/rust/commit/59cb1705d790ac15d336525c4e2aa5bf5c9cf104", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ac32726100c58ca66f3da6e35b423c17fc96a4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ac32726100c58ca66f3da6e35b423c17fc96a4f", "html_url": "https://github.com/rust-lang/rust/commit/8ac32726100c58ca66f3da6e35b423c17fc96a4f"}], "stats": {"total": 290, "additions": 157, "deletions": 133}, "files": [{"sha": "58d860d9d983b067a3f2b558381b4fdf420f2ce0", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=59cb1705d790ac15d336525c4e2aa5bf5c9cf104", "patch": "@@ -1385,7 +1385,6 @@ impl<'a> LoweringContext<'a> {\n             // does not actually exist in the AST.\n             lctx.items.insert(exist_ty_id.node_id, exist_ty_item);\n \n-            let def = Def::Existential(DefId::local(exist_ty_def_index));\n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`\n             hir::TyKind::Def(hir::ItemId { id: exist_ty_id.node_id }, lifetimes)\n         })"}, {"sha": "b7ed3ef59b4c891349c2695af1e7d8bab6108bf0", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=59cb1705d790ac15d336525c4e2aa5bf5c9cf104", "patch": "@@ -16,7 +16,7 @@\n use macros::{InvocationData, ParentScope, LegacyScope};\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n-use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n+use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n use {ModuleOrUniformRoot, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use {resolve_error, resolve_struct_error, ResolutionError};\n@@ -122,7 +122,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         use_tree: &ast::UseTree,\n         id: NodeId,\n         vis: ty::Visibility,\n-        parent_prefix: &[Ident],\n+        parent_prefix: &[Segment],\n         mut uniform_paths_canary_emitted: bool,\n         nested: bool,\n         item: &Item,\n@@ -139,10 +139,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             self.session.features_untracked().uniform_paths;\n \n         let prefix_iter = || parent_prefix.iter().cloned()\n-            .chain(use_tree.prefix.segments.iter().map(|seg| seg.ident));\n+            .chain(use_tree.prefix.segments.iter().map(|seg| seg.into()));\n         let prefix_start = prefix_iter().next();\n-        let starts_with_non_keyword = prefix_start.map_or(false, |(ident, _)| {\n-            !ident.is_path_segment_keyword()\n+        let starts_with_non_keyword = prefix_start.map_or(false, |seg| {\n+            !seg.ident.is_path_segment_keyword()\n         });\n \n         // Imports are resolved as global by default, prepend `CrateRoot`,\n@@ -156,7 +156,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             };\n         let root = if inject_crate_root {\n             let span = use_tree.prefix.span.shrink_to_lo();\n-            Some(Ident::new(keywords::CrateRoot.name(), span))\n+            Some(Segment::from_ident(Ident::new(keywords::CrateRoot.name(), span)))\n         } else {\n             None\n         };\n@@ -202,13 +202,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             let source = prefix_start.unwrap();\n \n             // Helper closure to emit a canary with the given base path.\n-            let emit = |this: &mut Self, base: Option<(Ident, Option<NodeId>)>| {\n+            let emit = |this: &mut Self, base: Option<Segment>| {\n                 let subclass = SingleImport {\n                     target: Ident {\n                         name: keywords::Underscore.name().gensymed(),\n-                        span: source.0.span,\n+                        span: source.ident.span,\n                     },\n-                    source: source.0,\n+                    source: source.ident,\n                     result: PerNS {\n                         type_ns: Cell::new(Err(Undetermined)),\n                         value_ns: Cell::new(Err(Undetermined)),\n@@ -219,7 +219,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 this.add_import_directive(\n                     base.into_iter().collect(),\n                     subclass.clone(),\n-                    source.0.span,\n+                    source.ident.span,\n                     id,\n                     root_use_tree.span,\n                     root_id,\n@@ -230,15 +230,18 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             };\n \n             // A single simple `self::x` canary.\n-            emit(self, Some((Ident {\n-                name: keywords::SelfValue.name(),\n-                span: source.0.span,\n-            }, source.1)));\n+            emit(self, Some(Segment {\n+                ident: Ident {\n+                    name: keywords::SelfValue.name(),\n+                    span: source.ident.span,\n+                },\n+                id: source.id\n+            }));\n \n             // One special unprefixed canary per block scope around\n             // the import, to detect items unreachable by `self::x`.\n             let orig_current_module = self.current_module;\n-            let mut span = source.0.span.modern();\n+            let mut span = source.ident.span.modern();\n             loop {\n                 match self.current_module.kind {\n                     ModuleKind::Block(..) => emit(self, None),\n@@ -265,11 +268,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                 if nested {\n                     // Correctly handle `self`\n-                    if source.0.name == keywords::SelfValue.name() {\n+                    if source.ident.name == keywords::SelfValue.name() {\n                         type_ns_only = true;\n \n-                        let empty_prefix = module_path.last().map_or(true, |(ident, _)| {\n-                            ident.name == keywords::CrateRoot.name()\n+                        let empty_prefix = module_path.last().map_or(true, |seg| {\n+                            seg.ident.name == keywords::CrateRoot.name()\n                         });\n                         if empty_prefix {\n                             resolve_error(\n@@ -284,20 +287,20 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         // Replace `use foo::self;` with `use foo;`\n                         source = module_path.pop().unwrap();\n                         if rename.is_none() {\n-                            ident = source.0;\n+                            ident = source.ident;\n                         }\n                     }\n                 } else {\n                     // Disallow `self`\n-                    if source.0.name == keywords::SelfValue.name() {\n+                    if source.ident.name == keywords::SelfValue.name() {\n                         resolve_error(self,\n                                       use_tree.span,\n                                       ResolutionError::SelfImportsOnlyAllowedWithin);\n                     }\n \n                     // Disallow `use $crate;`\n-                    if source.0.name == keywords::DollarCrate.name() && module_path.is_empty() {\n-                        let crate_root = self.resolve_crate_root(source.0);\n+                    if source.ident.name == keywords::DollarCrate.name() && module_path.is_empty() {\n+                        let crate_root = self.resolve_crate_root(source.ident);\n                         let crate_name = match crate_root.kind {\n                             ModuleKind::Def(_, name) => name,\n                             ModuleKind::Block(..) => unreachable!(),\n@@ -307,11 +310,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         // while the current crate doesn't have a valid `crate_name`.\n                         if crate_name != keywords::Invalid.name() {\n                             // `crate_name` should not be interpreted as relative.\n-                            module_path.push((Ident {\n-                                name: keywords::CrateRoot.name(),\n-                                span: source.0.span,\n-                            }, Some(self.session.next_node_id())));\n-                            source.0.name = crate_name;\n+                            module_path.push(Segment {\n+                                ident: Ident {\n+                                    name: keywords::CrateRoot.name(),\n+                                    span: source.ident.span,\n+                                },\n+                                id: Some(self.session.next_node_id()),\n+                            });\n+                            source.ident.name = crate_name;\n                         }\n                         if rename.is_none() {\n                             ident.name = crate_name;\n@@ -332,7 +338,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                 let subclass = SingleImport {\n                     target: ident,\n-                    source: source.0,\n+                    source: source.ident,\n                     result: PerNS {\n                         type_ns: Cell::new(Err(Undetermined)),\n                         value_ns: Cell::new(Err(Undetermined)),\n@@ -392,17 +398,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     e.emit();\n                 }\n \n-                let prefix = ast::Path {\n-                    segments: module_path.into_iter()\n-                        .map(|(ident, id)| {\n-                            let mut seg = ast::PathSegment::from_ident(ident);\n-                            seg.id = id.expect(\"Missing node id\");\n-                            seg\n-                        })\n-                        .collect(),\n-                    span: path.span,\n-                };\n-\n                 for &(ref tree, id) in items {\n                     self.build_reduced_graph_for_use_tree(\n                         root_use_tree,"}, {"sha": "d77b1868ed72e736331ec463aaf0f3d275f0f379", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=59cb1705d790ac15d336525c4e2aa5bf5c9cf104", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {CrateLint, PathResult};\n+use {CrateLint, PathResult, Segment};\n \n use std::collections::BTreeSet;\n \n@@ -23,8 +23,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     pub(crate) fn make_path_suggestion(\n         &mut self,\n         span: Span,\n-        path: Vec<Ident>\n-    ) -> Option<Vec<Ident>> {\n+        path: Vec<Segment>\n+    ) -> Option<Vec<Segment>> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n         // If we don't have a path to suggest changes to, then return.\n         if path.is_empty() {\n@@ -37,13 +37,13 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n         match (path.get(0), path.get(1)) {\n             // Make suggestions that require at least two non-special path segments.\n-            (Some(fst), Some(snd)) if !is_special(*fst) && !is_special(*snd) => {\n+            (Some(fst), Some(snd)) if !is_special(fst.ident) && !is_special(snd.ident) => {\n                 debug!(\"make_path_suggestion: fst={:?} snd={:?}\", fst, snd);\n \n                 self.make_missing_self_suggestion(span, path.clone())\n                     .or_else(|| self.make_missing_crate_suggestion(span, path.clone()))\n                     .or_else(|| self.make_missing_super_suggestion(span, path.clone()))\n-                    .or_else(|| self.make_external_crate_suggestion(span, path.clone()))\n+                    .or_else(|| self.make_external_crate_suggestion(span, path))\n             },\n             _ => None,\n         }\n@@ -59,10 +59,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_missing_self_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Ident>\n-    ) -> Option<Vec<Ident>> {\n+        mut path: Vec<Segment>\n+    ) -> Option<Vec<Segment>> {\n         // Replace first ident with `self` and check if that is valid.\n-        path[0].name = keywords::SelfValue.name();\n+        path[0].ident.name = keywords::SelfValue.name();\n         let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n@@ -82,10 +82,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_missing_crate_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Ident>\n-    ) -> Option<Vec<Ident>> {\n+        mut path: Vec<Segment>\n+    ) -> Option<Vec<Segment>> {\n         // Replace first ident with `crate` and check if that is valid.\n-        path[0].name = keywords::Crate.name();\n+        path[0].ident.name = keywords::Crate.name();\n         let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n@@ -105,10 +105,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_missing_super_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Ident>\n-    ) -> Option<Vec<Ident>> {\n+        mut path: Vec<Segment>\n+    ) -> Option<Vec<Segment>> {\n         // Replace first ident with `crate` and check if that is valid.\n-        path[0].name = keywords::Super.name();\n+        path[0].ident.name = keywords::Super.name();\n         let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n@@ -131,8 +131,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_external_crate_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Ident>\n-    ) -> Option<Vec<Ident>> {\n+        mut path: Vec<Segment>\n+    ) -> Option<Vec<Segment>> {\n         // Need to clone else we can't call `resolve_path` without a borrow error. We also store\n         // into a `BTreeMap` so we can get consistent ordering (and therefore the same diagnostic)\n         // each time.\n@@ -148,7 +148,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         for name in external_crate_names.iter().rev() {\n             // Replace the first after root (a placeholder we inserted) with a crate name\n             // and check if that is valid.\n-            path[1].name = *name;\n+            path[1].ident.name = *name;\n             let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n             debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                     name, path, result);\n@@ -157,8 +157,6 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             }\n         }\n \n-        // Remove our placeholder segment.\n-        path.remove(1);\n         None\n     }\n }"}, {"sha": "58e39e900ac917748f29f785012de71c40883a2c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 81, "deletions": 48, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=59cb1705d790ac15d336525c4e2aa5bf5c9cf104", "patch": "@@ -632,6 +632,43 @@ impl<'a> PathSource<'a> {\n     }\n }\n \n+// A minimal representation of a path segment. We use this in resolve because\n+// we synthesize 'path segments' which don't have the rest of an AST or HIR\n+// PathSegment.\n+#[derive(Clone, Copy, Debug)]\n+pub struct Segment {\n+    ident: Ident,\n+    id: Option<NodeId>,\n+}\n+\n+impl Segment {\n+    fn from_path(path: &Path) -> Vec<Segment> {\n+        path.segments.iter().map(|s| s.into()).collect()\n+    }\n+\n+    fn from_ident(ident: Ident) -> Segment {\n+        Segment {\n+            ident,\n+            id: None,\n+        }\n+    }\n+\n+    fn names_to_string(segments: &[Segment]) -> String {\n+        names_to_string(&segments.iter()\n+                            .map(|seg| seg.ident)\n+                            .collect::<Vec<_>>())\n+    }\n+}\n+\n+impl<'a> From<&'a ast::PathSegment> for Segment {\n+    fn from(seg: &'a ast::PathSegment) -> Segment {\n+        Segment {\n+            ident: seg.ident,\n+            id: Some(seg.id),\n+        }\n+    }\n+}\n+\n struct UsePlacementFinder {\n     target_module: NodeId,\n     span: Option<Span>,\n@@ -1632,7 +1669,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let span = path.span;\n         let segments = &path.segments;\n-        let path: Vec<_> = segments.iter().map(|seg| (seg.ident, Some(seg.id))).collect();\n+        let path = Segment::from_path(&path);\n         // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n         let def = match self.resolve_path(None, &path, Some(namespace), true, span, CrateLint::No) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n@@ -2482,9 +2519,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n-            let path: Vec<_> = trait_ref.path.segments.iter()\n-                .map(|seg| (seg.ident, Some(seg.id)))\n-                .collect();\n+            let path: Vec<_> = Segment::from_path(&trait_ref.path);\n             let def = self.smart_resolve_path_fragment(\n                 trait_ref.ref_id,\n                 None,\n@@ -2980,21 +3015,25 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         source: PathSource,\n         crate_lint: CrateLint\n     ) -> PathResolution {\n-        let segments = &path.segments.iter()\n-            .map(|seg| (seg.ident, Some(seg.id)))\n-            .collect::<Vec<_>>();\n-        self.smart_resolve_path_fragment(id, qself, segments, path.span, source, crate_lint)\n+        self.smart_resolve_path_fragment(\n+            id,\n+            qself,\n+            &Segment::from_path(path),\n+            path.span,\n+            source,\n+            crate_lint,\n+        )\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n-                                   path: &[(Ident, Option<NodeId>)],\n+                                   path: &[Segment],\n                                    span: Span,\n                                    source: PathSource,\n                                    crate_lint: CrateLint)\n                                    -> PathResolution {\n-        let ident_span = path.last().map_or(span, |ident| ident.0.span);\n+        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n         let ns = source.namespace();\n         let is_expected = &|def| source.is_expected(def);\n         let is_enum_variant = &|def| if let Def::Variant(..) = def { true } else { false };\n@@ -3004,17 +3043,17 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             // Make the base error.\n             let expected = source.descr_expected();\n             let path_str = names_to_string(path);\n-            let item_str = path.last().unwrap().0;\n+            let item_str = path.last().unwrap().ident;\n             let code = source.error_code(def.is_some());\n             let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n                 (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n                  format!(\"not a {}\", expected),\n                  span)\n             } else {\n-                let item_span = path.last().unwrap().0.span;\n+                let item_span = path.last().unwrap().ident.span;\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n                     (String::new(), \"this scope\".to_string())\n-                } else if path.len() == 2 && path[0].0.name == keywords::CrateRoot.name() {\n+                } else if path.len() == 2 && path[0].ident.name == keywords::CrateRoot.name() {\n                     (String::new(), \"the crate root\".to_string())\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n@@ -3024,7 +3063,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             module.def(),\n                         _ => None,\n                     }.map_or(String::new(), |def| format!(\"{} \", def.kind_name()));\n-                    (mod_prefix, format!(\"`{}`\", names_and_ids_to_string(mod_path)))\n+                    (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n                 };\n                 (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n                  format!(\"not found in {}\", mod_str),\n@@ -3035,7 +3074,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             // Emit help message for fake-self from other languages like `this`(javascript)\n             if [\"this\", \"my\"].contains(&&*item_str.as_str())\n-                && this.self_value_is_available(path[0].span, span) {\n+                && this.self_value_is_available(path[0].ident.span, span) {\n                 err.span_suggestion_with_applicability(\n                     span,\n                     \"did you mean\",\n@@ -3070,7 +3109,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n \n             // Try to lookup the name in more relaxed fashion for better error reporting.\n-            let ident = path.last().unwrap().0;\n+            let ident = path.last().unwrap().ident;\n             let candidates = this.lookup_import_candidates(ident.name, ns, is_expected);\n             if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n                 let enum_candidates =\n@@ -3097,7 +3136,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n             if path.len() == 1 && this.self_type_is_available(span) {\n                 if let Some(candidate) = this.lookup_assoc_candidate(ident, ns, is_expected) {\n-                    let self_is_available = this.self_value_is_available(path[0].0.span, span);\n+                    let self_is_available = this.self_value_is_available(path[0].ident.span, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n                             err.span_suggestion_with_applicability(\n@@ -3332,7 +3371,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 // or `<T>::A::B`. If `B` should be resolved in value namespace then\n                 // it needs to be added to the trait map.\n                 if ns == ValueNS {\n-                    let item_name = path.last().unwrap().0;\n+                    let item_name = path.last().unwrap().ident;\n                     let traits = self.get_traits_containing_item(item_name, ns);\n                     self.trait_map.insert(id, traits);\n                 }\n@@ -3402,7 +3441,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn resolve_qpath_anywhere(&mut self,\n                               id: NodeId,\n                               qself: Option<&QSelf>,\n-                              path: &[(Ident, Option<NodeId>)],\n+                              path: &[Segment],\n                               primary_ns: Namespace,\n                               span: Span,\n                               defer_to_typeck: bool,\n@@ -3424,10 +3463,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n         }\n         if primary_ns != MacroNS &&\n-           (self.macro_names.contains(&path[0].0.modern()) ||\n-            self.builtin_macros.get(&path[0].0.name).cloned()\n+           (self.macro_names.contains(&path[0].ident.modern()) ||\n+            self.builtin_macros.get(&path[0].ident.name).cloned()\n                                .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang) ||\n-            self.macro_use_prelude.get(&path[0].0.name).cloned()\n+            self.macro_use_prelude.get(&path[0].ident.name).cloned()\n                                   .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang)) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n@@ -3441,7 +3480,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn resolve_qpath(&mut self,\n                      id: NodeId,\n                      qself: Option<&QSelf>,\n-                     path: &[(Ident, Option<NodeId>)],\n+                     path: &[Segment],\n                      ns: Namespace,\n                      span: Span,\n                      global_by_default: bool,\n@@ -3531,8 +3570,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             PathResult::Failed(..)\n                     if (ns == TypeNS || path.len() > 1) &&\n                        self.primitive_type_table.primitive_types\n-                           .contains_key(&path[0].0.name) => {\n-                let prim = self.primitive_type_table.primitive_types[&path[0].0.name];\n+                           .contains_key(&path[0].ident.name) => {\n+                let prim = self.primitive_type_table.primitive_types[&path[0].ident.name];\n                 PathResolution::with_unresolved_segments(Def::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n@@ -3547,8 +3586,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         };\n \n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n-           path[0].0.name != keywords::CrateRoot.name() &&\n-           path[0].0.name != keywords::DollarCrate.name() {\n+           path[0].ident.name != keywords::CrateRoot.name() &&\n+           path[0].ident.name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path(\n                     None,\n@@ -3576,7 +3615,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn resolve_path(\n         &mut self,\n         base_module: Option<ModuleOrUniformRoot<'a>>,\n-        path: &[(Ident, Option<NodeId>)],\n+        path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path\n         record_used: bool,\n         path_span: Span,\n@@ -3590,7 +3629,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn resolve_path_with_parent_scope(\n         &mut self,\n         base_module: Option<ModuleOrUniformRoot<'a>>,\n-        path: &[Ident],\n+        path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path\n         parent_scope: &ParentScope<'a>,\n         record_used: bool,\n@@ -3612,7 +3651,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             crate_lint,\n         );\n \n-        for (i, &(ident, id)) in path.iter().enumerate() {\n+        for (i, &Segment { ident, id }) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?}\", i, ident);\n \n             let is_last = i == path.len() - 1;\n@@ -3674,7 +3713,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 } else {\n                     format!(\"`{}`\", name)\n                 };\n-                let msg = if i == 1 && path[0].0.name == keywords::CrateRoot.name() {\n+                let msg = if i == 1 && path[0].ident.name == keywords::CrateRoot.name() {\n                     format!(\"global paths cannot start with {}\", name_str)\n                 } else {\n                     format!(\"{} in paths can only be used in start position\", name_str)\n@@ -3771,7 +3810,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     } else if i == 0 {\n                         format!(\"Use of undeclared type or module `{}`\", ident)\n                     } else {\n-                        format!(\"Could not find `{}` in `{}`\", ident, path[i - 1].0)\n+                        format!(\"Could not find `{}` in `{}`\", ident, path[i - 1].ident)\n                     };\n                     return PathResult::Failed(ident.span, msg, is_last);\n                 }\n@@ -3789,7 +3828,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn lint_if_path_starts_with_module(\n         &self,\n         crate_lint: CrateLint,\n-        path: &[(Ident, Option<NodeId>)],\n+        path: &[Segment],\n         path_span: Span,\n         second_binding: Option<&NameBinding>,\n     ) {\n@@ -3806,7 +3845,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         };\n \n         let first_name = match path.get(0) {\n-            Some(ident) => ident.0.name,\n+            Some(ident) => ident.ident.name,\n             None => return,\n         };\n \n@@ -3818,7 +3857,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         match path.get(1) {\n             // If this import looks like `crate::...` it's already good\n-            Some((ident, _)) if ident.name == keywords::Crate.name() => return,\n+            Some(Segment { ident, .. }) if ident.name == keywords::Crate.name() => return,\n             // Otherwise go below to see if it's an extern crate\n             Some(_) => {}\n             // If the path has length one (and it's `CrateRoot` most likely)\n@@ -4011,7 +4050,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn lookup_typo_candidate<FilterFn>(&mut self,\n-                                       path: &[(Ident, Option<NodeId>)],\n+                                       path: &[Segment],\n                                        ns: Namespace,\n                                        filter_fn: FilterFn,\n                                        span: Span)\n@@ -4075,7 +4114,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n         }\n \n-        let name = path[path.len() - 1].0.name;\n+        let name = path[path.len() - 1].ident.name;\n         // Make sure error reporting is deterministic.\n         names.sort_by_cached_key(|name| name.as_str());\n         match find_best_match_for_name(names.iter(), &name.as_str(), None) {\n@@ -4592,7 +4631,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 // Visibilities are resolved as global by default, add starting root segment.\n                 let segments = path.make_root().iter().chain(path.segments.iter())\n-                    .map(|seg| (seg.ident, Some(seg.id)))\n+                    .map(|seg| Segment { ident: seg.ident, id: Some(seg.id) })\n                     .collect::<Vec<_>>();\n                 let def = self.smart_resolve_path_fragment(\n                     id,\n@@ -4885,12 +4924,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n }\n \n-fn is_self_type(path: &[(Ident, Option<NodeId>)], namespace: Namespace) -> bool {\n-    namespace == TypeNS && path.len() == 1 && path[0].0.name == keywords::SelfType.name()\n+fn is_self_type(path: &[Segment], namespace: Namespace) -> bool {\n+    namespace == TypeNS && path.len() == 1 && path[0].ident.name == keywords::SelfType.name()\n }\n \n-fn is_self_value(path: &[(Ident, Option<NodeId>)], namespace: Namespace) -> bool {\n-    namespace == ValueNS && path.len() == 1 && path[0].0.name == keywords::SelfValue.name()\n+fn is_self_value(path: &[Segment], namespace: Namespace) -> bool {\n+    namespace == ValueNS && path.len() == 1 && path[0].ident.name == keywords::SelfValue.name()\n }\n \n fn names_to_string(idents: &[Ident]) -> String {\n@@ -4906,12 +4945,6 @@ fn names_to_string(idents: &[Ident]) -> String {\n     result\n }\n \n-fn names_and_ids_to_string(segments: &[(Ident, Option<NodeId>)]) -> String {\n-    names_to_string(&segments.iter()\n-                        .map(|seg| seg.0)\n-                        .collect::<Vec<_>>())\n-}\n-\n fn path_names_to_string(path: &Path) -> String {\n     names_to_string(&path.segments.iter()\n                         .map(|seg| seg.ident)"}, {"sha": "68b3a6be2928253a48a385f8aaaa80f1d42da9e3", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=59cb1705d790ac15d336525c4e2aa5bf5c9cf104", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use {AmbiguityError, CrateLint, Resolver, ResolutionError, is_known_tool, resolve_error};\n-use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, ToNameBinding};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n use ModuleOrUniformRoot;\n use Namespace::{self, *};\n use build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n@@ -461,14 +461,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         parent_scope: &ParentScope<'a>,\n         force: bool,\n     ) -> Result<Def, Determinacy> {\n-        let ast::Path { ref segments, span } = *path;\n-        let mut path: Vec<_> = segments.iter().map(|seg| (seg.ident, Some(seg.id))).collect();\n+        let span = path.span;\n+        let mut path = Segment::from_path(path);\n \n         // Possibly apply the macro helper hack\n         if kind == MacroKind::Bang && path.len() == 1 &&\n-           path[0].0.span.ctxt().outer().expn_info().map_or(false, |info| info.local_inner_macros) {\n-            let root = Ident::new(keywords::DollarCrate.name(), path[0].0.span);\n-            path.insert(0, (root, None));\n+           path[0].ident.span.ctxt().outer().expn_info()\n+               .map_or(false, |info| info.local_inner_macros) {\n+            let root = Ident::new(keywords::DollarCrate.name(), path[0].ident.span);\n+            path.insert(0, Segment::from_ident(root));\n         }\n \n         if path.len() > 1 {\n@@ -498,14 +499,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             parent_scope.module.macro_resolutions.borrow_mut()\n                 .push((path\n                     .iter()\n-                    .map(|(ident, _)| *ident)\n+                    .map(|seg| seg.ident)\n                     .collect::<Vec<Ident>>()\n                     .into_boxed_slice(), span));\n \n             def\n         } else {\n             let binding = self.early_resolve_ident_in_lexical_scope(\n-                path[0].0, MacroNS, Some(kind), parent_scope, false, force, span\n+                path[0].ident, MacroNS, Some(kind), parent_scope, false, force, span\n             );\n             match binding {\n                 Ok(..) => {}\n@@ -514,7 +515,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n \n             parent_scope.module.legacy_macro_resolutions.borrow_mut()\n-                .push((path[0].0, kind, parent_scope.clone(), binding.ok()));\n+                .push((path[0].ident, kind, parent_scope.clone(), binding.ok()));\n \n             binding.map(|binding| binding.def_ignoring_ambiguity())\n         }\n@@ -850,10 +851,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            let path = path\n-                .iter()\n-                .map(|ident| (*ident, None))\n-                .collect::<Vec<(Ident, Option<ast::NodeId>)>>();\n+            let path: Vec<_> = path.iter().map(|&ident| Segment::from_ident(ident)).collect();\n             match self.resolve_path(None, &path, Some(MacroNS), true, span, CrateLint::No) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(span, msg, _) => {\n@@ -946,7 +944,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 }\n             };\n             let ident = Ident::new(Symbol::intern(name), span);\n-            self.lookup_typo_candidate(&[(ident, None)], MacroNS, is_macro, span)\n+            self.lookup_typo_candidate(&[Segment::from_ident(ident)], MacroNS, is_macro, span)\n         });\n \n         if let Some(suggestion) = suggestion {"}, {"sha": "bd968f1cbec257cbff2a8ad1d69eb139f555ab59", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=59cb1705d790ac15d336525c4e2aa5bf5c9cf104", "patch": "@@ -13,8 +13,8 @@ use self::ImportDirectiveSubclass::*;\n use {AmbiguityError, CrateLint, Module, ModuleOrUniformRoot, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n-use Resolver;\n-use {names_to_string, names_and_ids_to_string, module_to_string};\n+use {Resolver, Segment};\n+use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n \n use rustc_data_structures::ptr_key::PtrKey;\n@@ -89,7 +89,7 @@ pub struct ImportDirective<'a> {\n     pub root_span: Span,\n \n     pub parent: Module<'a>,\n-    pub module_path: Vec<(Ident, Option<NodeId>)>,\n+    pub module_path: Vec<Segment>,\n     /// The resolution of `module_path`.\n     pub imported_module: Cell<Option<ModuleOrUniformRoot<'a>>>,\n     pub subclass: ImportDirectiveSubclass<'a>,\n@@ -393,7 +393,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n \n     // Add an import directive to the current module.\n     pub fn add_import_directive(&mut self,\n-                                module_path: Vec<(Ident, Option<NodeId>)>,\n+                                module_path: Vec<Segment>,\n                                 subclass: ImportDirectiveSubclass<'a>,\n                                 span: Span,\n                                 id: NodeId,\n@@ -679,7 +679,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n                 let has_explicit_self =\n                     !import.module_path.is_empty() &&\n-                    import.module_path[0].0.name == keywords::SelfValue.name();\n+                    import.module_path[0].ident.name == keywords::SelfValue.name();\n \n                 self.per_ns(|_, ns| {\n                     if let Some(result) = result[ns].get().ok() {\n@@ -729,7 +729,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 }\n                 if !seen_spans.contains(&span) {\n                     let path = import_path_to_string(\n-                        &import.module_path.iter().map(|(ident, _)| *ident).collect::<Vec<_>>(),\n+                        &import.module_path.iter().map(|seg| seg.ident).collect::<Vec<_>>(),\n                         &import.subclass,\n                         span,\n                     );\n@@ -853,9 +853,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               names_and_ids_to_string(&directive.module_path[..]),\n+               Segment::names_to_string(&directive.module_path[..]),\n                module_to_string(self.current_module).unwrap_or_else(|| \"???\".to_string()));\n \n+\n         self.current_module = directive.parent;\n \n         let module = if let Some(module) = directive.imported_module.get() {\n@@ -968,7 +969,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 ) {\n                     Some((\n                         span,\n-                        format!(\"Did you mean `{}`?\", names_to_string(&suggested_path[..]))\n+                        format!(\"Did you mean `{}`?\", Segment::names_to_string(&suggested_path))\n                     ))\n                 } else {\n                     Some((span, msg))\n@@ -984,7 +985,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                     // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n                     let mut full_path = module_path.clone();\n-                    full_path.push((keywords::Invalid.ident(), None));\n+                    full_path.push(Segment::from_ident(keywords::Invalid.ident()));\n                     self.lint_if_path_starts_with_module(\n                         directive.crate_lint(),\n                         &full_path,\n@@ -1148,7 +1149,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n             // 2 segments, so the `resolve_path` above won't trigger it.\n             let mut full_path = module_path.clone();\n-            full_path.push((ident, None));\n+            full_path.push(Segment::from_ident(ident));\n             self.per_ns(|this, ns| {\n                 if let Ok(binding) = result[ns].get() {\n                     this.lint_if_path_starts_with_module(\n@@ -1290,7 +1291,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                         let resolutions = imported_module.parent.expect(\"parent should exist\")\n                             .resolutions.borrow();\n                         let enum_path_segment_index = directive.module_path.len() - 1;\n-                        let enum_ident = directive.module_path[enum_path_segment_index].0;\n+                        let enum_ident = directive.module_path[enum_path_segment_index].ident;\n \n                         let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n                             .expect(\"resolution should exist\");"}, {"sha": "589b3e30fcfbc41bbd24a258f4f70bd969e5a60a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59cb1705d790ac15d336525c4e2aa5bf5c9cf104/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=59cb1705d790ac15d336525c4e2aa5bf5c9cf104", "patch": "@@ -2137,7 +2137,7 @@ impl<'a> Parser<'a> {\n             PathSegment { ident, args, id: ast::DUMMY_NODE_ID }\n         } else {\n             // Generic arguments are not found.\n-            PathSegment::from_ident(ident,)\n+            PathSegment::from_ident(ident)\n         })\n     }\n "}]}