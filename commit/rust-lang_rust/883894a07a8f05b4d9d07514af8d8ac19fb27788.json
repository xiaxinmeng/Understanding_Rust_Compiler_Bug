{"sha": "883894a07a8f05b4d9d07514af8d8ac19fb27788", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4Mzg5NGEwN2E4ZjA1YjRkOWQwNzUxNGFmOGQ4YWMxOWZiMjc3ODg=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-14T09:52:39Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-14T09:52:39Z"}, "message": "Move trans_*_binop to num.rs", "tree": {"sha": "4bdf950bbee8803abe1bd75d3524c9da086fc8b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bdf950bbee8803abe1bd75d3524c9da086fc8b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/883894a07a8f05b4d9d07514af8d8ac19fb27788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/883894a07a8f05b4d9d07514af8d8ac19fb27788", "html_url": "https://github.com/rust-lang/rust/commit/883894a07a8f05b4d9d07514af8d8ac19fb27788", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/883894a07a8f05b4d9d07514af8d8ac19fb27788/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "581b6ea5bee7be1852713630d2eca8a7bd683e3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/581b6ea5bee7be1852713630d2eca8a7bd683e3e", "html_url": "https://github.com/rust-lang/rust/commit/581b6ea5bee7be1852713630d2eca8a7bd683e3e"}], "stats": {"total": 841, "additions": 422, "deletions": 419}, "files": [{"sha": "17abee4a003d701b98f95352d6681db67748688d", "filename": "src/base.rs", "status": "modified", "additions": 10, "deletions": 414, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/883894a07a8f05b4d9d07514af8d8ac19fb27788/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883894a07a8f05b4d9d07514af8d8ac19fb27788/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=883894a07a8f05b4d9d07514af8d8ac19fb27788", "patch": "@@ -314,17 +314,18 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                     let rhs = trans_operand(fx, rhs);\n \n                     let res = match ty.sty {\n-                        ty::Bool => trans_bool_binop(fx, *bin_op, lhs, rhs),\n+                        ty::Bool => crate::num::trans_bool_binop(fx, *bin_op, lhs, rhs),\n                         ty::Uint(_) => {\n-                            trans_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, false)\n+                            crate::num::trans_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, false)\n                         }\n                         ty::Int(_) => {\n-                            trans_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, true)\n+                            crate::num::trans_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, true)\n+                        }\n+                        ty::Float(_) => crate::num::trans_float_binop(fx, *bin_op, lhs, rhs, lval.layout().ty),\n+                        ty::Char => crate::num::trans_char_binop(fx, *bin_op, lhs, rhs, lval.layout().ty),\n+                        ty::RawPtr(..) | ty::FnPtr(..) => {\n+                            crate::num::trans_ptr_binop(fx, *bin_op, lhs, rhs, lval.layout().ty)\n                         }\n-                        ty::Float(_) => trans_float_binop(fx, *bin_op, lhs, rhs, lval.layout().ty),\n-                        ty::Char => trans_char_binop(fx, *bin_op, lhs, rhs, lval.layout().ty),\n-                        ty::RawPtr(..) => trans_ptr_binop(fx, *bin_op, lhs, rhs, lval.layout().ty),\n-                        ty::FnPtr(..) => trans_ptr_binop(fx, *bin_op, lhs, rhs, lval.layout().ty),\n                         _ => unimplemented!(\"binop {:?} for {:?}\", bin_op, ty),\n                     };\n                     lval.write_cvalue(fx, res);\n@@ -337,11 +338,11 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                     let signed = type_sign(ty);\n \n                     let res = if !fx.tcx.sess.overflow_checks() {\n-                        let val = trans_int_binop(fx, *bin_op, lhs, rhs, lhs.layout().ty, signed).load_scalar(fx);\n+                        let val = crate::num::trans_int_binop(fx, *bin_op, lhs, rhs, lhs.layout().ty, signed).load_scalar(fx);\n                         let is_overflow = fx.bcx.ins().iconst(types::I8, 0);\n                         CValue::by_val_pair(val, is_overflow, lval.layout())\n                     } else {\n-                        trans_checked_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, signed)\n+                        crate::num::trans_checked_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, signed)\n                     };\n \n                     lval.write_cvalue(fx, res);\n@@ -701,411 +702,6 @@ pub fn trans_get_discriminant<'a, 'tcx: 'a>(\n     }\n }\n \n-macro_rules! binop_match {\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, bug) => {\n-        bug!(\"binop {} on {} lhs: {:?} rhs: {:?}\", stringify!($var), $bug_fmt, $lhs, $rhs)\n-    };\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, icmp($cc:ident)) => {{\n-        assert_eq!($fx.tcx.types.bool, $ret_ty);\n-        let ret_layout = $fx.layout_of($ret_ty);\n-\n-        let b = $fx.bcx.ins().icmp(IntCC::$cc, $lhs, $rhs);\n-        CValue::by_val($fx.bcx.ins().bint(types::I8, b), ret_layout)\n-    }};\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, fcmp($cc:ident)) => {{\n-        assert_eq!($fx.tcx.types.bool, $ret_ty);\n-        let ret_layout = $fx.layout_of($ret_ty);\n-        let b = $fx.bcx.ins().fcmp(FloatCC::$cc, $lhs, $rhs);\n-        CValue::by_val($fx.bcx.ins().bint(types::I8, b), ret_layout)\n-    }};\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, custom(|| $body:expr)) => {{\n-        $body\n-    }};\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, $name:ident) => {{\n-        let ret_layout = $fx.layout_of($ret_ty);\n-        CValue::by_val($fx.bcx.ins().$name($lhs, $rhs), ret_layout)\n-    }};\n-    (\n-        $fx:expr, $bin_op:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, $bug_fmt:expr;\n-        $(\n-            $var:ident ($sign:pat) $name:tt $( ( $($next:tt)* ) )? ;\n-        )*\n-    ) => {{\n-        let lhs = $lhs.load_scalar($fx);\n-        let rhs = $rhs.load_scalar($fx);\n-        match ($bin_op, $signed) {\n-            $(\n-                (BinOp::$var, $sign) => binop_match!(@single $fx, $bug_fmt, $var, $signed, lhs, rhs, $ret_ty, $name $( ( $($next)* ) )?),\n-            )*\n-        }\n-    }}\n-}\n-\n-fn trans_bool_binop<'a, 'tcx: 'a>(\n-    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-    bin_op: BinOp,\n-    lhs: CValue<'tcx>,\n-    rhs: CValue<'tcx>,\n-) -> CValue<'tcx> {\n-    let res = binop_match! {\n-        fx, bin_op, false, lhs, rhs, fx.tcx.types.bool, \"bool\";\n-        Add (_) bug;\n-        Sub (_) bug;\n-        Mul (_) bug;\n-        Div (_) bug;\n-        Rem (_) bug;\n-        BitXor (_) bxor;\n-        BitAnd (_) band;\n-        BitOr (_) bor;\n-        Shl (_) bug;\n-        Shr (_) bug;\n-\n-        Eq (_) icmp(Equal);\n-        Lt (_) icmp(UnsignedLessThan);\n-        Le (_) icmp(UnsignedLessThanOrEqual);\n-        Ne (_) icmp(NotEqual);\n-        Ge (_) icmp(UnsignedGreaterThanOrEqual);\n-        Gt (_) icmp(UnsignedGreaterThan);\n-\n-        Offset (_) bug;\n-    };\n-\n-    res\n-}\n-\n-pub fn trans_int_binop<'a, 'tcx: 'a>(\n-    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-    bin_op: BinOp,\n-    lhs: CValue<'tcx>,\n-    rhs: CValue<'tcx>,\n-    out_ty: Ty<'tcx>,\n-    signed: bool,\n-) -> CValue<'tcx> {\n-    if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n-        assert_eq!(\n-            lhs.layout().ty,\n-            rhs.layout().ty,\n-            \"int binop requires lhs and rhs of same type\"\n-        );\n-    }\n-\n-    match out_ty.sty {\n-        ty::Bool | ty::Uint(_) | ty::Int(_) => {}\n-        _ => unreachable!(\"Out ty {:?} is not an integer or bool\", out_ty),\n-    }\n-\n-    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, false, signed, lhs, rhs, out_ty) {\n-        return res;\n-    }\n-\n-    let (lhs, rhs) = if\n-        (bin_op == BinOp::Eq || bin_op == BinOp::Ne)\n-        && (lhs.layout().ty.sty == fx.tcx.types.i8.sty || lhs.layout().ty.sty == fx.tcx.types.i16.sty)\n-    {\n-        // FIXME(CraneStation/cranelift#896) icmp_imm.i8/i16 with eq/ne for signed ints is implemented wrong.\n-        let lhs = lhs.load_scalar(fx);\n-        let rhs = rhs.load_scalar(fx);\n-        (\n-            CValue::by_val(fx.bcx.ins().sextend(types::I32, lhs), fx.layout_of(fx.tcx.types.i32)),\n-            CValue::by_val(fx.bcx.ins().sextend(types::I32, rhs), fx.layout_of(fx.tcx.types.i32)),\n-        )\n-    } else {\n-        (lhs, rhs)\n-    };\n-\n-    binop_match! {\n-        fx, bin_op, signed, lhs, rhs, out_ty, \"int/uint\";\n-        Add (_) iadd;\n-        Sub (_) isub;\n-        Mul (_) imul;\n-        Div (false) udiv;\n-        Div (true) sdiv;\n-        Rem (false) urem;\n-        Rem (true) srem;\n-        BitXor (_) bxor;\n-        BitAnd (_) band;\n-        BitOr (_) bor;\n-        Shl (_) ishl;\n-        Shr (false) ushr;\n-        Shr (true) sshr;\n-\n-        Eq (_) icmp(Equal);\n-        Lt (false) icmp(UnsignedLessThan);\n-        Lt (true) icmp(SignedLessThan);\n-        Le (false) icmp(UnsignedLessThanOrEqual);\n-        Le (true) icmp(SignedLessThanOrEqual);\n-        Ne (_) icmp(NotEqual);\n-        Ge (false) icmp(UnsignedGreaterThanOrEqual);\n-        Ge (true) icmp(SignedGreaterThanOrEqual);\n-        Gt (false) icmp(UnsignedGreaterThan);\n-        Gt (true) icmp(SignedGreaterThan);\n-\n-        Offset (_) bug;\n-    }\n-}\n-\n-pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n-    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-    bin_op: BinOp,\n-    in_lhs: CValue<'tcx>,\n-    in_rhs: CValue<'tcx>,\n-    out_ty: Ty<'tcx>,\n-    signed: bool,\n-) -> CValue<'tcx> {\n-    if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n-        assert_eq!(\n-            in_lhs.layout().ty,\n-            in_rhs.layout().ty,\n-            \"checked int binop requires lhs and rhs of same type\"\n-        );\n-    }\n-\n-    let lhs = in_lhs.load_scalar(fx);\n-    let rhs = in_rhs.load_scalar(fx);\n-\n-    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, true, signed, in_lhs, in_rhs, out_ty) {\n-        return res;\n-    }\n-\n-    let (res, has_overflow) = match bin_op {\n-        BinOp::Add => {\n-            /*let (val, c_out) = fx.bcx.ins().iadd_cout(lhs, rhs);\n-            (val, c_out)*/\n-            // FIXME(CraneStation/cranelift#849) legalize iadd_cout for i8 and i16\n-            let val = fx.bcx.ins().iadd(lhs, rhs);\n-            let has_overflow = if !signed {\n-                fx.bcx.ins().icmp(IntCC::UnsignedLessThan, val, lhs)\n-            } else {\n-                let rhs_is_negative = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, rhs, 0);\n-                let slt = fx.bcx.ins().icmp(IntCC::SignedLessThan, val, lhs);\n-                fx.bcx.ins().bxor(rhs_is_negative, slt)\n-            };\n-            (val, has_overflow)\n-        }\n-        BinOp::Sub => {\n-            /*let (val, b_out) = fx.bcx.ins().isub_bout(lhs, rhs);\n-            (val, b_out)*/\n-            // FIXME(CraneStation/cranelift#849) legalize isub_bout for i8 and i16\n-            let val = fx.bcx.ins().isub(lhs, rhs);\n-            let has_overflow = if !signed {\n-                fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, val, lhs)\n-            } else {\n-                let rhs_is_negative = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, rhs, 0);\n-                let sgt = fx.bcx.ins().icmp(IntCC::SignedGreaterThan, val, lhs);\n-                fx.bcx.ins().bxor(rhs_is_negative, sgt)\n-            };\n-            (val, has_overflow)\n-        }\n-        BinOp::Mul => {\n-            let val = fx.bcx.ins().imul(lhs, rhs);\n-            /*let val_hi = if !signed {\n-                fx.bcx.ins().umulhi(lhs, rhs)\n-            } else {\n-                fx.bcx.ins().smulhi(lhs, rhs)\n-            };\n-            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0);*/\n-            // TODO: check for overflow\n-            let has_overflow = fx.bcx.ins().bconst(types::B1, false);\n-            (val, has_overflow)\n-        }\n-        BinOp::Shl => {\n-            let val = fx.bcx.ins().ishl(lhs, rhs);\n-            // TODO: check for overflow\n-            let has_overflow = fx.bcx.ins().bconst(types::B1, false);\n-            (val, has_overflow)\n-        }\n-        BinOp::Shr => {\n-            let val = if !signed {\n-                fx.bcx.ins().ushr(lhs, rhs)\n-            } else {\n-                fx.bcx.ins().sshr(lhs, rhs)\n-            };\n-            // TODO: check for overflow\n-            let has_overflow = fx.bcx.ins().bconst(types::B1, false);\n-            (val, has_overflow)\n-        }\n-        _ => bug!(\n-            \"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\",\n-            bin_op,\n-            in_lhs,\n-            in_rhs\n-        ),\n-    };\n-\n-    let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);\n-    let out_place = CPlace::new_stack_slot(fx, out_ty);\n-    let out_layout = out_place.layout();\n-    out_place.write_cvalue(fx, CValue::by_val_pair(res, has_overflow, out_layout));\n-\n-    out_place.to_cvalue(fx)\n-}\n-\n-fn trans_float_binop<'a, 'tcx: 'a>(\n-    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-    bin_op: BinOp,\n-    lhs: CValue<'tcx>,\n-    rhs: CValue<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> CValue<'tcx> {\n-    let res = binop_match! {\n-        fx, bin_op, false, lhs, rhs, ty, \"float\";\n-        Add (_) fadd;\n-        Sub (_) fsub;\n-        Mul (_) fmul;\n-        Div (_) fdiv;\n-        Rem (_) custom(|| {\n-            assert_eq!(lhs.layout().ty, ty);\n-            assert_eq!(rhs.layout().ty, ty);\n-            match ty.sty {\n-                ty::Float(FloatTy::F32) => fx.easy_call(\"fmodf\", &[lhs, rhs], ty),\n-                ty::Float(FloatTy::F64) => fx.easy_call(\"fmod\", &[lhs, rhs], ty),\n-                _ => bug!(),\n-            }\n-        });\n-        BitXor (_) bxor;\n-        BitAnd (_) band;\n-        BitOr (_) bor;\n-        Shl (_) bug;\n-        Shr (_) bug;\n-\n-        Eq (_) fcmp(Equal);\n-        Lt (_) fcmp(LessThan);\n-        Le (_) fcmp(LessThanOrEqual);\n-        Ne (_) fcmp(NotEqual);\n-        Ge (_) fcmp(GreaterThanOrEqual);\n-        Gt (_) fcmp(GreaterThan);\n-\n-        Offset (_) bug;\n-    };\n-\n-    res\n-}\n-\n-fn trans_char_binop<'a, 'tcx: 'a>(\n-    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-    bin_op: BinOp,\n-    lhs: CValue<'tcx>,\n-    rhs: CValue<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> CValue<'tcx> {\n-    let res = binop_match! {\n-        fx, bin_op, false, lhs, rhs, ty, \"char\";\n-        Add (_) bug;\n-        Sub (_) bug;\n-        Mul (_) bug;\n-        Div (_) bug;\n-        Rem (_) bug;\n-        BitXor (_) bug;\n-        BitAnd (_) bug;\n-        BitOr (_) bug;\n-        Shl (_) bug;\n-        Shr (_) bug;\n-\n-        Eq (_) icmp(Equal);\n-        Lt (_) icmp(UnsignedLessThan);\n-        Le (_) icmp(UnsignedLessThanOrEqual);\n-        Ne (_) icmp(NotEqual);\n-        Ge (_) icmp(UnsignedGreaterThanOrEqual);\n-        Gt (_) icmp(UnsignedGreaterThan);\n-\n-        Offset (_) bug;\n-    };\n-\n-    res\n-}\n-\n-fn trans_ptr_binop<'a, 'tcx: 'a>(\n-    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-    bin_op: BinOp,\n-    lhs: CValue<'tcx>,\n-    rhs: CValue<'tcx>,\n-    ret_ty: Ty<'tcx>,\n-) -> CValue<'tcx> {\n-    let not_fat = match lhs.layout().ty.sty {\n-        ty::RawPtr(TypeAndMut { ty, mutbl: _ }) => {\n-            ty.is_sized(fx.tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n-        }\n-        ty::FnPtr(..) => true,\n-        _ => bug!(\"trans_ptr_binop on non ptr\"),\n-    };\n-    if not_fat {\n-        if let BinOp::Offset = bin_op {\n-            let (base, offset) = (lhs, rhs.load_scalar(fx));\n-            let pointee_ty = base.layout().ty.builtin_deref(true).unwrap().ty;\n-            let pointee_size = fx.layout_of(pointee_ty).size.bytes();\n-            let ptr_diff = fx.bcx.ins().imul_imm(offset, pointee_size as i64);\n-            let base_val = base.load_scalar(fx);\n-            let res = fx.bcx.ins().iadd(base_val, ptr_diff);\n-            return CValue::by_val(res, base.layout());\n-        }\n-\n-        binop_match! {\n-            fx, bin_op, false, lhs, rhs, ret_ty, \"ptr\";\n-            Add (_) bug;\n-            Sub (_) bug;\n-            Mul (_) bug;\n-            Div (_) bug;\n-            Rem (_) bug;\n-            BitXor (_) bug;\n-            BitAnd (_) bug;\n-            BitOr (_) bug;\n-            Shl (_) bug;\n-            Shr (_) bug;\n-\n-            Eq (_) icmp(Equal);\n-            Lt (_) icmp(UnsignedLessThan);\n-            Le (_) icmp(UnsignedLessThanOrEqual);\n-            Ne (_) icmp(NotEqual);\n-            Ge (_) icmp(UnsignedGreaterThanOrEqual);\n-            Gt (_) icmp(UnsignedGreaterThan);\n-\n-            Offset (_) bug; // Handled above\n-        }\n-    } else {\n-        let (lhs_ptr, lhs_extra) = lhs.load_scalar_pair(fx);\n-        let (rhs_ptr, rhs_extra) = rhs.load_scalar_pair(fx);\n-\n-        let res = match bin_op {\n-            BinOp::Eq => {\n-                let ptr_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_ptr, rhs_ptr);\n-                let extra_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_extra, rhs_extra);\n-                fx.bcx.ins().band(ptr_eq, extra_eq)\n-            }\n-            BinOp::Ne => {\n-                let ptr_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_ptr, rhs_ptr);\n-                let extra_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_extra, rhs_extra);\n-                fx.bcx.ins().bor(ptr_ne, extra_ne)\n-            }\n-            BinOp::Lt | BinOp::Le | BinOp::Ge | BinOp::Gt => {\n-                let ptr_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_ptr, rhs_ptr);\n-\n-                let ptr_cmp = fx.bcx.ins().icmp(match bin_op {\n-                    BinOp::Lt => IntCC::UnsignedLessThan,\n-                    BinOp::Le => IntCC::UnsignedLessThanOrEqual,\n-                    BinOp::Ge => IntCC::UnsignedGreaterThanOrEqual,\n-                    BinOp::Gt => IntCC::UnsignedGreaterThan,\n-                    _ => unreachable!(),\n-                }, lhs_ptr, rhs_ptr);\n-\n-                let extra_cmp = fx.bcx.ins().icmp(match bin_op {\n-                    BinOp::Lt => IntCC::UnsignedLessThan,\n-                    BinOp::Le => IntCC::UnsignedLessThanOrEqual,\n-                    BinOp::Ge => IntCC::UnsignedGreaterThanOrEqual,\n-                    BinOp::Gt => IntCC::UnsignedGreaterThan,\n-                    _ => unreachable!(),\n-                }, lhs_extra, rhs_extra);\n-\n-                fx.bcx.ins().select(ptr_eq, extra_cmp, ptr_cmp)\n-            }\n-            _ => panic!(\"bin_op {:?} on ptr\", bin_op),\n-        };\n-\n-        assert_eq!(fx.tcx.types.bool, ret_ty);\n-        let ret_layout = fx.layout_of(ret_ty);\n-        CValue::by_val(fx.bcx.ins().bint(types::I8, res), ret_layout)\n-    }\n-}\n-\n pub fn trans_place<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     place: &Place<'tcx>,"}, {"sha": "84288715f4d511717668120cbdb6a2e68fb02b06", "filename": "src/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/883894a07a8f05b4d9d07514af8d8ac19fb27788/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883894a07a8f05b4d9d07514af8d8ac19fb27788/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=883894a07a8f05b4d9d07514af8d8ac19fb27788", "patch": "@@ -447,15 +447,15 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 _ => unimplemented!(\"intrinsic {}\", intrinsic),\n             };\n             let res = match ret.layout().ty.sty {\n-                ty::Uint(_) => crate::base::trans_int_binop(\n+                ty::Uint(_) => crate::num::trans_int_binop(\n                     fx,\n                     bin_op,\n                     x,\n                     y,\n                     ret.layout().ty,\n                     false,\n                 ),\n-                ty::Int(_) => crate::base::trans_int_binop(\n+                ty::Int(_) => crate::num::trans_int_binop(\n                     fx,\n                     bin_op,\n                     x,\n@@ -476,7 +476,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 _ => unimplemented!(\"intrinsic {}\", intrinsic),\n             };\n \n-            let res = crate::base::trans_checked_int_binop(\n+            let res = crate::num::trans_checked_int_binop(\n                 fx,\n                 bin_op,\n                 x,\n@@ -494,7 +494,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 \"overflowing_mul\" => BinOp::Mul,\n                 _ => unimplemented!(\"intrinsic {}\", intrinsic),\n             };\n-            let res = crate::base::trans_int_binop(\n+            let res = crate::num::trans_int_binop(\n                 fx,\n                 bin_op,\n                 x,\n@@ -514,7 +514,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n \n             let signed = type_sign(T);\n \n-            let checked_res = crate::base::trans_checked_int_binop(\n+            let checked_res = crate::num::trans_checked_int_binop(\n                 fx,\n                 bin_op,\n                 x,"}, {"sha": "b61114bec983bdb0e64807516d3d1735a6174388", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/883894a07a8f05b4d9d07514af8d8ac19fb27788/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883894a07a8f05b4d9d07514af8d8ac19fb27788/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=883894a07a8f05b4d9d07514af8d8ac19fb27788", "patch": "@@ -44,6 +44,7 @@ mod linkage;\n mod llvm_intrinsics;\n mod main_shim;\n mod metadata;\n+mod num;\n mod pretty_clif;\n mod target_features_whitelist;\n mod trap;"}, {"sha": "41448b388db888bfd8cfb50e6c3b11220876eb5a", "filename": "src/num.rs", "status": "added", "additions": 406, "deletions": 0, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/883894a07a8f05b4d9d07514af8d8ac19fb27788/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883894a07a8f05b4d9d07514af8d8ac19fb27788/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=883894a07a8f05b4d9d07514af8d8ac19fb27788", "patch": "@@ -0,0 +1,406 @@\n+use crate::prelude::*;\n+\n+macro_rules! binop_match {\n+    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, bug) => {\n+        bug!(\"binop {} on {} lhs: {:?} rhs: {:?}\", stringify!($var), $bug_fmt, $lhs, $rhs)\n+    };\n+    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, icmp($cc:ident)) => {{\n+        assert_eq!($fx.tcx.types.bool, $ret_ty);\n+        let ret_layout = $fx.layout_of($ret_ty);\n+\n+        let b = $fx.bcx.ins().icmp(IntCC::$cc, $lhs, $rhs);\n+        CValue::by_val($fx.bcx.ins().bint(types::I8, b), ret_layout)\n+    }};\n+    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, fcmp($cc:ident)) => {{\n+        assert_eq!($fx.tcx.types.bool, $ret_ty);\n+        let ret_layout = $fx.layout_of($ret_ty);\n+        let b = $fx.bcx.ins().fcmp(FloatCC::$cc, $lhs, $rhs);\n+        CValue::by_val($fx.bcx.ins().bint(types::I8, b), ret_layout)\n+    }};\n+    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, custom(|| $body:expr)) => {{\n+        $body\n+    }};\n+    (@single $fx:expr, $bug_fmt:expr, $var:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, $name:ident) => {{\n+        let ret_layout = $fx.layout_of($ret_ty);\n+        CValue::by_val($fx.bcx.ins().$name($lhs, $rhs), ret_layout)\n+    }};\n+    (\n+        $fx:expr, $bin_op:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, $bug_fmt:expr;\n+        $(\n+            $var:ident ($sign:pat) $name:tt $( ( $($next:tt)* ) )? ;\n+        )*\n+    ) => {{\n+        let lhs = $lhs.load_scalar($fx);\n+        let rhs = $rhs.load_scalar($fx);\n+        match ($bin_op, $signed) {\n+            $(\n+                (BinOp::$var, $sign) => binop_match!(@single $fx, $bug_fmt, $var, $signed, lhs, rhs, $ret_ty, $name $( ( $($next)* ) )?),\n+            )*\n+        }\n+    }}\n+}\n+\n+pub fn trans_bool_binop<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+) -> CValue<'tcx> {\n+    let res = binop_match! {\n+        fx, bin_op, false, lhs, rhs, fx.tcx.types.bool, \"bool\";\n+        Add (_) bug;\n+        Sub (_) bug;\n+        Mul (_) bug;\n+        Div (_) bug;\n+        Rem (_) bug;\n+        BitXor (_) bxor;\n+        BitAnd (_) band;\n+        BitOr (_) bor;\n+        Shl (_) bug;\n+        Shr (_) bug;\n+\n+        Eq (_) icmp(Equal);\n+        Lt (_) icmp(UnsignedLessThan);\n+        Le (_) icmp(UnsignedLessThanOrEqual);\n+        Ne (_) icmp(NotEqual);\n+        Ge (_) icmp(UnsignedGreaterThanOrEqual);\n+        Gt (_) icmp(UnsignedGreaterThan);\n+\n+        Offset (_) bug;\n+    };\n+\n+    res\n+}\n+\n+pub fn trans_int_binop<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+    out_ty: Ty<'tcx>,\n+    signed: bool,\n+) -> CValue<'tcx> {\n+    if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n+        assert_eq!(\n+            lhs.layout().ty,\n+            rhs.layout().ty,\n+            \"int binop requires lhs and rhs of same type\"\n+        );\n+    }\n+\n+    match out_ty.sty {\n+        ty::Bool | ty::Uint(_) | ty::Int(_) => {}\n+        _ => unreachable!(\"Out ty {:?} is not an integer or bool\", out_ty),\n+    }\n+\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, false, signed, lhs, rhs, out_ty) {\n+        return res;\n+    }\n+\n+    let (lhs, rhs) = if\n+        (bin_op == BinOp::Eq || bin_op == BinOp::Ne)\n+        && (lhs.layout().ty.sty == fx.tcx.types.i8.sty || lhs.layout().ty.sty == fx.tcx.types.i16.sty)\n+    {\n+        // FIXME(CraneStation/cranelift#896) icmp_imm.i8/i16 with eq/ne for signed ints is implemented wrong.\n+        let lhs = lhs.load_scalar(fx);\n+        let rhs = rhs.load_scalar(fx);\n+        (\n+            CValue::by_val(fx.bcx.ins().sextend(types::I32, lhs), fx.layout_of(fx.tcx.types.i32)),\n+            CValue::by_val(fx.bcx.ins().sextend(types::I32, rhs), fx.layout_of(fx.tcx.types.i32)),\n+        )\n+    } else {\n+        (lhs, rhs)\n+    };\n+\n+    binop_match! {\n+        fx, bin_op, signed, lhs, rhs, out_ty, \"int/uint\";\n+        Add (_) iadd;\n+        Sub (_) isub;\n+        Mul (_) imul;\n+        Div (false) udiv;\n+        Div (true) sdiv;\n+        Rem (false) urem;\n+        Rem (true) srem;\n+        BitXor (_) bxor;\n+        BitAnd (_) band;\n+        BitOr (_) bor;\n+        Shl (_) ishl;\n+        Shr (false) ushr;\n+        Shr (true) sshr;\n+\n+        Eq (_) icmp(Equal);\n+        Lt (false) icmp(UnsignedLessThan);\n+        Lt (true) icmp(SignedLessThan);\n+        Le (false) icmp(UnsignedLessThanOrEqual);\n+        Le (true) icmp(SignedLessThanOrEqual);\n+        Ne (_) icmp(NotEqual);\n+        Ge (false) icmp(UnsignedGreaterThanOrEqual);\n+        Ge (true) icmp(SignedGreaterThanOrEqual);\n+        Gt (false) icmp(UnsignedGreaterThan);\n+        Gt (true) icmp(SignedGreaterThan);\n+\n+        Offset (_) bug;\n+    }\n+}\n+\n+pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    bin_op: BinOp,\n+    in_lhs: CValue<'tcx>,\n+    in_rhs: CValue<'tcx>,\n+    out_ty: Ty<'tcx>,\n+    signed: bool,\n+) -> CValue<'tcx> {\n+    if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n+        assert_eq!(\n+            in_lhs.layout().ty,\n+            in_rhs.layout().ty,\n+            \"checked int binop requires lhs and rhs of same type\"\n+        );\n+    }\n+\n+    let lhs = in_lhs.load_scalar(fx);\n+    let rhs = in_rhs.load_scalar(fx);\n+\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, true, signed, in_lhs, in_rhs, out_ty) {\n+        return res;\n+    }\n+\n+    let (res, has_overflow) = match bin_op {\n+        BinOp::Add => {\n+            /*let (val, c_out) = fx.bcx.ins().iadd_cout(lhs, rhs);\n+            (val, c_out)*/\n+            // FIXME(CraneStation/cranelift#849) legalize iadd_cout for i8 and i16\n+            let val = fx.bcx.ins().iadd(lhs, rhs);\n+            let has_overflow = if !signed {\n+                fx.bcx.ins().icmp(IntCC::UnsignedLessThan, val, lhs)\n+            } else {\n+                let rhs_is_negative = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, rhs, 0);\n+                let slt = fx.bcx.ins().icmp(IntCC::SignedLessThan, val, lhs);\n+                fx.bcx.ins().bxor(rhs_is_negative, slt)\n+            };\n+            (val, has_overflow)\n+        }\n+        BinOp::Sub => {\n+            /*let (val, b_out) = fx.bcx.ins().isub_bout(lhs, rhs);\n+            (val, b_out)*/\n+            // FIXME(CraneStation/cranelift#849) legalize isub_bout for i8 and i16\n+            let val = fx.bcx.ins().isub(lhs, rhs);\n+            let has_overflow = if !signed {\n+                fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, val, lhs)\n+            } else {\n+                let rhs_is_negative = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, rhs, 0);\n+                let sgt = fx.bcx.ins().icmp(IntCC::SignedGreaterThan, val, lhs);\n+                fx.bcx.ins().bxor(rhs_is_negative, sgt)\n+            };\n+            (val, has_overflow)\n+        }\n+        BinOp::Mul => {\n+            let val = fx.bcx.ins().imul(lhs, rhs);\n+            /*let val_hi = if !signed {\n+                fx.bcx.ins().umulhi(lhs, rhs)\n+            } else {\n+                fx.bcx.ins().smulhi(lhs, rhs)\n+            };\n+            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0);*/\n+            // TODO: check for overflow\n+            let has_overflow = fx.bcx.ins().bconst(types::B1, false);\n+            (val, has_overflow)\n+        }\n+        BinOp::Shl => {\n+            let val = fx.bcx.ins().ishl(lhs, rhs);\n+            // TODO: check for overflow\n+            let has_overflow = fx.bcx.ins().bconst(types::B1, false);\n+            (val, has_overflow)\n+        }\n+        BinOp::Shr => {\n+            let val = if !signed {\n+                fx.bcx.ins().ushr(lhs, rhs)\n+            } else {\n+                fx.bcx.ins().sshr(lhs, rhs)\n+            };\n+            // TODO: check for overflow\n+            let has_overflow = fx.bcx.ins().bconst(types::B1, false);\n+            (val, has_overflow)\n+        }\n+        _ => bug!(\n+            \"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\",\n+            bin_op,\n+            in_lhs,\n+            in_rhs\n+        ),\n+    };\n+\n+    let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);\n+    let out_place = CPlace::new_stack_slot(fx, out_ty);\n+    let out_layout = out_place.layout();\n+    out_place.write_cvalue(fx, CValue::by_val_pair(res, has_overflow, out_layout));\n+\n+    out_place.to_cvalue(fx)\n+}\n+\n+pub fn trans_float_binop<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> CValue<'tcx> {\n+    let res = binop_match! {\n+        fx, bin_op, false, lhs, rhs, ty, \"float\";\n+        Add (_) fadd;\n+        Sub (_) fsub;\n+        Mul (_) fmul;\n+        Div (_) fdiv;\n+        Rem (_) custom(|| {\n+            assert_eq!(lhs.layout().ty, ty);\n+            assert_eq!(rhs.layout().ty, ty);\n+            match ty.sty {\n+                ty::Float(FloatTy::F32) => fx.easy_call(\"fmodf\", &[lhs, rhs], ty),\n+                ty::Float(FloatTy::F64) => fx.easy_call(\"fmod\", &[lhs, rhs], ty),\n+                _ => bug!(),\n+            }\n+        });\n+        BitXor (_) bxor;\n+        BitAnd (_) band;\n+        BitOr (_) bor;\n+        Shl (_) bug;\n+        Shr (_) bug;\n+\n+        Eq (_) fcmp(Equal);\n+        Lt (_) fcmp(LessThan);\n+        Le (_) fcmp(LessThanOrEqual);\n+        Ne (_) fcmp(NotEqual);\n+        Ge (_) fcmp(GreaterThanOrEqual);\n+        Gt (_) fcmp(GreaterThan);\n+\n+        Offset (_) bug;\n+    };\n+\n+    res\n+}\n+\n+pub fn trans_char_binop<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> CValue<'tcx> {\n+    let res = binop_match! {\n+        fx, bin_op, false, lhs, rhs, ty, \"char\";\n+        Add (_) bug;\n+        Sub (_) bug;\n+        Mul (_) bug;\n+        Div (_) bug;\n+        Rem (_) bug;\n+        BitXor (_) bug;\n+        BitAnd (_) bug;\n+        BitOr (_) bug;\n+        Shl (_) bug;\n+        Shr (_) bug;\n+\n+        Eq (_) icmp(Equal);\n+        Lt (_) icmp(UnsignedLessThan);\n+        Le (_) icmp(UnsignedLessThanOrEqual);\n+        Ne (_) icmp(NotEqual);\n+        Ge (_) icmp(UnsignedGreaterThanOrEqual);\n+        Gt (_) icmp(UnsignedGreaterThan);\n+\n+        Offset (_) bug;\n+    };\n+\n+    res\n+}\n+\n+pub fn trans_ptr_binop<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+    ret_ty: Ty<'tcx>,\n+) -> CValue<'tcx> {\n+    let not_fat = match lhs.layout().ty.sty {\n+        ty::RawPtr(TypeAndMut { ty, mutbl: _ }) => {\n+            ty.is_sized(fx.tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n+        }\n+        ty::FnPtr(..) => true,\n+        _ => bug!(\"trans_ptr_binop on non ptr\"),\n+    };\n+    if not_fat {\n+        if let BinOp::Offset = bin_op {\n+            let (base, offset) = (lhs, rhs.load_scalar(fx));\n+            let pointee_ty = base.layout().ty.builtin_deref(true).unwrap().ty;\n+            let pointee_size = fx.layout_of(pointee_ty).size.bytes();\n+            let ptr_diff = fx.bcx.ins().imul_imm(offset, pointee_size as i64);\n+            let base_val = base.load_scalar(fx);\n+            let res = fx.bcx.ins().iadd(base_val, ptr_diff);\n+            return CValue::by_val(res, base.layout());\n+        }\n+\n+        binop_match! {\n+            fx, bin_op, false, lhs, rhs, ret_ty, \"ptr\";\n+            Add (_) bug;\n+            Sub (_) bug;\n+            Mul (_) bug;\n+            Div (_) bug;\n+            Rem (_) bug;\n+            BitXor (_) bug;\n+            BitAnd (_) bug;\n+            BitOr (_) bug;\n+            Shl (_) bug;\n+            Shr (_) bug;\n+\n+            Eq (_) icmp(Equal);\n+            Lt (_) icmp(UnsignedLessThan);\n+            Le (_) icmp(UnsignedLessThanOrEqual);\n+            Ne (_) icmp(NotEqual);\n+            Ge (_) icmp(UnsignedGreaterThanOrEqual);\n+            Gt (_) icmp(UnsignedGreaterThan);\n+\n+            Offset (_) bug; // Handled above\n+        }\n+    } else {\n+        let (lhs_ptr, lhs_extra) = lhs.load_scalar_pair(fx);\n+        let (rhs_ptr, rhs_extra) = rhs.load_scalar_pair(fx);\n+\n+        let res = match bin_op {\n+            BinOp::Eq => {\n+                let ptr_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_ptr, rhs_ptr);\n+                let extra_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_extra, rhs_extra);\n+                fx.bcx.ins().band(ptr_eq, extra_eq)\n+            }\n+            BinOp::Ne => {\n+                let ptr_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_ptr, rhs_ptr);\n+                let extra_ne = fx.bcx.ins().icmp(IntCC::NotEqual, lhs_extra, rhs_extra);\n+                fx.bcx.ins().bor(ptr_ne, extra_ne)\n+            }\n+            BinOp::Lt | BinOp::Le | BinOp::Ge | BinOp::Gt => {\n+                let ptr_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_ptr, rhs_ptr);\n+\n+                let ptr_cmp = fx.bcx.ins().icmp(match bin_op {\n+                    BinOp::Lt => IntCC::UnsignedLessThan,\n+                    BinOp::Le => IntCC::UnsignedLessThanOrEqual,\n+                    BinOp::Ge => IntCC::UnsignedGreaterThanOrEqual,\n+                    BinOp::Gt => IntCC::UnsignedGreaterThan,\n+                    _ => unreachable!(),\n+                }, lhs_ptr, rhs_ptr);\n+\n+                let extra_cmp = fx.bcx.ins().icmp(match bin_op {\n+                    BinOp::Lt => IntCC::UnsignedLessThan,\n+                    BinOp::Le => IntCC::UnsignedLessThanOrEqual,\n+                    BinOp::Ge => IntCC::UnsignedGreaterThanOrEqual,\n+                    BinOp::Gt => IntCC::UnsignedGreaterThan,\n+                    _ => unreachable!(),\n+                }, lhs_extra, rhs_extra);\n+\n+                fx.bcx.ins().select(ptr_eq, extra_cmp, ptr_cmp)\n+            }\n+            _ => panic!(\"bin_op {:?} on ptr\", bin_op),\n+        };\n+\n+        assert_eq!(fx.tcx.types.bool, ret_ty);\n+        let ret_layout = fx.layout_of(ret_ty);\n+        CValue::by_val(fx.bcx.ins().bint(types::I8, res), ret_layout)\n+    }\n+}"}]}