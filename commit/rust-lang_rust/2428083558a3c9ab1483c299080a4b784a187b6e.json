{"sha": "2428083558a3c9ab1483c299080a4b784a187b6e", "node_id": "C_kwDOAAsO6NoAKDI0MjgwODM1NThhM2M5YWIxNDgzYzI5OTA4MGE0Yjc4NGExODdiNmU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-08T20:26:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-08T20:26:51Z"}, "message": "Rollup merge of #108839 - compiler-errors:canonicalize-the-root-var, r=lcnr\n\nCanonicalize root var when making response from new solver\n\nDuring trait solving, if we equate two inference variables `?0` and `?1` but don't equate them with any rigid types, then `InferCtxt::probe_ty_var` will return `Err` for both of these. The canonicalizer code will then canonicalize the variables independently(!), and the response will not reflect the fact that these two variables have been made equal.\n\nThis hinders inference and I also don't think it's sound? I haven't thought too much about it past that, so let's talk about it.\n\nr? ``@lcnr``", "tree": {"sha": "c739371dd3bdbce3f6381198ac9e21a57d0c725e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c739371dd3bdbce3f6381198ac9e21a57d0c725e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2428083558a3c9ab1483c299080a4b784a187b6e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkCO+LCRBK7hj4Ov3rIwAA+RQIAACSuLxlUO23QIXOIk6pd7Y9\nwhpWgRBSbnypw+UKq/krKNx9kbAcUbHx78wOGWF+z0lWDTceQNapcX4b1bJc5+PJ\nlEvavsXM0zfRUefpuGy6DBHtCNArdkRXOSSWH1dy2uYESdwLctwbGQGd3/eKzgYt\nRwHuGJ1eA8JtOVmQmnwQfKleQDMCxw/TTJBEsrVzrwLZaGF5RSWnTyPskN5zoDsU\nwMvTpbOPL6epmKK6KkQ9rt8lhaSpkhKVjC9s9WigqfUbV53nq7wUzcu7gEgoCHqr\ndJJ7ACz+F9fB4FMWH2nKX8qh+6HNCE2V9V0u/oVmsffZD0wnCI63zR0REYbh2+Y=\n=Jss9\n-----END PGP SIGNATURE-----\n", "payload": "tree c739371dd3bdbce3f6381198ac9e21a57d0c725e\nparent 23f46c50b27e7c58026ba2a060c04b653d099412\nparent 3bfcfd079d41ba73228d382677688cd3ce088545\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1678307211 +0100\ncommitter GitHub <noreply@github.com> 1678307211 +0100\n\nRollup merge of #108839 - compiler-errors:canonicalize-the-root-var, r=lcnr\n\nCanonicalize root var when making response from new solver\n\nDuring trait solving, if we equate two inference variables `?0` and `?1` but don't equate them with any rigid types, then `InferCtxt::probe_ty_var` will return `Err` for both of these. The canonicalizer code will then canonicalize the variables independently(!), and the response will not reflect the fact that these two variables have been made equal.\n\nThis hinders inference and I also don't think it's sound? I haven't thought too much about it past that, so let's talk about it.\n\nr? ``@lcnr``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2428083558a3c9ab1483c299080a4b784a187b6e", "html_url": "https://github.com/rust-lang/rust/commit/2428083558a3c9ab1483c299080a4b784a187b6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2428083558a3c9ab1483c299080a4b784a187b6e/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23f46c50b27e7c58026ba2a060c04b653d099412", "url": "https://api.github.com/repos/rust-lang/rust/commits/23f46c50b27e7c58026ba2a060c04b653d099412", "html_url": "https://github.com/rust-lang/rust/commit/23f46c50b27e7c58026ba2a060c04b653d099412"}, {"sha": "3bfcfd079d41ba73228d382677688cd3ce088545", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bfcfd079d41ba73228d382677688cd3ce088545", "html_url": "https://github.com/rust-lang/rust/commit/3bfcfd079d41ba73228d382677688cd3ce088545"}], "stats": {"total": 119, "additions": 104, "deletions": 15}, "files": [{"sha": "a43330e2d4ea5db44b9a1392a0d814b464a755f1", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2428083558a3c9ab1483c299080a4b784a187b6e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428083558a3c9ab1483c299080a4b784a187b6e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=2428083558a3c9ab1483c299080a4b784a187b6e", "patch": "@@ -374,9 +374,18 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'cx, 'tcx> {\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, mut t: Ty<'tcx>) -> Ty<'tcx> {\n         match *t.kind() {\n-            ty::Infer(ty::TyVar(vid)) => {\n+            ty::Infer(ty::TyVar(mut vid)) => {\n+                // We need to canonicalize the *root* of our ty var.\n+                // This is so that our canonical response correctly reflects\n+                // any equated inference vars correctly!\n+                let root_vid = self.infcx.root_var(vid);\n+                if root_vid != vid {\n+                    t = self.infcx.tcx.mk_ty_var(root_vid);\n+                    vid = root_vid;\n+                }\n+\n                 debug!(\"canonical: type var found with vid {:?}\", vid);\n                 match self.infcx.probe_ty_var(vid) {\n                     // `t` could be a float / int variable; canonicalize that instead.\n@@ -467,9 +476,18 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'cx, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+    fn fold_const(&mut self, mut ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         match ct.kind() {\n-            ty::ConstKind::Infer(InferConst::Var(vid)) => {\n+            ty::ConstKind::Infer(InferConst::Var(mut vid)) => {\n+                // We need to canonicalize the *root* of our const var.\n+                // This is so that our canonical response correctly reflects\n+                // any equated inference vars correctly!\n+                let root_vid = self.infcx.root_const_var(vid);\n+                if root_vid != vid {\n+                    ct = self.infcx.tcx.mk_const(ty::InferConst::Var(root_vid), ct.ty());\n+                    vid = root_vid;\n+                }\n+\n                 debug!(\"canonical: const var found with vid {:?}\", vid);\n                 match self.infcx.probe_const_var(vid) {\n                     Ok(c) => {"}, {"sha": "4a2a55573131aa92c091ccf6f4fd2d376e06a334", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2428083558a3c9ab1483c299080a4b784a187b6e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428083558a3c9ab1483c299080a4b784a187b6e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=2428083558a3c9ab1483c299080a4b784a187b6e", "patch": "@@ -1359,6 +1359,10 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow_mut().type_variables().root_var(var)\n     }\n \n+    pub fn root_const_var(&self, var: ty::ConstVid<'tcx>) -> ty::ConstVid<'tcx> {\n+        self.inner.borrow_mut().const_unification_table().find(var)\n+    }\n+\n     /// Where possible, replaces type/const variables in\n     /// `value` with their final value. Note that region variables\n     /// are unaffected. If a type/const variable has not been unified, it"}, {"sha": "981a8f45e4542f8f7b78cfdb704a7dcdf8151dba", "filename": "compiler/rustc_trait_selection/src/solve/canonical/canonicalize.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2428083558a3c9ab1483c299080a4b784a187b6e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428083558a3c9ab1483c299080a4b784a187b6e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs?ref=2428083558a3c9ab1483c299080a4b784a187b6e", "patch": "@@ -261,12 +261,23 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n         self.interner().mk_re_late_bound(self.binder_index, br)\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn fold_ty(&mut self, mut t: Ty<'tcx>) -> Ty<'tcx> {\n         let kind = match *t.kind() {\n-            ty::Infer(ty::TyVar(vid)) => match self.infcx.probe_ty_var(vid) {\n-                Ok(t) => return self.fold_ty(t),\n-                Err(ui) => CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n-            },\n+            ty::Infer(ty::TyVar(mut vid)) => {\n+                // We need to canonicalize the *root* of our ty var.\n+                // This is so that our canonical response correctly reflects\n+                // any equated inference vars correctly!\n+                let root_vid = self.infcx.root_var(vid);\n+                if root_vid != vid {\n+                    t = self.infcx.tcx.mk_ty_var(root_vid);\n+                    vid = root_vid;\n+                }\n+\n+                match self.infcx.probe_ty_var(vid) {\n+                    Ok(t) => return self.fold_ty(t),\n+                    Err(ui) => CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n+                }\n+            }\n             ty::Infer(ty::IntVar(_)) => {\n                 let nt = self.infcx.shallow_resolve(t);\n                 if nt != t {\n@@ -338,13 +349,23 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n         self.interner().mk_bound(self.binder_index, bt)\n     }\n \n-    fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+    fn fold_const(&mut self, mut c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         let kind = match c.kind() {\n-            ty::ConstKind::Infer(ty::InferConst::Var(vid)) => match self.infcx.probe_const_var(vid)\n-            {\n-                Ok(c) => return self.fold_const(c),\n-                Err(universe) => CanonicalVarKind::Const(universe, c.ty()),\n-            },\n+            ty::ConstKind::Infer(ty::InferConst::Var(mut vid)) => {\n+                // We need to canonicalize the *root* of our const var.\n+                // This is so that our canonical response correctly reflects\n+                // any equated inference vars correctly!\n+                let root_vid = self.infcx.root_const_var(vid);\n+                if root_vid != vid {\n+                    c = self.infcx.tcx.mk_const(ty::InferConst::Var(root_vid), c.ty());\n+                    vid = root_vid;\n+                }\n+\n+                match self.infcx.probe_const_var(vid) {\n+                    Ok(c) => return self.fold_const(c),\n+                    Err(universe) => CanonicalVarKind::Const(universe, c.ty()),\n+                }\n+            }\n             ty::ConstKind::Infer(ty::InferConst::Fresh(_)) => {\n                 bug!(\"fresh var during canonicalization: {c:?}\")\n             }"}, {"sha": "43fd415e871e18dcdd2ba31c647bb27d66596323", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2428083558a3c9ab1483c299080a4b784a187b6e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428083558a3c9ab1483c299080a4b784a187b6e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=2428083558a3c9ab1483c299080a4b784a187b6e", "patch": "@@ -238,6 +238,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             && has_changed\n             && !self.in_projection_eq_hack\n             && !self.search_graph.in_cycle()\n+            && false\n         {\n             let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n             let canonical_response ="}, {"sha": "d1c6b1077e8efd0d2d35cb3b1c60abd8c75b7b00", "filename": "tests/ui/traits/new-solver/canonical-ty-var-eq-in-response.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2428083558a3c9ab1483c299080a4b784a187b6e/tests%2Fui%2Ftraits%2Fnew-solver%2Fcanonical-ty-var-eq-in-response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428083558a3c9ab1483c299080a4b784a187b6e/tests%2Fui%2Ftraits%2Fnew-solver%2Fcanonical-ty-var-eq-in-response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fcanonical-ty-var-eq-in-response.rs?ref=2428083558a3c9ab1483c299080a4b784a187b6e", "patch": "@@ -0,0 +1,39 @@\n+// check-pass\n+// compile-flags: -Ztrait-solver=next\n+\n+trait Mirror {\n+    type Item;\n+}\n+\n+struct Wrapper<T>(T);\n+impl<T> Mirror for Wrapper<T> {\n+    type Item = T;\n+}\n+\n+fn mirror<T>()\n+where\n+    Wrapper<T>: Mirror<Item = i32>,\n+{\n+}\n+\n+fn main() {\n+    mirror::<_ /* ?0 */>();\n+\n+    // Solving `<Wrapper<?0> as Mirror>::Item = i32`\n+\n+    // First, we replace the term with a fresh infer var:\n+    // `<Wrapper<?0> as Mirror>::Item = ?1`\n+\n+    // We select the impl candidate on line #6, which leads us to learn that\n+    // `?0 == ?1`.\n+\n+    // That should be reflected in our canonical response, which should have\n+    // `^0 = ^0, ^1 = ^0`\n+    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n+    // !! We used to return a totally unconstrained response here :< !!\n+    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n+\n+    // Then, during the \"equate term\" part of the projection solving, we\n+    // instantiate the response from the unconstrained projection predicate,\n+    // and equate `?0 == i32`.\n+}"}, {"sha": "7398bce7b61cfbd0792dce2ef8020faf67dc8e47", "filename": "tests/ui/traits/new-solver/deduce-ty-from-object.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2428083558a3c9ab1483c299080a4b784a187b6e/tests%2Fui%2Ftraits%2Fnew-solver%2Fdeduce-ty-from-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428083558a3c9ab1483c299080a4b784a187b6e/tests%2Fui%2Ftraits%2Fnew-solver%2Fdeduce-ty-from-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fdeduce-ty-from-object.rs?ref=2428083558a3c9ab1483c299080a4b784a187b6e", "patch": "@@ -0,0 +1,6 @@\n+// check-pass\n+// compile-flags: -Ztrait-solver=next\n+\n+fn main() {\n+    let x: Box<dyn Iterator<Item = ()>> = Box::new(std::iter::empty());\n+}"}]}