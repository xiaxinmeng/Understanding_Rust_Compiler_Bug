{"sha": "421be273cc389a5d426063f71cba82bf1c364f00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMWJlMjczY2MzODlhNWQ0MjYwNjNmNzFjYmE4MmJmMWMzNjRmMDA=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-18T19:25:11Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:26:36Z"}, "message": "Add concurrency tests.", "tree": {"sha": "6b788ef820c9296d06e1c8fe49ef144bb1cd4d5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b788ef820c9296d06e1c8fe49ef144bb1cd4d5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/421be273cc389a5d426063f71cba82bf1c364f00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/421be273cc389a5d426063f71cba82bf1c364f00", "html_url": "https://github.com/rust-lang/rust/commit/421be273cc389a5d426063f71cba82bf1c364f00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/421be273cc389a5d426063f71cba82bf1c364f00/comments", "author": null, "committer": null, "parents": [{"sha": "46fd333daa8dc71f1c61aa87ecbf9881fae920c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/46fd333daa8dc71f1c61aa87ecbf9881fae920c6", "html_url": "https://github.com/rust-lang/rust/commit/46fd333daa8dc71f1c61aa87ecbf9881fae920c6"}], "stats": {"total": 233, "additions": 227, "deletions": 6}, "files": [{"sha": "6a1ea108dbb06ed41cf4ceff2c53cb0fbe234b28", "filename": "src/shims/sync.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/421be273cc389a5d426063f71cba82bf1c364f00/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421be273cc389a5d426063f71cba82bf1c364f00/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=421be273cc389a5d426063f71cba82bf1c364f00", "patch": "@@ -532,6 +532,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n+    // FIXME: We should check that this lock was locked by the active thread.\n     fn pthread_rwlock_unlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n "}, {"sha": "89ec16596599e594e279d370a83cadff3d7406d7", "filename": "src/shims/tls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/421be273cc389a5d426063f71cba82bf1c364f00/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421be273cc389a5d426063f71cba82bf1c364f00/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=421be273cc389a5d426063f71cba82bf1c364f00", "patch": "@@ -233,6 +233,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ///\n     /// Note: on Windows OS this function is a no-op because we do not support\n     /// concurrency on Windows yet.\n+    ///\n+    /// FIXME: we do not support yet deallocation of thread local statics.\n     fn run_tls_dtors_for_active_thread(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if this.tcx.sess.target.target.target_os == \"windows\" {"}, {"sha": "ab6a4c94db83147deee16cdaa560e258416285be", "filename": "src/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/421be273cc389a5d426063f71cba82bf1c364f00/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421be273cc389a5d426063f71cba82bf1c364f00/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=421be273cc389a5d426063f71cba82bf1c364f00", "patch": "@@ -164,13 +164,13 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     /// Check if we have an allocation for the given thread local static for the\n     /// active thread.\n-    pub fn get_thread_local_alloc_id(&self, def_id: DefId) -> Option<AllocId> {\n+    fn get_thread_local_alloc_id(&self, def_id: DefId) -> Option<AllocId> {\n         self.thread_local_alloc_ids.borrow().get(&(def_id, self.active_thread)).cloned()\n     }\n \n     /// Set the allocation id as the allocation id of the given thread local\n     /// static for the active thread.\n-    pub fn set_thread_local_alloc_id(&self, def_id: DefId, new_alloc_id: AllocId) {\n+    fn set_thread_local_alloc_id(&self, def_id: DefId, new_alloc_id: AllocId) {\n         assert!(\n             self.thread_local_alloc_ids\n                 .borrow_mut()"}, {"sha": "ad12c107bffb089cabc2dbf2b3c26a4334a1f66c", "filename": "tests/compile-fail/concurrency/dangling_tls_lib.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/421be273cc389a5d426063f71cba82bf1c364f00/tests%2Fcompile-fail%2Fconcurrency%2Fdangling_tls_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421be273cc389a5d426063f71cba82bf1c364f00/tests%2Fcompile-fail%2Fconcurrency%2Fdangling_tls_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconcurrency%2Fdangling_tls_lib.rs?ref=421be273cc389a5d426063f71cba82bf1c364f00", "patch": "@@ -0,0 +1,46 @@\n+// ignore-windows\n+\n+#![feature(thread_local_internals)]\n+\n+use std::cell::RefCell;\n+use std::thread;\n+\n+static A: std::thread::LocalKey<RefCell<u8>> = {\n+    #[inline]\n+    fn __init() -> RefCell<u8> {\n+        RefCell::new(0)\n+    }\n+\n+    unsafe fn __getit() -> Option<&'static RefCell<u8>> {\n+        static __KEY: std::thread::__OsLocalKeyInner<RefCell<u8>> =\n+            std::thread::__OsLocalKeyInner::new();\n+        __KEY.get(__init)\n+    }\n+\n+    unsafe { std::thread::LocalKey::new(__getit) }\n+};\n+\n+struct Sender(*mut u8);\n+\n+unsafe impl Send for Sender {}\n+\n+fn main() {\n+    A.with(|f| {\n+        assert_eq!(*f.borrow(), 0);\n+        *f.borrow_mut() = 4;\n+    });\n+\n+    let handle = thread::spawn(|| {\n+        let ptr = A.with(|f| {\n+            assert_eq!(*f.borrow(), 0);\n+            *f.borrow_mut() = 5;\n+            &mut *f.borrow_mut() as *mut u8\n+        });\n+        Sender(ptr)\n+    });\n+    let ptr = handle.join().unwrap().0;\n+    A.with(|f| {\n+        assert_eq!(*f.borrow(), 4);\n+    });\n+    let _x = unsafe { *ptr }; //~ ERROR Undefined Behavior\n+}"}, {"sha": "5d04635a36c8883e1c5c4c9061cc51b5ae0fd16e", "filename": "tests/compile-fail/concurrency/libc_pthread_mutex_deadlock.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/421be273cc389a5d426063f71cba82bf1c364f00/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_mutex_deadlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421be273cc389a5d426063f71cba82bf1c364f00/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_mutex_deadlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_mutex_deadlock.rs?ref=421be273cc389a5d426063f71cba82bf1c364f00", "patch": "@@ -0,0 +1,32 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+use std::cell::UnsafeCell;\n+use std::sync::Arc;\n+use std::thread;\n+\n+struct Mutex(UnsafeCell<libc::pthread_mutex_t>);\n+\n+unsafe impl Send for Mutex {}\n+unsafe impl Sync for Mutex {}\n+\n+fn new_lock() -> Arc<Mutex> {\n+    Arc::new(Mutex(UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER)))\n+}\n+\n+fn main() {\n+    unsafe {\n+        let lock = new_lock();\n+        assert_eq!(libc::pthread_mutex_lock(lock.0.get() as *mut _), 0);\n+\n+        let lock_copy = lock.clone();\n+        thread::spawn(move || {\n+            assert_eq!(libc::pthread_mutex_lock(lock_copy.0.get() as *mut _), 0); //~ ERROR: deadlock\n+        })\n+        .join()\n+        .unwrap();\n+    }\n+}"}, {"sha": "3009721abe2e13ec3e57608e4e3e7855b1b3d449", "filename": "tests/compile-fail/concurrency/libc_pthread_mutex_wrong_owner.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/421be273cc389a5d426063f71cba82bf1c364f00/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_mutex_wrong_owner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421be273cc389a5d426063f71cba82bf1c364f00/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_mutex_wrong_owner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_mutex_wrong_owner.rs?ref=421be273cc389a5d426063f71cba82bf1c364f00", "patch": "@@ -0,0 +1,32 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+use std::cell::UnsafeCell;\n+use std::sync::Arc;\n+use std::thread;\n+\n+struct Mutex(UnsafeCell<libc::pthread_mutex_t>);\n+\n+unsafe impl Send for Mutex {}\n+unsafe impl Sync for Mutex {}\n+\n+fn new_lock() -> Arc<Mutex> {\n+    Arc::new(Mutex(UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER)))\n+}\n+\n+fn main() {\n+    unsafe {\n+        let lock = new_lock();\n+        assert_eq!(libc::pthread_mutex_lock(lock.0.get() as *mut _), 0);\n+\n+        let lock_copy = lock.clone();\n+        thread::spawn(move || {\n+            assert_eq!(libc::pthread_mutex_unlock(lock_copy.0.get() as *mut _), 0); //~ ERROR: Undefined Behavior: called pthread_mutex_unlock on a mutex owned by another thread\n+        })\n+        .join()\n+        .unwrap();\n+    }\n+}"}, {"sha": "19dce431c8b1cb710dc8e4ad8080765667aa62e4", "filename": "tests/compile-fail/concurrency/libc_pthread_rwlock_write_read_deadlock.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/421be273cc389a5d426063f71cba82bf1c364f00/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_rwlock_write_read_deadlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421be273cc389a5d426063f71cba82bf1c364f00/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_rwlock_write_read_deadlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_rwlock_write_read_deadlock.rs?ref=421be273cc389a5d426063f71cba82bf1c364f00", "patch": "@@ -0,0 +1,32 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+use std::cell::UnsafeCell;\n+use std::sync::Arc;\n+use std::thread;\n+\n+struct RwLock(UnsafeCell<libc::pthread_rwlock_t>);\n+\n+unsafe impl Send for RwLock {}\n+unsafe impl Sync for RwLock {}\n+\n+fn new_lock() -> Arc<RwLock> {\n+    Arc::new(RwLock(UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER)))\n+}\n+\n+fn main() {\n+    unsafe {\n+        let lock = new_lock();\n+        assert_eq!(libc::pthread_rwlock_rdlock(lock.0.get() as *mut _), 0);\n+\n+        let lock_copy = lock.clone();\n+        thread::spawn(move || {\n+            assert_eq!(libc::pthread_rwlock_wrlock(lock_copy.0.get() as *mut _), 0); //~ ERROR: deadlock\n+        })\n+        .join()\n+        .unwrap();\n+    }\n+}"}, {"sha": "098c1c2fe26cc7b8ab0e2746bf05a1002f3d8389", "filename": "tests/compile-fail/concurrency/libc_pthread_rwlock_write_write_deadlock.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/421be273cc389a5d426063f71cba82bf1c364f00/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_rwlock_write_write_deadlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421be273cc389a5d426063f71cba82bf1c364f00/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_rwlock_write_write_deadlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_rwlock_write_write_deadlock.rs?ref=421be273cc389a5d426063f71cba82bf1c364f00", "patch": "@@ -0,0 +1,32 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+use std::cell::UnsafeCell;\n+use std::sync::Arc;\n+use std::thread;\n+\n+struct RwLock(UnsafeCell<libc::pthread_rwlock_t>);\n+\n+unsafe impl Send for RwLock {}\n+unsafe impl Sync for RwLock {}\n+\n+fn new_lock() -> Arc<RwLock> {\n+    Arc::new(RwLock(UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER)))\n+}\n+\n+fn main() {\n+    unsafe {\n+        let lock = new_lock();\n+        assert_eq!(libc::pthread_rwlock_wrlock(lock.0.get() as *mut _), 0);\n+\n+        let lock_copy = lock.clone();\n+        thread::spawn(move || {\n+            assert_eq!(libc::pthread_rwlock_wrlock(lock_copy.0.get() as *mut _), 0); //~ ERROR: deadlock\n+        })\n+        .join()\n+        .unwrap();\n+    }\n+}"}, {"sha": "90c10b8ffe247894252914ea8a541c7973d2f180", "filename": "tests/run-pass/concurrency/locks.rs", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/421be273cc389a5d426063f71cba82bf1c364f00/tests%2Frun-pass%2Fconcurrency%2Flocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421be273cc389a5d426063f71cba82bf1c364f00/tests%2Frun-pass%2Fconcurrency%2Flocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flocks.rs?ref=421be273cc389a5d426063f71cba82bf1c364f00", "patch": "@@ -1,11 +1,9 @@\n // ignore-windows\n \n-//! This test just calls the relevant APIs to check if Miri crashes.\n-\n-use std::sync::{Arc, Mutex};\n+use std::sync::{Arc, Mutex, RwLock};\n use std::thread;\n \n-fn main() {\n+fn check_mutex() {\n     let data = Arc::new(Mutex::new(0));\n     let mut threads = Vec::new();\n \n@@ -27,3 +25,49 @@ fn main() {\n     let data = Arc::try_unwrap(data).unwrap().into_inner().unwrap();\n     assert_eq!(data, 3);\n }\n+\n+fn check_rwlock_write() {\n+    let data = Arc::new(RwLock::new(0));\n+    let mut threads = Vec::new();\n+\n+    for _ in 0..3 {\n+        let data = Arc::clone(&data);\n+        let thread = thread::spawn(move || {\n+            let mut data = data.write().unwrap();\n+            *data += 1;\n+        });\n+        threads.push(thread);\n+    }\n+\n+    for thread in threads {\n+        thread.join().unwrap();\n+    }\n+\n+    assert!(data.try_write().is_ok());\n+\n+    let data = Arc::try_unwrap(data).unwrap().into_inner().unwrap();\n+    assert_eq!(data, 3);\n+}\n+\n+fn check_rwlock_read_no_deadlock() {\n+    let l1 = Arc::new(RwLock::new(0));\n+    let l2 = Arc::new(RwLock::new(0));\n+\n+    let l1_copy = Arc::clone(&l1);\n+    let l2_copy = Arc::clone(&l2);\n+    let _guard1 = l1.read().unwrap();\n+    let handle = thread::spawn(move || {\n+        let _guard2 = l2_copy.read().unwrap();\n+        thread::yield_now();\n+        let _guard1 = l1_copy.read().unwrap();\n+    });\n+    thread::yield_now();\n+    let _guard2 = l2.read().unwrap();\n+    handle.join().unwrap();\n+}\n+\n+fn main() {\n+    check_mutex();\n+    check_rwlock_write();\n+    check_rwlock_read_no_deadlock();\n+}"}]}