{"sha": "8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkOTdjOTA1ZGRlY2VjMmUyZDBkNzI5MjZiYzRjOWU3MzljY2I2ZTM=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-20T03:25:46Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-20T03:25:46Z"}, "message": "Merge pull request #7897 from thestinger/double\n\nrollup of small pull requests\r\n\r\n404de4f r=huonw\r\n0cdb0a2 r=pcwalton\r\nb082302 r=sanxiyn\r\nb6a0138 r=huonw\r\n8d64fa3 r=graydon\r\nddd8c15 r=thestinger\r\neb74f0c r=thestinger", "tree": {"sha": "1c80a4d22820b1630617b076c212ddde942d83f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c80a4d22820b1630617b076c212ddde942d83f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "html_url": "https://github.com/rust-lang/rust/commit/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d04aa78e5e8a7e3c48141028137c1a69e7e32ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d04aa78e5e8a7e3c48141028137c1a69e7e32ee", "html_url": "https://github.com/rust-lang/rust/commit/0d04aa78e5e8a7e3c48141028137c1a69e7e32ee"}, {"sha": "eb74f0ccf60a1e8dda1afe9a3be0e8dd4fd96f9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb74f0ccf60a1e8dda1afe9a3be0e8dd4fd96f9f", "html_url": "https://github.com/rust-lang/rust/commit/eb74f0ccf60a1e8dda1afe9a3be0e8dd4fd96f9f"}], "stats": {"total": 465, "additions": 246, "deletions": 219}, "files": [{"sha": "d78176e569999ad162b0f03b0f59c0522454f744", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -249,7 +249,7 @@ endef\n \n # Same interface as above, but deletes rather than just listing the files.\n define REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT\n-  $(Q)MATCHES=\"$(filter-out %$(3),$(wildcard $(1)/$(2)))\"; if [ -n \"$$MATCHES\" ] ; then echo \"Warning: removing previous\" \\'$(2)\\' \"libraries:\" $$MATCHES; rm -v $$MATCHES ; fi\n+  $(Q)MATCHES=\"$(filter-out %$(3),$(wildcard $(1)/$(2)))\"; if [ -n \"$$MATCHES\" ] ; then echo \"Warning: removing previous\" \\'$(2)\\' \"libraries:\" $$MATCHES; rm $$MATCHES ; fi\n endef\n \n # We use a different strategy for LIST_ALL_OLD_GLOB_MATCHES_EXCEPT"}, {"sha": "30ad2bd112f8c624b35cefda29ce31c48cd5432d", "filename": "README.md", "status": "modified", "additions": 67, "deletions": 48, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -3,18 +3,72 @@\n This is a compiler for Rust, including standard libraries, tools and\n documentation.\n \n+## Quick Start\n \n-## Installation\n+### Windows\n \n-The Rust compiler currently must be built from a [tarball], unless you\n-are on Windows, in which case using the [installer][win-exe] is\n-recommended.\n+1. Download and use the [installer][win-exe].\n+2. Read the [tutorial].\n+2. Enjoy!\n \n-Since the Rust compiler is written in Rust, it must be built by\n-a precompiled \"snapshot\" version of itself (made in an earlier state\n-of development). As such, source builds require a connection to\n-the Internet, to fetch snapshots, and an OS that can execute the\n-available snapshot binaries.\n+> ***Note:*** Windows users should read the detailed\n+> [getting started][wiki-start] notes on the wiki. Even when using\n+> the binary installer the Windows build requires a MinGW installation,\n+> the precise details of which are not discussed here.\n+\n+[tutorial]: http://static.rust-lang.org/doc/tutorial.html\n+[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n+[win-exe]: http://static.rust-lang.org/dist/rust-0.7-install.exe\n+\n+### Linux / OS X\n+\n+1. Install the prerequisites (if not already installed)\n+    * g++ 4.4 or clang++ 3.x\n+    * python 2.6 or later (but not 3.x)\n+    * perl 5.0 or later\n+    * gnu make 3.81 or later\n+    * curl\n+2. Download and build Rust\n+    You can either download a [tarball] or build directly from the [repo].\n+    \n+    To build from the [tarball] do:\n+    \n+        $ curl -O http://static.rust-lang.org/dist/rust-0.7.tar.gz\n+        $ tar -xzf rust-0.7.tar.gz\n+        $ cd rust-0.7\n+    \n+    Or to build from the [repo] do:\n+\n+        $ git clone https://github.com/mozilla/rust.git\n+        $ cd rust\n+\n+    Now that you have Rust's source code, you can configure and build it:\n+    \n+        $ ./configure\n+        $ make && make install\n+    \n+    You may need to use `sudo make install` if you do not normally have\n+    permission to modify the destination directory. The install locations can\n+    be adjusted by passing a `--prefix` argument to `configure`. Various other\n+    options are also supported, pass `--help` for more information on them.\n+\n+    When complete, `make install` will place several programs into\n+    `/usr/local/bin`: `rustc`, the Rust compiler; `rustdoc`, the\n+    API-documentation tool, and `rustpkg`, the Rust package manager and build\n+    system.\n+3. Read the [tutorial].\n+4. Enjoy!\n+\n+[repo]: https://github.com/mozilla/rust\n+[tarball]: http://static.rust-lang.org/dist/rust-0.7.tar.gz\n+[tutorial]: http://static.rust-lang.org/doc/tutorial.html\n+\n+## Notes\n+\n+Since the Rust compiler is written in Rust, it must be built by a\n+precompiled \"snapshot\" version of itself (made in an earlier state of\n+development). As such, source builds require a connection to the Internet, to\n+fetch snapshots, and an OS that can execute the available snapshot binaries.\n \n Snapshot binaries are currently built and tested on several platforms:\n \n@@ -25,42 +79,12 @@ Snapshot binaries are currently built and tested on several platforms:\n You may find that other platforms work, but these are our \"tier 1\"\n supported build environments that are most likely to work.\n \n-> ***Note:*** Windows users should read the detailed\n-> [getting started][wiki-start] notes on the wiki. Even when using\n-> the binary installer the Windows build requires a MinGW installation,\n-> the precise details of which are not discussed here.\n-\n-To build from source you will also need the following prerequisite\n-packages:\n-\n-* g++ 4.4 or clang++ 3.x\n-* python 2.6 or later (but not 3.x)\n-* perl 5.0 or later\n-* gnu make 3.81 or later\n-* curl\n-\n-Assuming you're on a relatively modern *nix system and have met the\n-prerequisites, something along these lines should work.\n-\n-    $ curl -O http://static.rust-lang.org/dist/rust-0.7.tar.gz\n-    $ tar -xzf rust-0.7.tar.gz\n-    $ cd rust-0.7\n-    $ ./configure\n-    $ make && make install\n+Rust currently needs about 1.8G of RAM to build without swapping; if it hits\n+swap, it will take a very long time to build.\n \n-You may need to use `sudo make install` if you do not normally have\n-permission to modify the destination directory. The install locations\n-can be adjusted by passing a `--prefix` argument to\n-`configure`. Various other options are also supported, pass `--help`\n-for more information on them.\n+There is lots more documentation in the [wiki].\n \n-When complete, `make install` will place several programs into\n-`/usr/local/bin`: `rustc`, the Rust compiler; `rustdoc`, the\n-API-documentation tool, and `rustpkg`, the Rust package manager and build system.\n-\n-[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n-[tarball]: http://static.rust-lang.org/dist/rust-0.7.tar.gz\n-[win-exe]: http://static.rust-lang.org/dist/rust-0.7-install.exe\n+[wiki]: https://github.com/mozilla/rust/wiki\n \n \n ## License\n@@ -71,8 +95,3 @@ BSD-like licenses.\n \n See LICENSE-APACHE, LICENSE-MIT, and COPYRIGHT for details.\n \n-## More help\n-\n-The [tutorial] is a good starting point.\n-\n-[tutorial]: http://static.rust-lang.org/doc/tutorial.html"}, {"sha": "e98edd229b8d579c0eff0e18aae022695830acd1", "filename": "doc/rust.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -573,8 +573,7 @@ The top level of this tree is a module that is anonymous (from the point of view\n \n The Rust compiler is always invoked with a single source file as input, and always produces a single output crate.\n The processing of that source file may result in other source files being loaded as modules.\n-Source files typically have the extension `.rs` but, by convention,\n-source files that represent crates have the extension `.rc`, called *crate files*.\n+Source files have the extension `.rs`.\n \n A Rust source file describes a module, the name and\n location of which -- in the module tree of the current crate -- are defined\n@@ -3286,7 +3285,7 @@ As an example, to see all the logs generated by the compiler, you would set\n you would set it to `rustc::metadata::creader`. To see just error logging\n use `rustc=0`.\n \n-Note that when compiling either `.rs` or `.rc` files that don't specify a\n+Note that when compiling source files that don't specify a\n crate name the crate is given a default name that matches the source file,\n with the extension removed. In that case, to turn on logging for a program\n compiled from, e.g. `helloworld.rs`, `RUST_LOG` should be set to `helloworld`."}, {"sha": "d8f21b460138e941e3ce2863b5a6c9cabcb53347", "filename": "src/libextra/future.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -60,6 +60,19 @@ impl<A:Clone> Future<A> {\n     }\n }\n \n+impl<A> Future<A> {\n+    /// Gets the value from this future, forcing evaluation.\n+    pub fn unwrap(self) -> A {\n+        let mut this = self;\n+        this.get_ref();\n+        let state = replace(&mut this.state, Evaluating);\n+        match state {\n+            Forced(v) => v,\n+            _ => fail!( \"Logic error.\" ),\n+        }\n+    }\n+}\n+\n impl<A> Future<A> {\n     pub fn get_ref<'a>(&'a mut self) -> &'a A {\n         /*!\n@@ -179,6 +192,12 @@ mod test {\n         assert_eq!(f.get(), ~\"fail\");\n     }\n \n+    #[test]\n+    fn test_interface_unwrap() {\n+        let mut f = from_value(~\"fail\");\n+        assert_eq!(f.unwrap(), ~\"fail\");\n+    }\n+\n     #[test]\n     fn test_get_ref_method() {\n         let mut f = from_value(22);"}, {"sha": "5e086f94f28676a040ffacca76eb3d87652d3a0c", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 47, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -13,15 +13,12 @@ use back::abi;\n use back::link::{mangle_internal_name_by_path_and_seq};\n use lib::llvm::{llvm, ValueRef};\n use middle::moves;\n-use middle::lang_items::ClosureExchangeMallocFnLangItem;\n use middle::trans::base::*;\n use middle::trans::build::*;\n-use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::datum::{Datum, INIT, ByRef, ZeroMem};\n use middle::trans::expr;\n use middle::trans::glue;\n-use middle::trans::machine;\n use middle::trans::type_of::*;\n use middle::ty;\n use util::ppaux::ty_to_str;\n@@ -508,52 +505,9 @@ pub fn make_opaque_cbox_take_glue(\n             return bcx;\n         }\n         ast::OwnedSigil => {\n-            /* hard case: fallthrough to code below */\n+            fail!(\"unique closures are not copyable\")\n         }\n     }\n-\n-    // ~fn requires a deep copy.\n-    let ccx = bcx.ccx();\n-    let tcx = ccx.tcx;\n-    let llopaquecboxty = Type::opaque_box(ccx).ptr_to();\n-    let cbox_in = Load(bcx, cboxptr);\n-    do with_cond(bcx, IsNotNull(bcx, cbox_in)) |bcx| {\n-        // Load the size from the type descr found in the cbox\n-        let cbox_in = PointerCast(bcx, cbox_in, llopaquecboxty);\n-        let tydescptr = GEPi(bcx, cbox_in, [0u, abi::box_field_tydesc]);\n-        let tydesc = Load(bcx, tydescptr);\n-        let tydesc = PointerCast(bcx, tydesc, ccx.tydesc_type.ptr_to());\n-        let sz = Load(bcx, GEPi(bcx, tydesc, [0u, abi::tydesc_field_size]));\n-\n-        // Adjust sz to account for the rust_opaque_box header fields\n-        let sz = Add(bcx, sz, machine::llsize_of(ccx, Type::box_header(ccx)));\n-\n-        // Allocate memory, update original ptr, and copy existing data\n-        let opaque_tydesc = PointerCast(bcx, tydesc, Type::i8p());\n-        let mut bcx = bcx;\n-        let alloc_fn = langcall(bcx, None,\n-                                fmt!(\"allocation of type with sigil `%s`\",\n-                                    sigil.to_str()),\n-                                ClosureExchangeMallocFnLangItem);\n-        let llresult = unpack_result!(bcx, callee::trans_lang_call(\n-            bcx,\n-            alloc_fn,\n-            [opaque_tydesc, sz],\n-            None));\n-        let cbox_out = PointerCast(bcx, llresult, llopaquecboxty);\n-        call_memcpy(bcx, cbox_out, cbox_in, sz, 1);\n-        Store(bcx, cbox_out, cboxptr);\n-\n-        // Take the (deeply cloned) type descriptor\n-        let tydesc_out = GEPi(bcx, cbox_out, [0u, abi::box_field_tydesc]);\n-        let bcx = glue::take_ty(bcx, tydesc_out, ty::mk_type(tcx));\n-\n-        // Take the data in the tuple\n-        let cdata_out = GEPi(bcx, cbox_out, [0u, abi::box_field_body]);\n-        glue::call_tydesc_glue_full(bcx, cdata_out, tydesc,\n-                                    abi::tydesc_field_take_glue, None);\n-        bcx\n-    }\n }\n \n pub fn make_opaque_cbox_drop_glue("}, {"sha": "ffe6d22d5814f6125ef0c7281d90bb81dea17861", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -93,26 +93,6 @@ pub fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     }\n }\n \n-pub fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> Result {\n-    let _icx = push_ctxt(\"take_ty_immediate\");\n-    match ty::get(t).sty {\n-      ty::ty_box(_) | ty::ty_opaque_box |\n-      ty::ty_evec(_, ty::vstore_box) |\n-      ty::ty_estr(ty::vstore_box) => {\n-        incr_refcnt_of_boxed(bcx, v);\n-        rslt(bcx, v)\n-      }\n-      ty::ty_uniq(_) => {\n-        uniq::duplicate(bcx, v, t)\n-      }\n-      ty::ty_evec(_, ty::vstore_uniq) |\n-      ty::ty_estr(ty::vstore_uniq) => {\n-        tvec::duplicate_uniq(bcx, v, t)\n-      }\n-      _ => rslt(bcx, v)\n-    }\n-}\n-\n pub fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"free_ty\");\n@@ -589,23 +569,15 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n       ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx\n       }\n-      ty::ty_uniq(_) => {\n-        let Result {bcx, val} = uniq::duplicate(bcx, Load(bcx, v), t);\n-        Store(bcx, val, v);\n-        bcx\n-      }\n-      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n-        let Result {bcx, val} = tvec::duplicate_uniq(bcx, Load(bcx, v), t);\n-        Store(bcx, val, v);\n-        bcx\n-      }\n       ty::ty_evec(_, ty::vstore_slice(_))\n       | ty::ty_estr(ty::vstore_slice(_)) => {\n         bcx\n       }\n-      ty::ty_closure(_) => {\n+      ty::ty_closure(ty::ClosureTy { sigil: ast::BorrowedSigil, _ }) |\n+      ty::ty_closure(ty::ClosureTy { sigil: ast::ManagedSigil, _ }) => {\n         closure::make_closure_glue(bcx, v, t, take_ty)\n       }\n+      ty::ty_closure(ty::ClosureTy { sigil: ast::OwnedSigil, _ }) => bcx,\n       ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n         let llbox = Load(bcx, GEPi(bcx, v, [0u, abi::trt_field_box]));\n         incr_refcnt_of_boxed(bcx, llbox);"}, {"sha": "8aca10f9b92e24d39e2d3eb3fee80a1f7edb81f6", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -130,23 +130,6 @@ pub fn alloc_vec(bcx: block,\n     return rslt(bcx, vptr);\n }\n \n-pub fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> Result {\n-    let _icx = push_ctxt(\"tvec::duplicate_uniq\");\n-\n-    let fill = get_fill(bcx, get_bodyptr(bcx, vptr, vec_ty));\n-    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let Result {bcx, val: newptr} = alloc_uniq_raw(bcx, unit_ty, fill, fill);\n-\n-    let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr, vec_ty));\n-    let new_data_ptr = get_dataptr(bcx, get_bodyptr(bcx, newptr, vec_ty));\n-    base::call_memcpy(bcx, new_data_ptr, data_ptr, fill, 1);\n-\n-    let bcx = if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n-        iter_vec_raw(bcx, new_data_ptr, vec_ty, fill, glue::take_ty)\n-    } else { bcx };\n-    return rslt(bcx, newptr);\n-}\n-\n pub fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n    block {\n     let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");"}, {"sha": "e9df83549e28dda9fb4719012131ed473ed8eca5", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -14,11 +14,8 @@ use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n use middle::trans::datum::immediate_rvalue;\n-use middle::trans::datum;\n use middle::trans::glue;\n use middle::ty;\n-use middle::trans::machine::llsize_of;\n-use middle::trans::type_of;\n \n pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n     -> block {\n@@ -37,30 +34,3 @@ pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n         }\n     }\n }\n-\n-pub fn duplicate(bcx: block, src_box: ValueRef, src_ty: ty::t) -> Result {\n-    let _icx = push_ctxt(\"uniq::duplicate\");\n-\n-    // Load the body of the source (*src)\n-    let src_datum = immediate_rvalue(src_box, src_ty);\n-    let body_datum = src_datum.box_body(bcx);\n-\n-    // Malloc space in exchange heap and copy src into it\n-    if ty::type_contents(bcx.tcx(), src_ty).contains_managed() {\n-        let MallocResult {\n-            bcx: bcx,\n-            box: dst_box,\n-            body: dst_body\n-        } = malloc_general(bcx, body_datum.ty, heap_managed_unique);\n-        body_datum.copy_to(bcx, datum::INIT, dst_body);\n-\n-        rslt(bcx, dst_box)\n-    } else {\n-        let body_datum = body_datum.to_value_datum(bcx);\n-        let llty = type_of(bcx.ccx(), body_datum.ty);\n-        let size = llsize_of(bcx.ccx(), llty);\n-        let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, body_datum.ty, heap_exchange, size);\n-        body_datum.copy_to(bcx, datum::INIT, val);\n-        Result { bcx: bcx, val: val }\n-    }\n-}"}, {"sha": "6fd06c951917d83309e008978f855e9fa976eb6d", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -21,7 +21,7 @@ the `clone` method.\n \n */\n \n-use core::kinds::Freeze;\n+use std::kinds::Freeze;\n \n /// A common trait for cloning an object.\n pub trait Clone {"}, {"sha": "0acd6fee57efe1cb08ab6699ad83d25351948fe9", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -382,19 +382,19 @@ mod pipesy {\n \n     #[allow(non_camel_case_types)]\n     pub mod oneshot {\n-        priv use core::kinds::Send;\n+        priv use std::kinds::Send;\n         use ptr::to_mut_unsafe_ptr;\n \n         pub fn init<T: Send>() -> (server::Oneshot<T>, client::Oneshot<T>) {\n-            pub use core::pipes::HasBuffer;\n+            pub use std::pipes::HasBuffer;\n \n-            let buffer = ~::core::pipes::Buffer {\n-                header: ::core::pipes::BufferHeader(),\n+            let buffer = ~::std::pipes::Buffer {\n+                header: ::std::pipes::BufferHeader(),\n                 data: __Buffer {\n-                    Oneshot: ::core::pipes::mk_packet::<Oneshot<T>>()\n+                    Oneshot: ::std::pipes::mk_packet::<Oneshot<T>>()\n                 },\n             };\n-            do ::core::pipes::entangle_buffer(buffer) |buffer, data| {\n+            do ::std::pipes::entangle_buffer(buffer) |buffer, data| {\n                 data.Oneshot.set_buffer(buffer);\n                 to_mut_unsafe_ptr(&mut data.Oneshot)\n             }\n@@ -403,23 +403,23 @@ mod pipesy {\n         pub enum Oneshot<T> { pub send(T), }\n         #[allow(non_camel_case_types)]\n         pub struct __Buffer<T> {\n-            Oneshot: ::core::pipes::Packet<Oneshot<T>>,\n+            Oneshot: ::std::pipes::Packet<Oneshot<T>>,\n         }\n \n         #[allow(non_camel_case_types)]\n         pub mod client {\n \n-            priv use core::kinds::Send;\n+            priv use std::kinds::Send;\n \n             #[allow(non_camel_case_types)]\n             pub fn try_send<T: Send>(pipe: Oneshot<T>, x_0: T) ->\n-                ::core::option::Option<()> {\n+                ::std::option::Option<()> {\n                 {\n                     use super::send;\n                     let message = send(x_0);\n-                    if ::core::pipes::send(pipe, message) {\n-                        ::core::pipes::rt::make_some(())\n-                    } else { ::core::pipes::rt::make_none() }\n+                    if ::std::pipes::send(pipe, message) {\n+                        ::std::pipes::rt::make_some(())\n+                    } else { ::std::pipes::rt::make_none() }\n                 }\n             }\n \n@@ -428,21 +428,21 @@ mod pipesy {\n                 {\n                     use super::send;\n                     let message = send(x_0);\n-                    ::core::pipes::send(pipe, message);\n+                    ::std::pipes::send(pipe, message);\n                 }\n             }\n \n             #[allow(non_camel_case_types)]\n             pub type Oneshot<T> =\n-                ::core::pipes::SendPacketBuffered<super::Oneshot<T>,\n+                ::std::pipes::SendPacketBuffered<super::Oneshot<T>,\n             super::__Buffer<T>>;\n         }\n \n         #[allow(non_camel_case_types)]\n         pub mod server {\n             #[allow(non_camel_case_types)]\n             pub type Oneshot<T> =\n-                ::core::pipes::RecvPacketBuffered<super::Oneshot<T>,\n+                ::std::pipes::RecvPacketBuffered<super::Oneshot<T>,\n             super::__Buffer<T>>;\n         }\n     }\n@@ -557,52 +557,52 @@ mod pipesy {\n \n     #[allow(non_camel_case_types)]\n     pub mod streamp {\n-        priv use core::kinds::Send;\n+        priv use std::kinds::Send;\n \n         pub fn init<T: Send>() -> (server::Open<T>, client::Open<T>) {\n-            pub use core::pipes::HasBuffer;\n-            ::core::pipes::entangle()\n+            pub use std::pipes::HasBuffer;\n+            ::std::pipes::entangle()\n         }\n \n         #[allow(non_camel_case_types)]\n         pub enum Open<T> { pub data(T, server::Open<T>), }\n \n         #[allow(non_camel_case_types)]\n         pub mod client {\n-            priv use core::kinds::Send;\n+            priv use std::kinds::Send;\n \n             #[allow(non_camel_case_types)]\n             pub fn try_data<T: Send>(pipe: Open<T>, x_0: T) ->\n-                ::core::option::Option<Open<T>> {\n+                ::std::option::Option<Open<T>> {\n                 {\n                     use super::data;\n-                    let (s, c) = ::core::pipes::entangle();\n+                    let (s, c) = ::std::pipes::entangle();\n                     let message = data(x_0, s);\n-                    if ::core::pipes::send(pipe, message) {\n-                        ::core::pipes::rt::make_some(c)\n-                    } else { ::core::pipes::rt::make_none() }\n+                    if ::std::pipes::send(pipe, message) {\n+                        ::std::pipes::rt::make_some(c)\n+                    } else { ::std::pipes::rt::make_none() }\n                 }\n             }\n \n             #[allow(non_camel_case_types)]\n             pub fn data<T: Send>(pipe: Open<T>, x_0: T) -> Open<T> {\n                 {\n                     use super::data;\n-                    let (s, c) = ::core::pipes::entangle();\n+                    let (s, c) = ::std::pipes::entangle();\n                     let message = data(x_0, s);\n-                    ::core::pipes::send(pipe, message);\n+                    ::std::pipes::send(pipe, message);\n                     c\n                 }\n             }\n \n             #[allow(non_camel_case_types)]\n-            pub type Open<T> = ::core::pipes::SendPacket<super::Open<T>>;\n+            pub type Open<T> = ::std::pipes::SendPacket<super::Open<T>>;\n         }\n \n         #[allow(non_camel_case_types)]\n         pub mod server {\n             #[allow(non_camel_case_types)]\n-            pub type Open<T> = ::core::pipes::RecvPacket<super::Open<T>>;\n+            pub type Open<T> = ::std::pipes::RecvPacket<super::Open<T>>;\n         }\n     }\n "}, {"sha": "c8cde69197b237984762548dff2abf915f2b1b59", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -773,6 +773,17 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for ChainIterator<A, T, U> {\n     }\n }\n \n+impl<A, T: DoubleEndedIterator<A>, U: DoubleEndedIterator<A>> DoubleEndedIterator<A>\n+for ChainIterator<A, T, U> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        match self.b.next_back() {\n+            Some(x) => Some(x),\n+            None => self.a.next_back()\n+        }\n+    }\n+}\n+\n /// An iterator which iterates two other iterators simultaneously\n // FIXME #6967: Dummy A & B parameters to get around type inference bug\n pub struct ZipIterator<A, T, B, U> {\n@@ -828,6 +839,17 @@ impl<'self, A, B, T: Iterator<A>> Iterator<B> for MapIterator<'self, A, B, T> {\n     }\n }\n \n+impl<'self, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B>\n+for MapIterator<'self, A, B, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        match self.iter.next_back() {\n+            Some(a) => Some((self.f)(a)),\n+            _ => None\n+        }\n+    }\n+}\n+\n /// An iterator which filters the elements of `iter` with `predicate`\n pub struct FilterIterator<'self, A, T> {\n     priv iter: T,\n@@ -854,6 +876,24 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for FilterIterator<'self, A, T> {\n     }\n }\n \n+impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for FilterIterator<'self, A, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        loop {\n+            match self.iter.next_back() {\n+                None => return None,\n+                Some(x) => {\n+                    if (self.predicate)(&x) {\n+                        return Some(x);\n+                    } else {\n+                        loop\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// An iterator which uses `f` to both filter and map elements from `iter`\n pub struct FilterMapIterator<'self, A, B, T> {\n     priv iter: T,\n@@ -879,6 +919,24 @@ impl<'self, A, B, T: Iterator<A>> Iterator<B> for FilterMapIterator<'self, A, B,\n     }\n }\n \n+impl<'self, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B>\n+for FilterMapIterator<'self, A, B, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        loop {\n+            match self.iter.next_back() {\n+                None => return None,\n+                Some(x) => {\n+                    match (self.f)(x) {\n+                        Some(y) => return Some(y),\n+                        None => ()\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// An iterator which yields the current count and the element during iteration\n // FIXME #6967: Dummy A parameter to get around type inference bug\n pub struct EnumerateIterator<A, T> {\n@@ -1135,6 +1193,20 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for PeekIterator<'self, A, T> {\n     }\n }\n \n+impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for PeekIterator<'self, A, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        let next = self.iter.next_back();\n+\n+        match next {\n+            Some(ref a) => (self.f)(a),\n+            None => ()\n+        }\n+\n+        next\n+    }\n+}\n+\n /// An iterator which just modifies the contained state throughout iteration.\n pub struct UnfoldrIterator<'self, A, St> {\n     priv f: &'self fn(&mut St) -> Option<A>,\n@@ -1526,4 +1598,53 @@ mod tests {\n         it.next();\n         assert_eq!(it.invert().transform(|&x| x).collect::<~[int]>(), ~[16, 14, 12, 10, 8, 6]);\n     }\n+\n+    #[test]\n+    fn test_double_ended_map() {\n+        let xs = [1, 2, 3, 4, 5, 6];\n+        let mut it = xs.iter().transform(|&x| x * -1);\n+        assert_eq!(it.next(), Some(-1));\n+        assert_eq!(it.next(), Some(-2));\n+        assert_eq!(it.next_back(), Some(-6));\n+        assert_eq!(it.next_back(), Some(-5));\n+        assert_eq!(it.next(), Some(-3));\n+        assert_eq!(it.next_back(), Some(-4));\n+        assert_eq!(it.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_double_ended_filter() {\n+        let xs = [1, 2, 3, 4, 5, 6];\n+        let mut it = xs.iter().filter(|&x| *x & 1 == 0);\n+        assert_eq!(it.next_back().unwrap(), &6);\n+        assert_eq!(it.next_back().unwrap(), &4);\n+        assert_eq!(it.next().unwrap(), &2);\n+        assert_eq!(it.next_back(), None);\n+    }\n+\n+    #[test]\n+    fn test_double_ended_filter_map() {\n+        let xs = [1, 2, 3, 4, 5, 6];\n+        let mut it = xs.iter().filter_map(|&x| if x & 1 == 0 { Some(x * 2) } else { None });\n+        assert_eq!(it.next_back().unwrap(), 12);\n+        assert_eq!(it.next_back().unwrap(), 8);\n+        assert_eq!(it.next().unwrap(), 4);\n+        assert_eq!(it.next_back(), None);\n+    }\n+\n+    #[test]\n+    fn test_double_ended_chain() {\n+        let xs = [1, 2, 3, 4, 5];\n+        let ys = ~[7, 9, 11];\n+        let mut it = xs.iter().chain_(ys.iter()).invert();\n+        assert_eq!(it.next().unwrap(), &11)\n+        assert_eq!(it.next().unwrap(), &9)\n+        assert_eq!(it.next_back().unwrap(), &1)\n+        assert_eq!(it.next_back().unwrap(), &2)\n+        assert_eq!(it.next_back().unwrap(), &3)\n+        assert_eq!(it.next_back().unwrap(), &4)\n+        assert_eq!(it.next_back().unwrap(), &5)\n+        assert_eq!(it.next_back().unwrap(), &7)\n+        assert_eq!(it.next_back(), None)\n+    }\n }"}, {"sha": "8e7f49464ffc204c38125c3344183b5e37f9012e", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -12,7 +12,7 @@\n \n use clone::Clone;\n use container::Container;\n-use core::cmp::{Ord, Eq};\n+use std::cmp::{Ord, Eq};\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n use char;"}, {"sha": "b30a55978f742d9ba7363c97b36db1f4512f6615", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -209,6 +209,6 @@ fn align_down(sp: *mut uint) -> *mut uint {\n // XXX: ptr::offset is positive ints only\n #[inline]\n pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n-    use core::sys::size_of;\n+    use std::sys::size_of;\n     (ptr as int + count * (size_of::<T>() as int)) as *mut T\n }"}, {"sha": "cbf00f43c61b9364eefe68f44bfbfcf0c9e400cd", "filename": "src/libstd/std.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -206,16 +206,6 @@ pub mod rt;\n // 'std' so that macro-expanded references to std::error and such\n // can be resolved within libstd.\n #[doc(hidden)]\n-mod core {\n-    pub use clone;\n-    pub use cmp;\n-    pub use condition;\n-    pub use option;\n-    pub use kinds;\n-    pub use sys;\n-    pub use pipes;\n-}\n-#[doc(hidden)]\n mod std {\n     pub use clone;\n     pub use cmp;"}, {"sha": "822b005de37a2d2051858266df598beeffb89c2e", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=8d97c905ddecec2e2d0d72926bc4c9e739ccb6e3", "patch": "@@ -411,7 +411,7 @@ pub fn check_integrity<T>(trie: &TrieNode<T>) {\n #[cfg(test)]\n mod test_map {\n     use super::*;\n-    use core::option::{Some, None};\n+    use option::{Some, None};\n     use uint;\n \n     #[test]"}]}