{"sha": "d7734aebeca4d2f230bdec631ffce1416740afa5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NzM0YWViZWNhNGQyZjIzMGJkZWM2MzFmZmNlMTQxNjc0MGFmYTU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-07T23:06:10Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-08T02:25:09Z"}, "message": "Refactor away add_export and cleanup the end of resolve_single_import", "tree": {"sha": "32afc3e5af241179637abaaf79f6b8028a2d4cce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32afc3e5af241179637abaaf79f6b8028a2d4cce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7734aebeca4d2f230bdec631ffce1416740afa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7734aebeca4d2f230bdec631ffce1416740afa5", "html_url": "https://github.com/rust-lang/rust/commit/d7734aebeca4d2f230bdec631ffce1416740afa5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7734aebeca4d2f230bdec631ffce1416740afa5/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7000e708252bd9e45f28926d8fd38cc9ec054e57", "url": "https://api.github.com/repos/rust-lang/rust/commits/7000e708252bd9e45f28926d8fd38cc9ec054e57", "html_url": "https://github.com/rust-lang/rust/commit/7000e708252bd9e45f28926d8fd38cc9ec054e57"}], "stats": {"total": 77, "additions": 25, "deletions": 52}, "files": [{"sha": "0eab53260a58ba5c92aa0e94698b648cbb905038", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 25, "deletions": 52, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d7734aebeca4d2f230bdec631ffce1416740afa5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7734aebeca4d2f230bdec631ffce1416740afa5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=d7734aebeca4d2f230bdec631ffce1416740afa5", "patch": "@@ -471,28 +471,19 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             }\n         }\n \n-        let value_def_and_priv = {\n-            module_.decrement_outstanding_references_for(target, ValueNS);\n-\n-            // Record what this import resolves to for later uses in documentation,\n-            // this may resolve to either a value or a type, but for documentation\n-            // purposes it's good enough to just favor one over the other.\n-            value_result.success().map(|binding| {\n-                let def = binding.def().unwrap();\n-                let last_private = if binding.is_public() { lp } else { DependsOn(def.def_id()) };\n-                (def, last_private)\n-            })\n-        };\n-\n-        let type_def_and_priv = {\n-            module_.decrement_outstanding_references_for(target, TypeNS);\n-\n-            type_result.success().map(|binding| {\n-                let def = binding.def().unwrap();\n-                let last_private = if binding.is_public() { lp } else { DependsOn(def.def_id()) };\n-                (def, last_private)\n-            })\n+        // Record what this import resolves to for later uses in documentation,\n+        // this may resolve to either a value or a type, but for documentation\n+        // purposes it's good enough to just favor one over the other.\n+        module_.decrement_outstanding_references_for(target, ValueNS);\n+        module_.decrement_outstanding_references_for(target, TypeNS);\n+\n+        let def_and_priv = |binding: &NameBinding| {\n+            let def = binding.def().unwrap();\n+            let last_private = if binding.is_public() { lp } else { DependsOn(def.def_id()) };\n+            (def, last_private)\n         };\n+        let value_def_and_priv = value_result.success().map(&def_and_priv);\n+        let type_def_and_priv = type_result.success().map(&def_and_priv);\n \n         let import_lp = LastImport {\n             value_priv: value_def_and_priv.map(|(_, p)| p),\n@@ -501,22 +492,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             type_used: Used,\n         };\n \n-        if let Some((def, _)) = value_def_and_priv {\n-            self.resolver.def_map.borrow_mut().insert(directive.id,\n-                                                      PathResolution {\n-                                                          base_def: def,\n-                                                          last_private: import_lp,\n-                                                          depth: 0,\n-                                                      });\n-        }\n-        if let Some((def, _)) = type_def_and_priv {\n-            self.resolver.def_map.borrow_mut().insert(directive.id,\n-                                                      PathResolution {\n-                                                          base_def: def,\n-                                                          last_private: import_lp,\n-                                                          depth: 0,\n-                                                      });\n-        }\n+        let write_path_resolution = |(def, _)| {\n+            let path_resolution =\n+                PathResolution { base_def: def, last_private: import_lp, depth: 0 };\n+            self.resolver.def_map.borrow_mut().insert(directive.id, path_resolution);\n+        };\n+        value_def_and_priv.map(&write_path_resolution);\n+        type_def_and_priv.map(&write_path_resolution);\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n@@ -575,19 +557,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         return Success(());\n     }\n \n-    fn add_export(&mut self, module: Module<'b>, name: Name, binding: &NameBinding<'b>) {\n-        if !binding.is_public() { return }\n-        let node_id = match module.def_id() {\n-            Some(def_id) => self.resolver.ast_map.as_local_node_id(def_id).unwrap(),\n-            None => return,\n-        };\n-        let export = match binding.def() {\n-            Some(def) => Export { name: name, def_id: def.def_id() },\n-            None => return,\n-        };\n-        self.resolver.export_map.entry(node_id).or_insert(Vec::new()).push(export);\n-    }\n-\n     fn define(&mut self,\n               parent: Module<'b>,\n               name: Name,\n@@ -596,8 +565,12 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         let binding = self.resolver.new_name_binding(binding);\n         if let Err(old_binding) = parent.try_define_child(name, ns, binding) {\n             self.report_conflict(name, ns, binding, old_binding);\n-        } else if binding.is_public() {\n-            self.add_export(parent, name, binding);\n+        } else if binding.is_public() { // Add to the export map\n+            if let (Some(parent_def_id), Some(def)) = (parent.def_id(), binding.def()) {\n+                let parent_node_id = self.resolver.ast_map.as_local_node_id(parent_def_id).unwrap();\n+                let export = Export { name: name, def_id: def.def_id() };\n+                self.resolver.export_map.entry(parent_node_id).or_insert(Vec::new()).push(export);\n+            }\n         }\n     }\n "}]}