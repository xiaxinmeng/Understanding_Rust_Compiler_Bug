{"sha": "94b2d9dc4dd864b481bcf279921bc7ea796355e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YjJkOWRjNGRkODY0YjQ4MWJjZjI3OTkyMWJjN2VhNzk2MzU1ZTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-07T18:10:48Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-17T02:45:48Z"}, "message": "Move unix pipes implementation to pipe_unix.rs\n\nThe windows named pipes implementation will have almost nothing to do with unix\npipes, so I think it's best if they live in separate files.", "tree": {"sha": "458254143212ed0184da2c1cb95052bbefcfb814", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/458254143212ed0184da2c1cb95052bbefcfb814"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94b2d9dc4dd864b481bcf279921bc7ea796355e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94b2d9dc4dd864b481bcf279921bc7ea796355e5", "html_url": "https://github.com/rust-lang/rust/commit/94b2d9dc4dd864b481bcf279921bc7ea796355e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94b2d9dc4dd864b481bcf279921bc7ea796355e5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a226f566002b58d618787f1121388b3df65be9c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a226f566002b58d618787f1121388b3df65be9c2", "html_url": "https://github.com/rust-lang/rust/commit/a226f566002b58d618787f1121388b3df65be9c2"}], "stats": {"total": 619, "additions": 312, "deletions": 307}, "files": [{"sha": "ad0d7270c1a236318653e59520968992c49fe579", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/94b2d9dc4dd864b481bcf279921bc7ea796355e5/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2d9dc4dd864b481bcf279921bc7ea796355e5/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=94b2d9dc4dd864b481bcf279921bc7ea796355e5", "patch": "@@ -60,6 +60,14 @@ pub mod timer;\n #[path = \"timer_win32.rs\"]\n pub mod timer;\n \n+#[cfg(unix)]\n+#[path = \"path_unix.rs\"]\n+pub mod pipe;\n+\n+#[cfg(windows)]\n+#[path = \"path_win32.rs\"]\n+pub mod pipe;\n+\n mod timer_helper;\n \n pub type IoResult<T> = Result<T, IoError>;\n@@ -196,11 +204,11 @@ impl rtio::IoFactory for IoFactory {\n     fn udp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioUdpSocket> {\n         net::UdpSocket::bind(addr).map(|u| ~u as ~RtioUdpSocket)\n     }\n-    fn unix_bind(&mut self, _path: &CString) -> IoResult<~RtioUnixListener> {\n-        net::UnixListener::bind(_path).map(|s| ~s as ~RtioUnixListener)\n+    fn unix_bind(&mut self, path: &CString) -> IoResult<~RtioUnixListener> {\n+        pipe::UnixListener::bind(path).map(|s| ~s as ~RtioUnixListener)\n     }\n-    fn unix_connect(&mut self, _path: &CString) -> IoResult<~RtioPipe> {\n-        net::UnixStream::connect(_path, libc::SOCK_STREAM).map(|s| ~s as ~RtioPipe)\n+    fn unix_connect(&mut self, path: &CString) -> IoResult<~RtioPipe> {\n+        pipe::UnixStream::connect(path).map(|s| ~s as ~RtioPipe)\n     }\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> IoResult<~[ai::Info]> {"}, {"sha": "dce890dc129610d1c984d636b3dbc9bcc9aa04bd", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 0, "deletions": 303, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/94b2d9dc4dd864b481bcf279921bc7ea796355e5/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2d9dc4dd864b481bcf279921bc7ea796355e5/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=94b2d9dc4dd864b481bcf279921bc7ea796355e5", "patch": "@@ -685,306 +685,3 @@ impl rtio::RtioUdpSocket for UdpSocket {\n         ~UdpSocket { inner: self.inner.clone() } as ~rtio::RtioUdpSocket\n     }\n }\n-\n-\n-#[cfg(not(windows))]\n-////////////////////////////////////////////////////////////////////////////////\n-// Unix\n-////////////////////////////////////////////////////////////////////////////////\n-\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Unix streams\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct UnixStream {\n-    priv fd: sock_t,\n-}\n-\n-impl UnixStream {\n-    pub fn connect(addr: &CString, ty: libc::c_int) -> IoResult<UnixStream> {\n-        unsafe {\n-            unix_socket(ty).and_then(|fd| {\n-                match addr_to_sockaddr_un(addr) {\n-                    Err(e)          => return Err(e),\n-                    Ok((addr, len)) => {\n-                        let ret = UnixStream{ fd: fd };\n-                        let addrp = &addr as *libc::sockaddr_storage;\n-                        match retry(|| {\n-                          libc::connect(fd, addrp as *libc::sockaddr,\n-                                         len as libc::socklen_t)\n-                        }) {\n-                            -1 => return Err(super::last_error()),\n-                            _  => return Ok(ret)\n-                        }\n-                    }\n-                }\n-            })\n-        }\n-    }\n-\n-    pub fn fd(&self) -> sock_t { self.fd }\n-}\n-\n-impl rtio::RtioPipe for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let ret = retry(|| {\n-            unsafe {\n-                libc::recv(self.fd,\n-                           buf.as_ptr() as *mut libc::c_void,\n-                           buf.len() as wrlen,\n-                           0) as libc::c_int\n-            }\n-        });\n-        if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as uint)\n-        }\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::send(self.fd,\n-                           buf as *mut libc::c_void,\n-                           len as wrlen,\n-                           0) as i64\n-            }\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-}\n-\n-impl Drop for UnixStream {\n-    fn drop(&mut self) { unsafe { close(self.fd); } }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Unix Datagram\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct UnixDatagram {\n-    priv fd: sock_t,\n-}\n-\n-impl UnixDatagram {\n-    pub fn connect(addr: &CString, ty: libc::c_int) -> IoResult<UnixDatagram> {\n-        unsafe {\n-            unix_socket(ty).and_then(|fd| {\n-                match addr_to_sockaddr_un(addr) {\n-                    Err(e)          => return Err(e),\n-                    Ok((addr, len)) => {\n-                        let ret = UnixDatagram{ fd: fd };\n-                        let addrp = &addr as *libc::sockaddr_storage;\n-                        match retry(|| {\n-                          libc::connect(fd, addrp as *libc::sockaddr,\n-                                         len as libc::socklen_t)\n-                        }) {\n-                            -1 => return Err(super::last_error()),\n-                            _  => return Ok(ret)\n-                        }\n-                    }\n-                }\n-            })\n-        }\n-    }\n-\n-    pub fn bind(addr: &CString) -> IoResult<UnixDatagram> {\n-        unsafe {\n-            unix_socket(libc::SOCK_DGRAM).and_then(|fd| {\n-                match addr_to_sockaddr_un(addr) {\n-                    Err(e)          => return Err(e),\n-                    Ok((addr, len)) => {\n-                        let ret = UnixDatagram{ fd: fd };\n-                        let addrp = &addr as *libc::sockaddr_storage;\n-                        match libc::bind(fd, addrp as *libc::sockaddr,\n-                                         len as libc::socklen_t) {\n-                            -1 => return Err(super::last_error()),\n-                            _  => return Ok(ret)\n-                        }\n-                    }\n-                }\n-            })\n-        }\n-    }\n-\n-    pub fn fd(&self) -> sock_t { self.fd }\n-}\n-\n-impl rtio::RtioPipe for UnixDatagram {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let ret = retry(|| {\n-            unsafe {\n-                libc::recv(self.fd,\n-                           buf.as_ptr() as *mut libc::c_void,\n-                           buf.len() as wrlen,\n-                           0) as libc::c_int\n-            }\n-        });\n-        if ret == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as uint)\n-        }\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::send(self.fd,\n-                           buf as *mut libc::c_void,\n-                           len as wrlen,\n-                           0) as i64\n-            }\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-}\n-\n-impl rtio::RtioDatagramPipe for UnixDatagram {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, CString)> {\n-        unsafe {\n-            let mut storage: libc::sockaddr_storage = intrinsics::init();\n-            let storagep = &mut storage as *mut libc::sockaddr_storage;\n-            let mut addrlen: libc::socklen_t =\n-                    mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n-            let ret = retry(|| {\n-                libc::recvfrom(self.fd,\n-                               buf.as_ptr() as *mut libc::c_void,\n-                               buf.len() as msglen_t,\n-                               0,\n-                               storagep as *mut libc::sockaddr,\n-                               &mut addrlen) as libc::c_int\n-            });\n-            if ret < 0 { return Err(super::last_error()) }\n-            sockaddr_to_unix(&storage, addrlen as uint).and_then(|addr| {\n-                Ok((ret as uint, addr))\n-            })\n-        }\n-    }\n-\n-    fn sendto(&mut self, buf: &[u8], dst: &CString) -> IoResult<()> {\n-        match addr_to_sockaddr_un(dst) {\n-            Err(e)         => Err(e),\n-            Ok((dst, len)) => {\n-                let dstp = &dst as *libc::sockaddr_storage;\n-                unsafe {\n-                    let ret = retry(|| {\n-                        libc::sendto(self.fd,\n-                                     buf.as_ptr() as *libc::c_void,\n-                                     buf.len() as msglen_t,\n-                                     0,\n-                                     dstp as *libc::sockaddr,\n-                                     len as libc::socklen_t) as libc::c_int\n-                    });\n-                    match ret {\n-                        -1 => Err(super::last_error()),\n-                        n if n as uint != buf.len() => {\n-                            Err(io::IoError {\n-                                kind: io::OtherIoError,\n-                                desc: \"couldn't send entire packet at once\",\n-                                detail: None,\n-                            })\n-                        }\n-                        _ => Ok(())\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl Drop for UnixDatagram {\n-    fn drop(&mut self) { unsafe { close(self.fd); } }\n-}\n-////////////////////////////////////////////////////////////////////////////////\n-// Unix Listener\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct UnixListener {\n-    priv fd: sock_t,\n-}\n-\n-impl UnixListener {\n-    pub fn bind(addr: &CString) -> IoResult<UnixListener> {\n-        unsafe {\n-            unix_socket(libc::SOCK_STREAM).and_then(|fd| {\n-                match addr_to_sockaddr_un(addr) {\n-                    Err(e)          => return Err(e),\n-                    Ok((addr, len)) => {\n-                        let ret = UnixListener{ fd: fd };\n-                        let addrp = &addr as *libc::sockaddr_storage;\n-                        match libc::bind(fd, addrp as *libc::sockaddr,\n-                                         len as libc::socklen_t) {\n-                            -1 => return Err(super::last_error()),\n-                            _  => return Ok(ret)\n-                        }\n-                    }\n-                }\n-            })\n-        }\n-    }\n-\n-    pub fn fd(&self) -> sock_t { self.fd }\n-\n-    pub fn native_listen(self, backlog: int) -> IoResult<UnixAcceptor> {\n-        match unsafe { libc::listen(self.fd, backlog as libc::c_int) } {\n-            -1 => Err(super::last_error()),\n-            _ => Ok(UnixAcceptor { listener: self })\n-        }\n-    }\n-}\n-\n-impl rtio::RtioUnixListener for UnixListener {\n-    fn listen(~self) -> IoResult<~rtio::RtioUnixAcceptor> {\n-        self.native_listen(128).map(|a| ~a as ~rtio::RtioUnixAcceptor)\n-    }\n-}\n-\n-impl Drop for UnixListener {\n-    fn drop(&mut self) { unsafe { close(self.fd); } }\n-}\n-\n-pub struct UnixAcceptor {\n-    priv listener: UnixListener,\n-}\n-\n-impl UnixAcceptor {\n-    pub fn fd(&self) -> sock_t { self.listener.fd }\n-\n-    pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n-        unsafe {\n-            let mut storage: libc::sockaddr_storage = intrinsics::init();\n-            let storagep = &mut storage as *mut libc::sockaddr_storage;\n-            let size = mem::size_of::<libc::sockaddr_storage>();\n-            let mut size = size as libc::socklen_t;\n-            match retry(|| {\n-                libc::accept(self.fd(),\n-                             storagep as *mut libc::sockaddr,\n-                             &mut size as *mut libc::socklen_t) as libc::c_int\n-            }) as sock_t {\n-                -1 => Err(super::last_error()),\n-                fd => Ok(UnixStream { fd: fd })\n-            }\n-        }\n-    }\n-}\n-\n-impl rtio::RtioUnixAcceptor for UnixAcceptor {\n-    fn accept(&mut self) -> IoResult<~rtio::RtioPipe> {\n-        self.native_accept().map(|s| ~s as ~rtio::RtioPipe)\n-    }\n-}\n-\n-"}, {"sha": "1160bc196d8f0e5a36ef9bb01c559b10ac73a57e", "filename": "src/libnative/io/pipe_unix.rs", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/94b2d9dc4dd864b481bcf279921bc7ea796355e5/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b2d9dc4dd864b481bcf279921bc7ea796355e5/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=94b2d9dc4dd864b481bcf279921bc7ea796355e5", "patch": "@@ -0,0 +1,300 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Unix\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct UnixStream {\n+    priv fd: sock_t,\n+}\n+\n+impl UnixStream {\n+    pub fn connect(addr: &CString, ty: libc::c_int) -> IoResult<UnixStream> {\n+        unix_socket(ty).and_then(|fd| {\n+            match addr_to_sockaddr_un(addr) {\n+                Err(e)          => return Err(e),\n+                Ok((addr, len)) => {\n+                    let ret = UnixStream{ fd: fd };\n+                    let addrp = &addr as *libc::sockaddr_storage;\n+                    match retry(|| {\n+                      libc::connect(fd, addrp as *libc::sockaddr,\n+                                     len as libc::socklen_t)\n+                    }) {\n+                        -1 => return Err(super::last_error()),\n+                        _  => return Ok(ret)\n+                    }\n+                }\n+            }\n+        })\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.fd }\n+}\n+\n+impl rtio::RtioPipe for UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        let ret = retry(|| {\n+            unsafe {\n+                libc::recv(self.fd,\n+                           buf.as_ptr() as *mut libc::c_void,\n+                           buf.len() as wrlen,\n+                           0) as libc::c_int\n+            }\n+        });\n+        if ret == 0 {\n+            Err(io::standard_error(io::EndOfFile))\n+        } else if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as uint)\n+        }\n+    }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::send(self.fd,\n+                           buf as *mut libc::c_void,\n+                           len as wrlen,\n+                           0) as i64\n+            }\n+        });\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+}\n+\n+impl Drop for UnixStream {\n+    fn drop(&mut self) { unsafe { close(self.fd); } }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Unix Datagram\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct UnixDatagram {\n+    priv fd: sock_t,\n+}\n+\n+impl UnixDatagram {\n+    pub fn connect(addr: &CString, ty: libc::c_int) -> IoResult<UnixDatagram> {\n+        unsafe {\n+            unix_socket(ty).and_then(|fd| {\n+                match addr_to_sockaddr_un(addr) {\n+                    Err(e)          => return Err(e),\n+                    Ok((addr, len)) => {\n+                        let ret = UnixDatagram{ fd: fd };\n+                        let addrp = &addr as *libc::sockaddr_storage;\n+                        match retry(|| {\n+                          libc::connect(fd, addrp as *libc::sockaddr,\n+                                         len as libc::socklen_t)\n+                        }) {\n+                            -1 => return Err(super::last_error()),\n+                            _  => return Ok(ret)\n+                        }\n+                    }\n+                }\n+            })\n+        }\n+    }\n+\n+    pub fn bind(addr: &CString) -> IoResult<UnixDatagram> {\n+        unsafe {\n+            unix_socket(libc::SOCK_DGRAM).and_then(|fd| {\n+                match addr_to_sockaddr_un(addr) {\n+                    Err(e)          => return Err(e),\n+                    Ok((addr, len)) => {\n+                        let ret = UnixDatagram{ fd: fd };\n+                        let addrp = &addr as *libc::sockaddr_storage;\n+                        match libc::bind(fd, addrp as *libc::sockaddr,\n+                                         len as libc::socklen_t) {\n+                            -1 => return Err(super::last_error()),\n+                            _  => return Ok(ret)\n+                        }\n+                    }\n+                }\n+            })\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.fd }\n+}\n+\n+impl rtio::RtioPipe for UnixDatagram {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        let ret = retry(|| {\n+            unsafe {\n+                libc::recv(self.fd,\n+                           buf.as_ptr() as *mut libc::c_void,\n+                           buf.len() as wrlen,\n+                           0) as libc::c_int\n+            }\n+        });\n+        if ret == 0 {\n+            Err(io::standard_error(io::EndOfFile))\n+        } else if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as uint)\n+        }\n+    }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::send(self.fd,\n+                           buf as *mut libc::c_void,\n+                           len as wrlen,\n+                           0) as i64\n+            }\n+        });\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+}\n+\n+impl rtio::RtioDatagramPipe for UnixDatagram {\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, CString)> {\n+        unsafe {\n+            let mut storage: libc::sockaddr_storage = intrinsics::init();\n+            let storagep = &mut storage as *mut libc::sockaddr_storage;\n+            let mut addrlen: libc::socklen_t =\n+                    mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n+            let ret = retry(|| {\n+                libc::recvfrom(self.fd,\n+                               buf.as_ptr() as *mut libc::c_void,\n+                               buf.len() as msglen_t,\n+                               0,\n+                               storagep as *mut libc::sockaddr,\n+                               &mut addrlen) as libc::c_int\n+            });\n+            if ret < 0 { return Err(super::last_error()) }\n+            sockaddr_to_unix(&storage, addrlen as uint).and_then(|addr| {\n+                Ok((ret as uint, addr))\n+            })\n+        }\n+    }\n+\n+    fn sendto(&mut self, buf: &[u8], dst: &CString) -> IoResult<()> {\n+        match addr_to_sockaddr_un(dst) {\n+            Err(e)         => Err(e),\n+            Ok((dst, len)) => {\n+                let dstp = &dst as *libc::sockaddr_storage;\n+                unsafe {\n+                    let ret = retry(|| {\n+                        libc::sendto(self.fd,\n+                                     buf.as_ptr() as *libc::c_void,\n+                                     buf.len() as msglen_t,\n+                                     0,\n+                                     dstp as *libc::sockaddr,\n+                                     len as libc::socklen_t) as libc::c_int\n+                    });\n+                    match ret {\n+                        -1 => Err(super::last_error()),\n+                        n if n as uint != buf.len() => {\n+                            Err(io::IoError {\n+                                kind: io::OtherIoError,\n+                                desc: \"couldn't send entire packet at once\",\n+                                detail: None,\n+                            })\n+                        }\n+                        _ => Ok(())\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for UnixDatagram {\n+    fn drop(&mut self) { unsafe { close(self.fd); } }\n+}\n+////////////////////////////////////////////////////////////////////////////////\n+// Unix Listener\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct UnixListener {\n+    priv fd: sock_t,\n+}\n+\n+impl UnixListener {\n+    pub fn bind(addr: &CString) -> IoResult<UnixListener> {\n+        unsafe {\n+            unix_socket(libc::SOCK_STREAM).and_then(|fd| {\n+                match addr_to_sockaddr_un(addr) {\n+                    Err(e)          => return Err(e),\n+                    Ok((addr, len)) => {\n+                        let ret = UnixListener{ fd: fd };\n+                        let addrp = &addr as *libc::sockaddr_storage;\n+                        match libc::bind(fd, addrp as *libc::sockaddr,\n+                                         len as libc::socklen_t) {\n+                            -1 => return Err(super::last_error()),\n+                            _  => return Ok(ret)\n+                        }\n+                    }\n+                }\n+            })\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.fd }\n+\n+    pub fn native_listen(self, backlog: int) -> IoResult<UnixAcceptor> {\n+        match unsafe { libc::listen(self.fd, backlog as libc::c_int) } {\n+            -1 => Err(super::last_error()),\n+            _ => Ok(UnixAcceptor { listener: self })\n+        }\n+    }\n+}\n+\n+impl rtio::RtioUnixListener for UnixListener {\n+    fn listen(~self) -> IoResult<~rtio::RtioUnixAcceptor> {\n+        self.native_listen(128).map(|a| ~a as ~rtio::RtioUnixAcceptor)\n+    }\n+}\n+\n+impl Drop for UnixListener {\n+    fn drop(&mut self) { unsafe { close(self.fd); } }\n+}\n+\n+pub struct UnixAcceptor {\n+    priv listener: UnixListener,\n+}\n+\n+impl UnixAcceptor {\n+    pub fn fd(&self) -> sock_t { self.listener.fd }\n+\n+    pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n+        let mut storage: libc::sockaddr_storage = unsafe { intrinsics::init() };\n+        let storagep = &mut storage as *mut libc::sockaddr_storage;\n+        let size = mem::size_of::<libc::sockaddr_storage>();\n+        let mut size = size as libc::socklen_t;\n+        match retry(|| unsafe {\n+            libc::accept(self.fd(),\n+                         storagep as *mut libc::sockaddr,\n+                         &mut size as *mut libc::socklen_t) as libc::c_int\n+        }) as sock_t {\n+            -1 => Err(super::last_error()),\n+            fd => Ok(UnixStream { fd: fd })\n+        }\n+    }\n+}\n+\n+impl rtio::RtioUnixAcceptor for UnixAcceptor {\n+    fn accept(&mut self) -> IoResult<~rtio::RtioPipe> {\n+        self.native_accept().map(|s| ~s as ~rtio::RtioPipe)\n+    }\n+}\n+"}]}