{"sha": "22f9bcce042d8ab77c534f22173c31f9a9ee224e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZjliY2NlMDQyZDhhYjc3YzUzNGYyMjE3M2MzMWY5YTllZTIyNGU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-31T22:36:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-10T12:22:31Z"}, "message": "matches/mod.rs: rustfmt", "tree": {"sha": "f271f189e477ea608015cc3b2239ba7770744374", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f271f189e477ea608015cc3b2239ba7770744374"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22f9bcce042d8ab77c534f22173c31f9a9ee224e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22f9bcce042d8ab77c534f22173c31f9a9ee224e", "html_url": "https://github.com/rust-lang/rust/commit/22f9bcce042d8ab77c534f22173c31f9a9ee224e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22f9bcce042d8ab77c534f22173c31f9a9ee224e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50754d05138a93434397245746d0dcdfbf29e2a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/50754d05138a93434397245746d0dcdfbf29e2a4", "html_url": "https://github.com/rust-lang/rust/commit/50754d05138a93434397245746d0dcdfbf29e2a4"}], "stats": {"total": 702, "additions": 419, "deletions": 283}, "files": [{"sha": "09e03554f05c36f8e835f5f704da603c39db3ad1", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 419, "deletions": 283, "changes": 702, "blob_url": "https://github.com/rust-lang/rust/blob/22f9bcce042d8ab77c534f22173c31f9a9ee224e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f9bcce042d8ab77c534f22173c31f9a9ee224e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=22f9bcce042d8ab77c534f22173c31f9a9ee224e", "patch": "@@ -13,16 +13,16 @@\n //! includes the high-level algorithm, the submodules contain the\n //! details.\n \n+use build::scope::{CachedBlock, DropKind};\n+use build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n-use build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n-use build::scope::{CachedBlock, DropKind};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::bitvec::BitArray;\n-use rustc::ty::{self, CanonicalTy, Ty};\n-use rustc::mir::*;\n-use rustc::hir;\n use hair::*;\n+use rustc::hir;\n+use rustc::mir::*;\n+use rustc::ty::{self, CanonicalTy, Ty};\n+use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::{Name, NodeId};\n use syntax_pos::Span;\n \n@@ -37,13 +37,14 @@ mod util;\n pub(crate) struct ArmHasGuard(pub bool);\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n-    pub fn match_expr(&mut self,\n-                      destination: &Place<'tcx>,\n-                      span: Span,\n-                      mut block: BasicBlock,\n-                      discriminant: ExprRef<'tcx>,\n-                      arms: Vec<Arm<'tcx>>)\n-                      -> BlockAnd<()> {\n+    pub fn match_expr(\n+        &mut self,\n+        destination: &Place<'tcx>,\n+        span: Span,\n+        mut block: BasicBlock,\n+        discriminant: ExprRef<'tcx>,\n+        arms: Vec<Arm<'tcx>>,\n+    ) -> BlockAnd<()> {\n         let tcx = self.hir.tcx();\n         let discriminant_span = discriminant.span();\n         let discriminant_place = unpack!(block = self.as_place(block, discriminant));\n@@ -67,68 +68,83 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let dummy_access = Rvalue::Discriminant(discriminant_place.clone());\n         let dummy_ty = dummy_access.ty(&self.local_decls, tcx);\n         let dummy_temp = self.temp(dummy_ty, dummy_source_info.span);\n-        self.cfg.push_assign(block, dummy_source_info, &dummy_temp, dummy_access);\n+        self.cfg\n+            .push_assign(block, dummy_source_info, &dummy_temp, dummy_access);\n \n         let source_info = self.source_info(discriminant_span);\n         let borrowed_input_temp = if tcx.generate_borrow_of_any_match_input() {\n             // The region is unknown at this point; we rely on NLL\n             // inference to find an appropriate one. Therefore you can\n             // only use this when NLL is turned on.\n             assert!(tcx.use_mir_borrowck());\n-            let borrowed_input =\n-                Rvalue::Ref(tcx.types.re_empty, BorrowKind::Shared, discriminant_place.clone());\n+            let borrowed_input = Rvalue::Ref(\n+                tcx.types.re_empty,\n+                BorrowKind::Shared,\n+                discriminant_place.clone(),\n+            );\n             let borrowed_input_ty = borrowed_input.ty(&self.local_decls, tcx);\n             let borrowed_input_temp = self.temp(borrowed_input_ty, span);\n-            self.cfg.push_assign(block, source_info, &borrowed_input_temp, borrowed_input);\n+            self.cfg\n+                .push_assign(block, source_info, &borrowed_input_temp, borrowed_input);\n             Some(borrowed_input_temp)\n         } else {\n             None\n         };\n \n         let mut arm_blocks = ArmBlocks {\n-            blocks: arms.iter()\n-                        .map(|_| self.cfg.start_new_block())\n-                        .collect(),\n+            blocks: arms.iter().map(|_| self.cfg.start_new_block()).collect(),\n         };\n \n         // Get the arm bodies and their scopes, while declaring bindings.\n-        let arm_bodies: Vec<_> = arms.iter().map(|arm| {\n-            // BUG: use arm lint level\n-            let body = self.hir.mirror(arm.body.clone());\n-            let scope = self.declare_bindings(None, body.span,\n-                                              LintLevel::Inherited,\n-                                              &arm.patterns[..],\n-                                              ArmHasGuard(arm.guard.is_some()),\n-                                              Some((Some(&discriminant_place), discriminant_span)));\n-            (body, scope.unwrap_or(self.source_scope))\n-        }).collect();\n+        let arm_bodies: Vec<_> = arms.iter()\n+            .map(|arm| {\n+                // BUG: use arm lint level\n+                let body = self.hir.mirror(arm.body.clone());\n+                let scope = self.declare_bindings(\n+                    None,\n+                    body.span,\n+                    LintLevel::Inherited,\n+                    &arm.patterns[..],\n+                    ArmHasGuard(arm.guard.is_some()),\n+                    Some((Some(&discriminant_place), discriminant_span)),\n+                );\n+                (body, scope.unwrap_or(self.source_scope))\n+            })\n+            .collect();\n \n         // create binding start block for link them by false edges\n         let candidate_count = arms.iter().fold(0, |ac, c| ac + c.patterns.len());\n         let pre_binding_blocks: Vec<_> = (0..candidate_count + 1)\n-            .map(|_| self.cfg.start_new_block()).collect();\n+            .map(|_| self.cfg.start_new_block())\n+            .collect();\n \n         // assemble a list of candidates: there is one candidate per\n         // pattern, which means there may be more than one candidate\n         // *per arm*. These candidates are kept sorted such that the\n         // highest priority candidate comes first in the list.\n         // (i.e. same order as in source)\n \n-        let candidates: Vec<_> =\n-            arms.iter()\n-                .enumerate()\n-                .flat_map(|(arm_index, arm)| {\n-                    arm.patterns.iter().enumerate()\n-                        .map(move |(pat_index, pat)| {\n-                            (arm_index, pat_index, pat, arm.guard.clone())\n-                        })\n-                })\n-                .zip(pre_binding_blocks.iter().zip(pre_binding_blocks.iter().skip(1)))\n-                .map(|((arm_index, pat_index, pattern, guard),\n-                       (pre_binding_block, next_candidate_pre_binding_block))| {\n-\n-                    if let (true, Some(borrow_temp)) = (tcx.emit_read_for_match(),\n-                                                        borrowed_input_temp.clone()) {\n+        let candidates: Vec<_> = arms.iter()\n+            .enumerate()\n+            .flat_map(|(arm_index, arm)| {\n+                arm.patterns\n+                    .iter()\n+                    .enumerate()\n+                    .map(move |(pat_index, pat)| (arm_index, pat_index, pat, arm.guard.clone()))\n+            })\n+            .zip(\n+                pre_binding_blocks\n+                    .iter()\n+                    .zip(pre_binding_blocks.iter().skip(1)),\n+            )\n+            .map(\n+                |(\n+                    (arm_index, pat_index, pattern, guard),\n+                    (pre_binding_block, next_candidate_pre_binding_block),\n+                )| {\n+                    if let (true, Some(borrow_temp)) =\n+                        (tcx.emit_read_for_match(), borrowed_input_temp.clone())\n+                    {\n                         // inject a fake read of the borrowed input at\n                         // the start of each arm's pattern testing\n                         // code.\n@@ -137,10 +153,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         // the variant for an enum while you are in\n                         // the midst of matching on it.\n                         let pattern_source_info = self.source_info(pattern.span);\n-                        self.cfg.push(*pre_binding_block, Statement {\n-                            source_info: pattern_source_info,\n-                            kind: StatementKind::ReadForMatch(borrow_temp.clone()),\n-                        });\n+                        self.cfg.push(\n+                            *pre_binding_block,\n+                            Statement {\n+                                source_info: pattern_source_info,\n+                                kind: StatementKind::ReadForMatch(borrow_temp.clone()),\n+                            },\n+                        );\n                     }\n \n                     // One might ask: why not build up the match pair such that it\n@@ -175,12 +194,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         pre_binding_block: *pre_binding_block,\n                         next_candidate_pre_binding_block: *next_candidate_pre_binding_block,\n                     }\n-                })\n-                .collect();\n+                },\n+            )\n+            .collect();\n \n         let outer_source_info = self.source_info(span);\n-        self.cfg.terminate(*pre_binding_blocks.last().unwrap(),\n-                           outer_source_info, TerminatorKind::Unreachable);\n+        self.cfg.terminate(\n+            *pre_binding_blocks.last().unwrap(),\n+            outer_source_info,\n+            TerminatorKind::Unreachable,\n+        );\n \n         // this will generate code to test discriminant_place and\n         // branch to the appropriate arm block\n@@ -199,7 +222,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             otherwise.sort();\n             otherwise.dedup(); // variant switches can introduce duplicate target blocks\n             for block in otherwise {\n-                self.cfg.terminate(block, source_info, TerminatorKind::Unreachable);\n+                self.cfg\n+                    .terminate(block, source_info, TerminatorKind::Unreachable);\n             }\n         }\n \n@@ -212,26 +236,33 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // Re-enter the source scope we created the bindings in.\n             self.source_scope = source_scope;\n             unpack!(arm_block = self.into(destination, arm_block, body));\n-            self.cfg.terminate(arm_block, outer_source_info,\n-                               TerminatorKind::Goto { target: end_block });\n+            self.cfg.terminate(\n+                arm_block,\n+                outer_source_info,\n+                TerminatorKind::Goto { target: end_block },\n+            );\n         }\n         self.source_scope = outer_source_info.scope;\n \n         end_block.unit()\n     }\n \n-    pub fn expr_into_pattern(&mut self,\n-                             mut block: BasicBlock,\n-                             irrefutable_pat: Pattern<'tcx>,\n-                             initializer: ExprRef<'tcx>)\n-                             -> BlockAnd<()> {\n+    pub fn expr_into_pattern(\n+        &mut self,\n+        mut block: BasicBlock,\n+        irrefutable_pat: Pattern<'tcx>,\n+        initializer: ExprRef<'tcx>,\n+    ) -> BlockAnd<()> {\n         // optimize the case of `let x = ...`\n         match *irrefutable_pat.kind {\n-            PatternKind::Binding { mode: BindingMode::ByValue,\n-                                   var,\n-                                   subpattern: None, .. } => {\n-                let place = self.storage_live_binding(block, var, irrefutable_pat.span,\n-                                                      OutsideGuard);\n+            PatternKind::Binding {\n+                mode: BindingMode::ByValue,\n+                var,\n+                subpattern: None,\n+                ..\n+            } => {\n+                let place =\n+                    self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n                 unpack!(block = self.into(&place, block, initializer));\n                 self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n@@ -243,12 +274,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn place_into_pattern(&mut self,\n-                               mut block: BasicBlock,\n-                               irrefutable_pat: Pattern<'tcx>,\n-                               initializer: &Place<'tcx>,\n-                               set_match_place: bool)\n-                               -> BlockAnd<()> {\n+    pub fn place_into_pattern(\n+        &mut self,\n+        mut block: BasicBlock,\n+        irrefutable_pat: Pattern<'tcx>,\n+        initializer: &Place<'tcx>,\n+        set_match_place: bool,\n+    ) -> BlockAnd<()> {\n         // create a dummy candidate\n         let mut candidate = Candidate {\n             span: irrefutable_pat.span,\n@@ -261,18 +293,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             arm_index: 0,\n             pat_index: 0,\n             pre_binding_block: block,\n-            next_candidate_pre_binding_block: block\n+            next_candidate_pre_binding_block: block,\n         };\n \n         // Simplify the candidate. Since the pattern is irrefutable, this should\n         // always convert all match-pairs into bindings.\n         unpack!(block = self.simplify_candidate(block, &mut candidate));\n \n         if !candidate.match_pairs.is_empty() {\n-            span_bug!(candidate.match_pairs[0].pattern.span,\n-                      \"match pairs {:?} remaining after simplifying \\\n-                       irrefutable pattern\",\n-                      candidate.match_pairs);\n+            span_bug!(\n+                candidate.match_pairs[0].pattern.span,\n+                \"match pairs {:?} remaining after simplifying \\\n+                 irrefutable pattern\",\n+                candidate.match_pairs\n+            );\n         }\n \n         // for matches and function arguments, the place that is being matched\n@@ -283,9 +317,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             for binding in &candidate.bindings {\n                 let local = self.var_local_id(binding.var_id, OutsideGuard);\n \n-                if let Some(ClearCrossCrate::Set(BindingForm::Var(\n-                    VarBindingForm {opt_match_place: Some((ref mut match_place, _)), .. }\n-                ))) = self.local_decls[local].is_user_variable\n+                if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                    opt_match_place: Some((ref mut match_place, _)),\n+                    ..\n+                }))) = self.local_decls[local].is_user_variable\n                 {\n                     *match_place = Some(initializer.clone());\n                 } else {\n@@ -304,108 +339,136 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// scope for the bindings in these patterns, if such a scope had to be\n     /// created. NOTE: Declaring the bindings should always be done in their\n     /// drop scope.\n-    pub fn declare_bindings(&mut self,\n-                            mut visibility_scope: Option<SourceScope>,\n-                            scope_span: Span,\n-                            lint_level: LintLevel,\n-                            patterns: &[Pattern<'tcx>],\n-                            has_guard: ArmHasGuard,\n-                            opt_match_place: Option<(Option<&Place<'tcx>>, Span)>)\n-                            -> Option<SourceScope> {\n-        assert!(!(visibility_scope.is_some() && lint_level.is_explicit()),\n-                \"can't have both a visibility and a lint scope at the same time\");\n+    pub fn declare_bindings(\n+        &mut self,\n+        mut visibility_scope: Option<SourceScope>,\n+        scope_span: Span,\n+        lint_level: LintLevel,\n+        patterns: &[Pattern<'tcx>],\n+        has_guard: ArmHasGuard,\n+        opt_match_place: Option<(Option<&Place<'tcx>>, Span)>,\n+    ) -> Option<SourceScope> {\n+        assert!(\n+            !(visibility_scope.is_some() && lint_level.is_explicit()),\n+            \"can't have both a visibility and a lint scope at the same time\"\n+        );\n         let mut scope = self.source_scope;\n         let num_patterns = patterns.len();\n-        self.visit_bindings(&patterns[0], &mut |this, mutability, name, mode, var, span, ty| {\n-            if visibility_scope.is_none() {\n-                visibility_scope = Some(this.new_source_scope(scope_span,\n-                                                           LintLevel::Inherited,\n-                                                           None));\n-                // If we have lints, create a new source scope\n-                // that marks the lints for the locals. See the comment\n-                // on the `source_info` field for why this is needed.\n-                if lint_level.is_explicit() {\n-                    scope =\n-                        this.new_source_scope(scope_span, lint_level, None);\n+        self.visit_bindings(\n+            &patterns[0],\n+            &mut |this, mutability, name, mode, var, span, ty| {\n+                if visibility_scope.is_none() {\n+                    visibility_scope =\n+                        Some(this.new_source_scope(scope_span, LintLevel::Inherited, None));\n+                    // If we have lints, create a new source scope\n+                    // that marks the lints for the locals. See the comment\n+                    // on the `source_info` field for why this is needed.\n+                    if lint_level.is_explicit() {\n+                        scope = this.new_source_scope(scope_span, lint_level, None);\n+                    }\n                 }\n-            }\n-            let source_info = SourceInfo {\n-                span,\n-                scope,\n-            };\n-            let visibility_scope = visibility_scope.unwrap();\n-            this.declare_binding(source_info, visibility_scope, mutability, name, mode,\n-                                 num_patterns, var, ty, has_guard,\n-                                 opt_match_place.map(|(x, y)| (x.cloned(), y)),\n-                                 patterns[0].span);\n-        });\n+                let source_info = SourceInfo { span, scope };\n+                let visibility_scope = visibility_scope.unwrap();\n+                this.declare_binding(\n+                    source_info,\n+                    visibility_scope,\n+                    mutability,\n+                    name,\n+                    mode,\n+                    num_patterns,\n+                    var,\n+                    ty,\n+                    has_guard,\n+                    opt_match_place.map(|(x, y)| (x.cloned(), y)),\n+                    patterns[0].span,\n+                );\n+            },\n+        );\n         visibility_scope\n     }\n \n-    pub fn storage_live_binding(&mut self,\n-                                block: BasicBlock,\n-                                var: NodeId,\n-                                span: Span,\n-                                for_guard: ForGuard)\n-                            -> Place<'tcx>\n-    {\n+    pub fn storage_live_binding(\n+        &mut self,\n+        block: BasicBlock,\n+        var: NodeId,\n+        span: Span,\n+        for_guard: ForGuard,\n+    ) -> Place<'tcx> {\n         let local_id = self.var_local_id(var, for_guard);\n         let source_info = self.source_info(span);\n-        self.cfg.push(block, Statement {\n-            source_info,\n-            kind: StatementKind::StorageLive(local_id)\n-        });\n+        self.cfg.push(\n+            block,\n+            Statement {\n+                source_info,\n+                kind: StatementKind::StorageLive(local_id),\n+            },\n+        );\n         let place = Place::Local(local_id);\n         let var_ty = self.local_decls[local_id].ty;\n         let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n         let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n-        self.schedule_drop(\n-            span, region_scope, &place, var_ty,\n-            DropKind::Storage,\n-        );\n+        self.schedule_drop(span, region_scope, &place, var_ty, DropKind::Storage);\n         place\n     }\n \n-    pub fn schedule_drop_for_binding(&mut self,\n-                                     var: NodeId,\n-                                     span: Span,\n-                                     for_guard: ForGuard) {\n+    pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span, for_guard: ForGuard) {\n         let local_id = self.var_local_id(var, for_guard);\n         let var_ty = self.local_decls[local_id].ty;\n         let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n         let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n         self.schedule_drop(\n-            span, region_scope, &Place::Local(local_id), var_ty,\n+            span,\n+            region_scope,\n+            &Place::Local(local_id),\n+            var_ty,\n             DropKind::Value {\n                 cached_block: CachedBlock::default(),\n             },\n         );\n     }\n \n     pub fn visit_bindings<F>(&mut self, pattern: &Pattern<'tcx>, f: &mut F)\n-        where F: FnMut(&mut Self, Mutability, Name, BindingMode, NodeId, Span, Ty<'tcx>)\n+    where\n+        F: FnMut(&mut Self, Mutability, Name, BindingMode, NodeId, Span, Ty<'tcx>),\n     {\n         match *pattern.kind {\n-            PatternKind::Binding { mutability, name, mode, var, ty, ref subpattern, .. } => {\n+            PatternKind::Binding {\n+                mutability,\n+                name,\n+                mode,\n+                var,\n+                ty,\n+                ref subpattern,\n+                ..\n+            } => {\n                 f(self, mutability, name, mode, var, pattern.span, ty);\n                 if let Some(subpattern) = subpattern.as_ref() {\n                     self.visit_bindings(subpattern, f);\n                 }\n             }\n-            PatternKind::Array { ref prefix, ref slice, ref suffix } |\n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            PatternKind::Array {\n+                ref prefix,\n+                ref slice,\n+                ref suffix,\n+            }\n+            | PatternKind::Slice {\n+                ref prefix,\n+                ref slice,\n+                ref suffix,\n+            } => {\n                 for subpattern in prefix.iter().chain(slice).chain(suffix) {\n                     self.visit_bindings(subpattern, f);\n                 }\n             }\n-            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n-            }\n-            PatternKind::AscribeUserType { ref subpattern, .. } |\n-            PatternKind::Deref { ref subpattern } => {\n+            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {}\n+            PatternKind::AscribeUserType { ref subpattern, .. }\n+            | PatternKind::Deref { ref subpattern } => {\n                 self.visit_bindings(subpattern, f);\n             }\n-            PatternKind::Leaf { ref subpatterns } |\n-            PatternKind::Variant { ref subpatterns, .. } => {\n+            PatternKind::Leaf { ref subpatterns }\n+            | PatternKind::Variant {\n+                ref subpatterns, ..\n+            } => {\n                 for subpattern in subpatterns {\n                     self.visit_bindings(&subpattern.pattern, f);\n                 }\n@@ -414,15 +477,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n }\n \n-\n /// List of blocks for each arm (and potentially other metadata in the\n /// future).\n struct ArmBlocks {\n     blocks: Vec<BasicBlock>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Candidate<'pat, 'tcx:'pat> {\n+pub struct Candidate<'pat, 'tcx: 'pat> {\n     // span of the original pattern that gave rise to this candidate\n     span: Span,\n \n@@ -471,7 +533,7 @@ struct Ascription<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub struct MatchPair<'pat, 'tcx:'pat> {\n+pub struct MatchPair<'pat, 'tcx: 'pat> {\n     // this place...\n     place: Place<'tcx>,\n \n@@ -483,7 +545,7 @@ pub struct MatchPair<'pat, 'tcx:'pat> {\n     // the \"rest\" part of the pattern right now has type &[T] and\n     // as such, it requires an Rvalue::Slice to be generated.\n     // See RFC 495 / issue #23121 for the eventual (proper) solution.\n-    slice_len_checked: bool\n+    slice_len_checked: bool,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -552,15 +614,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// up the list of candidates and recurse with a non-exhaustive\n     /// list. This is important to keep the size of the generated code\n     /// under control. See `test_candidates` for more details.\n-    fn match_candidates<'pat>(&mut self,\n-                              span: Span,\n-                              arm_blocks: &mut ArmBlocks,\n-                              mut candidates: Vec<Candidate<'pat, 'tcx>>,\n-                              mut block: BasicBlock)\n-                              -> Vec<BasicBlock>\n-    {\n-        debug!(\"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n-               span, block, candidates);\n+    fn match_candidates<'pat>(\n+        &mut self,\n+        span: Span,\n+        arm_blocks: &mut ArmBlocks,\n+        mut candidates: Vec<Candidate<'pat, 'tcx>>,\n+        mut block: BasicBlock,\n+    ) -> Vec<BasicBlock> {\n+        debug!(\n+            \"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n+            span, block, candidates\n+        );\n \n         // Start by simplifying candidates. Once this process is\n         // complete, all the match pairs which remain require some\n@@ -573,13 +637,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // whether the higher priority candidates (and hence at\n         // the front of the vec) have satisfied all their match\n         // pairs.\n-        let fully_matched =\n-            candidates.iter().take_while(|c| c.match_pairs.is_empty()).count();\n-        debug!(\"match_candidates: {:?} candidates fully matched\", fully_matched);\n+        let fully_matched = candidates\n+            .iter()\n+            .take_while(|c| c.match_pairs.is_empty())\n+            .count();\n+        debug!(\n+            \"match_candidates: {:?} candidates fully matched\",\n+            fully_matched\n+        );\n         let mut unmatched_candidates = candidates.split_off(fully_matched);\n \n-        let fully_matched_with_guard =\n-            candidates.iter().take_while(|c| c.guard.is_some()).count();\n+        let fully_matched_with_guard = candidates.iter().take_while(|c| c.guard.is_some()).count();\n \n         let unreachable_candidates = if fully_matched_with_guard + 1 < candidates.len() {\n             candidates.split_off(fully_matched_with_guard + 1)\n@@ -596,20 +664,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // if None is returned, then any remaining candidates\n                 // are unreachable (at least not through this path).\n                 // Link them with false edges.\n-                debug!(\"match_candidates: add false edges for unreachable {:?} and unmatched {:?}\",\n-                       unreachable_candidates, unmatched_candidates);\n+                debug!(\n+                    \"match_candidates: add false edges for unreachable {:?} and unmatched {:?}\",\n+                    unreachable_candidates, unmatched_candidates\n+                );\n                 for candidate in unreachable_candidates {\n                     let source_info = self.source_info(candidate.span);\n                     let target = self.cfg.start_new_block();\n-                    if let Some(otherwise) = self.bind_and_guard_matched_candidate(target,\n-                                                                                   arm_blocks,\n-                                                                                   candidate) {\n-                        self.cfg.terminate(otherwise, source_info, TerminatorKind::Unreachable);\n+                    if let Some(otherwise) =\n+                        self.bind_and_guard_matched_candidate(target, arm_blocks, candidate)\n+                    {\n+                        self.cfg\n+                            .terminate(otherwise, source_info, TerminatorKind::Unreachable);\n                     }\n                 }\n \n                 if unmatched_candidates.is_empty() {\n-                    return vec![]\n+                    return vec![];\n                 } else {\n                     let target = self.cfg.start_new_block();\n                     return self.match_candidates(span, arm_blocks, unmatched_candidates, target);\n@@ -642,11 +713,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         self.match_candidates(span, arm_blocks, untested_candidates, join_block)\n     }\n \n-    fn join_otherwise_blocks(&mut self,\n-                             span: Span,\n-                             mut otherwise: Vec<BasicBlock>)\n-                             -> BasicBlock\n-    {\n+    fn join_otherwise_blocks(&mut self, span: Span, mut otherwise: Vec<BasicBlock>) -> BasicBlock {\n         let source_info = self.source_info(span);\n         otherwise.sort();\n         otherwise.dedup(); // variant switches can introduce duplicate target blocks\n@@ -655,8 +722,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         } else {\n             let join_block = self.cfg.start_new_block();\n             for block in otherwise {\n-                self.cfg.terminate(block, source_info,\n-                                   TerminatorKind::Goto { target: join_block });\n+                self.cfg.terminate(\n+                    block,\n+                    source_info,\n+                    TerminatorKind::Goto { target: join_block },\n+                );\n             }\n             join_block\n         }\n@@ -774,13 +844,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// In addition to avoiding exponential-time blowups, this algorithm\n     /// also has nice property that each guard and arm is only generated\n     /// once.\n-    fn test_candidates<'pat>(&mut self,\n-                             span: Span,\n-                             arm_blocks: &mut ArmBlocks,\n-                             candidates: &[Candidate<'pat, 'tcx>],\n-                             block: BasicBlock)\n-                             -> (Vec<BasicBlock>, usize)\n-    {\n+    fn test_candidates<'pat>(\n+        &mut self,\n+        span: Span,\n+        arm_blocks: &mut ArmBlocks,\n+        candidates: &[Candidate<'pat, 'tcx>],\n+        block: BasicBlock,\n+    ) -> (Vec<BasicBlock>, usize) {\n         // extract the match-pair from the highest priority candidate\n         let match_pair = &candidates.first().unwrap().match_pairs[0];\n         let mut test = self.test(match_pair);\n@@ -790,66 +860,75 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // may want to add cases based on the candidates that are\n         // available\n         match test.kind {\n-            TestKind::SwitchInt { switch_ty, ref mut options, ref mut indices } => {\n+            TestKind::SwitchInt {\n+                switch_ty,\n+                ref mut options,\n+                ref mut indices,\n+            } => {\n                 for candidate in candidates.iter() {\n-                    if !self.add_cases_to_switch(&match_pair.place,\n-                                                 candidate,\n-                                                 switch_ty,\n-                                                 options,\n-                                                 indices) {\n+                    if !self.add_cases_to_switch(\n+                        &match_pair.place,\n+                        candidate,\n+                        switch_ty,\n+                        options,\n+                        indices,\n+                    ) {\n                         break;\n                     }\n                 }\n             }\n-            TestKind::Switch { adt_def: _, ref mut variants} => {\n+            TestKind::Switch {\n+                adt_def: _,\n+                ref mut variants,\n+            } => {\n                 for candidate in candidates.iter() {\n-                    if !self.add_variants_to_switch(&match_pair.place,\n-                                                    candidate,\n-                                                    variants) {\n+                    if !self.add_variants_to_switch(&match_pair.place, candidate, variants) {\n                         break;\n                     }\n                 }\n             }\n-            _ => { }\n+            _ => {}\n         }\n \n         // perform the test, branching to one of N blocks. For each of\n         // those N possible outcomes, create a (initially empty)\n         // vector of candidates. Those are the candidates that still\n         // apply if the test has that particular outcome.\n-        debug!(\"match_candidates: test={:?} match_pair={:?}\", test, match_pair);\n+        debug!(\n+            \"match_candidates: test={:?} match_pair={:?}\",\n+            test, match_pair\n+        );\n         let target_blocks = self.perform_test(block, &match_pair.place, &test);\n         let mut target_candidates: Vec<_> = (0..target_blocks.len()).map(|_| vec![]).collect();\n \n         // Sort the candidates into the appropriate vector in\n         // `target_candidates`. Note that at some point we may\n         // encounter a candidate where the test is not relevant; at\n         // that point, we stop sorting.\n-        let tested_candidates =\n-            candidates.iter()\n-                      .take_while(|c| self.sort_candidate(&match_pair.place,\n-                                                          &test,\n-                                                          c,\n-                                                          &mut target_candidates))\n-                      .count();\n+        let tested_candidates = candidates\n+            .iter()\n+            .take_while(|c| {\n+                self.sort_candidate(&match_pair.place, &test, c, &mut target_candidates)\n+            })\n+            .count();\n         assert!(tested_candidates > 0); // at least the last candidate ought to be tested\n         debug!(\"tested_candidates: {}\", tested_candidates);\n-        debug!(\"untested_candidates: {}\", candidates.len() - tested_candidates);\n+        debug!(\n+            \"untested_candidates: {}\",\n+            candidates.len() - tested_candidates\n+        );\n \n         // For each outcome of test, process the candidates that still\n         // apply. Collect a list of blocks where control flow will\n         // branch if one of the `target_candidate` sets is not\n         // exhaustive.\n-        let otherwise: Vec<_> =\n-            target_blocks.into_iter()\n-                         .zip(target_candidates)\n-                         .flat_map(|(target_block, target_candidates)| {\n-                             self.match_candidates(span,\n-                                                   arm_blocks,\n-                                                   target_candidates,\n-                                                   target_block)\n-                         })\n-                         .collect();\n+        let otherwise: Vec<_> = target_blocks\n+            .into_iter()\n+            .zip(target_candidates)\n+            .flat_map(|(target_block, target_candidates)| {\n+                self.match_candidates(span, arm_blocks, target_candidates, target_block)\n+            })\n+            .collect();\n \n         (otherwise, tested_candidates)\n     }\n@@ -866,30 +945,39 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// bindings, further tests would be a use-after-move (which would\n     /// in turn be detected by the borrowck code that runs on the\n     /// MIR).\n-    fn bind_and_guard_matched_candidate<'pat>(&mut self,\n-                                              mut block: BasicBlock,\n-                                              arm_blocks: &mut ArmBlocks,\n-                                              candidate: Candidate<'pat, 'tcx>)\n-                                              -> Option<BasicBlock> {\n-        debug!(\"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n-               block, candidate);\n+    fn bind_and_guard_matched_candidate<'pat>(\n+        &mut self,\n+        mut block: BasicBlock,\n+        arm_blocks: &mut ArmBlocks,\n+        candidate: Candidate<'pat, 'tcx>,\n+    ) -> Option<BasicBlock> {\n+        debug!(\n+            \"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n+            block, candidate\n+        );\n \n         debug_assert!(candidate.match_pairs.is_empty());\n \n         let arm_block = arm_blocks.blocks[candidate.arm_index];\n         let candidate_source_info = self.source_info(candidate.span);\n \n-        self.cfg.terminate(block, candidate_source_info,\n-                               TerminatorKind::Goto { target: candidate.pre_binding_block });\n+        self.cfg.terminate(\n+            block,\n+            candidate_source_info,\n+            TerminatorKind::Goto {\n+                target: candidate.pre_binding_block,\n+            },\n+        );\n \n         block = self.cfg.start_new_block();\n-        self.cfg.terminate(candidate.pre_binding_block, candidate_source_info,\n-                               TerminatorKind::FalseEdges {\n-                                   real_target: block,\n-                                   imaginary_targets:\n-                                       vec![candidate.next_candidate_pre_binding_block],\n-                               });\n-\n+        self.cfg.terminate(\n+            candidate.pre_binding_block,\n+            candidate_source_info,\n+            TerminatorKind::FalseEdges {\n+                real_target: block,\n+                imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n+            },\n+        );\n \n         // rust-lang/rust#27282: The `autoref` business deserves some\n         // explanation here.\n@@ -973,13 +1061,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         //      match input itself; it is up to us to create a place\n         //      holding a `&` or `&mut` that we can then borrow).\n \n-        let autoref = self.hir.tcx().all_pat_vars_are_implicit_refs_within_guards();\n+        let autoref = self.hir\n+            .tcx()\n+            .all_pat_vars_are_implicit_refs_within_guards();\n         if let Some(guard) = candidate.guard {\n             if autoref {\n                 self.bind_matched_candidate_for_guard(\n-                    block, candidate.pat_index, &candidate.bindings);\n+                    block,\n+                    candidate.pat_index,\n+                    &candidate.bindings,\n+                );\n                 let guard_frame = GuardFrame {\n-                    locals: candidate.bindings.iter()\n+                    locals: candidate\n+                        .bindings\n+                        .iter()\n                         .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n                         .collect(),\n                 };\n@@ -998,7 +1093,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let cond = unpack!(block = self.as_local_operand(block, guard));\n             if autoref {\n                 let guard_frame = self.guard_context.pop().unwrap();\n-                debug!(\"Exiting guard building context with locals: {:?}\", guard_frame);\n+                debug!(\n+                    \"Exiting guard building context with locals: {:?}\",\n+                    guard_frame\n+                );\n             }\n \n             let false_edge_block = self.cfg.start_new_block();\n@@ -1030,45 +1128,59 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             //\n             // and that is clearly not correct.\n             let post_guard_block = self.cfg.start_new_block();\n-            self.cfg.terminate(block, source_info,\n-                               TerminatorKind::if_(self.hir.tcx(), cond, post_guard_block,\n-                                                   false_edge_block));\n+            self.cfg.terminate(\n+                block,\n+                source_info,\n+                TerminatorKind::if_(self.hir.tcx(), cond, post_guard_block, false_edge_block),\n+            );\n \n             if autoref {\n                 self.bind_matched_candidate_for_arm_body(post_guard_block, &candidate.bindings);\n             }\n \n-            self.cfg.terminate(post_guard_block, source_info,\n-                               TerminatorKind::Goto { target: arm_block });\n+            self.cfg.terminate(\n+                post_guard_block,\n+                source_info,\n+                TerminatorKind::Goto { target: arm_block },\n+            );\n \n             let otherwise = self.cfg.start_new_block();\n \n-            self.cfg.terminate(false_edge_block, source_info,\n-                               TerminatorKind::FalseEdges {\n-                                   real_target: otherwise,\n-                                   imaginary_targets:\n-                                       vec![candidate.next_candidate_pre_binding_block],\n-                               });\n+            self.cfg.terminate(\n+                false_edge_block,\n+                source_info,\n+                TerminatorKind::FalseEdges {\n+                    real_target: otherwise,\n+                    imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n+                },\n+            );\n             Some(otherwise)\n         } else {\n             // (Here, it is not too early to bind the matched\n             // candidate on `block`, because there is no guard result\n             // that we have to inspect before we bind them.)\n             self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n-            self.cfg.terminate(block, candidate_source_info,\n-                               TerminatorKind::Goto { target: arm_block });\n+            self.cfg.terminate(\n+                block,\n+                candidate_source_info,\n+                TerminatorKind::Goto { target: arm_block },\n+            );\n             None\n         }\n     }\n \n     // Only called when all_pat_vars_are_implicit_refs_within_guards,\n     // and thus all code/comments assume we are in that context.\n-    fn bind_matched_candidate_for_guard(&mut self,\n-                                        block: BasicBlock,\n-                                        pat_index: usize,\n-                                        bindings: &[Binding<'tcx>]) {\n-        debug!(\"bind_matched_candidate_for_guard(block={:?}, pat_index={:?}, bindings={:?})\",\n-               block, pat_index, bindings);\n+    fn bind_matched_candidate_for_guard(\n+        &mut self,\n+        block: BasicBlock,\n+        pat_index: usize,\n+        bindings: &[Binding<'tcx>],\n+    ) {\n+        debug!(\n+            \"bind_matched_candidate_for_guard(block={:?}, pat_index={:?}, bindings={:?})\",\n+            block, pat_index, bindings\n+        );\n \n         // Assign each of the bindings. Since we are binding for a\n         // guard expression, this will never trigger moves out of the\n@@ -1081,16 +1193,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // a reference R: &T pointing to the location matched by\n             // the pattern, and every occurrence of P within a guard\n             // denotes *R.\n-            let ref_for_guard = self.storage_live_binding(\n-                block, binding.var_id, binding.span, RefWithinGuard);\n+            let ref_for_guard =\n+                self.storage_live_binding(block, binding.var_id, binding.span, RefWithinGuard);\n             // Question: Why schedule drops if bindings are all\n             // shared-&'s?  Answer: Because schedule_drop_for_binding\n             // also emits StorageDead's for those locals.\n             self.schedule_drop_for_binding(binding.var_id, binding.span, RefWithinGuard);\n             match binding.binding_mode {\n                 BindingMode::ByValue => {\n                     let rvalue = Rvalue::Ref(re_empty, BorrowKind::Shared, binding.source.clone());\n-                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n+                    self.cfg\n+                        .push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n                 BindingMode::ByRef(region, borrow_kind) => {\n                     // Tricky business: For `ref id` and `ref mut id`\n@@ -1107,9 +1220,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // used by the arm body itself. This eases\n                     // observing two-phase borrow restrictions.\n                     let val_for_guard = self.storage_live_binding(\n-                        block, binding.var_id, binding.span, ValWithinGuard(pat_index));\n+                        block,\n+                        binding.var_id,\n+                        binding.span,\n+                        ValWithinGuard(pat_index),\n+                    );\n                     self.schedule_drop_for_binding(\n-                        binding.var_id, binding.span, ValWithinGuard(pat_index));\n+                        binding.var_id,\n+                        binding.span,\n+                        ValWithinGuard(pat_index),\n+                    );\n \n                     // rust-lang/rust#27282: We reuse the two-phase\n                     // borrow infrastructure so that the mutable\n@@ -1119,27 +1239,36 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // discussion on rust-lang/rust#49870.\n                     let borrow_kind = match borrow_kind {\n                         BorrowKind::Shared | BorrowKind::Unique => borrow_kind,\n-                        BorrowKind::Mut { .. } => BorrowKind::Mut { allow_two_phase_borrow: true },\n+                        BorrowKind::Mut { .. } => BorrowKind::Mut {\n+                            allow_two_phase_borrow: true,\n+                        },\n                     };\n                     let rvalue = Rvalue::Ref(region, borrow_kind, binding.source.clone());\n-                    self.cfg.push_assign(block, source_info, &val_for_guard, rvalue);\n+                    self.cfg\n+                        .push_assign(block, source_info, &val_for_guard, rvalue);\n                     let rvalue = Rvalue::Ref(region, BorrowKind::Shared, val_for_guard);\n-                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n+                    self.cfg\n+                        .push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n             }\n         }\n     }\n \n-    fn bind_matched_candidate_for_arm_body(&mut self,\n-                                           block: BasicBlock,\n-                                           bindings: &[Binding<'tcx>]) {\n-        debug!(\"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}\", block, bindings);\n+    fn bind_matched_candidate_for_arm_body(\n+        &mut self,\n+        block: BasicBlock,\n+        bindings: &[Binding<'tcx>],\n+    ) {\n+        debug!(\n+            \"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}\",\n+            block, bindings\n+        );\n \n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n             let source_info = self.source_info(binding.span);\n-            let local = self.storage_live_binding(block, binding.var_id, binding.span,\n-                                                  OutsideGuard);\n+            let local =\n+                self.storage_live_binding(block, binding.var_id, binding.span, OutsideGuard);\n             self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n             let rvalue = match binding.binding_mode {\n                 BindingMode::ByValue => {\n@@ -1168,22 +1297,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// parts of the matched data, and we want them to be distinct\n     /// temps in order to simplify checks performed by our internal\n     /// leveraging of two-phase borrows).\n-    fn declare_binding(&mut self,\n-                       source_info: SourceInfo,\n-                       visibility_scope: SourceScope,\n-                       mutability: Mutability,\n-                       name: Name,\n-                       mode: BindingMode,\n-                       num_patterns: usize,\n-                       var_id: NodeId,\n-                       var_ty: Ty<'tcx>,\n-                       has_guard: ArmHasGuard,\n-                       opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n-                       pat_span: Span)\n-    {\n-        debug!(\"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n-                visibility_scope={:?}, source_info={:?})\",\n-               var_id, name, mode, var_ty, visibility_scope, source_info);\n+    fn declare_binding(\n+        &mut self,\n+        source_info: SourceInfo,\n+        visibility_scope: SourceScope,\n+        mutability: Mutability,\n+        name: Name,\n+        mode: BindingMode,\n+        num_patterns: usize,\n+        var_id: NodeId,\n+        var_ty: Ty<'tcx>,\n+        has_guard: ArmHasGuard,\n+        opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n+        pat_span: Span,\n+    ) {\n+        debug!(\n+            \"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n+             visibility_scope={:?}, source_info={:?})\",\n+            var_id, name, mode, var_ty, visibility_scope, source_info\n+        );\n \n         let tcx = self.hir.tcx();\n         let binding_mode = match mode {\n@@ -1231,7 +1363,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 internal: false,\n                 is_user_variable: Some(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n-            LocalsForNode::ForGuard { vals_for_guard, ref_for_guard, for_arm_body }\n+            LocalsForNode::ForGuard {\n+                vals_for_guard,\n+                ref_for_guard,\n+                for_arm_body,\n+            }\n         } else {\n             LocalsForNode::One(for_arm_body)\n         };"}]}