{"sha": "a1c5c798c7b8d7b556144ed3ba286936fb8ba639", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYzVjNzk4YzdiOGQ3YjU1NjE0NGVkM2JhMjg2OTM2ZmI4YmE2Mzk=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-17T08:18:02Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-19T05:58:28Z"}, "message": "debuginfo: Added some documenting comments to debuginfo.rs", "tree": {"sha": "6bc5855488254a207b8c97ea571bde1e2efe43ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bc5855488254a207b8c97ea571bde1e2efe43ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1c5c798c7b8d7b556144ed3ba286936fb8ba639", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1c5c798c7b8d7b556144ed3ba286936fb8ba639", "html_url": "https://github.com/rust-lang/rust/commit/a1c5c798c7b8d7b556144ed3ba286936fb8ba639", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1c5c798c7b8d7b556144ed3ba286936fb8ba639/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9baeab695ffb0483ce6bef872f5d85c636dd04a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9baeab695ffb0483ce6bef872f5d85c636dd04a", "html_url": "https://github.com/rust-lang/rust/commit/e9baeab695ffb0483ce6bef872f5d85c636dd04a"}], "stats": {"total": 53, "additions": 33, "deletions": 20}, "files": [{"sha": "cb76d27b8b0d32e41fedc0da10db8954d430278b", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a1c5c798c7b8d7b556144ed3ba286936fb8ba639/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c5c798c7b8d7b556144ed3ba286936fb8ba639/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a1c5c798c7b8d7b556144ed3ba286936fb8ba639", "patch": "@@ -27,11 +27,18 @@ where possible. This will hopefully ease the adaption of this module to future L\n \n The public API of the module is a set of functions that will insert the correct metadata into the\n LLVM IR when called with the right parameters. The module is thus driven from an outside client with\n-functions like `debuginfo::create_local_var_metadata(bcx: block, local: @ast::local)`.\n+functions like `debuginfo::local_var_metadata(bcx: block, local: &ast::local)`.\n \n-Internally the module will try to reuse already created metadata by utilizing a cache. All private\n-state used by the module is stored within a DebugContext struct, which in turn is contained in the\n-CrateContext.\n+Internally the module will try to reuse already created metadata by utilizing a cache. The way to\n+get a shared metadata node when needed is thus to just call the corresponding function in this\n+module:\n+\n+    let file_metadata = file_metadata(crate_context, path);\n+\n+The function will take care of probing the cache for an existing node for that exact file path.\n+\n+All private state used by the module is stored within a DebugContext struct, which in turn is\n+contained in the CrateContext.\n \n \n This file consists of three conceptual sections:\n@@ -149,7 +156,7 @@ pub fn create_local_var_metadata(bcx: block, local: @ast::local) -> DIVariable {\n \n     let context = match bcx.parent {\n         None => create_function_metadata(bcx.fcx),\n-        Some(_) => block_metadata(bcx)\n+        Some(_) => lexical_block_metadata(bcx)\n     };\n \n     let var_metadata = do as_c_str(name) |name| {\n@@ -178,7 +185,7 @@ pub fn create_local_var_metadata(bcx: block, local: @ast::local) -> DIVariable {\n         }\n     };\n \n-    set_debug_location(cx, block_metadata(bcx), loc.line, loc.col.to_uint());\n+    set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_metadata, bcx.llbb);\n         llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n@@ -236,7 +243,7 @@ pub fn create_argument_metadata(bcx: block, arg: &ast::arg, span: span) -> Optio\n             };\n \n             let llptr = fcx.llargs.get_copy(&arg.id);\n-            set_debug_location(cx, block_metadata(bcx), loc.line, loc.col.to_uint());\n+            set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n             unsafe {\n                 let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n                         DIB(cx), llptr, var_metadata, bcx.llbb);\n@@ -259,7 +266,7 @@ pub fn update_source_pos(bcx: block, span: span) {\n     }\n     debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n     let loc = span_start(bcx.ccx(), span);\n-    set_debug_location(bcx.ccx(), block_metadata(bcx), loc.line, loc.col.to_uint())\n+    set_debug_location(bcx.ccx(), lexical_block_metadata(bcx), loc.line, loc.col.to_uint())\n }\n \n /// Creates debug information for the given function.\n@@ -418,44 +425,50 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n     return file_metadata;\n }\n \n-fn block_metadata(bcx: block) -> DILexicalBlock {\n-    let mut bcx = bcx;\n+/// Get or create the lexical block metadata node for the given LLVM basic block.\n+fn lexical_block_metadata(bcx: block) -> DILexicalBlock {\n     let cx = bcx.ccx();\n+    let mut bcx = bcx;\n \n+    // Search up the tree of basic blocks until we find one that knows the containing lexical block.\n     while bcx.node_info.is_none() {\n         match bcx.parent {\n-          Some(b) => bcx = b,\n-          None => fail!()\n+            Some(b) => bcx = b,\n+            None => cx.sess.bug(\"debuginfo: Could not find lexical block for LLVM basic block.\")\n         }\n     }\n+\n     let span = bcx.node_info.get().span;\n     let id = bcx.node_info.get().id;\n \n+    // Check whether we already have a cache entry for this node id\n     match dbg_cx(cx).created_blocks.find(&id) {\n         Some(block) => return *block,\n         None => ()\n     }\n \n-    debug!(\"block_metadata: %s\", bcx.sess().codemap.span_to_str(span));\n+    debug!(\"lexical_block_metadata: %s\", bcx.sess().codemap.span_to_str(span));\n \n     let parent = match bcx.parent {\n         None => create_function_metadata(bcx.fcx),\n-        Some(b) => block_metadata(b)\n+        Some(b) => lexical_block_metadata(b)\n     };\n-    let cx = bcx.ccx();\n+\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let block_metadata = unsafe {\n+    let lexical_block_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateLexicalBlock(\n             DIB(cx),\n-            parent, file_metadata,\n-            loc.line as c_uint, loc.col.to_uint() as c_uint)\n+            parent,\n+            file_metadata,\n+            loc.line as c_uint,\n+            loc.col.to_uint() as c_uint)\n     };\n \n-    dbg_cx(cx).created_blocks.insert(id, block_metadata);\n+    dbg_cx(cx).created_blocks.insert(id, lexical_block_metadata);\n \n-    return block_metadata;\n+    return lexical_block_metadata;\n }\n \n fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {"}]}