{"sha": "ae7e55c1dd801c60092205ec8890179e10a47814", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlN2U1NWMxZGQ4MDFjNjAwOTIyMDVlYzg4OTAxNzllMTBhNDc4MTQ=", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-03-21T12:13:34Z"}, "committer": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-03-21T12:13:34Z"}, "message": "clippy::complexity simplifications related to Iterators", "tree": {"sha": "7e55e7a0c144610d55509b3e28bde0edf0953e39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e55e7a0c144610d55509b3e28bde0edf0953e39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae7e55c1dd801c60092205ec8890179e10a47814", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae7e55c1dd801c60092205ec8890179e10a47814", "html_url": "https://github.com/rust-lang/rust/commit/ae7e55c1dd801c60092205ec8890179e10a47814", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae7e55c1dd801c60092205ec8890179e10a47814/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd407a9882250cbbb0897faba08e7d5ef80a4862", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd407a9882250cbbb0897faba08e7d5ef80a4862", "html_url": "https://github.com/rust-lang/rust/commit/bd407a9882250cbbb0897faba08e7d5ef80a4862"}], "stats": {"total": 140, "additions": 62, "deletions": 78}, "files": [{"sha": "44eaeffb9e6f10cbb62ff554c53a74f17217fc39", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=ae7e55c1dd801c60092205ec8890179e10a47814", "patch": "@@ -213,7 +213,7 @@ impl Crate {\n                 Some(TokenTree::Leaf(Leaf::Literal(Literal{ref text, ..}))) => Some(text),\n                 _ => None\n             }\n-        }).flat_map(|t| t).next();\n+        }).flatten().next();\n \n         doc_url.map(|s| s.trim_matches('\"').trim_end_matches('/').to_owned() + \"/\")\n     }"}, {"sha": "52a2bce9b10aad3a18892e1863cbe4b20e9af1ed", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=ae7e55c1dd801c60092205ec8890179e10a47814", "patch": "@@ -638,7 +638,7 @@ fn collect_attrs(\n     owner: &dyn ast::AttrsOwner,\n ) -> impl Iterator<Item = Either<ast::Attr, ast::Comment>> {\n     let (inner_attrs, inner_docs) = inner_attributes(owner.syntax())\n-        .map_or((None, None), |(attrs, docs)| ((Some(attrs), Some(docs))));\n+        .map_or((None, None), |(attrs, docs)| (Some(attrs), Some(docs)));\n \n     let outer_attrs = owner.attrs().filter(|attr| attr.excl_token().is_none());\n     let attrs = outer_attrs"}, {"sha": "ec491648fe9a33ab1c01e03c992206fdd933d726", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=ae7e55c1dd801c60092205ec8890179e10a47814", "patch": "@@ -38,7 +38,7 @@ impl<'a> InferenceContext<'a> {\n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n         let (pre, post) = match ellipsis {\n             Some(idx) => subpats.split_at(idx),\n-            None => (&subpats[..], &[][..]),\n+            None => (subpats, &[][..]),\n         };\n         let post_idx_offset = field_tys.iter().count() - post.len();\n "}, {"sha": "5201ce587a8570ee7ef851246680cabf10266bc6", "filename": "crates/ide/src/extend_selection.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fextend_selection.rs?ref=ae7e55c1dd801c60092205ec8890179e10a47814", "patch": "@@ -263,11 +263,10 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n     ) -> Option<SyntaxToken> {\n         node.siblings_with_tokens(dir)\n             .skip(1)\n-            .skip_while(|node| match node {\n-                NodeOrToken::Node(_) => false,\n-                NodeOrToken::Token(it) => is_single_line_ws(it),\n+            .find(|node| match node {\n+                NodeOrToken::Node(_) => true,\n+                NodeOrToken::Token(it) => !is_single_line_ws(it),\n             })\n-            .next()\n             .and_then(|it| it.into_token())\n             .filter(|node| node.kind() == delimiter_kind)\n     }"}, {"sha": "9dc3ee28fd168b93aba734d1d6db7c2db499426d", "filename": "crates/ide_assists/src/handlers/convert_comment_block.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs?ref=ae7e55c1dd801c60092205ec8890179e10a47814", "patch": "@@ -1,5 +1,4 @@\n use itertools::Itertools;\n-use std::convert::identity;\n use syntax::{\n     ast::{\n         self,\n@@ -140,7 +139,7 @@ fn relevant_line_comments(comment: &ast::Comment) -> Vec<Comment> {\n         .filter(|s| !skippable(s))\n         .map(|not| not.into_token().and_then(Comment::cast).filter(same_prefix))\n         .take_while(|opt_com| opt_com.is_some())\n-        .filter_map(identity)\n+        .flatten()\n         .skip(1); // skip the first element so we don't duplicate it in next_comments\n \n     let next_comments = comment\n@@ -149,7 +148,7 @@ fn relevant_line_comments(comment: &ast::Comment) -> Vec<Comment> {\n         .filter(|s| !skippable(s))\n         .map(|not| not.into_token().and_then(Comment::cast).filter(same_prefix))\n         .take_while(|opt_com| opt_com.is_some())\n-        .filter_map(identity);\n+        .flatten();\n \n     let mut comments: Vec<_> = prev_comments.collect();\n     comments.reverse();"}, {"sha": "98389e4f7b1a990533b7137de3d691fbcb38d765", "filename": "crates/ide_assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=ae7e55c1dd801c60092205ec8890179e10a47814", "patch": "@@ -136,18 +136,13 @@ impl Refs {\n                 .into_iter()\n                 .filter(|r| {\n                     if let Def::ModuleDef(ModuleDef::Trait(tr)) = r.def {\n-                        if tr\n-                            .items(ctx.db())\n-                            .into_iter()\n-                            .find(|ai| {\n-                                if let AssocItem::Function(f) = *ai {\n-                                    Def::ModuleDef(ModuleDef::Function(f)).is_referenced_in(ctx)\n-                                } else {\n-                                    false\n-                                }\n-                            })\n-                            .is_some()\n-                        {\n+                        if tr.items(ctx.db()).into_iter().any(|ai| {\n+                            if let AssocItem::Function(f) = ai {\n+                                Def::ModuleDef(ModuleDef::Function(f)).is_referenced_in(ctx)\n+                            } else {\n+                                false\n+                            }\n+                        }) {\n                             return true;\n                         }\n                     }"}, {"sha": "f976e73adc30b9d95c545104e7ec10e7068a8969", "filename": "crates/ide_assists/src/handlers/reorder_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_impl.rs?ref=ae7e55c1dd801c60092205ec8890179e10a47814", "patch": "@@ -95,7 +95,7 @@ fn compute_method_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<FxHashM\n                 _ => None,\n             })\n             .enumerate()\n-            .map(|(idx, func)| ((func.name(ctx.db()).to_string(), idx)))\n+            .map(|(idx, func)| (func.name(ctx.db()).to_string(), idx))\n             .collect(),\n     )\n }"}, {"sha": "d82564381d19def76985b2d002f73419a945eb1a", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=ae7e55c1dd801c60092205ec8890179e10a47814", "patch": "@@ -71,7 +71,7 @@ fn test_has_block_expr_parent() {\n }\n \n pub(crate) fn has_bind_pat_parent(element: SyntaxElement) -> bool {\n-    element.ancestors().find(|it| it.kind() == IDENT_PAT).is_some()\n+    element.ancestors().any(|it| it.kind() == IDENT_PAT)\n }\n #[test]\n fn test_has_bind_pat_parent() {"}, {"sha": "5e757e70191a1142254db6eb83ba303a08336693", "filename": "crates/ide_ssr/src/parsing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fide_ssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fide_ssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fparsing.rs?ref=ae7e55c1dd801c60092205ec8890179e10a47814", "patch": "@@ -67,7 +67,7 @@ impl ParsedRule {\n     ) -> Result<Vec<ParsedRule>, SsrError> {\n         let raw_pattern = pattern.as_rust_code();\n         let raw_template = template.map(|t| t.as_rust_code());\n-        let raw_template = raw_template.as_ref().map(|s| s.as_str());\n+        let raw_template = raw_template.as_deref();\n         let mut builder = RuleBuilder {\n             placeholders_by_stand_in: pattern.placeholders_by_stand_in(),\n             rules: Vec::new(),"}, {"sha": "8951f3813759497656d9469f70a0a5452516185b", "filename": "crates/mbe/src/tests/expand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests%2Fexpand.rs?ref=ae7e55c1dd801c60092205ec8890179e10a47814", "patch": "@@ -1225,8 +1225,7 @@ macro_rules! m {\n     )\n     .expand_statements(r#\"m!(C(\"0\"))\"#)\n     .descendants()\n-    .find(|token| token.kind() == ERROR)\n-    .is_some());\n+    .any(|token| token.kind() == ERROR));\n }\n \n #[test]"}, {"sha": "f7050be4e7f0c5fe5b6d103ed132b577335054f9", "filename": "crates/project_model/src/build_data.rs", "status": "modified", "additions": 42, "deletions": 49, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs?ref=ae7e55c1dd801c60092205ec8890179e10a47814", "patch": "@@ -137,60 +137,53 @@ fn collect_from_workspace(\n     let stdout = BufReader::new(child_stdout);\n \n     let mut res = BuildDataMap::default();\n-    for message in cargo_metadata::Message::parse_stream(stdout) {\n-        if let Ok(message) = message {\n-            match message {\n-                Message::BuildScriptExecuted(BuildScript {\n-                    package_id,\n-                    out_dir,\n-                    cfgs,\n-                    env,\n-                    ..\n-                }) => {\n-                    let cfgs = {\n-                        let mut acc = Vec::new();\n-                        for cfg in cfgs {\n-                            match cfg.parse::<CfgFlag>() {\n-                                Ok(it) => acc.push(it),\n-                                Err(err) => {\n-                                    anyhow::bail!(\"invalid cfg from cargo-metadata: {}\", err)\n-                                }\n-                            };\n-                        }\n-                        acc\n-                    };\n-                    let res = res.entry(package_id.repr.clone()).or_default();\n-                    // cargo_metadata crate returns default (empty) path for\n-                    // older cargos, which is not absolute, so work around that.\n-                    if !out_dir.as_str().is_empty() {\n-                        let out_dir = AbsPathBuf::assert(PathBuf::from(out_dir.into_os_string()));\n-                        res.out_dir = Some(out_dir);\n-                        res.cfgs = cfgs;\n+    for message in cargo_metadata::Message::parse_stream(stdout).flatten() {\n+        match message {\n+            Message::BuildScriptExecuted(BuildScript {\n+                package_id, out_dir, cfgs, env, ..\n+            }) => {\n+                let cfgs = {\n+                    let mut acc = Vec::new();\n+                    for cfg in cfgs {\n+                        match cfg.parse::<CfgFlag>() {\n+                            Ok(it) => acc.push(it),\n+                            Err(err) => {\n+                                anyhow::bail!(\"invalid cfg from cargo-metadata: {}\", err)\n+                            }\n+                        };\n                     }\n-\n-                    res.envs = env;\n+                    acc\n+                };\n+                let res = res.entry(package_id.repr.clone()).or_default();\n+                // cargo_metadata crate returns default (empty) path for\n+                // older cargos, which is not absolute, so work around that.\n+                if !out_dir.as_str().is_empty() {\n+                    let out_dir = AbsPathBuf::assert(PathBuf::from(out_dir.into_os_string()));\n+                    res.out_dir = Some(out_dir);\n+                    res.cfgs = cfgs;\n                 }\n-                Message::CompilerArtifact(message) => {\n-                    progress(format!(\"metadata {}\", message.target.name));\n-\n-                    if message.target.kind.contains(&\"proc-macro\".to_string()) {\n-                        let package_id = message.package_id;\n-                        // Skip rmeta file\n-                        if let Some(filename) = message.filenames.iter().find(|name| is_dylib(name))\n-                        {\n-                            let filename = AbsPathBuf::assert(PathBuf::from(&filename));\n-                            let res = res.entry(package_id.repr.clone()).or_default();\n-                            res.proc_macro_dylib_path = Some(filename);\n-                        }\n+\n+                res.envs = env;\n+            }\n+            Message::CompilerArtifact(message) => {\n+                progress(format!(\"metadata {}\", message.target.name));\n+\n+                if message.target.kind.contains(&\"proc-macro\".to_string()) {\n+                    let package_id = message.package_id;\n+                    // Skip rmeta file\n+                    if let Some(filename) = message.filenames.iter().find(|name| is_dylib(name)) {\n+                        let filename = AbsPathBuf::assert(PathBuf::from(&filename));\n+                        let res = res.entry(package_id.repr.clone()).or_default();\n+                        res.proc_macro_dylib_path = Some(filename);\n                     }\n                 }\n-                Message::CompilerMessage(message) => {\n-                    progress(message.target.name.clone());\n-                }\n-                Message::BuildFinished(_) => {}\n-                Message::TextLine(_) => {}\n-                _ => {}\n             }\n+            Message::CompilerMessage(message) => {\n+                progress(message.target.name.clone());\n+            }\n+            Message::BuildFinished(_) => {}\n+            Message::TextLine(_) => {}\n+            _ => {}\n         }\n     }\n "}, {"sha": "365de4463163c3b2d59b553b07764013bdd67bf8", "filename": "crates/syntax/src/ast/edit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e55c1dd801c60092205ec8890179e10a47814/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs?ref=ae7e55c1dd801c60092205ec8890179e10a47814", "patch": "@@ -461,8 +461,7 @@ impl ast::MatchArmList {\n         let end = if let Some(comma) = start\n             .siblings_with_tokens(Direction::Next)\n             .skip(1)\n-            .skip_while(|it| it.kind().is_trivia())\n-            .next()\n+            .find(|it| !it.kind().is_trivia())\n             .filter(|it| it.kind() == T![,])\n         {\n             comma"}]}