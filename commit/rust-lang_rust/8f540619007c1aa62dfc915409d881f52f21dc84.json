{"sha": "8f540619007c1aa62dfc915409d881f52f21dc84", "node_id": "C_kwDOAAsO6NoAKDhmNTQwNjE5MDA3YzFhYTYyZGZjOTE1NDA5ZDg4MWY1MmYyMWRjODQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-19T06:26:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-19T06:26:07Z"}, "message": "Auto merge of #91871 - camelid:urlpartsbuilder, r=GuillaumeGomez\n\nrustdoc: Add `UrlPartsBuilder`\n\nThis is a type for efficiently and easily constructing the part of a URL\nafter the domain: `nightly/core/str/struct.Bytes.html`.\n\nIt allows simplifying some code and avoiding some allocations in the\n`href_*` functions.\n\nIt will also allow making `Cache.paths` et al. use `Symbol` without\nhaving to allocate `String`s in the `href_*` functions. `String`s would\nbe necessary otherwise because `Symbol::as_str()` returns `SymbolStr`,\nwhose `Deref<Target = str>` impl requires the `str` to not outlive it.\nThis is the primary motivation for the addition of `UrlPartsBuilder`.", "tree": {"sha": "b61df12b68f6ffd3fe561d158590ce1eabc7a4d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b61df12b68f6ffd3fe561d158590ce1eabc7a4d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f540619007c1aa62dfc915409d881f52f21dc84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f540619007c1aa62dfc915409d881f52f21dc84", "html_url": "https://github.com/rust-lang/rust/commit/8f540619007c1aa62dfc915409d881f52f21dc84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f540619007c1aa62dfc915409d881f52f21dc84/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6cffe41b59feaab5fb92bb320e60586202c9950", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6cffe41b59feaab5fb92bb320e60586202c9950", "html_url": "https://github.com/rust-lang/rust/commit/d6cffe41b59feaab5fb92bb320e60586202c9950"}, {"sha": "4bac09f58fdc3d847b3231dcf64b2d02f4eac403", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bac09f58fdc3d847b3231dcf64b2d02f4eac403", "html_url": "https://github.com/rust-lang/rust/commit/4bac09f58fdc3d847b3231dcf64b2d02f4eac403"}], "stats": {"total": 209, "additions": 192, "deletions": 17}, "files": [{"sha": "f6788e94431dc045173887346494926347a2f885", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f540619007c1aa62dfc915409d881f52f21dc84/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f540619007c1aa62dfc915409d881f52f21dc84/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=8f540619007c1aa62dfc915409d881f52f21dc84", "patch": "@@ -27,6 +27,8 @@ use crate::html::escape::Escape;\n use crate::html::render::cache::ExternalLocation;\n use crate::html::render::Context;\n \n+use super::url_parts_builder::UrlPartsBuilder;\n+\n crate trait Print {\n     fn print(self, buffer: &mut Buffer);\n }\n@@ -544,9 +546,9 @@ crate fn href_with_root_path(\n                         ExternalLocation::Remote(ref s) => {\n                             is_remote = true;\n                             let s = s.trim_end_matches('/');\n-                            let mut s = vec![s];\n-                            s.extend(module_fqp[..].iter().map(String::as_str));\n-                            s\n+                            let mut builder = UrlPartsBuilder::singleton(s);\n+                            builder.extend(module_fqp.iter().map(String::as_str));\n+                            builder\n                         }\n                         ExternalLocation::Local => href_relative_parts(module_fqp, relative_to),\n                         ExternalLocation::Unknown => return Err(HrefError::DocumentationNotBuilt),\n@@ -560,22 +562,21 @@ crate fn href_with_root_path(\n     if !is_remote {\n         if let Some(root_path) = root_path {\n             let root = root_path.trim_end_matches('/');\n-            url_parts.insert(0, root);\n+            url_parts.push_front(root);\n         }\n     }\n     debug!(?url_parts);\n     let last = &fqp.last().unwrap()[..];\n-    let filename;\n     match shortty {\n         ItemType::Module => {\n             url_parts.push(\"index.html\");\n         }\n         _ => {\n-            filename = format!(\"{}.{}.html\", shortty.as_str(), last);\n+            let filename = format!(\"{}.{}.html\", shortty.as_str(), last);\n             url_parts.push(&filename);\n         }\n     }\n-    Ok((url_parts.join(\"/\"), shortty, fqp.to_vec()))\n+    Ok((url_parts.finish(), shortty, fqp.to_vec()))\n }\n \n crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<String>), HrefError> {\n@@ -585,7 +586,7 @@ crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<Str\n /// Both paths should only be modules.\n /// This is because modules get their own directories; that is, `std::vec` and `std::vec::Vec` will\n /// both need `../iter/trait.Iterator.html` to get at the iterator trait.\n-crate fn href_relative_parts<'a>(fqp: &'a [String], relative_to_fqp: &'a [String]) -> Vec<&'a str> {\n+crate fn href_relative_parts(fqp: &[String], relative_to_fqp: &[String]) -> UrlPartsBuilder {\n     for (i, (f, r)) in fqp.iter().zip(relative_to_fqp.iter()).enumerate() {\n         // e.g. linking to std::iter from std::vec (`dissimilar_part_count` will be 1)\n         if f != r {\n@@ -603,7 +604,7 @@ crate fn href_relative_parts<'a>(fqp: &'a [String], relative_to_fqp: &'a [String\n         iter::repeat(\"..\").take(dissimilar_part_count).collect()\n     // linking to the same module\n     } else {\n-        Vec::new()\n+        UrlPartsBuilder::new()\n     }\n }\n "}, {"sha": "e1bbc784fd1cd6c611ac2060cfed05f74dfd8f2d", "filename": "src/librustdoc/html/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f540619007c1aa62dfc915409d881f52f21dc84/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f540619007c1aa62dfc915409d881f52f21dc84/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmod.rs?ref=8f540619007c1aa62dfc915409d881f52f21dc84", "patch": "@@ -9,6 +9,7 @@ crate mod render;\n crate mod sources;\n crate mod static_files;\n crate mod toc;\n+mod url_parts_builder;\n \n #[cfg(test)]\n mod tests;"}, {"sha": "dee9f5e5038a827242dc48b4332fcd51cdaec604", "filename": "src/librustdoc/html/tests.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f540619007c1aa62dfc915409d881f52f21dc84/src%2Flibrustdoc%2Fhtml%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f540619007c1aa62dfc915409d881f52f21dc84/src%2Flibrustdoc%2Fhtml%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftests.rs?ref=8f540619007c1aa62dfc915409d881f52f21dc84", "patch": "@@ -1,44 +1,44 @@\n use crate::html::format::href_relative_parts;\n \n-fn assert_relative_path(expected: &[&str], relative_to_fqp: &[&str], fqp: &[&str]) {\n+fn assert_relative_path(expected: &str, relative_to_fqp: &[&str], fqp: &[&str]) {\n     let relative_to_fqp: Vec<String> = relative_to_fqp.iter().copied().map(String::from).collect();\n     let fqp: Vec<String> = fqp.iter().copied().map(String::from).collect();\n-    assert_eq!(expected, href_relative_parts(&fqp, &relative_to_fqp));\n+    assert_eq!(expected, href_relative_parts(&fqp, &relative_to_fqp).finish());\n }\n \n #[test]\n fn href_relative_parts_basic() {\n     let relative_to_fqp = &[\"std\", \"vec\"];\n     let fqp = &[\"std\", \"iter\"];\n-    assert_relative_path(&[\"..\", \"iter\"], relative_to_fqp, fqp);\n+    assert_relative_path(\"../iter\", relative_to_fqp, fqp);\n }\n #[test]\n fn href_relative_parts_parent_module() {\n     let relative_to_fqp = &[\"std\", \"vec\"];\n     let fqp = &[\"std\"];\n-    assert_relative_path(&[\"..\"], relative_to_fqp, fqp);\n+    assert_relative_path(\"..\", relative_to_fqp, fqp);\n }\n #[test]\n fn href_relative_parts_different_crate() {\n     let relative_to_fqp = &[\"std\", \"vec\"];\n     let fqp = &[\"core\", \"iter\"];\n-    assert_relative_path(&[\"..\", \"..\", \"core\", \"iter\"], relative_to_fqp, fqp);\n+    assert_relative_path(\"../../core/iter\", relative_to_fqp, fqp);\n }\n #[test]\n fn href_relative_parts_same_module() {\n     let relative_to_fqp = &[\"std\", \"vec\"];\n     let fqp = &[\"std\", \"vec\"];\n-    assert_relative_path(&[], relative_to_fqp, fqp);\n+    assert_relative_path(\"\", relative_to_fqp, fqp);\n }\n #[test]\n fn href_relative_parts_child_module() {\n     let relative_to_fqp = &[\"std\"];\n     let fqp = &[\"std\", \"vec\"];\n-    assert_relative_path(&[\"vec\"], relative_to_fqp, fqp);\n+    assert_relative_path(\"vec\", relative_to_fqp, fqp);\n }\n #[test]\n fn href_relative_parts_root() {\n     let relative_to_fqp = &[];\n     let fqp = &[\"std\"];\n-    assert_relative_path(&[\"std\"], relative_to_fqp, fqp);\n+    assert_relative_path(\"std\", relative_to_fqp, fqp);\n }"}, {"sha": "918d5e6bd1b3a3da274d920dfd089f3906b6b866", "filename": "src/librustdoc/html/url_parts_builder.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/8f540619007c1aa62dfc915409d881f52f21dc84/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f540619007c1aa62dfc915409d881f52f21dc84/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs?ref=8f540619007c1aa62dfc915409d881f52f21dc84", "patch": "@@ -0,0 +1,119 @@\n+/// A builder that allows efficiently and easily constructing the part of a URL\n+/// after the domain: `nightly/core/str/struct.Bytes.html`.\n+///\n+/// This type is a wrapper around the final `String` buffer,\n+/// but its API is like that of a `Vec` of URL components.\n+#[derive(Debug)]\n+crate struct UrlPartsBuilder {\n+    buf: String,\n+}\n+\n+impl UrlPartsBuilder {\n+    /// Create an empty buffer.\n+    crate fn new() -> Self {\n+        Self { buf: String::new() }\n+    }\n+\n+    /// Create an empty buffer with capacity for the specified number of bytes.\n+    fn with_capacity_bytes(count: usize) -> Self {\n+        Self { buf: String::with_capacity(count) }\n+    }\n+\n+    /// Create a buffer with one URL component.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```ignore (private-type)\n+    /// let builder = UrlPartsBuilder::singleton(\"core\");\n+    /// assert_eq!(builder.finish(), \"core\");\n+    /// ```\n+    ///\n+    /// Adding more components afterward.\n+    ///\n+    /// ```ignore (private-type)\n+    /// let mut builder = UrlPartsBuilder::singleton(\"core\");\n+    /// builder.push(\"str\");\n+    /// builder.push_front(\"nightly\");\n+    /// assert_eq!(builder.finish(), \"nightly/core/str\");\n+    /// ```\n+    crate fn singleton(part: &str) -> Self {\n+        Self { buf: part.to_owned() }\n+    }\n+\n+    /// Push a component onto the buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```ignore (private-type)\n+    /// let mut builder = UrlPartsBuilder::new();\n+    /// builder.push(\"core\");\n+    /// builder.push(\"str\");\n+    /// builder.push(\"struct.Bytes.html\");\n+    /// assert_eq!(builder.finish(), \"core/str/struct.Bytes.html\");\n+    /// ```\n+    crate fn push(&mut self, part: &str) {\n+        if !self.buf.is_empty() {\n+            self.buf.push('/');\n+        }\n+        self.buf.push_str(part);\n+    }\n+\n+    /// Push a component onto the front of the buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```ignore (private-type)\n+    /// let mut builder = UrlPartsBuilder::new();\n+    /// builder.push(\"core\");\n+    /// builder.push(\"str\");\n+    /// builder.push_front(\"nightly\");\n+    /// builder.push(\"struct.Bytes.html\");\n+    /// assert_eq!(builder.finish(), \"nightly/core/str/struct.Bytes.html\");\n+    /// ```\n+    crate fn push_front(&mut self, part: &str) {\n+        let is_empty = self.buf.is_empty();\n+        self.buf.reserve(part.len() + if !is_empty { 1 } else { 0 });\n+        self.buf.insert_str(0, part);\n+        if !is_empty {\n+            self.buf.insert(part.len(), '/');\n+        }\n+    }\n+\n+    /// Get the final `String` buffer.\n+    crate fn finish(self) -> String {\n+        self.buf\n+    }\n+}\n+\n+/// This is just a guess at the average length of a URL part,\n+/// used for [`String::with_capacity`] calls in the [`FromIterator`]\n+/// and [`Extend`] impls.\n+///\n+/// This is intentionally on the lower end to avoid overallocating.\n+const AVG_PART_LENGTH: usize = 5;\n+\n+impl<'a> FromIterator<&'a str> for UrlPartsBuilder {\n+    fn from_iter<T: IntoIterator<Item = &'a str>>(iter: T) -> Self {\n+        let iter = iter.into_iter();\n+        let mut builder = Self::with_capacity_bytes(AVG_PART_LENGTH * iter.size_hint().0);\n+        iter.for_each(|part| builder.push(part));\n+        builder\n+    }\n+}\n+\n+impl<'a> Extend<&'a str> for UrlPartsBuilder {\n+    fn extend<T: IntoIterator<Item = &'a str>>(&mut self, iter: T) {\n+        let iter = iter.into_iter();\n+        self.buf.reserve(AVG_PART_LENGTH * iter.size_hint().0);\n+        iter.for_each(|part| self.push(part));\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "43338c95010a0cb01538d4d7161d4d6cf2e23df7", "filename": "src/librustdoc/html/url_parts_builder/tests.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8f540619007c1aa62dfc915409d881f52f21dc84/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f540619007c1aa62dfc915409d881f52f21dc84/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder%2Ftests.rs?ref=8f540619007c1aa62dfc915409d881f52f21dc84", "patch": "@@ -0,0 +1,54 @@\n+use super::*;\n+\n+fn t(builder: UrlPartsBuilder, expect: &str) {\n+    assert_eq!(builder.finish(), expect);\n+}\n+\n+#[test]\n+fn empty() {\n+    t(UrlPartsBuilder::new(), \"\");\n+}\n+\n+#[test]\n+fn singleton() {\n+    t(UrlPartsBuilder::singleton(\"index.html\"), \"index.html\");\n+}\n+\n+#[test]\n+fn push_several() {\n+    let mut builder = UrlPartsBuilder::new();\n+    builder.push(\"core\");\n+    builder.push(\"str\");\n+    builder.push(\"struct.Bytes.html\");\n+    t(builder, \"core/str/struct.Bytes.html\");\n+}\n+\n+#[test]\n+fn push_front_empty() {\n+    let mut builder = UrlPartsBuilder::new();\n+    builder.push_front(\"page.html\");\n+    t(builder, \"page.html\");\n+}\n+\n+#[test]\n+fn push_front_non_empty() {\n+    let mut builder = UrlPartsBuilder::new();\n+    builder.push(\"core\");\n+    builder.push(\"str\");\n+    builder.push(\"struct.Bytes.html\");\n+    builder.push_front(\"nightly\");\n+    t(builder, \"nightly/core/str/struct.Bytes.html\");\n+}\n+\n+#[test]\n+fn collect() {\n+    t([\"core\", \"str\"].into_iter().collect(), \"core/str\");\n+    t([\"core\", \"str\", \"struct.Bytes.html\"].into_iter().collect(), \"core/str/struct.Bytes.html\");\n+}\n+\n+#[test]\n+fn extend() {\n+    let mut builder = UrlPartsBuilder::singleton(\"core\");\n+    builder.extend([\"str\", \"struct.Bytes.html\"]);\n+    t(builder, \"core/str/struct.Bytes.html\");\n+}"}]}