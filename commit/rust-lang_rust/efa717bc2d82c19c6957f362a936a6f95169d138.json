{"sha": "efa717bc2d82c19c6957f362a936a6f95169d138", "node_id": "C_kwDOAAsO6NoAKGVmYTcxN2JjMmQ4MmMxOWM2OTU3ZjM2MmE5MzZhNmY5NTE2OWQxMzg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-19T04:56:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-19T04:56:14Z"}, "message": "Auto merge of #101924 - jackh726:revert-static-hrtb-error, r=compiler-errors\n\nRe-add HRTB implied static bug note\n\nr? `@compiler-errors` since you reviewed it previously\n\nI deleted a `normalize` call and forgot about it. Whoops.", "tree": {"sha": "778ebbb8bde0ba44631943673392f159fc79a26a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/778ebbb8bde0ba44631943673392f159fc79a26a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efa717bc2d82c19c6957f362a936a6f95169d138", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efa717bc2d82c19c6957f362a936a6f95169d138", "html_url": "https://github.com/rust-lang/rust/commit/efa717bc2d82c19c6957f362a936a6f95169d138", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efa717bc2d82c19c6957f362a936a6f95169d138/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8e12cc8bf0de646234524924f39c85d9f3c7c37", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e12cc8bf0de646234524924f39c85d9f3c7c37", "html_url": "https://github.com/rust-lang/rust/commit/c8e12cc8bf0de646234524924f39c85d9f3c7c37"}, {"sha": "e7ca6e1b47ce31ad544cd8f0eb7e5cd47b325e63", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7ca6e1b47ce31ad544cd8f0eb7e5cd47b325e63", "html_url": "https://github.com/rust-lang/rust/commit/e7ca6e1b47ce31ad544cd8f0eb7e5cd47b325e63"}], "stats": {"total": 610, "additions": 500, "deletions": 110}, "files": [{"sha": "df04128135b8986c2a976af99df433447e1f1af2", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -21,10 +21,7 @@ pub(crate) struct OutlivesConstraintSet<'tcx> {\n \n impl<'tcx> OutlivesConstraintSet<'tcx> {\n     pub(crate) fn push(&mut self, constraint: OutlivesConstraint<'tcx>) {\n-        debug!(\n-            \"OutlivesConstraintSet::push({:?}: {:?} @ {:?}\",\n-            constraint.sup, constraint.sub, constraint.locations\n-        );\n+        debug!(\"OutlivesConstraintSet::push({:?})\", constraint);\n         if constraint.sup == constraint.sub {\n             // 'a: 'a is pretty uninteresting\n             return;"}, {"sha": "1c01e78abd422ed097b440c49ce32bb56a54863b", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::{self, RegionVid, TyCtxt};\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{sym, DesugaringKind, Span};\n \n-use crate::region_infer::BlameConstraint;\n+use crate::region_infer::{BlameConstraint, ExtraConstraintInfo};\n use crate::{\n     borrow_set::BorrowData, nll::ConstraintDescription, region_infer::Cause, MirBorrowckCtxt,\n     WriteKind,\n@@ -38,6 +38,7 @@ pub(crate) enum BorrowExplanation<'tcx> {\n         span: Span,\n         region_name: RegionName,\n         opt_place_desc: Option<String>,\n+        extra_info: Vec<ExtraConstraintInfo>,\n     },\n     Unexplained,\n }\n@@ -243,6 +244,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                 ref region_name,\n                 ref opt_place_desc,\n                 from_closure: _,\n+                ref extra_info,\n             } => {\n                 region_name.highlight_region_name(err);\n \n@@ -268,6 +270,14 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                     );\n                 };\n \n+                for extra in extra_info {\n+                    match extra {\n+                        ExtraConstraintInfo::PlaceholderFromPredicate(span) => {\n+                            err.span_note(*span, format!(\"due to current limitations in the borrow checker, this implies a `'static` lifetime\"));\n+                        }\n+                    }\n+                }\n+\n                 self.add_lifetime_bound_suggestion_to_diagnostic(err, &category, span, region_name);\n             }\n             _ => {}\n@@ -309,16 +319,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n-    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>) {\n-        let BlameConstraint { category, from_closure, cause, variance_info: _ } = self\n-            .regioncx\n-            .best_blame_constraint(borrow_region, NllRegionVariableOrigin::FreeRegion, |r| {\n-                self.regioncx.provides_universal_region(r, borrow_region, outlived_region)\n-            });\n+    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>, Vec<ExtraConstraintInfo>) {\n+        let (blame_constraint, extra_info) = self.regioncx.best_blame_constraint(\n+            borrow_region,\n+            NllRegionVariableOrigin::FreeRegion,\n+            |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n+        );\n+        let BlameConstraint { category, from_closure, cause, .. } = blame_constraint;\n \n         let outlived_fr_name = self.give_region_a_name(outlived_region);\n \n-        (category, from_closure, cause.span, outlived_fr_name)\n+        (category, from_closure, cause.span, outlived_fr_name, extra_info)\n     }\n \n     /// Returns structured explanation for *why* the borrow contains the\n@@ -390,7 +401,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             None => {\n                 if let Some(region) = self.to_error_region_vid(borrow_region_vid) {\n-                    let (category, from_closure, span, region_name) =\n+                    let (category, from_closure, span, region_name, extra_info) =\n                         self.free_region_constraint_info(borrow_region_vid, region);\n                     if let Some(region_name) = region_name {\n                         let opt_place_desc = self.describe_place(borrow.borrowed_place.as_ref());\n@@ -400,6 +411,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             span,\n                             region_name,\n                             opt_place_desc,\n+                            extra_info,\n                         }\n                     } else {\n                         debug!(\"Could not generate a region name\");"}, {"sha": "34be2874fcb738d527c9f64923eb2aa7921f006e", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -31,7 +31,7 @@ use crate::session_diagnostics::{\n };\n \n use super::{OutlivesSuggestionBuilder, RegionName};\n-use crate::region_infer::BlameConstraint;\n+use crate::region_infer::{BlameConstraint, ExtraConstraintInfo};\n use crate::{\n     nll::ConstraintDescription,\n     region_infer::{values::RegionElement, TypeTest},\n@@ -354,10 +354,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"report_region_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let BlameConstraint { category, cause, variance_info, from_closure: _ } =\n+        let (blame_constraint, extra_info) =\n             self.regioncx.best_blame_constraint(fr, fr_origin, |r| {\n                 self.regioncx.provides_universal_region(r, fr, outlived_fr)\n             });\n+        let BlameConstraint { category, cause, variance_info, .. } = blame_constraint;\n \n         debug!(\"report_region_error: category={:?} {:?} {:?}\", category, cause, variance_info);\n \n@@ -466,6 +467,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n         }\n \n+        for extra in extra_info {\n+            match extra {\n+                ExtraConstraintInfo::PlaceholderFromPredicate(span) => {\n+                    diag.span_note(span, format!(\"due to current limitations in the borrow checker, this implies a `'static` lifetime\"));\n+                }\n+            }\n+        }\n+\n         self.buffer_error(diag);\n     }\n \n@@ -557,6 +566,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// LL |     ref_obj(x)\n     ///    |     ^^^^^^^^^^ `x` escapes the function body here\n     /// ```\n+    #[instrument(level = \"debug\", skip(self))]\n     fn report_escaping_data_error(\n         &self,\n         errci: &ErrorConstraintInfo<'tcx>,"}, {"sha": "244e6e3422d83d0dcdee8ff0b7214727e530cb1c", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -245,6 +245,11 @@ enum Trace<'tcx> {\n     NotVisited,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum ExtraConstraintInfo {\n+    PlaceholderFromPredicate(Span),\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -1818,10 +1823,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr1_origin: NllRegionVariableOrigin,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory<'tcx>, ObligationCause<'tcx>) {\n-        let BlameConstraint { category, cause, .. } =\n-            self.best_blame_constraint(fr1, fr1_origin, |r| {\n-                self.provides_universal_region(r, fr1, fr2)\n-            });\n+        let BlameConstraint { category, cause, .. } = self\n+            .best_blame_constraint(fr1, fr1_origin, |r| self.provides_universal_region(r, fr1, fr2))\n+            .0;\n         (category, cause)\n     }\n \n@@ -2010,7 +2014,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         from_region: RegionVid,\n         from_region_origin: NllRegionVariableOrigin,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> BlameConstraint<'tcx> {\n+    ) -> (BlameConstraint<'tcx>, Vec<ExtraConstraintInfo>) {\n         // Find all paths\n         let (path, target_region) =\n             self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n@@ -2026,6 +2030,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .collect::<Vec<_>>()\n         );\n \n+        let mut extra_info = vec![];\n+        for constraint in path.iter() {\n+            let outlived = constraint.sub;\n+            let Some(origin) = self.var_infos.get(outlived) else { continue; };\n+            let RegionVariableOrigin::Nll(NllRegionVariableOrigin::Placeholder(p)) = origin.origin else { continue; };\n+            debug!(?constraint, ?p);\n+            let ConstraintCategory::Predicate(span) = constraint.category else { continue; };\n+            extra_info.push(ExtraConstraintInfo::PlaceholderFromPredicate(span));\n+            // We only want to point to one\n+            break;\n+        }\n+\n         // We try to avoid reporting a `ConstraintCategory::Predicate` as our best constraint.\n         // Instead, we use it to produce an improved `ObligationCauseCode`.\n         // FIXME - determine what we should do if we encounter multiple `ConstraintCategory::Predicate`\n@@ -2073,6 +2089,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     from_closure,\n                     cause: ObligationCause::new(span, CRATE_HIR_ID, cause_code),\n                     variance_info: constraint.variance_info,\n+                    outlives_constraint: *constraint,\n                 }\n             })\n             .collect();\n@@ -2174,7 +2191,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let best_choice =\n             if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n \n-        debug!(?best_choice, ?blame_source);\n+        debug!(?best_choice, ?blame_source, ?extra_info);\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n@@ -2183,7 +2200,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 {\n                     // The return expression is being influenced by the return type being\n                     // impl Trait, point at the return type and not the return expr.\n-                    return next.clone();\n+                    return (next.clone(), extra_info);\n                 }\n             }\n \n@@ -2203,7 +2220,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n             }\n \n-            return categorized_path[i].clone();\n+            return (categorized_path[i].clone(), extra_info);\n         }\n \n         // If that search fails, that is.. unusual. Maybe everything\n@@ -2213,7 +2230,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         categorized_path.sort_by(|p0, p1| p0.category.cmp(&p1.category));\n         debug!(\"sorted_path={:#?}\", categorized_path);\n \n-        categorized_path.remove(0)\n+        (categorized_path.remove(0), extra_info)\n     }\n \n     pub(crate) fn universe_info(&self, universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n@@ -2295,7 +2312,13 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n                              outlives_requirement={:?}\",\n                             region, outlived_region, outlives_requirement,\n                         );\n-                        ty::Binder::dummy(ty::OutlivesPredicate(region.into(), outlived_region))\n+                        (\n+                            ty::Binder::dummy(ty::OutlivesPredicate(\n+                                region.into(),\n+                                outlived_region,\n+                            )),\n+                            ConstraintCategory::BoringNoLocation,\n+                        )\n                     }\n \n                     ClosureOutlivesSubject::Ty(ty) => {\n@@ -2305,7 +2328,10 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n                              outlives_requirement={:?}\",\n                             ty, outlived_region, outlives_requirement,\n                         );\n-                        ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region))\n+                        (\n+                            ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region)),\n+                            ConstraintCategory::BoringNoLocation,\n+                        )\n                     }\n                 }\n             })\n@@ -2319,4 +2345,5 @@ pub struct BlameConstraint<'tcx> {\n     pub from_closure: bool,\n     pub cause: ObligationCause<'tcx>,\n     pub variance_info: ty::VarianceDiagInfo<'tcx>,\n+    pub outlives_constraint: OutlivesConstraint<'tcx>,\n }"}, {"sha": "9271a2f4dc718f345fb32bad3814386fda2b2738", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// constraints should occur within this method so that those\n     /// constraints can be properly localized!**\n     #[instrument(skip(self, op), level = \"trace\")]\n-    pub(super) fn fully_perform_op<R, Op>(\n+    pub(super) fn fully_perform_op<R: fmt::Debug, Op>(\n         &mut self,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n@@ -39,6 +39,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n         let TypeOpOutput { output, constraints, error_info } = op.fully_perform(self.infcx)?;\n \n+        debug!(?output, ?constraints);\n+\n         if let Some(data) = constraints {\n             self.push_region_constraints(locations, category, data);\n         }\n@@ -102,6 +104,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         );\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn normalize_and_prove_instantiated_predicates(\n         &mut self,\n         // Keep this parameter for now, in case we start using\n@@ -116,8 +119,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             .zip(instantiated_predicates.spans.into_iter())\n         {\n             debug!(?predicate);\n-            let predicate = self.normalize(predicate, locations);\n-            self.prove_predicate(predicate, locations, ConstraintCategory::Predicate(span));\n+            let category = ConstraintCategory::Predicate(span);\n+            let predicate = self.normalize_with_category(predicate, locations, category);\n+            self.prove_predicate(predicate, locations, category);\n         }\n     }\n \n@@ -153,15 +157,27 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         })\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n     pub(super) fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T\n+    where\n+        T: type_op::normalize::Normalizable<'tcx> + fmt::Display + Copy + 'tcx,\n+    {\n+        self.normalize_with_category(value, location, ConstraintCategory::Boring)\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(super) fn normalize_with_category<T>(\n+        &mut self,\n+        value: T,\n+        location: impl NormalizeLocation,\n+        category: ConstraintCategory<'tcx>,\n+    ) -> T\n     where\n         T: type_op::normalize::Normalizable<'tcx> + fmt::Display + Copy + 'tcx,\n     {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n             location.to_locations(),\n-            ConstraintCategory::Boring,\n+            category,\n             param_env.and(type_op::normalize::Normalize::new(value)),\n         )\n         .unwrap_or_else(|NoSolution| {"}, {"sha": "71eae0583cb483870b4a612d8442a36436602310", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n+    fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n         debug!(\"generate: constraints at: {:#?}\", self.locations);\n \n         // Extract out various useful fields we'll need below.\n@@ -98,15 +98,18 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         // region constraints like `for<'a> 'a: 'b`. At some point\n         // when we move to universes, we will, and this assertion\n         // will start to fail.\n-        let ty::OutlivesPredicate(k1, r2) = query_constraint.no_bound_vars().unwrap_or_else(|| {\n-            bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n-        });\n+        let ty::OutlivesPredicate(k1, r2) =\n+            query_constraint.0.no_bound_vars().unwrap_or_else(|| {\n+                bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n+            });\n+\n+        let constraint_category = query_constraint.1;\n \n         match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n                 let r1_vid = self.to_region_vid(r1);\n                 let r2_vid = self.to_region_vid(r2);\n-                self.add_outlives(r1_vid, r2_vid);\n+                self.add_outlives(r1_vid, r2_vid, constraint_category);\n             }\n \n             GenericArgKind::Type(t1) => {\n@@ -121,7 +124,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n                     Some(implicit_region_bound),\n                     param_env,\n                 )\n-                .type_must_outlive(origin, t1, r2);\n+                .type_must_outlive(origin, t1, r2, constraint_category);\n             }\n \n             GenericArgKind::Const(_) => {\n@@ -168,10 +171,19 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n     }\n \n-    fn add_outlives(&mut self, sup: ty::RegionVid, sub: ty::RegionVid) {\n+    fn add_outlives(\n+        &mut self,\n+        sup: ty::RegionVid,\n+        sub: ty::RegionVid,\n+        category: ConstraintCategory<'tcx>,\n+    ) {\n+        let category = match self.category {\n+            ConstraintCategory::Boring | ConstraintCategory::BoringNoLocation => category,\n+            _ => self.category,\n+        };\n         self.constraints.outlives_constraints.push(OutlivesConstraint {\n             locations: self.locations,\n-            category: self.category,\n+            category,\n             span: self.span,\n             sub,\n             sup,\n@@ -191,10 +203,11 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         _origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n+        constraint_category: ConstraintCategory<'tcx>,\n     ) {\n         let b = self.to_region_vid(b);\n         let a = self.to_region_vid(a);\n-        self.add_outlives(b, a);\n+        self.add_outlives(b, a, constraint_category);\n     }\n \n     fn push_verify("}, {"sha": "3713ec3f5d8256dc1a431c26743743cf38e163f4", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -312,6 +312,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n     }\n \n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n+        debug!(?constant, ?location, \"visit_constant\");\n+\n         self.super_constant(constant, location);\n         let ty = self.sanitize_type(constant, constant.literal.ty());\n \n@@ -1815,6 +1817,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     }\n \n     fn check_operand(&mut self, op: &Operand<'tcx>, location: Location) {\n+        debug!(?op, ?location, \"check_operand\");\n+\n         if let Operand::Constant(constant) = op {\n             let maybe_uneval = match constant.literal {\n                 ConstantKind::Val(..) | ConstantKind::Ty(_) => None,\n@@ -2593,7 +2597,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 .enumerate()\n                 .filter_map(|(idx, constraint)| {\n                     let ty::OutlivesPredicate(k1, r2) =\n-                        constraint.no_bound_vars().unwrap_or_else(|| {\n+                        constraint.0.no_bound_vars().unwrap_or_else(|| {\n                             bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n                         });\n "}, {"sha": "65371a285911e22f03a45c7cb8a1811b9593f63c", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -110,6 +110,7 @@ infer_relate_param_bound = ...so that the type `{$name}` will meet its required\n infer_relate_param_bound_2 = ...that is required by this bound\n infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait\n+infer_ascribe_user_type_prove_predicate = ...so that the where clause holds\n \n infer_nothing = {\"\"}\n "}, {"sha": "56e83489879516f0659329050dfb4848fa218c40", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -22,6 +22,7 @@ use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_middle::arena::ArenaAllocatable;\n+use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n@@ -129,7 +130,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         let region_constraints = self.with_region_constraints(|region_constraints| {\n             make_query_region_constraints(\n                 tcx,\n-                region_obligations.iter().map(|r_o| (r_o.sup_type, r_o.sub_region)),\n+                region_obligations\n+                    .iter()\n+                    .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category())),\n                 region_constraints,\n             )\n         });\n@@ -248,6 +251,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         // the original values `v_o` that was canonicalized into a\n         // variable...\n \n+        let constraint_category = cause.to_constraint_category();\n+\n         for (index, original_value) in original_values.var_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n             let result_value = query_response.substitute_projected(self.tcx, &result_subst, |v| {\n@@ -263,12 +268,14 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 (GenericArgKind::Lifetime(v_o), GenericArgKind::Lifetime(v_r)) => {\n                     // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n                     if v_o != v_r {\n-                        output_query_region_constraints\n-                            .outlives\n-                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)));\n-                        output_query_region_constraints\n-                            .outlives\n-                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)));\n+                        output_query_region_constraints.outlives.push((\n+                            ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)),\n+                            constraint_category,\n+                        ));\n+                        output_query_region_constraints.outlives.push((\n+                            ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)),\n+                            constraint_category,\n+                        ));\n                     }\n                 }\n \n@@ -314,7 +321,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 // Screen out `'a: 'a` cases -- we skip the binder here but\n                 // only compare the inner values to one another, so they are still at\n                 // consistent binding levels.\n-                let ty::OutlivesPredicate(k1, r2) = r_c.skip_binder();\n+                let ty::OutlivesPredicate(k1, r2) = r_c.0.skip_binder();\n                 if k1 != r2.into() { Some(r_c) } else { None }\n             }),\n         );\n@@ -559,7 +566,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Obligation<'tcx, ty::Predicate<'tcx>> {\n-        let ty::OutlivesPredicate(k1, r2) = predicate.skip_binder();\n+        let ty::OutlivesPredicate(k1, r2) = predicate.0.skip_binder();\n \n         let atom = match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n@@ -574,7 +581,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 span_bug!(cause.span, \"unexpected const outlives {:?}\", predicate);\n             }\n         };\n-        let predicate = predicate.rebind(atom).to_predicate(self.tcx);\n+        let predicate = predicate.0.rebind(atom).to_predicate(self.tcx);\n \n         Obligation::new(cause, param_env, predicate)\n     }\n@@ -625,7 +632,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n /// creates query region constraints.\n pub fn make_query_region_constraints<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>)>,\n+    outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>, ConstraintCategory<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> QueryRegionConstraints<'tcx> {\n     let RegionConstraintData { constraints, verifys, givens, member_constraints } =\n@@ -638,26 +645,31 @@ pub fn make_query_region_constraints<'tcx>(\n \n     let outlives: Vec<_> = constraints\n         .iter()\n-        .map(|(k, _)| match *k {\n-            // Swap regions because we are going from sub (<=) to outlives\n-            // (>=).\n-            Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n-                tcx.mk_region(ty::ReVar(v2)).into(),\n-                tcx.mk_region(ty::ReVar(v1)),\n-            ),\n-            Constraint::VarSubReg(v1, r2) => {\n-                ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n-            }\n-            Constraint::RegSubVar(r1, v2) => {\n-                ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n-            }\n-            Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n+        .map(|(k, origin)| {\n+            // no bound vars in the code above\n+            let constraint = ty::Binder::dummy(match *k {\n+                // Swap regions because we are going from sub (<=) to outlives\n+                // (>=).\n+                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n+                    tcx.mk_region(ty::ReVar(v2)).into(),\n+                    tcx.mk_region(ty::ReVar(v1)),\n+                ),\n+                Constraint::VarSubReg(v1, r2) => {\n+                    ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n+                }\n+                Constraint::RegSubVar(r1, v2) => {\n+                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n+                }\n+                Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n+            });\n+            (constraint, origin.to_constraint_category())\n         })\n-        .map(ty::Binder::dummy) // no bound vars in the code above\n         .chain(\n             outlives_obligations\n-                .map(|(ty, r)| ty::OutlivesPredicate(ty.into(), r))\n-                .map(ty::Binder::dummy), // no bound vars in the code above\n+                // no bound vars in the code above\n+                .map(|(ty, r, constraint_category)| {\n+                    (ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), r)), constraint_category)\n+                }),\n         )\n         .collect();\n "}, {"sha": "adaa47c01402303a297990a385fb1910f0826a55", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -77,6 +77,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n                 self.note_region_origin(err, &parent);\n             }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                RegionOriginNote::Plain {\n+                    span,\n+                    msg: fluent::infer::ascribe_user_type_prove_predicate,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n         }\n     }\n \n@@ -356,6 +363,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 err\n             }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"lifetime instantiated with \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but lifetime must outlive \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n         }\n     }\n "}, {"sha": "3abed12217ccd9a9b6e604738c49ddef8c4a0dd2", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -20,6 +20,7 @@ use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n+use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::select;\n use rustc_middle::ty::abstract_const::{AbstractConst, FailureKind};\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n@@ -408,20 +409,36 @@ pub enum SubregionOrigin<'tcx> {\n \n     /// Comparing the signature and requirements of an impl method against\n     /// the containing trait.\n-    CompareImplItemObligation { span: Span, impl_item_def_id: LocalDefId, trait_item_def_id: DefId },\n+    CompareImplItemObligation {\n+        span: Span,\n+        impl_item_def_id: LocalDefId,\n+        trait_item_def_id: DefId,\n+    },\n \n     /// Checking that the bounds of a trait's associated type hold for a given impl\n     CheckAssociatedTypeBounds {\n         parent: Box<SubregionOrigin<'tcx>>,\n         impl_item_def_id: LocalDefId,\n         trait_item_def_id: DefId,\n     },\n+\n+    AscribeUserTypeProvePredicate(Span),\n }\n \n // `SubregionOrigin` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(SubregionOrigin<'_>, 32);\n \n+impl<'tcx> SubregionOrigin<'tcx> {\n+    pub fn to_constraint_category(&self) -> ConstraintCategory<'tcx> {\n+        match self {\n+            Self::Subtype(type_trace) => type_trace.cause.to_constraint_category(),\n+            Self::AscribeUserTypeProvePredicate(span) => ConstraintCategory::Predicate(*span),\n+            _ => ConstraintCategory::BoringNoLocation,\n+        }\n+    }\n+}\n+\n /// Times when we replace late-bound regions with variables:\n #[derive(Clone, Copy, Debug)]\n pub enum LateBoundRegionConversionTime {\n@@ -1988,6 +2005,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             DataBorrowed(_, a) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n             CompareImplItemObligation { span, .. } => span,\n+            AscribeUserTypeProvePredicate(span) => span,\n             CheckAssociatedTypeBounds { ref parent, .. } => parent.span(),\n         }\n     }\n@@ -2020,6 +2038,10 @@ impl<'tcx> SubregionOrigin<'tcx> {\n                 parent: Box::new(default()),\n             },\n \n+            traits::ObligationCauseCode::AscribeUserTypeProvePredicate(span) => {\n+                SubregionOrigin::AscribeUserTypeProvePredicate(span)\n+            }\n+\n             _ => default(),\n         }\n     }"}, {"sha": "5bd1774f6b1ec7b11dc58fe1e2a3e6c735914f9d", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -69,6 +69,7 @@ use crate::infer::{\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::undo_log::UndoLogs;\n use rustc_hir::def_id::LocalDefId;\n+use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, Ty, TyCtxt, TypeVisitable};\n use smallvec::smallvec;\n@@ -163,7 +164,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n             let outlives =\n                 &mut TypeOutlives::new(self, self.tcx, &region_bound_pairs, None, param_env);\n-            outlives.type_must_outlive(origin, sup_type, sub_region);\n+            let category = origin.to_constraint_category();\n+            outlives.type_must_outlive(origin, sup_type, sub_region, category);\n         }\n     }\n \n@@ -207,6 +209,7 @@ pub trait TypeOutlivesDelegate<'tcx> {\n         origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n+        constraint_category: ConstraintCategory<'tcx>,\n     );\n \n     fn push_verify(\n@@ -255,25 +258,27 @@ where\n         origin: infer::SubregionOrigin<'tcx>,\n         ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         assert!(!ty.has_escaping_bound_vars());\n \n         let mut components = smallvec![];\n         push_outlives_components(self.tcx, ty, &mut components);\n-        self.components_must_outlive(origin, &components, region);\n+        self.components_must_outlive(origin, &components, region, category);\n     }\n \n     fn components_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         components: &[Component<'tcx>],\n         region: ty::Region<'tcx>,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         for component in components.iter() {\n             let origin = origin.clone();\n             match component {\n                 Component::Region(region1) => {\n-                    self.delegate.push_sub_region_constraint(origin, region, *region1);\n+                    self.delegate.push_sub_region_constraint(origin, region, *region1, category);\n                 }\n                 Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, *param_ty);\n@@ -282,7 +287,7 @@ where\n                     self.projection_must_outlive(origin, region, *projection_ty);\n                 }\n                 Component::EscapingProjection(subcomponents) => {\n-                    self.components_must_outlive(origin, &subcomponents, region);\n+                    self.components_must_outlive(origin, &subcomponents, region, category);\n                 }\n                 Component::UnresolvedInferenceVariable(v) => {\n                     // ignore this, we presume it will yield an error\n@@ -389,13 +394,19 @@ where\n         if approx_env_bounds.is_empty() && trait_bounds.is_empty() && needs_infer {\n             debug!(\"projection_must_outlive: no declared bounds\");\n \n+            let constraint = origin.to_constraint_category();\n             for k in projection_ty.substs {\n                 match k.unpack() {\n                     GenericArgKind::Lifetime(lt) => {\n-                        self.delegate.push_sub_region_constraint(origin.clone(), region, lt);\n+                        self.delegate.push_sub_region_constraint(\n+                            origin.clone(),\n+                            region,\n+                            lt,\n+                            constraint,\n+                        );\n                     }\n                     GenericArgKind::Type(ty) => {\n-                        self.type_must_outlive(origin.clone(), ty, region);\n+                        self.type_must_outlive(origin.clone(), ty, region, constraint);\n                     }\n                     GenericArgKind::Const(_) => {\n                         // Const parameters don't impose constraints.\n@@ -433,7 +444,8 @@ where\n             let unique_bound = trait_bounds[0];\n             debug!(\"projection_must_outlive: unique trait bound = {:?}\", unique_bound);\n             debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-            self.delegate.push_sub_region_constraint(origin, region, unique_bound);\n+            let category = origin.to_constraint_category();\n+            self.delegate.push_sub_region_constraint(origin, region, unique_bound, category);\n             return;\n         }\n \n@@ -455,6 +467,7 @@ impl<'cx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'tcx> {\n         origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n+        _constraint_category: ConstraintCategory<'tcx>,\n     ) {\n         self.sub_regions(origin, a, b)\n     }"}, {"sha": "d3cf519b633c71db5860a291a17347e06ac07104", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -22,6 +22,7 @@\n //! [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html\n \n use crate::infer::MemberConstraint;\n+use crate::mir::ConstraintCategory;\n use crate::ty::subst::GenericArg;\n use crate::ty::{self, BoundVar, List, Region, Ty, TyCtxt};\n use rustc_index::vec::IndexVec;\n@@ -301,8 +302,10 @@ impl<'tcx, V> Canonical<'tcx, V> {\n     }\n }\n \n-pub type QueryOutlivesConstraint<'tcx> =\n-    ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n+pub type QueryOutlivesConstraint<'tcx> = (\n+    ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>,\n+    ConstraintCategory<'tcx>,\n+);\n \n TrivialTypeTraversalAndLiftImpls! {\n     for <'tcx> {"}, {"sha": "d89efe2b3f024a68a19ab18cb42ea3fd57f94f2b", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -327,7 +327,7 @@ rustc_data_structures::static_assert_size!(ConstraintCategory<'_>, 16);\n ///\n /// See also `rustc_const_eval::borrow_check::constraints`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n-#[derive(TyEncodable, TyDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable, Lift, TypeVisitable, TypeFoldable)]\n pub enum ConstraintCategory<'tcx> {\n     Return(ReturnConstraint),\n     Yield,\n@@ -369,7 +369,7 @@ pub enum ConstraintCategory<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n-#[derive(TyEncodable, TyDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable, TypeVisitable, TypeFoldable)]\n pub enum ReturnConstraint {\n     Normal,\n     ClosureUpvar(Field),"}, {"sha": "68a7af0b8c8d75669028135952d7f8e921431d45", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -10,6 +10,7 @@ mod structural_impls;\n pub mod util;\n \n use crate::infer::canonical::Canonical;\n+use crate::mir::ConstraintCategory;\n use crate::ty::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n@@ -183,6 +184,16 @@ impl<'tcx> ObligationCause<'tcx> {\n             variant(DerivedObligationCause { parent_trait_pred, parent_code: self.code }).into();\n         self\n     }\n+\n+    pub fn to_constraint_category(&self) -> ConstraintCategory<'tcx> {\n+        match self.code() {\n+            MatchImpl(cause, _) => cause.to_constraint_category(),\n+            AscribeUserTypeProvePredicate(predicate_span) => {\n+                ConstraintCategory::Predicate(*predicate_span)\n+            }\n+            _ => ConstraintCategory::BoringNoLocation,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n@@ -418,6 +429,8 @@ pub enum ObligationCauseCode<'tcx> {\n         is_lit: bool,\n         output_ty: Option<Ty<'tcx>>,\n     },\n+\n+    AscribeUserTypeProvePredicate(Span),\n }\n \n /// The 'location' at which we try to perform HIR-based wf checking."}, {"sha": "13d9c160038f2820e580a2c45b1936c49d1dc527", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -2256,7 +2256,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             | ObligationCauseCode::QuestionMark\n             | ObligationCauseCode::CheckAssociatedTypeBounds { .. }\n             | ObligationCauseCode::LetElse\n-            | ObligationCauseCode::BinOp { .. } => {}\n+            | ObligationCauseCode::BinOp { .. }\n+            | ObligationCauseCode::AscribeUserTypeProvePredicate(..) => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}, {"sha": "40acabf622a546cd2ca29c9b1947fa7f162d1a37", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -48,10 +48,11 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         debug!(\n-            \"normalize::<{}>(value={:?}, param_env={:?})\",\n+            \"normalize::<{}>(value={:?}, param_env={:?}, cause={:?})\",\n             std::any::type_name::<T>(),\n             value,\n             self.param_env,\n+            self.cause,\n         );\n         if !needs_normalization(&value, self.param_env.reveal()) {\n             return Ok(Normalized { value, obligations: vec![] });"}, {"sha": "18988861add136646170b71408ee69b9efc297e0", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -23,7 +23,7 @@ impl<F, G> CustomTypeOp<F, G> {\n     }\n }\n \n-impl<'tcx, F, R, G> super::TypeOp<'tcx> for CustomTypeOp<F, G>\n+impl<'tcx, F, R: fmt::Debug, G> super::TypeOp<'tcx> for CustomTypeOp<F, G>\n where\n     F: for<'a, 'cx> FnOnce(&'a InferCtxt<'cx, 'tcx>) -> Fallible<InferOk<'tcx, R>>,\n     G: Fn() -> String,\n@@ -89,8 +89,8 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n         infcx.tcx,\n         region_obligations\n             .iter()\n-            .map(|r_o| (r_o.sup_type, r_o.sub_region))\n-            .map(|(ty, r)| (infcx.resolve_vars_if_possible(ty), r)),\n+            .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category()))\n+            .map(|(ty, r, cc)| (infcx.resolve_vars_if_possible(ty), r, cc)),\n         &region_constraint_data,\n     );\n "}, {"sha": "8a79165702ca3f6f52252063db779268241c0a9b", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -26,7 +26,7 @@ pub use rustc_middle::traits::query::type_op::*;\n /// extract out the resulting region constraints (or an error if it\n /// cannot be completed).\n pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n-    type Output;\n+    type Output: fmt::Debug;\n     type ErrorInfo;\n \n     /// Processes the operation and all resulting obligations,"}, {"sha": "1bb6506b3678c379690c94c2011e95d0e5ea8571", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -3,7 +3,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n-use rustc_infer::traits::TraitEngineExt as _;\n+use rustc_infer::traits::{ObligationCauseCode, TraitEngineExt as _};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArg, Subst, UserSelfTy, UserSubsts};\n use rustc_middle::ty::{\n@@ -22,6 +22,7 @@ use rustc_trait_selection::traits::query::type_op::subtype::Subtype;\n use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, TraitEngine};\n use std::fmt;\n+use std::iter::zip;\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers {\n@@ -61,28 +62,32 @@ pub fn type_op_ascribe_user_type_with_span<'a, 'tcx: 'a>(\n         mir_ty, def_id, user_substs\n     );\n \n-    let mut cx = AscribeUserTypeCx { infcx, param_env, fulfill_cx };\n-    cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs, span)?;\n+    let mut cx = AscribeUserTypeCx { infcx, param_env, span: span.unwrap_or(DUMMY_SP), fulfill_cx };\n+    cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs)?;\n     Ok(())\n }\n \n struct AscribeUserTypeCx<'me, 'tcx> {\n     infcx: &'me InferCtxt<'me, 'tcx>,\n     param_env: ParamEnv<'tcx>,\n+    span: Span,\n     fulfill_cx: &'me mut dyn TraitEngine<'tcx>,\n }\n \n impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n     fn normalize<T>(&mut self, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.normalize_with_cause(value, ObligationCause::misc(self.span, hir::CRATE_HIR_ID))\n+    }\n+\n+    fn normalize_with_cause<T>(&mut self, value: T, cause: ObligationCause<'tcx>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         self.infcx\n-            .partially_normalize_associated_types_in(\n-                ObligationCause::misc(DUMMY_SP, hir::CRATE_HIR_ID),\n-                self.param_env,\n-                value,\n-            )\n+            .partially_normalize_associated_types_in(cause, self.param_env, value)\n             .into_value_registering_obligations(self.infcx, self.fulfill_cx)\n     }\n \n@@ -91,18 +96,13 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         T: ToTrace<'tcx>,\n     {\n         self.infcx\n-            .at(&ObligationCause::dummy(), self.param_env)\n+            .at(&ObligationCause::dummy_with_span(self.span), self.param_env)\n             .relate(a, variance, b)?\n             .into_value_registering_obligations(self.infcx, self.fulfill_cx);\n         Ok(())\n     }\n \n-    fn prove_predicate(&mut self, predicate: Predicate<'tcx>, span: Option<Span>) {\n-        let cause = if let Some(span) = span {\n-            ObligationCause::dummy_with_span(span)\n-        } else {\n-            ObligationCause::dummy()\n-        };\n+    fn prove_predicate(&mut self, predicate: Predicate<'tcx>, cause: ObligationCause<'tcx>) {\n         self.fulfill_cx.register_predicate_obligation(\n             self.infcx,\n             Obligation::new(cause, self.param_env, predicate),\n@@ -126,7 +126,6 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         mir_ty: Ty<'tcx>,\n         def_id: DefId,\n         user_substs: UserSubsts<'tcx>,\n-        span: Option<Span>,\n     ) -> Result<(), NoSolution> {\n         let UserSubsts { user_self_ty, substs } = user_substs;\n         let tcx = self.tcx();\n@@ -145,10 +144,22 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         // outlives\" error messages.\n         let instantiated_predicates =\n             self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+\n+        let cause = ObligationCause::dummy_with_span(self.span);\n+\n         debug!(?instantiated_predicates);\n-        for instantiated_predicate in instantiated_predicates.predicates {\n-            let instantiated_predicate = self.normalize(instantiated_predicate);\n-            self.prove_predicate(instantiated_predicate, span);\n+        for (instantiated_predicate, predicate_span) in\n+            zip(instantiated_predicates.predicates, instantiated_predicates.spans)\n+        {\n+            let span = if self.span == DUMMY_SP { predicate_span } else { self.span };\n+            let cause = ObligationCause::new(\n+                span,\n+                hir::CRATE_HIR_ID,\n+                ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n+            );\n+            let instantiated_predicate =\n+                self.normalize_with_cause(instantiated_predicate, cause.clone());\n+            self.prove_predicate(instantiated_predicate, cause);\n         }\n \n         if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n@@ -161,7 +172,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n             self.prove_predicate(\n                 ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()))\n                     .to_predicate(self.tcx()),\n-                span,\n+                cause.clone(),\n             );\n         }\n \n@@ -178,7 +189,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         // which...could happen with normalization...\n         self.prove_predicate(\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(self.tcx()),\n-            span,\n+            cause,\n         );\n         Ok(())\n     }"}, {"sha": "27b3da8ab3dfa7af14518069da365100021c6b7a", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::{OutlivesEnvironment, RegionBoundPairs};\n use rustc_infer::infer::outlives::obligations::TypeOutlives;\n use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n+use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n@@ -663,7 +664,7 @@ fn ty_known_to_outlive<'tcx>(\n     resolve_regions_with_wf_tys(tcx, id, param_env, &wf_tys, |infcx, region_bound_pairs| {\n         let origin = infer::RelateParamBound(DUMMY_SP, ty, None);\n         let outlives = &mut TypeOutlives::new(infcx, tcx, region_bound_pairs, None, param_env);\n-        outlives.type_must_outlive(origin, ty, region);\n+        outlives.type_must_outlive(origin, ty, region, ConstraintCategory::BoringNoLocation);\n     })\n }\n \n@@ -681,7 +682,12 @@ fn region_known_to_outlive<'tcx>(\n         use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n         let origin = infer::RelateRegionParamBound(DUMMY_SP);\n         // `region_a: region_b` -> `region_b <= region_a`\n-        infcx.push_sub_region_constraint(origin, region_b, region_a);\n+        infcx.push_sub_region_constraint(\n+            origin,\n+            region_b,\n+            region_a,\n+            ConstraintCategory::BoringNoLocation,\n+        );\n     })\n }\n "}, {"sha": "719d1bd5a4c7dabf518cdb41e5718b511632d482", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-1.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -0,0 +1,35 @@\n+// check-fail\n+// known-bug\n+\n+// This gives us problems because `for<'a> I::Item<'a>: Debug` should mean \"for\n+// all 'a where I::Item<'a> is WF\", but really means \"for all 'a possible\"\n+\n+use std::fmt::Debug;\n+\n+pub trait LendingIterator {\n+    type Item<'this>\n+    where\n+        Self: 'this;\n+}\n+\n+pub struct WindowsMut<'x> {\n+    slice: &'x (),\n+}\n+\n+impl<'y> LendingIterator for WindowsMut<'y> {\n+    type Item<'this> = &'this mut () where 'y: 'this;\n+}\n+\n+fn print_items<I>(_iter: I)\n+where\n+    I: LendingIterator,\n+    for<'a> I::Item<'a>: Debug,\n+{\n+}\n+\n+fn main() {\n+    let slice = &mut ();\n+    //~^ temporary value dropped while borrowed\n+    let windows = WindowsMut { slice };\n+    print_items::<WindowsMut<'_>>(windows);\n+}"}, {"sha": "414999881d4701cb5ab2a7e72b72e86ad1e7934a", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-1.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-1.stderr?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -0,0 +1,20 @@\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/hrtb-implied-1.rs:31:22\n+   |\n+LL |     let slice = &mut ();\n+   |                      ^^ creates a temporary which is freed while still in use\n+...\n+LL |     print_items::<WindowsMut<'_>>(windows);\n+   |     -------------------------------------- argument requires that borrow lasts for `'static`\n+LL | }\n+   | - temporary value is freed at the end of this statement\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/hrtb-implied-1.rs:26:26\n+   |\n+LL |     for<'a> I::Item<'a>: Debug,\n+   |                          ^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0716`."}, {"sha": "8e6c5348e71cab2194056bdb3d980a0ccc99fb8c", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-2.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-2.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -0,0 +1,40 @@\n+// check-fail\n+// known-bug\n+\n+// This gives us problems because `for<'a> I::Item<'a>: Debug` should mean \"for\n+// all 'a where I::Item<'a> is WF\", but really means \"for all 'a possible\"\n+\n+trait LendingIterator: Sized {\n+    type Item<'a>\n+    where\n+        Self: 'a;\n+    fn next(&mut self) -> Self::Item<'_>;\n+}\n+fn fails<I: LendingIterator, F>(iter: &mut I, f: F) -> bool\n+where\n+    F: FnMut(I::Item<'_>),\n+{\n+    let mut iter2 = Eat(iter, f);\n+    let _next = iter2.next();\n+    //~^ borrowed data escapes\n+    true\n+}\n+impl<I: LendingIterator> LendingIterator for &mut I {\n+    type Item<'a> = I::Item<'a> where Self:'a;\n+    fn next(&mut self) -> Self::Item<'_> {\n+        (**self).next()\n+    }\n+}\n+\n+struct Eat<I, F>(I, F);\n+impl<I: LendingIterator, F> Iterator for Eat<I, F>\n+where\n+    F: FnMut(I::Item<'_>),\n+{\n+    type Item = ();\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1ee270398de4dcf16e1274793b6e4ffc610bcafc", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-2.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-2.stderr?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -0,0 +1,22 @@\n+error[E0521]: borrowed data escapes outside of function\n+  --> $DIR/hrtb-implied-2.rs:18:17\n+   |\n+LL | fn fails<I: LendingIterator, F>(iter: &mut I, f: F) -> bool\n+   |                                 ----  - let's call the lifetime of this reference `'1`\n+   |                                 |\n+   |                                 `iter` is a reference that is only valid in the function body\n+...\n+LL |     let _next = iter2.next();\n+   |                 ^^^^^^^^^^^^\n+   |                 |\n+   |                 `iter` escapes the function body here\n+   |                 argument requires that `'1` must outlive `'static`\n+   |\n+   = note: requirement occurs because of a mutable reference to `Eat<&mut I, F>`\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n+   = note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0521`."}, {"sha": "bc9e6c8aea85e59d40bf00efc7dc86b20f7eda9e", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-3.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-3.rs?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -0,0 +1,23 @@\n+trait LendingIterator {\n+    type Item<'a>\n+    where\n+        Self: 'a;\n+}\n+\n+impl LendingIterator for &str {\n+    type Item<'a> = () where Self:'a;\n+}\n+\n+fn trivial_bound<I>(_: I)\n+where\n+    I: LendingIterator,\n+    for<'a> I::Item<'a>: Sized,\n+{\n+}\n+\n+fn fails(iter: &str) {\n+    trivial_bound(iter);\n+    //~^ borrowed data escapes\n+}\n+\n+fn main() {}"}, {"sha": "c67e02437cd8dcdbd5dce54305f40d2ae3ed8210", "filename": "src/test/ui/generic-associated-types/bugs/hrtb-implied-3.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fhrtb-implied-3.stderr?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -0,0 +1,22 @@\n+error[E0521]: borrowed data escapes outside of function\n+  --> $DIR/hrtb-implied-3.rs:19:5\n+   |\n+LL | fn fails(iter: &str) {\n+   |          ----  - let's call the lifetime of this reference `'1`\n+   |          |\n+   |          `iter` is a reference that is only valid in the function body\n+LL |     trivial_bound(iter);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     `iter` escapes the function body here\n+   |     argument requires that `'1` must outlive `'static`\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/hrtb-implied-3.rs:14:26\n+   |\n+LL |     for<'a> I::Item<'a>: Sized,\n+   |                          ^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0521`."}, {"sha": "45b64d2b0248376fcbf0d65067ab7410be818f3e", "filename": "src/test/ui/generic-associated-types/trait-objects.extended.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Ftrait-objects.extended.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fgeneric-associated-types%2Ftrait-objects.extended.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Ftrait-objects.extended.stderr?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -11,6 +11,8 @@ LL |     x.size_hint().0\n    |     |\n    |     `x` escapes the function body here\n    |     argument requires that `'1` must outlive `'static`\n+   |\n+   = note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n \n error: aborting due to previous error\n "}, {"sha": "31e11e12835166a4aca0c219a9cfd58ecc0f3b0b", "filename": "src/test/ui/higher-rank-trait-bounds/hrtb-just-for-static.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-just-for-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-just-for-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-just-for-static.stderr?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -14,6 +14,12 @@ LL | fn give_some<'a>() {\n    |              -- lifetime `'a` defined here\n LL |     want_hrtb::<&'a u32>()\n    |     ^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/hrtb-just-for-static.rs:9:15\n+   |\n+LL |     where T : for<'a> Foo<&'a isize>\n+   |               ^^^^^^^^^^^^^^^^^^^^^^\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-just-for-static.rs:30:5"}, {"sha": "5e75a4cc8afa5021cb0da986e4d1c29990ce3e1c", "filename": "src/test/ui/higher-rank-trait-bounds/hrtb-perfect-forwarding.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-perfect-forwarding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-perfect-forwarding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-perfect-forwarding.stderr?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -46,6 +46,12 @@ LL | fn foo_hrtb_bar_not<'b, T>(mut t: T)\n ...\n LL |     foo_hrtb_bar_not(&mut t);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'static`\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/hrtb-perfect-forwarding.rs:37:8\n+   |\n+LL |     T: for<'a> Foo<&'a isize> + Bar<&'b isize>,\n+   |        ^^^^^^^^^^^^^^^^^^^^^^\n \n error: implementation of `Bar` is not general enough\n   --> $DIR/hrtb-perfect-forwarding.rs:43:5"}, {"sha": "73c772205c3dadb34e48d29c2bb9369afaf3d5a6", "filename": "src/test/ui/issues/issue-26217.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fissues%2Fissue-26217.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fissues%2Fissue-26217.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26217.stderr?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -5,6 +5,12 @@ LL | fn bar<'a>() {\n    |        -- lifetime `'a` defined here\n LL |     foo::<&'a i32>();\n    |     ^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/issue-26217.rs:1:30\n+   |\n+LL | fn foo<T>() where for<'a> T: 'a {}\n+   |                              ^^\n \n error: aborting due to previous error\n "}, {"sha": "f5c10f3ddea0ea0686342e06ab87b16a6b4d63fb", "filename": "src/test/ui/nll/local-outlives-static-via-hrtb.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Flocal-outlives-static-via-hrtb.stderr?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -9,6 +9,12 @@ LL |     assert_static_via_hrtb(&local);\n LL |     assert_static_via_hrtb_with_assoc_type(&&local);\n LL | }\n    | - `local` dropped here while still borrowed\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/local-outlives-static-via-hrtb.rs:15:53\n+   |\n+LL | fn assert_static_via_hrtb<G>(_: G) where for<'a> G: Outlives<'a> {}\n+   |                                                     ^^^^^^^^^^^^\n \n error[E0597]: `local` does not live long enough\n   --> $DIR/local-outlives-static-via-hrtb.rs:25:45\n@@ -20,6 +26,12 @@ LL |     assert_static_via_hrtb_with_assoc_type(&&local);\n    |     argument requires that `local` is borrowed for `'static`\n LL | }\n    | - `local` dropped here while still borrowed\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/local-outlives-static-via-hrtb.rs:19:20\n+   |\n+LL |     for<'a> &'a T: Reference<AssociatedType = &'a ()>,\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "31e17d64b8caf4b41165d3da1e29aa3270bc3695", "filename": "src/test/ui/nll/type-test-universe.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fnll%2Ftype-test-universe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efa717bc2d82c19c6957f362a936a6f95169d138/src%2Ftest%2Fui%2Fnll%2Ftype-test-universe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-test-universe.stderr?ref=efa717bc2d82c19c6957f362a936a6f95169d138", "patch": "@@ -11,6 +11,12 @@ LL | fn test2<'a>() {\n    |          -- lifetime `'a` defined here\n LL |     outlives_forall::<Value<'a>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+   |\n+note: due to current limitations in the borrow checker, this implies a `'static` lifetime\n+  --> $DIR/type-test-universe.rs:6:16\n+   |\n+LL |     for<'u> T: 'u,\n+   |                ^^\n \n error: aborting due to 2 previous errors\n "}]}