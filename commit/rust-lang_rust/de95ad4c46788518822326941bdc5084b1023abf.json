{"sha": "de95ad4c46788518822326941bdc5084b1023abf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlOTVhZDRjNDY3ODg1MTg4MjIzMjY5NDFiZGM1MDg0YjEwMjNhYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-01T17:51:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-01T17:51:55Z"}, "message": "auto merge of #19436 : lifthrasiir/rust/rustdoc-short-src-paths, r=alexcrichton\n\nBefore: `doc/src/collections/home/lifthrasiir/git/rust/src/libcollections/vec.rs.html`\r\nAfter: `doc/src/collections/vec.rs.html`\r\n\r\nIf the source code is in the parent dirs relative to the crate root, `..` is replaced with `up` as expected. Any other error like non-UTF-8 paths or drive-relative paths falls back to the absolute path.\r\n\r\nThere might be a way to improve on false negatives, but this alone should be enough for fixing #18370.", "tree": {"sha": "568aa3e6c255e0c8d3f4eef376ec96adc902cbe3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/568aa3e6c255e0c8d3f4eef376ec96adc902cbe3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de95ad4c46788518822326941bdc5084b1023abf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de95ad4c46788518822326941bdc5084b1023abf", "html_url": "https://github.com/rust-lang/rust/commit/de95ad4c46788518822326941bdc5084b1023abf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de95ad4c46788518822326941bdc5084b1023abf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09f04bf2c919725d5ee69b8cbb34cdcbb3433e25", "url": "https://api.github.com/repos/rust-lang/rust/commits/09f04bf2c919725d5ee69b8cbb34cdcbb3433e25", "html_url": "https://github.com/rust-lang/rust/commit/09f04bf2c919725d5ee69b8cbb34cdcbb3433e25"}, {"sha": "08fb9aa2d218399ed6d246c97fb6cdd0d1150b59", "url": "https://api.github.com/repos/rust-lang/rust/commits/08fb9aa2d218399ed6d246c97fb6cdd0d1150b59", "html_url": "https://github.com/rust-lang/rust/commit/08fb9aa2d218399ed6d246c97fb6cdd0d1150b59"}], "stats": {"total": 22, "additions": 17, "deletions": 5}, "files": [{"sha": "a18804be2755961ee16c326293607a341209e9c0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de95ad4c46788518822326941bdc5084b1023abf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de95ad4c46788518822326941bdc5084b1023abf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=de95ad4c46788518822326941bdc5084b1023abf", "patch": "@@ -53,6 +53,7 @@ use std::rc::Rc;\n use std::u32;\n use std::str::Str as StrTrait; // Conflicts with Str variant\n use std::char::Char as CharTrait; // Conflicts with Char variant\n+use std::path::Path as FsPath; // Conflicts with Path struct\n \n use core::DocContext;\n use doctree;\n@@ -115,6 +116,7 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct Crate {\n     pub name: String,\n+    pub src: FsPath,\n     pub module: Option<Item>,\n     pub externs: Vec<(ast::CrateNum, ExternalCrate)>,\n     pub primitives: Vec<PrimitiveType>,\n@@ -194,6 +196,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         Crate {\n             name: name.to_string(),\n+            src: cx.src.clone(),\n             module: Some(module),\n             externs: externs,\n             primitives: primitives,"}, {"sha": "492517bad93e420dd4310dda36947a3f6d01ffac", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/de95ad4c46788518822326941bdc5084b1023abf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de95ad4c46788518822326941bdc5084b1023abf/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=de95ad4c46788518822326941bdc5084b1023abf", "patch": "@@ -83,6 +83,9 @@ pub struct Context {\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n     pub root_path: String,\n+    /// The path to the crate root source minus the file name.\n+    /// Used for simplifying paths to the highlighted source code files.\n+    pub src_root: Path,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n     pub dst: Path,\n@@ -249,6 +252,7 @@ pub fn run(mut krate: clean::Crate,\n            passes: HashSet<String>) -> io::IoResult<()> {\n     let mut cx = Context {\n         dst: dst,\n+        src_root: krate.src.dir_path(),\n         passes: passes,\n         current: Vec::new(),\n         root_path: String::new(),\n@@ -642,8 +646,13 @@ fn mkdir(path: &Path) -> io::IoResult<()> {\n /// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n /// static HTML tree.\n // FIXME (#9639): The closure should deal with &[u8] instead of &str\n-fn clean_srcpath(src: &[u8], f: |&str|) {\n+// FIXME (#9639): This is too conservative, rejecting non-UTF-8 paths\n+fn clean_srcpath(src_root: &Path, src: &[u8], f: |&str|) {\n     let p = Path::new(src);\n+\n+    // make it relative, if possible\n+    let p = p.path_relative_from(src_root).unwrap_or(p);\n+\n     if p.as_vec() != b\".\" {\n         for c in p.str_components().map(|x|x.unwrap()) {\n             if \"..\" == c {\n@@ -749,7 +758,7 @@ impl<'a> SourceCollector<'a> {\n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n         let mut root_path = String::from_str(\"../../\");\n-        clean_srcpath(p.dirname(), |component| {\n+        clean_srcpath(&self.cx.src_root, p.dirname(), |component| {\n             cur.push(component);\n             mkdir(&cur).unwrap();\n             root_path.push_str(\"../\");\n@@ -1299,13 +1308,13 @@ impl<'a> Item<'a> {\n     /// If `None` is returned, then a source link couldn't be generated. This\n     /// may happen, for example, with externally inlined items where the source\n     /// of their crate documentation isn't known.\n-    fn href(&self) -> Option<String> {\n+    fn href(&self, cx: &Context) -> Option<String> {\n         // If this item is part of the local crate, then we're guaranteed to\n         // know the span, so we plow forward and generate a proper url. The url\n         // has anchors for the line numbers that we're linking to.\n         if ast_util::is_local(self.item.def_id) {\n             let mut path = Vec::new();\n-            clean_srcpath(self.item.source.filename.as_bytes(), |component| {\n+            clean_srcpath(&cx.src_root, self.item.source.filename.as_bytes(), |component| {\n                 path.push(component.to_string());\n             });\n             let href = if self.item.source.loline == self.item.source.hiline {\n@@ -1412,7 +1421,7 @@ impl<'a> fmt::Show for Item<'a> {\n         // this page, and this link will be auto-clicked. The `id` attribute is\n         // used to find the link to auto-click.\n         if self.cx.include_sources && !is_primitive {\n-            match self.href() {\n+            match self.href(self.cx) {\n                 Some(l) => {\n                     try!(write!(fmt, \"<a id='src-{}' href='{}'>[src]</a>\",\n                                 self.item.def_id.node, l));"}]}