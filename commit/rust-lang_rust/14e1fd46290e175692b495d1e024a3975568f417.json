{"sha": "14e1fd46290e175692b495d1e024a3975568f417", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZTFmZDQ2MjkwZTE3NTY5MmI0OTVkMWUwMjRhMzk3NTU2OGY0MTc=", "commit": {"author": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-04-15T12:06:38Z"}, "committer": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-04-17T17:24:52Z"}, "message": "Add span to error for missing type params on enums.", "tree": {"sha": "cc17002616fe76ce0afbd5fda185c24f2a21aefd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc17002616fe76ce0afbd5fda185c24f2a21aefd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14e1fd46290e175692b495d1e024a3975568f417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14e1fd46290e175692b495d1e024a3975568f417", "html_url": "https://github.com/rust-lang/rust/commit/14e1fd46290e175692b495d1e024a3975568f417", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14e1fd46290e175692b495d1e024a3975568f417/comments", "author": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b9ade0f81d519733940ec28b796c11fdb0fd17b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b9ade0f81d519733940ec28b796c11fdb0fd17b", "html_url": "https://github.com/rust-lang/rust/commit/3b9ade0f81d519733940ec28b796c11fdb0fd17b"}], "stats": {"total": 27, "additions": 14, "deletions": 13}, "files": [{"sha": "bc01d2b126d33d2f889b59618c57a845bc998a76", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/14e1fd46290e175692b495d1e024a3975568f417/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e1fd46290e175692b495d1e024a3975568f417/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=14e1fd46290e175692b495d1e024a3975568f417", "patch": "@@ -2416,13 +2416,13 @@ pub enum Representability {\n \n /// Check whether a type is representable. This means it cannot contain unboxed\n /// structural recursion. This check is needed for structs and enums.\n-pub fn is_type_representable(cx: &ctxt, ty: t) -> Representability {\n+pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n \n     // Iterate until something non-representable is found\n-    fn find_nonrepresentable<It: Iterator<t>>(cx: &ctxt, seen: &mut Vec<DefId>,\n+    fn find_nonrepresentable<It: Iterator<t>>(cx: &ctxt, sp: Span, seen: &mut Vec<DefId>,\n                                               mut iter: It) -> Representability {\n         for ty in iter {\n-            let r = type_structurally_recursive(cx, seen, ty);\n+            let r = type_structurally_recursive(cx, sp, seen, ty);\n             if r != Representable {\n                  return r\n             }\n@@ -2432,7 +2432,7 @@ pub fn is_type_representable(cx: &ctxt, ty: t) -> Representability {\n \n     // Does the type `ty` directly (without indirection through a pointer)\n     // contain any types on stack `seen`?\n-    fn type_structurally_recursive(cx: &ctxt, seen: &mut Vec<DefId>,\n+    fn type_structurally_recursive(cx: &ctxt, sp: Span, seen: &mut Vec<DefId>,\n                                    ty: t) -> Representability {\n         debug!(\"type_structurally_recursive: {}\",\n                ::util::ppaux::ty_to_str(cx, ty));\n@@ -2455,19 +2455,19 @@ pub fn is_type_representable(cx: &ctxt, ty: t) -> Representability {\n         match get(ty).sty {\n             // Tuples\n             ty_tup(ref ts) => {\n-                find_nonrepresentable(cx, seen, ts.iter().map(|t| *t))\n+                find_nonrepresentable(cx, sp, seen, ts.iter().map(|t| *t))\n             }\n             // Fixed-length vectors.\n             // FIXME(#11924) Behavior undecided for zero-length vectors.\n             ty_vec(ty, VstoreFixed(_)) => {\n-                type_structurally_recursive(cx, seen, ty)\n+                type_structurally_recursive(cx, sp, seen, ty)\n             }\n \n             // Push struct and enum def-ids onto `seen` before recursing.\n             ty_struct(did, ref substs) => {\n                 seen.push(did);\n                 let fields = struct_fields(cx, did, substs);\n-                let r = find_nonrepresentable(cx, seen,\n+                let r = find_nonrepresentable(cx, sp, seen,\n                                               fields.iter().map(|f| f.mt.ty));\n                 seen.pop();\n                 r\n@@ -2478,8 +2478,10 @@ pub fn is_type_representable(cx: &ctxt, ty: t) -> Representability {\n \n                 let mut r = Representable;\n                 for variant in vs.iter() {\n-                    let iter = variant.args.iter().map(|aty| subst(cx, substs, *aty));\n-                    r = find_nonrepresentable(cx, seen, iter);\n+                    let iter = variant.args.iter().map(|aty| {\n+                        aty.subst_spanned(cx, substs, Some(sp))\n+                    });\n+                    r = find_nonrepresentable(cx, sp, seen, iter);\n \n                     if r != Representable { break }\n                 }\n@@ -2499,7 +2501,7 @@ pub fn is_type_representable(cx: &ctxt, ty: t) -> Representability {\n     // contains a different, structurally recursive type, maintain a stack\n     // of seen types and check recursion for each of them (issues #3008, #3779).\n     let mut seen: Vec<DefId> = Vec::new();\n-    type_structurally_recursive(cx, &mut seen, ty)\n+    type_structurally_recursive(cx, sp, &mut seen, ty)\n }\n \n pub fn type_is_trait(ty: t) -> bool {"}, {"sha": "6770640cfacc7c187e3b44ce5b81fcb470bb7029", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14e1fd46290e175692b495d1e024a3975568f417/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e1fd46290e175692b495d1e024a3975568f417/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=14e1fd46290e175692b495d1e024a3975568f417", "patch": "@@ -3356,7 +3356,7 @@ pub fn check_representable(tcx: &ty::ctxt,\n     // recursive type. It is only necessary to throw an error on those that\n     // contain themselves. For case 2, there must be an inner type that will be\n     // caught by case 1.\n-    match ty::is_type_representable(tcx, rty) {\n+    match ty::is_type_representable(tcx, sp, rty) {\n       ty::SelfRecursive => {\n         tcx.sess.span_err(\n           sp, format!(\"illegal recursive {} type; \\"}, {"sha": "951f991f106969c8a3539beba9f1ce59eb8fdf50", "filename": "src/test/compile-fail/issue-5997-enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14e1fd46290e175692b495d1e024a3975568f417/src%2Ftest%2Fcompile-fail%2Fissue-5997-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e1fd46290e175692b495d1e024a3975568f417/src%2Ftest%2Fcompile-fail%2Fissue-5997-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5997-enum.rs?ref=14e1fd46290e175692b495d1e024a3975568f417", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: missing type param `Z` in the substitution of `Z`\n-\n fn f<Z>() -> bool {\n     enum E { V(Z) }\n+    //~^ ERROR missing type param `Z` in the substitution of `Z`\n \n     true\n }"}]}