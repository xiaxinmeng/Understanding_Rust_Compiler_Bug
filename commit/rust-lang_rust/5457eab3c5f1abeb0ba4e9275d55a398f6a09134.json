{"sha": "5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NTdlYWIzYzVmMWFiZWIwYmE0ZTkyNzVkNTVhMzk4ZjZhMDkxMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-03T02:05:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-03T02:05:18Z"}, "message": "Auto merge of #22600 - brson:num, r=Gankro\n\n* count_ones/zeros, trailing_ones/zeros return u32, not usize\r\n* rotate_left/right take u32, not usize\r\n* RADIX, MANTISSA_DIGITS, DIGITS, BITS, BYTES are u32, not usize\r\n\r\nDoesn't touch pow because there's another PR for it.\r\n\r\ncc https://github.com/rust-lang/rust/issues/22240\r\n\r\nr? @Gankro", "tree": {"sha": "03faf98dc680da1c6cb4cff46593d295c971df07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03faf98dc680da1c6cb4cff46593d295c971df07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "html_url": "https://github.com/rust-lang/rust/commit/5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4c965ee803a4521d8b4575f634e036f93e408f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4c965ee803a4521d8b4575f634e036f93e408f3", "html_url": "https://github.com/rust-lang/rust/commit/b4c965ee803a4521d8b4575f634e036f93e408f3"}, {"sha": "76e9fa63ba0b6d892aa880db9c8373ede3e67c03", "url": "https://api.github.com/repos/rust-lang/rust/commits/76e9fa63ba0b6d892aa880db9c8373ede3e67c03", "html_url": "https://github.com/rust-lang/rust/commit/76e9fa63ba0b6d892aa880db9c8373ede3e67c03"}], "stats": {"total": 370, "additions": 215, "deletions": 155}, "files": [{"sha": "a92eccce142b1877095519d4c08ebcb8d90f1161", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -189,17 +189,17 @@ fn blocks_for_bits(bits: usize) -> usize {\n     //\n     // Note that we can technically avoid this branch with the expression\n     // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost usize::MAX this will overflow.\n-    if bits % u32::BITS == 0 {\n-        bits / u32::BITS\n+    if bits % u32::BITS as usize == 0 {\n+        bits / u32::BITS as usize\n     } else {\n-        bits / u32::BITS + 1\n+        bits / u32::BITS as usize + 1\n     }\n }\n \n /// Computes the bitmask for the final word of the vector\n fn mask_for_bits(bits: usize) -> u32 {\n     // Note especially that a perfect multiple of u32::BITS should mask all 1s.\n-    !0u32 >> (u32::BITS - bits % u32::BITS) % u32::BITS\n+    !0u32 >> (u32::BITS as usize - bits % u32::BITS as usize) % u32::BITS as usize\n }\n \n impl BitVec {\n@@ -237,7 +237,7 @@ impl BitVec {\n     /// An operation might screw up the unused bits in the last block of the\n     /// `BitVec`. As per (3), it's assumed to be all 0s. This method fixes it up.\n     fn fix_last_block(&mut self) {\n-        let extra_bits = self.len() % u32::BITS;\n+        let extra_bits = self.len() % u32::BITS as usize;\n         if extra_bits > 0 {\n             let mask = (1 << extra_bits) - 1;\n             let storage_len = self.storage.len();\n@@ -313,7 +313,7 @@ impl BitVec {\n     ///                     false, false, true, false]));\n     /// ```\n     pub fn from_bytes(bytes: &[u8]) -> BitVec {\n-        let len = bytes.len().checked_mul(u8::BITS).expect(\"capacity overflow\");\n+        let len = bytes.len().checked_mul(u8::BITS as usize).expect(\"capacity overflow\");\n         let mut bit_vec = BitVec::with_capacity(len);\n         let complete_words = bytes.len() / 4;\n         let extra_bytes = bytes.len() % 4;\n@@ -380,8 +380,8 @@ impl BitVec {\n         if i >= self.nbits {\n             return None;\n         }\n-        let w = i / u32::BITS;\n-        let b = i % u32::BITS;\n+        let w = i / u32::BITS as usize;\n+        let b = i % u32::BITS as usize;\n         self.storage.get(w).map(|&block|\n             (block & (1 << b)) != 0\n         )\n@@ -407,8 +407,8 @@ impl BitVec {\n                reason = \"panic semantics are likely to change in the future\")]\n     pub fn set(&mut self, i: usize, x: bool) {\n         assert!(i < self.nbits);\n-        let w = i / u32::BITS;\n-        let b = i % u32::BITS;\n+        let w = i / u32::BITS as usize;\n+        let b = i % u32::BITS as usize;\n         let flag = 1 << b;\n         let val = if x { self.storage[w] | flag }\n                   else { self.storage[w] & !flag };\n@@ -789,7 +789,7 @@ impl BitVec {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.storage.capacity().checked_mul(u32::BITS).unwrap_or(usize::MAX)\n+        self.storage.capacity().checked_mul(u32::BITS as usize).unwrap_or(usize::MAX)\n     }\n \n     /// Grows the `BitVec` in-place, adding `n` copies of `value` to the `BitVec`.\n@@ -819,7 +819,7 @@ impl BitVec {\n \n         // Correct the old tail word, setting or clearing formerly unused bits\n         let old_last_word = blocks_for_bits(self.nbits) - 1;\n-        if self.nbits % u32::BITS > 0 {\n+        if self.nbits % u32::BITS as usize > 0 {\n             let mask = mask_for_bits(self.nbits);\n             if value {\n                 self.storage[old_last_word] |= !mask;\n@@ -868,7 +868,7 @@ impl BitVec {\n             // (3)\n             self.set(i, false);\n             self.nbits = i;\n-            if self.nbits % u32::BITS == 0 {\n+            if self.nbits % u32::BITS as usize == 0 {\n                 // (2)\n                 self.storage.pop();\n             }\n@@ -890,7 +890,7 @@ impl BitVec {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, elem: bool) {\n-        if self.nbits % u32::BITS == 0 {\n+        if self.nbits % u32::BITS as usize == 0 {\n             self.storage.push(0);\n         }\n         let insert_pos = self.nbits;\n@@ -1406,7 +1406,7 @@ impl BitSet {\n         // Truncate\n         let trunc_len = cmp::max(old_len - n, 1);\n         bit_vec.storage.truncate(trunc_len);\n-        bit_vec.nbits = trunc_len * u32::BITS;\n+        bit_vec.nbits = trunc_len * u32::BITS as usize;\n     }\n \n     /// Iterator over each u32 stored in the `BitSet`.\n@@ -1663,7 +1663,7 @@ impl BitSet {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize  {\n-        self.bit_vec.blocks().fold(0, |acc, n| acc + n.count_ones())\n+        self.bit_vec.blocks().fold(0, |acc, n| acc + n.count_ones() as usize)\n     }\n \n     /// Returns whether there are no bits set in this set\n@@ -1831,13 +1831,13 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n     fn next(&mut self) -> Option<usize> {\n         while self.next_idx < self.set.bit_vec.len() ||\n               self.next_idx < self.other.bit_vec.len() {\n-            let bit_idx = self.next_idx % u32::BITS;\n+            let bit_idx = self.next_idx % u32::BITS as usize;\n             if bit_idx == 0 {\n                 let s_bit_vec = &self.set.bit_vec;\n                 let o_bit_vec = &self.other.bit_vec;\n                 // Merging the two words is a bit of an awkward dance since\n                 // one BitVec might be longer than the other\n-                let word_idx = self.next_idx / u32::BITS;\n+                let word_idx = self.next_idx / u32::BITS as usize;\n                 let w1 = if word_idx < s_bit_vec.storage.len() {\n                              s_bit_vec.storage[word_idx]\n                          } else { 0 };\n@@ -2441,70 +2441,70 @@ mod tests {\n \n     #[test]\n     fn test_bit_vec_push_pop() {\n-        let mut s = BitVec::from_elem(5 * u32::BITS - 2, false);\n-        assert_eq!(s.len(), 5 * u32::BITS - 2);\n-        assert_eq!(s[5 * u32::BITS - 3], false);\n+        let mut s = BitVec::from_elem(5 * u32::BITS as usize - 2, false);\n+        assert_eq!(s.len(), 5 * u32::BITS as usize - 2);\n+        assert_eq!(s[5 * u32::BITS as usize - 3], false);\n         s.push(true);\n         s.push(true);\n-        assert_eq!(s[5 * u32::BITS - 2], true);\n-        assert_eq!(s[5 * u32::BITS - 1], true);\n+        assert_eq!(s[5 * u32::BITS as usize - 2], true);\n+        assert_eq!(s[5 * u32::BITS as usize - 1], true);\n         // Here the internal vector will need to be extended\n         s.push(false);\n-        assert_eq!(s[5 * u32::BITS], false);\n+        assert_eq!(s[5 * u32::BITS as usize], false);\n         s.push(false);\n-        assert_eq!(s[5 * u32::BITS + 1], false);\n-        assert_eq!(s.len(), 5 * u32::BITS + 2);\n+        assert_eq!(s[5 * u32::BITS as usize + 1], false);\n+        assert_eq!(s.len(), 5 * u32::BITS as usize + 2);\n         // Pop it all off\n         assert_eq!(s.pop(), Some(false));\n         assert_eq!(s.pop(), Some(false));\n         assert_eq!(s.pop(), Some(true));\n         assert_eq!(s.pop(), Some(true));\n-        assert_eq!(s.len(), 5 * u32::BITS - 2);\n+        assert_eq!(s.len(), 5 * u32::BITS as usize - 2);\n     }\n \n     #[test]\n     fn test_bit_vec_truncate() {\n-        let mut s = BitVec::from_elem(5 * u32::BITS, true);\n+        let mut s = BitVec::from_elem(5 * u32::BITS as usize, true);\n \n-        assert_eq!(s, BitVec::from_elem(5 * u32::BITS, true));\n-        assert_eq!(s.len(), 5 * u32::BITS);\n-        s.truncate(4 * u32::BITS);\n-        assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n-        assert_eq!(s.len(), 4 * u32::BITS);\n+        assert_eq!(s, BitVec::from_elem(5 * u32::BITS as usize, true));\n+        assert_eq!(s.len(), 5 * u32::BITS as usize);\n+        s.truncate(4 * u32::BITS as usize);\n+        assert_eq!(s, BitVec::from_elem(4 * u32::BITS as usize, true));\n+        assert_eq!(s.len(), 4 * u32::BITS as usize);\n         // Truncating to a size > s.len() should be a noop\n-        s.truncate(5 * u32::BITS);\n-        assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n-        assert_eq!(s.len(), 4 * u32::BITS);\n-        s.truncate(3 * u32::BITS - 10);\n-        assert_eq!(s, BitVec::from_elem(3 * u32::BITS - 10, true));\n-        assert_eq!(s.len(), 3 * u32::BITS - 10);\n+        s.truncate(5 * u32::BITS as usize);\n+        assert_eq!(s, BitVec::from_elem(4 * u32::BITS as usize, true));\n+        assert_eq!(s.len(), 4 * u32::BITS as usize);\n+        s.truncate(3 * u32::BITS as usize - 10);\n+        assert_eq!(s, BitVec::from_elem(3 * u32::BITS as usize - 10, true));\n+        assert_eq!(s.len(), 3 * u32::BITS as usize - 10);\n         s.truncate(0);\n         assert_eq!(s, BitVec::from_elem(0, true));\n         assert_eq!(s.len(), 0);\n     }\n \n     #[test]\n     fn test_bit_vec_reserve() {\n-        let mut s = BitVec::from_elem(5 * u32::BITS, true);\n+        let mut s = BitVec::from_elem(5 * u32::BITS as usize, true);\n         // Check capacity\n-        assert!(s.capacity() >= 5 * u32::BITS);\n-        s.reserve(2 * u32::BITS);\n-        assert!(s.capacity() >= 7 * u32::BITS);\n-        s.reserve(7 * u32::BITS);\n-        assert!(s.capacity() >= 12 * u32::BITS);\n-        s.reserve_exact(7 * u32::BITS);\n-        assert!(s.capacity() >= 12 * u32::BITS);\n-        s.reserve(7 * u32::BITS + 1);\n-        assert!(s.capacity() >= 12 * u32::BITS + 1);\n+        assert!(s.capacity() >= 5 * u32::BITS as usize);\n+        s.reserve(2 * u32::BITS as usize);\n+        assert!(s.capacity() >= 7 * u32::BITS as usize);\n+        s.reserve(7 * u32::BITS as usize);\n+        assert!(s.capacity() >= 12 * u32::BITS as usize);\n+        s.reserve_exact(7 * u32::BITS as usize);\n+        assert!(s.capacity() >= 12 * u32::BITS as usize);\n+        s.reserve(7 * u32::BITS as usize + 1);\n+        assert!(s.capacity() >= 12 * u32::BITS as usize + 1);\n         // Check that length hasn't changed\n-        assert_eq!(s.len(), 5 * u32::BITS);\n+        assert_eq!(s.len(), 5 * u32::BITS as usize);\n         s.push(true);\n         s.push(false);\n         s.push(true);\n-        assert_eq!(s[5 * u32::BITS - 1], true);\n-        assert_eq!(s[5 * u32::BITS - 0], true);\n-        assert_eq!(s[5 * u32::BITS + 1], false);\n-        assert_eq!(s[5 * u32::BITS + 2], true);\n+        assert_eq!(s[5 * u32::BITS as usize - 1], true);\n+        assert_eq!(s[5 * u32::BITS as usize - 0], true);\n+        assert_eq!(s[5 * u32::BITS as usize + 1], false);\n+        assert_eq!(s[5 * u32::BITS as usize + 2], true);\n     }\n \n     #[test]\n@@ -2557,7 +2557,7 @@ mod bit_vec_bench {\n         let mut bit_vec = 0 as usize;\n         b.iter(|| {\n             for _ in 0..100 {\n-                bit_vec |= 1 << ((r.next_u32() as usize) % u32::BITS);\n+                bit_vec |= 1 << ((r.next_u32() as usize) % u32::BITS as usize);\n             }\n             black_box(&bit_vec);\n         });\n@@ -2590,10 +2590,10 @@ mod bit_vec_bench {\n     #[bench]\n     fn bench_bit_set_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bit_vec = BitVec::from_elem(u32::BITS, false);\n+        let mut bit_vec = BitVec::from_elem(u32::BITS as usize, false);\n         b.iter(|| {\n             for _ in 0..100 {\n-                bit_vec.set((r.next_u32() as usize) % u32::BITS, true);\n+                bit_vec.set((r.next_u32() as usize) % u32::BITS as usize, true);\n             }\n             black_box(&bit_vec);\n         });\n@@ -2610,7 +2610,7 @@ mod bit_vec_bench {\n \n     #[bench]\n     fn bench_bit_vec_small_iter(b: &mut Bencher) {\n-        let bit_vec = BitVec::from_elem(u32::BITS, false);\n+        let bit_vec = BitVec::from_elem(u32::BITS as usize, false);\n         b.iter(|| {\n             let mut sum = 0;\n             for _ in 0..10 {\n@@ -3052,7 +3052,7 @@ mod bit_set_bench {\n         let mut bit_vec = BitSet::new();\n         b.iter(|| {\n             for _ in 0..100 {\n-                bit_vec.insert((r.next_u32() as usize) % u32::BITS);\n+                bit_vec.insert((r.next_u32() as usize) % u32::BITS as usize);\n             }\n             black_box(&bit_vec);\n         });"}, {"sha": "4c966c0d44b4d992ab833029f88735d6c339855d", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -78,7 +78,7 @@ pub trait CLike {\n fn bit<E:CLike>(e: &E) -> usize {\n     use core::usize;\n     let value = e.to_usize();\n-    assert!(value < usize::BITS,\n+    assert!(value < usize::BITS as usize,\n             \"EnumSet only supports up to {} variants.\", usize::BITS - 1);\n     1 << value\n }\n@@ -95,7 +95,7 @@ impl<E:CLike> EnumSet<E> {\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn len(&self) -> usize {\n-        self.bits.count_ones()\n+        self.bits.count_ones() as usize\n     }\n \n     /// Returns true if the `EnumSet` is empty.\n@@ -250,7 +250,7 @@ impl<E:CLike> Iterator for Iter<E> {\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let exact = self.bits.count_ones();\n+        let exact = self.bits.count_ones() as usize;\n         (exact, Some(exact))\n     }\n }"}, {"sha": "81eef132b9c65ed30446dc0fd926e74ad9e86226", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -156,7 +156,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         deccum = deccum / radix_gen;\n         deccum = deccum.trunc();\n \n-        let c = char::from_digit(current_digit.to_int().unwrap() as u32, radix);\n+        let c = char::from_digit(current_digit.to_isize().unwrap() as u32, radix);\n         buf[end] = c.unwrap() as u8;\n         end += 1;\n \n@@ -211,7 +211,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n             // See note in first loop.\n             let current_digit = deccum.trunc().abs();\n \n-            let c = char::from_digit(current_digit.to_int().unwrap() as u32,\n+            let c = char::from_digit(current_digit.to_isize().unwrap() as u32,\n                                      radix);\n             buf[end] = c.unwrap() as u8;\n             end += 1;"}, {"sha": "4b545435ea171345a5041daf53a2b260a7231bfd", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -182,7 +182,7 @@ mod impls {\n                 }\n \n                 fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n-                    let newlen = data.len() * ::$ty::BYTES;\n+                    let newlen = data.len() * ::$ty::BYTES as usize;\n                     let ptr = data.as_ptr() as *const u8;\n                     state.write(unsafe { slice::from_raw_parts(ptr, newlen) })\n                 }"}, {"sha": "518ec05f5b980944e5c06b5116b1835bd1c3c0dc", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -2467,15 +2467,15 @@ impl<A: Int + ToPrimitive> Iterator for Range<A> {\n             Some(a) => {\n                 let sz = self.stop.to_i64().map(|b| b.checked_sub(a));\n                 match sz {\n-                    Some(Some(bound)) => bound.to_uint(),\n+                    Some(Some(bound)) => bound.to_usize(),\n                     _ => None,\n                 }\n             },\n             None => match self.state.to_u64() {\n                 Some(a) => {\n                     let sz = self.stop.to_u64().map(|b| b.checked_sub(a));\n                     match sz {\n-                        Some(Some(bound)) => bound.to_uint(),\n+                        Some(Some(bound)) => bound.to_usize(),\n                         _ => None\n                     }\n                 },\n@@ -2741,7 +2741,7 @@ impl<A: Int> Iterator for ::ops::Range<A> {\n         if self.start >= self.end {\n             (0, Some(0))\n         } else {\n-            let length = (self.end - self.start).to_uint();\n+            let length = (self.end - self.start).to_usize();\n             (length.unwrap_or(0), length)\n         }\n     }"}, {"sha": "0d8e3044eccea1374cb06a9c54737cbc45d202b5", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -23,12 +23,12 @@ use num::FpCategory as Fp;\n use option::Option;\n \n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const RADIX: uint = 2;\n+pub const RADIX: u32 = 2;\n \n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const MANTISSA_DIGITS: uint = 24;\n+pub const MANTISSA_DIGITS: u32 = 24;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const DIGITS: uint = 6;\n+pub const DIGITS: u32 = 6;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f32 = 1.19209290e-07_f32;\n@@ -57,14 +57,14 @@ pub const MIN_POSITIVE: f32 = 1.17549435e-38_f32;\n pub const MAX: f32 = 3.40282347e+38_f32;\n \n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const MIN_EXP: int = -125;\n+pub const MIN_EXP: i32 = -125;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const MAX_EXP: int = 128;\n+pub const MAX_EXP: i32 = 128;\n \n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const MIN_10_EXP: int = -37;\n+pub const MIN_10_EXP: i32 = -37;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const MAX_10_EXP: int = 38;\n+pub const MAX_10_EXP: i32 = 38;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NAN: f32 = 0.0_f32/0.0_f32;\n@@ -193,12 +193,12 @@ impl Float for f32 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS }\n+    fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS as uint }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn digits(_: Option<f32>) -> uint { DIGITS }\n+    fn digits(_: Option<f32>) -> uint { DIGITS as uint }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n@@ -208,22 +208,22 @@ impl Float for f32 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_exp(_: Option<f32>) -> int { MIN_EXP }\n+    fn min_exp(_: Option<f32>) -> int { MIN_EXP as int }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_exp(_: Option<f32>) -> int { MAX_EXP }\n+    fn max_exp(_: Option<f32>) -> int { MAX_EXP as int }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP }\n+    fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP as int }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }\n+    fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP as int }\n \n     #[inline]\n     #[unstable(feature = \"core\")]"}, {"sha": "d7e91058a46fbcb9fc38d91adc3185cd8020a897", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -27,11 +27,11 @@ use option::Option;\n // members of `Bounded` and `Float`.\n \n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const RADIX: uint = 2;\n+pub const RADIX: u32 = 2;\n \n-pub const MANTISSA_DIGITS: uint = 53;\n+pub const MANTISSA_DIGITS: u32 = 53;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const DIGITS: uint = 15;\n+pub const DIGITS: u32 = 15;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n@@ -60,14 +60,14 @@ pub const MIN_POSITIVE: f64 = 2.2250738585072014e-308_f64;\n pub const MAX: f64 = 1.7976931348623157e+308_f64;\n \n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const MIN_EXP: int = -1021;\n+pub const MIN_EXP: i32 = -1021;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const MAX_EXP: int = 1024;\n+pub const MAX_EXP: i32 = 1024;\n \n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const MIN_10_EXP: int = -307;\n+pub const MIN_10_EXP: i32 = -307;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub const MAX_10_EXP: int = 308;\n+pub const MAX_10_EXP: i32 = 308;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NAN: f64 = 0.0_f64/0.0_f64;\n@@ -200,12 +200,12 @@ impl Float for f64 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS }\n+    fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS as uint }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn digits(_: Option<f64>) -> uint { DIGITS }\n+    fn digits(_: Option<f64>) -> uint { DIGITS as uint }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n@@ -215,22 +215,22 @@ impl Float for f64 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_exp(_: Option<f64>) -> int { MIN_EXP }\n+    fn min_exp(_: Option<f64>) -> int { MIN_EXP as int }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_exp(_: Option<f64>) -> int { MAX_EXP }\n+    fn max_exp(_: Option<f64>) -> int { MAX_EXP as int }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP }\n+    fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP as int }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP }\n+    fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP as int }\n \n     #[inline]\n     #[unstable(feature = \"core\")]"}, {"sha": "fe0d6d13c4c06483649bdbf737fe89c68048cf43", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -15,11 +15,11 @@ macro_rules! int_module { ($T:ty, $bits:expr) => (\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n #[unstable(feature = \"core\")]\n-pub const BITS : uint = $bits;\n+pub const BITS : u32 = $bits;\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n #[unstable(feature = \"core\")]\n-pub const BYTES : uint = ($bits / 8);\n+pub const BYTES : u32 = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::min_value` function."}, {"sha": "d77a1eb4203c6b4bf786a6c5c6c93f29537c75ba", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 85, "deletions": 25, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -86,7 +86,7 @@ pub trait Int\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn count_ones(self) -> uint;\n+    fn count_ones(self) -> u32;\n \n     /// Returns the number of zeros in the binary representation of `self`.\n     ///\n@@ -102,7 +102,7 @@ pub trait Int\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n-    fn count_zeros(self) -> uint {\n+    fn count_zeros(self) -> u32 {\n         (!self).count_ones()\n     }\n \n@@ -120,7 +120,7 @@ pub trait Int\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn leading_zeros(self) -> uint;\n+    fn leading_zeros(self) -> u32;\n \n     /// Returns the number of trailing zeros in the binary representation\n     /// of `self`.\n@@ -136,7 +136,7 @@ pub trait Int\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn trailing_zeros(self) -> uint;\n+    fn trailing_zeros(self) -> u32;\n \n     /// Shifts the bits to the left by a specified amount amount, `n`, wrapping\n     /// the truncated bits to the end of the resulting integer.\n@@ -153,7 +153,7 @@ pub trait Int\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn rotate_left(self, n: uint) -> Self;\n+    fn rotate_left(self, n: u32) -> Self;\n \n     /// Shifts the bits to the right by a specified amount amount, `n`, wrapping\n     /// the truncated bits to the beginning of the resulting integer.\n@@ -170,7 +170,7 @@ pub trait Int\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn rotate_right(self, n: uint) -> Self;\n+    fn rotate_right(self, n: u32) -> Self;\n \n     /// Reverses the byte order of the integer.\n     ///\n@@ -418,23 +418,23 @@ macro_rules! uint_impl {\n             fn max_value() -> $T { -1 }\n \n             #[inline]\n-            fn count_ones(self) -> uint { unsafe { $ctpop(self as $ActualT) as uint } }\n+            fn count_ones(self) -> u32 { unsafe { $ctpop(self as $ActualT) as u32 } }\n \n             #[inline]\n-            fn leading_zeros(self) -> uint { unsafe { $ctlz(self as $ActualT) as uint } }\n+            fn leading_zeros(self) -> u32 { unsafe { $ctlz(self as $ActualT) as u32 } }\n \n             #[inline]\n-            fn trailing_zeros(self) -> uint { unsafe { $cttz(self as $ActualT) as uint } }\n+            fn trailing_zeros(self) -> u32 { unsafe { $cttz(self as $ActualT) as u32 } }\n \n             #[inline]\n-            fn rotate_left(self, n: uint) -> $T {\n+            fn rotate_left(self, n: u32) -> $T {\n                 // Protect against undefined behaviour for over-long bit shifts\n                 let n = n % $BITS;\n                 (self << n) | (self >> (($BITS - n) % $BITS))\n             }\n \n             #[inline]\n-            fn rotate_right(self, n: uint) -> $T {\n+            fn rotate_right(self, n: u32) -> $T {\n                 // Protect against undefined behaviour for over-long bit shifts\n                 let n = n % $BITS;\n                 (self >> n) | (self << (($BITS - n) % $BITS))\n@@ -549,19 +549,19 @@ macro_rules! int_impl {\n             fn max_value() -> $T { let min: $T = Int::min_value(); !min }\n \n             #[inline]\n-            fn count_ones(self) -> uint { (self as $UnsignedT).count_ones() }\n+            fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n \n             #[inline]\n-            fn leading_zeros(self) -> uint { (self as $UnsignedT).leading_zeros() }\n+            fn leading_zeros(self) -> u32 { (self as $UnsignedT).leading_zeros() }\n \n             #[inline]\n-            fn trailing_zeros(self) -> uint { (self as $UnsignedT).trailing_zeros() }\n+            fn trailing_zeros(self) -> u32 { (self as $UnsignedT).trailing_zeros() }\n \n             #[inline]\n-            fn rotate_left(self, n: uint) -> $T { (self as $UnsignedT).rotate_left(n) as $T }\n+            fn rotate_left(self, n: u32) -> $T { (self as $UnsignedT).rotate_left(n) as $T }\n \n             #[inline]\n-            fn rotate_right(self, n: uint) -> $T { (self as $UnsignedT).rotate_right(n) as $T }\n+            fn rotate_right(self, n: u32) -> $T { (self as $UnsignedT).rotate_right(n) as $T }\n \n             #[inline]\n             fn swap_bytes(self) -> $T { (self as $UnsignedT).swap_bytes() as $T }\n@@ -706,7 +706,7 @@ pub trait UnsignedInt: Int {\n     fn next_power_of_two(self) -> Self {\n         let bits = size_of::<Self>() * 8;\n         let one: Self = Int::one();\n-        one << ((bits - (self - one).leading_zeros()) % bits)\n+        one << ((bits - (self - one).leading_zeros() as usize) % bits)\n     }\n \n     /// Returns the smallest power of two greater than or equal to `n`. If the\n@@ -743,8 +743,16 @@ impl UnsignedInt for u64 {}\n pub trait ToPrimitive {\n     /// Converts the value of `self` to an `int`.\n     #[inline]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use to_isize\")]\n     fn to_int(&self) -> Option<int> {\n-        self.to_i64().and_then(|x| x.to_int())\n+        self.to_i64().and_then(|x| x.to_isize())\n+    }\n+\n+    /// Converts the value of `self` to an `isize`.\n+    #[inline]\n+    fn to_isize(&self) -> Option<isize> {\n+        self.to_i64().and_then(|x| x.to_isize())\n     }\n \n     /// Converts the value of `self` to an `i8`.\n@@ -770,8 +778,16 @@ pub trait ToPrimitive {\n \n     /// Converts the value of `self` to an `uint`.\n     #[inline]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use to_usize\")]\n     fn to_uint(&self) -> Option<uint> {\n-        self.to_u64().and_then(|x| x.to_uint())\n+        self.to_u64().and_then(|x| x.to_usize())\n+    }\n+\n+    /// Converts the value of `self` to a `usize`.\n+    #[inline]\n+    fn to_usize(&self) -> Option<usize> {\n+        self.to_u64().and_then(|x| x.to_usize())\n     }\n \n     /// Converts the value of `self` to an `u8`.\n@@ -848,6 +864,8 @@ macro_rules! impl_to_primitive_int {\n             #[inline]\n             fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int, *self) }\n             #[inline]\n+            fn to_isize(&self) -> Option<isize> { impl_to_primitive_int_to_int!($T, isize, *self) }\n+            #[inline]\n             fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8, *self) }\n             #[inline]\n             fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16, *self) }\n@@ -859,6 +877,8 @@ macro_rules! impl_to_primitive_int {\n             #[inline]\n             fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint, *self) }\n             #[inline]\n+            fn to_usize(&self) -> Option<usize> { impl_to_primitive_int_to_uint!($T, usize, *self) }\n+            #[inline]\n             fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8, *self) }\n             #[inline]\n             fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16, *self) }\n@@ -875,7 +895,7 @@ macro_rules! impl_to_primitive_int {\n     )\n }\n \n-impl_to_primitive_int! { int }\n+impl_to_primitive_int! { isize }\n impl_to_primitive_int! { i8 }\n impl_to_primitive_int! { i16 }\n impl_to_primitive_int! { i32 }\n@@ -918,6 +938,8 @@ macro_rules! impl_to_primitive_uint {\n             #[inline]\n             fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int, *self) }\n             #[inline]\n+            fn to_isize(&self) -> Option<int> { impl_to_primitive_uint_to_int!(isize, *self) }\n+            #[inline]\n             fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8, *self) }\n             #[inline]\n             fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16, *self) }\n@@ -929,6 +951,8 @@ macro_rules! impl_to_primitive_uint {\n             #[inline]\n             fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint, *self) }\n             #[inline]\n+            fn to_usize(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, usize, *self) }\n+            #[inline]\n             fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8, *self) }\n             #[inline]\n             fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16, *self) }\n@@ -945,7 +969,7 @@ macro_rules! impl_to_primitive_uint {\n     )\n }\n \n-impl_to_primitive_uint! { uint }\n+impl_to_primitive_uint! { usize }\n impl_to_primitive_uint! { u8 }\n impl_to_primitive_uint! { u16 }\n impl_to_primitive_uint! { u32 }\n@@ -973,6 +997,8 @@ macro_rules! impl_to_primitive_float {\n             #[inline]\n             fn to_int(&self) -> Option<int> { Some(*self as int) }\n             #[inline]\n+            fn to_isize(&self) -> Option<int> { Some(*self as isize) }\n+            #[inline]\n             fn to_i8(&self) -> Option<i8> { Some(*self as i8) }\n             #[inline]\n             fn to_i16(&self) -> Option<i16> { Some(*self as i16) }\n@@ -984,6 +1010,8 @@ macro_rules! impl_to_primitive_float {\n             #[inline]\n             fn to_uint(&self) -> Option<uint> { Some(*self as uint) }\n             #[inline]\n+            fn to_usize(&self) -> Option<uint> { Some(*self as usize) }\n+            #[inline]\n             fn to_u8(&self) -> Option<u8> { Some(*self as u8) }\n             #[inline]\n             fn to_u16(&self) -> Option<u16> { Some(*self as u16) }\n@@ -1009,10 +1037,19 @@ pub trait FromPrimitive : ::marker::Sized {\n     /// Convert an `int` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n     #[inline]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use from_isize\")]\n     fn from_int(n: int) -> Option<Self> {\n         FromPrimitive::from_i64(n as i64)\n     }\n \n+    /// Convert an `isize` to return an optional value of this type. If the\n+    /// value cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_isize(n: isize) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+\n     /// Convert an `i8` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n@@ -1041,10 +1078,19 @@ pub trait FromPrimitive : ::marker::Sized {\n     /// Convert an `uint` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use from_usize\")]\n     fn from_uint(n: uint) -> Option<Self> {\n         FromPrimitive::from_u64(n as u64)\n     }\n \n+    /// Convert a `usize` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_usize(n: usize) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n+\n     /// Convert an `u8` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n@@ -1087,8 +1133,15 @@ pub trait FromPrimitive : ::marker::Sized {\n \n /// A utility function that just calls `FromPrimitive::from_int`.\n #[unstable(feature = \"core\", reason = \"likely to be removed\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use from_isize\")]\n pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n-    FromPrimitive::from_int(n)\n+    FromPrimitive::from_isize(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_isize`.\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n+pub fn from_isize<A: FromPrimitive>(n: isize) -> Option<A> {\n+    FromPrimitive::from_isize(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i8`.\n@@ -1117,8 +1170,15 @@ pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n \n /// A utility function that just calls `FromPrimitive::from_uint`.\n #[unstable(feature = \"core\", reason = \"likely to be removed\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use from_uint\")]\n pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n-    FromPrimitive::from_uint(n)\n+    FromPrimitive::from_usize(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_usize`.\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n+pub fn from_usize<A: FromPrimitive>(n: usize) -> Option<A> {\n+    FromPrimitive::from_usize(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u8`.\n@@ -1718,12 +1778,12 @@ macro_rules! from_str_radix_int_impl {\n         }\n     }\n }\n-from_str_radix_int_impl! { int }\n+from_str_radix_int_impl! { isize }\n from_str_radix_int_impl! { i8 }\n from_str_radix_int_impl! { i16 }\n from_str_radix_int_impl! { i32 }\n from_str_radix_int_impl! { i64 }\n-from_str_radix_int_impl! { uint }\n+from_str_radix_int_impl! { usize }\n from_str_radix_int_impl! { u8 }\n from_str_radix_int_impl! { u16 }\n from_str_radix_int_impl! { u32 }"}, {"sha": "330f0b91bf18303c6f7bde9deda735b2b9b6a6c5", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -13,9 +13,9 @@\n macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => (\n \n #[unstable(feature = \"core\")]\n-pub const BITS : uint = $bits;\n+pub const BITS : u32 = $bits;\n #[unstable(feature = \"core\")]\n-pub const BYTES : uint = ($bits / 8);\n+pub const BYTES : u32 = ($bits / 8);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: $T = 0 as $T;"}, {"sha": "9f18a0e88e7398c49d41a2680b65ea2c0ddd25cb", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -1837,7 +1837,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n         debug!(\">> Side table document with tag 0x{:x} \\\n                 found for id {} (orig {})\",\n                tag, id, id0);\n-        let decoded_tag: Option<c::astencode_tag> = FromPrimitive::from_uint(tag);\n+        let decoded_tag: Option<c::astencode_tag> = FromPrimitive::from_usize(tag);\n         match decoded_tag {\n             None => {\n                 dcx.tcx.sess.bug("}, {"sha": "faed3f5977fdcb01b67747b6867ac5d6ecf909dc", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -205,7 +205,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                oper: O,\n                id_range: IdRange,\n                bits_per_id: uint) -> DataFlowContext<'a, 'tcx, O> {\n-        let words_per_id = (bits_per_id + usize::BITS - 1) / usize::BITS;\n+        let words_per_id = (bits_per_id + usize::BITS as usize - 1) / usize::BITS as usize;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n         debug!(\"DataFlowContext::new(analysis_name: {}, id_range={:?}, \\\n@@ -377,7 +377,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         for (word_index, &word) in words.iter().enumerate() {\n             if word != 0 {\n-                let base_index = word_index * usize::BITS;\n+                let base_index = word_index * usize::BITS as usize;\n                 for offset in 0..usize::BITS {\n                     let bit = 1 << offset;\n                     if (word & bit) != 0 {\n@@ -390,7 +390,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                         // whether the bit_index is greater than the\n                         // actual value the user specified and stop\n                         // iterating if so.\n-                        let bit_index = base_index + offset;\n+                        let bit_index = base_index + offset as usize;\n                         if bit_index >= self.bits_per_id {\n                             return true;\n                         } else if !f(bit_index) {\n@@ -609,8 +609,8 @@ fn bitwise<Op:BitwiseOperator>(out_vec: &mut [uint],\n fn set_bit(words: &mut [uint], bit: uint) -> bool {\n     debug!(\"set_bit: words={} bit={}\",\n            mut_bits_to_string(words), bit_str(bit));\n-    let word = bit / usize::BITS;\n-    let bit_in_word = bit % usize::BITS;\n+    let word = bit / usize::BITS as usize;\n+    let bit_in_word = bit % usize::BITS as usize;\n     let bit_mask = 1 << bit_in_word;\n     debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, word);\n     let oldv = words[word];"}, {"sha": "3525d46a1f2f1ee02070a104642ac10e03676be3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -71,7 +71,7 @@ impl LanguageItems {\n     }\n \n     pub fn item_name(index: uint) -> &'static str {\n-        let item: Option<LangItem> = FromPrimitive::from_uint(index);\n+        let item: Option<LangItem> = FromPrimitive::from_usize(index);\n         match item {\n             $( Some($variant) => $name, )*\n             None => \"???\""}, {"sha": "ca2e6ba5d5dfb229135a72ad6321db18091a2967", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -253,7 +253,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n         deccum = deccum / radix_gen;\n         deccum = deccum.trunc();\n \n-        buf.push(char::from_digit(current_digit.to_int().unwrap() as u32, radix)\n+        buf.push(char::from_digit(current_digit.to_isize().unwrap() as u32, radix)\n              .unwrap() as u8);\n \n         // No more digits to calculate for the non-fractional part -> break\n@@ -310,7 +310,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n             let current_digit = deccum.trunc().abs();\n \n             buf.push(char::from_digit(\n-                current_digit.to_int().unwrap() as u32, radix).unwrap() as u8);\n+                current_digit.to_isize().unwrap() as u32, radix).unwrap() as u8);\n \n             // Decrease the deccumulator one fractional digit at a time\n             deccum = deccum.fract();"}, {"sha": "728a5dac4e4c9316a8bf2e8211bff2f4436c0641", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -714,28 +714,28 @@ pub trait Reader {\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_le_uint(&mut self) -> IoResult<uint> {\n-        self.read_le_uint_n(usize::BYTES).map(|i| i as uint)\n+        self.read_le_uint_n(usize::BYTES as usize).map(|i| i as uint)\n     }\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_le_int(&mut self) -> IoResult<int> {\n-        self.read_le_int_n(isize::BYTES).map(|i| i as int)\n+        self.read_le_int_n(isize::BYTES as usize).map(|i| i as int)\n     }\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_be_uint(&mut self) -> IoResult<uint> {\n-        self.read_be_uint_n(usize::BYTES).map(|i| i as uint)\n+        self.read_be_uint_n(usize::BYTES as usize).map(|i| i as uint)\n     }\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_be_int(&mut self) -> IoResult<int> {\n-        self.read_be_int_n(isize::BYTES).map(|i| i as int)\n+        self.read_be_int_n(isize::BYTES as usize).map(|i| i as int)\n     }\n \n     /// Reads a big-endian `u64`.\n@@ -1098,25 +1098,25 @@ pub trait Writer {\n     /// Write a little-endian uint (number of bytes depends on system).\n     #[inline]\n     fn write_le_uint(&mut self, n: uint) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n+        extensions::u64_to_le_bytes(n as u64, usize::BYTES as usize, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian int (number of bytes depends on system).\n     #[inline]\n     fn write_le_int(&mut self, n: int) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n+        extensions::u64_to_le_bytes(n as u64, isize::BYTES as usize, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian uint (number of bytes depends on system).\n     #[inline]\n     fn write_be_uint(&mut self, n: uint) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n+        extensions::u64_to_be_bytes(n as u64, usize::BYTES as usize, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian int (number of bytes depends on system).\n     #[inline]\n     fn write_be_int(&mut self, n: int) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n+        extensions::u64_to_be_bytes(n as u64, isize::BYTES as usize, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian u64 (8 bytes)."}, {"sha": "4e9f9c80a1821c9996dba6a4c6fe6fac8309b3fc", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -194,12 +194,12 @@ mod select {\n     #[repr(C)]\n     pub struct fd_set {\n         // FIXME: shouldn't this be a c_ulong?\n-        fds_bits: [libc::uintptr_t; (FD_SETSIZE / usize::BITS)]\n+        fds_bits: [libc::uintptr_t; (FD_SETSIZE / usize::BITS as usize)]\n     }\n \n     pub fn fd_set(set: &mut fd_set, fd: i32) {\n         let fd = fd as uint;\n-        set.fds_bits[fd / usize::BITS] |= 1 << (fd % usize::BITS);\n+        set.fds_bits[fd / usize::BITS as usize] |= 1 << (fd % usize::BITS as usize);\n     }\n }\n "}, {"sha": "42812e1e597bccdf64514b733bb19852f01b2a1a", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -210,11 +210,11 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n \n     fn mean(&self) -> T {\n         assert!(self.len() != 0);\n-        self.sum() / FromPrimitive::from_uint(self.len()).unwrap()\n+        self.sum() / FromPrimitive::from_usize(self.len()).unwrap()\n     }\n \n     fn median(&self) -> T {\n-        self.percentile(FromPrimitive::from_uint(50).unwrap())\n+        self.percentile(FromPrimitive::from_usize(50).unwrap())\n     }\n \n     fn var(&self) -> T {\n@@ -230,7 +230,7 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n             // NB: this is _supposed to be_ len-1, not len. If you\n             // change it back to len, you will be calculating a\n             // population variance, not a sample variance.\n-            let denom = FromPrimitive::from_uint(self.len()-1).unwrap();\n+            let denom = FromPrimitive::from_usize(self.len()-1).unwrap();\n             v/denom\n         }\n     }\n@@ -240,7 +240,7 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n     }\n \n     fn std_dev_pct(&self) -> T {\n-        let hundred = FromPrimitive::from_uint(100).unwrap();\n+        let hundred = FromPrimitive::from_usize(100).unwrap();\n         (self.std_dev() / self.mean()) * hundred\n     }\n \n@@ -254,7 +254,7 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n     }\n \n     fn median_abs_dev_pct(&self) -> T {\n-        let hundred = FromPrimitive::from_uint(100).unwrap();\n+        let hundred = FromPrimitive::from_usize(100).unwrap();\n         (self.median_abs_dev() / self.median()) * hundred\n     }\n \n@@ -267,11 +267,11 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n     fn quartiles(&self) -> (T,T,T) {\n         let mut tmp = self.to_vec();\n         local_sort(&mut tmp);\n-        let first = FromPrimitive::from_uint(25).unwrap();\n+        let first = FromPrimitive::from_usize(25).unwrap();\n         let a = percentile_of_sorted(&tmp, first);\n-        let secound = FromPrimitive::from_uint(50).unwrap();\n+        let secound = FromPrimitive::from_usize(50).unwrap();\n         let b = percentile_of_sorted(&tmp, secound);\n-        let third = FromPrimitive::from_uint(75).unwrap();\n+        let third = FromPrimitive::from_usize(75).unwrap();\n         let c = percentile_of_sorted(&tmp, third);\n         (a,b,c)\n     }\n@@ -293,16 +293,16 @@ fn percentile_of_sorted<T: Float + FromPrimitive>(sorted_samples: &[T],\n     }\n     let zero: T = Float::zero();\n     assert!(zero <= pct);\n-    let hundred = FromPrimitive::from_uint(100).unwrap();\n+    let hundred = FromPrimitive::from_usize(100).unwrap();\n     assert!(pct <= hundred);\n     if pct == hundred {\n         return sorted_samples[sorted_samples.len() - 1];\n     }\n-    let length = FromPrimitive::from_uint(sorted_samples.len() - 1).unwrap();\n+    let length = FromPrimitive::from_usize(sorted_samples.len() - 1).unwrap();\n     let rank = (pct / hundred) * length;\n     let lrank = rank.floor();\n     let d = rank - lrank;\n-    let n = lrank.to_uint().unwrap();\n+    let n = lrank.to_usize().unwrap();\n     let lo = sorted_samples[n];\n     let hi = sorted_samples[n+1];\n     lo + (hi - lo) * d\n@@ -319,7 +319,7 @@ pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n     let mut tmp = samples.to_vec();\n     local_sort(&mut tmp);\n     let lo = percentile_of_sorted(&tmp, pct);\n-    let hundred: T = FromPrimitive::from_uint(100).unwrap();\n+    let hundred: T = FromPrimitive::from_usize(100).unwrap();\n     let hi = percentile_of_sorted(&tmp, hundred-pct);\n     for samp in samples {\n         if *samp > hi {"}, {"sha": "a6f4b8299cb6898284ffa9e784b610173aad9cb7", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5457eab3c5f1abeb0ba4e9275d55a398f6a09134/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=5457eab3c5f1abeb0ba4e9275d55a398f6a09134", "patch": "@@ -53,7 +53,7 @@ impl Drop for DropCounter {\n }\n \n pub fn main() {\n-    assert!(MAX_LEN <= std::usize::BITS);\n+    assert!(MAX_LEN <= std::usize::BITS as usize);\n     // len can't go above 64.\n     for len in 2..MAX_LEN {\n         for _ in 0..REPEATS {"}]}