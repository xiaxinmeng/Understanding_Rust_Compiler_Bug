{"sha": "aaa53ec8531565e2f5721548b5a38c0062aa0e51", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhYTUzZWM4NTMxNTY1ZTJmNTcyMTU0OGI1YTM4YzAwNjJhYTBlNTE=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-03-16T00:04:02Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-06-05T20:09:26Z"}, "message": "Implemented for traits (associated type definitions).", "tree": {"sha": "eaaa5e4630770263fe3321afdc05fc4f539ff664", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaaa5e4630770263fe3321afdc05fc4f539ff664"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aaa53ec8531565e2f5721548b5a38c0062aa0e51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aaa53ec8531565e2f5721548b5a38c0062aa0e51", "html_url": "https://github.com/rust-lang/rust/commit/aaa53ec8531565e2f5721548b5a38c0062aa0e51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aaa53ec8531565e2f5721548b5a38c0062aa0e51/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3816958f18ea6c8990d64d03da839e5a180b0b9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3816958f18ea6c8990d64d03da839e5a180b0b9b", "html_url": "https://github.com/rust-lang/rust/commit/3816958f18ea6c8990d64d03da839e5a180b0b9b"}], "stats": {"total": 563, "additions": 313, "deletions": 250}, "files": [{"sha": "da4d41c9d872fcfe0a108da64b04f1ba1313cf77", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=aaa53ec8531565e2f5721548b5a38c0062aa0e51", "patch": "@@ -626,6 +626,9 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyKind::CVarArgs(ref lt) => {\n             visitor.visit_lifetime(lt)\n         }\n+        TyKind::AssocTyExistential(ref bounds) => {\n+            walk_list!(visitor, visit_param_bound, bounds);\n+        }\n         TyKind::Infer | TyKind::Err => {}\n     }\n }"}, {"sha": "2c2cd6a2f6f53e49280a5cf63ff54503b42f4aa0", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=aaa53ec8531565e2f5721548b5a38c0062aa0e51", "patch": "@@ -195,6 +195,12 @@ enum ImplTraitContext<'a> {\n     /// (e.g., for consts and statics).\n     Existential(Option<DefId> /* fn def-ID */),\n \n+    /// Treat `impl Trait` as a bound on the associated type applied to the trait.\n+    /// Example: `trait Foo { type Bar: Iterator<Item = impl Debug>; }` is conceptually\n+    /// equivalent to `trait Foo where <Self::Bar as Iterator>::Item: Debug\n+    /// { type Bar: Iterator; }`.\n+    AssociatedTy,\n+\n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n }\n@@ -217,6 +223,7 @@ impl<'a> ImplTraitContext<'a> {\n         match self {\n             Universal(params) => Universal(params),\n             Existential(fn_def_id) => Existential(*fn_def_id),\n+            AssociatedTy => AssociatedTy,\n             Disallowed(pos) => Disallowed(*pos),\n         }\n     }\n@@ -1537,6 +1544,16 @@ impl<'a> LoweringContext<'a> {\n                             }),\n                         ))\n                     }\n+                    ImplTraitContext::AssociatedTy => {\n+                        let hir_bounds = self.lower_param_bounds(\n+                            bounds,\n+                            ImplTraitContext::AssociatedTy,\n+                        );\n+\n+                        hir::TyKind::AssocTyExistential(\n+                            hir_bounds,\n+                        )\n+                    }\n                     ImplTraitContext::Disallowed(pos) => {\n                         let allowed_in = if self.sess.features_untracked()\n                                                 .impl_trait_in_bindings {\n@@ -1640,8 +1657,8 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    /// Registers a new existential type with the proper `NodeId`ss and\n-    /// returns the lowered node ID for the existential type.\n+    /// Registers a new existential type with the proper `NodeId`s and\n+    /// returns the lowered node-ID for the existential type.\n     fn generate_existential_type(\n         &mut self,\n         exist_ty_node_id: NodeId,\n@@ -2226,8 +2243,9 @@ impl<'a> LoweringContext<'a> {\n         (\n             hir::GenericArgs {\n                 args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n-                bindings: constraints.iter().map(\n-                    |b| self.lower_assoc_ty_constraint(b, itctx.reborrow())).collect(),\n+                bindings: constraints.iter()\n+                    .map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow()))\n+                    .collect(),\n                 parenthesized: false,\n             },\n             !has_types && param_mode == ParamMode::Optional\n@@ -3257,13 +3275,13 @@ impl<'a> LoweringContext<'a> {\n             ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n             ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n             ItemKind::Ty(ref t, ref generics) => hir::ItemKind::Ty(\n-                self.lower_ty(t, ImplTraitContext::disallowed()),\n-                self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                self.lower_ty(t, ImplTraitContext::AssociatedTy),\n+                self.lower_generics(generics, ImplTraitContext::AssociatedTy),\n             ),\n             ItemKind::Existential(ref b, ref generics) => hir::ItemKind::Existential(\n                 hir::ExistTy {\n-                    generics: self.lower_generics(generics, ImplTraitContext::disallowed()),\n-                    bounds: self.lower_param_bounds(b, ImplTraitContext::Existential(None)),\n+                    generics: self.lower_generics(generics, ImplTraitContext::AssociatedTy),\n+                    bounds: self.lower_param_bounds(b, ImplTraitContext::AssociatedTy),\n                     impl_trait_fn: None,\n                     origin: hir::ExistTyOrigin::ExistentialType,\n                 },\n@@ -3276,20 +3294,20 @@ impl<'a> LoweringContext<'a> {\n                         .map(|x| self.lower_variant(x))\n                         .collect(),\n                 },\n-                self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                self.lower_generics(generics, ImplTraitContext::AssociatedTy),\n             ),\n             ItemKind::Struct(ref struct_def, ref generics) => {\n                 let struct_def = self.lower_variant_data(struct_def);\n                 hir::ItemKind::Struct(\n                     struct_def,\n-                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                    self.lower_generics(generics, ImplTraitContext::AssociatedTy),\n                 )\n             }\n             ItemKind::Union(ref vdata, ref generics) => {\n                 let vdata = self.lower_variant_data(vdata);\n                 hir::ItemKind::Union(\n                     vdata,\n-                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                    self.lower_generics(generics, ImplTraitContext::AssociatedTy),\n                 )\n             }\n             ItemKind::Impl(\n@@ -3656,15 +3674,17 @@ impl<'a> LoweringContext<'a> {\n                 );\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n             }\n-            TraitItemKind::Type(ref bounds, ref default) => (\n-                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n-                hir::TraitItemKind::Type(\n-                    self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n+            TraitItemKind::Type(ref bounds, ref default) => {\n+                let generics = self.lower_generics(&i.generics, ImplTraitContext::AssociatedTy);\n+                let node = hir::TraitItemKind::Type(\n+                    self.lower_param_bounds(bounds, ImplTraitContext::AssociatedTy),\n                     default\n                         .as_ref()\n                         .map(|x| self.lower_ty(x, ImplTraitContext::disallowed())),\n-                ),\n-            ),\n+                );\n+\n+                (generics, node)\n+            },\n             TraitItemKind::Macro(..) => bug!(\"macro item shouldn't exist at this point\"),\n         };\n "}, {"sha": "20968ec6a63bebae63b5a9475bf0f1dd5e9956f1", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=aaa53ec8531565e2f5721548b5a38c0062aa0e51", "patch": "@@ -1898,6 +1898,8 @@ pub enum TyKind {\n     /// Placeholder for C-variadic arguments. We \"spoof\" the `VaList` created\n     /// from the variadic arguments. This type is only valid up to typeck.\n     CVarArgs(Lifetime),\n+    /// The existential type (i.e., `impl Trait`) that constrains an associated type.\n+    AssocTyExistential(HirVec<GenericBound>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]"}, {"sha": "c8f9e4c7043e026313bccff787026bb3b9cbbabd", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=aaa53ec8531565e2f5721548b5a38c0062aa0e51", "patch": "@@ -409,6 +409,9 @@ impl<'a> State<'a> {\n             hir::TyKind::CVarArgs(_) => {\n                 self.s.word(\"...\")?;\n             }\n+            hir::TyKind::AssocTyExistential(ref bounds) => {\n+                self.print_bounds(\":\", bounds)?;\n+            }\n         }\n         self.end()\n     }"}, {"sha": "2127fbbd56e931df8dc914f7006e5fec9c159692", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=aaa53ec8531565e2f5721548b5a38c0062aa0e51", "patch": "@@ -948,15 +948,17 @@ pub fn may_define_existential_type(\n     let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     trace!(\n         \"may_define_existential_type(def={:?}, opaque_node={:?})\",\n-        tcx.hir().get(hir_id),\n-        tcx.hir().get(opaque_hir_id)\n+        tcx.hir().get_by_hir_id(hir_id),\n+        tcx.hir().get_by_hir_id(opaque_hir_id)\n     );\n \n     // Named existential types can be defined by any siblings or children of siblings.\n-    let scope_id = tcx.hir().get_defining_scope(opaque_hir_id)\n-                            .expect(\"could not get defining scope\");\n+    let scope_node_id = tcx.hir()\n+        .get_defining_scope(tcx.hir().hir_to_node_id(opaque_hir_id))\n+        .expect(\"could not get defining scope\");\n+    let scope_id = tcx.hir().node_to_hir_id(scope_node_id);\n     // We walk up the node tree until we hit the root or the scope of the opaque type.\n-    while hir_id != scope_id && hir_id != ast::CRATE_hir_ID {\n+    while hir_id != scope_id && hir_id != hir::CRATE_HIR_ID {\n         hir_id = tcx.hir().get_parent_item(hir_id);\n     }\n     // Syntactically, we are allowed to define the concrete type if:"}, {"sha": "fe24eab9f4439268fc092d5c318507ada45dc7eb", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=aaa53ec8531565e2f5721548b5a38c0062aa0e51", "patch": "@@ -726,7 +726,8 @@ impl<'a> ReplaceBodyWithLoop<'a> {\n                                 any_assoc_ty_bounds ||\n                                 any_involves_impl_trait(types.into_iter()) ||\n                                 any_involves_impl_trait(data.constraints.iter().filter_map(|c| {\n-                                    if let ast::AssocTyConstraintKind::Equality { ref ty } = c.kind {\n+                                    if let ast::AssocTyConstraintKind::Equality { ref ty }\n+                                            = c.kind {\n                                         Some(ty)\n                                     } else {\n                                         None"}, {"sha": "6d01328cd16e686bb08ed3342bcf96efc8010cfd", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=aaa53ec8531565e2f5721548b5a38c0062aa0e51", "patch": "@@ -1040,12 +1040,11 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         if !self.in_body {\n             // Avoid calling `hir_trait_to_predicates` in bodies, it will ICE.\n             // The traits' privacy in bodies is already checked as a part of trait object types.\n-            let (principal, projections) =\n-                rustc_typeck::hir_trait_to_predicates(self.tcx, trait_ref);\n+            let (principal, bounds) = rustc_typeck::hir_trait_to_predicates(self.tcx, trait_ref);\n             if self.visit_trait(*principal.skip_binder()) {\n                 return;\n             }\n-            for (poly_predicate, _) in projections {\n+            for (poly_predicate, _) in bounds.projection_bounds {\n                 let tcx = self.tcx;\n                 if self.visit(poly_predicate.skip_binder().ty) ||\n                    self.visit_trait(poly_predicate.skip_binder().projection_ty.trait_ref(tcx)) {"}, {"sha": "6123ee2af6e888cc6ee13ffe042ac942c0dc4f80", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 217, "deletions": 72, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=aaa53ec8531565e2f5721548b5a38c0062aa0e51", "patch": "@@ -8,6 +8,7 @@ use crate::hir::def::{CtorOf, Res, DefKind};\n use crate::hir::def_id::DefId;\n use crate::hir::HirVec;\n use crate::lint;\n+use crate::middle::lang_items::SizedTraitLangItem;\n use crate::middle::resolve_lifetime as rl;\n use crate::namespace::Namespace;\n use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n@@ -86,12 +87,22 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span);\n }\n \n+pub enum SizedByDefault {\n+    Yes,\n+    No,\n+}\n+\n struct ConvertedBinding<'tcx> {\n     item_name: ast::Ident,\n-    ty: Ty<'tcx>,\n+    kind: ConvertedBindingKind<'tcx>,\n     span: Span,\n }\n \n+enum ConvertedBindingKind<'tcx> {\n+    Equality(Ty<'tcx>),\n+    Constraint(P<[hir::GenericBound]>),\n+}\n+\n #[derive(PartialEq)]\n enum GenericArgPosition {\n     Type,\n@@ -562,10 +573,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// set of substitutions. This may involve applying defaulted type parameters.\n     ///\n     /// Note that the type listing given here is *exactly* what the user provided.\n-    fn create_substs_for_ast_path(&self,\n+    fn create_substs_for_ast_path<'a>(&self,\n         span: Span,\n         def_id: DefId,\n-        generic_args: &hir::GenericArgs,\n+        generic_args: &'a hir::GenericArgs,\n         infer_types: bool,\n         self_ty: Option<Ty<'tcx>>)\n         -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'tcx>>, Option<Vec<Span>>)\n@@ -688,13 +699,20 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             },\n         );\n \n-        let assoc_bindings = generic_args.bindings.iter().map(|binding| {\n-            ConvertedBinding {\n-                item_name: binding.ident,\n-                ty: self.ast_ty_to_ty(&binding.ty),\n-                span: binding.span,\n-            }\n-        }).collect();\n+        let assoc_bindings = generic_args.bindings.iter()\n+            .map(|binding| {\n+                let kind = if let hir::TyKind::AssocTyExistential(ref bounds) = binding.ty.node {\n+                    ConvertedBindingKind::Constraint(bounds.clone())\n+                } else {\n+                    ConvertedBindingKind::Equality(self.ast_ty_to_ty(&binding.ty))\n+                };\n+                ConvertedBinding {\n+                    item_name: binding.ident,\n+                    kind,\n+                    span: binding.span,\n+                }\n+            })\n+            .collect();\n \n         debug!(\"create_substs_for_ast_path(generic_params={:?}, self_ty={:?}) -> {:?}\",\n                generic_params, self_ty, substs);\n@@ -725,7 +743,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     pub(super) fn instantiate_poly_trait_ref_inner(&self,\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>,\n-        poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n+        bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n     ) -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n     {\n@@ -744,36 +762,40 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n \n         let mut dup_bindings = FxHashMap::default();\n-        poly_projections.extend(assoc_bindings.iter().filter_map(|binding| {\n-            // specify type to assert that error was already reported in Err case:\n-            let predicate: Result<_, ErrorReported> =\n-                self.ast_type_binding_to_poly_projection_predicate(\n-                    trait_ref.hir_ref_id, poly_trait_ref, binding, speculative, &mut dup_bindings);\n-            // okay to ignore Err because of ErrorReported (see above)\n-            Some((predicate.ok()?, binding.span))\n-        }));\n-\n-        debug!(\"instantiate_poly_trait_ref({:?}, projections={:?}) -> {:?}\",\n-               trait_ref, poly_projections, poly_trait_ref);\n+        for binding in &assoc_bindings {\n+            // Specify type to assert that error was already reported in `Err` case.\n+            let _ =\n+                self.add_predicates_for_ast_type_binding(\n+                    trait_ref.hir_ref_id,\n+                    poly_trait_ref,\n+                    binding,\n+                    bounds,\n+                    speculative,\n+                    &mut dup_bindings\n+                );\n+            // Okay to ignore `Err` because of `ErrorReported` (see above).\n+        }\n+\n+        debug!(\"instantiate_poly_trait_ref({:?}, bounds={:?}) -> {:?}\",\n+               trait_ref, bounds, poly_trait_ref);\n         (poly_trait_ref, potential_assoc_types)\n     }\n \n     pub fn instantiate_poly_trait_ref(&self,\n         poly_trait_ref: &hir::PolyTraitRef,\n         self_ty: Ty<'tcx>,\n-        poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>)\n-        -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n+        bounds: &mut Bounds<'tcx>\n+    ) -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n     {\n-        self.instantiate_poly_trait_ref_inner(&poly_trait_ref.trait_ref, self_ty,\n-                                              poly_projections, false)\n+        self.instantiate_poly_trait_ref_inner(&poly_trait_ref.trait_ref, self_ty, bounds, false)\n     }\n \n     fn ast_path_to_mono_trait_ref(&self,\n-                                  span: Span,\n-                                  trait_def_id: DefId,\n-                                  self_ty: Ty<'tcx>,\n-                                  trait_segment: &hir::PathSegment)\n-                                  -> ty::TraitRef<'tcx>\n+        span: Span,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        trait_segment: &hir::PathSegment\n+    ) -> ty::TraitRef<'tcx>\n     {\n         let (substs, assoc_bindings, _) =\n             self.create_substs_for_ast_trait_ref(span,\n@@ -830,15 +852,120 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         })\n     }\n \n-    fn ast_type_binding_to_poly_projection_predicate(\n+    // Returns `true` if a bounds list includes `?Sized`.\n+    pub fn is_unsized(&self, ast_bounds: &[hir::GenericBound], span: Span) -> bool {\n+        let tcx = self.tcx();\n+\n+        // Try to find an unbound in bounds.\n+        let mut unbound = None;\n+        for ab in ast_bounds {\n+            if let &hir::GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = ab {\n+                if unbound.is_none() {\n+                    unbound = Some(ptr.trait_ref.clone());\n+                } else {\n+                    span_err!(\n+                        tcx.sess,\n+                        span,\n+                        E0203,\n+                        \"type parameter has more than one relaxed default \\\n+                        bound, only one is supported\"\n+                    );\n+                }\n+            }\n+        }\n+\n+        let kind_id = tcx.lang_items().require(SizedTraitLangItem);\n+        match unbound {\n+            Some(ref tpb) => {\n+                // FIXME(#8559) currently requires the unbound to be built-in.\n+                if let Ok(kind_id) = kind_id {\n+                    if tpb.path.res != Res::Def(DefKind::Trait, kind_id) {\n+                        tcx.sess.span_warn(\n+                            span,\n+                            \"default bound relaxed for a type parameter, but \\\n+                            this does nothing because the given bound is not \\\n+                            a default. Only `?Sized` is supported\",\n+                        );\n+                    }\n+                }\n+            }\n+            _ if kind_id.is_ok() => {\n+                return false;\n+            }\n+            // No lang item for `Sized`, so we can't add it as a bound.\n+            None => {}\n+        }\n+\n+        true\n+    }\n+\n+    pub fn add_bounds(&self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: &[hir::GenericBound],\n+        bounds: &mut Bounds<'tcx>,\n+    ) {\n+        let mut trait_bounds = Vec::new();\n+        let mut region_bounds = Vec::new();\n+\n+        for ast_bound in ast_bounds {\n+            match *ast_bound {\n+                hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::None) =>\n+                    trait_bounds.push(b),\n+                hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n+                hir::GenericBound::Outlives(ref l) =>\n+                    region_bounds.push(l),\n+            }\n+        }\n+\n+        for bound in trait_bounds {\n+            let (poly_trait_ref, _) = self.instantiate_poly_trait_ref(\n+                bound,\n+                param_ty,\n+                bounds,\n+            );\n+            bounds.trait_bounds.push((poly_trait_ref, bound.span))\n+        }\n+\n+        bounds.region_bounds.extend(region_bounds\n+            .into_iter()\n+            .map(|r| (self.ast_region_to_region(r, None), r.span))\n+        );\n+\n+        bounds.trait_bounds.sort_by_key(|(t, _)| t.def_id());\n+    }\n+\n+    /// Translates the AST's notion of ty param bounds (which are an enum consisting of a newtyped `Ty`\n+    /// or a region) to ty's notion of ty param bounds, which can either be user-defined traits or the\n+    /// built-in trait `Send`.\n+    pub fn compute_bounds(&self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: &[hir::GenericBound],\n+        sized_by_default: SizedByDefault,\n+        span: Span,\n+    ) -> Bounds<'tcx> {\n+        let mut bounds = Bounds::default();\n+        self.add_bounds(param_ty, ast_bounds, &mut bounds);\n+        bounds.implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n+            if !self.is_unsized(ast_bounds, span) {\n+                Some(span)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        };\n+        bounds\n+    }\n+\n+    fn add_predicates_for_ast_type_binding(\n         &self,\n         hir_ref_id: hir::HirId,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         binding: &ConvertedBinding<'tcx>,\n+        bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n-        dup_bindings: &mut FxHashMap<DefId, Span>)\n-        -> Result<ty::PolyProjectionPredicate<'tcx>, ErrorReported>\n-    {\n+        dup_bindings: &mut FxHashMap<DefId, Span>,\n+    ) -> Result<(), ErrorReported> {\n         let tcx = self.tcx();\n \n         if !speculative {\n@@ -865,28 +992,30 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             //\n             //     for<'a> <T as Iterator>::Item = &'a str // <-- 'a is bad\n             //     for<'a> <T as FnMut<(&'a u32,)>>::Output = &'a str // <-- 'a is ok\n-            let late_bound_in_trait_ref = tcx.collect_constrained_late_bound_regions(&trait_ref);\n-            let late_bound_in_ty =\n-                tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(binding.ty));\n-            debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n-            debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n-            for br in late_bound_in_ty.difference(&late_bound_in_trait_ref) {\n-                let br_name = match *br {\n-                    ty::BrNamed(_, name) => name,\n-                    _ => {\n-                        span_bug!(\n-                            binding.span,\n-                            \"anonymous bound region {:?} in binding but not trait ref\",\n-                            br);\n-                    }\n-                };\n-                struct_span_err!(tcx.sess,\n+            if let ConvertedBindingKind::Equality(ty) = binding.kind {\n+                let late_bound_in_trait_ref = tcx.collect_constrained_late_bound_regions(&trait_ref);\n+                let late_bound_in_ty =\n+                    tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(ty));\n+                debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n+                debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n+                for br in late_bound_in_ty.difference(&late_bound_in_trait_ref) {\n+                    let br_name = match *br {\n+                        ty::BrNamed(_, name) => name,\n+                        _ => {\n+                            span_bug!(\n                                 binding.span,\n-                                E0582,\n-                                \"binding for associated type `{}` references lifetime `{}`, \\\n-                                 which does not appear in the trait input types\",\n-                                binding.item_name, br_name)\n-                    .emit();\n+                                \"anonymous bound region {:?} in binding but not trait ref\",\n+                                br);\n+                        }\n+                    };\n+                    struct_span_err!(tcx.sess,\n+                                    binding.span,\n+                                    E0582,\n+                                    \"binding for associated type `{}` references lifetime `{}`, \\\n+                                     which does not appear in the trait input types\",\n+                                    binding.item_name, br_name)\n+                        .emit();\n+                }\n             }\n         }\n \n@@ -931,16 +1060,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 .or_insert(binding.span);\n         }\n \n-        Ok(candidate.map_bound(|trait_ref| {\n-            ty::ProjectionPredicate {\n-                projection_ty: ty::ProjectionTy::from_ref_and_name(\n-                    tcx,\n-                    trait_ref,\n-                    binding.item_name,\n-                ),\n-                ty: binding.ty,\n+        match binding.kind {\n+            ConvertedBindingKind::Equality(ref ty) => {\n+                bounds.projection_bounds.push((candidate.map_bound(|trait_ref| {\n+                    ty::ProjectionPredicate {\n+                        projection_ty: ty::ProjectionTy::from_ref_and_name(\n+                            tcx,\n+                            trait_ref,\n+                            binding.item_name,\n+                        ),\n+                        ty,\n+                    }\n+                }), binding.span));\n             }\n-        }))\n+            ConvertedBindingKind::Constraint(ref ast_bounds) => {\n+                self.add_bounds(\n+                    trait_ref.self_ty(),\n+                    ast_bounds,\n+                    bounds,\n+                );\n+            }\n+        }\n+        Ok(())\n     }\n \n     fn ast_path_to_ty(&self,\n@@ -974,7 +1115,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     {\n         let tcx = self.tcx();\n \n-        let mut projection_bounds = Vec::new();\n+        let mut bounds = Bounds::default();\n         let mut potential_assoc_types = Vec::new();\n         let dummy_self = self.tcx().types.trait_object_dummy_self;\n         // FIXME: we want to avoid collecting into a `Vec` here, but simply cloning the iterator is\n@@ -986,7 +1127,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 let (trait_ref, cur_potential_assoc_types) = self.instantiate_poly_trait_ref(\n                     trait_bound,\n                     dummy_self,\n-                    &mut projection_bounds\n+                    &mut bounds,\n                 );\n                 potential_assoc_types.extend(cur_potential_assoc_types.into_iter().flatten());\n                 (trait_ref, trait_bound.span)\n@@ -1074,14 +1215,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     // which is uglier but works. See the discussion in #56288 for alternatives.\n                     if !references_self {\n                         // Include projections defined on supertraits.\n-                        projection_bounds.push((pred, DUMMY_SP))\n+                        bounds.projection_bounds.push((pred, DUMMY_SP))\n                     }\n                 }\n                 _ => ()\n             }\n         }\n \n-        for (projection_bound, _) in &projection_bounds {\n+        for (projection_bound, _) in &bounds.projection_bounds {\n             associated_types.remove(&projection_bound.projection_def_id());\n         }\n \n@@ -1161,7 +1302,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let existential_trait_refs = regular_traits.iter().map(|i| {\n             i.trait_ref().map_bound(|trait_ref| self.trait_ref_to_existential(trait_ref))\n         });\n-        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n+        let existential_projections = bounds.projection_bounds.iter().map(|(bound, _)| {\n             bound.map_bound(|b| {\n                 let trait_ref = self.trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n                 ty::ExistentialProjection {\n@@ -1900,6 +2041,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 let region = self.ast_region_to_region(&lt, None);\n                 tcx.type_of(va_list_did).subst(tcx, &[region.into()])\n             }\n+            hir::TyKind::AssocTyExistential(..) => {\n+                // Type is never actually used.\n+                tcx.types.err\n+            }\n             hir::TyKind::Err => {\n                 tcx.types.err\n             }\n@@ -2121,12 +2266,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n // A helper struct for conveniently grouping a set of bounds which we pass to\n // and return from functions in multiple places.\n-#[derive(PartialEq, Eq, Clone, Debug)]\n+#[derive(Default, PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n     pub region_bounds: Vec<(ty::Region<'tcx>, Span)>,\n-    pub implicitly_sized: Option<Span>,\n     pub trait_bounds: Vec<(ty::PolyTraitRef<'tcx>, Span)>,\n     pub projection_bounds: Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n+    pub implicitly_sized: Option<Span>,\n }\n \n impl<'a, 'gcx, 'tcx> Bounds<'tcx> {"}, {"sha": "c3b6fb21e38d64f62f94260ae3e90dbe6446a1a9", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=aaa53ec8531565e2f5721548b5a38c0062aa0e51", "patch": "@@ -991,8 +991,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Guarantees that any lifetimes which appear in the type of the node `id` (after applying\n-    /// adjustments) are valid for at least `minimum_lifetime`\n+    /// Guarantees that any lifetimes that appear in the type of the node `id` (after applying\n+    /// adjustments) are valid for at least `minimum_lifetime`.\n     fn type_of_node_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,"}, {"sha": "92d0e37cb9bbdbbb8451cc7a9423103c693dcde7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 28, "deletions": 144, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=aaa53ec8531565e2f5721548b5a38c0062aa0e51", "patch": "@@ -14,11 +14,10 @@\n //! At present, however, we do run collection across all items in the\n //! crate as a kind of pass. This should eventually be factored away.\n \n-use crate::astconv::{AstConv, Bounds};\n+use crate::astconv::{AstConv, Bounds, SizedByDefault};\n use crate::constrained_generic_params as cgp;\n use crate::check::intrinsic::intrisic_operation_unsafety;\n use crate::lint;\n-use crate::middle::lang_items::SizedTraitLangItem;\n use crate::middle::resolve_lifetime as rl;\n use crate::middle::weak_lang_items;\n use rustc::mir::mono::Linkage;\n@@ -704,7 +703,7 @@ fn super_predicates_of<'a, 'tcx>(\n \n     // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n     let self_param_ty = tcx.mk_self_type();\n-    let superbounds1 = compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No, item.span);\n+    let superbounds1 = AstConv::compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No, item.span);\n \n     let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n \n@@ -1650,9 +1649,11 @@ fn find_existential_constraints<'a, 'tcx>(\n         }\n     }\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let scope_id = tcx.hir().get_defining_scope(hir_id)\n-                            .expect(\"could not get defining scope\");\n+    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let scope_node_id = tcx.hir()\n+        .get_defining_scope(node_id)\n+        .expect(\"could not get defining scope\");\n+    let scope_id = tcx.hir().node_to_hir_id(scope_node_id);\n     let mut locator = ConstraintLocator {\n         def_id,\n         tcx,\n@@ -1661,7 +1662,7 @@ fn find_existential_constraints<'a, 'tcx>(\n \n     debug!(\"find_existential_constraints: scope_id={:?}\", scope_id);\n \n-    if scope_id == ast::CRATE_HIR_ID {\n+    if scope_id == hir::CRATE_HIR_ID {\n         intravisit::walk_crate(&mut locator, tcx.hir().krate());\n     } else {\n         debug!(\"find_existential_constraints: scope={:?}\", tcx.hir().get_by_hir_id(scope_id));\n@@ -1788,57 +1789,6 @@ fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> hir::I\n     }\n }\n \n-// Is it marked with ?Sized\n-fn is_unsized<'gcx: 'tcx, 'tcx>(\n-    astconv: &dyn AstConv<'gcx, 'tcx>,\n-    ast_bounds: &[hir::GenericBound],\n-    span: Span,\n-) -> bool {\n-    let tcx = astconv.tcx();\n-\n-    // Try to find an unbound in bounds.\n-    let mut unbound = None;\n-    for ab in ast_bounds {\n-        if let &hir::GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = ab {\n-            if unbound.is_none() {\n-                unbound = Some(ptr.trait_ref.clone());\n-            } else {\n-                span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0203,\n-                    \"type parameter has more than one relaxed default \\\n-                     bound, only one is supported\"\n-                );\n-            }\n-        }\n-    }\n-\n-    let kind_id = tcx.lang_items().require(SizedTraitLangItem);\n-    match unbound {\n-        Some(ref tpb) => {\n-            // FIXME(#8559) currently requires the unbound to be built-in.\n-            if let Ok(kind_id) = kind_id {\n-                if tpb.path.res != Res::Def(DefKind::Trait, kind_id) {\n-                    tcx.sess.span_warn(\n-                        span,\n-                        \"default bound relaxed for a type parameter, but \\\n-                         this does nothing because the given bound is not \\\n-                         a default. Only `?Sized` is supported\",\n-                    );\n-                }\n-            }\n-        }\n-        _ if kind_id.is_ok() => {\n-            return false;\n-        }\n-        // No lang item for Sized, so we can't add it as a bound.\n-        None => {}\n-    }\n-\n-    true\n-}\n-\n /// Returns the early-bound lifetimes declared in this generics\n /// listing. For anything other than fns/methods, this is just all\n /// the lifetimes that are declared. For fns or methods, we have to\n@@ -1984,7 +1934,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                 let opaque_ty = tcx.mk_opaque(def_id, substs);\n \n                 // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n-                let bounds = compute_bounds(\n+                let bounds = AstConv::compute_bounds(\n                     &icx,\n                     opaque_ty,\n                     bounds,\n@@ -2030,7 +1980,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n                     let opaque_ty = tcx.mk_opaque(def_id, substs);\n \n                     // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n-                    let bounds = compute_bounds(\n+                    let bounds = AstConv::compute_bounds(\n                         &icx,\n                         opaque_ty,\n                         bounds,\n@@ -2124,7 +2074,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n             index += 1;\n \n             let sized = SizedByDefault::Yes;\n-            let bounds = compute_bounds(&icx, param_ty, &param.bounds, sized, param.span);\n+            let bounds = AstConv::compute_bounds(&icx, param_ty, &param.bounds, sized, param.span);\n             predicates.extend(bounds.predicates(tcx, param_ty));\n         }\n     }\n@@ -2159,19 +2109,17 @@ fn explicit_predicates_of<'a, 'tcx>(\n                 for bound in bound_pred.bounds.iter() {\n                     match bound {\n                         &hir::GenericBound::Trait(ref poly_trait_ref, _) => {\n-                            let mut projections = Vec::new();\n+                            let mut bounds = Bounds::default();\n \n                             let (trait_ref, _) = AstConv::instantiate_poly_trait_ref(\n                                 &icx,\n                                 poly_trait_ref,\n                                 ty,\n-                                &mut projections,\n+                                &mut bounds,\n                             );\n \n-                            predicates.extend(\n-                                iter::once((trait_ref.to_predicate(), poly_trait_ref.span)).chain(\n-                                    projections.iter().map(|&(p, span)| (p.to_predicate(), span)\n-                            )));\n+                            predicates.push((trait_ref.to_predicate(), poly_trait_ref.span));\n+                            predicates.extend(bounds.predicates(tcx, ty));\n                         }\n \n                         &hir::GenericBound::Outlives(ref lifetime) => {\n@@ -2210,14 +2158,14 @@ fn explicit_predicates_of<'a, 'tcx>(\n             let trait_item = tcx.hir().trait_item(trait_item_ref.id);\n             let bounds = match trait_item.node {\n                 hir::TraitItemKind::Type(ref bounds, _) => bounds,\n-                _ => return vec![].into_iter()\n+                _ => return Vec::new().into_iter()\n             };\n \n             let assoc_ty =\n                 tcx.mk_projection(tcx.hir().local_def_id_from_hir_id(trait_item.hir_id),\n                     self_trait_ref.substs);\n \n-            let bounds = compute_bounds(\n+            let bounds = AstConv::compute_bounds(\n                 &ItemCtxt::new(tcx, def_id),\n                 assoc_ty,\n                 bounds,\n@@ -2259,68 +2207,6 @@ fn explicit_predicates_of<'a, 'tcx>(\n     result\n }\n \n-pub enum SizedByDefault {\n-    Yes,\n-    No,\n-}\n-\n-/// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped `Ty`\n-/// or a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n-/// built-in trait `Send`.\n-pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n-    astconv: &dyn AstConv<'gcx, 'tcx>,\n-    param_ty: Ty<'tcx>,\n-    ast_bounds: &[hir::GenericBound],\n-    sized_by_default: SizedByDefault,\n-    span: Span,\n-) -> Bounds<'tcx> {\n-    let mut region_bounds = Vec::new();\n-    let mut trait_bounds = Vec::new();\n-\n-    for ast_bound in ast_bounds {\n-        match *ast_bound {\n-            hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::None) => trait_bounds.push(b),\n-            hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n-            hir::GenericBound::Outlives(ref l) => region_bounds.push(l),\n-        }\n-    }\n-\n-    let mut projection_bounds = Vec::new();\n-\n-    let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n-        let (poly_trait_ref, _) = astconv.instantiate_poly_trait_ref(\n-            bound,\n-            param_ty,\n-            &mut projection_bounds,\n-        );\n-        (poly_trait_ref, bound.span)\n-    }).collect();\n-\n-    let region_bounds = region_bounds\n-        .into_iter()\n-        .map(|r| (astconv.ast_region_to_region(r, None), r.span))\n-        .collect();\n-\n-    trait_bounds.sort_by_key(|(t, _)| t.def_id());\n-\n-    let implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n-        if !is_unsized(astconv, ast_bounds, span) {\n-            Some(span)\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    };\n-\n-    Bounds {\n-        region_bounds,\n-        implicitly_sized,\n-        trait_bounds,\n-        projection_bounds,\n-    }\n-}\n-\n /// Converts a specific `GenericBound` from the AST into a set of\n /// predicates that apply to the self type. A vector is returned\n /// because this can be anywhere from zero predicates (`T: ?Sized` adds no\n@@ -2333,13 +2219,11 @@ fn predicates_from_bound<'tcx>(\n ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n     match *bound {\n         hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n-            let mut projections = Vec::new();\n-            let (pred, _) = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut projections);\n-            iter::once((pred.to_predicate(), tr.span)).chain(\n-                projections\n-                    .into_iter()\n-                    .map(|(p, span)| (p.to_predicate(), span))\n-            ).collect()\n+            let mut bounds = Bounds::default();\n+            let (pred, _) = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut bounds);\n+            iter::once((pred.to_predicate(), tr.span))\n+                .chain(bounds.predicates(astconv.tcx(), param_ty))\n+                .collect()\n         }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n@@ -2363,8 +2247,8 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n     };\n     let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), unsafety, abi, decl);\n \n-    // feature gate SIMD types in FFI, since I (huonw) am not sure the\n-    // ABIs are handled at all correctly.\n+    // Feature gate SIMD types in FFI, since I am not sure that the\n+    // ABIs are handled at all correctly. -huonw\n     if abi != abi::Abi::RustIntrinsic\n         && abi != abi::Abi::PlatformIntrinsic\n         && !tcx.features().simd_ffi\n@@ -2439,7 +2323,7 @@ fn from_target_feature(\n     };\n     let rust_features = tcx.features();\n     for item in list {\n-        // Only `enable = ...` is accepted in the meta item list\n+        // Only `enable = ...` is accepted in the meta-item list.\n         if !item.check_name(sym::enable) {\n             bad_item(item.span());\n             continue;\n@@ -2454,9 +2338,9 @@ fn from_target_feature(\n             }\n         };\n \n-        // We allow comma separation to enable multiple features\n+        // We allow comma separation to enable multiple features.\n         target_features.extend(value.as_str().split(',').filter_map(|feature| {\n-            // Only allow whitelisted features per platform\n+            // Only allow whitelisted features per platform.\n             let feature_gate = match whitelist.get(feature) {\n                 Some(g) => g,\n                 None => {\n@@ -2480,7 +2364,7 @@ fn from_target_feature(\n                 }\n             };\n \n-            // Only allow features whose feature gates have been enabled\n+            // Only allow features whose feature gates have been enabled.\n             let allowed = match feature_gate.as_ref().map(|s| *s) {\n                 Some(sym::arm_target_feature) => rust_features.arm_target_feature,\n                 Some(sym::aarch64_target_feature) => rust_features.aarch64_target_feature,"}, {"sha": "30993b86a385fa6c2b4166d64747af2110dd2f4e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=aaa53ec8531565e2f5721548b5a38c0062aa0e51", "patch": "@@ -114,6 +114,7 @@ use util::common::time;\n \n use std::iter;\n \n+use astconv::{AstConv, Bounds};\n pub use collect::checked_type_of;\n \n pub struct TypeAndSubsts<'tcx> {\n@@ -390,19 +391,19 @@ pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) ->\n }\n \n pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_trait: &hir::TraitRef)\n-        -> (ty::PolyTraitRef<'tcx>, Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>) {\n+        -> (ty::PolyTraitRef<'tcx>, Bounds<'tcx>) {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_hir_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n     let env_def_id = tcx.hir().local_def_id_from_hir_id(env_hir_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n-    let mut projections = Vec::new();\n-    let (principal, _) = astconv::AstConv::instantiate_poly_trait_ref_inner(\n-        &item_cx, hir_trait, tcx.types.err, &mut projections, true\n+    let mut bounds = Bounds::default();\n+    let (principal, _) = AstConv::instantiate_poly_trait_ref_inner(\n+        &item_cx, hir_trait, tcx.types.err, &mut bounds, true\n     );\n \n-    (principal, projections)\n+    (principal, bounds)\n }\n \n __build_diagnostic_array! { librustc_typeck, DIAGNOSTICS }"}, {"sha": "161e426604e9455536df69590abd677a1f83ef1d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa53ec8531565e2f5721548b5a38c0062aa0e51/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=aaa53ec8531565e2f5721548b5a38c0062aa0e51", "patch": "@@ -2445,7 +2445,7 @@ pub struct PolyTrait {\n \n /// A representation of a type suitable for hyperlinking purposes. Ideally, one can get the original\n /// type out of the AST/`TyCtxt` given one of these, if more information is needed. Most\n-/// importantly, it does not preserve mutability or boxes.\n+/// importanntly, it does not preserve mutability or boxes.\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum Type {\n     /// Structs/enums/traits (most that would be an `hir::TyKind::Path`).\n@@ -2939,6 +2939,9 @@ impl Clean<Type> for hir::Ty {\n             TyKind::Infer | TyKind::Err => Infer,\n             TyKind::Typeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n             TyKind::CVarArgs(_) => CVarArgs,\n+            TyKind::AssocTyExistential(ref bounds) => {\n+                ImplTrait(bounds.into_iter().map(|b| b.clean(cx)).collect())\n+            }\n         }\n     }\n }"}]}