{"sha": "0479604be1a0ded845b8bb038318db0e92b0d11b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0Nzk2MDRiZTFhMGRlZDg0NWI4YmIwMzgzMThkYjBlOTJiMGQxMWI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-23T16:54:15Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-23T16:54:15Z"}, "message": "Implement some more things", "tree": {"sha": "34f513a6aa594d7fa0ac141a8011eb4ec35d1ce6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34f513a6aa594d7fa0ac141a8011eb4ec35d1ce6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0479604be1a0ded845b8bb038318db0e92b0d11b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0479604be1a0ded845b8bb038318db0e92b0d11b", "html_url": "https://github.com/rust-lang/rust/commit/0479604be1a0ded845b8bb038318db0e92b0d11b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0479604be1a0ded845b8bb038318db0e92b0d11b/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1", "html_url": "https://github.com/rust-lang/rust/commit/6de95c89d9d21d36d3dd18dcfb6e42513e2a52d1"}], "stats": {"total": 190, "additions": 138, "deletions": 52}, "files": [{"sha": "25f630bbc629e65e6b4905d459c45e92689bb0be", "filename": "src/base.rs", "status": "modified", "additions": 98, "deletions": 29, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/0479604be1a0ded845b8bb038318db0e92b0d11b/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479604be1a0ded845b8bb038318db0e92b0d11b/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=0479604be1a0ded845b8bb038318db0e92b0d11b", "patch": "@@ -50,7 +50,7 @@ pub fn trans_crate<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Box<Any> {\n                         ::rustc_mir::util::write_mir_pretty(cx.tcx, Some(def_id), &mut mir).unwrap();\n                         tcx.sess.warn(&format!(\"{:?}:\\n\\n{}\", def_id, String::from_utf8_lossy(&mir.into_inner())));\n \n-                        trans_fn(cx, &mut f, def_id, substs);\n+                        trans_fn(cx, &mut f, inst);\n \n                         let mut cton = String::new();\n                         ::cretonne::codegen::write_function(&mut cton, &f, None).unwrap();\n@@ -114,8 +114,8 @@ struct CodegenCx<'a, 'tcx: 'a, B: Backend + 'a> {\n     def_id_fn_id_map: &'a mut HashMap<Instance<'tcx>, FuncId>,\n }\n \n-fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut Function, def_id: DefId, substs: &Substs<'tcx>) {\n-    let mir = cx.tcx.optimized_mir(def_id);\n+fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut Function, instance: Instance<'tcx>) {\n+    let mir = cx.tcx.optimized_mir(instance.def_id());\n     let mut func_ctx = FunctionBuilderContext::new();\n     let mut bcx: FunctionBuilder<Variable> = FunctionBuilder::new(f, &mut func_ctx);\n \n@@ -130,8 +130,13 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n         tcx: cx.tcx,\n         module: &mut cx.module,\n         def_id_fn_id_map: &mut cx.def_id_fn_id_map,\n-        bcx,\n+        instance,\n         mir,\n+        bcx,\n+        param_substs: {\n+            assert!(!instance.substs.needs_infer());\n+            instance.substs\n+        },\n         ebb_map,\n         local_map: HashMap::new(),\n     };\n@@ -145,7 +150,7 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n     }); // Dummy stack slot for debugging\n \n     let func_params = mir.args_iter().map(|local| {\n-        let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(mir.local_decls[local].ty)).unwrap();\n+        let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(fx.monomorphize(&mir.local_decls[local].ty))).unwrap();\n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             size: layout.size.bytes() as u32,\n@@ -160,8 +165,6 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n     for (local, ebb_param, ty, stack_slot) in func_params {\n         let place = CPlace::from_stack_slot(fx, stack_slot);\n         if ty.is_some() {\n-            // FIXME(cretonne) support i16 and smaller\n-            let ebb_param = extend_val(fx, ebb_param, mir.local_decls[local].ty);\n             CPlace::from_stack_slot(fx, stack_slot).write_cvalue(fx, CValue::ByVal(ebb_param), mir.local_decls[local].ty);\n             //fx.bcx.ins().stack_store(ebb_param, stack_slot, 0);\n         } else {\n@@ -258,7 +261,7 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n                             TypeVariants::TyFnPtr(fn_sig) => fn_sig,\n                             _ => bug!(\"Calling non function type {:?}\", func_ty),\n                         };\n-                        let sig = fx.bcx.import_signature(cton_sig_from_fn_sig(fx.tcx, sig, substs));\n+                        let sig = fx.bcx.import_signature(cton_sig_from_fn_sig(fx.tcx, sig, fx.param_substs));\n                         fx.bcx.ins().call_indirect(sig, func, &args);\n                     }\n                 }\n@@ -289,19 +292,72 @@ fn trans_fn<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend>, f: &mut\n \n fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx>) {\n     match &stmt.kind {\n+        /*StatementKind::SetDiscriminant { place, variant_index } => {\n+            if self.layout.for_variant(bx.cx, variant_index).abi == layout::Abi::Uninhabited {\n+                return;\n+            }\n+            match self.layout.variants {\n+                layout::Variants::Single { index } => {\n+                    assert_eq!(index, variant_index);\n+                }\n+                layout::Variants::Tagged { .. } => {\n+                    let ptr = self.project_field(bx, 0);\n+                    let to = self.layout.ty.ty_adt_def().unwrap()\n+                        .discriminant_for_variant(bx.tcx(), variant_index)\n+                        .val;\n+                    bx.store(\n+                        C_uint_big(ptr.layout.llvm_type(bx.cx), to),\n+                        ptr.llval,\n+                        ptr.align);\n+                }\n+                layout::Variants::NicheFilling {\n+                    dataful_variant,\n+                    ref niche_variants,\n+                    niche_start,\n+                    ..\n+                } => {\n+                    if variant_index != dataful_variant {\n+                        if bx.sess().target.target.arch == \"arm\" ||\n+                        bx.sess().target.target.arch == \"aarch64\" {\n+                            // Issue #34427: As workaround for LLVM bug on ARM,\n+                            // use memset of 0 before assigning niche value.\n+                            let llptr = bx.pointercast(self.llval, Type::i8(bx.cx).ptr_to());\n+                            let fill_byte = C_u8(bx.cx, 0);\n+                            let (size, align) = self.layout.size_and_align();\n+                            let size = C_usize(bx.cx, size.bytes());\n+                            let align = C_u32(bx.cx, align.abi() as u32);\n+                            base::call_memset(bx, llptr, fill_byte, size, align, false);\n+                        }\n+\n+                        let niche = self.project_field(bx, 0);\n+                        let niche_llty = niche.layout.immediate_llvm_type(bx.cx);\n+                        let niche_value = ((variant_index - *niche_variants.start()) as u128)\n+                            .wrapping_add(niche_start);\n+                        // FIXME(eddyb) Check the actual primitive type here.\n+                        let niche_llval = if niche_value == 0 {\n+                            // HACK(eddyb) Using `C_null` as it works on all types.\n+                            C_null(niche_llty)\n+                        } else {\n+                            C_uint_big(niche_llty, niche_value)\n+                        };\n+                        OperandValue::Immediate(niche_llval).store(bx, niche);\n+                    }\n+                }\n+            }\n+        }*/\n         StatementKind::Assign(to_place, rval) => {\n-            let dest_ty = to_place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx);\n+            let dest_ty = fx.monomorphize(&to_place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx));\n             let lval = trans_place(fx, to_place);\n             match rval {\n                 Rvalue::Use(operand) => {\n                     let val = trans_operand(fx, operand);\n-                    lval.write_cvalue(fx, val, dest_ty);\n+                    lval.write_cvalue(fx, val, &dest_ty);\n                 },\n                 Rvalue::BinaryOp(bin_op, lhs, rhs) => {\n-                    let ty = lhs.ty(&fx.mir.local_decls, fx.tcx);\n-                    let lhs_ty = lhs.ty(&fx.mir.local_decls, fx.tcx);\n+                    let ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n+                    let lhs_ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n                     let lhs = trans_operand(fx, lhs).load_value(fx, lhs_ty);\n-                    let rhs_ty = rhs.ty(&fx.mir.local_decls, fx.tcx);\n+                    let rhs_ty = fx.monomorphize(&rhs.ty(&fx.mir.local_decls, fx.tcx));\n                     let rhs = trans_operand(fx, rhs).load_value(fx, rhs_ty);\n \n                     let res = match ty.sty {\n@@ -314,17 +370,26 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                                 bin_op => unimplemented!(\"checked uint bin op {:?} {:?} {:?}\", bin_op, lhs, rhs),\n                             }\n                         }\n+                        TypeVariants::TyInt(_) => {\n+                            match bin_op {\n+                                BinOp::Add => fx.bcx.ins().iadd(lhs, rhs),\n+                                BinOp::Sub => fx.bcx.ins().isub(lhs, rhs),\n+                                BinOp::Mul => fx.bcx.ins().imul(lhs, rhs),\n+                                BinOp::Div => fx.bcx.ins().sdiv(lhs, rhs),\n+                                bin_op => unimplemented!(\"checked int bin op {:?} {:?} {:?}\", bin_op, lhs, rhs),\n+                            }\n+                        }\n                         _ => unimplemented!(),\n                     };\n                     lval.write_cvalue(fx, CValue::ByVal(res), ty);\n                 }\n                 Rvalue::CheckedBinaryOp(bin_op, lhs, rhs) => {\n                     // TODO correctly write output tuple\n \n-                    let ty = lhs.ty(&fx.mir.local_decls, fx.tcx);\n-                    let lhs_ty = lhs.ty(&fx.mir.local_decls, fx.tcx);\n+                    let ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n+                    let lhs_ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n                     let lhs = trans_operand(fx, lhs).load_value(fx, lhs_ty);\n-                    let rhs_ty = rhs.ty(&fx.mir.local_decls, fx.tcx);\n+                    let rhs_ty = fx.monomorphize(&rhs.ty(&fx.mir.local_decls, fx.tcx));\n                     let rhs = trans_operand(fx, rhs).load_value(fx, rhs_ty);\n \n                     let res = match ty.sty {\n@@ -344,15 +409,15 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                 }\n                 Rvalue::Cast(CastKind::ReifyFnPointer, operand, ty) => {\n                     let operand = trans_operand(fx, operand);\n-                    lval.write_cvalue(fx, operand, dest_ty);\n+                    lval.write_cvalue(fx, operand, &dest_ty);\n                 }\n                 Rvalue::Cast(CastKind::UnsafeFnPointer, operand, ty) => {\n                     let operand = trans_operand(fx, operand);\n-                    lval.write_cvalue(fx, operand, dest_ty);\n+                    lval.write_cvalue(fx, operand, &dest_ty);\n                 }\n                 Rvalue::Discriminant(place) => {\n-                    let place_ty = place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx);\n-                    let cton_place_ty = cton_type_from_ty(place_ty);\n+                    let place_ty = fx.monomorphize(&place.ty(&fx.mir.local_decls, fx.tcx).to_ty(fx.tcx));\n+                    let cton_place_ty = cton_type_from_ty(&place_ty);\n                     let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(place_ty)).unwrap();\n \n                     if layout.abi == layout::Abi::Uninhabited {\n@@ -363,8 +428,8 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                             let discr_val = layout.ty.ty_adt_def().map_or(\n                                 index as u128,\n                                 |def| def.discriminant_for_variant(fx.tcx, index).val);\n-                            let val = CValue::const_val(fx, dest_ty, discr_val as u64 as i64);\n-                            lval.write_cvalue(fx, val, dest_ty);\n+                            let val = CValue::const_val(fx, &dest_ty, discr_val as u64 as i64);\n+                            lval.write_cvalue(fx, val, &dest_ty);\n                         }\n                         layout::Variants::Tagged { .. } |\n                         layout::Variants::NicheFilling { .. } => {},\n@@ -383,8 +448,8 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                                 layout::Int(_, signed) => signed,\n                                 _ => false\n                             };\n-                            let val = cton_intcast(fx, lldiscr, discr_ty, dest_ty, signed);\n-                            lval.write_cvalue(fx, CValue::ByVal(val), dest_ty);\n+                            let val = cton_intcast(fx, lldiscr, discr_ty, &dest_ty, signed);\n+                            lval.write_cvalue(fx, CValue::ByVal(val), &dest_ty);\n                         }\n                         layout::Variants::NicheFilling {\n                             dataful_variant,\n@@ -395,21 +460,21 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                             let niche_llty = cton_type_from_ty(discr_ty).unwrap();\n                             if niche_variants.start() == niche_variants.end() {\n                                 let b = fx.bcx.ins().icmp_imm(IntCC::Equal, lldiscr, niche_start as u64 as i64);\n-                                let if_true = fx.bcx.ins().iconst(cton_type_from_ty(dest_ty).unwrap(), *niche_variants.start() as u64 as i64);\n-                                let if_false = fx.bcx.ins().iconst(cton_type_from_ty(dest_ty).unwrap(), dataful_variant as u64 as i64);\n+                                let if_true = fx.bcx.ins().iconst(cton_type_from_ty(&dest_ty).unwrap(), *niche_variants.start() as u64 as i64);\n+                                let if_false = fx.bcx.ins().iconst(cton_type_from_ty(&dest_ty).unwrap(), dataful_variant as u64 as i64);\n                                 let val = fx.bcx.ins().select(b, if_true, if_false);\n-                                lval.write_cvalue(fx, CValue::ByVal(val), dest_ty);\n+                                lval.write_cvalue(fx, CValue::ByVal(val), &dest_ty);\n                             } else {\n                                 // Rebase from niche values to discriminant values.\n                                 let delta = niche_start.wrapping_sub(*niche_variants.start() as u128);\n                                 let delta = fx.bcx.ins().iconst(niche_llty, delta as u64 as i64);\n                                 let lldiscr = fx.bcx.ins().isub(lldiscr, delta);\n                                 let lldiscr_max = fx.bcx.ins().iconst(niche_llty, *niche_variants.end() as u64 as i64);\n                                 let b = fx.bcx.ins().icmp_imm(IntCC::UnsignedLessThanOrEqual, lldiscr, *niche_variants.end() as u64 as i64);\n-                                let if_true = cton_intcast(fx, lldiscr, discr_ty, dest_ty, false);\n+                                let if_true = cton_intcast(fx, lldiscr, discr_ty, &dest_ty, false);\n                                 let if_false = fx.bcx.ins().iconst(niche_llty, dataful_variant as u64 as i64);\n                                 let val = fx.bcx.ins().select(b, if_true, if_false);\n-                                lval.write_cvalue(fx, CValue::ByVal(val), dest_ty);\n+                                lval.write_cvalue(fx, CValue::ByVal(val), &dest_ty);\n                             }\n                         }\n                     }\n@@ -427,7 +492,11 @@ fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>)\n         Place::Local(local) => fx.get_local_place(*local),\n         Place::Projection(projection) => {\n             let base = trans_place(fx, &projection.base);\n+            let place_ty = fx.monomorphize(&place.ty(&*fx.mir, fx.tcx)).to_ty(fx.tcx);\n             match projection.elem {\n+                ProjectionElem::Deref => {\n+                    CPlace::Addr(base.to_cvalue(fx).load_value(fx, place_ty))\n+                }\n                 ProjectionElem::Field(field, ty) => {\n                     base.place_field(fx, field, ty).0\n                 }"}, {"sha": "a86dc0c5f53b43759c952d5e8ed0c618b05022bd", "filename": "src/common.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0479604be1a0ded845b8bb038318db0e92b0d11b/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479604be1a0ded845b8bb038318db0e92b0d11b/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=0479604be1a0ded845b8bb038318db0e92b0d11b", "patch": "@@ -28,7 +28,7 @@ pub fn cton_type_from_ty(ty: Ty) -> Option<types::Type> {\n                 UintTy::U16 => types::I16,\n                 UintTy::U32 => types::I32,\n                 UintTy::U64 => types::I64,\n-                UintTy::U128 => unimplemented!(),\n+                UintTy::U128 => types::I64X2,\n                 UintTy::Usize => types::I64,\n             }\n         }\n@@ -38,15 +38,24 @@ pub fn cton_type_from_ty(ty: Ty) -> Option<types::Type> {\n                 IntTy::I16 => types::I16,\n                 IntTy::I32 => types::I32,\n                 IntTy::I64 => types::I64,\n-                IntTy::I128 => unimplemented!(),\n+                IntTy::I128 => types::I64X2,\n                 IntTy::Isize => types::I64,\n             }\n         }\n         TypeVariants::TyFnPtr(_) => types::I64,\n+        TypeVariants::TyRef(..) | TypeVariants::TyRawPtr(..) => types::I64,\n         _ => return None,\n     })\n }\n \n+// FIXME(cretonne) fix types smaller than I32\n+pub fn fixup_cton_ty(ty: Type) -> Type {\n+    match ty {\n+        types::I64X2 | types::I64 | types::I32 => ty,\n+        _ => types::I32,\n+    }\n+}\n+\n pub fn extend_val<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, val: Value, ty: Ty) -> Value {\n     let cton_ty = cton_type_from_ty(ty).unwrap();\n     let to_ty = match cton_ty {\n@@ -116,7 +125,7 @@ impl CValue {\n     pub fn load_value<'a, 'tcx: 'a>(self, fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>) -> Value {\n         match self {\n             CValue::ByRef(value) => {\n-                let cton_ty = cton_type_from_ty(ty).unwrap();\n+                let cton_ty = cton_type_from_ty(fx.monomorphize(&ty)).expect(&format!(\"{:?}\", ty));\n                 load_workaround(fx, cton_ty, value, 0)\n             }\n             CValue::ByVal(value) => value,\n@@ -139,7 +148,7 @@ impl CValue {\n             CValue::ByRef(addr) => addr,\n             _ => bug!(\"place_field for {:?}\", self),\n         };\n-        let layout = fx.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n+        let layout = fx.tcx.layout_of(ParamEnv::empty().and(fx.monomorphize(&ty))).unwrap();\n         let field_offset = layout.fields.offset(field.index());\n         if field_offset.bytes() > 0 {\n             let field_offset = fx.bcx.ins().iconst(types::I64, field_offset.bytes() as i64);\n@@ -150,6 +159,7 @@ impl CValue {\n     }\n \n     pub fn const_val<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, ty: Ty<'tcx>, const_val: i64) -> CValue {\n+        let ty = fx.monomorphize(&ty);\n         CValue::ByVal(fx.bcx.ins().iconst(cton_type_from_ty(ty).unwrap(), const_val))\n     }\n }\n@@ -180,7 +190,7 @@ impl<'a, 'tcx: 'a> CPlace {\n     }\n \n     pub fn write_cvalue(self, fx: &mut FunctionCx<'a, 'tcx>, from: CValue, ty: Ty<'tcx>) {\n-        let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n+        let layout = fx.tcx.layout_of(ParamEnv::reveal_all().and(fx.monomorphize(&ty))).unwrap();\n         let size = layout.size.bytes() as i32;\n         match self {\n             CPlace::Var(var) => {\n@@ -236,7 +246,7 @@ pub fn cton_sig_from_mono_fn_sig<'a ,'tcx: 'a>(sig: PolyFnSig<'tcx>) -> Signatur\n     };\n     Signature {\n         params: Some(types::I64).into_iter() // First param is place to put return val\n-            .chain(inputs.into_iter().map(|ty| cton_type_from_ty(ty).unwrap_or(types::I64)))\n+            .chain(inputs.into_iter().map(|ty| fixup_cton_ty(cton_type_from_ty(ty).unwrap_or(types::I64))))\n             .map(AbiParam::new).collect(),\n         returns: vec![],\n         call_conv,\n@@ -265,13 +275,25 @@ pub struct FunctionCx<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub module: &'a mut Module<CurrentBackend>,\n     pub def_id_fn_id_map: &'a mut HashMap<Instance<'tcx>, FuncId>,\n-    pub bcx: FunctionBuilder<'a, Variable>,\n+    pub instance: Instance<'tcx>,\n     pub mir: &'tcx Mir<'tcx>,\n+    pub param_substs: &'tcx Substs<'tcx>,\n+    pub bcx: FunctionBuilder<'a, Variable>,\n     pub ebb_map: HashMap<BasicBlock, Ebb>,\n     pub local_map: HashMap<Local, CPlace>,\n }\n \n impl<'f, 'tcx> FunctionCx<'f, 'tcx> {\n+    pub fn monomorphize<T>(&self, value: &T) -> T\n+        where T: TypeFoldable<'tcx>\n+    {\n+        self.tcx.subst_and_normalize_erasing_regions(\n+            self.param_substs,\n+            ty::ParamEnv::reveal_all(),\n+            value,\n+        )\n+    }\n+\n     pub fn get_ebb(&self, bb: BasicBlock) -> Ebb {\n         *self.ebb_map.get(&bb).unwrap()\n     }"}, {"sha": "2327400e4f64e3c27c7f48e92e11b97e2ed0b90e", "filename": "src/lib.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0479604be1a0ded845b8bb038318db0e92b0d11b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0479604be1a0ded845b8bb038318db0e92b0d11b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=0479604be1a0ded845b8bb038318db0e92b0d11b", "patch": "@@ -38,31 +38,26 @@ mod common;\n mod prelude {\n     pub use std::collections::HashMap;\n \n-    pub use rustc::session::Session;\n     pub use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-    pub use rustc::ty::{TyCtxt, Ty, TypeVariants, Instance, InstanceDef, ParamEnv, FnSig, PolyFnSig, subst::Substs};\n-    pub use rustc::ty::layout;\n     pub use rustc::mir;\n     pub use rustc::mir::*;\n-    pub use rustc_mir::monomorphize::collector;\n-    pub use rustc_data_structures::{\n-        sync::Lrc,\n-        indexed_vec::Idx,\n+    pub use rustc::session::Session;\n+    pub use rustc::ty::layout;\n+    pub use rustc::ty::{\n+        self, subst::Substs, FnSig, Instance, InstanceDef, ParamEnv, PolyFnSig, Ty, TyCtxt,\n+        TypeFoldable, TypeVariants,\n     };\n+    pub use rustc_data_structures::{indexed_vec::Idx, sync::Lrc};\n+    pub use rustc_mir::monomorphize::collector;\n \n-    pub use cretonne::prelude::*;\n-    pub use cretonne::codegen::Context;\n     pub use cretonne::codegen::ir::{\n-        ExternalName,\n-        FuncRef,\n-        StackSlot,\n-        function::Function,\n-        condcodes::IntCC,\n+        condcodes::IntCC, function::Function, ExternalName, FuncRef, StackSlot,\n     };\n+    pub use cretonne::codegen::Context;\n+    pub use cretonne::prelude::*;\n \n-\n-    pub use common::*;\n     pub use common::Variable;\n+    pub use common::*;\n }\n \n use prelude::*;"}]}