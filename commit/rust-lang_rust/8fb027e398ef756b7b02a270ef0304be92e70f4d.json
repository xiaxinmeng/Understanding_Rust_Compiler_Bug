{"sha": "8fb027e398ef756b7b02a270ef0304be92e70f4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmYjAyN2UzOThlZjc1NmI3YjAyYTI3MGVmMDMwNGJlOTJlNzBmNGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-26T12:02:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-26T12:02:16Z"}, "message": "auto merge of #19252 : japaric/rust/cow, r=aturon\n\n- Add `IntoCow` trait, and put it in the prelude\r\n- Add `is_owned`/`is_borrowed` methods to `Cow`\r\n- Add `CowString`/`CowVec` type aliases (to `Cow<'_, String, str>`/`Cow<'_, Vec, [T]>` respectively)\r\n- `Cow` implements: `Show`, `Hash`, `[Partial]{Eq,Ord}`\r\n- `impl BorrowFrom<Cow<'a, T, B>> for B`\r\n\r\n[breaking-change]s:\r\n\r\n- `IntoMaybeOwned` has been removed from the prelude\r\n- libcollections: `SendStr` is now an alias to `CowString<'static>` (it was aliased to `MaybeOwned<'static>`)\r\n- libgraphviz:\r\n  - `LabelText` variants now wrap `CowString` instead of `MaybeOwned`\r\n  - `Nodes` and `Edges` are now type aliases to `CowVec` (they were aliased to `MaybeOwnedVec`)\r\n- libstd/path: `Display::as_maybe_owned` has been renamed to `Display::as_cow` and now returns a `CowString`\r\n- These functions now accept/return `Cow` instead of `MaybeOwned[Vector]`:\r\n  - libregex: `Replacer::reg_replace`\r\n  - libcollections: `str::from_utf8_lossy`\r\n  - libgraphviz: `Id::new`, `Id::name`, `LabelText::pre_escaped_content`\r\n  - libstd: `TaskBuilder::named`\r\n\r\nr? @aturon", "tree": {"sha": "e842ec33ca78ddc8223bdbfc0e6839f7d3643618", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e842ec33ca78ddc8223bdbfc0e6839f7d3643618"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fb027e398ef756b7b02a270ef0304be92e70f4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fb027e398ef756b7b02a270ef0304be92e70f4d", "html_url": "https://github.com/rust-lang/rust/commit/8fb027e398ef756b7b02a270ef0304be92e70f4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fb027e398ef756b7b02a270ef0304be92e70f4d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61af40278909eb899f1bdfbb8c45d4e4fb3dad5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/61af40278909eb899f1bdfbb8c45d4e4fb3dad5d", "html_url": "https://github.com/rust-lang/rust/commit/61af40278909eb899f1bdfbb8c45d4e4fb3dad5d"}, {"sha": "3293ab14e24d136d0482bb18afef577aebed251e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3293ab14e24d136d0482bb18afef577aebed251e", "html_url": "https://github.com/rust-lang/rust/commit/3293ab14e24d136d0482bb18afef577aebed251e"}], "stats": {"total": 498, "additions": 326, "deletions": 172}, "files": [{"sha": "4173ffc5d2fd87460e12357d8dfcb39c3c298a84", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -67,6 +67,7 @@ use core::prelude::*;\n \n use alloc::boxed::Box;\n use alloc::rc::Rc;\n+use core::borrow::{Cow, ToOwned};\n use core::intrinsics::TypeId;\n use core::mem;\n use core::num::Int;\n@@ -284,6 +285,13 @@ impl<S: Writer, T: Hash<S>, U: Hash<S>> Hash<S> for Result<T, U> {\n     }\n }\n \n+impl<'a, T, Sized? B, S> Hash<S> for Cow<'a, T, B> where B: Hash<S> + ToOwned<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        Hash::hash(&**self, state)\n+    }\n+}\n+\n //////////////////////////////////////////////////////////////////////////////\n \n #[cfg(test)]"}, {"sha": "7b53fead6b22634a840b9609b72f255aa376f257", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -54,7 +54,7 @@\n pub use self::MaybeOwned::*;\n use self::RecompositionState::*;\n use self::DecompositionType::*;\n-use core::borrow::{BorrowFrom, ToOwned};\n+use core::borrow::{BorrowFrom, Cow, ToOwned};\n use core::default::Default;\n use core::fmt;\n use core::cmp;\n@@ -67,7 +67,7 @@ use core::prelude::{range};\n \n use hash;\n use ring_buf::RingBuf;\n-use string::{String, ToString};\n+use string::String;\n use unicode;\n use vec::Vec;\n \n@@ -425,22 +425,24 @@ Section: MaybeOwned\n /// A string type that can hold either a `String` or a `&str`.\n /// This can be useful as an optimization when an allocation is sometimes\n /// needed but not always.\n+#[deprecated = \"use std::str::CowString\"]\n pub enum MaybeOwned<'a> {\n     /// A borrowed string.\n     Slice(&'a str),\n     /// An owned string.\n     Owned(String)\n }\n \n-/// A specialization of `MaybeOwned` to be sendable.\n-pub type SendStr = MaybeOwned<'static>;\n+/// A specialization of `CowString` to be sendable.\n+pub type SendStr = CowString<'static>;\n \n+#[deprecated = \"use std::str::CowString\"]\n impl<'a> MaybeOwned<'a> {\n     /// Returns `true` if this `MaybeOwned` wraps an owned string.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ``` ignore\n     /// let string = String::from_str(\"orange\");\n     /// let maybe_owned_string = string.into_maybe_owned();\n     /// assert_eq!(true, maybe_owned_string.is_owned());\n@@ -457,7 +459,7 @@ impl<'a> MaybeOwned<'a> {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ``` ignore\n     /// let string = \"orange\";\n     /// let maybe_owned_string = string.as_slice().into_maybe_owned();\n     /// assert_eq!(true, maybe_owned_string.is_slice());\n@@ -475,46 +477,56 @@ impl<'a> MaybeOwned<'a> {\n     pub fn len(&self) -> uint { self.as_slice().len() }\n \n     /// Returns true if the string contains no bytes\n+    #[allow(deprecated)]\n     #[inline]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n+#[deprecated = \"use std::borrow::IntoCow\"]\n /// Trait for moving into a `MaybeOwned`.\n pub trait IntoMaybeOwned<'a> {\n     /// Moves `self` into a `MaybeOwned`.\n     fn into_maybe_owned(self) -> MaybeOwned<'a>;\n }\n \n+#[deprecated = \"use std::borrow::IntoCow\"]\n+#[allow(deprecated)]\n impl<'a> IntoMaybeOwned<'a> for String {\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ``` ignore\n     /// let owned_string = String::from_str(\"orange\");\n     /// let maybe_owned_string = owned_string.into_maybe_owned();\n     /// assert_eq!(true, maybe_owned_string.is_owned());\n     /// ```\n+    #[allow(deprecated)]\n     #[inline]\n     fn into_maybe_owned(self) -> MaybeOwned<'a> {\n         Owned(self)\n     }\n }\n \n+#[deprecated = \"use std::borrow::IntoCow\"]\n+#[allow(deprecated)]\n impl<'a> IntoMaybeOwned<'a> for &'a str {\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ``` ignore\n     /// let string = \"orange\";\n     /// let maybe_owned_str = string.as_slice().into_maybe_owned();\n     /// assert_eq!(false, maybe_owned_str.is_owned());\n     /// ```\n+    #[allow(deprecated)]\n     #[inline]\n     fn into_maybe_owned(self) -> MaybeOwned<'a> { Slice(self) }\n }\n \n+#[allow(deprecated)]\n+#[deprecated = \"use std::borrow::IntoCow\"]\n impl<'a> IntoMaybeOwned<'a> for MaybeOwned<'a> {\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ``` ignore\n     /// let str = \"orange\";\n     /// let maybe_owned_str = str.as_slice().into_maybe_owned();\n     /// let maybe_maybe_owned_str = maybe_owned_str.into_maybe_owned();\n@@ -524,37 +536,44 @@ impl<'a> IntoMaybeOwned<'a> for MaybeOwned<'a> {\n     fn into_maybe_owned(self) -> MaybeOwned<'a> { self }\n }\n \n+#[deprecated = \"use std::str::CowString\"]\n impl<'a> PartialEq for MaybeOwned<'a> {\n     #[inline]\n     fn eq(&self, other: &MaybeOwned) -> bool {\n         self.as_slice() == other.as_slice()\n     }\n }\n \n+#[deprecated = \"use std::str::CowString\"]\n impl<'a> Eq for MaybeOwned<'a> {}\n \n+#[deprecated = \"use std::str::CowString\"]\n impl<'a> PartialOrd for MaybeOwned<'a> {\n     #[inline]\n     fn partial_cmp(&self, other: &MaybeOwned) -> Option<Ordering> {\n         Some(self.cmp(other))\n     }\n }\n \n+#[deprecated = \"use std::str::CowString\"]\n impl<'a> Ord for MaybeOwned<'a> {\n     #[inline]\n     fn cmp(&self, other: &MaybeOwned) -> Ordering {\n         self.as_slice().cmp(other.as_slice())\n     }\n }\n \n+#[deprecated = \"use std::str::CowString\"]\n impl<'a, S: Str> Equiv<S> for MaybeOwned<'a> {\n     #[inline]\n     fn equiv(&self, other: &S) -> bool {\n         self.as_slice() == other.as_slice()\n     }\n }\n \n+#[deprecated = \"use std::str::CowString\"]\n impl<'a> Str for MaybeOwned<'a> {\n+    #[allow(deprecated)]\n     #[inline]\n     fn as_slice<'b>(&'b self) -> &'b str {\n         match *self {\n@@ -564,7 +583,9 @@ impl<'a> Str for MaybeOwned<'a> {\n     }\n }\n \n+#[deprecated = \"use std::str::CowString\"]\n impl<'a> StrAllocating for MaybeOwned<'a> {\n+    #[allow(deprecated)]\n     #[inline]\n     fn into_string(self) -> String {\n         match self {\n@@ -574,7 +595,9 @@ impl<'a> StrAllocating for MaybeOwned<'a> {\n     }\n }\n \n+#[deprecated = \"use std::str::CowString\"]\n impl<'a> Clone for MaybeOwned<'a> {\n+    #[allow(deprecated)]\n     #[inline]\n     fn clone(&self) -> MaybeOwned<'a> {\n         match *self {\n@@ -584,18 +607,22 @@ impl<'a> Clone for MaybeOwned<'a> {\n     }\n }\n \n+#[deprecated = \"use std::str::CowString\"]\n impl<'a> Default for MaybeOwned<'a> {\n+    #[allow(deprecated)]\n     #[inline]\n     fn default() -> MaybeOwned<'a> { Slice(\"\") }\n }\n \n+#[deprecated = \"use std::str::CowString\"]\n impl<'a, H: hash::Writer> hash::Hash<H> for MaybeOwned<'a> {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         self.as_slice().hash(hasher)\n     }\n }\n \n+#[deprecated = \"use std::str::CowString\"]\n impl<'a> fmt::Show for MaybeOwned<'a> {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -613,7 +640,7 @@ impl BorrowFrom<String> for str {\n \n #[unstable = \"trait is unstable\"]\n impl ToOwned<String> for str {\n-    fn to_owned(&self) -> String { self.to_string() }\n+    fn to_owned(&self) -> String { self.into_string() }\n }\n \n /// Unsafe string operations.\n@@ -622,6 +649,13 @@ pub mod raw {\n     pub use core::str::raw::{slice_unchecked};\n }\n \n+/*\n+Section: CowString\n+*/\n+\n+/// A clone-on-write string\n+pub type CowString<'a> = Cow<'a, String, str>;\n+\n /*\n Section: Trait implementations\n */"}, {"sha": "38b67fbd7445189c36c4cf23bf63874d9913e820", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -14,6 +14,7 @@\n \n use core::prelude::*;\n \n+use core::borrow::{Cow, IntoCow};\n use core::default::Default;\n use core::fmt;\n use core::mem;\n@@ -25,8 +26,7 @@ use core::raw::Slice as RawSlice;\n use hash;\n use slice::CloneSliceAllocPrelude;\n use str;\n-use str::{CharRange, FromStr, StrAllocating, MaybeOwned, Owned};\n-use str::Slice as MaybeOwnedSlice; // So many `Slice`s...\n+use str::{CharRange, CowString, FromStr, StrAllocating, Owned};\n use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -121,9 +121,9 @@ impl String {\n     /// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n     /// ```\n     #[unstable = \"return type may change\"]\n-    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n+    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> CowString<'a> {\n         if str::is_utf8(v) {\n-            return MaybeOwnedSlice(unsafe { mem::transmute(v) })\n+            return Cow::Borrowed(unsafe { mem::transmute(v) })\n         }\n \n         static TAG_CONT_U8: u8 = 128u8;\n@@ -234,7 +234,7 @@ impl String {\n                 res.as_mut_vec().push_all(v[subseqidx..total])\n             };\n         }\n-        Owned(res.into_string())\n+        Cow::Owned(res.into_string())\n     }\n \n     /// Decode a UTF-16 encoded vector `v` into a `String`, returning `None`\n@@ -868,6 +868,18 @@ impl<T: fmt::Show> ToString for T {\n     }\n }\n \n+impl IntoCow<'static, String, str> for String {\n+    fn into_cow(self) -> CowString<'static> {\n+        Cow::Owned(self)\n+    }\n+}\n+\n+impl<'a> IntoCow<'a, String, str> for &'a str {\n+    fn into_cow(self) -> CowString<'a> {\n+        Cow::Borrowed(self)\n+    }\n+}\n+\n /// Unsafe operations\n #[deprecated]\n pub mod raw {\n@@ -921,11 +933,11 @@ mod tests {\n     use std::prelude::*;\n     use test::Bencher;\n \n+    use slice::CloneSliceAllocPrelude;\n+    use str::{Str, StrPrelude};\n     use str;\n-    use str::{Str, StrPrelude, Owned};\n     use super::{as_string, String, ToString};\n     use vec::Vec;\n-    use slice::CloneSliceAllocPrelude;\n \n     #[test]\n     fn test_as_string() {\n@@ -955,39 +967,39 @@ mod tests {\n     #[test]\n     fn test_from_utf8_lossy() {\n         let xs = b\"hello\";\n-        assert_eq!(String::from_utf8_lossy(xs), str::Slice(\"hello\"));\n+        assert_eq!(String::from_utf8_lossy(xs), \"hello\".into_cow());\n \n         let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-        assert_eq!(String::from_utf8_lossy(xs), str::Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+        assert_eq!(String::from_utf8_lossy(xs), \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".into_cow());\n \n         let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n         assert_eq!(String::from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"Hello\\uFFFD There\\uFFFD Goodbye\")));\n+                   String::from_str(\"Hello\\uFFFD There\\uFFFD Goodbye\").into_cow());\n \n         let xs = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n         assert_eq!(String::from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\")));\n+                   String::from_str(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\").into_cow());\n \n         let xs = b\"\\xF5foo\\xF5\\x80bar\";\n         assert_eq!(String::from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\")));\n+                   String::from_str(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\").into_cow());\n \n         let xs = b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\";\n         assert_eq!(String::from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\")));\n+                   String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\").into_cow());\n \n         let xs = b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\";\n         assert_eq!(String::from_utf8_lossy(xs),\n-                   Owned(String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\")));\n+                   String::from_str(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\").into_cow());\n \n         let xs = b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\";\n-        assert_eq!(String::from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\\n-                                               foo\\U00010000bar\")));\n+        assert_eq!(String::from_utf8_lossy(xs), String::from_str(\"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\\n+                                               foo\\U00010000bar\").into_cow());\n \n         // surrogates\n         let xs = b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\";\n-        assert_eq!(String::from_utf8_lossy(xs), Owned(String::from_str(\"\\uFFFD\\uFFFD\\uFFFDfoo\\\n-                                               \\uFFFD\\uFFFD\\uFFFDbar\")));\n+        assert_eq!(String::from_utf8_lossy(xs), String::from_str(\"\\uFFFD\\uFFFD\\uFFFDfoo\\\n+                                               \\uFFFD\\uFFFD\\uFFFDbar\").into_cow());\n     }\n \n     #[test]"}, {"sha": "ec520a93c1eae37465e820c00a60241363241429", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -16,6 +16,7 @@ use core::prelude::*;\n \n use alloc::boxed::Box;\n use alloc::heap::{EMPTY, allocate, reallocate, deallocate};\n+use core::borrow::{Cow, IntoCow};\n use core::cmp::max;\n use core::default::Default;\n use core::fmt;\n@@ -107,6 +108,27 @@ pub struct Vec<T> {\n     cap: uint,\n }\n \n+/// A clone-on-write vector\n+pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n+\n+impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n+    fn from_iter<I: Iterator<T>>(it: I) -> CowVec<'a, T> {\n+        Cow::Owned(FromIterator::from_iter(it))\n+    }\n+}\n+\n+impl<'a, T: 'a> IntoCow<'a, Vec<T>, [T]> for Vec<T> where T: Clone {\n+    fn into_cow(self) -> CowVec<'a, T> {\n+        Cow::Owned(self)\n+    }\n+}\n+\n+impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n+    fn into_cow(self) -> CowVec<'a, T> {\n+        Cow::Borrowed(self)\n+    }\n+}\n+\n impl<T> Vec<T> {\n     /// Constructs a new, empty `Vec`.\n     ///"}, {"sha": "06fda8d60928fc46de3cf76e90ab26ea559ebcf4", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -45,8 +45,11 @@\n #![unstable = \"recently added as part of collections reform\"]\n \n use clone::Clone;\n+use cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n+use fmt;\n use kinds::Sized;\n use ops::Deref;\n+use option::Option;\n use self::Cow::*;\n \n /// A trait for borrowing data.\n@@ -81,6 +84,24 @@ impl<'a, Sized? T> BorrowFromMut<&'a mut T> for T {\n     fn borrow_from_mut<'b>(owned: &'b mut &'a mut T) -> &'b mut T { &mut **owned }\n }\n \n+impl<'a, T, Sized? B> BorrowFrom<Cow<'a, T, B>> for B where B: ToOwned<T> {\n+    fn borrow_from<'b>(owned: &'b Cow<'a, T, B>) -> &'b B {\n+        &**owned\n+    }\n+}\n+\n+/// Trait for moving into a `Cow`\n+pub trait IntoCow<'a, T, Sized? B> {\n+    /// Moves `self` into `Cow`\n+    fn into_cow(self) -> Cow<'a, T, B>;\n+}\n+\n+impl<'a, T, Sized? B> IntoCow<'a, T, B> for Cow<'a, T, B> where B: ToOwned<T> {\n+    fn into_cow(self) -> Cow<'a, T, B> {\n+        self\n+    }\n+}\n+\n /// A generalization of Clone to borrowed data.\n pub trait ToOwned<Owned> for Sized?: BorrowFrom<Owned> {\n     /// Create owned data from borrowed data, usually by copying.\n@@ -139,6 +160,22 @@ impl<'a, T, Sized? B> Cow<'a, T, B> where B: ToOwned<T> {\n             Owned(owned) => owned\n         }\n     }\n+\n+    /// Returns true if this `Cow` wraps a borrowed value\n+    pub fn is_borrowed(&self) -> bool {\n+        match *self {\n+            Borrowed(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this `Cow` wraps an owned value\n+    pub fn is_owned(&self) -> bool {\n+        match *self {\n+            Owned(_) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n impl<'a, T, Sized? B> Deref<B> for Cow<'a, T, B> where B: ToOwned<T>  {\n@@ -149,3 +186,35 @@ impl<'a, T, Sized? B> Deref<B> for Cow<'a, T, B> where B: ToOwned<T>  {\n         }\n     }\n }\n+\n+impl<'a, T, Sized? B> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n+\n+impl<'a, T, Sized? B> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n+    #[inline]\n+    fn cmp(&self, other: &Cow<'a, T, B>) -> Ordering {\n+        Ord::cmp(&**self, &**other)\n+    }\n+}\n+\n+impl<'a, T, Sized? B> PartialEq for Cow<'a, T, B> where B: PartialEq + ToOwned<T> {\n+    #[inline]\n+    fn eq(&self, other: &Cow<'a, T, B>) -> bool {\n+        PartialEq::eq(&**self, &**other)\n+    }\n+}\n+\n+impl<'a, T, Sized? B> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Cow<'a, T, B>) -> Option<Ordering> {\n+        PartialOrd::partial_cmp(&**self, &**other)\n+    }\n+}\n+\n+impl<'a, T, Sized? B> fmt::Show for Cow<'a, T, B> where B: fmt::Show + ToOwned<T>, T: fmt::Show {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Borrowed(ref b) => fmt::Show::fmt(b, f),\n+            Owned(ref o) => fmt::Show::fmt(o, f),\n+        }\n+    }\n+}"}, {"sha": "f149ec509af053f0be6eb05e03526372c774f54d", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -37,7 +37,7 @@ pairs of ints, representing the edges (the node set is implicit).\n Each node label is derived directly from the int representing the node,\n while the edge labels are all empty strings.\n \n-This example also illustrates how to use `MaybeOwnedVector` to return\n+This example also illustrates how to use `CowVec` to return\n an owned vector or a borrowed slice as appropriate: we construct the\n node vector from scratch, but borrow the edge list (rather than\n constructing a copy of all the edges from scratch).\n@@ -48,7 +48,6 @@ which is cyclic.\n \n ```rust\n use graphviz as dot;\n-use graphviz::maybe_owned_vec::IntoMaybeOwnedVector;\n \n type Nd = int;\n type Ed = (int,int);\n@@ -77,12 +76,12 @@ impl<'a> dot::GraphWalk<'a, Nd, Ed> for Edges {\n         }\n         nodes.sort();\n         nodes.dedup();\n-        nodes.into_maybe_owned()\n+        nodes.into_cow()\n     }\n \n     fn edges(&'a self) -> dot::Edges<'a,Ed> {\n         let &Edges(ref edges) = self;\n-        edges.as_slice().into_maybe_owned()\n+        edges.as_slice().into_cow()\n     }\n \n     fn source(&self, e: &Ed) -> Nd { let &(s,_) = e; s }\n@@ -137,8 +136,8 @@ edges stored in `self`.\n Since both the set of nodes and the set of edges are always\n constructed from scratch via iterators, we use the `collect()` method\n from the `Iterator` trait to collect the nodes and edges into freshly\n-constructed growable `Vec` values (rather use the `into_maybe_owned`\n-from the `IntoMaybeOwnedVector` trait as was used in the first example\n+constructed growable `Vec` values (rather use the `into_cow`\n+from the `IntoCow` trait as was used in the first example\n above).\n \n The output from this example renders four nodes that make up the\n@@ -148,7 +147,6 @@ entity `&sube`).\n \n ```rust\n use graphviz as dot;\n-use std::str;\n \n type Nd = uint;\n type Ed<'a> = &'a (uint, uint);\n@@ -168,10 +166,10 @@ impl<'a> dot::Labeller<'a, Nd, Ed<'a>> for Graph {\n         dot::Id::new(format!(\"N{}\", n)).unwrap()\n     }\n     fn node_label<'a>(&'a self, n: &Nd) -> dot::LabelText<'a> {\n-        dot::LabelStr(str::Slice(self.nodes[*n].as_slice()))\n+        dot::LabelStr(self.nodes[*n].as_slice().into_cow())\n     }\n     fn edge_label<'a>(&'a self, _: &Ed) -> dot::LabelText<'a> {\n-        dot::LabelStr(str::Slice(\"&sube;\"))\n+        dot::LabelStr(\"&sube;\".into_cow())\n     }\n }\n \n@@ -204,7 +202,6 @@ Hasse-diagram for the subsets of the set `{x, y}`.\n \n ```rust\n use graphviz as dot;\n-use std::str;\n \n type Nd<'a> = (uint, &'a str);\n type Ed<'a> = (Nd<'a>, Nd<'a>);\n@@ -225,10 +222,10 @@ impl<'a> dot::Labeller<'a, Nd<'a>, Ed<'a>> for Graph {\n     }\n     fn node_label<'a>(&'a self, n: &Nd<'a>) -> dot::LabelText<'a> {\n         let &(i, _) = n;\n-        dot::LabelStr(str::Slice(self.nodes[i].as_slice()))\n+        dot::LabelStr(self.nodes[i].as_slice().into_cow())\n     }\n     fn edge_label<'a>(&'a self, _: &Ed<'a>) -> dot::LabelText<'a> {\n-        dot::LabelStr(str::Slice(\"&sube;\"))\n+        dot::LabelStr(\"&sube;\".into_cow())\n     }\n }\n \n@@ -279,8 +276,8 @@ pub fn main() {\n pub use self::LabelText::*;\n \n use std::io;\n-use std::str;\n-use self::maybe_owned_vec::MaybeOwnedVector;\n+use std::str::CowString;\n+use std::vec::CowVec;\n \n pub mod maybe_owned_vec;\n \n@@ -290,7 +287,7 @@ pub enum LabelText<'a> {\n     ///\n     /// Occurrences of backslashes (`\\`) are escaped, and thus appear\n     /// as backslashes in the rendered label.\n-    LabelStr(str::MaybeOwned<'a>),\n+    LabelStr(CowString<'a>),\n \n     /// This kind of label uses the graphviz label escString type:\n     /// http://www.graphviz.org/content/attrs#kescString\n@@ -302,7 +299,7 @@ pub enum LabelText<'a> {\n     /// to break a line (centering the line preceding the `\\n`), there\n     /// are also the escape sequences `\\l` which left-justifies the\n     /// preceding line and `\\r` which right-justifies it.\n-    EscStr(str::MaybeOwned<'a>),\n+    EscStr(CowString<'a>),\n }\n \n // There is a tension in the design of the labelling API.\n@@ -339,7 +336,7 @@ pub enum LabelText<'a> {\n \n /// `Id` is a Graphviz `ID`.\n pub struct Id<'a> {\n-    name: str::MaybeOwned<'a>,\n+    name: CowString<'a>,\n }\n \n impl<'a> Id<'a> {\n@@ -357,10 +354,10 @@ impl<'a> Id<'a> {\n     ///\n     /// Passing an invalid string (containing spaces, brackets,\n     /// quotes, ...) will return an empty `Err` value.\n-    pub fn new<Name:str::IntoMaybeOwned<'a>>(name: Name) -> Result<Id<'a>, ()> {\n-        let name = name.into_maybe_owned();\n+    pub fn new<Name: IntoCow<'a, String, str>>(name: Name) -> Result<Id<'a>, ()> {\n+        let name = name.into_cow();\n         {\n-            let mut chars = name.as_slice().chars();\n+            let mut chars = name.chars();\n             match chars.next() {\n                 Some(c) if is_letter_or_underscore(c) => { ; },\n                 _ => return Err(())\n@@ -383,10 +380,10 @@ impl<'a> Id<'a> {\n     }\n \n     pub fn as_slice(&'a self) -> &'a str {\n-        self.name.as_slice()\n+        &*self.name\n     }\n \n-    pub fn name(self) -> str::MaybeOwned<'a> {\n+    pub fn name(self) -> CowString<'a> {\n         self.name\n     }\n }\n@@ -421,7 +418,7 @@ pub trait Labeller<'a,N,E> {\n     /// default is in fact the empty string.\n     fn edge_label(&'a self, e: &E) -> LabelText<'a> {\n         let _ignored = e;\n-        LabelStr(str::Slice(\"\"))\n+        LabelStr(\"\".into_cow())\n     }\n }\n \n@@ -454,11 +451,11 @@ impl<'a> LabelText<'a> {\n     /// yields same content as self.  The result obeys the law\n     /// render(`lt`) == render(`EscStr(lt.pre_escaped_content())`) for\n     /// all `lt: LabelText`.\n-    fn pre_escaped_content(self) -> str::MaybeOwned<'a> {\n+    fn pre_escaped_content(self) -> CowString<'a> {\n         match self {\n             EscStr(s) => s,\n-            LabelStr(s) => if s.as_slice().contains_char('\\\\') {\n-                str::Owned(s.as_slice().escape_default())\n+            LabelStr(s) => if s.contains_char('\\\\') {\n+                s.escape_default().into_cow()\n             } else {\n                 s\n             },\n@@ -476,12 +473,12 @@ impl<'a> LabelText<'a> {\n         let suffix = suffix.pre_escaped_content();\n         prefix.push_str(r\"\\n\\n\");\n         prefix.push_str(suffix.as_slice());\n-        EscStr(str::Owned(prefix))\n+        EscStr(prefix.into_cow())\n     }\n }\n \n-pub type Nodes<'a,N> = MaybeOwnedVector<'a,N>;\n-pub type Edges<'a,E> = MaybeOwnedVector<'a,E>;\n+pub type Nodes<'a,N> = CowVec<'a,N>;\n+pub type Edges<'a,E> = CowVec<'a,E>;\n \n // (The type parameters in GraphWalk should be associated items,\n // when/if Rust supports such.)\n@@ -496,7 +493,7 @@ pub type Edges<'a,E> = MaybeOwnedVector<'a,E>;\n /// that is bound by the self lifetime `'a`.\n ///\n /// The `nodes` and `edges` method each return instantiations of\n-/// `MaybeOwnedVector` to leave implementers the freedom to create\n+/// `CowVec` to leave implementers the freedom to create\n /// entirely new vectors or to pass back slices into internally owned\n /// vectors.\n pub trait GraphWalk<'a, N, E> {\n@@ -512,7 +509,7 @@ pub trait GraphWalk<'a, N, E> {\n \n /// Renders directed graph `g` into the writer `w` in DOT syntax.\n /// (Main entry point for the library.)\n-pub fn render<'a, N:'a, E:'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Writer>(\n+pub fn render<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Writer>(\n               g: &'a G,\n               w: &mut W) -> io::IoResult<()>\n {\n@@ -647,12 +644,12 @@ mod tests {\n         }\n         fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n             match self.node_labels[*n] {\n-                Some(ref l) => LabelStr(str::Slice(l.as_slice())),\n+                Some(ref l) => LabelStr(l.into_cow()),\n                 None        => LabelStr(id_name(n).name()),\n             }\n         }\n         fn edge_label(&'a self, e: & &'a Edge) -> LabelText<'a> {\n-            LabelStr(str::Slice(e.label.as_slice()))\n+            LabelStr(e.label.into_cow())\n         }\n     }\n "}, {"sha": "6482a514115aaa3e1c823cf60f5982c1a3c72f98", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deprecated = \"use std::vec::CowVec\"]\n+\n pub use self::MaybeOwnedVector::*;\n \n use std::default::Default;\n@@ -46,12 +48,16 @@ pub trait IntoMaybeOwnedVector<'a,T> {\n     fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T>;\n }\n \n+#[allow(deprecated)]\n impl<'a,T:'a> IntoMaybeOwnedVector<'a,T> for Vec<T> {\n+    #[allow(deprecated)]\n     #[inline]\n     fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { Growable(self) }\n }\n \n+#[allow(deprecated)]\n impl<'a,T> IntoMaybeOwnedVector<'a,T> for &'a [T] {\n+    #[allow(deprecated)]\n     #[inline]\n     fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { Borrowed(self) }\n }\n@@ -66,6 +72,7 @@ impl<'a,T> MaybeOwnedVector<'a,T> {\n \n     pub fn len(&self) -> uint { self.as_slice().len() }\n \n+    #[allow(deprecated)]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n@@ -114,6 +121,7 @@ impl<'b,T> AsSlice<T> for MaybeOwnedVector<'b,T> {\n }\n \n impl<'a,T> FromIterator<T> for MaybeOwnedVector<'a,T> {\n+    #[allow(deprecated)]\n     fn from_iter<I:Iterator<T>>(iterator: I) -> MaybeOwnedVector<'a,T> {\n         // If we are building from scratch, might as well build the\n         // most flexible variant.\n@@ -143,6 +151,7 @@ impl<'a,T:Clone> CloneSliceAllocPrelude<T> for MaybeOwnedVector<'a,T> {\n }\n \n impl<'a, T: Clone> Clone for MaybeOwnedVector<'a, T> {\n+    #[allow(deprecated)]\n     fn clone(&self) -> MaybeOwnedVector<'a, T> {\n         match *self {\n             Growable(ref v) => Growable(v.clone()),\n@@ -152,6 +161,7 @@ impl<'a, T: Clone> Clone for MaybeOwnedVector<'a, T> {\n }\n \n impl<'a, T> Default for MaybeOwnedVector<'a, T> {\n+    #[allow(deprecated)]\n     fn default() -> MaybeOwnedVector<'a, T> {\n         Growable(Vec::new())\n     }"}, {"sha": "58ce72a31736d517af3f624a70ca7d9b1dce0fb3", "filename": "src/libregex/re.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -13,7 +13,7 @@ pub use self::Regex::*;\n \n use std::collections::HashMap;\n use std::fmt;\n-use std::str::{MaybeOwned, Owned, Slice};\n+use std::str::CowString;\n \n use compile::Program;\n use parse;\n@@ -565,25 +565,25 @@ pub trait Replacer {\n     ///\n     /// The `'a` lifetime refers to the lifetime of a borrowed string when\n     /// a new owned string isn't needed (e.g., for `NoExpand`).\n-    fn reg_replace<'a>(&'a mut self, caps: &Captures) -> MaybeOwned<'a>;\n+    fn reg_replace<'a>(&'a mut self, caps: &Captures) -> CowString<'a>;\n }\n \n impl<'t> Replacer for NoExpand<'t> {\n-    fn reg_replace<'a>(&'a mut self, _: &Captures) -> MaybeOwned<'a> {\n+    fn reg_replace<'a>(&'a mut self, _: &Captures) -> CowString<'a> {\n         let NoExpand(s) = *self;\n-        Slice(s)\n+        s.into_cow()\n     }\n }\n \n impl<'t> Replacer for &'t str {\n-    fn reg_replace<'a>(&'a mut self, caps: &Captures) -> MaybeOwned<'a> {\n-        Owned(caps.expand(*self))\n+    fn reg_replace<'a>(&'a mut self, caps: &Captures) -> CowString<'a> {\n+        caps.expand(*self).into_cow()\n     }\n }\n \n impl<'t> Replacer for |&Captures|: 't -> String {\n-    fn reg_replace<'a>(&'a mut self, caps: &Captures) -> MaybeOwned<'a> {\n-        Owned((*self)(caps))\n+    fn reg_replace<'a>(&'a mut self, caps: &Captures) -> CowString<'a> {\n+        (*self)(caps).into_cow()\n     }\n }\n "}, {"sha": "a209b1a28f284427d55ab48f282c3a944901dfe0", "filename": "src/librustc/middle/borrowck/graphviz.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -26,7 +26,6 @@ use middle::dataflow::{DataFlowOperator, DataFlowContext, EntryOrExit};\n use middle::dataflow;\n \n use std::rc::Rc;\n-use std::str;\n \n #[deriving(Show)]\n pub enum Variant {\n@@ -137,8 +136,8 @@ impl<'a, 'tcx> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a, 't\n         let suffix = self.dataflow_for(dataflow::Exit, n);\n         let inner_label = self.inner.node_label(n);\n         inner_label\n-            .prefix_line(dot::LabelStr(str::Owned(prefix)))\n-            .suffix_line(dot::LabelStr(str::Owned(suffix)))\n+            .prefix_line(dot::LabelStr(prefix.into_cow()))\n+            .suffix_line(dot::LabelStr(suffix.into_cow()))\n     }\n     fn edge_label(&'a self, e: &Edge<'a>) -> dot::LabelText<'a> { self.inner.edge_label(e) }\n }"}, {"sha": "8e0e8ee1c5ee03c0d77349250e73f8bbea291fc6", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -58,16 +58,16 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n \n     fn node_label(&'a self, &(i, n): &Node<'a>) -> dot::LabelText<'a> {\n         if i == self.cfg.entry {\n-            dot::LabelStr(\"entry\".into_maybe_owned())\n+            dot::LabelStr(\"entry\".into_cow())\n         } else if i == self.cfg.exit {\n-            dot::LabelStr(\"exit\".into_maybe_owned())\n+            dot::LabelStr(\"exit\".into_cow())\n         } else if n.data.id == ast::DUMMY_NODE_ID {\n-            dot::LabelStr(\"(dummy_node)\".into_maybe_owned())\n+            dot::LabelStr(\"(dummy_node)\".into_cow())\n         } else {\n             let s = self.ast_map.node_to_string(n.data.id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n-            dot::EscStr(s.into_maybe_owned())\n+            dot::EscStr(s.into_cow())\n         }\n     }\n \n@@ -86,15 +86,15 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             label.push_str(format!(\"exiting scope_{} {}\", i,\n                                    s.as_slice()).as_slice());\n         }\n-        dot::EscStr(label.into_maybe_owned())\n+        dot::EscStr(label.into_cow())\n     }\n }\n \n impl<'a> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for &'a cfg::CFG {\n     fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> {\n         let mut v = Vec::new();\n         self.graph.each_node(|i, nd| { v.push((i, nd)); true });\n-        dot::maybe_owned_vec::Growable(v)\n+        v.into_cow()\n     }\n     fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> {\n         self.graph.all_edges().iter().collect()"}, {"sha": "ce3440ead4000af4a5c05428a781d11e811824c1", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -74,7 +74,7 @@ use fmt;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str;\n-use str::{MaybeOwned, Str, StrPrelude};\n+use str::{CowString, MaybeOwned, Str, StrPrelude};\n use string::String;\n use slice::{AsSlice, CloneSliceAllocPrelude};\n use slice::{PartialEqSlicePrelude, SlicePrelude};\n@@ -830,7 +830,7 @@ pub struct Display<'a, P:'a> {\n \n impl<'a, P: GenericPath> fmt::Show for Display<'a, P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_maybe_owned().as_slice().fmt(f)\n+        self.as_cow().fmt(f)\n     }\n }\n \n@@ -840,7 +840,7 @@ impl<'a, P: GenericPath> Display<'a, P> {\n     /// If the path is not UTF-8, invalid sequences will be replaced with the\n     /// Unicode replacement char. This involves allocation.\n     #[inline]\n-    pub fn as_maybe_owned(&self) -> MaybeOwned<'a> {\n+    pub fn as_cow(&self) -> CowString<'a> {\n         String::from_utf8_lossy(if self.filename {\n             match self.path.filename() {\n                 None => {"}, {"sha": "bdce759a1df37b22f244f5ba6d7efc0eca31fa4a", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -551,14 +551,14 @@ mod tests {\n             ($path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    let mo = path.display().as_maybe_owned();\n+                    let mo = path.display().as_cow();\n                     assert!(mo.as_slice() == $exp);\n                 }\n             );\n             ($path:expr, $exp:expr, filename) => (\n                 {\n                     let path = Path::new($path);\n-                    let mo = path.filename_display().as_maybe_owned();\n+                    let mo = path.filename_display().as_cow();\n                     assert!(mo.as_slice() == $exp);\n                 }\n             )"}, {"sha": "fc367710131390510fb0ec996c3d29d1ce6c7dcc", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -1326,10 +1326,10 @@ mod tests {\n         assert_eq!(path.filename_display().to_string(), \"\".to_string());\n \n         let path = Path::new(\"foo\");\n-        let mo = path.display().as_maybe_owned();\n+        let mo = path.display().as_cow();\n         assert_eq!(mo.as_slice(), \"foo\");\n         let path = Path::new(b\"\\\\\");\n-        let mo = path.filename_display().as_maybe_owned();\n+        let mo = path.filename_display().as_cow();\n         assert_eq!(mo.as_slice(), \"\");\n     }\n "}, {"sha": "756ff1c58f30375595e89b3ea03cebd01b5be0c7", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -58,6 +58,7 @@\n \n #[doc(no_inline)] pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr};\n #[doc(no_inline)] pub use ascii::IntoBytes;\n+#[doc(no_inline)] pub use borrow::IntoCow;\n #[doc(no_inline)] pub use c_str::ToCStr;\n #[doc(no_inline)] pub use char::{Char, UnicodeChar};\n #[doc(no_inline)] pub use clone::Clone;\n@@ -78,7 +79,7 @@\n #[doc(no_inline)] pub use result::Result::{Ok, Err};\n #[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek, BufferPrelude};\n #[doc(no_inline)] pub use str::{Str, StrVector, StrPrelude};\n-#[doc(no_inline)] pub use str::{IntoMaybeOwned, StrAllocating, UnicodeStrPrelude};\n+#[doc(no_inline)] pub use str::{StrAllocating, UnicodeStrPrelude};\n #[doc(no_inline)] pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n #[doc(no_inline)] pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n #[doc(no_inline)] pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};"}, {"sha": "872a545224184863f1cc990aaeadd367c8348b59", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -56,6 +56,7 @@ Several modules in `core` are clients of `rt`:\n \n #![allow(dead_code)]\n \n+use borrow::IntoCow;\n use failure;\n use rustrt;\n use os;\n@@ -113,7 +114,6 @@ pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n     use prelude::*;\n     use rt;\n     use rustrt::task::Task;\n-    use str;\n \n     let something_around_the_top_of_the_stack = 1;\n     let addr = &something_around_the_top_of_the_stack as *const int;\n@@ -147,7 +147,7 @@ pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n     let mut main = Some(main);\n     let mut task = box Task::new(Some((my_stack_bottom, my_stack_top)),\n                                  Some(rustrt::thread::main_guard_page()));\n-    task.name = Some(str::Slice(\"<main>\"));\n+    task.name = Some(\"<main>\".into_cow());\n     drop(task.run(|| {\n         unsafe {\n             rustrt::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);"}, {"sha": "a0ee08570d90d03050573a72d906b34fea994315", "filename": "src/libstd/task.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -44,16 +44,17 @@\n                will likely be renamed from `task` to `thread`.\"]\n \n use any::Any;\n+use borrow::IntoCow;\n+use boxed::Box;\n use comm::channel;\n use io::{Writer, stdio};\n use kinds::{Send, marker};\n use option::{None, Some, Option};\n-use boxed::Box;\n use result::Result;\n use rustrt::local::Local;\n-use rustrt::task;\n use rustrt::task::Task;\n-use str::{Str, SendStr, IntoMaybeOwned};\n+use rustrt::task;\n+use str::{Str, SendStr};\n use string::{String, ToString};\n use sync::Future;\n \n@@ -101,8 +102,8 @@ impl TaskBuilder {\n     /// Name the task-to-be. Currently the name is used for identification\n     /// only in panic messages.\n     #[unstable = \"IntoMaybeOwned will probably change.\"]\n-    pub fn named<T: IntoMaybeOwned<'static>>(mut self, name: T) -> TaskBuilder {\n-        self.name = Some(name.into_maybe_owned());\n+    pub fn named<T: IntoCow<'static, String, str>>(mut self, name: T) -> TaskBuilder {\n+        self.name = Some(name.into_cow());\n         self\n     }\n \n@@ -264,12 +265,13 @@ pub fn failing() -> bool {\n #[cfg(test)]\n mod test {\n     use any::{Any, AnyRefExt};\n+    use borrow::IntoCow;\n     use boxed::BoxAny;\n-    use result;\n+    use prelude::*;\n     use result::{Ok, Err};\n-    use string::String;\n+    use result;\n     use std::io::{ChanReader, ChanWriter};\n-    use prelude::*;\n+    use string::String;\n     use super::*;\n \n     // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n@@ -298,7 +300,7 @@ mod test {\n \n     #[test]\n     fn test_send_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\".into_maybe_owned()).try(proc() {\n+        TaskBuilder::new().named(\"ada lovelace\".into_cow()).try(proc() {\n             assert!(name().unwrap() == \"ada lovelace\".to_string());\n         }).map_err(|_| ()).unwrap();\n     }"}, {"sha": "b5358e7d4859d747fd5d575d9c96585e2e1c8994", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -272,21 +272,21 @@ impl<'a> StringReader<'a> {\n \n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n     fn translate_crlf<'a>(&self, start: BytePos,\n-                          s: &'a str, errmsg: &'a str) -> str::MaybeOwned<'a> {\n+                          s: &'a str, errmsg: &'a str) -> str::CowString<'a> {\n         let mut i = 0u;\n         while i < s.len() {\n             let str::CharRange { ch, next } = s.char_range_at(i);\n             if ch == '\\r' {\n                 if next < s.len() && s.char_at(next) == '\\n' {\n-                    return translate_crlf_(self, start, s, errmsg, i).into_maybe_owned();\n+                    return translate_crlf_(self, start, s, errmsg, i).into_cow();\n                 }\n                 let pos = start + BytePos(i as u32);\n                 let end_pos = start + BytePos(next as u32);\n                 self.err_span_(pos, end_pos, errmsg);\n             }\n             i = next;\n         }\n-        return s.into_maybe_owned();\n+        return s.into_cow();\n \n         fn translate_crlf_(rdr: &StringReader, start: BytePos,\n                         s: &str, errmsg: &str, mut i: uint) -> String {\n@@ -550,7 +550,7 @@ impl<'a> StringReader<'a> {\n                 let string = if has_cr {\n                     self.translate_crlf(start_bpos, string,\n                                         \"bare CR not allowed in block doc-comment\")\n-                } else { string.into_maybe_owned() };\n+                } else { string.into_cow() };\n                 token::DocComment(token::intern(string.as_slice()))\n             } else {\n                 token::Comment"}, {"sha": "c731a0005f8843228efff3f7ecf7942932baa771", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -4966,10 +4966,10 @@ impl<'a> Parser<'a> {\n                 let mut err = String::from_str(\"circular modules: \");\n                 let len = included_mod_stack.len();\n                 for p in included_mod_stack.slice(i, len).iter() {\n-                    err.push_str(p.display().as_maybe_owned().as_slice());\n+                    err.push_str(p.display().as_cow().as_slice());\n                     err.push_str(\" -> \");\n                 }\n-                err.push_str(path.display().as_maybe_owned().as_slice());\n+                err.push_str(path.display().as_cow().as_slice());\n                 self.span_fatal(id_sp, err.as_slice());\n             }\n             None => ()"}, {"sha": "fb4fb5c2f7081a949aa938d828e56de2f9ff237d", "filename": "src/test/run-fail/panic-task-name-send-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Ftest%2Frun-fail%2Fpanic-task-name-send-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Ftest%2Frun-fail%2Fpanic-task-name-send-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-send-str.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -12,7 +12,7 @@\n \n fn main() {\n     let r: Result<int,_> =\n-        ::std::task::TaskBuilder::new().named(\"send name\".into_maybe_owned())\n+        ::std::task::TaskBuilder::new().named(\"send name\".into_cow())\n                                        .try(proc() {\n             panic!(\"test\");\n             3i"}, {"sha": "ef485723c7e2b7c189b449f3fc1d5ee29927e8d6", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -10,51 +10,51 @@\n \n extern crate collections;\n \n-use std::str::{SendStr, Owned, Slice};\n use std::collections::HashMap;\n use std::option::Some;\n+use std::str::SendStr;\n \n pub fn main() {\n     let mut map: HashMap<SendStr, uint> = HashMap::new();\n-    assert!(map.insert(Slice(\"foo\"), 42).is_none());\n-    assert!(map.insert(Owned(\"foo\".to_string()), 42).is_some());\n-    assert!(map.insert(Slice(\"foo\"), 42).is_some());\n-    assert!(map.insert(Owned(\"foo\".to_string()), 42).is_some());\n+    assert!(map.insert(\"foo\".into_cow(), 42).is_none());\n+    assert!(map.insert(\"foo\".to_string().into_cow(), 42).is_some());\n+    assert!(map.insert(\"foo\".into_cow(), 42).is_some());\n+    assert!(map.insert(\"foo\".to_string().into_cow(), 42).is_some());\n \n-    assert!(map.insert(Slice(\"foo\"), 43).is_some());\n-    assert!(map.insert(Owned(\"foo\".to_string()), 44).is_some());\n-    assert!(map.insert(Slice(\"foo\"), 45).is_some());\n-    assert!(map.insert(Owned(\"foo\".to_string()), 46).is_some());\n+    assert!(map.insert(\"foo\".into_cow(), 43).is_some());\n+    assert!(map.insert(\"foo\".to_string().into_cow(), 44).is_some());\n+    assert!(map.insert(\"foo\".into_cow(), 45).is_some());\n+    assert!(map.insert(\"foo\".to_string().into_cow(), 46).is_some());\n \n     let v = 46;\n \n-    assert_eq!(map.get(&Owned(\"foo\".to_string())), Some(&v));\n-    assert_eq!(map.get(&Slice(\"foo\")), Some(&v));\n+    assert_eq!(map.get(&\"foo\".to_string().into_cow()), Some(&v));\n+    assert_eq!(map.get(&\"foo\".into_cow()), Some(&v));\n \n     let (a, b, c, d) = (50, 51, 52, 53);\n \n-    assert!(map.insert(Slice(\"abc\"), a).is_none());\n-    assert!(map.insert(Owned(\"bcd\".to_string()), b).is_none());\n-    assert!(map.insert(Slice(\"cde\"), c).is_none());\n-    assert!(map.insert(Owned(\"def\".to_string()), d).is_none());\n-\n-    assert!(map.insert(Slice(\"abc\"), a).is_some());\n-    assert!(map.insert(Owned(\"bcd\".to_string()), b).is_some());\n-    assert!(map.insert(Slice(\"cde\"), c).is_some());\n-    assert!(map.insert(Owned(\"def\".to_string()), d).is_some());\n-\n-    assert!(map.insert(Owned(\"abc\".to_string()), a).is_some());\n-    assert!(map.insert(Slice(\"bcd\"), b).is_some());\n-    assert!(map.insert(Owned(\"cde\".to_string()), c).is_some());\n-    assert!(map.insert(Slice(\"def\"), d).is_some());\n-\n-    assert_eq!(map.find_equiv(\"abc\"), Some(&a));\n-    assert_eq!(map.find_equiv(\"bcd\"), Some(&b));\n-    assert_eq!(map.find_equiv(\"cde\"), Some(&c));\n-    assert_eq!(map.find_equiv(\"def\"), Some(&d));\n-\n-    assert_eq!(map.find_equiv(&Slice(\"abc\")), Some(&a));\n-    assert_eq!(map.find_equiv(&Slice(\"bcd\")), Some(&b));\n-    assert_eq!(map.find_equiv(&Slice(\"cde\")), Some(&c));\n-    assert_eq!(map.find_equiv(&Slice(\"def\")), Some(&d));\n+    assert!(map.insert(\"abc\".into_cow(), a).is_none());\n+    assert!(map.insert(\"bcd\".to_string().into_cow(), b).is_none());\n+    assert!(map.insert(\"cde\".into_cow(), c).is_none());\n+    assert!(map.insert(\"def\".to_string().into_cow(), d).is_none());\n+\n+    assert!(map.insert(\"abc\".into_cow(), a).is_some());\n+    assert!(map.insert(\"bcd\".to_string().into_cow(), b).is_some());\n+    assert!(map.insert(\"cde\".into_cow(), c).is_some());\n+    assert!(map.insert(\"def\".to_string().into_cow(), d).is_some());\n+\n+    assert!(map.insert(\"abc\".to_string().into_cow(), a).is_some());\n+    assert!(map.insert(\"bcd\".into_cow(), b).is_some());\n+    assert!(map.insert(\"cde\".to_string().into_cow(), c).is_some());\n+    assert!(map.insert(\"def\".into_cow(), d).is_some());\n+\n+    assert_eq!(map.get(\"abc\"), Some(&a));\n+    assert_eq!(map.get(\"bcd\"), Some(&b));\n+    assert_eq!(map.get(\"cde\"), Some(&c));\n+    assert_eq!(map.get(\"def\"), Some(&d));\n+\n+    assert_eq!(map.get(&\"abc\".into_cow()), Some(&a));\n+    assert_eq!(map.get(&\"bcd\".into_cow()), Some(&b));\n+    assert_eq!(map.get(&\"cde\".into_cow()), Some(&c));\n+    assert_eq!(map.get(&\"def\".into_cow()), Some(&d));\n }"}, {"sha": "f72ca109b6e68e2946a90574c2e9ad8057a6419c", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb027e398ef756b7b02a270ef0304be92e70f4d/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=8fb027e398ef756b7b02a270ef0304be92e70f4d", "patch": "@@ -10,56 +10,56 @@\n \n extern crate collections;\n \n-use std::str::{SendStr, Owned, Slice};\n-use std::string::ToString;\n use self::collections::TreeMap;\n use std::option::Some;\n+use std::str::SendStr;\n+use std::string::ToString;\n \n pub fn main() {\n     let mut map: TreeMap<SendStr, uint> = TreeMap::new();\n-    assert!(map.insert(Slice(\"foo\"), 42).is_none());\n-    assert!(map.insert(Owned(\"foo\".to_string()), 42).is_some());\n-    assert!(map.insert(Slice(\"foo\"), 42).is_some());\n-    assert!(map.insert(Owned(\"foo\".to_string()), 42).is_some());\n+    assert!(map.insert(\"foo\".into_cow(), 42).is_none());\n+    assert!(map.insert(\"foo\".to_string().into_cow(), 42).is_some());\n+    assert!(map.insert(\"foo\".into_cow(), 42).is_some());\n+    assert!(map.insert(\"foo\".to_string().into_cow(), 42).is_some());\n \n-    assert!(map.insert(Slice(\"foo\"), 43).is_some());\n-    assert!(map.insert(Owned(\"foo\".to_string()), 44).is_some());\n-    assert!(map.insert(Slice(\"foo\"), 45).is_some());\n-    assert!(map.insert(Owned(\"foo\".to_string()), 46).is_some());\n+    assert!(map.insert(\"foo\".into_cow(), 43).is_some());\n+    assert!(map.insert(\"foo\".to_string().into_cow(), 44).is_some());\n+    assert!(map.insert(\"foo\".into_cow(), 45).is_some());\n+    assert!(map.insert(\"foo\".to_string().into_cow(), 46).is_some());\n \n     let v = 46;\n \n-    assert_eq!(map.get(&Owned(\"foo\".to_string())), Some(&v));\n-    assert_eq!(map.get(&Slice(\"foo\")), Some(&v));\n+    assert_eq!(map.get(&\"foo\".to_string().into_cow()), Some(&v));\n+    assert_eq!(map.get(&\"foo\".into_cow()), Some(&v));\n \n     let (a, b, c, d) = (50, 51, 52, 53);\n \n-    assert!(map.insert(Slice(\"abc\"), a).is_none());\n-    assert!(map.insert(Owned(\"bcd\".to_string()), b).is_none());\n-    assert!(map.insert(Slice(\"cde\"), c).is_none());\n-    assert!(map.insert(Owned(\"def\".to_string()), d).is_none());\n+    assert!(map.insert(\"abc\".into_cow(), a).is_none());\n+    assert!(map.insert(\"bcd\".to_string().into_cow(), b).is_none());\n+    assert!(map.insert(\"cde\".into_cow(), c).is_none());\n+    assert!(map.insert(\"def\".to_string().into_cow(), d).is_none());\n \n-    assert!(map.insert(Slice(\"abc\"), a).is_some());\n-    assert!(map.insert(Owned(\"bcd\".to_string()), b).is_some());\n-    assert!(map.insert(Slice(\"cde\"), c).is_some());\n-    assert!(map.insert(Owned(\"def\".to_string()), d).is_some());\n+    assert!(map.insert(\"abc\".into_cow(), a).is_some());\n+    assert!(map.insert(\"bcd\".to_string().into_cow(), b).is_some());\n+    assert!(map.insert(\"cde\".into_cow(), c).is_some());\n+    assert!(map.insert(\"def\".to_string().into_cow(), d).is_some());\n \n-    assert!(map.insert(Owned(\"abc\".to_string()), a).is_some());\n-    assert!(map.insert(Slice(\"bcd\"), b).is_some());\n-    assert!(map.insert(Owned(\"cde\".to_string()), c).is_some());\n-    assert!(map.insert(Slice(\"def\"), d).is_some());\n+    assert!(map.insert(\"abc\".to_string().into_cow(), a).is_some());\n+    assert!(map.insert(\"bcd\".into_cow(), b).is_some());\n+    assert!(map.insert(\"cde\".to_string().into_cow(), c).is_some());\n+    assert!(map.insert(\"def\".into_cow(), d).is_some());\n \n-    assert_eq!(map.get(&Slice(\"abc\")), Some(&a));\n-    assert_eq!(map.get(&Slice(\"bcd\")), Some(&b));\n-    assert_eq!(map.get(&Slice(\"cde\")), Some(&c));\n-    assert_eq!(map.get(&Slice(\"def\")), Some(&d));\n+    assert_eq!(map.get(&\"abc\".into_cow()), Some(&a));\n+    assert_eq!(map.get(&\"bcd\".into_cow()), Some(&b));\n+    assert_eq!(map.get(&\"cde\".into_cow()), Some(&c));\n+    assert_eq!(map.get(&\"def\".into_cow()), Some(&d));\n \n-    assert_eq!(map.get(&Owned(\"abc\".to_string())), Some(&a));\n-    assert_eq!(map.get(&Owned(\"bcd\".to_string())), Some(&b));\n-    assert_eq!(map.get(&Owned(\"cde\".to_string())), Some(&c));\n-    assert_eq!(map.get(&Owned(\"def\".to_string())), Some(&d));\n+    assert_eq!(map.get(&\"abc\".to_string().into_cow()), Some(&a));\n+    assert_eq!(map.get(&\"bcd\".to_string().into_cow()), Some(&b));\n+    assert_eq!(map.get(&\"cde\".to_string().into_cow()), Some(&c));\n+    assert_eq!(map.get(&\"def\".to_string().into_cow()), Some(&d));\n \n-    assert!(map.remove(&Slice(\"foo\")).is_some());\n+    assert!(map.remove(&\"foo\".into_cow()).is_some());\n     assert_eq!(map.into_iter().map(|(k, v)| format!(\"{}{}\", k, v))\n                               .collect::<Vec<String>>()\n                               .concat(),"}]}