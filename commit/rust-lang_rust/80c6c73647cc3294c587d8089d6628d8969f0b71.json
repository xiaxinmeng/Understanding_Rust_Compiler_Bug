{"sha": "80c6c73647cc3294c587d8089d6628d8969f0b71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYzZjNzM2NDdjYzMyOTRjNTg3ZDgwODlkNjYyOGQ4OTY5ZjBiNzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-08T03:31:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-08T03:31:31Z"}, "message": "auto merge of #12059 : thestinger/rust/glue, r=pcwalton\n\nA follow-up from the work I started with 383e3fd13b99827b5dbb107da7433bd0a70dea80.", "tree": {"sha": "7a6e789f7123151a8fd0e4b2fe1bd7abfb7e0dcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a6e789f7123151a8fd0e4b2fe1bd7abfb7e0dcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80c6c73647cc3294c587d8089d6628d8969f0b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80c6c73647cc3294c587d8089d6628d8969f0b71", "html_url": "https://github.com/rust-lang/rust/commit/80c6c73647cc3294c587d8089d6628d8969f0b71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80c6c73647cc3294c587d8089d6628d8969f0b71/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29e500db8a98a86b3de56688cd9fa6571a840470", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e500db8a98a86b3de56688cd9fa6571a840470", "html_url": "https://github.com/rust-lang/rust/commit/29e500db8a98a86b3de56688cd9fa6571a840470"}, {"sha": "95d897c579621d92a17e9f0bc4edb3ffa24477c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/95d897c579621d92a17e9f0bc4edb3ffa24477c7", "html_url": "https://github.com/rust-lang/rust/commit/95d897c579621d92a17e9f0bc4edb3ffa24477c7"}], "stats": {"total": 702, "additions": 387, "deletions": 315}, "files": [{"sha": "856540989df55fbc470207b54cafccf902b0fac4", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -214,8 +214,7 @@ impl Arena {\n     #[inline]\n     fn alloc_pod<'a, T>(&'a mut self, op: || -> T) -> &'a T {\n         unsafe {\n-            let tydesc = get_tydesc::<T>();\n-            let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n+            let ptr = self.alloc_pod_inner(mem::size_of::<T>(), mem::min_align_of::<T>());\n             let ptr: *mut T = transmute(ptr);\n             intrinsics::move_val_init(&mut (*ptr), op());\n             return transmute(ptr);\n@@ -272,7 +271,7 @@ impl Arena {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n-                self.alloc_nonpod_inner((*tydesc).size, (*tydesc).align);\n+                self.alloc_nonpod_inner(mem::size_of::<T>(), mem::min_align_of::<T>());\n             let ty_ptr: *mut uint = transmute(ty_ptr);\n             let ptr: *mut T = transmute(ptr);\n             // Write in our tydesc along with a bit indicating that it"}, {"sha": "39e0ca176eb0b5b02e5c6e0d30cbf246b7dcb6c9", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -352,7 +352,6 @@ pub fn malloc_raw_dyn<'a>(\n     if heap == heap_exchange {\n         let llty_value = type_of::type_of(ccx, t);\n \n-\n         // Allocate space:\n         let r = callee::trans_lang_call(\n             bcx,\n@@ -375,17 +374,14 @@ pub fn malloc_raw_dyn<'a>(\n         // Grab the TypeRef type of box_ptr_ty.\n         let box_ptr_ty = ty::mk_box(bcx.tcx(), t);\n         let llty = type_of(ccx, box_ptr_ty);\n-\n-        // Get the tydesc for the body:\n-        let static_ti = get_tydesc(ccx, t);\n-        glue::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n+        let llalign = C_uint(ccx, llalign_of_min(ccx, llty) as uint);\n \n         // Allocate space:\n-        let tydesc = PointerCast(bcx, static_ti.tydesc, Type::i8p());\n+        let drop_glue = glue::get_drop_glue(ccx, t);\n         let r = callee::trans_lang_call(\n             bcx,\n             langcall,\n-            [tydesc, size],\n+            [PointerCast(bcx, drop_glue, Type::glue_fn(Type::i8p()).ptr_to()), size, llalign],\n             None);\n         rslt(r.bcx, PointerCast(r.bcx, r.val, llty))\n     }"}, {"sha": "7ee77e4c0d6f56db2748d18e326e696bfa171cea", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -114,7 +114,6 @@ pub struct tydesc_info {\n     size: ValueRef,\n     align: ValueRef,\n     name: ValueRef,\n-    drop_glue: Cell<Option<ValueRef>>,\n     visit_glue: Cell<Option<ValueRef>>,\n }\n "}, {"sha": "95875a01401826a267b0851f9ed7805fe30b8c36", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 131, "deletions": 129, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -36,83 +36,84 @@ use syntax::ast;\n use syntax::parse::token::InternedString;\n \n pub struct CrateContext {\n-     sess: session::Session,\n-     llmod: ModuleRef,\n-     llcx: ContextRef,\n-     metadata_llmod: ModuleRef,\n-     td: TargetData,\n-     tn: TypeNames,\n-     externs: RefCell<ExternMap>,\n-     intrinsics: HashMap<&'static str, ValueRef>,\n-     item_vals: RefCell<HashMap<ast::NodeId, ValueRef>>,\n-     exp_map2: resolve::ExportMap2,\n-     reachable: @RefCell<HashSet<ast::NodeId>>,\n-     item_symbols: RefCell<HashMap<ast::NodeId, ~str>>,\n-     link_meta: LinkMeta,\n-     tydescs: RefCell<HashMap<ty::t, @tydesc_info>>,\n-     // Set when running emit_tydescs to enforce that no more tydescs are\n-     // created.\n-     finished_tydescs: Cell<bool>,\n-     // Track mapping of external ids to local items imported for inlining\n-     external: RefCell<HashMap<ast::DefId, Option<ast::NodeId>>>,\n-     // Backwards version of the `external` map (inlined items to where they\n-     // came from)\n-     external_srcs: RefCell<HashMap<ast::NodeId, ast::DefId>>,\n-     // A set of static items which cannot be inlined into other crates. This\n-     // will pevent in IIItem() structures from being encoded into the metadata\n-     // that is generated\n-     non_inlineable_statics: RefCell<HashSet<ast::NodeId>>,\n-     // Cache instances of monomorphized functions\n-     monomorphized: RefCell<HashMap<mono_id, ValueRef>>,\n-     monomorphizing: RefCell<HashMap<ast::DefId, uint>>,\n-     // Cache generated vtables\n-     vtables: RefCell<HashMap<(ty::t, mono_id), ValueRef>>,\n-     // Cache of constant strings,\n-     const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n+    sess: session::Session,\n+    llmod: ModuleRef,\n+    llcx: ContextRef,\n+    metadata_llmod: ModuleRef,\n+    td: TargetData,\n+    tn: TypeNames,\n+    externs: RefCell<ExternMap>,\n+    intrinsics: HashMap<&'static str, ValueRef>,\n+    item_vals: RefCell<HashMap<ast::NodeId, ValueRef>>,\n+    exp_map2: resolve::ExportMap2,\n+    reachable: @RefCell<HashSet<ast::NodeId>>,\n+    item_symbols: RefCell<HashMap<ast::NodeId, ~str>>,\n+    link_meta: LinkMeta,\n+    drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n+    tydescs: RefCell<HashMap<ty::t, @tydesc_info>>,\n+    // Set when running emit_tydescs to enforce that no more tydescs are\n+    // created.\n+    finished_tydescs: Cell<bool>,\n+    // Track mapping of external ids to local items imported for inlining\n+    external: RefCell<HashMap<ast::DefId, Option<ast::NodeId>>>,\n+    // Backwards version of the `external` map (inlined items to where they\n+    // came from)\n+    external_srcs: RefCell<HashMap<ast::NodeId, ast::DefId>>,\n+    // A set of static items which cannot be inlined into other crates. This\n+    // will pevent in IIItem() structures from being encoded into the metadata\n+    // that is generated\n+    non_inlineable_statics: RefCell<HashSet<ast::NodeId>>,\n+    // Cache instances of monomorphized functions\n+    monomorphized: RefCell<HashMap<mono_id, ValueRef>>,\n+    monomorphizing: RefCell<HashMap<ast::DefId, uint>>,\n+    // Cache generated vtables\n+    vtables: RefCell<HashMap<(ty::t, mono_id), ValueRef>>,\n+    // Cache of constant strings,\n+    const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n \n-     // Reverse-direction for const ptrs cast from globals.\n-     // Key is an int, cast from a ValueRef holding a *T,\n-     // Val is a ValueRef holding a *[T].\n-     //\n-     // Needed because LLVM loses pointer->pointee association\n-     // when we ptrcast, and we have to ptrcast during translation\n-     // of a [T] const because we form a slice, a [*T,int] pair, not\n-     // a pointer to an LLVM array type.\n-     const_globals: RefCell<HashMap<int, ValueRef>>,\n+    // Reverse-direction for const ptrs cast from globals.\n+    // Key is an int, cast from a ValueRef holding a *T,\n+    // Val is a ValueRef holding a *[T].\n+    //\n+    // Needed because LLVM loses pointer->pointee association\n+    // when we ptrcast, and we have to ptrcast during translation\n+    // of a [T] const because we form a slice, a [*T,int] pair, not\n+    // a pointer to an LLVM array type.\n+    const_globals: RefCell<HashMap<int, ValueRef>>,\n \n-     // Cache of emitted const values\n-     const_values: RefCell<HashMap<ast::NodeId, ValueRef>>,\n+    // Cache of emitted const values\n+    const_values: RefCell<HashMap<ast::NodeId, ValueRef>>,\n \n-     // Cache of external const values\n-     extern_const_values: RefCell<HashMap<ast::DefId, ValueRef>>,\n+    // Cache of external const values\n+    extern_const_values: RefCell<HashMap<ast::DefId, ValueRef>>,\n \n-     impl_method_cache: RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>>,\n+    impl_method_cache: RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>>,\n \n-     // Cache of closure wrappers for bare fn's.\n-     closure_bare_wrapper_cache: RefCell<HashMap<ValueRef, ValueRef>>,\n+    // Cache of closure wrappers for bare fn's.\n+    closure_bare_wrapper_cache: RefCell<HashMap<ValueRef, ValueRef>>,\n \n-     module_data: RefCell<HashMap<~str, ValueRef>>,\n-     lltypes: RefCell<HashMap<ty::t, Type>>,\n-     llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n-     adt_reprs: RefCell<HashMap<ty::t, @adt::Repr>>,\n-     symbol_hasher: RefCell<Sha256>,\n-     type_hashcodes: RefCell<HashMap<ty::t, ~str>>,\n-     all_llvm_symbols: RefCell<HashSet<~str>>,\n-     tcx: ty::ctxt,\n-     maps: astencode::Maps,\n-     stats: @Stats,\n-     tydesc_type: Type,\n-     int_type: Type,\n-     opaque_vec_type: Type,\n-     builder: BuilderRef_res,\n-     crate_map: ValueRef,\n-     crate_map_name: ~str,\n-     // Set when at least one function uses GC. Needed so that\n-     // decl_gc_metadata knows whether to link to the module metadata, which\n-     // is not emitted by LLVM's GC pass when no functions use GC.\n-     uses_gc: bool,\n-     dbg_cx: Option<debuginfo::CrateDebugContext>,\n-     do_not_commit_warning_issued: Cell<bool>,\n+    module_data: RefCell<HashMap<~str, ValueRef>>,\n+    lltypes: RefCell<HashMap<ty::t, Type>>,\n+    llsizingtypes: RefCell<HashMap<ty::t, Type>>,\n+    adt_reprs: RefCell<HashMap<ty::t, @adt::Repr>>,\n+    symbol_hasher: RefCell<Sha256>,\n+    type_hashcodes: RefCell<HashMap<ty::t, ~str>>,\n+    all_llvm_symbols: RefCell<HashSet<~str>>,\n+    tcx: ty::ctxt,\n+    maps: astencode::Maps,\n+    stats: @Stats,\n+    tydesc_type: Type,\n+    int_type: Type,\n+    opaque_vec_type: Type,\n+    builder: BuilderRef_res,\n+    crate_map: ValueRef,\n+    crate_map_name: ~str,\n+    // Set when at least one function uses GC. Needed so that\n+    // decl_gc_metadata knows whether to link to the module metadata, which\n+    // is not emitted by LLVM's GC pass when no functions use GC.\n+    uses_gc: bool,\n+    dbg_cx: Option<debuginfo::CrateDebugContext>,\n+    do_not_commit_warning_issued: Cell<bool>,\n }\n \n impl CrateContext {\n@@ -175,64 +176,65 @@ impl CrateContext {\n             }\n \n             CrateContext {\n-                  sess: sess,\n-                  llmod: llmod,\n-                  llcx: llcx,\n-                  metadata_llmod: metadata_llmod,\n-                  td: td,\n-                  tn: tn,\n-                  externs: RefCell::new(HashMap::new()),\n-                  intrinsics: intrinsics,\n-                  item_vals: RefCell::new(HashMap::new()),\n-                  exp_map2: emap2,\n-                  reachable: reachable,\n-                  item_symbols: RefCell::new(HashMap::new()),\n-                  link_meta: link_meta,\n-                  tydescs: RefCell::new(HashMap::new()),\n-                  finished_tydescs: Cell::new(false),\n-                  external: RefCell::new(HashMap::new()),\n-                  external_srcs: RefCell::new(HashMap::new()),\n-                  non_inlineable_statics: RefCell::new(HashSet::new()),\n-                  monomorphized: RefCell::new(HashMap::new()),\n-                  monomorphizing: RefCell::new(HashMap::new()),\n-                  vtables: RefCell::new(HashMap::new()),\n-                  const_cstr_cache: RefCell::new(HashMap::new()),\n-                  const_globals: RefCell::new(HashMap::new()),\n-                  const_values: RefCell::new(HashMap::new()),\n-                  extern_const_values: RefCell::new(HashMap::new()),\n-                  impl_method_cache: RefCell::new(HashMap::new()),\n-                  closure_bare_wrapper_cache: RefCell::new(HashMap::new()),\n-                  module_data: RefCell::new(HashMap::new()),\n-                  lltypes: RefCell::new(HashMap::new()),\n-                  llsizingtypes: RefCell::new(HashMap::new()),\n-                  adt_reprs: RefCell::new(HashMap::new()),\n-                  symbol_hasher: RefCell::new(symbol_hasher),\n-                  type_hashcodes: RefCell::new(HashMap::new()),\n-                  all_llvm_symbols: RefCell::new(HashSet::new()),\n-                  tcx: tcx,\n-                  maps: maps,\n-                  stats: @Stats {\n-                    n_static_tydescs: Cell::new(0u),\n-                    n_glues_created: Cell::new(0u),\n-                    n_null_glues: Cell::new(0u),\n-                    n_real_glues: Cell::new(0u),\n-                    n_fns: Cell::new(0u),\n-                    n_monos: Cell::new(0u),\n-                    n_inlines: Cell::new(0u),\n-                    n_closures: Cell::new(0u),\n-                    n_llvm_insns: Cell::new(0u),\n-                    llvm_insns: RefCell::new(HashMap::new()),\n-                    fn_stats: RefCell::new(~[]),\n-                  },\n-                  tydesc_type: tydesc_type,\n-                  int_type: int_type,\n-                  opaque_vec_type: opaque_vec_type,\n-                  builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                  crate_map: crate_map,\n-                  crate_map_name: crate_map_name,\n-                  uses_gc: false,\n-                  dbg_cx: dbg_cx,\n-                  do_not_commit_warning_issued: Cell::new(false),\n+                 sess: sess,\n+                 llmod: llmod,\n+                 llcx: llcx,\n+                 metadata_llmod: metadata_llmod,\n+                 td: td,\n+                 tn: tn,\n+                 externs: RefCell::new(HashMap::new()),\n+                 intrinsics: intrinsics,\n+                 item_vals: RefCell::new(HashMap::new()),\n+                 exp_map2: emap2,\n+                 reachable: reachable,\n+                 item_symbols: RefCell::new(HashMap::new()),\n+                 link_meta: link_meta,\n+                 drop_glues: RefCell::new(HashMap::new()),\n+                 tydescs: RefCell::new(HashMap::new()),\n+                 finished_tydescs: Cell::new(false),\n+                 external: RefCell::new(HashMap::new()),\n+                 external_srcs: RefCell::new(HashMap::new()),\n+                 non_inlineable_statics: RefCell::new(HashSet::new()),\n+                 monomorphized: RefCell::new(HashMap::new()),\n+                 monomorphizing: RefCell::new(HashMap::new()),\n+                 vtables: RefCell::new(HashMap::new()),\n+                 const_cstr_cache: RefCell::new(HashMap::new()),\n+                 const_globals: RefCell::new(HashMap::new()),\n+                 const_values: RefCell::new(HashMap::new()),\n+                 extern_const_values: RefCell::new(HashMap::new()),\n+                 impl_method_cache: RefCell::new(HashMap::new()),\n+                 closure_bare_wrapper_cache: RefCell::new(HashMap::new()),\n+                 module_data: RefCell::new(HashMap::new()),\n+                 lltypes: RefCell::new(HashMap::new()),\n+                 llsizingtypes: RefCell::new(HashMap::new()),\n+                 adt_reprs: RefCell::new(HashMap::new()),\n+                 symbol_hasher: RefCell::new(symbol_hasher),\n+                 type_hashcodes: RefCell::new(HashMap::new()),\n+                 all_llvm_symbols: RefCell::new(HashSet::new()),\n+                 tcx: tcx,\n+                 maps: maps,\n+                 stats: @Stats {\n+                   n_static_tydescs: Cell::new(0u),\n+                   n_glues_created: Cell::new(0u),\n+                   n_null_glues: Cell::new(0u),\n+                   n_real_glues: Cell::new(0u),\n+                   n_fns: Cell::new(0u),\n+                   n_monos: Cell::new(0u),\n+                   n_inlines: Cell::new(0u),\n+                   n_closures: Cell::new(0u),\n+                   n_llvm_insns: Cell::new(0u),\n+                   llvm_insns: RefCell::new(HashMap::new()),\n+                   fn_stats: RefCell::new(~[]),\n+                 },\n+                 tydesc_type: tydesc_type,\n+                 int_type: int_type,\n+                 opaque_vec_type: opaque_vec_type,\n+                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n+                 crate_map: crate_map,\n+                 crate_map_name: crate_map_name,\n+                 uses_gc: false,\n+                 dbg_cx: dbg_cx,\n+                 do_not_commit_warning_issued: Cell::new(false),\n             }\n         }\n     }"}, {"sha": "7bbbf4f99059f1ef1a1c32344066a61edbb4f4e1", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -1779,7 +1779,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n-            name: ~\"tydesc\",\n+            name: ~\"drop_glue\",\n             llvm_type: member_llvm_types[1],\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n@@ -1824,7 +1824,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n                           -> bool {\n         member_llvm_types.len() == 5 &&\n         member_llvm_types[0] == cx.int_type &&\n-        member_llvm_types[1] == cx.tydesc_type.ptr_to() &&\n+        member_llvm_types[1] == Type::generic_glue_fn(cx).ptr_to() &&\n         member_llvm_types[2] == Type::i8().ptr_to() &&\n         member_llvm_types[3] == Type::i8().ptr_to() &&\n         member_llvm_types[4] == content_llvm_type"}, {"sha": "1b9605a172cb696032395732ef09707b0deb2113", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 81, "deletions": 133, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -73,14 +73,49 @@ pub fn take_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     }\n }\n \n-pub fn drop_ty<'a>(cx: &'a Block<'a>, v: ValueRef, t: ty::t)\n+fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n+    let tcx = ccx.tcx;\n+    if !ty::type_needs_drop(tcx, t) {\n+        return ty::mk_i8();\n+    }\n+    match ty::get(t).sty {\n+        ty::ty_box(typ) if !ty::type_needs_drop(tcx, typ) =>\n+            ty::mk_box(tcx, ty::mk_i8()),\n+\n+        ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ) => {\n+            let llty = sizing_type_of(ccx, typ);\n+            // Unique boxes do not allocate for zero-size types. The standard library may assume\n+            // that `free` is never called on the pointer returned for `~ZeroSizeType`.\n+            if llsize_of_alloc(ccx, llty) == 0 {\n+                ty::mk_i8()\n+            } else {\n+                ty::mk_uniq(tcx, ty::mk_i8())\n+            }\n+        }\n+\n+        ty::ty_vec(mt, ty::vstore_uniq) if !ty::type_needs_drop(tcx, mt.ty) =>\n+            ty::mk_uniq(tcx, ty::mk_i8()),\n+\n+        _ => t\n+    }\n+}\n+\n+pub fn drop_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n                -> &'a Block<'a> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"drop_ty\");\n-    if ty::type_needs_drop(cx.tcx(), t) {\n-        return call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n+    let ccx = bcx.ccx();\n+    if ty::type_needs_drop(bcx.tcx(), t) {\n+        let glue = get_drop_glue(ccx, t);\n+        let glue_type = get_drop_glue_type(ccx, t);\n+        let ptr = if glue_type != t {\n+            PointerCast(bcx, v, type_of(ccx, glue_type).ptr_to())\n+        } else {\n+            v\n+        };\n+        Call(bcx, glue, [ptr], []);\n     }\n-    return cx;\n+    bcx\n }\n \n pub fn drop_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n@@ -91,95 +126,49 @@ pub fn drop_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     drop_ty(bcx, vp, t)\n }\n \n-pub fn lazily_emit_all_tydesc_glue(ccx: @CrateContext,\n-                                   static_ti: @tydesc_info) {\n-    lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n-    lazily_emit_tydesc_glue(ccx, abi::tydesc_field_visit_glue, static_ti);\n-}\n-\n-fn get_glue_type(ccx: &CrateContext, field: uint, t: ty::t) -> ty::t {\n-    let tcx = ccx.tcx;\n-    if field == abi::tydesc_field_drop_glue {\n-        if !ty::type_needs_drop(tcx, t) {\n-            return ty::mk_i8();\n-        }\n-        match ty::get(t).sty {\n-            ty::ty_box(typ) if !ty::type_needs_drop(tcx, typ) =>\n-                return ty::mk_box(tcx, ty::mk_i8()),\n-\n-            ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ) => {\n-                let llty = sizing_type_of(ccx, typ);\n-                // Unique boxes do not allocate for zero-size types. The standard library may assume\n-                // that `free` is never called on the pointer returned for `~ZeroSizeType`.\n-                if llsize_of_alloc(ccx, llty) == 0 {\n-                    return ty::mk_i8();\n-                } else {\n-                    return ty::mk_uniq(tcx, ty::mk_i8());\n-                }\n-            }\n-\n-            ty::ty_vec(mt, ty::vstore_uniq) if !ty::type_needs_drop(tcx, mt.ty) =>\n-                return ty::mk_uniq(tcx, ty::mk_i8()),\n-\n-            _ => {}\n+pub fn get_drop_glue(ccx: @CrateContext, t: ty::t) -> ValueRef {\n+    let t = get_drop_glue_type(ccx, t);\n+    {\n+        let drop_glues = ccx.drop_glues.borrow();\n+        match drop_glues.get().find(&t) {\n+            Some(&glue) => return glue,\n+            _ => { }\n         }\n     }\n \n-    t\n-}\n+    let llfnty = Type::glue_fn(type_of(ccx, t).ptr_to());\n+    let glue = declare_generic_glue(ccx, t, llfnty, \"drop\");\n \n-pub fn lazily_emit_tydesc_glue(ccx: @CrateContext, field: uint, ti: @tydesc_info) {\n-    let _icx = push_ctxt(\"lazily_emit_tydesc_glue\");\n+    {\n+        let mut drop_glues = ccx.drop_glues.borrow_mut();\n+        drop_glues.get().insert(t, glue);\n+    }\n \n-    let simpl = get_glue_type(ccx, field, ti.ty);\n-    if simpl != ti.ty {\n-        let _icx = push_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n-        let simpl_ti = get_tydesc(ccx, simpl);\n-        lazily_emit_tydesc_glue(ccx, field, simpl_ti);\n+    make_generic_glue(ccx, t, glue, make_drop_glue, \"drop\");\n \n-        if field == abi::tydesc_field_drop_glue {\n-            ti.drop_glue.set(simpl_ti.drop_glue.get());\n-        } else if field == abi::tydesc_field_visit_glue {\n-            ti.visit_glue.set(simpl_ti.visit_glue.get());\n-        }\n+    glue\n+}\n \n-        return;\n-    }\n+pub fn lazily_emit_visit_glue(ccx: @CrateContext, ti: @tydesc_info) {\n+    let _icx = push_ctxt(\"lazily_emit_visit_glue\");\n \n     let llfnty = Type::glue_fn(type_of(ccx, ti.ty).ptr_to());\n \n-    if field == abi::tydesc_field_drop_glue {\n-        match ti.drop_glue.get() {\n-          Some(_) => (),\n-          None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue DROP {}\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n-            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"drop\");\n-            ti.drop_glue.set(Some(glue_fn));\n-            make_generic_glue(ccx, ti.ty, glue_fn, make_drop_glue, \"drop\");\n-            debug!(\"--- lazily_emit_tydesc_glue DROP {}\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n-          }\n-        }\n-    } else if field == abi::tydesc_field_visit_glue {\n-        match ti.visit_glue.get() {\n-          Some(_) => (),\n-          None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+    match ti.visit_glue.get() {\n+        Some(_) => (),\n+        None => {\n+            debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n             ti.visit_glue.set(Some(glue_fn));\n             make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n-            debug!(\"--- lazily_emit_tydesc_glue VISIT {}\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n-          }\n+            debug!(\"--- lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx, ti.ty));\n         }\n     }\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue_full(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n-                             field: uint, static_ti: Option<@tydesc_info>) {\n+pub fn call_visit_glue(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n+                       static_ti: Option<@tydesc_info>) {\n     let _icx = push_ctxt(\"call_tydesc_glue_full\");\n     let ccx = bcx.ccx();\n     // NB: Don't short-circuit even if this block is unreachable because\n@@ -189,37 +178,23 @@ pub fn call_tydesc_glue_full(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n     let static_glue_fn = match static_ti {\n         None => None,\n         Some(sti) => {\n-            lazily_emit_tydesc_glue(ccx, field, sti);\n-            if field == abi::tydesc_field_drop_glue {\n-                sti.drop_glue.get()\n-            } else if field == abi::tydesc_field_visit_glue {\n-                sti.visit_glue.get()\n-            } else {\n-                None\n-            }\n+            lazily_emit_visit_glue(ccx, sti);\n+            sti.visit_glue.get()\n         }\n     };\n \n-    // When static type info is available, avoid casting parameter unless the\n-    // glue is using a simplified type, because the function already has the\n-    // right type. Otherwise cast to generic pointer.\n+    // When static type info is available, avoid casting to a generic pointer.\n     let llrawptr = if static_glue_fn.is_none() {\n         PointerCast(bcx, v, Type::i8p())\n     } else {\n-        let ty = static_ti.unwrap().ty;\n-        let simpl = get_glue_type(ccx, field, ty);\n-        if simpl != ty {\n-            PointerCast(bcx, v, type_of(ccx, simpl).ptr_to())\n-        } else {\n-            v\n-        }\n+        v\n     };\n \n     let llfn = {\n         match static_glue_fn {\n             None => {\n                 // Select out the glue function to call from the tydesc\n-                let llfnptr = GEPi(bcx, tydesc, [0u, field]);\n+                let llfnptr = GEPi(bcx, tydesc, [0u, abi::tydesc_field_visit_glue]);\n                 Load(bcx, llfnptr)\n             }\n             Some(sgf) => sgf\n@@ -229,15 +204,6 @@ pub fn call_tydesc_glue_full(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n     Call(bcx, llfn, [llrawptr], []);\n }\n \n-// See [Note-arg-mode]\n-fn call_tydesc_glue<'a>(cx: &'a Block<'a>, v: ValueRef, t: ty::t, field: uint)\n-                    -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"call_tydesc_glue\");\n-    let ti = get_tydesc(cx.ccx(), t);\n-    call_tydesc_glue_full(cx, v, ti.tydesc, field, Some(ti));\n-    cx\n-}\n-\n fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n                    -> &'a Block<'a> {\n     let _icx = push_ctxt(\"make_visit_glue\");\n@@ -355,9 +321,9 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n             let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n             // Only drop the value when it is non-null\n             with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue)), |bcx| {\n-                let lldtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n-                let lldtor = Load(bcx, lldtor_ptr);\n-                Call(bcx, lldtor, [PointerCast(bcx, lluniquevalue, Type::i8p())], []);\n+                let dtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n+                let dtor = Load(bcx, dtor_ptr);\n+                Call(bcx, dtor, [PointerCast(bcx, lluniquevalue, Type::i8p())], []);\n                 bcx\n             })\n         }\n@@ -367,18 +333,12 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n             let env_ptr_ty = Type::at_box(ccx, Type::i8()).ptr_to();\n             let env = PointerCast(bcx, env, env_ptr_ty);\n             with_cond(bcx, IsNotNull(bcx, env), |bcx| {\n-                // Load the type descr found in the env\n-                let lltydescty = ccx.tydesc_type.ptr_to();\n-                let tydescptr = GEPi(bcx, env, [0u, abi::box_field_tydesc]);\n-                let tydesc = Load(bcx, tydescptr);\n-                let tydesc = PointerCast(bcx, tydesc, lltydescty);\n-\n-                // Drop the tuple data then free the descriptor\n+                let dtor_ptr = GEPi(bcx, env, [0u, abi::box_field_tydesc]);\n+                let dtor = Load(bcx, dtor_ptr);\n                 let cdata = GEPi(bcx, env, [0u, abi::box_field_body]);\n-                call_tydesc_glue_full(bcx, cdata, tydesc,\n-                                      abi::tydesc_field_drop_glue, None);\n+                Call(bcx, dtor, [PointerCast(bcx, cdata, Type::i8p())], []);\n \n-                // Free the ty descr (if necc) and the env itself\n+                // Free the environment itself\n                 trans_exchange_free(bcx, env)\n             })\n         }\n@@ -468,7 +428,6 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n         size: llsize,\n         align: llalign,\n         name: ty_name,\n-        drop_glue: Cell::new(None),\n         visit_glue: Cell::new(None),\n     };\n     debug!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx, t));\n@@ -520,7 +479,7 @@ fn make_generic_glue(ccx: @CrateContext,\n     llfn\n }\n \n-pub fn emit_tydescs(ccx: &CrateContext) {\n+pub fn emit_tydescs(ccx: @CrateContext) {\n     let _icx = push_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs.set(true);\n@@ -533,21 +492,10 @@ pub fn emit_tydescs(ccx: &CrateContext) {\n         // before being put into the tydesc because we only have a singleton\n         // tydesc type. Then we'll recast each function to its real type when\n         // calling it.\n-        let drop_glue =\n-            match ti.drop_glue.get() {\n-              None => {\n-                  ccx.stats.n_null_glues.set(ccx.stats.n_null_glues.get() +\n-                                             1u);\n-                  C_null(glue_fn_ty)\n-              }\n-              Some(v) => {\n-                unsafe {\n-                    ccx.stats.n_real_glues.set(ccx.stats.n_real_glues.get() +\n-                                               1);\n-                    llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n-                }\n-              }\n-            };\n+        let drop_glue = unsafe {\n+            llvm::LLVMConstPointerCast(get_drop_glue(ccx, ti.ty), glue_fn_ty.to_ref())\n+        };\n+        ccx.stats.n_real_glues.set(ccx.stats.n_real_glues.get() + 1);\n         let visit_glue =\n             match ti.visit_glue.get() {\n               None => {"}, {"sha": "234b8072decc3eeeeaca2cd5287ef42504c0258a", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -11,7 +11,6 @@\n #[allow(non_uppercase_pattern_statics)];\n \n use arena::TypedArena;\n-use back::abi;\n use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg};\n use lib::llvm::{ValueRef, Pointer, Array, Struct};\n use lib;\n@@ -326,7 +325,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         \"get_tydesc\" => {\n             let tp_ty = substs.tys[0];\n             let static_ti = get_tydesc(ccx, tp_ty);\n-            glue::lazily_emit_all_tydesc_glue(ccx, static_ti);\n+            glue::lazily_emit_visit_glue(ccx, static_ti);\n \n             // FIXME (#3730): ideally this shouldn't need a cast,\n             // but there's a circularity between translating rust types to llvm\n@@ -459,8 +458,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let td = get_param(decl, first_real_arg);\n             let visitor = get_param(decl, first_real_arg + 1u);\n             let td = PointerCast(bcx, td, ccx.tydesc_type.ptr_to());\n-            glue::call_tydesc_glue_full(bcx, visitor, td,\n-                                        abi::tydesc_field_visit_glue, None);\n+            glue::call_visit_glue(bcx, visitor, td, None);\n             RetVoid(bcx);\n         }\n         \"morestack_addr\" => {"}, {"sha": "4a1ba7b22ac5432a3089b6489447c8523f0b0428", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -479,11 +479,9 @@ pub fn get_vtable(bcx: &Block,\n         }\n     });\n \n-    // Generate a type descriptor for the vtable.\n-    let tydesc = get_tydesc(ccx, self_ty);\n-    glue::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, tydesc);\n-\n-    let vtable = make_vtable(ccx, tydesc, methods);\n+    // Generate a destructor for the vtable.\n+    let drop_glue = glue::get_drop_glue(ccx, self_ty);\n+    let vtable = make_vtable(ccx, drop_glue, methods);\n \n     let mut vtables = ccx.vtables.borrow_mut();\n     vtables.get().insert(hash_id, vtable);\n@@ -492,13 +490,13 @@ pub fn get_vtable(bcx: &Block,\n \n /// Helper function to declare and initialize the vtable.\n pub fn make_vtable(ccx: &CrateContext,\n-                   tydesc: &tydesc_info,\n+                   drop_glue: ValueRef,\n                    ptrs: &[ValueRef])\n                    -> ValueRef {\n     unsafe {\n         let _icx = push_ctxt(\"meth::make_vtable\");\n \n-        let mut components = ~[tydesc.drop_glue.get().unwrap()];\n+        let mut components = ~[drop_glue];\n         for &ptr in ptrs.iter() {\n             components.push(ptr)\n         }"}, {"sha": "8c2047a5fc56c2813d16c38054ad9e29818e3d1d", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -81,7 +81,7 @@ impl<'a> Reflector<'a> {\n     pub fn c_tydesc(&mut self, t: ty::t) -> ValueRef {\n         let bcx = self.bcx;\n         let static_ti = get_tydesc(bcx.ccx(), t);\n-        glue::lazily_emit_all_tydesc_glue(bcx.ccx(), static_ti);\n+        glue::lazily_emit_visit_glue(bcx.ccx(), static_ti);\n         PointerCast(bcx, static_ti.tydesc, self.tydesc_ty.ptr_to())\n     }\n "}, {"sha": "804486c415976e04783eb827156b54002ecd4d42", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -238,7 +238,7 @@ impl Type {\n     // The box pointed to by @T.\n     pub fn at_box(ctx: &CrateContext, ty: Type) -> Type {\n         Type::struct_([\n-            ctx.int_type, ctx.tydesc_type.ptr_to(),\n+            ctx.int_type, Type::glue_fn(Type::i8p()).ptr_to(),\n             Type::i8p(), Type::i8p(), ty\n         ], false)\n     }"}, {"sha": "a43dca949703043b538f9a1ae73bc103f84c9dd6", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 50, "deletions": 21, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -11,11 +11,8 @@\n #[doc(hidden)];\n \n use ptr;\n-use unstable::intrinsics::TyDesc;\n use unstable::raw;\n \n-type DropGlue<'a> = 'a |**TyDesc, *u8|;\n-\n static RC_IMMORTAL : uint = 0x77777777;\n \n /*\n@@ -24,11 +21,6 @@ static RC_IMMORTAL : uint = 0x77777777;\n  * This runs at task death to free all boxes.\n  */\n \n-struct AnnihilateStats {\n-    n_total_boxes: uint,\n-    n_bytes_freed: uint\n-}\n-\n unsafe fn each_live_alloc(read_next_before: bool,\n                           f: |alloc: *mut raw::Box<()>| -> bool)\n                           -> bool {\n@@ -65,21 +57,18 @@ fn debug_mem() -> bool {\n }\n \n /// Destroys all managed memory (i.e. @ boxes) held by the current task.\n+#[cfg(stage0)]\n pub unsafe fn annihilate() {\n     use rt::local_heap::local_free;\n-    use mem;\n \n-    let mut stats = AnnihilateStats {\n-        n_total_boxes: 0,\n-        n_bytes_freed: 0\n-    };\n+    let mut n_total_boxes = 0u;\n \n     // Pass 1: Make all boxes immortal.\n     //\n     // In this pass, nothing gets freed, so it does not matter whether\n     // we read the next field before or after the callback.\n     each_live_alloc(true, |alloc| {\n-        stats.n_total_boxes += 1;\n+        n_total_boxes += 1;\n         (*alloc).ref_count = RC_IMMORTAL;\n         true\n     });\n@@ -103,18 +92,58 @@ pub unsafe fn annihilate() {\n     // left), so we must read the `next` field before, since it will\n     // not be valid after.\n     each_live_alloc(true, |alloc| {\n-        stats.n_bytes_freed +=\n-            (*((*alloc).type_desc)).size\n-            + mem::size_of::<raw::Box<()>>();\n         local_free(alloc as *u8);\n         true\n     });\n \n     if debug_mem() {\n         // We do logging here w/o allocation.\n-        debug!(\"annihilator stats:\\n  \\\n-                       total boxes: {}\\n  \\\n-                       bytes freed: {}\",\n-                stats.n_total_boxes, stats.n_bytes_freed);\n+        debug!(\"total boxes annihilated: {}\", n_total_boxes);\n+    }\n+}\n+\n+/// Destroys all managed memory (i.e. @ boxes) held by the current task.\n+#[cfg(not(stage0))]\n+pub unsafe fn annihilate() {\n+    use rt::local_heap::local_free;\n+\n+    let mut n_total_boxes = 0u;\n+\n+    // Pass 1: Make all boxes immortal.\n+    //\n+    // In this pass, nothing gets freed, so it does not matter whether\n+    // we read the next field before or after the callback.\n+    each_live_alloc(true, |alloc| {\n+        n_total_boxes += 1;\n+        (*alloc).ref_count = RC_IMMORTAL;\n+        true\n+    });\n+\n+    // Pass 2: Drop all boxes.\n+    //\n+    // In this pass, unique-managed boxes may get freed, but not\n+    // managed boxes, so we must read the `next` field *after* the\n+    // callback, as the original value may have been freed.\n+    each_live_alloc(false, |alloc| {\n+        let drop_glue = (*alloc).drop_glue;\n+        let data = &mut (*alloc).data as *mut ();\n+        drop_glue(data as *mut u8);\n+        true\n+    });\n+\n+    // Pass 3: Free all boxes.\n+    //\n+    // In this pass, managed boxes may get freed (but not\n+    // unique-managed boxes, though I think that none of those are\n+    // left), so we must read the `next` field before, since it will\n+    // not be valid after.\n+    each_live_alloc(true, |alloc| {\n+        local_free(alloc as *u8);\n+        true\n+    });\n+\n+    if debug_mem() {\n+        // We do logging here w/o allocation.\n+        debug!(\"total boxes annihilated: {}\", n_total_boxes);\n     }\n }"}, {"sha": "571ed77592fcc7a0a94415f5c922174b19222b7a", "filename": "src/libstd/rt/env.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -10,6 +10,8 @@\n \n //! Runtime environment settings\n \n+// NOTE: remove `POISON_ON_FREE` after a snapshot\n+\n use from_str::from_str;\n use option::{Some, None};\n use os;"}, {"sha": "2f553585f38ce67b0b3fac4e50be4a1d53213b64", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -10,7 +10,9 @@\n \n use libc::{c_void, size_t, free, malloc, realloc};\n use ptr::{RawPtr, mut_null};\n-use unstable::intrinsics::{TyDesc, abort};\n+#[cfg(stage0)]\n+use unstable::intrinsics::TyDesc;\n+use unstable::intrinsics::abort;\n use unstable::raw;\n use mem::size_of;\n \n@@ -73,14 +75,23 @@ pub unsafe fn exchange_malloc(size: uint) -> *u8 {\n }\n \n // FIXME: #7496\n-#[cfg(not(test))]\n+#[cfg(not(test), stage0)]\n #[lang=\"closure_exchange_malloc\"]\n #[inline]\n pub unsafe fn closure_exchange_malloc_(td: *u8, size: uint) -> *u8 {\n     closure_exchange_malloc(td, size)\n }\n \n+// FIXME: #7496\n+#[cfg(not(test), not(stage0))]\n+#[lang=\"closure_exchange_malloc\"]\n #[inline]\n+pub unsafe fn closure_exchange_malloc_(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n+    closure_exchange_malloc(drop_glue, size, align)\n+}\n+\n+#[inline]\n+#[cfg(stage0)]\n pub unsafe fn closure_exchange_malloc(td: *u8, size: uint) -> *u8 {\n     let td = td as *TyDesc;\n     let size = size;\n@@ -96,6 +107,18 @@ pub unsafe fn closure_exchange_malloc(td: *u8, size: uint) -> *u8 {\n     alloc as *u8\n }\n \n+#[inline]\n+#[cfg(not(stage0))]\n+pub unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n+    let total_size = get_box_size(size, align);\n+    let p = malloc_raw(total_size);\n+\n+    let alloc = p as *mut raw::Box<()>;\n+    (*alloc).drop_glue = drop_glue;\n+\n+    alloc as *u8\n+}\n+\n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler.\n #[cfg(not(test))]"}, {"sha": "3bee9e48b602ed7c8cf81360a921ee8c406a9864", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -21,6 +21,7 @@ use rt::env;\n use rt::global_heap;\n use rt::local::Local;\n use rt::task::Task;\n+#[cfg(stage0)]\n use unstable::intrinsics::TyDesc;\n use unstable::raw;\n use vec::ImmutableVector;\n@@ -60,6 +61,7 @@ impl LocalHeap {\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     pub fn alloc(&mut self, td: *TyDesc, size: uint) -> *mut Box {\n         let total_size = global_heap::get_box_size(size, unsafe { (*td).align });\n         let alloc = self.memory_region.malloc(total_size);\n@@ -80,6 +82,28 @@ impl LocalHeap {\n         return alloc;\n     }\n \n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn alloc(&mut self, drop_glue: fn(*mut u8), size: uint, align: uint) -> *mut Box {\n+        let total_size = global_heap::get_box_size(size, align);\n+        let alloc = self.memory_region.malloc(total_size);\n+        {\n+            // Make sure that we can't use `mybox` outside of this scope\n+            let mybox: &mut Box = unsafe { cast::transmute(alloc) };\n+            // Clear out this box, and move it to the front of the live\n+            // allocations list\n+            mybox.drop_glue = drop_glue;\n+            mybox.ref_count = 1;\n+            mybox.prev = ptr::mut_null();\n+            mybox.next = self.live_allocs;\n+            if !self.live_allocs.is_null() {\n+                unsafe { (*self.live_allocs).prev = alloc; }\n+            }\n+            self.live_allocs = alloc;\n+        }\n+        return alloc;\n+    }\n+\n     #[inline]\n     pub fn realloc(&mut self, ptr: *mut Box, size: uint) -> *mut Box {\n         // Make sure that we can't use `mybox` outside of this scope\n@@ -102,6 +126,7 @@ impl LocalHeap {\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     pub fn free(&mut self, alloc: *mut Box) {\n         {\n             // Make sure that we can't use `mybox` outside of this scope\n@@ -133,6 +158,28 @@ impl LocalHeap {\n \n         self.memory_region.free(alloc);\n     }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn free(&mut self, alloc: *mut Box) {\n+        {\n+            // Make sure that we can't use `mybox` outside of this scope\n+            let mybox: &mut Box = unsafe { cast::transmute(alloc) };\n+\n+            // Unlink it from the linked list\n+            if !mybox.prev.is_null() {\n+                unsafe { (*mybox.prev).next = mybox.next; }\n+            }\n+            if !mybox.next.is_null() {\n+                unsafe { (*mybox.next).prev = mybox.prev; }\n+            }\n+            if self.live_allocs == alloc {\n+                self.live_allocs = mybox.next;\n+            }\n+        }\n+\n+        self.memory_region.free(alloc);\n+    }\n }\n \n impl Drop for LocalHeap {\n@@ -292,6 +339,7 @@ impl Drop for MemoryRegion {\n }\n \n #[inline]\n+#[cfg(stage0)]\n pub unsafe fn local_malloc(td: *u8, size: uint) -> *u8 {\n     // FIXME: Unsafe borrow for speed. Lame.\n     let task: Option<*mut Task> = Local::try_unsafe_borrow();\n@@ -303,6 +351,19 @@ pub unsafe fn local_malloc(td: *u8, size: uint) -> *u8 {\n     }\n }\n \n+#[inline]\n+#[cfg(not(stage0))]\n+pub unsafe fn local_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n+    // FIXME: Unsafe borrow for speed. Lame.\n+    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n+    match task {\n+        Some(task) => {\n+            (*task).heap.alloc(drop_glue, size, align) as *u8\n+        }\n+        None => rtabort!(\"local malloc outside of task\")\n+    }\n+}\n+\n // A little compatibility function\n #[inline]\n pub unsafe fn local_free(ptr: *u8) {"}, {"sha": "a85f26720bf179df02b923d650ef2fad6f40e6a7", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -27,11 +27,19 @@ pub fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! {\n }\n \n #[lang=\"malloc\"]\n+#[cfg(stage0)]\n #[inline]\n pub unsafe fn local_malloc(td: *u8, size: uint) -> *u8 {\n     ::rt::local_heap::local_malloc(td, size)\n }\n \n+#[lang=\"malloc\"]\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn local_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n+    ::rt::local_heap::local_malloc(drop_glue, size, align)\n+}\n+\n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead."}, {"sha": "98dde95d3b7cc03d804c5af9d1ea4eb67568639b", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -9,9 +9,11 @@\n // except according to those terms.\n \n use cast;\n+#[cfg(stage0)]\n use unstable::intrinsics::TyDesc;\n \n /// The representation of a Rust managed box\n+#[cfg(stage0)]\n pub struct Box<T> {\n     ref_count: uint,\n     type_desc: *TyDesc,\n@@ -20,6 +22,16 @@ pub struct Box<T> {\n     data: T\n }\n \n+/// The representation of a Rust managed box\n+#[cfg(not(stage0))]\n+pub struct Box<T> {\n+    ref_count: uint,\n+    drop_glue: fn(ptr: *mut u8),\n+    prev: *mut Box<T>,\n+    next: *mut Box<T>,\n+    data: T\n+}\n+\n /// The representation of a Rust vector\n pub struct Vec<T> {\n     fill: uint,\n@@ -59,9 +71,6 @@ impl<T> Repr<*Box<T>> for @T {}\n impl<T> Repr<*Vec<T>> for ~[T] {}\n impl Repr<*String> for ~str {}\n \n-// sure would be nice to have this\n-// impl<T> Repr<*Vec<T>> for ~[T] {}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "a67279254de3ab0357b2266eee48b15d7b21fa61", "filename": "src/test/debug-info/basic-types-metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Ftest%2Fdebug-info%2Fbasic-types-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80c6c73647cc3294c587d8089d6628d8969f0b71/src%2Ftest%2Fdebug-info%2Fbasic-types-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbasic-types-metadata.rs?ref=80c6c73647cc3294c587d8089d6628d8969f0b71", "patch": "@@ -45,7 +45,7 @@\n // debugger:whatis f64\n // check:type = f64\n // debugger:info functions _yyy\n-// check:[...]![...]_yyy()();\n+// check:[...]![...]_yyy([...])([...]);\n // debugger:detach\n // debugger:quit\n "}]}