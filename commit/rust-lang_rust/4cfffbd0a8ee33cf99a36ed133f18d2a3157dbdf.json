{"sha": "4cfffbd0a8ee33cf99a36ed133f18d2a3157dbdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZmZmYmQwYThlZTMzY2Y5OWEzNmVkMTMzZjE4ZDJhMzE1N2RiZGY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-03-12T07:56:02Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-03-19T20:27:31Z"}, "message": "Reimplement import reordering.", "tree": {"sha": "09dd220c51b851df5aa5f99a0e8ac44876e58822", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09dd220c51b851df5aa5f99a0e8ac44876e58822"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cfffbd0a8ee33cf99a36ed133f18d2a3157dbdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cfffbd0a8ee33cf99a36ed133f18d2a3157dbdf", "html_url": "https://github.com/rust-lang/rust/commit/4cfffbd0a8ee33cf99a36ed133f18d2a3157dbdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cfffbd0a8ee33cf99a36ed133f18d2a3157dbdf/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a76d9b529a75780690aa0978471f18da81676dd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a76d9b529a75780690aa0978471f18da81676dd4", "html_url": "https://github.com/rust-lang/rust/commit/a76d9b529a75780690aa0978471f18da81676dd4"}], "stats": {"total": 485, "additions": 403, "deletions": 82}, "files": [{"sha": "0a33177d72f8ec88db5944c0f6d0d38c993de230", "filename": "src/reorder.rs", "status": "modified", "additions": 403, "deletions": 82, "changes": 485, "blob_url": "https://github.com/rust-lang/rust/blob/4cfffbd0a8ee33cf99a36ed133f18d2a3157dbdf/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfffbd0a8ee33cf99a36ed133f18d2a3157dbdf/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=4cfffbd0a8ee33cf99a36ed133f18d2a3157dbdf", "patch": "@@ -17,6 +17,7 @@\n // TODO(#2455): Reorder trait items.\n \n use config::{Config, lists::*};\n+use syntax::ast::UseTreeKind;\n use syntax::{ast, attr, codemap::Span};\n \n use attr::filter_inline_attrs;\n@@ -31,86 +32,12 @@ use spanned::Spanned;\n use utils::mk_sp;\n use visitor::FmtVisitor;\n \n-use std::cmp::Ordering;\n+use std::cmp::{Ord, Ordering, PartialOrd};\n \n-fn compare_path_segments(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n-    a.identifier.name.as_str().cmp(&b.identifier.name.as_str())\n-}\n-\n-fn compare_paths(a: &ast::Path, b: &ast::Path) -> Ordering {\n-    for segment in a.segments.iter().zip(b.segments.iter()) {\n-        let ord = compare_path_segments(segment.0, segment.1);\n-        if ord != Ordering::Equal {\n-            return ord;\n-        }\n-    }\n-    a.segments.len().cmp(&b.segments.len())\n-}\n-\n-fn compare_use_trees(a: &ast::UseTree, b: &ast::UseTree, nested: bool) -> Ordering {\n-    use ast::UseTreeKind::*;\n-\n-    // `use_nested_groups` is not yet supported, remove the `if !nested` when support will be\n-    // fully added\n-    if !nested {\n-        let paths_cmp = compare_paths(&a.prefix, &b.prefix);\n-        if paths_cmp != Ordering::Equal {\n-            return paths_cmp;\n-        }\n-    }\n-\n-    match (&a.kind, &b.kind) {\n-        (&Simple(ident_a), &Simple(ident_b)) => {\n-            let name_a = &*path_to_imported_ident(&a.prefix).name.as_str();\n-            let name_b = &*path_to_imported_ident(&b.prefix).name.as_str();\n-            let name_ordering = if name_a == \"self\" {\n-                if name_b == \"self\" {\n-                    Ordering::Equal\n-                } else {\n-                    Ordering::Less\n-                }\n-            } else if name_b == \"self\" {\n-                Ordering::Greater\n-            } else {\n-                name_a.cmp(name_b)\n-            };\n-            if name_ordering == Ordering::Equal {\n-                if ident_a.name.as_str() != name_a {\n-                    if ident_b.name.as_str() != name_b {\n-                        ident_a.name.as_str().cmp(&ident_b.name.as_str())\n-                    } else {\n-                        Ordering::Greater\n-                    }\n-                } else {\n-                    Ordering::Less\n-                }\n-            } else {\n-                name_ordering\n-            }\n-        }\n-        (&Glob, &Glob) => Ordering::Equal,\n-        (&Simple(_), _) | (&Glob, &Nested(_)) => Ordering::Less,\n-        (&Nested(ref a_items), &Nested(ref b_items)) => {\n-            let mut a = a_items\n-                .iter()\n-                .map(|&(ref tree, _)| tree.clone())\n-                .collect::<Vec<_>>();\n-            let mut b = b_items\n-                .iter()\n-                .map(|&(ref tree, _)| tree.clone())\n-                .collect::<Vec<_>>();\n-            a.sort_by(|a, b| compare_use_trees(a, b, true));\n-            b.sort_by(|a, b| compare_use_trees(a, b, true));\n-            for comparison_pair in a.iter().zip(b.iter()) {\n-                let ord = compare_use_trees(comparison_pair.0, comparison_pair.1, true);\n-                if ord != Ordering::Equal {\n-                    return ord;\n-                }\n-            }\n-            a.len().cmp(&b.len())\n-        }\n-        (&Glob, &Simple(_)) | (&Nested(_), _) => Ordering::Greater,\n-    }\n+fn compare_use_trees(a: &ast::UseTree, b: &ast::UseTree) -> Ordering {\n+    let aa = UseTree::from_ast(a).normalize();\n+    let bb = UseTree::from_ast(b).normalize();\n+    aa.cmp(&bb)\n }\n \n /// Choose the ordering between the given two items.\n@@ -120,7 +47,7 @@ fn compare_items(a: &ast::Item, b: &ast::Item) -> Ordering {\n             a.ident.name.as_str().cmp(&b.ident.name.as_str())\n         }\n         (&ast::ItemKind::Use(ref a_tree), &ast::ItemKind::Use(ref b_tree)) => {\n-            compare_use_trees(a_tree, b_tree, false)\n+            compare_use_trees(a_tree, b_tree)\n         }\n         (&ast::ItemKind::ExternCrate(ref a_name), &ast::ItemKind::ExternCrate(ref b_name)) => {\n             // `extern crate foo as bar;`\n@@ -149,8 +76,6 @@ fn compare_items(a: &ast::Item, b: &ast::Item) -> Ordering {\n \n /// Rewrite a list of items with reordering. Every item in `items` must have\n /// the same `ast::ItemKind`.\n-// TODO (some day) remove unused imports, expand globs, compress many single\n-// imports into a list import.\n fn rewrite_reorderable_items(\n     context: &RewriteContext,\n     reorderable_items: &[&ast::Item],\n@@ -329,3 +254,399 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n     }\n }\n+\n+// Ordering of imports\n+\n+// We order imports by translating to our own representation and then sorting.\n+// The Rust AST data structures are really bad for this. Rustfmt applies a bunch\n+// of normalisations to imports and since we want to sort based on the result\n+// of these (and to maintain idempotence) we must apply the same normalisations\n+// to the data structures for sorting.\n+//\n+// We sort `self` and `super` before other imports, then identifier imports,\n+// then glob imports, then lists of imports. We do not take aliases into account\n+// when ordering unless the imports are identical except for the alias (rare in\n+// practice).\n+\n+// FIXME(#2531) - we should unify the comparison code here with the formatting\n+// code elsewhere since we are essentially string-ifying twice. Furthermore, by\n+// parsing to our own format on comparison, we repeat a lot of work when\n+// sorting.\n+\n+// FIXME we do a lot of allocation to make our own representation.\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+enum UseSegment {\n+    Ident(String, Option<String>),\n+    Slf(Option<String>),\n+    Super(Option<String>),\n+    Glob,\n+    List(Vec<UseTree>),\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+struct UseTree {\n+    path: Vec<UseSegment>,\n+}\n+\n+impl UseSegment {\n+    // Clone a version of self with any top-level alias removed.\n+    fn remove_alias(&self) -> UseSegment {\n+        match *self {\n+            UseSegment::Ident(ref s, _) => UseSegment::Ident(s.clone(), None),\n+            UseSegment::Slf(_) => UseSegment::Slf(None),\n+            UseSegment::Super(_) => UseSegment::Super(None),\n+            _ => self.clone(),\n+        }\n+    }\n+}\n+\n+impl UseTree {\n+    fn from_ast(a: &ast::UseTree) -> UseTree {\n+        let mut result = UseTree { path: vec![] };\n+        for p in &a.prefix.segments {\n+            result.path.push(UseSegment::Ident(\n+                (*p.identifier.name.as_str()).to_owned(),\n+                None,\n+            ));\n+        }\n+        match a.kind {\n+            UseTreeKind::Glob => {\n+                result.path.push(UseSegment::Glob);\n+            }\n+            UseTreeKind::Nested(ref list) => {\n+                result.path.push(UseSegment::List(\n+                    list.iter().map(|t| Self::from_ast(&t.0)).collect(),\n+                ));\n+            }\n+            UseTreeKind::Simple(ref rename) => {\n+                let mut name = (*path_to_imported_ident(&a.prefix).name.as_str()).to_owned();\n+                let alias = if &name == &*rename.name.as_str() {\n+                    None\n+                } else {\n+                    Some((&*rename.name.as_str()).to_owned())\n+                };\n+\n+                let segment = if &name == \"self\" {\n+                    UseSegment::Slf(alias)\n+                } else if &name == \"super\" {\n+                    UseSegment::Super(alias)\n+                } else {\n+                    UseSegment::Ident(name, alias)\n+                };\n+\n+                // `name` is already in result.\n+                result.path.pop();\n+                result.path.push(segment);\n+            }\n+        }\n+        result\n+    }\n+\n+    // Do the adjustments that rustfmt does elsewhere to use paths.\n+    fn normalize(mut self) -> UseTree {\n+        let mut last = self.path.pop().expect(\"Empty use tree?\");\n+        // Hack around borrow checker.\n+        let mut normalize_sole_list = false;\n+        let mut aliased_self = false;\n+\n+        // Normalise foo::self -> foo.\n+        if let UseSegment::Slf(None) = last {\n+            return self;\n+        }\n+\n+        // Normalise foo::self as bar -> foo as bar.\n+        if let UseSegment::Slf(_) = last {\n+            match self.path.last() {\n+                None => {}\n+                Some(UseSegment::Ident(_, None)) => {\n+                    aliased_self = true;\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        if aliased_self {\n+            match self.path.last() {\n+                Some(UseSegment::Ident(_, ref mut old_rename)) => {\n+                    assert!(old_rename.is_none());\n+                    if let UseSegment::Slf(Some(rename)) = last {\n+                        *old_rename = Some(rename);\n+                        return self;\n+                    }\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        // Normalise foo::{bar} -> foo::bar\n+        if let UseSegment::List(ref list) = last {\n+            if list.len() == 1 && list[0].path.len() == 1 {\n+                normalize_sole_list = true;\n+            }\n+        }\n+\n+        if normalize_sole_list {\n+            match last {\n+                UseSegment::List(list) => {\n+                    self.path.push(list[0].path[0].clone());\n+                    return self.normalize();\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        // Recursively normalize elements of a list use (including sorting the list).\n+        if let UseSegment::List(list) = last {\n+            let mut list: Vec<_> = list.into_iter().map(|ut| ut.normalize()).collect();\n+            list.sort();\n+            last = UseSegment::List(list);\n+        }\n+\n+        self.path.push(last);\n+        self\n+    }\n+}\n+\n+impl PartialOrd for UseSegment {\n+    fn partial_cmp(&self, other: &UseSegment) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+impl PartialOrd for UseTree {\n+    fn partial_cmp(&self, other: &UseTree) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+impl Ord for UseSegment {\n+    fn cmp(&self, other: &UseSegment) -> Ordering {\n+        use self::UseSegment::*;\n+\n+        match (self, other) {\n+            (&Slf(ref a), &Slf(ref b)) | (&Super(ref a), &Super(ref b)) => a.cmp(b),\n+            (&Glob, &Glob) => Ordering::Equal,\n+            (&Ident(ref ia, ref aa), &Ident(ref ib, ref ab)) => {\n+                let ident_ord = ia.cmp(ib);\n+                if ident_ord != Ordering::Equal {\n+                    return ident_ord;\n+                }\n+                if aa.is_none() && ab.is_some() {\n+                    return Ordering::Less;\n+                }\n+                if aa.is_some() && ab.is_none() {\n+                    return Ordering::Greater;\n+                }\n+                aa.cmp(ab)\n+            }\n+            (&List(ref a), &List(ref b)) => {\n+                for (a, b) in a.iter().zip(b.iter()) {\n+                    let ord = a.cmp(b);\n+                    if ord != Ordering::Equal {\n+                        return ord;\n+                    }\n+                }\n+\n+                a.len().cmp(&b.len())\n+            }\n+            (&Slf(_), _) => Ordering::Less,\n+            (_, &Slf(_)) => Ordering::Greater,\n+            (&Super(_), _) => Ordering::Less,\n+            (_, &Super(_)) => Ordering::Greater,\n+            (&Ident(..), _) => Ordering::Less,\n+            (_, &Ident(..)) => Ordering::Greater,\n+            (&Glob, _) => Ordering::Less,\n+            (_, &Glob) => Ordering::Greater,\n+        }\n+    }\n+}\n+impl Ord for UseTree {\n+    fn cmp(&self, other: &UseTree) -> Ordering {\n+        for (a, b) in self.path.iter().zip(other.path.iter()) {\n+            let ord = a.cmp(b);\n+            // The comparison without aliases is a hack to avoid situations like\n+            // comparing `a::b` to `a as c` - where the latter should be ordered\n+            // first since it is shorter.\n+            if ord != Ordering::Equal && a.remove_alias().cmp(&b.remove_alias()) != Ordering::Equal\n+            {\n+                return ord;\n+            }\n+        }\n+\n+        self.path.len().cmp(&other.path.len())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    // Parse the path part of an import. This parser is not robust and is only\n+    // suitable for use in a test harness.\n+    fn parse_use_tree(s: &str) -> UseTree {\n+        use std::iter::Peekable;\n+        use std::mem::swap;\n+        use std::str::Chars;\n+\n+        struct Parser<'a> {\n+            input: Peekable<Chars<'a>>,\n+        }\n+\n+        impl<'a> Parser<'a> {\n+            fn bump(&mut self) {\n+                self.input.next().unwrap();\n+            }\n+            fn eat(&mut self, c: char) {\n+                assert!(self.input.next().unwrap() == c);\n+            }\n+            fn push_segment(\n+                result: &mut Vec<UseSegment>,\n+                buf: &mut String,\n+                alias_buf: &mut Option<String>,\n+            ) {\n+                if !buf.is_empty() {\n+                    let mut alias = None;\n+                    swap(alias_buf, &mut alias);\n+                    if buf == \"self\" {\n+                        result.push(UseSegment::Slf(alias));\n+                        *buf = String::new();\n+                        *alias_buf = None;\n+                    } else if buf == \"super\" {\n+                        result.push(UseSegment::Super(alias));\n+                        *buf = String::new();\n+                        *alias_buf = None;\n+                    } else {\n+                        let mut name = String::new();\n+                        swap(buf, &mut name);\n+                        result.push(UseSegment::Ident(name, alias));\n+                    }\n+                }\n+            }\n+            fn parse_in_list(&mut self) -> UseTree {\n+                let mut result = vec![];\n+                let mut buf = String::new();\n+                let mut alias_buf = None;\n+                while let Some(&c) = self.input.peek() {\n+                    match c {\n+                        '{' => {\n+                            assert!(buf.is_empty());\n+                            self.bump();\n+                            result.push(UseSegment::List(self.parse_list()));\n+                            self.eat('}');\n+                        }\n+                        '*' => {\n+                            assert!(buf.is_empty());\n+                            self.bump();\n+                            result.push(UseSegment::Glob);\n+                        }\n+                        ':' => {\n+                            self.bump();\n+                            self.eat(':');\n+                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                        }\n+                        '}' | ',' => {\n+                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                            return UseTree { path: result };\n+                        }\n+                        ' ' => {\n+                            self.bump();\n+                            self.eat('a');\n+                            self.eat('s');\n+                            self.eat(' ');\n+                            alias_buf = Some(String::new());\n+                        }\n+                        c => {\n+                            self.bump();\n+                            if let Some(ref mut buf) = alias_buf {\n+                                buf.push(c);\n+                            } else {\n+                                buf.push(c);\n+                            }\n+                        }\n+                    }\n+                }\n+                Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                UseTree { path: result }\n+            }\n+\n+            fn parse_list(&mut self) -> Vec<UseTree> {\n+                let mut result = vec![];\n+                loop {\n+                    match self.input.peek().unwrap() {\n+                        ',' | ' ' => self.bump(),\n+                        '}' => {\n+                            return result;\n+                        }\n+                        _ => result.push(self.parse_in_list()),\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut parser = Parser {\n+            input: s.chars().peekable(),\n+        };\n+        parser.parse_in_list()\n+    }\n+\n+    #[test]\n+    fn test_use_tree_normalize() {\n+        assert_eq!(parse_use_tree(\"a::self\").normalize(), parse_use_tree(\"a\"));\n+        assert_eq!(\n+            parse_use_tree(\"a::self as foo\").normalize(),\n+            parse_use_tree(\"a as foo\")\n+        );\n+        assert_eq!(parse_use_tree(\"a::{self}\").normalize(), parse_use_tree(\"a\"));\n+        assert_eq!(parse_use_tree(\"a::{b}\").normalize(), parse_use_tree(\"a::b\"));\n+        assert_eq!(\n+            parse_use_tree(\"a::{b, c::self}\").normalize(),\n+            parse_use_tree(\"a::{b, c}\")\n+        );\n+        assert_eq!(\n+            parse_use_tree(\"a::{b as bar, c::self}\").normalize(),\n+            parse_use_tree(\"a::{b as bar, c}\")\n+        );\n+    }\n+\n+    #[test]\n+    fn test_use_tree_ord() {\n+        assert!(parse_use_tree(\"a\").normalize() < parse_use_tree(\"aa\").normalize());\n+        assert!(parse_use_tree(\"a\").normalize() < parse_use_tree(\"a::a\").normalize());\n+        assert!(parse_use_tree(\"a\").normalize() < parse_use_tree(\"*\").normalize());\n+        assert!(parse_use_tree(\"a\").normalize() < parse_use_tree(\"{a, b}\").normalize());\n+        assert!(parse_use_tree(\"*\").normalize() < parse_use_tree(\"{a, b}\").normalize());\n+\n+        assert!(\n+            parse_use_tree(\"aaaaaaaaaaaaaaa::{bb, cc, dddddddd}\").normalize()\n+                < parse_use_tree(\"aaaaaaaaaaaaaaa::{bb, cc, ddddddddd}\").normalize()\n+        );\n+        assert!(\n+            parse_use_tree(\"serde::de::{Deserialize}\").normalize()\n+                < parse_use_tree(\"serde_json\").normalize()\n+        );\n+        assert!(parse_use_tree(\"a::b::c\").normalize() < parse_use_tree(\"a::b::*\").normalize());\n+        assert!(\n+            parse_use_tree(\"foo::{Bar, Baz}\").normalize()\n+                < parse_use_tree(\"{Bar, Baz}\").normalize()\n+        );\n+\n+        assert!(\n+            parse_use_tree(\"foo::{self as bar}\").normalize()\n+                < parse_use_tree(\"foo::{qux as bar}\").normalize()\n+        );\n+        assert!(\n+            parse_use_tree(\"foo::{qux as bar}\").normalize()\n+                < parse_use_tree(\"foo::{baz, qux as bar}\").normalize()\n+        );\n+        assert!(\n+            parse_use_tree(\"foo::{self as bar, baz}\").normalize()\n+                < parse_use_tree(\"foo::{baz, qux as bar}\").normalize()\n+        );\n+\n+        assert!(parse_use_tree(\"Foo\").normalize() < parse_use_tree(\"foo\").normalize());\n+        assert!(parse_use_tree(\"foo\").normalize() < parse_use_tree(\"foo::Bar\").normalize());\n+\n+        assert!(\n+            parse_use_tree(\"std::cmp::{d, c, b, a}\").normalize()\n+                < parse_use_tree(\"std::cmp::{b, e, g, f}\").normalize()\n+        );\n+    }\n+}"}]}