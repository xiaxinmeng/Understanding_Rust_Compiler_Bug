{"sha": "5520ea81a1ce986e0ca1a6305c82290571a0be4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MjBlYTgxYTFjZTk4NmUwY2ExYTYzMDVjODIyOTA1NzFhMGJlNGM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-09-01T23:25:01Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-09-02T07:47:39Z"}, "message": "Reviewer changes", "tree": {"sha": "7af859a8e925c0e293c5b92896e88ac608202ffb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7af859a8e925c0e293c5b92896e88ac608202ffb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5520ea81a1ce986e0ca1a6305c82290571a0be4c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5520ea81a1ce986e0ca1a6305c82290571a0be4c", "html_url": "https://github.com/rust-lang/rust/commit/5520ea81a1ce986e0ca1a6305c82290571a0be4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5520ea81a1ce986e0ca1a6305c82290571a0be4c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52d6d3be483365a375cca89b226e1fee008702d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/52d6d3be483365a375cca89b226e1fee008702d2", "html_url": "https://github.com/rust-lang/rust/commit/52d6d3be483365a375cca89b226e1fee008702d2"}], "stats": {"total": 173, "additions": 108, "deletions": 65}, "files": [{"sha": "da4bc4dbc7694f97eab14654d6d9325307ef933c", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=5520ea81a1ce986e0ca1a6305c82290571a0be4c", "patch": "@@ -896,8 +896,8 @@ fn trait_cast_types(fcx: &FnCtxt,\n         match autoref {\n             &ty::AutoUnsize(ref k) |\n             &ty::AutoUnsizeUniq(ref k) => trait_cast_types_unsize(fcx, k, src_ty, sp),\n-            &ty::AutoPtr(_, _, Some(box ref autoref))\n-            | &ty::AutoUnsafe(_, Some(box ref autoref))=> {\n+            &ty::AutoPtr(_, _, Some(box ref autoref)) |\n+            &ty::AutoUnsafe(_, Some(box ref autoref)) => {\n                 trait_cast_types_autoref(fcx, autoref, src_ty, sp)\n             }\n             _ => None"}, {"sha": "9c58a4c79f057a400b37d0a73ed3762b29f6fef0", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=5520ea81a1ce986e0ca1a6305c82290571a0be4c", "patch": "@@ -157,16 +157,19 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n                 ty_unboxed_closure(def_id, _) => {\n                     Some(def_id)\n                 }\n-                ty_ptr(ty::mt {ty, ..}) | ty_rptr(_, ty::mt {ty, ..}) | ty_uniq(ty)\n-                => match ty::get(ty).sty {\n-                    ty_trait(box ty::TyTrait { def_id, .. }) => {\n-                        Some(def_id)\n-                    }\n-                    _ => {\n-                        fail!(\"get_base_type() returned a type that wasn't an \\\n-                               enum, struct, or trait\");\n+                ty_ptr(ty::mt {ty, ..}) |\n+                ty_rptr(_, ty::mt {ty, ..}) |\n+                ty_uniq(ty) => {\n+                    match ty::get(ty).sty {\n+                        ty_trait(box ty::TyTrait { def_id, .. }) => {\n+                            Some(def_id)\n+                        }\n+                        _ => {\n+                            fail!(\"get_base_type() returned a type that wasn't an \\\n+                                   enum, struct, or trait\");\n+                        }\n                     }\n-                },\n+                }\n                 ty_trait(box ty::TyTrait { def_id, .. }) => {\n                     Some(def_id)\n                 }"}, {"sha": "381c47279e390ff8ef7f88ee37c7d7f422bf1251", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 26, "deletions": 38, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=5520ea81a1ce986e0ca1a6305c82290571a0be4c", "patch": "@@ -350,8 +350,7 @@ impl<'f> Coerce<'f> {\n                     }\n                 })\n             }\n-            (&ty::ty_ptr(ty::mt{ty: t_a, ..}), &ty::ty_ptr(mt_b))\n-            | (&ty::ty_rptr(_, ty::mt{ty: t_a, ..}), &ty::ty_ptr(mt_b)) => {\n+            (&ty::ty_rptr(_, ty::mt{ty: t_a, ..}), &ty::ty_ptr(mt_b)) => {\n                 self.unpack_actual_value(t_a, |sty_a| {\n                     match self.unsize_ty(sty_a, mt_b.ty) {\n                         Some((ty, kind)) => {\n@@ -478,63 +477,52 @@ impl<'f> Coerce<'f> {\n                b.repr(tcx));\n \n         let coercion = Coercion(self.get_ref().trace.clone());\n+        let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n-        match *sty_a {\n-            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n-                ty::ty_trait(box ty::TyTrait {\n-                        def_id,\n-                        ref substs,\n-                        bounds,\n-                        ..\n-                    }) => {\n-                    let tr = ty::mk_trait(tcx, def_id, substs.clone(), bounds);\n-                    let r_a = self.get_ref().infcx.next_region_var(coercion);\n-                    let a_borrowed = ty::mk_rptr(tcx, r_a, ty::mt{ mutbl: b_mutbl, ty: tr });\n-\n-                    try!(self.subtype(a_borrowed, b));\n-                    Ok(Some(AutoDerefRef(AutoDerefRef {\n-                        autoderefs: 1,\n-                        autoref: Some(AutoPtr(r_a, b_mutbl, None))\n-                    })))\n-                }\n-                _ => {\n-                    self.subtype(a, b)\n-                }\n-            },\n-            _ => {\n-                self.subtype(a, b)\n-            }\n-        }\n+        self.coerce_object(a, sty_a, b,\n+                           |tr| ty::mk_rptr(tcx, r_a, ty::mt{ mutbl: b_mutbl, ty: tr }),\n+                           || AutoPtr(r_a, b_mutbl, None))\n     }\n \n     fn coerce_unsafe_object(&self,\n-                              a: ty::t,\n-                              sty_a: &ty::sty,\n-                              b: ty::t,\n-                              b_mutbl: ast::Mutability) -> CoerceResult\n+                            a: ty::t,\n+                            sty_a: &ty::sty,\n+                            b: ty::t,\n+                            b_mutbl: ast::Mutability) -> CoerceResult\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n         debug!(\"coerce_unsafe_object(a={}, sty_a={:?}, b={})\",\n                a.repr(tcx), sty_a,\n                b.repr(tcx));\n \n+        self.coerce_object(a, sty_a, b,\n+                           |tr| ty::mk_ptr(tcx, ty::mt{ mutbl: b_mutbl, ty: tr }),\n+                           || AutoUnsafe(b_mutbl, None))\n+    }\n+\n+    fn coerce_object(&self,\n+                     a: ty::t,\n+                     sty_a: &ty::sty,\n+                     b: ty::t,\n+                     mk_ty: |ty::t| -> ty::t,\n+                     mk_adjust: || -> ty::AutoRef) -> CoerceResult\n+    {\n+        let tcx = self.get_ref().infcx.tcx;\n+\n         match *sty_a {\n-            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) |\n-            ty::ty_ptr(ty::mt{ty, ..}) => match ty::get(ty).sty {\n+            ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n                 ty::ty_trait(box ty::TyTrait {\n                         def_id,\n                         ref substs,\n                         bounds,\n                         ..\n                     }) => {\n                     let tr = ty::mk_trait(tcx, def_id, substs.clone(), bounds);\n-                    let a_raw = ty::mk_ptr(tcx, ty::mt{ mutbl: b_mutbl, ty: tr });\n-\n-                    try!(self.subtype(a_raw, b));\n+                    try!(self.subtype(mk_ty(tr), b));\n                     Ok(Some(AutoDerefRef(AutoDerefRef {\n                         autoderefs: 1,\n-                        autoref: Some(AutoUnsafe(b_mutbl, None))\n+                        autoref: Some(mk_adjust())\n                     })))\n                 }\n                 _ => {"}, {"sha": "cc5d3b520f95cc89ebeaf7727476a5eeffd5276e", "filename": "src/test/compile-fail/dst-bad-coercions.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs?ref=5520ea81a1ce986e0ca1a6305c82290571a0be4c", "patch": "@@ -8,21 +8,44 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test implicit coercions involving DSTs and raw pointers.\n+\n struct S;\n trait T {}\n impl T for S {}\n \n+struct Foo<Sized? T> {\n+    f: T\n+}\n+\n pub fn main() {\n+    // Test that we cannot convert from *-ptr to &-ptr\n     let x: *const S = &S;\n-    let y: &S = x; //~ ERROR mismatched types: expected `&S`, found `*const S` (expected &-ptr\n-    let y: &T = x; //~ ERROR  mismatched types: expected `&T`, found `*const S` (expected &-ptr\n+    let y: &S = x; //~ ERROR mismatched types\n+    let y: &T = x; //~ ERROR mismatched types\n \n+    // Test that we cannot convert from *-ptr to &-ptr (mut version)\n     let x: *mut S = &mut S;\n-    let y: &S = x; //~ ERROR mismatched types: expected `&S`, found `*mut S` (expected &-ptr\n-    let y: &T = x; //~ ERROR  mismatched types: expected `&T`, found `*mut S` (expected &-ptr\n+    let y: &S = x; //~ ERROR mismatched types\n+    let y: &T = x; //~ ERROR mismatched types\n \n+    // Test that we cannot convert an immutable ptr to a mutable one using *-ptrs\n     let x: &mut T = &S; //~ ERROR types differ in mutability\n     let x: *mut T = &S; //~ ERROR types differ in mutability\n     let x: *mut S = &S;\n-    //~^ ERROR mismatched types: expected `*mut S`, found `&S` (values differ in mutability)\n-}\n\\ No newline at end of file\n+    //~^ ERROR mismatched types\n+\n+    // The below four sets of tests test that we cannot implicitly deref a *-ptr\n+    // during a coercion.\n+    let x: *const S = &S;\n+    let y: *const T = x;  //~ ERROR mismatched types\n+\n+    let x: *mut S = &mut S;\n+    let y: *mut T = x;  //~ ERROR mismatched types\n+\n+    let x: *const Foo<S> = &Foo {f: S};\n+    let y: *const Foo<T> = x;  //~ ERROR mismatched types\n+\n+    let x: *mut Foo<S> = &mut Foo {f: S};\n+    let y: *mut Foo<T> = x;  //~ ERROR mismatched types\n+}"}, {"sha": "39bf899a023f14fce9ea3d20293b7cf52c7385bb", "filename": "src/test/run-fail/dst-raw-slice.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Ftest%2Frun-fail%2Fdst-raw-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Ftest%2Frun-fail%2Fdst-raw-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdst-raw-slice.rs?ref=5520ea81a1ce986e0ca1a6305c82290571a0be4c", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test bounds checking for DST raw slices\n+// error-pattern:index out of bounds\n+\n+fn main() {\n+    let a: *const [_] = &[1i, 2, 3];\n+    unsafe {\n+        let _b = (*a)[3];\n+    }\n+}"}, {"sha": "1c9d5cd3afe4d6c2a8b997090bd864ec694e9936", "filename": "src/test/run-pass/dst-coercions.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Ftest%2Frun-pass%2Fdst-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Ftest%2Frun-pass%2Fdst-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-coercions.rs?ref=5520ea81a1ce986e0ca1a6305c82290571a0be4c", "patch": "@@ -8,21 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test coercions involving DST and/or raw pointers\n+\n struct S;\n trait T {}\n impl T for S {}\n \n pub fn main() {\n     let x: &T = &S;\n+    // Test we can convert from &-ptr to *-ptr of trait objects\n     let x: *const T = &S;\n \n+    // Test we can convert from &-ptr to *-ptr of struct pointer (not DST)\n     let x: *const S = &S;\n \n+    // As above, but mut\n     let x: &mut T = &mut S;\n     let x: *mut T = &mut S;\n \n     let x: *mut S = &mut S;\n \n+    // Test we can chnage the mutability from mut to const.\n     let x: &T = &mut S;\n     let x: *const T = &mut S;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "a977e961b13521c826f2f391d04dbd35f849776b", "filename": "src/test/run-pass/dst-raw.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5520ea81a1ce986e0ca1a6305c82290571a0be4c/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-raw.rs?ref=5520ea81a1ce986e0ca1a6305c82290571a0be4c", "patch": "@@ -23,24 +23,22 @@ impl Trait for A {\n     }\n }\n \n-pub struct Foo<Sized? T> {\n+struct Foo<Sized? T> {\n     f: T\n }\n \n pub fn main() {\n     // raw trait object\n     let x = A { f: 42 };\n-    let y: *const A = &x;\n-    let z: *const Trait = y;\n+    let z: *const Trait = &x;\n     let r = unsafe {\n         (&*z).foo()\n     };\n     assert!(r == 42);\n \n     // raw DST struct\n     let p = Foo {f: A { f: 42 }};\n-    let q: *const Foo<A> = &p;\n-    let o: *const Foo<Trait> = q;\n+    let o: *const Foo<Trait> = &p;\n     let r = unsafe {\n         (&*o).f.foo()\n     };\n@@ -51,27 +49,29 @@ pub fn main() {\n     unsafe {\n         let b = (*a)[2];\n         assert!(b == 3);\n+        let len = (*a).len();\n+        assert!(len == 3);\n     }\n \n     // raw DST struct with slice\n     let c: *const Foo<[_]> = &Foo {f: [1i, 2, 3]};\n     unsafe {\n         let b = (&*c).f[0];\n         assert!(b == 1);\n+        let len = (&*c).f.len();\n+        assert!(len == 3);\n     }\n \n     // all of the above with *mut\n     let mut x = A { f: 42 };\n-    let y: *mut A = &mut x;\n-    let z: *mut Trait = y;\n+    let z: *mut Trait = &mut x;\n     let r = unsafe {\n         (&*z).foo()\n     };\n     assert!(r == 42);\n \n     let mut p = Foo {f: A { f: 42 }};\n-    let q: *mut Foo<A> = &mut p;\n-    let o: *mut Foo<Trait> = q;\n+    let o: *mut Foo<Trait> = &mut p;\n     let r = unsafe {\n         (&*o).f.foo()\n     };\n@@ -81,11 +81,15 @@ pub fn main() {\n     unsafe {\n         let b = (*a)[2];\n         assert!(b == 3);\n+        let len = (*a).len();\n+        assert!(len == 3);\n     }\n \n     let c: *mut Foo<[_]> = &mut Foo {f: [1i, 2, 3]};\n     unsafe {\n         let b = (&*c).f[0];\n         assert!(b == 1);\n+        let len = (&*c).f.len();\n+        assert!(len == 3);\n     }\n }\n\\ No newline at end of file"}]}