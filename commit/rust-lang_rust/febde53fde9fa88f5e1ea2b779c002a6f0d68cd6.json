{"sha": "febde53fde9fa88f5e1ea2b779c002a6f0d68cd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlYmRlNTNmZGU5ZmE4OGY1ZTFlYTJiNzc5YzAwMmE2ZjBkNjhjZDY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-17T16:21:43Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-17T17:13:54Z"}, "message": "rustc_metadata: Cleanup crate search with exact paths", "tree": {"sha": "3a7eb276025d2e3dfce1130ae30a88d550265f05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a7eb276025d2e3dfce1130ae30a88d550265f05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/febde53fde9fa88f5e1ea2b779c002a6f0d68cd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/febde53fde9fa88f5e1ea2b779c002a6f0d68cd6", "html_url": "https://github.com/rust-lang/rust/commit/febde53fde9fa88f5e1ea2b779c002a6f0d68cd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/febde53fde9fa88f5e1ea2b779c002a6f0d68cd6/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26f113e5b670a37678750b81d8ad3e5ca2a789a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/26f113e5b670a37678750b81d8ad3e5ca2a789a0", "html_url": "https://github.com/rust-lang/rust/commit/26f113e5b670a37678750b81d8ad3e5ca2a789a0"}], "stats": {"total": 48, "additions": 22, "deletions": 26}, "files": [{"sha": "64230fd9e608d5194d6519a51c32eee332d7b277", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/febde53fde9fa88f5e1ea2b779c002a6f0d68cd6/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febde53fde9fa88f5e1ea2b779c002a6f0d68cd6/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=febde53fde9fa88f5e1ea2b779c002a6f0d68cd6", "patch": "@@ -261,6 +261,7 @@ crate struct CrateLocator<'a> {\n \n     // Immutable per-search configuration.\n     crate_name: Symbol,\n+    exact_paths: Vec<PathBuf>,\n     pub hash: Option<&'a Svh>,\n     pub host_hash: Option<&'a Svh>,\n     extra_filename: Option<&'a str>,\n@@ -277,7 +278,6 @@ crate struct CrateLocator<'a> {\n     rejected_via_kind: Vec<CrateMismatch>,\n     rejected_via_version: Vec<CrateMismatch>,\n     rejected_via_filename: Vec<CrateMismatch>,\n-    should_match_name: bool,\n }\n \n crate struct CratePaths {\n@@ -326,6 +326,15 @@ impl<'a> CrateLocator<'a> {\n             sess,\n             metadata_loader,\n             crate_name,\n+            exact_paths: if hash.is_none() {\n+                sess.opts.externs.get(&crate_name.as_str()).into_iter()\n+                    .flat_map(|entry| entry.locations.iter())\n+                    .filter_map(|location| location.clone().map(PathBuf::from)).collect()\n+            } else {\n+                // SVH being specified means this is a transitive dependency,\n+                // so `--extern` options do not apply.\n+                Vec::new()\n+            },\n             hash,\n             host_hash,\n             extra_filename,\n@@ -348,7 +357,6 @@ impl<'a> CrateLocator<'a> {\n             rejected_via_kind: Vec::new(),\n             rejected_via_version: Vec::new(),\n             rejected_via_filename: Vec::new(),\n-            should_match_name: true,\n         }\n     }\n \n@@ -361,6 +369,9 @@ impl<'a> CrateLocator<'a> {\n     }\n \n     crate fn maybe_load_library_crate(&mut self) -> Option<Library> {\n+        if !self.exact_paths.is_empty() {\n+            return self.find_commandline_library();\n+        }\n         let mut seen_paths = FxHashSet::default();\n         match self.extra_filename {\n             Some(s) => self.find_library_crate(s, &mut seen_paths)\n@@ -486,21 +497,6 @@ impl<'a> CrateLocator<'a> {\n                           extra_prefix: &str,\n                           seen_paths: &mut FxHashSet<PathBuf>)\n                           -> Option<Library> {\n-        // If an SVH is specified, then this is a transitive dependency that\n-        // must be loaded via -L plus some filtering.\n-        if self.hash.is_none() {\n-            self.should_match_name = false;\n-            if let Some(entry) = self.sess.opts.externs.get(&self.crate_name.as_str()) {\n-                // Only use `--extern crate_name=path` here, not `--extern crate_name`.\n-                if entry.locations.iter().any(|l| l.is_some()) {\n-                    return self.find_commandline_library(\n-                        entry.locations.iter().filter_map(|l| l.as_ref()),\n-                    );\n-                }\n-            }\n-            self.should_match_name = true;\n-        }\n-\n         let dypair = self.dylibname();\n         let staticpair = self.staticlibname();\n \n@@ -777,7 +773,7 @@ impl<'a> CrateLocator<'a> {\n             }\n         }\n \n-        if self.should_match_name {\n+        if self.exact_paths.is_empty() {\n             if self.crate_name != root.name {\n                 info!(\"Rejecting via crate name\");\n                 return None;\n@@ -824,9 +820,7 @@ impl<'a> CrateLocator<'a> {\n         (t.options.staticlib_prefix.clone(), t.options.staticlib_suffix.clone())\n     }\n \n-    fn find_commandline_library<'b, LOCS>(&mut self, locs: LOCS) -> Option<Library>\n-        where LOCS: Iterator<Item = &'b String>\n-    {\n+    fn find_commandline_library(&mut self) -> Option<Library> {\n         // First, filter out all libraries that look suspicious. We only accept\n         // files which actually exist that have the correct naming scheme for\n         // rlibs/dylibs.\n@@ -836,18 +830,20 @@ impl<'a> CrateLocator<'a> {\n         let mut rmetas = FxHashMap::default();\n         let mut dylibs = FxHashMap::default();\n         {\n-            let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n+                let crate_name = self.crate_name;\n+                let rejected_via_filename = &mut self.rejected_via_filename;\n+                let locs = self.exact_paths.iter().filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n-                                      self.crate_name,\n+                                      crate_name,\n                                       loc.display()));\n                     return false;\n                 }\n                 let file = match loc.file_name().and_then(|s| s.to_str()) {\n                     Some(file) => file,\n                     None => {\n                         sess.err(&format!(\"extern location for {} is not a file: {}\",\n-                                          self.crate_name,\n+                                          crate_name,\n                                           loc.display()));\n                         return false;\n                     }\n@@ -862,8 +858,8 @@ impl<'a> CrateLocator<'a> {\n                     }\n                 }\n \n-                self.rejected_via_filename.push(CrateMismatch {\n-                    path: loc.clone(),\n+                rejected_via_filename.push(CrateMismatch {\n+                    path: (*loc).clone(),\n                     got: String::new(),\n                 });\n "}]}