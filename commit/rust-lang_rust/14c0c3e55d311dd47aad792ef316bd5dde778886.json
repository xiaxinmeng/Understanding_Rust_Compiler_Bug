{"sha": "14c0c3e55d311dd47aad792ef316bd5dde778886", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0YzBjM2U1NWQzMTFkZDQ3YWFkNzkyZWYzMTZiZDVkZGU3Nzg4ODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-13T01:52:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-13T01:52:49Z"}, "message": "Auto merge of #87095 - JohnTitor:rollup-mn7ggy2, r=JohnTitor\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #86344 (Split MaybeUninit::write into new feature gate and stabilize it)\n - #86811 (Remove unstable `io::Cursor::remaining`)\n - #86846 (stdio_locked: add tracking issue)\n - #86887 (rustdoc: remove dead code in `clean`)\n - #87007 (Fix rust-analyzer install when not available.)\n - #87035 (Fix implementors display)\n - #87065 (Fix ICE with unsized type in const pattern)\n - #87070 (Simplify future incompatible reporting.)\n - #87077 (:arrow_up: rust-analyzer)\n - #87078 (Rustdoc: suggest removing disambiguator if linking to field)\n - #87089 (CTFE engine: small cleanups)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "60377c410357e23f1b01e0f719c66244a22d201a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60377c410357e23f1b01e0f719c66244a22d201a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14c0c3e55d311dd47aad792ef316bd5dde778886", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14c0c3e55d311dd47aad792ef316bd5dde778886", "html_url": "https://github.com/rust-lang/rust/commit/14c0c3e55d311dd47aad792ef316bd5dde778886", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14c0c3e55d311dd47aad792ef316bd5dde778886/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa06edb4d5011a36ca7d6d505a7d210b359a3495", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa06edb4d5011a36ca7d6d505a7d210b359a3495", "html_url": "https://github.com/rust-lang/rust/commit/aa06edb4d5011a36ca7d6d505a7d210b359a3495"}, {"sha": "e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b", "html_url": "https://github.com/rust-lang/rust/commit/e46b790b9deb8f0c4db0a052f3cd9a875fc70d3b"}], "stats": {"total": 520, "additions": 316, "deletions": 204}, "files": [{"sha": "b7e8e8fa15752d6761bfe49fcd9ad287c6830b78", "filename": ".gitignore", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -72,4 +72,7 @@ __pycache__/\n **node_modules\n **package-lock.json\n \n+## Rustdoc GUI tests\n+src/test/rustdoc-gui/src/**.lock\n+\n # Before adding new lines, see the comment at the top."}, {"sha": "becc1c6db5bbb9c3337c18dee51a0506d7959784", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -9,7 +9,6 @@\n \n use Destination::*;\n \n-use rustc_lint_defs::FutureBreakage;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{MultiSpan, SourceFile, Span};\n \n@@ -193,7 +192,7 @@ pub trait Emitter {\n     /// other formats can, and will, simply ignore it.\n     fn emit_artifact_notification(&mut self, _path: &Path, _artifact_type: &str) {}\n \n-    fn emit_future_breakage_report(&mut self, _diags: Vec<(FutureBreakage, Diagnostic)>) {}\n+    fn emit_future_breakage_report(&mut self, _diags: Vec<Diagnostic>) {}\n \n     /// Emit list of unused externs\n     fn emit_unused_externs(&mut self, _lint_level: &str, _unused_externs: &[&str]) {}"}, {"sha": "1b6cd04cca642e213efdf22273ddb62a5cfa0d25", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -16,7 +16,7 @@ use crate::registry::Registry;\n use crate::DiagnosticId;\n use crate::ToolMetadata;\n use crate::{CodeSuggestion, SubDiagnostic};\n-use rustc_lint_defs::{Applicability, FutureBreakage};\n+use rustc_lint_defs::Applicability;\n \n use rustc_data_structures::sync::Lrc;\n use rustc_span::hygiene::ExpnData;\n@@ -134,17 +134,14 @@ impl Emitter for JsonEmitter {\n         }\n     }\n \n-    fn emit_future_breakage_report(&mut self, diags: Vec<(FutureBreakage, crate::Diagnostic)>) {\n+    fn emit_future_breakage_report(&mut self, diags: Vec<crate::Diagnostic>) {\n         let data: Vec<FutureBreakageItem> = diags\n             .into_iter()\n-            .map(|(breakage, mut diag)| {\n+            .map(|mut diag| {\n                 if diag.level == crate::Level::Allow {\n                     diag.level = crate::Level::Warning;\n                 }\n-                FutureBreakageItem {\n-                    future_breakage_date: breakage.date,\n-                    diagnostic: Diagnostic::from_errors_diagnostic(&diag, self),\n-                }\n+                FutureBreakageItem { diagnostic: Diagnostic::from_errors_diagnostic(&diag, self) }\n             })\n             .collect();\n         let report = FutureIncompatReport { future_incompat_report: data };\n@@ -326,7 +323,6 @@ struct ArtifactNotification<'a> {\n \n #[derive(Encodable)]\n struct FutureBreakageItem {\n-    future_breakage_date: Option<&'static str>,\n     diagnostic: Diagnostic,\n }\n "}, {"sha": "993a7c2c162c6b7936f5496c1e295e50cc050160", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -23,7 +23,6 @@ use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{self, Lock, Lrc};\n use rustc_data_structures::AtomicRef;\n-use rustc_lint_defs::FutureBreakage;\n pub use rustc_lint_defs::{pluralize, Applicability};\n use rustc_serialize::json::Json;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n@@ -790,7 +789,7 @@ impl Handler {\n         self.inner.borrow_mut().emit_artifact_notification(path, artifact_type)\n     }\n \n-    pub fn emit_future_breakage_report(&self, diags: Vec<(FutureBreakage, Diagnostic)>) {\n+    pub fn emit_future_breakage_report(&self, diags: Vec<Diagnostic>) {\n         self.inner.borrow_mut().emitter.emit_future_breakage_report(diags)\n     }\n "}, {"sha": "5b1cd0bcb3ffe72b34ebeca9b8ae714e064f6c7c", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -6,7 +6,7 @@\n //! compiler code, rather than using their own custom pass. Those\n //! lints are all available in `rustc_lint::builtin`.\n \n-use crate::{declare_lint, declare_lint_pass, FutureBreakage, FutureIncompatibilityReason};\n+use crate::{declare_lint, declare_lint_pass, FutureIncompatibilityReason};\n use rustc_span::edition::Edition;\n \n declare_lint! {\n@@ -3176,9 +3176,7 @@ declare_lint! {\n     \"detects usage of old versions of certain proc-macro crates\",\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #83125 <https://github.com/rust-lang/rust/issues/83125>\",\n-        future_breakage: Some(FutureBreakage {\n-            date: None\n-        })\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n     };\n }\n "}, {"sha": "001198226d9a3a1ee18fce8e3d866402c17d961b", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -152,10 +152,6 @@ pub struct FutureIncompatibleInfo {\n     /// Set to false for lints that already include a more detailed\n     /// explanation.\n     pub explain_reason: bool,\n-    /// Information about a future breakage, which will\n-    /// be emitted in JSON messages to be displayed by Cargo\n-    /// for upstream deps\n-    pub future_breakage: Option<FutureBreakage>,\n }\n \n /// The reason for future incompatibility\n@@ -164,6 +160,9 @@ pub enum FutureIncompatibilityReason {\n     /// This will be an error in a future release\n     /// for all editions\n     FutureReleaseError,\n+    /// This will be an error in a future release, and\n+    /// Cargo should create a report even for dependencies\n+    FutureReleaseErrorReportNow,\n     /// Previously accepted code that will become an\n     /// error in the provided edition\n     EditionError(Edition),\n@@ -182,18 +181,12 @@ impl FutureIncompatibilityReason {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct FutureBreakage {\n-    pub date: Option<&'static str>,\n-}\n-\n impl FutureIncompatibleInfo {\n     pub const fn default_fields_for_macro() -> Self {\n         FutureIncompatibleInfo {\n             reference: \"\",\n             reason: FutureIncompatibilityReason::FutureReleaseError,\n             explain_reason: true,\n-            future_breakage: None,\n         }\n     }\n }"}, {"sha": "484e30027e521ce3961368584152b64a474a02c2", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n use rustc_session::lint::{\n     builtin::{self, FORBIDDEN_LINT_GROUPS},\n-    FutureIncompatibilityReason, Level, Lint, LintId,\n+    FutureIncompatibilityReason, FutureIncompatibleInfo, Level, Lint, LintId,\n };\n use rustc_session::{DiagnosticMessageId, Session};\n use rustc_span::hygiene::MacroKind;\n@@ -223,8 +223,13 @@ pub fn struct_lint_level<'s, 'd>(\n         let lint_id = LintId::of(lint);\n         let future_incompatible = lint.future_incompatible;\n \n-        let has_future_breakage =\n-            future_incompatible.map_or(false, |incompat| incompat.future_breakage.is_some());\n+        let has_future_breakage = matches!(\n+            future_incompatible,\n+            Some(FutureIncompatibleInfo {\n+                reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n+                ..\n+            })\n+        );\n \n         let mut err = match (level, span) {\n             (Level::Allow, span) => {"}, {"sha": "75cbb55239c8b21ff8a10ffb566732e724862548", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -512,7 +512,7 @@ impl InitMaskCompressed {\n /// Transferring the initialization mask to other allocations.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n     /// Creates a run-length encoding of the initialization mask.\n-    pub fn compress_uninit_range(&self, src: Pointer<Tag>, size: Size) -> InitMaskCompressed {\n+    pub fn compress_uninit_range(&self, range: AllocRange) -> InitMaskCompressed {\n         // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n         // a naive initialization mask copying algorithm would repeatedly have to read the initialization mask from\n         // the source and write it to the destination. Even if we optimized the memory accesses,\n@@ -526,13 +526,13 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         // where each element toggles the state.\n \n         let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n-        let initial = self.init_mask.get(src.offset);\n+        let initial = self.init_mask.get(range.start);\n         let mut cur_len = 1;\n         let mut cur = initial;\n \n-        for i in 1..size.bytes() {\n+        for i in 1..range.size.bytes() {\n             // FIXME: optimize to bitshift the current uninitialized block's bits and read the top bit.\n-            if self.init_mask.get(src.offset + Size::from_bytes(i)) == cur {\n+            if self.init_mask.get(range.start + Size::from_bytes(i)) == cur {\n                 cur_len += 1;\n             } else {\n                 ranges.push(cur_len);\n@@ -550,24 +550,23 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n     pub fn mark_compressed_init_range(\n         &mut self,\n         defined: &InitMaskCompressed,\n-        dest: Pointer<Tag>,\n-        size: Size,\n+        range: AllocRange,\n         repeat: u64,\n     ) {\n         // An optimization where we can just overwrite an entire range of initialization\n         // bits if they are going to be uniformly `1` or `0`.\n         if defined.ranges.len() <= 1 {\n             self.init_mask.set_range_inbounds(\n-                dest.offset,\n-                dest.offset + size * repeat, // `Size` operations\n+                range.start,\n+                range.start + range.size * repeat, // `Size` operations\n                 defined.initial,\n             );\n             return;\n         }\n \n         for mut j in 0..repeat {\n-            j *= size.bytes();\n-            j += dest.offset.bytes();\n+            j *= range.size.bytes();\n+            j += range.start.bytes();\n             let mut cur = defined.initial;\n             for range in &defined.ranges {\n                 let old_j = j;"}, {"sha": "8cd459265dfc54fe2a1f81170068eddab5dfdbfc", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -18,8 +18,8 @@ use rustc_span::{Pos, Span};\n use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n \n use super::{\n-    Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, Operand, Place, PlaceTy,\n-    ScalarMaybeUninit, StackPopJump,\n+    Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, MemoryKind, Operand, Place,\n+    PlaceTy, ScalarMaybeUninit, StackPopJump,\n };\n use crate::transform::validate::equal_up_to_regions;\n use crate::util::storage::AlwaysLiveLocals;\n@@ -900,7 +900,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // due to the local having ZST type.\n             let ptr = ptr.assert_ptr();\n             trace!(\"deallocating local: {:?}\", self.memory.dump_alloc(ptr.alloc_id));\n-            self.memory.deallocate_local(ptr)?;\n+            self.memory.deallocate(ptr, None, MemoryKind::Stack)?;\n         };\n         Ok(())\n     }"}, {"sha": "5f719cc160706d09aa3fa9d1e0cee62a7ac00d46", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -276,17 +276,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(new_ptr)\n     }\n \n-    /// Deallocate a local, or do nothing if that local has been made into a global.\n-    pub fn deallocate_local(&mut self, ptr: Pointer<M::PointerTag>) -> InterpResult<'tcx> {\n-        // The allocation might be already removed by global interning.\n-        // This can only really happen in the CTFE instance, not in miri.\n-        if self.alloc_map.contains_key(&ptr.alloc_id) {\n-            self.deallocate(ptr, None, MemoryKind::Stack)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n     pub fn deallocate(\n         &mut self,\n         ptr: Pointer<M::PointerTag>,\n@@ -1049,7 +1038,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             num_copies,\n         );\n         // Prepare a copy of the initialization mask.\n-        let compressed = src_alloc.compress_uninit_range(src, size);\n+        let compressed = src_alloc.compress_uninit_range(alloc_range(src.offset, size));\n         // This checks relocation edges on the src.\n         let src_bytes = src_alloc\n             .get_bytes_with_uninit_and_ptr(&tcx, alloc_range(src.offset, size))\n@@ -1110,7 +1099,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n \n         // now fill in all the \"init\" data\n-        dest_alloc.mark_compressed_init_range(&compressed, dest, size, num_copies);\n+        dest_alloc.mark_compressed_init_range(\n+            &compressed,\n+            alloc_range(dest.offset, size),\n+            num_copies,\n+        );\n         // copy the relocations to the destination\n         dest_alloc.mark_relocation_range(relocations);\n "}, {"sha": "3859b22223c006bfc39d2d85282e0518efcbff74", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -490,17 +490,29 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // convert the dereferenced constant to a pattern that is the sub-pattern of the\n                 // deref pattern.\n                 _ => {\n-                    let old = self.behind_reference.replace(true);\n-                    // In case there are structural-match violations somewhere in this subpattern,\n-                    // we fall back to a const pattern. If we do not do this, we may end up with\n-                    // a !structural-match constant that is not of reference type, which makes it\n-                    // very hard to invoke `PartialEq::eq` on it as a fallback.\n-                    let val = match self.recur(tcx.deref_const(self.param_env.and(cv)), false) {\n-                        Ok(subpattern) => PatKind::Deref { subpattern },\n-                        Err(_) => PatKind::Constant { value: cv },\n-                    };\n-                    self.behind_reference.set(old);\n-                    val\n+                    if !pointee_ty.is_sized(tcx.at(span), param_env) {\n+                        // `tcx.deref_const()` below will ICE with an unsized type\n+                        // (except slices, which are handled in a separate arm above).\n+                        let msg = format!(\"cannot use unsized non-slice type `{}` in constant patterns\", pointee_ty);\n+                        if self.include_lint_checks {\n+                            tcx.sess.span_err(span, &msg);\n+                        } else {\n+                            tcx.sess.delay_span_bug(span, &msg);\n+                        }\n+                        PatKind::Wild\n+                    } else {\n+                        let old = self.behind_reference.replace(true);\n+                        // In case there are structural-match violations somewhere in this subpattern,\n+                        // we fall back to a const pattern. If we do not do this, we may end up with\n+                        // a !structural-match constant that is not of reference type, which makes it\n+                        // very hard to invoke `PartialEq::eq` on it as a fallback.\n+                        let val = match self.recur(tcx.deref_const(self.param_env.and(cv)), false) {\n+                            Ok(subpattern) => PatKind::Deref { subpattern },\n+                            Err(_) => PatKind::Constant { value: cv },\n+                        };\n+                        self.behind_reference.set(old);\n+                        val\n+                    }\n                 }\n             },\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::FnDef(..) => {"}, {"sha": "f3ce78d2d78f89042f146dd66cc99d449c04355a", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -20,8 +20,7 @@ use rustc_errors::annotate_snippet_emitter_writer::AnnotateSnippetEmitterWriter;\n use rustc_errors::emitter::{Emitter, EmitterWriter, HumanReadableErrorType};\n use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticId, ErrorReported};\n-use rustc_lint_defs::FutureBreakage;\n+use rustc_errors::{DiagnosticBuilder, DiagnosticId, ErrorReported};\n use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n use rustc_span::source_map::{FileLoader, MultiSpan, RealFileLoader, SourceMap, Span};\n@@ -317,23 +316,7 @@ impl Session {\n         if diags.is_empty() {\n             return;\n         }\n-        // If any future-breakage lints were registered, this lint store\n-        // should be available\n-        let lint_store = self.lint_store.get().expect(\"`lint_store` not initialized!\");\n-        let diags_and_breakage: Vec<(FutureBreakage, Diagnostic)> = diags\n-            .into_iter()\n-            .map(|diag| {\n-                let lint_name = match &diag.code {\n-                    Some(DiagnosticId::Lint { name, has_future_breakage: true, .. }) => name,\n-                    _ => panic!(\"Unexpected code in diagnostic {:?}\", diag),\n-                };\n-                let lint = lint_store.name_to_lint(&lint_name);\n-                let future_breakage =\n-                    lint.lint.future_incompatible.unwrap().future_breakage.unwrap();\n-                (future_breakage, diag)\n-            })\n-            .collect();\n-        self.parse_sess.span_diagnostic.emit_future_breakage_report(diags_and_breakage);\n+        self.parse_sess.span_diagnostic.emit_future_breakage_report(diags);\n     }\n \n     pub fn local_stable_crate_id(&self) -> StableCrateId {"}, {"sha": "5122421ea8c852fdef7afbbba7c3f58075f49a0f", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -79,7 +79,7 @@ use crate::ptr;\n /// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n /// let mut x = MaybeUninit::<&i32>::uninit();\n /// // Set it to a valid value.\n-/// unsafe { x.as_mut_ptr().write(&0); }\n+/// x.write(&0);\n /// // Extract the initialized data -- this is only allowed *after* properly\n /// // initializing `x`!\n /// let x = unsafe { x.assume_init() };\n@@ -135,7 +135,7 @@ use crate::ptr;\n ///     // this loop, we have a memory leak, but there is no memory safety\n ///     // issue.\n ///     for elem in &mut data[..] {\n-///         *elem = MaybeUninit::new(vec![42]);\n+///         elem.write(vec![42]);\n ///     }\n ///\n ///     // Everything is initialized. Transmute the array to the\n@@ -161,7 +161,7 @@ use crate::ptr;\n /// let mut data_len: usize = 0;\n ///\n /// for elem in &mut data[0..500] {\n-///     *elem = MaybeUninit::new(String::from(\"hello\"));\n+///     elem.write(String::from(\"hello\"));\n ///     data_len += 1;\n /// }\n ///\n@@ -410,7 +410,7 @@ impl<T> MaybeUninit<T> {\n     /// (now safely initialized) contents of `self`.\n     ///\n     /// As the content is stored inside a `MaybeUninit`, the destructor is not\n-    /// ran for the inner data if the MaybeUninit leaves scope without a call to\n+    /// run for the inner data if the MaybeUninit leaves scope without a call to\n     /// [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n     /// the mutable reference returned by this function needs to keep this in\n     /// mind. The safety model of Rust regards leaks as safe, but they are\n@@ -426,7 +426,6 @@ impl<T> MaybeUninit<T> {\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit_extra)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u8>>::uninit();\n@@ -445,7 +444,6 @@ impl<T> MaybeUninit<T> {\n     /// This usage of the method causes a leak:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit_extra)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<String>::uninit();\n@@ -456,8 +454,38 @@ impl<T> MaybeUninit<T> {\n     /// // x is initialized now:\n     /// let s = unsafe { x.assume_init() };\n     /// ```\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n-    #[rustc_const_unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n+    ///\n+    /// This method can be used to avoid unsafe in some cases. The example below\n+    /// shows a part of an implementation of a fixed sized arena that lends out\n+    /// pinned references.\n+    /// With `write`, we can avoid the need to write through a raw pointer:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use core::pin::Pin;\n+    /// use core::mem::MaybeUninit;\n+    ///\n+    /// struct PinArena<T> {\n+    ///     memory: Box<[MaybeUninit<T>]>,\n+    ///     len: usize,\n+    /// }\n+    ///\n+    /// impl <T> PinArena<T> {\n+    ///     pub fn capacity(&self) -> usize {\n+    ///         self.memory.len()\n+    ///     }\n+    ///     pub fn push(&mut self, val: T) -> Pin<&mut T> {\n+    ///         if self.len >= self.capacity() {\n+    ///             panic!(\"Attempted to push to a full pin arena!\");\n+    ///         }\n+    ///         let ref_ = self.memory[self.len].write(val);\n+    ///         self.len += 1;\n+    ///         unsafe { Pin::new_unchecked(ref_) }\n+    ///     }\n+    /// }\n+    /// ```\n+    #[stable(feature = \"maybe_uninit_write\", since = \"1.55.0\")]\n+    #[rustc_const_unstable(feature = \"const_maybe_uninit_write\", issue = \"63567\")]\n     #[inline(always)]\n     pub const fn write(&mut self, val: T) -> &mut T {\n         *self = MaybeUninit::new(val);\n@@ -478,7 +506,7 @@ impl<T> MaybeUninit<T> {\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(vec![0, 1, 2]); }\n+    /// x.write(vec![0, 1, 2]);\n     /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n     /// let x_vec = unsafe { &*x.as_ptr() };\n     /// assert_eq!(x_vec.len(), 3);\n@@ -515,7 +543,7 @@ impl<T> MaybeUninit<T> {\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(vec![0, 1, 2]); }\n+    /// x.write(vec![0, 1, 2]);\n     /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n     /// // This is okay because we initialized it.\n     /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n@@ -574,7 +602,7 @@ impl<T> MaybeUninit<T> {\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<bool>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(true); }\n+    /// x.write(true);\n     /// let x_init = unsafe { x.assume_init() };\n     /// assert_eq!(x_init, true);\n     /// ```\n@@ -723,7 +751,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n     /// // Initialize `x`:\n-    /// unsafe { x.as_mut_ptr().write(vec![1, 2, 3]); }\n+    /// x.write(vec![1, 2, 3]);\n     /// // Now that our `MaybeUninit<_>` is known to be initialized, it is okay to\n     /// // create a shared reference to it:\n     /// let x: &Vec<u32> = unsafe {\n@@ -897,9 +925,9 @@ impl<T> MaybeUninit<T> {\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut array: [MaybeUninit<i32>; 3] = MaybeUninit::uninit_array();\n-    /// array[0] = MaybeUninit::new(0);\n-    /// array[1] = MaybeUninit::new(1);\n-    /// array[2] = MaybeUninit::new(2);\n+    /// array[0].write(0);\n+    /// array[1].write(1);\n+    /// array[2].write(2);\n     ///\n     /// // SAFETY: Now safe as we initialised all elements\n     /// let array = unsafe {"}, {"sha": "ae0cea985d77c9b8314044d7eaad75e2e07581a1", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -209,32 +209,6 @@ impl<T> Cursor<T>\n where\n     T: AsRef<[u8]>,\n {\n-    /// Returns the remaining length.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(cursor_remaining)]\n-    /// use std::io::Cursor;\n-    ///\n-    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n-    ///\n-    /// assert_eq!(buff.remaining(), 5);\n-    ///\n-    /// buff.set_position(2);\n-    /// assert_eq!(buff.remaining(), 3);\n-    ///\n-    /// buff.set_position(4);\n-    /// assert_eq!(buff.remaining(), 1);\n-    ///\n-    /// buff.set_position(6);\n-    /// assert_eq!(buff.remaining(), 0);\n-    /// ```\n-    #[unstable(feature = \"cursor_remaining\", issue = \"86369\")]\n-    pub fn remaining(&self) -> u64 {\n-        (self.inner.as_ref().len() as u64).checked_sub(self.pos).unwrap_or(0)\n-    }\n-\n     /// Returns the remaining slice.\n     ///\n     /// # Examples"}, {"sha": "ad8975c03f17564228ef611170eeabe27d08095e", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -277,7 +277,7 @@ pub use self::error::{Error, ErrorKind, Result};\n pub use self::stdio::set_output_capture;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::stdio::{stderr, stdin, stdout, Stderr, Stdin, Stdout};\n-#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+#[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n pub use self::stdio::{stderr_locked, stdin_locked, stdout_locked};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::stdio::{StderrLock, StdinLock, StdoutLock};"}, {"sha": "206687e38fb9cfc402121d3c24c000124092102e", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -347,7 +347,7 @@ pub fn stdin() -> Stdin {\n ///     Ok(())\n /// }\n /// ```\n-#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+#[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n pub fn stdin_locked() -> StdinLock<'static> {\n     stdin().into_locked()\n }\n@@ -442,7 +442,7 @@ impl Stdin {\n     ///     Ok(())\n     /// }\n     /// ```\n-    #[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+    #[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n     pub fn into_locked(self) -> StdinLock<'static> {\n         self.lock_any()\n     }\n@@ -668,7 +668,7 @@ pub fn stdout() -> Stdout {\n ///     Ok(())\n /// }\n /// ```\n-#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+#[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n pub fn stdout_locked() -> StdoutLock<'static> {\n     stdout().into_locked()\n }\n@@ -745,7 +745,7 @@ impl Stdout {\n     ///     Ok(())\n     /// }\n     /// ```\n-    #[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+    #[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n     pub fn into_locked(self) -> StdoutLock<'static> {\n         self.lock_any()\n     }\n@@ -945,7 +945,7 @@ pub fn stderr() -> Stderr {\n ///     Ok(())\n /// }\n /// ```\n-#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+#[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n pub fn stderr_locked() -> StderrLock<'static> {\n     stderr().into_locked()\n }\n@@ -1005,7 +1005,7 @@ impl Stderr {\n     ///     Ok(())\n     /// }\n     /// ```\n-    #[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+    #[unstable(feature = \"stdio_locked\", issue = \"86845\")]\n     pub fn into_locked(self) -> StderrLock<'static> {\n         self.lock_any()\n     }"}, {"sha": "8a1b6df0dafe34910e2631733e8cb4642c7ddb65", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -139,11 +139,17 @@ macro_rules! install {\n \n install!((self, builder, _config),\n     Docs, \"src/doc\", _config.docs, only_hosts: false, {\n-        let tarball = builder.ensure(dist::Docs { host: self.target }).expect(\"missing docs\");\n-        install_sh(builder, \"docs\", self.compiler.stage, Some(self.target), &tarball);\n+        if let Some(tarball) = builder.ensure(dist::Docs { host: self.target }) {\n+            install_sh(builder, \"docs\", self.compiler.stage, Some(self.target), &tarball);\n+        } else {\n+            panic!(\"docs are not available to install, \\\n+                check that `build.docs` is true in `config.toml`\");\n+        }\n     };\n     Std, \"library/std\", true, only_hosts: false, {\n         for target in &builder.targets {\n+            // `expect` should be safe, only None when host != build, but this\n+            // only runs when host == build\n             let tarball = builder.ensure(dist::Std {\n                 compiler: self.compiler,\n                 target: *target\n@@ -165,10 +171,15 @@ install!((self, builder, _config),\n         }\n     };\n     RustAnalyzer, \"rust-analyzer\", Self::should_build(_config), only_hosts: true, {\n-        let tarball = builder\n-            .ensure(dist::RustAnalyzer { compiler: self.compiler, target: self.target })\n-            .expect(\"missing rust-analyzer\");\n-        install_sh(builder, \"rust-analyzer\", self.compiler.stage, Some(self.target), &tarball);\n+        if let Some(tarball) =\n+            builder.ensure(dist::RustAnalyzer { compiler: self.compiler, target: self.target })\n+        {\n+            install_sh(builder, \"rust-analyzer\", self.compiler.stage, Some(self.target), &tarball);\n+        } else {\n+            builder.info(\n+                &format!(\"skipping Install rust-analyzer stage{} ({})\", self.compiler.stage, self.target),\n+            );\n+        }\n     };\n     Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n         let tarball = builder.ensure(dist::Clippy { compiler: self.compiler, target: self.target });\n@@ -212,6 +223,8 @@ install!((self, builder, _config),\n         }\n     };\n     Analysis, \"analysis\", Self::should_build(_config), only_hosts: false, {\n+        // `expect` should be safe, only None with host != build, but this\n+        // only uses the `build` compiler\n         let tarball = builder.ensure(dist::Analysis {\n             // Find the actual compiler (handling the full bootstrap option) which\n             // produced the save-analysis data because that data isn't copied"}, {"sha": "61ffae47e2ad02a24bc1d2d8afade03f34e1509c", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -907,27 +907,25 @@ impl Step for RustdocGUI {\n         // We remove existing folder to be sure there won't be artifacts remaining.\n         let _ = fs::remove_dir_all(&out_dir);\n \n-        let mut nb_generated = 0;\n+        let src_path = \"src/test/rustdoc-gui/src\";\n         // We generate docs for the libraries present in the rustdoc-gui's src folder.\n-        let libs_dir = builder.build.src.join(\"src/test/rustdoc-gui/src\");\n-        for entry in libs_dir.read_dir().expect(\"read_dir call failed\") {\n-            let entry = entry.expect(\"invalid entry\");\n-            let path = entry.path();\n-            if path.extension().map(|e| e == \"rs\").unwrap_or(false) {\n-                let mut command = builder.rustdoc_cmd(self.compiler);\n-                command.arg(path).arg(\"-o\").arg(&out_dir);\n-                builder.run(&mut command);\n-                nb_generated += 1;\n-            }\n-        }\n-        assert!(nb_generated > 0, \"no documentation was generated...\");\n+        let mut cargo = Command::new(&builder.initial_cargo);\n+        cargo\n+            .arg(\"doc\")\n+            .arg(\"--workspace\")\n+            .arg(\"--target-dir\")\n+            .arg(&out_dir)\n+            .env(\"RUSTDOC\", builder.rustdoc(self.compiler))\n+            .env(\"RUSTC\", builder.rustc(self.compiler))\n+            .current_dir(&builder.build.src.join(src_path));\n+        builder.run(&mut cargo);\n \n         // We now run GUI tests.\n         let mut command = Command::new(&nodejs);\n         command\n             .arg(builder.build.src.join(\"src/tools/rustdoc-gui/tester.js\"))\n             .arg(\"--doc-folder\")\n-            .arg(out_dir)\n+            .arg(out_dir.join(\"doc\"))\n             .arg(\"--tests-folder\")\n             .arg(builder.build.src.join(\"src/test/rustdoc-gui\"));\n         for path in &builder.paths {"}, {"sha": "8f74a48547d8833c0f88a12e6ec8ac111cda1af4", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     visibility: Inherited,\n                     def_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n                     kind: box ImplItem(Impl {\n-                        span: self.cx.tcx.def_span(impl_def_id).clean(self.cx),\n+                        span: Span::from_rustc_span(self.cx.tcx.def_span(impl_def_id)),\n                         unsafety: hir::Unsafety::Normal,\n                         generics: (\n                             self.cx.tcx.generics_of(impl_def_id),"}, {"sha": "80aaae1580114752da8ebe3a610719c814ce5624", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -227,20 +227,6 @@ impl<'tcx> Clean<GenericBound> for ty::PolyTraitRef<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<Option<Vec<GenericBound>>> for InternalSubsts<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<Vec<GenericBound>> {\n-        let mut v = Vec::new();\n-        v.extend(self.regions().filter_map(|r| r.clean(cx)).map(GenericBound::Outlives));\n-        v.extend(self.types().map(|t| {\n-            GenericBound::TraitBound(\n-                PolyTrait { trait_: t.clean(cx), generic_params: Vec::new() },\n-                hir::TraitBoundModifier::None,\n-            )\n-        }));\n-        if !v.is_empty() { Some(v) } else { None }\n-    }\n-}\n-\n impl Clean<Lifetime> for hir::Lifetime {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Lifetime {\n         let def = cx.tcx.named_region(self.hir_id);\n@@ -296,12 +282,6 @@ impl Clean<Constant> for hir::ConstArg {\n     }\n }\n \n-impl Clean<Lifetime> for ty::GenericParamDef {\n-    fn clean(&self, _cx: &mut DocContext<'_>) -> Lifetime {\n-        Lifetime(self.name)\n-    }\n-}\n-\n impl Clean<Option<Lifetime>> for ty::RegionKind {\n     fn clean(&self, _cx: &mut DocContext<'_>) -> Option<Lifetime> {\n         match *self {\n@@ -1764,12 +1744,6 @@ impl Clean<Variant> for hir::VariantData<'_> {\n     }\n }\n \n-impl Clean<Span> for rustc_span::Span {\n-    fn clean(&self, _cx: &mut DocContext<'_>) -> Span {\n-        Span::from_rustc_span(*self)\n-    }\n-}\n-\n impl Clean<Path> for hir::Path<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n         Path {\n@@ -2193,22 +2167,3 @@ impl Clean<TypeBindingKind> for hir::TypeBindingKind<'_> {\n         }\n     }\n }\n-\n-enum SimpleBound {\n-    TraitBound(Vec<PathSegment>, Vec<SimpleBound>, Vec<GenericParamDef>, hir::TraitBoundModifier),\n-    Outlives(Lifetime),\n-}\n-\n-impl From<GenericBound> for SimpleBound {\n-    fn from(bound: GenericBound) -> Self {\n-        match bound.clone() {\n-            GenericBound::Outlives(l) => SimpleBound::Outlives(l),\n-            GenericBound::TraitBound(t, mod_) => match t.trait_ {\n-                Type::ResolvedPath { path, .. } => {\n-                    SimpleBound::TraitBound(path.segments, Vec::new(), t.generic_params, mod_)\n-                }\n-                _ => panic!(\"Unexpected bound {:?}\", bound),\n-            },\n-        }\n-    }\n-}"}, {"sha": "38ddbb3ad74278d68d2c9623fbdb46f7ca07b603", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -683,6 +683,9 @@ function hideThemeButtonState() {\n             });\n         }\n \n+        var currentNbImpls = implementors.getElementsByClassName(\"impl\").length;\n+        var traitName = document.querySelector(\"h1.fqn > .in-band > .trait\").textContent;\n+        var baseIdName = \"impl-\" + traitName + \"-\";\n         var libs = Object.getOwnPropertyNames(imp);\n         for (var i = 0, llength = libs.length; i < llength; ++i) {\n             if (libs[i] === window.currentCrate) { continue; }\n@@ -705,6 +708,7 @@ function hideThemeButtonState() {\n \n                 var code = document.createElement(\"code\");\n                 code.innerHTML = struct.text;\n+                addClass(code, \"in-band\");\n \n                 onEachLazy(code.getElementsByTagName(\"a\"), function(elem) {\n                     var href = elem.getAttribute(\"href\");\n@@ -714,12 +718,18 @@ function hideThemeButtonState() {\n                     }\n                 });\n \n-                var display = document.createElement(\"h3\");\n+                var currentId = baseIdName + currentNbImpls;\n+                var anchor = document.createElement(\"a\");\n+                anchor.href = \"#\" + currentId;\n+                addClass(anchor, \"anchor\");\n+\n+                var display = document.createElement(\"div\");\n+                display.id = currentId;\n                 addClass(display, \"impl\");\n-                display.innerHTML = \"<span class=\\\"in-band\\\"><table class=\\\"table-display\\\">\" +\n-                    \"<tbody><tr><td><code>\" + code.outerHTML + \"</code></td><td></td></tr>\" +\n-                    \"</tbody></table></span>\";\n+                display.appendChild(anchor);\n+                display.appendChild(code);\n                 list.appendChild(display);\n+                currentNbImpls += 1;\n             }\n         }\n     };"}, {"sha": "21bd3ebd21bc838d86cd89f2c6ef0d52fbc87a97", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -1610,6 +1610,8 @@ impl Disambiguator {\n             return Suggestion::Macro;\n         } else if kind == DefKind::Fn || kind == DefKind::AssocFn {\n             return Suggestion::Function;\n+        } else if kind == DefKind::Field {\n+            return Suggestion::RemoveDisambiguator;\n         }\n \n         let prefix = match kind {\n@@ -1674,6 +1676,8 @@ enum Suggestion {\n     Function,\n     /// `m!`\n     Macro,\n+    /// `foo` without any disambiguator\n+    RemoveDisambiguator,\n }\n \n impl Suggestion {\n@@ -1682,6 +1686,7 @@ impl Suggestion {\n             Self::Prefix(x) => format!(\"prefix with `{}@`\", x).into(),\n             Self::Function => \"add parentheses\".into(),\n             Self::Macro => \"add an exclamation mark\".into(),\n+            Self::RemoveDisambiguator => \"remove the disambiguator\".into(),\n         }\n     }\n \n@@ -1691,6 +1696,7 @@ impl Suggestion {\n             Self::Prefix(prefix) => format!(\"{}@{}\", prefix, path_str),\n             Self::Function => format!(\"{}()\", path_str),\n             Self::Macro => format!(\"{}!\", path_str),\n+            Self::RemoveDisambiguator => path_str.into(),\n         }\n     }\n }"}, {"sha": "a4db5cee7c76842ba5c7dd84a0a6a1fbdc8c314f", "filename": "src/test/rustdoc-gui/implementors.goml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fimplementors.goml", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fimplementors.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fimplementors.goml?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -0,0 +1,16 @@\n+// The goal of this test is to check that the external trait implementors, generated with JS,\n+// have the same display than the \"local\" ones.\n+goto: file://|DOC_PATH|/implementors/trait.Whatever.html\n+assert: \"#implementors-list\"\n+// There are supposed to be two implementors listed.\n+assert-count: (\"#implementors-list > .impl\", 2)\n+// Now we check that both implementors have an anchor, an ID and a similar DOM.\n+assert: (\"#implementors-list > .impl:nth-child(1) > a.anchor\")\n+assert-attribute: (\"#implementors-list > .impl:nth-child(1)\", {\"id\": \"impl-Whatever\"})\n+assert-attribute: (\"#implementors-list > .impl:nth-child(1) > a.anchor\", {\"href\": \"#impl-Whatever\"})\n+assert: \"#implementors-list > .impl:nth-child(1) > code.in-band\"\n+\n+assert: (\"#implementors-list > .impl:nth-child(2) > a.anchor\")\n+assert-attribute: (\"#implementors-list > .impl:nth-child(2)\", {\"id\": \"impl-Whatever-1\"})\n+assert-attribute: (\"#implementors-list > .impl:nth-child(2) > a.anchor\", {\"href\": \"#impl-Whatever-1\"})\n+assert: \"#implementors-list > .impl:nth-child(2) > code.in-band\""}, {"sha": "a72ccffc6ddf9ba7009535ee3e37d7f3c135a374", "filename": "src/test/rustdoc-gui/src/Cargo.lock", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2FCargo.lock?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -0,0 +1,18 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"implementors\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"lib2\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"implementors\",\n+]\n+\n+[[package]]\n+name = \"test_docs\"\n+version = \"0.1.0\""}, {"sha": "9c8c0c636f07fac38c91cf153cae9939dd75cfed", "filename": "src/test/rustdoc-gui/src/Cargo.toml", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2FCargo.toml?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -0,0 +1,6 @@\n+[workspace]\n+members = [\n+    \"test_docs\",\n+    \"lib2\",\n+    \"implementors\",\n+]"}, {"sha": "7ef1052c49fd2e0a360336cdb241a26a4bc8e7dc", "filename": "src/test/rustdoc-gui/src/implementors/Cargo.toml", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Fimplementors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Fimplementors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Fimplementors%2FCargo.toml?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -0,0 +1,7 @@\n+[package]\n+name = \"implementors\"\n+version = \"0.1.0\"\n+edition = \"2018\"\n+\n+[lib]\n+path = \"lib.rs\""}, {"sha": "4b2f6962e30c50498ea7bdd381c8bbc77bc6c389", "filename": "src/test/rustdoc-gui/src/implementors/lib.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Fimplementors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Fimplementors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Fimplementors%2Flib.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -0,0 +1,7 @@\n+pub trait Whatever {\n+    fn method() {}\n+}\n+\n+pub struct Struct;\n+\n+impl Whatever for Struct {}"}, {"sha": "6041a793f08dae9f952d45d2593edd69eb86563b", "filename": "src/test/rustdoc-gui/src/lib2/Cargo.toml", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2FCargo.toml?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -0,0 +1,10 @@\n+[package]\n+name = \"lib2\"\n+version = \"0.1.0\"\n+edition = \"2018\"\n+\n+[lib]\n+path = \"lib.rs\"\n+\n+[dependencies]\n+implementors = { path = \"../implementors\" }"}, {"sha": "72ef3cbd2026d7230862b5b99fa7d68edf9dd023", "filename": "src/test/rustdoc-gui/src/lib2/lib.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Flib.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -31,3 +31,5 @@ impl Trait for Foo {\n     type X = u32;\n     const Y: u32 = 0;\n }\n+\n+impl implementors::Whatever for Foo {}", "previous_filename": "src/test/rustdoc-gui/src/lib2.rs"}, {"sha": "31e1bb209f98ec5fc6b7cbea4c4766a555c87247", "filename": "src/test/rustdoc-gui/src/lib2/src/lib.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Fsrc%2Flib.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -0,0 +1,7 @@\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn it_works() {\n+        assert_eq!(2 + 2, 4);\n+    }\n+}"}, {"sha": "7f3c65746fcf800215abd36fb9f6c158c7b1b876", "filename": "src/test/rustdoc-gui/src/test_docs/Cargo.toml", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2FCargo.toml?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -0,0 +1,7 @@\n+[package]\n+name = \"test_docs\"\n+version = \"0.1.0\"\n+edition = \"2018\"\n+\n+[lib]\n+path = \"lib.rs\""}, {"sha": "3e753cb4de8b19937b255f74ae9b783c56b86d45", "filename": "src/test/rustdoc-gui/src/test_docs/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "previous_filename": "src/test/rustdoc-gui/src/lib.rs"}, {"sha": "c5d501e38daf548632cf445f1d9fa7707d4a144a", "filename": "src/test/rustdoc-ui/intra-doc/field-ice.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Ffield-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Ffield-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Ffield-ice.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -0,0 +1,11 @@\n+#![deny(rustdoc::broken_intra_doc_links)]\n+//~^NOTE the lint level is defined here\n+\n+/// [`Foo::bar`]\n+/// [`Foo::bar()`]\n+//~^ERROR incompatible link kind for `Foo::bar`\n+//~|HELP to link to the field, remove the disambiguator\n+//~|NOTE this link resolved to a field, which is not a function\n+pub struct Foo {\n+    pub bar: u8\n+}"}, {"sha": "ccb05b84a7282087c14becb1f206812c606d6fee", "filename": "src/test/rustdoc-ui/intra-doc/field-ice.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Ffield-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Ffield-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Ffield-ice.stderr?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -0,0 +1,15 @@\n+error: incompatible link kind for `Foo::bar`\n+  --> $DIR/field-ice.rs:5:6\n+   |\n+LL | /// [`Foo::bar()`]\n+   |      ^^^^^^^^^^^^ help: to link to the field, remove the disambiguator: ``Foo::bar``\n+   |\n+note: the lint level is defined here\n+  --> $DIR/field-ice.rs:1:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this link resolved to a field, which is not a function\n+\n+error: aborting due to previous error\n+"}, {"sha": "1f147439f8bc37e0853433fa932b5ddd59e168fb", "filename": "src/test/ui/consts/issue-87046.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Fui%2Fconsts%2Fissue-87046.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Fui%2Fconsts%2Fissue-87046.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-87046.rs?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -0,0 +1,34 @@\n+// Regression test for the ICE described in #87046.\n+\n+#![crate_type=\"lib\"]\n+#![allow(unreachable_patterns)]\n+#![feature(const_fn_union)]\n+\n+#[derive(PartialEq, Eq)]\n+#[repr(transparent)]\n+pub struct Username(str);\n+\n+pub const ROOT_USER: &Username = Username::from_str(\"root\");\n+\n+impl Username {\n+    pub const fn from_str(raw: &str) -> &Self {\n+        union Transmute<'a> {\n+            raw: &'a str,\n+            typed: &'a Username,\n+        }\n+\n+        unsafe { Transmute { raw }.typed }\n+    }\n+\n+    pub const fn as_str(&self) -> &str {\n+        &self.0\n+    }\n+\n+    pub fn is_root(&self) -> bool {\n+        match self {\n+            ROOT_USER => true,\n+            //~^ ERROR: cannot use unsized non-slice type `Username` in constant patterns\n+            _ => false,\n+        }\n+    }\n+}"}, {"sha": "5da7a9e2390007ab077636c8e70a45d340a502d6", "filename": "src/test/ui/consts/issue-87046.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Fui%2Fconsts%2Fissue-87046.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14c0c3e55d311dd47aad792ef316bd5dde778886/src%2Ftest%2Fui%2Fconsts%2Fissue-87046.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-87046.stderr?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -0,0 +1,8 @@\n+error: cannot use unsized non-slice type `Username` in constant patterns\n+  --> $DIR/issue-87046.rs:29:13\n+   |\n+LL |             ROOT_USER => true,\n+   |             ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "fe00358888a24c64878abc15f09b0e60e16db9d6", "filename": "src/tools/rust-analyzer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer?ref=14c0c3e55d311dd47aad792ef316bd5dde778886", "patch": "@@ -1 +1 @@\n-Subproject commit e5c1c8cf2fcfae3e15c8bcf5256e84cad3bd3436\n+Subproject commit fe00358888a24c64878abc15f09b0e60e16db9d6"}]}