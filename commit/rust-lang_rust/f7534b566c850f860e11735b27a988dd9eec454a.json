{"sha": "f7534b566c850f860e11735b27a988dd9eec454a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3NTM0YjU2NmM4NTBmODYwZTExNzM1YjI3YTk4OGRkOWVlYzQ1NGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-10T03:30:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-10T03:30:17Z"}, "message": "Auto merge of #81952 - JohnTitor:rollup-i28kgfb, r=JohnTitor\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #79849 (Clarify docs regarding sleep of zero duration)\n - #80438 (Add `Box::into_inner`.)\n - #81466 (Add suggest mut method for loop)\n - #81687 (Make Vec::split_at_spare_mut public)\n - #81904 (Bump stabilization version for const int methods)\n - #81909 ([compiler/rustc_typeck/src/check/expr.rs] Remove unnecessary refs in pattern matching)\n - #81910 (Use format string in bootstrap panic instead of a string directly)\n - #81913 (Rename HIR UnOp variants)\n - #81925 (Add long explanation for E0547)\n - #81926 (add suggestion to use the `async_recursion` crate)\n - #81951 (Update cargo)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b748ff49315edc163a163403d2586d52d8757e5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b748ff49315edc163a163403d2586d52d8757e5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7534b566c850f860e11735b27a988dd9eec454a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7534b566c850f860e11735b27a988dd9eec454a", "html_url": "https://github.com/rust-lang/rust/commit/f7534b566c850f860e11735b27a988dd9eec454a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7534b566c850f860e11735b27a988dd9eec454a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca98712ff92c56506442cd5a500547f2f0cba0c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca98712ff92c56506442cd5a500547f2f0cba0c3", "html_url": "https://github.com/rust-lang/rust/commit/ca98712ff92c56506442cd5a500547f2f0cba0c3"}, {"sha": "77114af9ca55447c44b0915d33faa7bcf236dbc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/77114af9ca55447c44b0915d33faa7bcf236dbc3", "html_url": "https://github.com/rust-lang/rust/commit/77114af9ca55447c44b0915d33faa7bcf236dbc3"}], "stats": {"total": 547, "additions": 387, "deletions": 160}, "files": [{"sha": "b118c0eaed4f3245dc04edb2322a72fff27edf4c", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -260,9 +260,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_unop(&mut self, u: UnOp) -> hir::UnOp {\n         match u {\n-            UnOp::Deref => hir::UnOp::UnDeref,\n-            UnOp::Not => hir::UnOp::UnNot,\n-            UnOp::Neg => hir::UnOp::UnNeg,\n+            UnOp::Deref => hir::UnOp::Deref,\n+            UnOp::Not => hir::UnOp::Not,\n+            UnOp::Neg => hir::UnOp::Neg,\n         }\n     }\n "}, {"sha": "d01c162b0c864cca85e13979847cf740cc404376", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -287,6 +287,7 @@ E0539: include_str!(\"./error_codes/E0539.md\"),\n E0541: include_str!(\"./error_codes/E0541.md\"),\n E0542: include_str!(\"./error_codes/E0542.md\"),\n E0546: include_str!(\"./error_codes/E0546.md\"),\n+E0547: include_str!(\"./error_codes/E0547.md\"),\n E0550: include_str!(\"./error_codes/E0550.md\"),\n E0551: include_str!(\"./error_codes/E0551.md\"),\n E0552: include_str!(\"./error_codes/E0552.md\"),\n@@ -606,7 +607,6 @@ E0781: include_str!(\"./error_codes/E0781.md\"),\n     E0543, // missing 'reason'\n     E0544, // multiple stability levels\n     E0545, // incorrect 'issue'\n-    E0547, // missing 'issue'\n //  E0548, // replaced with a generic attribute input check\n     // rustc_deprecated attribute must be paired with either stable or unstable\n     // attribute"}, {"sha": "1aa4b354248842e5dbf408fb6cefb563d97f27c2", "filename": "compiler/rustc_error_codes/src/error_codes/E0547.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0547.md", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0547.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0547.md?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -0,0 +1,37 @@\n+The `issue` value is missing in a stability attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0547\n+#![feature(staged_api)]\n+#![stable(since = \"1.0.0\", feature = \"test\")]\n+\n+#[unstable(feature = \"_unstable_fn\")] // invalid\n+fn _unstable_fn() {}\n+\n+#[rustc_const_unstable(feature = \"_unstable_const_fn\")] // invalid\n+fn _unstable_const_fn() {}\n+```\n+\n+To fix this issue, you need to provide the `issue` field. Example:\n+\n+```\n+#![feature(staged_api)]\n+#![stable(since = \"1.0.0\", feature = \"test\")]\n+\n+#[unstable(feature = \"_unstable_fn\", issue = \"none\")] // ok!\n+fn _unstable_fn() {}\n+\n+#[rustc_const_unstable(\n+    feature = \"_unstable_const_fn\",\n+    issue = \"none\"\n+)] // ok!\n+fn _unstable_const_fn() {}\n+```\n+\n+See the [How Rust is Made and \u201cNightly Rust\u201d][how-rust-made-nightly] appendix\n+of the Book and the [Stability attributes][stability-attributes] section of the\n+Rustc Dev Guide for more details.\n+\n+[how-rust-made-nightly]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\n+[stability-attributes]: https://rustc-dev-guide.rust-lang.org/stability.html"}, {"sha": "9609510d0af6ba2baf28ee2a342fed1cffff0e36", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -1112,25 +1112,25 @@ pub type BinOp = Spanned<BinOpKind>;\n #[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum UnOp {\n     /// The `*` operator (deferencing).\n-    UnDeref,\n+    Deref,\n     /// The `!` operator (logical negation).\n-    UnNot,\n+    Not,\n     /// The `-` operator (negation).\n-    UnNeg,\n+    Neg,\n }\n \n impl UnOp {\n     pub fn as_str(self) -> &'static str {\n         match self {\n-            Self::UnDeref => \"*\",\n-            Self::UnNot => \"!\",\n-            Self::UnNeg => \"-\",\n+            Self::Deref => \"*\",\n+            Self::Not => \"!\",\n+            Self::Neg => \"-\",\n         }\n     }\n \n     /// Returns `true` if the unary operator takes its argument by value.\n     pub fn is_by_value(self) -> bool {\n-        matches!(self, Self::UnNeg | Self::UnNot)\n+        matches!(self, Self::Neg | Self::Not)\n     }\n }\n \n@@ -1477,7 +1477,7 @@ impl Expr<'_> {\n             // https://github.com/rust-lang/rfcs/blob/master/text/0803-type-ascription.md#type-ascription-and-temporaries\n             ExprKind::Type(ref e, _) => e.is_place_expr(allow_projections_from),\n \n-            ExprKind::Unary(UnOp::UnDeref, _) => true,\n+            ExprKind::Unary(UnOp::Deref, _) => true,\n \n             ExprKind::Field(ref base, _) | ExprKind::Index(ref base, _) => {\n                 allow_projections_from(base) || base.is_place_expr(allow_projections_from)"}, {"sha": "784b36c2837b701537318e39b0c4ae47ac208a1f", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -472,7 +472,7 @@ fn lint_literal<'tcx>(\n impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx hir::Expr<'tcx>) {\n         match e.kind {\n-            hir::ExprKind::Unary(hir::UnOp::UnNeg, ref expr) => {\n+            hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n                 if self.negated_expr_id != Some(e.hir_id) {\n                     self.negated_expr_id = Some(expr.hir_id);"}, {"sha": "ed953b981130a3de0e841dd243915fb08a87969a", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -55,7 +55,7 @@ impl<'tcx> Const<'tcx> {\n \n         let lit_input = match expr.kind {\n             hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n-            hir::ExprKind::Unary(hir::UnOp::UnNeg, ref expr) => match expr.kind {\n+            hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => match expr.kind {\n                 hir::ExprKind::Lit(ref lit) => {\n                     Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n                 }"}, {"sha": "0467bf76afecc5251daaef68715de379e3a564a4", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 85, "deletions": 9, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -376,15 +376,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     opt_assignment_rhs_span.and_then(|span| span.desugaring_kind());\n                                 match opt_desugaring_kind {\n                                     // on for loops, RHS points to the iterator part\n-                                    Some(DesugaringKind::ForLoop(_)) => Some((\n-                                        false,\n-                                        opt_assignment_rhs_span.unwrap(),\n-                                        format!(\n-                                            \"this iterator yields `{SIGIL}` {DESC}s\",\n-                                            SIGIL = pointer_sigil,\n-                                            DESC = pointer_desc\n-                                        ),\n-                                    )),\n+                                    Some(DesugaringKind::ForLoop(_)) => {\n+                                        self.suggest_similar_mut_method_for_for_loop(&mut err);\n+                                        Some((\n+                                            false,\n+                                            opt_assignment_rhs_span.unwrap(),\n+                                            format!(\n+                                                \"this iterator yields `{SIGIL}` {DESC}s\",\n+                                                SIGIL = pointer_sigil,\n+                                                DESC = pointer_desc\n+                                            ),\n+                                        ))\n+                                    }\n                                     // don't create labels for compiler-generated spans\n                                     Some(_) => None,\n                                     None => {\n@@ -537,6 +540,79 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         );\n     }\n \n+    // Attempt to search similar mutable assosiated items for suggestion.\n+    // In the future, attempt in all path but initially for RHS of for_loop\n+    fn suggest_similar_mut_method_for_for_loop(&self, err: &mut DiagnosticBuilder<'_>) {\n+        let hir = self.infcx.tcx.hir();\n+        let node = hir.item(self.mir_hir_id());\n+        use hir::{\n+            Expr,\n+            ExprKind::{Block, Call, DropTemps, Match, MethodCall},\n+        };\n+        if let hir::ItemKind::Fn(_, _, body_id) = node.kind {\n+            if let Block(\n+                hir::Block {\n+                    expr:\n+                        Some(Expr {\n+                            kind:\n+                                DropTemps(Expr {\n+                                    kind:\n+                                        Match(\n+                                            Expr {\n+                                                kind:\n+                                                    Call(\n+                                                        _,\n+                                                        [Expr {\n+                                                            kind: MethodCall(path_segment, ..),\n+                                                            hir_id,\n+                                                            ..\n+                                                        }, ..],\n+                                                    ),\n+                                                ..\n+                                            },\n+                                            ..,\n+                                        ),\n+                                    ..\n+                                }),\n+                            ..\n+                        }),\n+                    ..\n+                },\n+                _,\n+            ) = hir.body(body_id).value.kind\n+            {\n+                let opt_suggestions = path_segment\n+                    .hir_id\n+                    .map(|path_hir_id| self.infcx.tcx.typeck(path_hir_id.owner))\n+                    .and_then(|typeck| typeck.type_dependent_def_id(*hir_id))\n+                    .and_then(|def_id| self.infcx.tcx.impl_of_method(def_id))\n+                    .map(|def_id| self.infcx.tcx.associated_items(def_id))\n+                    .map(|assoc_items| {\n+                        assoc_items\n+                            .in_definition_order()\n+                            .map(|assoc_item_def| assoc_item_def.ident)\n+                            .filter(|&ident| {\n+                                let original_method_ident = path_segment.ident;\n+                                original_method_ident != ident\n+                                    && ident\n+                                        .as_str()\n+                                        .starts_with(&original_method_ident.name.to_string())\n+                            })\n+                            .map(|ident| format!(\"{}()\", ident))\n+                    });\n+\n+                if let Some(suggestions) = opt_suggestions {\n+                    err.span_suggestions(\n+                        path_segment.ident.span,\n+                        &format!(\"use mutable method\"),\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        };\n+    }\n+\n     /// Targeted error when encountering an `FnMut` closure where an `Fn` closure was expected.\n     fn expected_fn_found_fn_mut_call(&self, err: &mut DiagnosticBuilder<'_>, sp: Span, act: &str) {\n         err.span_label(sp, format!(\"cannot {}\", act));"}, {"sha": "620ce360e7d9122d8a64bc08257f8b0ad12952f2", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -299,23 +299,23 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             }\n         }\n \n-        hir::ExprKind::Unary(hir::UnOp::UnDeref, ref arg) => {\n+        hir::ExprKind::Unary(hir::UnOp::Deref, ref arg) => {\n             if cx.typeck_results().is_method_call(expr) {\n                 overloaded_place(cx, expr, expr_ty, None, vec![arg.to_ref()], expr.span)\n             } else {\n                 ExprKind::Deref { arg: arg.to_ref() }\n             }\n         }\n \n-        hir::ExprKind::Unary(hir::UnOp::UnNot, ref arg) => {\n+        hir::ExprKind::Unary(hir::UnOp::Not, ref arg) => {\n             if cx.typeck_results().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n                 ExprKind::Unary { op: UnOp::Not, arg: arg.to_ref() }\n             }\n         }\n \n-        hir::ExprKind::Unary(hir::UnOp::UnNeg, ref arg) => {\n+        hir::ExprKind::Unary(hir::UnOp::Neg, ref arg) => {\n             if cx.typeck_results().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else if let hir::ExprKind::Lit(ref lit) = arg.kind {"}, {"sha": "6e29e60b3034dfdd971b45a59559129c5c453846", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -866,7 +866,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                     return *self.const_to_pat(value, expr.hir_id, expr.span, false).kind;\n                 }\n                 hir::ExprKind::Lit(ref lit) => (lit, false),\n-                hir::ExprKind::Unary(hir::UnOp::UnNeg, ref expr) => {\n+                hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => {\n                     let lit = match expr.kind {\n                         hir::ExprKind::Lit(ref lit) => lit,\n                         _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),"}, {"sha": "b532021bed2e9ad03b978c222355bbcab0b46319", "filename": "compiler/rustc_passes/src/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fregion.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -664,7 +664,7 @@ fn resolve_local<'tcx>(\n \n             match expr.kind {\n                 hir::ExprKind::AddrOf(_, _, ref subexpr)\n-                | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref subexpr)\n+                | hir::ExprKind::Unary(hir::UnOp::Deref, ref subexpr)\n                 | hir::ExprKind::Field(ref subexpr, _)\n                 | hir::ExprKind::Index(ref subexpr, _) => {\n                     expr = &subexpr;"}, {"sha": "114fe969edd8d03de082afa910483a6c1f93a73f", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -1505,6 +1505,9 @@ fn async_opaque_type_cycle_error(tcx: TyCtxt<'tcx>, span: Span) {\n     struct_span_err!(tcx.sess, span, E0733, \"recursion in an `async fn` requires boxing\")\n         .span_label(span, \"recursive `async fn`\")\n         .note(\"a recursive `async fn` must be rewritten to return a boxed `dyn Future`\")\n+        .note(\n+            \"consider using the `async_recursion` crate: https://crates.io/crates/async_recursion\",\n+        )\n         .emit();\n }\n "}, {"sha": "8d2004a543b7b1b151f6a088a370f6b010aa32d5", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -773,7 +773,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let hir::ExprKind::Lit(lit) = &expr.kind { lit.node.is_suffixed() } else { false }\n         };\n         let is_negative_int =\n-            |expr: &hir::Expr<'_>| matches!(expr.kind, hir::ExprKind::Unary(hir::UnOp::UnNeg, ..));\n+            |expr: &hir::Expr<'_>| matches!(expr.kind, hir::ExprKind::Unary(hir::UnOp::Neg, ..));\n         let is_uint = |ty: Ty<'_>| matches!(ty.kind(), ty::Uint(..));\n \n         let in_const_context = self.tcx.hir().is_inside_const_context(expr.hir_id);"}, {"sha": "fa09c26c800aea39927eb5e682ee6b833e554ac1", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // without the final expr (e.g. `try { return; }`). We don't want to generate an\n         // unreachable_code lint for it since warnings for autogenerated code are confusing.\n         let is_try_block_generated_unit_expr = match expr.kind {\n-            ExprKind::Call(_, ref args) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {\n+            ExprKind::Call(_, args) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {\n                 args.len() == 1 && args[0].span.is_desugaring(DesugaringKind::TryBlock)\n             }\n \n@@ -193,9 +193,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // diverging expression (e.g. it arose from desugaring of `try { return }`),\n             // we skip issuing a warning because it is autogenerated code.\n             ExprKind::Call(..) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {}\n-            ExprKind::Call(ref callee, _) => {\n-                self.warn_if_unreachable(expr.hir_id, callee.span, \"call\")\n-            }\n+            ExprKind::Call(callee, _) => self.warn_if_unreachable(expr.hir_id, callee.span, \"call\"),\n             ExprKind::MethodCall(_, ref span, _, _) => {\n                 self.warn_if_unreachable(expr.hir_id, *span, \"call\")\n             }\n@@ -231,23 +229,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let tcx = self.tcx;\n         match expr.kind {\n-            ExprKind::Box(ref subexpr) => self.check_expr_box(subexpr, expected),\n+            ExprKind::Box(subexpr) => self.check_expr_box(subexpr, expected),\n             ExprKind::Lit(ref lit) => self.check_lit(&lit, expected),\n-            ExprKind::Binary(op, ref lhs, ref rhs) => self.check_binop(expr, op, lhs, rhs),\n-            ExprKind::Assign(ref lhs, ref rhs, ref span) => {\n+            ExprKind::Binary(op, lhs, rhs) => self.check_binop(expr, op, lhs, rhs),\n+            ExprKind::Assign(lhs, rhs, ref span) => {\n                 self.check_expr_assign(expr, expected, lhs, rhs, span)\n             }\n-            ExprKind::AssignOp(op, ref lhs, ref rhs) => self.check_binop_assign(expr, op, lhs, rhs),\n-            ExprKind::Unary(unop, ref oprnd) => self.check_expr_unary(unop, oprnd, expected, expr),\n-            ExprKind::AddrOf(kind, mutbl, ref oprnd) => {\n+            ExprKind::AssignOp(op, lhs, rhs) => self.check_binop_assign(expr, op, lhs, rhs),\n+            ExprKind::Unary(unop, oprnd) => self.check_expr_unary(unop, oprnd, expected, expr),\n+            ExprKind::AddrOf(kind, mutbl, oprnd) => {\n                 self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n             }\n             ExprKind::Path(QPath::LangItem(lang_item, _)) => {\n                 self.check_lang_item_path(lang_item, expr)\n             }\n             ExprKind::Path(ref qpath) => self.check_expr_path(qpath, expr),\n             ExprKind::InlineAsm(asm) => self.check_expr_asm(asm),\n-            ExprKind::LlvmInlineAsm(ref asm) => {\n+            ExprKind::LlvmInlineAsm(asm) => {\n                 for expr in asm.outputs_exprs.iter().chain(asm.inputs_exprs.iter()) {\n                     self.check_expr(expr);\n                 }\n@@ -265,42 +263,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => self.check_expr_return(expr_opt.as_deref(), expr),\n-            ExprKind::Loop(ref body, _, source, _) => {\n+            ExprKind::Loop(body, _, source, _) => {\n                 self.check_expr_loop(body, source, expected, expr)\n             }\n-            ExprKind::Match(ref discrim, ref arms, match_src) => {\n+            ExprKind::Match(discrim, arms, match_src) => {\n                 self.check_match(expr, &discrim, arms, expected, match_src)\n             }\n-            ExprKind::Closure(capture, ref decl, body_id, _, gen) => {\n+            ExprKind::Closure(capture, decl, body_id, _, gen) => {\n                 self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n             }\n-            ExprKind::Block(ref body, _) => self.check_block_with_expected(&body, expected),\n-            ExprKind::Call(ref callee, ref args) => self.check_call(expr, &callee, args, expected),\n-            ExprKind::MethodCall(ref segment, span, ref args, _) => {\n+            ExprKind::Block(body, _) => self.check_block_with_expected(&body, expected),\n+            ExprKind::Call(callee, args) => self.check_call(expr, &callee, args, expected),\n+            ExprKind::MethodCall(segment, span, args, _) => {\n                 self.check_method_call(expr, segment, span, args, expected)\n             }\n-            ExprKind::Cast(ref e, ref t) => self.check_expr_cast(e, t, expr),\n-            ExprKind::Type(ref e, ref t) => {\n+            ExprKind::Cast(e, t) => self.check_expr_cast(e, t, expr),\n+            ExprKind::Type(e, t) => {\n                 let ty = self.to_ty_saving_user_provided_ty(&t);\n                 self.check_expr_eq_type(&e, ty);\n                 ty\n             }\n             ExprKind::If(cond, then_expr, opt_else_expr) => {\n                 self.check_then_else(cond, then_expr, opt_else_expr, expr.span, expected)\n             }\n-            ExprKind::DropTemps(ref e) => self.check_expr_with_expectation(e, expected),\n-            ExprKind::Array(ref args) => self.check_expr_array(args, expected, expr),\n+            ExprKind::DropTemps(e) => self.check_expr_with_expectation(e, expected),\n+            ExprKind::Array(args) => self.check_expr_array(args, expected, expr),\n             ExprKind::ConstBlock(ref anon_const) => self.to_const(anon_const).ty,\n-            ExprKind::Repeat(ref element, ref count) => {\n+            ExprKind::Repeat(element, ref count) => {\n                 self.check_expr_repeat(element, count, expected, expr)\n             }\n-            ExprKind::Tup(ref elts) => self.check_expr_tuple(elts, expected, expr),\n-            ExprKind::Struct(ref qpath, fields, ref base_expr) => {\n+            ExprKind::Tup(elts) => self.check_expr_tuple(elts, expected, expr),\n+            ExprKind::Struct(qpath, fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            ExprKind::Field(ref base, field) => self.check_field(expr, &base, field),\n-            ExprKind::Index(ref base, ref idx) => self.check_expr_index(base, idx, expr),\n-            ExprKind::Yield(ref value, ref src) => self.check_expr_yield(value, expr, src),\n+            ExprKind::Field(base, field) => self.check_field(expr, &base, field),\n+            ExprKind::Index(base, idx) => self.check_expr_index(base, idx, expr),\n+            ExprKind::Yield(value, ref src) => self.check_expr_yield(value, expr, src),\n             hir::ExprKind::Err => tcx.ty_error(),\n         }\n     }\n@@ -323,15 +321,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected_inner = match unop {\n-            hir::UnOp::UnNot | hir::UnOp::UnNeg => expected,\n-            hir::UnOp::UnDeref => NoExpectation,\n+            hir::UnOp::Not | hir::UnOp::Neg => expected,\n+            hir::UnOp::Deref => NoExpectation,\n         };\n         let mut oprnd_t = self.check_expr_with_expectation(&oprnd, expected_inner);\n \n         if !oprnd_t.references_error() {\n             oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n             match unop {\n-                hir::UnOp::UnDeref => {\n+                hir::UnOp::Deref => {\n                     if let Some(ty) = self.lookup_derefing(expr, oprnd, oprnd_t) {\n                         oprnd_t = ty;\n                     } else {\n@@ -353,14 +351,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         oprnd_t = tcx.ty_error();\n                     }\n                 }\n-                hir::UnOp::UnNot => {\n+                hir::UnOp::Not => {\n                     let result = self.check_user_unop(expr, oprnd_t, unop);\n                     // If it's builtin, we can reuse the type, this helps inference.\n                     if !(oprnd_t.is_integral() || *oprnd_t.kind() == ty::Bool) {\n                         oprnd_t = result;\n                     }\n                 }\n-                hir::UnOp::UnNeg => {\n+                hir::UnOp::Neg => {\n                     let result = self.check_user_unop(expr, oprnd_t, unop);\n                     // If it's builtin, we can reuse the type, this helps inference.\n                     if !oprnd_t.is_numeric() {\n@@ -541,7 +539,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         if let Ok(target_id) = destination.target_id {\n             let (e_ty, cause);\n-            if let Some(ref e) = expr_opt {\n+            if let Some(e) = expr_opt {\n                 // If this is a break with a value, we need to type-check\n                 // the expression. Get an expected type from the loop context.\n                 let opt_coerce_to = {\n@@ -650,12 +648,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // We still need to assign a type to the inner expression to\n             // prevent the ICE in #43162.\n-            if let Some(ref e) = expr_opt {\n+            if let Some(e) = expr_opt {\n                 self.check_expr_with_hint(e, err);\n \n                 // ... except when we try to 'break rust;'.\n                 // ICE this expression in particular (see #43162).\n-                if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.kind {\n+                if let ExprKind::Path(QPath::Resolved(_, path)) = e.kind {\n                     if path.segments.len() == 1 && path.segments[0].ident.name == sym::rust {\n                         fatally_break_rust(self.tcx.sess);\n                     }\n@@ -674,7 +672,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         if self.ret_coercion.is_none() {\n             self.tcx.sess.emit_err(ReturnStmtOutsideOfFnBody { span: expr.span });\n-        } else if let Some(ref e) = expr_opt {\n+        } else if let Some(e) = expr_opt {\n             if self.ret_coercion_span.get().is_none() {\n                 self.ret_coercion_span.set(Some(e.span));\n             }\n@@ -1133,13 +1131,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let flds = expected.only_has_type(self).and_then(|ty| {\n             let ty = self.resolve_vars_with_obligations(ty);\n             match ty.kind() {\n-                ty::Tuple(ref flds) => Some(&flds[..]),\n+                ty::Tuple(flds) => Some(&flds[..]),\n                 _ => None,\n             }\n         });\n \n         let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| match flds {\n-            Some(ref fs) if i < fs.len() => {\n+            Some(fs) if i < fs.len() => {\n                 let ety = fs[i].expect_ty();\n                 self.check_expr_coercable_to_type(&e, ety, None);\n                 ety\n@@ -1328,7 +1326,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         for field in fields {\n             self.check_expr(&field.expr);\n         }\n-        if let Some(ref base) = *base_expr {\n+        if let Some(base) = *base_expr {\n             self.check_expr(&base);\n         }\n     }\n@@ -1488,7 +1486,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n             _ => {\n                 // prevent all specified fields from being suggested\n-                let skip_fields = skip_fields.iter().map(|ref x| x.ident.name);\n+                let skip_fields = skip_fields.iter().map(|x| x.ident.name);\n                 if let Some(field_name) =\n                     Self::suggest_field_name(variant, field.ident.name, skip_fields.collect())\n                 {\n@@ -1617,7 +1615,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         private_candidate = Some((base_def.did, field_ty));\n                     }\n                 }\n-                ty::Tuple(ref tys) => {\n+                ty::Tuple(tys) => {\n                     let fstr = field.as_str();\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {"}, {"sha": "567cb1a90d0d9d9ee8d216449f866adf685f355e", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -681,7 +681,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         format!(\"cannot apply unary operator `{}`\", op.as_str()),\n                     );\n                     match actual.kind() {\n-                        Uint(_) if op == hir::UnOp::UnNeg => {\n+                        Uint(_) if op == hir::UnOp::Neg => {\n                             err.note(\"unsigned values cannot be negated\");\n \n                             if let hir::ExprKind::Unary(\n@@ -711,9 +711,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Ref(_, ref lty, _) if *lty.kind() == Str => {}\n                         _ => {\n                             let missing_trait = match op {\n-                                hir::UnOp::UnNeg => \"std::ops::Neg\",\n-                                hir::UnOp::UnNot => \"std::ops::Not\",\n-                                hir::UnOp::UnDeref => \"std::ops::UnDerf\",\n+                                hir::UnOp::Neg => \"std::ops::Neg\",\n+                                hir::UnOp::Not => \"std::ops::Not\",\n+                                hir::UnOp::Deref => \"std::ops::UnDerf\",\n                             };\n                             suggest_impl_missing(&mut err, operand_ty, &missing_trait);\n                         }\n@@ -782,9 +782,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     span_bug!(span, \"&& and || are not overloadable\")\n                 }\n             }\n-        } else if let Op::Unary(hir::UnOp::UnNot, _) = op {\n+        } else if let Op::Unary(hir::UnOp::Not, _) = op {\n             (sym::not, lang.not_trait())\n-        } else if let Op::Unary(hir::UnOp::UnNeg, _) = op {\n+        } else if let Op::Unary(hir::UnOp::Neg, _) = op {\n             (sym::neg, lang.neg_trait())\n         } else {\n             bug!(\"lookup_op_method: op not supported: {:?}\", op)"}, {"sha": "254e41706f90b72c01e2b7e97a2be86d2e55e057", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -203,7 +203,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         while let hir::ExprKind::Field(ref expr, _)\n         | hir::ExprKind::Index(ref expr, _)\n-        | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) = exprs.last().unwrap().kind\n+        | hir::ExprKind::Unary(hir::UnOp::Deref, ref expr) = exprs.last().unwrap().kind\n         {\n             exprs.push(&expr);\n         }\n@@ -216,7 +216,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n \n             let mut source = self.node_ty(expr.hir_id);\n-            if matches!(expr.kind, hir::ExprKind::Unary(hir::UnOp::UnDeref, _)) {\n+            if matches!(expr.kind, hir::ExprKind::Unary(hir::UnOp::Deref, _)) {\n                 // Clear previous flag; after a pointer indirection it does not apply any more.\n                 inside_union = false;\n             }\n@@ -270,7 +270,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::ExprKind::Index(ref base_expr, ..) => {\n                     self.convert_place_op_to_mutable(PlaceOp::Index, expr, base_expr);\n                 }\n-                hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base_expr) => {\n+                hir::ExprKind::Unary(hir::UnOp::Deref, ref base_expr) => {\n                     self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr);\n                 }\n                 _ => {}"}, {"sha": "4f785982150779e0ecc12862f3ed75a665b90066", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -138,7 +138,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // operating on scalars, we clear the overload.\n     fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr<'_>) {\n         match e.kind {\n-            hir::ExprKind::Unary(hir::UnOp::UnNeg | hir::UnOp::UnNot, ref inner) => {\n+            hir::ExprKind::Unary(hir::UnOp::Neg | hir::UnOp::Not, ref inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n                 let inner_ty = self.fcx.resolve_vars_if_possible(inner_ty);\n "}, {"sha": "52110af47929e4edfc5cd18f6c48f412bcc4bb67", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -184,7 +184,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n             hir::ExprKind::Type(ref subexpr, _) => self.walk_expr(subexpr),\n \n-            hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base) => {\n+            hir::ExprKind::Unary(hir::UnOp::Deref, ref base) => {\n                 // *base\n                 self.select_from_expr(base);\n             }"}, {"sha": "14af11097cf8b8dc05fa3abc8c65b1ad88afa893", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -303,7 +303,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n         let expr_ty = self.expr_ty(expr)?;\n         match expr.kind {\n-            hir::ExprKind::Unary(hir::UnOp::UnDeref, ref e_base) => {\n+            hir::ExprKind::Unary(hir::UnOp::Deref, ref e_base) => {\n                 if self.typeck_results.is_method_call(expr) {\n                     self.cat_overloaded_place(expr, e_base)\n                 } else {"}, {"sha": "354efdefc2103166f7169f8e4699ddd26c2c83a2", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -509,6 +509,23 @@ impl<T, A: Allocator> Box<T, A> {\n         let (raw, alloc) = Box::into_raw_with_allocator(boxed);\n         unsafe { Box::from_raw_in(raw as *mut [T; 1], alloc) }\n     }\n+\n+    /// Consumes the `Box`, returning the wrapped value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(box_into_inner)]\n+    ///\n+    /// let c = Box::new(5);\n+    ///\n+    /// assert_eq!(Box::into_inner(c), 5);\n+    /// ```\n+    #[unstable(feature = \"box_into_inner\", issue = \"80437\")]\n+    #[inline]\n+    pub fn into_inner(boxed: Self) -> T {\n+        *boxed\n+    }\n }\n \n impl<T> Box<[T]> {"}, {"sha": "c7b4c98041b2e658e4f1969cfe407420880f66f6", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -1828,8 +1828,60 @@ impl<T, A: Allocator> Vec<T, A> {\n         self.split_at_spare_mut().1\n     }\n \n+    /// Returns vector content as a slice of `T`, along with the remaining spare\n+    /// capacity of the vector as a slice of `MaybeUninit<T>`.\n+    ///\n+    /// The returned spare capacity slice can be used to fill the vector with data\n+    /// (e.g. by reading from a file) before marking the data as initialized using\n+    /// the [`set_len`] method.\n+    ///\n+    /// [`set_len`]: Vec::set_len\n+    ///\n+    /// Note that this is a low-level API, which should be used with care for\n+    /// optimization purposes. If you need to append data to a `Vec`\n+    /// you can use [`push`], [`extend`], [`extend_from_slice`],\n+    /// [`extend_from_within`], [`insert`], [`append`], [`resize`] or\n+    /// [`resize_with`], depending on your exact needs.\n+    ///\n+    /// [`push`]: Vec::push\n+    /// [`extend`]: Vec::extend\n+    /// [`extend_from_slice`]: Vec::extend_from_slice\n+    /// [`extend_from_within`]: Vec::extend_from_within\n+    /// [`insert`]: Vec::insert\n+    /// [`append`]: Vec::append\n+    /// [`resize`]: Vec::resize\n+    /// [`resize_with`]: Vec::resize_with\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_split_at_spare, maybe_uninit_extra)]\n+    ///\n+    /// let mut v = vec![1, 1, 2];\n+    ///\n+    /// // Reserve additional space big enough for 10 elements.\n+    /// v.reserve(10);\n+    ///\n+    /// let (init, uninit) = v.split_at_spare_mut();\n+    /// let sum = init.iter().copied().sum::<u32>();\n+    ///\n+    /// // Fill in the next 4 elements.\n+    /// uninit[0].write(sum);\n+    /// uninit[1].write(sum * 2);\n+    /// uninit[2].write(sum * 3);\n+    /// uninit[3].write(sum * 4);\n+    ///\n+    /// // Mark the 4 elements of the vector as being initialized.\n+    /// unsafe {\n+    ///     let len = v.len();\n+    ///     v.set_len(len + 4);\n+    /// }\n+    ///\n+    /// assert_eq!(&v, &[1, 1, 2, 4, 8, 12, 16]);\n+    /// ```\n+    #[unstable(feature = \"vec_split_at_spare\", issue = \"81944\")]\n     #[inline]\n-    fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]) {\n+    pub fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]) {\n         let ptr = self.as_mut_ptr();\n \n         // Safety:"}, {"sha": "c12770fb8b6d71e191367a7d30157ae1308f0d00", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -1586,15 +1586,15 @@ extern \"rust-intrinsic\" {\n     /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_div` method. For example,\n     /// [`u32::checked_div`]\n-    #[rustc_const_stable(feature = \"const_int_unchecked_arith\", since = \"1.51.0\")]\n+    #[rustc_const_stable(feature = \"const_int_unchecked_arith\", since = \"1.52.0\")]\n     pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior when `y == 0` or `x == T::MIN && y == -1`\n     ///\n     /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_rem` method. For example,\n     /// [`u32::checked_rem`]\n-    #[rustc_const_stable(feature = \"const_int_unchecked_arith\", since = \"1.51.0\")]\n+    #[rustc_const_stable(feature = \"const_int_unchecked_arith\", since = \"1.52.0\")]\n     pub fn unchecked_rem<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked left shift, resulting in undefined behavior when"}, {"sha": "709ed26d2a39febf244e9634c1c45a6d827dc34b", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -513,7 +513,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\")]\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -539,7 +539,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\")]\n         /// ```\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -565,7 +565,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\")]\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -591,7 +591,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\")]\n         /// ```\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -949,7 +949,7 @@ macro_rules! int_impl {\n         /// assert_eq!((-128i8).wrapping_div(-1), -128);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -977,7 +977,7 @@ macro_rules! int_impl {\n         /// assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n         /// ```\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1005,7 +1005,7 @@ macro_rules! int_impl {\n         /// assert_eq!((-128i8).wrapping_rem(-1), 0);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1032,7 +1032,7 @@ macro_rules! int_impl {\n         /// assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n         /// ```\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1299,7 +1299,7 @@ macro_rules! int_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n@@ -1329,7 +1329,7 @@ macro_rules! int_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n@@ -1360,7 +1360,7 @@ macro_rules! int_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n@@ -1390,7 +1390,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\")]\n         /// ```\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1615,7 +1615,7 @@ macro_rules! int_impl {\n         /// assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n         /// ```\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1653,7 +1653,7 @@ macro_rules! int_impl {\n         /// assert_eq!((-a).rem_euclid(-b), 1);\n         /// ```\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "bf5331a01d58ea1413177f78b88a30cc9df10010", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -522,7 +522,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -548,7 +548,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n         /// ```\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -573,7 +573,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -599,7 +599,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n         /// ```\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -876,7 +876,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -901,7 +901,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n         /// ```\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -924,7 +924,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n-        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -950,7 +950,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n         /// ```\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1185,7 +1185,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n@@ -1215,7 +1215,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n@@ -1242,7 +1242,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n@@ -1272,7 +1272,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n@@ -1456,7 +1456,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n         /// ```\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1484,7 +1484,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n         /// ```\n         #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n-        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.51.0\")]\n+        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "0ef848ff0c4c1a3269f7bac5bcf10ebd707d20ff", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -775,6 +775,15 @@ pub fn sleep_ms(ms: u32) {\n /// Platforms which do not support nanosecond precision for sleeping will\n /// have `dur` rounded up to the nearest granularity of time they can sleep for.\n ///\n+/// Currently, specifying a zero duration on Unix platforms returns immediately\n+/// without invoking the underlying [`nanosleep`] syscall, whereas on Windows\n+/// platforms the underlying [`Sleep`] syscall is always invoked.\n+/// If the intention is to yield the current time-slice you may want to use\n+/// [`yield_now`] instead.\n+///\n+/// [`nanosleep`]: https://linux.die.net/man/2/nanosleep\n+/// [`Sleep`]: https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep\n+///\n /// # Examples\n ///\n /// ```no_run"}, {"sha": "8fddd8cba08defe4e2d83e8cb9e364bc338e998b", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -1512,7 +1512,7 @@ impl<'a> Builder<'a> {\n                 for el in stack.iter().rev() {\n                     out += &format!(\"\\t{:?}\\n\", el);\n                 }\n-                panic!(out);\n+                panic!(\"{}\", out);\n             }\n             if let Some(out) = self.cache.get(&step) {\n                 self.verbose(&format!(\"{}c {:?}\", \"  \".repeat(stack.len()), step));"}, {"sha": "8f005be7cf78999d4f49de1d775b5ec497f0235f", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -316,7 +316,7 @@ crate fn is_literal_expr(cx: &DocContext<'_>, hir_id: hir::HirId) -> bool {\n             return true;\n         }\n \n-        if let hir::ExprKind::Unary(hir::UnOp::UnNeg, expr) = &expr.kind {\n+        if let hir::ExprKind::Unary(hir::UnOp::Neg, expr) = &expr.kind {\n             if let hir::ExprKind::Lit(_) = &expr.kind {\n                 return true;\n             }"}, {"sha": "f789ad2a05c7d5499b898f1f9f79c0bdee5bdc97", "filename": "src/test/ui/async-await/mutually-recursive-async-impl-trait-type.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftest%2Fui%2Fasync-await%2Fmutually-recursive-async-impl-trait-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftest%2Fui%2Fasync-await%2Fmutually-recursive-async-impl-trait-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmutually-recursive-async-impl-trait-type.stderr?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -5,6 +5,7 @@ LL | async fn rec_1() {\n    |                  ^ recursive `async fn`\n    |\n    = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`\n+   = note: consider using the `async_recursion` crate: https://crates.io/crates/async_recursion\n \n error[E0733]: recursion in an `async fn` requires boxing\n   --> $DIR/mutually-recursive-async-impl-trait-type.rs:9:18\n@@ -13,6 +14,7 @@ LL | async fn rec_2() {\n    |                  ^ recursive `async fn`\n    |\n    = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`\n+   = note: consider using the `async_recursion` crate: https://crates.io/crates/async_recursion\n \n error: aborting due to 2 previous errors\n "}, {"sha": "63f64f4455749acbec7833cd1aa24319ffdcfefd", "filename": "src/test/ui/async-await/recursive-async-impl-trait-type.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.stderr?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -5,6 +5,7 @@ LL | async fn recursive_async_function() -> () {\n    |                                        ^^ recursive `async fn`\n    |\n    = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`\n+   = note: consider using the `async_recursion` crate: https://crates.io/crates/async_recursion\n \n error: aborting due to previous error\n "}, {"sha": "674139f4afccee6421946fe67e74677ccc0cf3fc", "filename": "src/test/ui/stability-attribute/stability-attribute-sanity.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fstability-attribute-sanity.stderr?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -116,5 +116,5 @@ LL | #[rustc_deprecated(since = \"a\", reason = \"text\")]\n \n error: aborting due to 19 previous errors\n \n-Some errors have detailed explanations: E0539, E0541, E0542, E0546, E0550.\n+Some errors have detailed explanations: E0539, E0541, E0542, E0546, E0547, E0550.\n For more information about an error, try `rustc --explain E0539`."}, {"sha": "756768bce46504925f8954d909641e23327bbace", "filename": "src/test/ui/suggestions/suggest-mut-method-for-loop.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -0,0 +1,17 @@\n+use std::collections::HashMap;\n+struct X(usize);\n+struct Y {\n+    v: u32\n+}\n+\n+fn main() {\n+    let mut buzz = HashMap::new();\n+    buzz.insert(\"a\", Y { v: 0 });\n+\n+    for mut t in buzz.values() {\n+                  //~^ HELP\n+                  //~| SUGGESTION values_mut()\n+        t.v += 1;\n+        //~^ ERROR cannot assign\n+    }\n+}"}, {"sha": "6ab08197441c39a2654826518983683c503b9108", "filename": "src/test/ui/suggestions/suggest-mut-method-for-loop.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop.stderr?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -0,0 +1,15 @@\n+error[E0594]: cannot assign to `t.v` which is behind a `&` reference\n+  --> $DIR/suggest-mut-method-for-loop.rs:14:9\n+   |\n+LL |     for mut t in buzz.values() {\n+   |                  -------------\n+   |                  |    |\n+   |                  |    help: use mutable method: `values_mut()`\n+   |                  this iterator yields `&` references\n+...\n+LL |         t.v += 1;\n+   |         ^^^^^^^^ `t` is a `&` reference, so the data it refers to cannot be written\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0594`."}, {"sha": "ab64d1393b5b77c66b6534ef5023a1b89ee7bf64", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -1 +1 @@\n-Subproject commit 34170fcd6e0947808a1ac63ac85ffc0da7dace2f\n+Subproject commit ab64d1393b5b77c66b6534ef5023a1b89ee7bf64"}, {"sha": "61fdf9495b918c6b44f8ca72a8b2833a9a27e482", "filename": "src/tools/clippy/clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Farithmetic.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -91,7 +91,7 @@ impl<'tcx> LateLintPass<'tcx> for Arithmetic {\n                     match op.node {\n                         hir::BinOpKind::Div | hir::BinOpKind::Rem => match &r.kind {\n                             hir::ExprKind::Lit(_lit) => (),\n-                            hir::ExprKind::Unary(hir::UnOp::UnNeg, expr) => {\n+                            hir::ExprKind::Unary(hir::UnOp::Neg, expr) => {\n                                 if let hir::ExprKind::Lit(lit) = &expr.kind {\n                                     if let rustc_ast::ast::LitKind::Int(1, _) = lit.node {\n                                         span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n@@ -114,7 +114,7 @@ impl<'tcx> LateLintPass<'tcx> for Arithmetic {\n                     self.expr_span = Some(expr.span);\n                 }\n             },\n-            hir::ExprKind::Unary(hir::UnOp::UnNeg, arg) => {\n+            hir::ExprKind::Unary(hir::UnOp::Neg, arg) => {\n                 let ty = cx.typeck_results().expr_ty(arg);\n                 if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n                     if ty.is_integral() {"}, {"sha": "77b26faaa586a35ce74bf5c7757f61453a26feb2", "filename": "src/tools/clippy/clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -112,7 +112,7 @@ enum AssertKind {\n fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n     if_chain! {\n         if let ExprKind::If(ref cond, ref then, _) = expr.kind;\n-        if let ExprKind::Unary(UnOp::UnNot, ref expr) = cond.kind;\n+        if let ExprKind::Unary(UnOp::Not, ref expr) = cond.kind;\n         // bind the first argument of the `assert!` macro\n         if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n         // block"}, {"sha": "0713303ec4b672c0190d8a8f2031060b0dceefb5", "filename": "src/tools/clippy/clippy_lints/src/booleans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n         // prevent folding of `cfg!` macros and the like\n         if !e.span.from_expansion() {\n             match &e.kind {\n-                ExprKind::Unary(UnOp::UnNot, inner) => return Ok(Bool::Not(box self.run(inner)?)),\n+                ExprKind::Unary(UnOp::Not, inner) => return Ok(Bool::Not(box self.run(inner)?)),\n                 ExprKind::Binary(binop, lhs, rhs) => match &binop.node {\n                     BinOpKind::Or => {\n                         return Ok(Bool::Or(self.extract(BinOpKind::Or, &[lhs, rhs], Vec::new())?));\n@@ -454,7 +454,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n             ExprKind::Binary(binop, _, _) if binop.node == BinOpKind::Or || binop.node == BinOpKind::And => {\n                 self.bool_expr(e)\n             },\n-            ExprKind::Unary(UnOp::UnNot, inner) => {\n+            ExprKind::Unary(UnOp::Not, inner) => {\n                 if self.cx.typeck_results().node_types()[inner.hir_id].is_bool() {\n                     self.bool_expr(e);\n                 } else {\n@@ -482,7 +482,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NotSimplificationVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Unary(UnOp::UnNot, inner) = &expr.kind {\n+        if let ExprKind::Unary(UnOp::Not, inner) = &expr.kind {\n             if let Some(suggestion) = simplify_not(self.cx, inner) {\n                 span_lint_and_sugg(\n                     self.cx,"}, {"sha": "b8828719f627c8ecb45d15aa3a3cbcbae9c5cdaf", "filename": "src/tools/clippy/clippy_lints/src/bytecount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -101,7 +101,7 @@ fn check_arg(name: Symbol, arg: Symbol, needle: &Expr<'_>) -> bool {\n \n fn get_path_name(expr: &Expr<'_>) -> Option<Symbol> {\n     match expr.kind {\n-        ExprKind::Box(ref e) | ExprKind::AddrOf(BorrowKind::Ref, _, ref e) | ExprKind::Unary(UnOp::UnDeref, ref e) => {\n+        ExprKind::Box(ref e) | ExprKind::AddrOf(BorrowKind::Ref, _, ref e) | ExprKind::Unary(UnOp::Deref, ref e) => {\n             get_path_name(e)\n         },\n         ExprKind::Block(ref b, _) => {"}, {"sha": "b83aae0e5719cad9fb15357f8cfc68b0fe501b42", "filename": "src/tools/clippy/clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -186,7 +186,7 @@ fn addr_adjusted_binding(mut expr: &Expr<'_>, cx: &LateContext<'_>) -> Option<Hi\n                 Res::Local(binding_id) => break Some(binding_id),\n                 _ => break None,\n             },\n-            ExprKind::Unary(UnOp::UnDeref, e) if cx.typeck_results().expr_ty(e).is_ref() => expr = e,\n+            ExprKind::Unary(UnOp::Deref, e) if cx.typeck_results().expr_ty(e).is_ref() => expr = e,\n             _ => break None,\n         }\n     }"}, {"sha": "1b89d0bbe3862cebfee0e5a7c071f35fcef8997e", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -242,9 +242,9 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n             },\n             ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n-                UnOp::UnNot => self.constant_not(&o, self.typeck_results.expr_ty(e)),\n-                UnOp::UnNeg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n-                UnOp::UnDeref => Some(if let Constant::Ref(r) = o { *r } else { o }),\n+                UnOp::Not => self.constant_not(&o, self.typeck_results.expr_ty(e)),\n+                UnOp::Neg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n+                UnOp::Deref => Some(if let Constant::Ref(r) = o { *r } else { o }),\n             }),\n             ExprKind::If(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, *otherwise),\n             ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),"}, {"sha": "6b9f9a56754814a46575b754b3d7ae6bba8cfbd1", "filename": "src/tools/clippy/clippy_lints/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -55,7 +55,7 @@ declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::If(ref check, ref then_block, ref else_block) = expr.kind {\n-            if let ExprKind::Unary(UnOp::UnNot, ref check) = check.kind {\n+            if let ExprKind::Unary(UnOp::Not, ref check) = check.kind {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message"}, {"sha": "086a791520fa8ec351ba4152d9089ab253f9c7c9", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -129,7 +129,7 @@ fn get_specialized_log_method(cx: &LateContext<'_>, base: &Expr<'_>) -> Option<&\n fn prepare_receiver_sugg<'a>(cx: &LateContext<'_>, mut expr: &'a Expr<'a>) -> Sugg<'a> {\n     let mut suggestion = Sugg::hir(cx, expr, \"..\");\n \n-    if let ExprKind::Unary(UnOp::UnNeg, inner_expr) = &expr.kind {\n+    if let ExprKind::Unary(UnOp::Neg, inner_expr) = &expr.kind {\n         expr = &inner_expr;\n     }\n \n@@ -541,12 +541,12 @@ fn is_zero(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n /// If the two expressions are not negations of each other, then it\n /// returns None.\n fn are_negated<'a>(cx: &LateContext<'_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a>) -> Option<(bool, &'a Expr<'a>)> {\n-    if let ExprKind::Unary(UnOp::UnNeg, expr1_negated) = &expr1.kind {\n+    if let ExprKind::Unary(UnOp::Neg, expr1_negated) = &expr1.kind {\n         if eq_expr_value(cx, expr1_negated, expr2) {\n             return Some((false, expr2));\n         }\n     }\n-    if let ExprKind::Unary(UnOp::UnNeg, expr2_negated) = &expr2.kind {\n+    if let ExprKind::Unary(UnOp::Neg, expr2_negated) = &expr2.kind {\n         if eq_expr_value(cx, expr1, expr2_negated) {\n             return Some((true, expr1));\n         }"}, {"sha": "71a146cc29805a93c08b5a5f6019fa5ce29a3587", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -644,7 +644,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprKind::Unary(hir::UnOp::UnDeref, ref ptr) => self.check_arg(ptr),\n+            hir::ExprKind::Unary(hir::UnOp::Deref, ref ptr) => self.check_arg(ptr),\n             _ => (),\n         }\n "}, {"sha": "bd0be88028904a6d1bbad626b78a3ba5e8451b52", "filename": "src/tools/clippy/clippy_lints/src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -70,7 +70,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                     },\n                     hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, .., name, None) => {\n                         match closure_expr.kind {\n-                            hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner) => {\n+                            hir::ExprKind::Unary(hir::UnOp::Deref, ref inner) => {\n                                 if ident_eq(name, inner) {\n                                     if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind() {\n                                         lint(cx, e.span, args[0].span, true);"}, {"sha": "eaa604c2ae63eef88b25330b9bbc2942376df10b", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -148,7 +148,7 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) -> Option<M\n     }\n \n     if ty.is_signed() {\n-        if let hir::ExprKind::Unary(hir::UnOp::UnNeg, val) = &expr.kind {\n+        if let hir::ExprKind::Unary(hir::UnOp::Neg, val) = &expr.kind {\n             return check_lit(val, true);\n         }\n     }\n@@ -163,7 +163,7 @@ enum Sign {\n }\n \n fn lit_sign(expr: &hir::Expr<'_>) -> Option<Sign> {\n-    if let hir::ExprKind::Unary(hir::UnOp::UnNeg, inner) = &expr.kind {\n+    if let hir::ExprKind::Unary(hir::UnOp::Neg, inner) = &expr.kind {\n         if let hir::ExprKind::Lit(..) = &inner.kind {\n             return Some(Sign::Neg);\n         }"}, {"sha": "0918843294d479ac10a90779b5948d5bb4ad4622", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -2619,7 +2619,7 @@ fn lint_get_unwrap<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args:\n     if_chain! {\n         if needs_ref;\n         if let Some(parent) = get_parent_expr(cx, expr);\n-        if let hir::ExprKind::Unary(hir::UnOp::UnDeref, _) = parent.kind;\n+        if let hir::ExprKind::Unary(hir::UnOp::Deref, _) = parent.kind;\n         then {\n             needs_ref = false;\n             span = parent.span;\n@@ -3063,7 +3063,7 @@ fn lint_filter_map<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, is_f\n             // in `filter(|x| ..)`, replace `*x` with `x`\n             let a_path = if_chain! {\n                 if !is_filter_param_ref;\n-                if let ExprKind::Unary(UnOp::UnDeref, expr_path) = a.kind;\n+                if let ExprKind::Unary(UnOp::Deref, expr_path) = a.kind;\n                 then { expr_path } else { a }\n             };\n             // let the filter closure arg and the map closure arg be equal\n@@ -3708,8 +3708,8 @@ fn lint_option_as_ref_deref<'tcx>(\n                 },\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref inner) if same_mutability(m) => {\n                     if_chain! {\n-                        if let hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner1) = inner.kind;\n-                        if let hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner2) = inner1.kind;\n+                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner1) = inner.kind;\n+                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner2) = inner1.kind;\n                         if let hir::ExprKind::Path(ref qpath) = inner2.kind;\n                         if let hir::def::Res::Local(local_id) = cx.qpath_res(qpath, inner2.hir_id);\n                         then {\n@@ -4065,7 +4065,7 @@ fn lint_filetype_is_file(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir\n     if_chain! {\n         if let Some(parent) = get_parent_expr(cx, expr);\n         if let hir::ExprKind::Unary(op, _) = parent.kind;\n-        if op == hir::UnOp::UnNot;\n+        if op == hir::UnOp::Not;\n         then {\n             lint_unary = \"!\";\n             verb = \"denies\";"}, {"sha": "2ef5c6aa2a4e2a8b39c2d8e38a622a7c2f5c4ec4", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -502,7 +502,7 @@ fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n // Return true if `expr` is the result of `signum()` invoked on a float value.\n fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     // The negation of a signum is still a signum\n-    if let ExprKind::Unary(UnOp::UnNeg, ref child_expr) = expr.kind {\n+    if let ExprKind::Unary(UnOp::Neg, ref child_expr) = expr.kind {\n         return is_signum(cx, &child_expr);\n     }\n \n@@ -586,7 +586,7 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n         return;\n     }\n \n-    let other_gets_derefed = matches!(other.kind, ExprKind::Unary(UnOp::UnDeref, _));\n+    let other_gets_derefed = matches!(other.kind, ExprKind::Unary(UnOp::Deref, _));\n \n     let lint_span = if other_gets_derefed {\n         expr.span.to(other.span)"}, {"sha": "f283ff1715fb667df833c98cebc41039603d04ee", "filename": "src/tools/clippy/clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -195,7 +195,7 @@ struct ExpressionInfoWithSpan {\n }\n \n fn is_unary_not(e: &Expr<'_>) -> (bool, Span) {\n-    if let ExprKind::Unary(UnOp::UnNot, operand) = e.kind {\n+    if let ExprKind::Unary(UnOp::Not, operand) = e.kind {\n         return (true, operand.span);\n     }\n     (false, e.span)"}, {"sha": "ec0ad58ca9c3e9558a726b2ce9bad59b00b5e46f", "filename": "src/tools/clippy/clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for NoNegCompOpForPartialOrd {\n         if_chain! {\n \n             if !in_external_macro(cx.sess(), expr.span);\n-            if let ExprKind::Unary(UnOp::UnNot, ref inner) = expr.kind;\n+            if let ExprKind::Unary(UnOp::Not, ref inner) = expr.kind;\n             if let ExprKind::Binary(ref op, ref left, _) = inner.kind;\n             if let BinOpKind::Le | BinOpKind::Ge | BinOpKind::Lt | BinOpKind::Gt = op.node;\n "}, {"sha": "ef7cc65cfcf0a36fe3416a70fd35e5aa07bd9b7d", "filename": "src/tools/clippy/clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -32,8 +32,8 @@ impl<'tcx> LateLintPass<'tcx> for NegMultiply {\n             if BinOpKind::Mul == op.node {\n                 match (&left.kind, &right.kind) {\n                     (&ExprKind::Unary(..), &ExprKind::Unary(..)) => {},\n-                    (&ExprKind::Unary(UnOp::UnNeg, ref lit), _) => check_mul(cx, e.span, lit, right),\n-                    (_, &ExprKind::Unary(UnOp::UnNeg, ref lit)) => check_mul(cx, e.span, lit, left),\n+                    (&ExprKind::Unary(UnOp::Neg, ref lit), _) => check_mul(cx, e.span, lit, right),\n+                    (_, &ExprKind::Unary(UnOp::Neg, ref lit)) => check_mul(cx, e.span, lit, left),\n                     _ => {},\n                 }\n             }"}, {"sha": "0b2262d849076857ed43d883e3398904e837ff40", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -383,7 +383,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                             needs_check_adjustment = false;\n                             break;\n                         },\n-                        ExprKind::Unary(UnOp::UnDeref, _) => {\n+                        ExprKind::Unary(UnOp::Deref, _) => {\n                             // `*e` => desugared to `*Deref::deref(&e)`,\n                             // meaning `e` must be referenced.\n                             // no need to go further up since a method call is involved now."}, {"sha": "9ef0d267b0b20b49b691ae5bfdf49c637fb357c8", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -181,7 +181,7 @@ fn detect_option_if_let_else<'tcx>(\n             };\n             let cond_expr = match &cond_expr.kind {\n                 // Pointer dereferencing happens automatically, so we can omit it in the suggestion\n-                ExprKind::Unary(UnOp::UnDeref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n+                ExprKind::Unary(UnOp::Deref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n                 _ => cond_expr,\n             };\n             Some(OptionIfLetElseOccurence {"}, {"sha": "32f6bc74642ca8c17e12ecd805184eceb1a21670", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -389,7 +389,7 @@ fn is_self_shadow(name: Symbol, expr: &Expr<'_>) -> bool {\n         ExprKind::Block(ref block, _) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |e| is_self_shadow(name, e))\n         },\n-        ExprKind::Unary(op, ref inner) => (UnOp::UnDeref == op) && is_self_shadow(name, inner),\n+        ExprKind::Unary(op, ref inner) => (UnOp::Deref == op) && is_self_shadow(name, inner),\n         ExprKind::Path(QPath::Resolved(_, ref path)) => path_eq_name(name, path),\n         _ => false,\n     }"}, {"sha": "0b7d08cb1645a11f74609a22009d6f87dc482ec4", "filename": "src/tools/clippy/clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -194,7 +194,7 @@ impl<'tcx> Visitor<'tcx> for BinaryExprVisitor {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n         match expr.kind {\n             hir::ExprKind::Binary(..)\n-            | hir::ExprKind::Unary(hir::UnOp::UnNot | hir::UnOp::UnNeg, _)\n+            | hir::ExprKind::Unary(hir::UnOp::Not | hir::UnOp::Neg, _)\n             | hir::ExprKind::AssignOp(..) => self.nb_binops += 1,\n             _ => {},\n         }"}, {"sha": "dc938ed02383dc0513ddbd2ab87a2171723c5cdc", "filename": "src/tools/clippy/clippy_lints/src/transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -586,7 +586,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                             let mut expr = &args[0];\n                             let mut arg = sugg::Sugg::hir(cx, expr, \"..\");\n \n-                            if let ExprKind::Unary(UnOp::UnNeg, inner_expr) = &expr.kind {\n+                            if let ExprKind::Unary(UnOp::Neg, inner_expr) = &expr.kind {\n                                 expr = &inner_expr;\n                             }\n "}, {"sha": "58af5b12c37354dae49994486031f74ad7d1eac0", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -1706,13 +1706,13 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n }\n \n fn is_unary_neg(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::Unary(UnOp::UnNeg, _))\n+    matches!(expr.kind, ExprKind::Unary(UnOp::Neg, _))\n }\n \n fn get_numeric_literal<'e>(expr: &'e Expr<'e>) -> Option<&'e Lit> {\n     match expr.kind {\n         ExprKind::Lit(ref lit) => Some(lit),\n-        ExprKind::Unary(UnOp::UnNeg, e) => {\n+        ExprKind::Unary(UnOp::Neg, e) => {\n             if let ExprKind::Lit(ref lit) = e.kind {\n                 Some(lit)\n             } else {\n@@ -2868,7 +2868,7 @@ declare_lint_pass!(RefToMut => [CAST_REF_TO_MUT]);\n impl<'tcx> LateLintPass<'tcx> for RefToMut {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Unary(UnOp::UnDeref, e) = &expr.kind;\n+            if let ExprKind::Unary(UnOp::Deref, e) = &expr.kind;\n             if let ExprKind::Cast(e, t) = &e.kind;\n             if let TyKind::Ptr(MutTy { mutbl: Mutability::Mut, .. }) = t.kind;\n             if let ExprKind::Cast(e, t) = &e.kind;"}, {"sha": "2fb0463c5a6c250c646ceb5cdcd2e795f5c39df4", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -108,7 +108,7 @@ fn collect_unwrap_info<'tcx>(\n             },\n             _ => (),\n         }\n-    } else if let ExprKind::Unary(UnOp::UnNot, expr) = &expr.kind {\n+    } else if let ExprKind::Unary(UnOp::Not, expr) = &expr.kind {\n         return collect_unwrap_info(cx, expr, branch, !invert);\n     } else {\n         if_chain! {"}, {"sha": "145703d1bdc3fcb2d2d7a2a68355568de3dfd7f4", "filename": "src/tools/clippy/clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -243,7 +243,7 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n                 // macros with unique arg: `{debug_}assert!` (e.g., `debug_assert!(some_condition)`)\n                 if_chain! {\n                     if let ExprKind::If(ref clause, _, _)  = matchexpr.kind;\n-                    if let ExprKind::Unary(UnOp::UnNot, condition) = clause.kind;\n+                    if let ExprKind::Unary(UnOp::Not, condition) = clause.kind;\n                     then {\n                         return Some(vec![condition]);\n                     }"}, {"sha": "ff3be590317ba1a9b5db1fc80624d7d268fe32fd", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -1001,7 +1001,7 @@ impl InterningDefinedSymbol {\n         // SymbolStr might be de-referenced: `&*symbol.as_str()`\n         let call = if_chain! {\n             if let ExprKind::AddrOf(_, _, e) = expr.kind;\n-            if let ExprKind::Unary(UnOp::UnDeref, e) = e.kind;\n+            if let ExprKind::Unary(UnOp::Deref, e) = e.kind;\n             then { e } else { expr }\n         };\n         if_chain! {"}, {"sha": "ae253a0487cb40083457f728c6255163168bc333", "filename": "src/tools/clippy/tests/ui/suspicious_arithmetic_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_arithmetic_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7534b566c850f860e11735b27a988dd9eec454a/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_arithmetic_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_arithmetic_impl.rs?ref=f7534b566c850f860e11735b27a988dd9eec454a", "patch": "@@ -117,7 +117,7 @@ impl Add for Bar {\n     type Output = Bar;\n \n     fn add(self, other: Self) -> Self {\n-        Bar(self.0 & !other.0) // OK: UnNot part of BiExpr as child node\n+        Bar(self.0 & !other.0) // OK: Not part of BiExpr as child node\n     }\n }\n \n@@ -126,7 +126,7 @@ impl Sub for Bar {\n \n     fn sub(self, other: Self) -> Self {\n         if self.0 <= other.0 {\n-            Bar(-(self.0 & other.0)) // OK: UnNeg part of BiExpr as parent node\n+            Bar(-(self.0 & other.0)) // OK: Neg part of BiExpr as parent node\n         } else {\n             Bar(0)\n         }"}]}