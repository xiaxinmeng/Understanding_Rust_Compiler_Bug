{"sha": "f29c91bf1245fc01853b0f1d8913139b3b355f63", "node_id": "C_kwDOAAsO6NoAKGYyOWM5MWJmMTI0NWZjMDE4NTNiMGYxZDg5MTMxMzliM2IzNTVmNjM", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-06-26T04:10:07Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-09-08T21:57:32Z"}, "message": "Create VarValue::Empty", "tree": {"sha": "fce20295e3756c73e122d6f14d3166302cefedd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fce20295e3756c73e122d6f14d3166302cefedd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f29c91bf1245fc01853b0f1d8913139b3b355f63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f29c91bf1245fc01853b0f1d8913139b3b355f63", "html_url": "https://github.com/rust-lang/rust/commit/f29c91bf1245fc01853b0f1d8913139b3b355f63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f29c91bf1245fc01853b0f1d8913139b3b355f63/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc87d53da9018eb985af69caea22b2ad79b2505a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc87d53da9018eb985af69caea22b2ad79b2505a", "html_url": "https://github.com/rust-lang/rust/commit/cc87d53da9018eb985af69caea22b2ad79b2505a"}], "stats": {"total": 213, "additions": 191, "deletions": 22}, "files": [{"sha": "3e6a48195f8ce2daf3f3dcc1baae97f727250261", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f29c91bf1245fc01853b0f1d8913139b3b355f63/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29c91bf1245fc01853b0f1d8913139b3b355f63/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=f29c91bf1245fc01853b0f1d8913139b3b355f63", "patch": "@@ -109,7 +109,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         .iter()\n                         .find(|ur_vid| self.eval_equal(vid, **ur_vid))\n                         .and_then(|ur_vid| self.definitions[*ur_vid].external_name)\n-                        .unwrap_or(infcx.tcx.lifetimes.re_root_empty),\n+                        .unwrap_or(infcx.tcx.lifetimes.re_erased),\n                     _ => region,\n                 });\n "}, {"sha": "41695d6807bc453df66127d0ca5e57637763684e", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 181, "deletions": 20, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/f29c91bf1245fc01853b0f1d8913139b3b355f63/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29c91bf1245fc01853b0f1d8913139b3b355f63/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=f29c91bf1245fc01853b0f1d8913139b3b355f63", "patch": "@@ -51,6 +51,13 @@ pub struct LexicalRegionResolutions<'tcx> {\n \n #[derive(Copy, Clone, Debug)]\n pub(crate) enum VarValue<'tcx> {\n+    /// Empty lifetime is for data that is never accessed.  We tag the\n+    /// empty lifetime with a universe -- the idea is that we don't\n+    /// want `exists<'a> { forall<'b> { 'b: 'a } }` to be satisfiable.\n+    /// Therefore, the `'empty` in a universe `U` is less than all\n+    /// regions visible from `U`, but not less than regions not visible\n+    /// from `U`.\n+    Empty(ty::UniverseIndex),\n     Value(Region<'tcx>),\n     ErrorValue,\n }\n@@ -117,7 +124,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         &mut self,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) -> LexicalRegionResolutions<'tcx> {\n-        let mut var_data = self.construct_var_data(self.tcx());\n+        let mut var_data = self.construct_var_data();\n \n         if cfg!(debug_assertions) {\n             self.dump_constraints();\n@@ -137,13 +144,12 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n     /// Initially, the value for all variables is set to `'empty`, the\n     /// empty region. The `expansion` phase will grow this larger.\n-    fn construct_var_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n+    fn construct_var_data(&self) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             values: IndexVec::from_fn_n(\n                 |vid| {\n                     let vid_universe = self.var_infos[vid].universe;\n-                    let re_empty = tcx.mk_region(ty::ReEmpty(vid_universe));\n-                    VarValue::Value(re_empty)\n+                    VarValue::Empty(vid_universe)\n                 },\n                 self.num_vars(),\n             ),\n@@ -190,38 +196,139 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     }\n \n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n+        // In the first pass, we expand region vids according to constraints we\n+        // have previously found. In the second pass, we loop through the region\n+        // vids we expanded and expand *across* region vids (effectively\n+        // \"expanding\" new `RegSubVar` constraints).\n+\n+        // Tracks the `VarSubVar` constraints generated for each region vid. We\n+        // later use this to expand across vids.\n         let mut constraints = IndexVec::from_elem_n(Vec::new(), var_values.values.len());\n+        // Tracks the changed region vids.\n         let mut changes = Vec::new();\n         for constraint in self.data.constraints.keys() {\n-            let (a_vid, a_region, b_vid, b_data) = match *constraint {\n+            match *constraint {\n                 Constraint::RegSubVar(a_region, b_vid) => {\n                     let b_data = var_values.value_mut(b_vid);\n-                    (None, a_region, b_vid, b_data)\n+\n+                    if self.expand_node(a_region, b_vid, b_data) {\n+                        changes.push(b_vid);\n+                    }\n                 }\n                 Constraint::VarSubVar(a_vid, b_vid) => match *var_values.value(a_vid) {\n                     VarValue::ErrorValue => continue,\n+                    VarValue::Empty(a_universe) => {\n+                        let b_data = var_values.value_mut(b_vid);\n+\n+                        let changed = (|| match *b_data {\n+                            VarValue::Empty(b_universe) => {\n+                                // Empty regions are ordered according to the universe\n+                                // they are associated with.\n+                                let ui = a_universe.min(b_universe);\n+\n+                                debug!(\n+                                    \"Expanding value of {:?} \\\n+                                    from empty lifetime with universe {:?} \\\n+                                    to empty lifetime with universe {:?}\",\n+                                    b_vid, b_universe, ui\n+                                );\n+\n+                                *b_data = VarValue::Empty(ui);\n+                                true\n+                            }\n+                            VarValue::Value(cur_region) => {\n+                                let lub = match *cur_region {\n+                                    ReLateBound(..) | ReErased => {\n+                                        bug!(\"cannot relate region: {:?}\", cur_region);\n+                                    }\n+\n+                                    ReVar(v_id) => {\n+                                        span_bug!(\n+                                            self.var_infos[v_id].origin.span(),\n+                                            \"lub_concrete_regions invoked with non-concrete regions: {:?}\",\n+                                            cur_region,\n+                                        );\n+                                    }\n+\n+                                    ReStatic => {\n+                                        // nothing lives longer than `'static`\n+                                        self.tcx().lifetimes.re_static\n+                                    }\n+\n+                                    ReEarlyBound(_) | ReFree(_) => {\n+                                        // All empty regions are less than early-bound, free,\n+                                        // and scope regions.\n+                                        cur_region\n+                                    }\n+\n+                                    ReEmpty(b_ui) => {\n+                                        // Empty regions are ordered according to the universe\n+                                        // they are associated with.\n+                                        let ui = a_universe.min(b_ui);\n+                                        self.tcx().mk_region(ReEmpty(ui))\n+                                    }\n+\n+                                    RePlaceholder(placeholder) => {\n+                                        // If the empty and placeholder regions are in the same universe,\n+                                        // then the LUB is the Placeholder region (which is the cur_region).\n+                                        // If they are not in the same universe, the LUB is the Static lifetime.\n+                                        if a_universe == placeholder.universe {\n+                                            cur_region\n+                                        } else {\n+                                            self.tcx().lifetimes.re_static\n+                                        }\n+                                    }\n+                                };\n+\n+                                if lub == cur_region {\n+                                    return false;\n+                                }\n+\n+                                debug!(\n+                                    \"Expanding value of {:?} from {:?} to {:?}\",\n+                                    b_vid, cur_region, lub\n+                                );\n+\n+                                *b_data = VarValue::Value(lub);\n+                                true\n+                            }\n+\n+                            VarValue::ErrorValue => false,\n+                        })();\n+\n+                        if changed {\n+                            changes.push(b_vid);\n+                        }\n+                        match b_data {\n+                            VarValue::Value(Region(Interned(ReStatic, _)))\n+                            | VarValue::ErrorValue => (),\n+                            _ => {\n+                                constraints[a_vid].push((a_vid, b_vid));\n+                                constraints[b_vid].push((a_vid, b_vid));\n+                            }\n+                        }\n+                    }\n                     VarValue::Value(a_region) => {\n                         let b_data = var_values.value_mut(b_vid);\n-                        (Some(a_vid), a_region, b_vid, b_data)\n+\n+                        if self.expand_node(a_region, b_vid, b_data) {\n+                            changes.push(b_vid);\n+                        }\n+                        match b_data {\n+                            VarValue::Value(Region(Interned(ReStatic, _)))\n+                            | VarValue::ErrorValue => (),\n+                            _ => {\n+                                constraints[a_vid].push((a_vid, b_vid));\n+                                constraints[b_vid].push((a_vid, b_vid));\n+                            }\n+                        }\n                     }\n                 },\n                 Constraint::RegSubReg(..) | Constraint::VarSubReg(..) => {\n                     // These constraints are checked after expansion\n                     // is done, in `collect_errors`.\n                     continue;\n                 }\n-            };\n-            if self.expand_node(a_region, b_vid, b_data) {\n-                changes.push(b_vid);\n-            }\n-            if let Some(a_vid) = a_vid {\n-                match b_data {\n-                    VarValue::Value(Region(Interned(ReStatic, _))) | VarValue::ErrorValue => (),\n-                    _ => {\n-                        constraints[a_vid].push((a_vid, b_vid));\n-                        constraints[b_vid].push((a_vid, b_vid));\n-                    }\n-                }\n             }\n         }\n \n@@ -242,6 +349,10 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// Expands the value of the region represented with `b_vid` with current\n+    /// value `b_data` to the lub of `b_data` and `a_region`. The corresponds\n+    /// with the constraint `'?b: 'a` (`'a <: '?b`), where `'a` is some known\n+    /// region and `'?b` is some region variable.\n     fn expand_node(\n         &self,\n         a_region: Region<'tcx>,\n@@ -263,6 +374,55 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n \n         match *b_data {\n+            VarValue::Empty(empty_ui) => {\n+                let lub = match *a_region {\n+                    ReLateBound(..) | ReErased => {\n+                        bug!(\"cannot relate region: {:?}\", a_region);\n+                    }\n+\n+                    ReVar(v_id) => {\n+                        span_bug!(\n+                            self.var_infos[v_id].origin.span(),\n+                            \"expand_node invoked with non-concrete regions: {:?}\",\n+                            a_region,\n+                        );\n+                    }\n+\n+                    ReStatic => {\n+                        // nothing lives longer than `'static`\n+                        self.tcx().lifetimes.re_static\n+                    }\n+\n+                    ReEarlyBound(_) | ReFree(_) => {\n+                        // All empty regions are less than early-bound, free,\n+                        // and scope regions.\n+                        a_region\n+                    }\n+\n+                    ReEmpty(a_ui) => {\n+                        // Empty regions are ordered according to the universe\n+                        // they are associated with.\n+                        let ui = a_ui.min(empty_ui);\n+                        self.tcx().mk_region(ReEmpty(ui))\n+                    }\n+\n+                    RePlaceholder(placeholder) => {\n+                        // If this empty region is from a universe that can\n+                        // name the placeholder, then the placeholder is\n+                        // larger; otherwise, the only ancestor is `'static`.\n+                        if empty_ui.can_name(placeholder.universe) {\n+                            self.tcx().mk_region(RePlaceholder(placeholder))\n+                        } else {\n+                            self.tcx().lifetimes.re_static\n+                        }\n+                    }\n+                };\n+\n+                debug!(\"Expanding value of {:?} from empty lifetime to {:?}\", b_vid, lub);\n+\n+                *b_data = VarValue::Value(lub);\n+                true\n+            }\n             VarValue::Value(cur_region) => {\n                 // This is a specialized version of the `lub_concrete_regions`\n                 // check below for a common case, here purely as an\n@@ -508,7 +668,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         for (node_vid, value) in var_data.values.iter_enumerated() {\n             match *value {\n-                VarValue::Value(_) => { /* Inference successful */ }\n+                VarValue::Empty(_) | VarValue::Value(_) => { /* Inference successful */ }\n                 VarValue::ErrorValue => {\n                     // Inference impossible: this value contains\n                     // inconsistent constraints.\n@@ -876,6 +1036,7 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n     ) -> ty::Region<'tcx> {\n         let result = match *r {\n             ty::ReVar(rid) => match self.values[rid] {\n+                VarValue::Empty(vid_universe) => tcx.mk_region(ty::ReEmpty(vid_universe)),\n                 VarValue::Value(r) => r,\n                 VarValue::ErrorValue => tcx.lifetimes.re_static,\n             },"}, {"sha": "9d3a1a4a031aed171163b2b9bfaaf31a5e975496", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f29c91bf1245fc01853b0f1d8913139b3b355f63/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29c91bf1245fc01853b0f1d8913139b3b355f63/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=f29c91bf1245fc01853b0f1d8913139b3b355f63", "patch": "@@ -101,6 +101,7 @@ pub fn trait_obligations<'a, 'tcx>(\n     wf.normalize(infcx)\n }\n \n+#[instrument(skip(infcx), ret)]\n pub fn predicate_obligations<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -440,6 +441,7 @@ impl<'tcx> WfPredicates<'tcx> {\n         let param_env = self.param_env;\n         let depth = self.recursion_depth;\n         while let Some(arg) = walker.next() {\n+            debug!(?arg, ?self.out);\n             let ty = match arg.unpack() {\n                 GenericArgKind::Type(ty) => ty,\n \n@@ -689,6 +691,8 @@ impl<'tcx> WfPredicates<'tcx> {\n                     ));\n                 }\n             }\n+\n+            debug!(?self.out);\n         }\n     }\n "}, {"sha": "ab143c059820dc1497f2157f3287789786d2abab", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f29c91bf1245fc01853b0f1d8913139b3b355f63/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29c91bf1245fc01853b0f1d8913139b3b355f63/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=f29c91bf1245fc01853b0f1d8913139b3b355f63", "patch": "@@ -144,6 +144,8 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n     let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n \n+    debug!(?assumptions_in_impl_context, ?dtor_predicates.predicates);\n+\n     let self_param_env = tcx.param_env(self_type_did);\n \n     // An earlier version of this code attempted to do this checking"}, {"sha": "b0ce0de1469b953dd33afd8427e8af0227f9bbc5", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f29c91bf1245fc01853b0f1d8913139b3b355f63/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29c91bf1245fc01853b0f1d8913139b3b355f63/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=f29c91bf1245fc01853b0f1d8913139b3b355f63", "patch": "@@ -1816,6 +1816,7 @@ fn report_bivariance(\n impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n     /// Feature gates RFC 2056 -- trivial bounds, checking for global bounds that\n     /// aren't true.\n+    #[instrument(level = \"debug\", skip(self))]\n     fn check_false_global_bounds(&mut self) {\n         let tcx = self.ocx.infcx.tcx;\n         let mut span = self.span;"}, {"sha": "c2a34b91ad672825f651c72e69deab892ef2eefb", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f29c91bf1245fc01853b0f1d8913139b3b355f63/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29c91bf1245fc01853b0f1d8913139b3b355f63/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=f29c91bf1245fc01853b0f1d8913139b3b355f63", "patch": "@@ -1808,6 +1808,7 @@ pub fn get_infer_ret_ty<'hir>(output: &'hir hir::FnRetTy<'hir>) -> Option<&'hir\n     None\n }\n \n+#[instrument(level = \"debug\", skip(tcx))]\n fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n     use rustc_hir::Node::*;\n     use rustc_hir::*;\n@@ -2038,8 +2039,8 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx: 'a>(\n /// Returns a list of type predicates for the definition with ID `def_id`, including inferred\n /// lifetime constraints. This includes all predicates returned by `explicit_predicates_of`, plus\n /// inferred constraints concerning which regions outlive other regions.\n+#[instrument(level = \"debug\", skip(tcx))]\n fn predicates_defined_on(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n-    debug!(\"predicates_defined_on({:?})\", def_id);\n     let mut result = tcx.explicit_predicates_of(def_id);\n     debug!(\"predicates_defined_on: explicit_predicates_of({:?}) = {:?}\", def_id, result,);\n     let inferred_outlives = tcx.inferred_outlives_of(def_id);"}]}