{"sha": "47ef20014c32443b12a122c0371a87f513830807", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZWYyMDAxNGMzMjQ0M2IxMmExMjJjMDM3MWE4N2Y1MTM4MzA4MDc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-06T23:23:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-12T00:32:00Z"}, "message": "Shuffle around ownership in concurrent queues\n\nBeforehand, using a concurrent queue always mandated that the \"shared state\" be\nstored internally to the queues in order to provide a safe interface. This isn't\nquite as flexible as one would want in some circumstances, so instead this\ncommit moves the queues to not containing the shared state.\n\nThe queues no longer have a \"default useful safe\" interface, but rather a\n\"default safe\" interface (minus the useful part). The queues have to be shared\nmanually through an Arc or some other means. This allows them to be a little\nmore flexible at the cost of a usability hindrance.\n\nI plan on using this new flexibility to upgrade a channel to a shared channel\nseamlessly.", "tree": {"sha": "f31f158b6c0c0718a8b54910746eef0f24290aa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f31f158b6c0c0718a8b54910746eef0f24290aa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47ef20014c32443b12a122c0371a87f513830807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47ef20014c32443b12a122c0371a87f513830807", "html_url": "https://github.com/rust-lang/rust/commit/47ef20014c32443b12a122c0371a87f513830807", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47ef20014c32443b12a122c0371a87f513830807/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "html_url": "https://github.com/rust-lang/rust/commit/0ac6e5afda2a9741d50d6b5c557ee16fee44878f"}], "stats": {"total": 717, "additions": 344, "deletions": 373}, "files": [{"sha": "495f6ead1cae6a383e50d4db4b88eb318c76ec72", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47ef20014c32443b12a122c0371a87f513830807/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ef20014c32443b12a122c0371a87f513830807/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=47ef20014c32443b12a122c0371a87f513830807", "patch": "@@ -193,6 +193,7 @@ use task::GreenTask;\n \n mod macros;\n mod simple;\n+mod message_queue;\n \n pub mod basic;\n pub mod context;"}, {"sha": "3a118476affb7c3aed3ea9f515732cc058f3563b", "filename": "src/libgreen/message_queue.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/47ef20014c32443b12a122c0371a87f513830807/src%2Flibgreen%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ef20014c32443b12a122c0371a87f513830807/src%2Flibgreen%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fmessage_queue.rs?ref=47ef20014c32443b12a122c0371a87f513830807", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use mpsc = std::sync::mpsc_queue;\n+use std::sync::arc::UnsafeArc;\n+\n+pub enum PopResult<T> {\n+    Inconsistent,\n+    Empty,\n+    Data(T),\n+}\n+\n+pub fn queue<T: Send>() -> (Consumer<T>, Producer<T>) {\n+    let (a, b) = UnsafeArc::new2(mpsc::Queue::new());\n+    (Consumer { inner: a }, Producer { inner: b })\n+}\n+\n+pub struct Producer<T> {\n+    priv inner: UnsafeArc<mpsc::Queue<T>>,\n+}\n+\n+pub struct Consumer<T> {\n+    priv inner: UnsafeArc<mpsc::Queue<T>>,\n+}\n+\n+impl<T: Send> Consumer<T> {\n+    pub fn pop(&mut self) -> PopResult<T> {\n+        match unsafe { (*self.inner.get()).pop() } {\n+            mpsc::Inconsistent => Inconsistent,\n+            mpsc::Empty => Empty,\n+            mpsc::Data(t) => Data(t),\n+        }\n+    }\n+\n+    pub fn casual_pop(&mut self) -> Option<T> {\n+        match unsafe { (*self.inner.get()).pop() } {\n+            mpsc::Inconsistent => None,\n+            mpsc::Empty => None,\n+            mpsc::Data(t) => Some(t),\n+        }\n+    }\n+}\n+\n+impl<T: Send> Producer<T> {\n+    pub fn push(&mut self, t: T) {\n+        unsafe { (*self.inner.get()).push(t); }\n+    }\n+}\n+\n+impl<T: Send> Clone for Producer<T> {\n+    fn clone(&self) -> Producer<T> {\n+        Producer { inner: self.inner.clone() }\n+    }\n+}"}, {"sha": "bf6e0c3430e9ccb6b8d8d1aa5fe4a6f55c00cb36", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/47ef20014c32443b12a122c0371a87f513830807/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ef20014c32443b12a122c0371a87f513830807/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=47ef20014c32443b12a122c0371a87f513830807", "patch": "@@ -17,14 +17,14 @@ use std::rt::task::Task;\n use std::sync::deque;\n use std::unstable::mutex::Mutex;\n use std::unstable::raw;\n-use mpsc = std::sync::mpsc_queue;\n \n use TaskState;\n use context::Context;\n use coroutine::Coroutine;\n use sleeper_list::SleeperList;\n use stack::StackPool;\n use task::{TypeSched, GreenTask, HomeSched, AnySched};\n+use msgq = message_queue;\n \n /// A scheduler is responsible for coordinating the execution of Tasks\n /// on a single thread. The scheduler runs inside a slightly modified\n@@ -47,9 +47,9 @@ pub struct Scheduler {\n     /// The queue of incoming messages from other schedulers.\n     /// These are enqueued by SchedHandles after which a remote callback\n     /// is triggered to handle the message.\n-    message_queue: mpsc::Consumer<SchedMessage, ()>,\n+    message_queue: msgq::Consumer<SchedMessage>,\n     /// Producer used to clone sched handles from\n-    message_producer: mpsc::Producer<SchedMessage, ()>,\n+    message_producer: msgq::Producer<SchedMessage>,\n     /// A shared list of sleeping schedulers. We'll use this to wake\n     /// up schedulers when pushing work onto the work queue.\n     sleeper_list: SleeperList,\n@@ -143,7 +143,7 @@ impl Scheduler {\n                        state: TaskState)\n         -> Scheduler {\n \n-        let (consumer, producer) = mpsc::queue(());\n+        let (consumer, producer) = msgq::queue();\n         let mut sched = Scheduler {\n             pool_id: pool_id,\n             sleeper_list: sleeper_list,\n@@ -215,7 +215,7 @@ impl Scheduler {\n \n         // Should not have any messages\n         let message = stask.sched.get_mut_ref().message_queue.pop();\n-        rtassert!(match message { mpsc::Empty => true, _ => false });\n+        rtassert!(match message { msgq::Empty => true, _ => false });\n \n         stask.task.get_mut_ref().destroyed = true;\n     }\n@@ -340,8 +340,8 @@ impl Scheduler {\n             //\n             // I have chosen to take route #2.\n             match self.message_queue.pop() {\n-                mpsc::Data(t) => Some(t),\n-                mpsc::Empty | mpsc::Inconsistent => None\n+                msgq::Data(t) => Some(t),\n+                msgq::Empty | msgq::Inconsistent => None\n             }\n         };\n \n@@ -849,7 +849,7 @@ pub enum SchedMessage {\n \n pub struct SchedHandle {\n     priv remote: ~RemoteCallback,\n-    priv queue: mpsc::Producer<SchedMessage, ()>,\n+    priv queue: msgq::Producer<SchedMessage>,\n     sched_id: uint\n }\n "}, {"sha": "5b697e0d73d0802fbe14b3233a65c41e18701911", "filename": "src/librustuv/queue.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/47ef20014c32443b12a122c0371a87f513830807/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ef20014c32443b12a122c0371a87f513830807/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=47ef20014c32443b12a122c0371a87f513830807", "patch": "@@ -24,6 +24,7 @@ use std::cast;\n use std::libc::{c_void, c_int};\n use std::rt::task::BlockedTask;\n use std::unstable::sync::LittleLock;\n+use std::sync::arc::UnsafeArc;\n use mpsc = std::sync::mpsc_queue;\n \n use async::AsyncWatcher;\n@@ -39,46 +40,46 @@ enum Message {\n struct State {\n     handle: *uvll::uv_async_t,\n     lock: LittleLock, // see comments in async_cb for why this is needed\n+    queue: mpsc::Queue<Message>,\n }\n \n /// This structure is intended to be stored next to the event loop, and it is\n /// used to create new `Queue` structures.\n pub struct QueuePool {\n-    priv producer: mpsc::Producer<Message, State>,\n-    priv consumer: mpsc::Consumer<Message, State>,\n+    priv queue: UnsafeArc<State>,\n     priv refcnt: uint,\n }\n \n /// This type is used to send messages back to the original event loop.\n pub struct Queue {\n-    priv queue: mpsc::Producer<Message, State>,\n+    priv queue: UnsafeArc<State>,\n }\n \n extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n     assert_eq!(status, 0);\n-    let state: &mut QueuePool = unsafe {\n+    let pool: &mut QueuePool = unsafe {\n         cast::transmute(uvll::get_data_for_uv_handle(handle))\n     };\n-    let packet = unsafe { state.consumer.packet() };\n+    let state: &mut State = unsafe { cast::transmute(pool.queue.get()) };\n \n     // Remember that there is no guarantee about how many times an async\n     // callback is called with relation to the number of sends, so process the\n     // entire queue in a loop.\n     loop {\n-        match state.consumer.pop() {\n+        match state.queue.pop() {\n             mpsc::Data(Task(task)) => {\n                 let _ = task.wake().map(|t| t.reawaken());\n             }\n             mpsc::Data(Increment) => unsafe {\n-                if state.refcnt == 0 {\n-                    uvll::uv_ref((*packet).handle);\n+                if pool.refcnt == 0 {\n+                    uvll::uv_ref(state.handle);\n                 }\n-                state.refcnt += 1;\n+                pool.refcnt += 1;\n             },\n             mpsc::Data(Decrement) => unsafe {\n-                state.refcnt -= 1;\n-                if state.refcnt == 0 {\n-                    uvll::uv_unref((*packet).handle);\n+                pool.refcnt -= 1;\n+                if pool.refcnt == 0 {\n+                    uvll::uv_unref(state.handle);\n                 }\n             },\n             mpsc::Empty | mpsc::Inconsistent => break\n@@ -99,24 +100,24 @@ extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n     // If we acquire the mutex here, then we are guaranteed that there are no\n     // longer any senders which are holding on to their handles, so we can\n     // safely allow the event loop to exit.\n-    if state.refcnt == 0 {\n+    if pool.refcnt == 0 {\n         unsafe {\n-            let _l = (*packet).lock.lock();\n+            let _l = state.lock.lock();\n         }\n     }\n }\n \n impl QueuePool {\n     pub fn new(loop_: &mut Loop) -> ~QueuePool {\n         let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n-        let (c, p) = mpsc::queue(State {\n+        let state = UnsafeArc::new(State {\n             handle: handle,\n             lock: LittleLock::new(),\n+            queue: mpsc::Queue::new(),\n         });\n         let q = ~QueuePool {\n-            producer: p,\n-            consumer: c,\n             refcnt: 0,\n+            queue: state,\n         };\n \n         unsafe {\n@@ -132,23 +133,23 @@ impl QueuePool {\n     pub fn queue(&mut self) -> Queue {\n         unsafe {\n             if self.refcnt == 0 {\n-                uvll::uv_ref((*self.producer.packet()).handle);\n+                uvll::uv_ref((*self.queue.get()).handle);\n             }\n             self.refcnt += 1;\n         }\n-        Queue { queue: self.producer.clone() }\n+        Queue { queue: self.queue.clone() }\n     }\n \n     pub fn handle(&self) -> *uvll::uv_async_t {\n-        unsafe { (*self.producer.packet()).handle }\n+        unsafe { (*self.queue.get()).handle }\n     }\n }\n \n impl Queue {\n     pub fn push(&mut self, task: BlockedTask) {\n-        self.queue.push(Task(task));\n         unsafe {\n-            uvll::uv_async_send((*self.queue.packet()).handle);\n+            (*self.queue.get()).queue.push(Task(task));\n+            uvll::uv_async_send((*self.queue.get()).handle);\n         }\n     }\n }\n@@ -161,7 +162,7 @@ impl Clone for Queue {\n         // and if the queue is dropped later on it'll see the increment for the\n         // decrement anyway.\n         unsafe {\n-            cast::transmute_mut(self).queue.push(Increment);\n+            (*self.queue.get()).queue.push(Increment);\n         }\n         Queue { queue: self.queue.clone() }\n     }\n@@ -172,9 +173,9 @@ impl Drop for Queue {\n         // See the comments in the async_cb function for why there is a lock\n         // that is acquired only on a drop.\n         unsafe {\n-            let state = self.queue.packet();\n+            let state = self.queue.get();\n             let _l = (*state).lock.lock();\n-            self.queue.push(Decrement);\n+            (*state).queue.push(Decrement);\n             uvll::uv_async_send((*state).handle);\n         }\n     }"}, {"sha": "63d691006713b63bae8c10e9354337d58d4fca7f", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 65, "deletions": 67, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/47ef20014c32443b12a122c0371a87f513830807/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ef20014c32443b12a122c0371a87f513830807/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=47ef20014c32443b12a122c0371a87f513830807", "patch": "@@ -238,6 +238,7 @@ use result::{Ok, Err};\n use rt::local::Local;\n use rt::task::{Task, BlockedTask};\n use rt::thread::Thread;\n+use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicInt, AtomicBool, SeqCst, Relaxed};\n use vec::OwnedVector;\n \n@@ -273,33 +274,14 @@ macro_rules! test (\n \n mod select;\n \n-///////////////////////////////////////////////////////////////////////////////\n-// Helper type to abstract ports for channels and shared channels\n-///////////////////////////////////////////////////////////////////////////////\n-\n-enum Consumer<T> {\n-    SPSC(spsc::Consumer<T, Packet>),\n-    MPSC(mpsc::Consumer<T, Packet>),\n-}\n-\n-impl<T: Send> Consumer<T>{\n-    unsafe fn packet(&self) -> *mut Packet {\n-        match *self {\n-            SPSC(ref c) => c.packet(),\n-            MPSC(ref c) => c.packet(),\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////////\n // Public structs\n ///////////////////////////////////////////////////////////////////////////////\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n pub struct Port<T> {\n-    priv queue: Consumer<T>,\n-\n+    priv inner: PortInner<T>,\n     // can't share in an arc\n     priv marker: marker::NoFreeze,\n }\n@@ -314,17 +296,14 @@ pub struct Messages<'a, T> {\n /// The sending-half of Rust's channel type. This half can only be owned by one\n /// task\n pub struct Chan<T> {\n-    priv queue: spsc::Producer<T, Packet>,\n-\n+    priv inner: UnsafeArc<SingleInner<T>>,\n     // can't share in an arc\n     priv marker: marker::NoFreeze,\n }\n \n /// The sending-half of Rust's channel type. This half can be shared among many\n /// tasks by creating copies of itself through the `clone` method.\n pub struct SharedChan<T> {\n-    priv queue: mpsc::Producer<T, Packet>,\n-\n     // can't share in an arc -- technically this implementation is\n     // shareable, but it shouldn't be required to be shareable in an\n     // arc\n@@ -349,16 +328,26 @@ pub enum TryRecvResult<T> {\n // Internal struct definitions\n ///////////////////////////////////////////////////////////////////////////////\n \n+enum PortInner<T> {\n+    Single(UnsafeArc<SingleInner<T>>),\n+    Shared(UnsafeArc<SharedInner<T>>),\n+}\n+\n+struct SingleInner<T> {\n+    queue: spsc::Queue<T>,\n+    packet: Packet,\n+}\n+\n+struct SharedInner<T> {\n+    queue: mpsc::Queue<T>,\n+    packet: Packet,\n+}\n+\n struct Packet {\n     cnt: AtomicInt, // How many items are on this channel\n     steals: int,    // How many times has a port received without blocking?\n     to_wake: Option<BlockedTask>, // Task to wake up\n \n-    // This lock is used to wake up native threads blocked in select. The\n-    // `lock` field is not used because the thread blocking in select must\n-    // block on only one mutex.\n-    //selection_lock: Option<UnsafeArc<Mutex>>,\n-\n     // The number of channels which are currently using this packet. This is\n     // used to reference count shared channels.\n     channels: AtomicInt,\n@@ -377,6 +366,15 @@ struct Packet {\n static DISCONNECTED: int = int::MIN;\n static RESCHED_FREQ: int = 200;\n \n+impl<T: Send> PortInner<T> {\n+    fn packet<'a>(&'a mut self) -> &'a mut Packet {\n+        match *self {\n+            Single(ref arc) => unsafe { &mut (*arc.get()).packet },\n+            Shared(ref arc) => unsafe { &mut (*arc.get()).packet },\n+        }\n+    }\n+}\n+\n impl Packet {\n     fn new() -> Packet {\n         Packet {\n@@ -550,10 +548,12 @@ impl<T: Send> Chan<T> {\n     pub fn new() -> (Port<T>, Chan<T>) {\n         // arbitrary 128 size cache -- this is just a max cache size, not a\n         // maximum buffer size\n-        let (c, p) = spsc::queue(128, Packet::new());\n-        let c = SPSC(c);\n-        (Port { queue: c, marker: marker::NoFreeze },\n-         Chan { queue: p, marker: marker::NoFreeze })\n+        let (a, b) = UnsafeArc::new2(SingleInner {\n+            queue: spsc::Queue::new(128),\n+            packet: Packet::new(),\n+        });\n+        (Port { inner: Single(a), marker: marker::NoFreeze },\n+         Chan { inner: b, marker: marker::NoFreeze })\n     }\n \n     /// Sends a value along this channel to be received by the corresponding\n@@ -596,16 +596,15 @@ impl<T: Send> Chan<T> {\n     /// be tolerated, then this method should be used instead.\n     pub fn try_send(&self, t: T) -> bool {\n         unsafe {\n-            let this = cast::transmute_mut(self);\n-            this.queue.push(t);\n-            let packet = this.queue.packet();\n-            match (*packet).increment() {\n+            let inner = self.inner.get();\n+            (*inner).queue.push(t);\n+            match (*inner).packet.increment() {\n                 // As described above, -1 == wakeup\n-                -1 => { (*packet).wakeup(); true }\n+                -1 => { (*inner).packet.wakeup(); true }\n                 // Also as above, SPSC queues must be >= -2\n                 -2 => true,\n                 // We succeeded if we sent data\n-                DISCONNECTED => this.queue.is_empty(),\n+                DISCONNECTED => (*inner).queue.is_empty(),\n                 // In order to prevent starvation of other tasks in situations\n                 // where a task sends repeatedly without ever receiving, we\n                 // occassionally yield instead of doing a send immediately.\n@@ -630,7 +629,7 @@ impl<T: Send> Chan<T> {\n #[unsafe_destructor]\n impl<T: Send> Drop for Chan<T> {\n     fn drop(&mut self) {\n-        unsafe { (*self.queue.packet()).drop_chan(); }\n+        unsafe { (*self.inner.get()).packet.drop_chan(); }\n     }\n }\n \n@@ -640,10 +639,13 @@ impl<T: Send> SharedChan<T> {\n     /// same time. All data sent on any channel will become available on the\n     /// provided port as well.\n     pub fn new() -> (Port<T>, SharedChan<T>) {\n-        let (c, p) = mpsc::queue(Packet::new());\n-        let c = MPSC(c);\n-        (Port { queue: c, marker: marker::NoFreeze },\n-         SharedChan { queue: p, marker: marker::NoFreeze })\n+        let (a, b) = UnsafeArc::new2(SharedInner {\n+            queue: mpsc::Queue::new(),\n+            packet: Packet::new(),\n+        });\n+        (Port { inner: Shared(a), marker: marker::NoFreeze },\n+         SharedChan { inner: b, marker: marker::NoFreeze })\n+        (Port { inner: Shared(a) }, SharedChan { inner: b })\n     }\n \n     /// Equivalent method to `send` on the `Chan` type (using the same\n@@ -683,17 +685,15 @@ impl<T: Send> SharedChan<T> {\n             // preflight check serves as the definitive \"this will never be\n             // received\". Once we get beyond this check, we have permanently\n             // entered the realm of \"this may be received\"\n-            let packet = self.queue.packet();\n-            if (*packet).cnt.load(Relaxed) < DISCONNECTED + 1024 {\n+            let inner = self.inner.get();\n+            if (*inner).packet.cnt.load(Relaxed) < DISCONNECTED + 1024 {\n                 return false\n             }\n \n-            let this = cast::transmute_mut(self);\n-            this.queue.push(t);\n-\n-            match (*packet).increment() {\n+            (*inner).queue.push(t);\n+            match (*inner).packet.increment() {\n                 DISCONNECTED => {} // oh well, we tried\n-                -1 => { (*packet).wakeup(); }\n+                -1 => { (*inner).packet.wakeup(); }\n                 n => {\n                     if n > 0 && n % RESCHED_FREQ == 0 {\n                         let task: ~Task = Local::take();\n@@ -708,15 +708,15 @@ impl<T: Send> SharedChan<T> {\n \n impl<T: Send> Clone for SharedChan<T> {\n     fn clone(&self) -> SharedChan<T> {\n-        unsafe { (*self.queue.packet()).channels.fetch_add(1, SeqCst); }\n-        SharedChan { queue: self.queue.clone(), marker: marker::NoFreeze }\n+        unsafe { (*self.inner.get()).packet.channels.fetch_add(1, SeqCst); }\n+        SharedChan { inner: self.inner.clone(), marker: marker::NoFreeze }\n     }\n }\n \n #[unsafe_destructor]\n impl<T: Send> Drop for SharedChan<T> {\n     fn drop(&mut self) {\n-        unsafe { (*self.queue.packet()).drop_chan(); }\n+        unsafe { (*self.inner.get()).packet.drop_chan(); }\n     }\n }\n \n@@ -768,18 +768,18 @@ impl<T: Send> Port<T> {\n \n         // See the comment about yielding on sends, but the same applies here.\n         // If a thread is spinning in try_recv we should try\n-        unsafe {\n-            let packet = this.queue.packet();\n-            (*packet).recv_cnt += 1;\n-            if (*packet).recv_cnt % RESCHED_FREQ == 0 {\n+        {\n+            let packet = this.inner.packet();\n+            packet.recv_cnt += 1;\n+            if packet.recv_cnt % RESCHED_FREQ == 0 {\n                 let task: ~Task = Local::take();\n                 task.maybe_yield();\n             }\n         }\n \n-        let ret = match this.queue {\n-            SPSC(ref mut queue) => queue.pop(),\n-            MPSC(ref mut queue) => match queue.pop() {\n+        let ret = match this.inner {\n+            Single(ref mut arc) => unsafe { (*arc.get()).queue.pop() },\n+            Shared(ref mut arc) => match unsafe { (*arc.get()).queue.pop() } {\n                 mpsc::Data(t) => Some(t),\n                 mpsc::Empty => None,\n \n@@ -812,7 +812,7 @@ impl<T: Send> Port<T> {\n                     let data;\n                     loop {\n                         Thread::yield_now();\n-                        match queue.pop() {\n+                        match unsafe { (*arc.get()).queue.pop() } {\n                             mpsc::Data(t) => { data = t; break }\n                             mpsc::Empty => fail!(\"inconsistent => empty\"),\n                             mpsc::Inconsistent => {}\n@@ -823,7 +823,7 @@ impl<T: Send> Port<T> {\n             }\n         };\n         if increment && ret.is_some() {\n-            unsafe { (*this.queue.packet()).steals += 1; }\n+            this.inner.packet().steals += 1;\n         }\n         match ret {\n             Some(t) => Data(t),\n@@ -880,7 +880,7 @@ impl<T: Send> Port<T> {\n         let this;\n         unsafe {\n             this = cast::transmute_mut(self);\n-            packet = this.queue.packet();\n+            packet = this.inner.packet();\n             let task: ~Task = Local::take();\n             task.deschedule(1, |task| {\n                 assert!((*packet).to_wake.is_none());\n@@ -917,9 +917,7 @@ impl<T: Send> Drop for Port<T> {\n         // All we need to do is store that we're disconnected. If the channel\n         // half has already disconnected, then we'll just deallocate everything\n         // when the shared packet is deallocated.\n-        unsafe {\n-            (*self.queue.packet()).cnt.store(DISCONNECTED, SeqCst);\n-        }\n+        self.inner.packet().cnt.store(DISCONNECTED, SeqCst);\n     }\n }\n "}, {"sha": "cf8df86381743a689d68babeb532221086eef4fc", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/47ef20014c32443b12a122c0371a87f513830807/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ef20014c32443b12a122c0371a87f513830807/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=47ef20014c32443b12a122c0371a87f513830807", "patch": "@@ -130,18 +130,18 @@ impl Select {\n         let id = this.next_id;\n         this.next_id += 1;\n         unsafe {\n-            let packet = port.queue.packet();\n+            let packet = port.inner.packet();\n             assert!(!(*packet).selecting.load(Relaxed));\n             assert_eq!((*packet).selection_id, 0);\n             (*packet).selection_id = id;\n             if this.head.is_null() {\n-                this.head = packet;\n-                this.tail = packet;\n+                this.head = packet as *mut Packet;\n+                this.tail = packet as *mut Packet;\n             } else {\n                 (*packet).select_prev = this.tail;\n                 assert!((*packet).select_next.is_null());\n-                (*this.tail).select_next = packet;\n-                this.tail = packet;\n+                (*this.tail).select_next = packet as *mut Packet;\n+                this.tail = packet as *mut Packet;\n             }\n         }\n         Handle { id: id, selector: this, port: port }\n@@ -303,7 +303,7 @@ impl Drop for Select {\n #[unsafe_destructor]\n impl<'port, T: Send> Drop for Handle<'port, T> {\n     fn drop(&mut self) {\n-        unsafe { self.selector.remove(self.port.queue.packet()) }\n+        unsafe { self.selector.remove(self.port.inner.packet()) }\n     }\n }\n "}, {"sha": "258162069d91f9cbf4ef6906de0dd1e65a368626", "filename": "src/libstd/sync/mpsc_queue.rs", "status": "modified", "additions": 54, "deletions": 100, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/47ef20014c32443b12a122c0371a87f513830807/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ef20014c32443b12a122c0371a87f513830807/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc_queue.rs?ref=47ef20014c32443b12a122c0371a87f513830807", "patch": "@@ -39,12 +39,10 @@\n //                         /queues/non-intrusive-mpsc-node-based-queue\n \n use cast;\n-use clone::Clone;\n use kinds::Send;\n use ops::Drop;\n use option::{Option, None, Some};\n use ptr::RawPtr;\n-use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicPtr, Release, Acquire, AcqRel, Relaxed};\n \n /// A result of the `pop` function.\n@@ -65,40 +63,12 @@ struct Node<T> {\n     value: Option<T>,\n }\n \n-struct State<T, P> {\n-    head: AtomicPtr<Node<T>>,\n-    tail: *mut Node<T>,\n-    packet: P,\n-}\n-\n-/// The consumer half of this concurrent queue. This half is used to receive\n-/// data from the producers.\n-pub struct Consumer<T, P> {\n-    priv state: UnsafeArc<State<T, P>>,\n-}\n-\n-/// The production half of the concurrent queue. This handle may be cloned in\n-/// order to make handles for new producers.\n-pub struct Producer<T, P> {\n-    priv state: UnsafeArc<State<T, P>>,\n-}\n-\n-impl<T: Send, P: Send> Clone for Producer<T, P> {\n-    fn clone(&self) -> Producer<T, P> {\n-        Producer { state: self.state.clone() }\n-    }\n-}\n-\n-/// Creates a new MPSC queue. The given argument `p` is a user-defined \"packet\"\n-/// of information which will be shared by the consumer and the producer which\n-/// can be re-acquired via the `packet` function. This is helpful when extra\n-/// state is shared between the producer and consumer, but note that there is no\n-/// synchronization performed of this data.\n-pub fn queue<T: Send, P: Send>(p: P) -> (Consumer<T, P>, Producer<T, P>) {\n-    unsafe {\n-        let (a, b) = UnsafeArc::new2(State::new(p));\n-        (Consumer { state: a }, Producer { state: b })\n-    }\n+/// The multi-producer single-consumer structure. This is not cloneable, but it\n+/// may be safely shared so long as it is guaranteed that there is only one\n+/// popper at a time (many pushers are allowed).\n+pub struct Queue<T> {\n+    priv head: AtomicPtr<Node<T>>,\n+    priv tail: *mut Node<T>,\n }\n \n impl<T> Node<T> {\n@@ -110,67 +80,26 @@ impl<T> Node<T> {\n     }\n }\n \n-impl<T: Send, P: Send> State<T, P> {\n-    unsafe fn new(p: P) -> State<T, P> {\n-        let stub = Node::new(None);\n-        State {\n+impl<T: Send> Queue<T> {\n+    /// Creates a new queue that is safe to share among multiple producers and\n+    /// one consumer.\n+    pub fn new() -> Queue<T> {\n+        let stub = unsafe { Node::new(None) };\n+        Queue {\n             head: AtomicPtr::new(stub),\n             tail: stub,\n-            packet: p,\n         }\n     }\n \n-    unsafe fn push(&mut self, t: T) {\n-        let n = Node::new(Some(t));\n-        let prev = self.head.swap(n, AcqRel);\n-        (*prev).next.store(n, Release);\n-    }\n-\n-    unsafe fn pop(&mut self) -> PopResult<T> {\n-        let tail = self.tail;\n-        let next = (*tail).next.load(Acquire);\n-\n-        if !next.is_null() {\n-            self.tail = next;\n-            assert!((*tail).value.is_none());\n-            assert!((*next).value.is_some());\n-            let ret = (*next).value.take_unwrap();\n-            let _: ~Node<T> = cast::transmute(tail);\n-            return Data(ret);\n-        }\n-\n-        if self.head.load(Acquire) == tail {Empty} else {Inconsistent}\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T: Send, P: Send> Drop for State<T, P> {\n-    fn drop(&mut self) {\n+    /// Pushes a new value onto this queue.\n+    pub fn push(&mut self, t: T) {\n         unsafe {\n-            let mut cur = self.tail;\n-            while !cur.is_null() {\n-                let next = (*cur).next.load(Relaxed);\n-                let _: ~Node<T> = cast::transmute(cur);\n-                cur = next;\n-            }\n+            let n = Node::new(Some(t));\n+            let prev = self.head.swap(n, AcqRel);\n+            (*prev).next.store(n, Release);\n         }\n     }\n-}\n-\n-impl<T: Send, P: Send> Producer<T, P> {\n-    /// Pushes a new value onto this queue.\n-    pub fn push(&mut self, value: T) {\n-        unsafe { (*self.state.get()).push(value) }\n-    }\n-    /// Gets an unsafe pointer to the user-defined packet shared by the\n-    /// producers and the consumer. Note that care must be taken to ensure that\n-    /// the lifetime of the queue outlives the usage of the returned pointer.\n-    pub unsafe fn packet(&self) -> *mut P {\n-        &mut (*self.state.get()).packet as *mut P\n-    }\n-}\n \n-impl<T: Send, P: Send> Consumer<T, P> {\n     /// Pops some data from this queue.\n     ///\n     /// Note that the current implementation means that this function cannot\n@@ -182,8 +111,23 @@ impl<T: Send, P: Send> Consumer<T, P> {\n     /// This inconsistent state means that this queue does indeed have data, but\n     /// it does not currently have access to it at this time.\n     pub fn pop(&mut self) -> PopResult<T> {\n-        unsafe { (*self.state.get()).pop() }\n+        unsafe {\n+            let tail = self.tail;\n+            let next = (*tail).next.load(Acquire);\n+\n+            if !next.is_null() {\n+                self.tail = next;\n+                assert!((*tail).value.is_none());\n+                assert!((*next).value.is_some());\n+                let ret = (*next).value.take_unwrap();\n+                let _: ~Node<T> = cast::transmute(tail);\n+                return Data(ret);\n+            }\n+\n+            if self.head.load(Acquire) == tail {Empty} else {Inconsistent}\n+        }\n     }\n+\n     /// Attempts to pop data from this queue, but doesn't attempt too hard. This\n     /// will canonicalize inconsistent states to a `None` value.\n     pub fn casual_pop(&mut self) -> Option<T> {\n@@ -192,23 +136,32 @@ impl<T: Send, P: Send> Consumer<T, P> {\n             Empty | Inconsistent => None,\n         }\n     }\n-    /// Gets an unsafe pointer to the underlying user-defined packet. See\n-    /// `Producer.packet` for more information.\n-    pub unsafe fn packet(&self) -> *mut P {\n-        &mut (*self.state.get()).packet as *mut P\n+}\n+\n+#[unsafe_destructor]\n+impl<T: Send> Drop for Queue<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let mut cur = self.tail;\n+            while !cur.is_null() {\n+                let next = (*cur).next.load(Relaxed);\n+                let _: ~Node<T> = cast::transmute(cur);\n+                cur = next;\n+            }\n+        }\n     }\n }\n \n #[cfg(test)]\n mod tests {\n     use prelude::*;\n \n-    use super::{queue, Data, Empty, Inconsistent};\n+    use super::{Queue, Data, Empty, Inconsistent};\n     use native;\n \n     #[test]\n     fn test_full() {\n-        let (_, mut p) = queue(());\n+        let mut q = Queue::new();\n         p.push(~1);\n         p.push(~2);\n     }\n@@ -217,32 +170,33 @@ mod tests {\n     fn test() {\n         let nthreads = 8u;\n         let nmsgs = 1000u;\n-        let (mut c, p) = queue(());\n+        let mut q = Queue::new();\n         match c.pop() {\n             Empty => {}\n             Inconsistent | Data(..) => fail!()\n         }\n         let (port, chan) = SharedChan::new();\n+        let q = UnsafeArc::new(q);\n \n         for _ in range(0, nthreads) {\n-            let q = p.clone();\n             let chan = chan.clone();\n+            let q = q.clone();\n             native::task::spawn(proc() {\n-                let mut q = q;\n                 for i in range(0, nmsgs) {\n-                    q.push(i);\n+                    unsafe { (*q.get()).push(i); }\n                 }\n                 chan.send(());\n             });\n         }\n \n         let mut i = 0u;\n         while i < nthreads * nmsgs {\n-            match c.pop() {\n+            match unsafe { (*q.get()).pop() } {\n                 Empty | Inconsistent => {},\n                 Data(_) => { i += 1 }\n             }\n         }\n+        drop(chan);\n         for _ in range(0, nthreads) {\n             port.recv();\n         }"}, {"sha": "d1fde759cc16278c12914265d72f0365780c401a", "filename": "src/libstd/sync/spsc_queue.rs", "status": "modified", "additions": 123, "deletions": 167, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/47ef20014c32443b12a122c0371a87f513830807/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ef20014c32443b12a122c0371a87f513830807/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fspsc_queue.rs?ref=47ef20014c32443b12a122c0371a87f513830807", "patch": "@@ -38,7 +38,6 @@ use kinds::Send;\n use ops::Drop;\n use option::{Some, None, Option};\n use ptr::RawPtr;\n-use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicPtr, Relaxed, AtomicUint, Acquire, Release};\n \n // Node within the linked list queue of messages to send\n@@ -50,75 +49,25 @@ struct Node<T> {\n     next: AtomicPtr<Node<T>>,   // next node in the queue\n }\n \n-// The producer/consumer halves both need access to the `tail` field, and if\n-// they both have access to that we may as well just give them both access\n-// to this whole structure.\n-struct State<T, P> {\n+/// The single-producer single-consumer queue. This structure is not cloneable,\n+/// but it can be safely shared in an UnsafeArc if it is guaranteed that there\n+/// is only one popper and one pusher touching the queue at any one point in\n+/// time.\n+pub struct Queue<T> {\n     // consumer fields\n-    tail: *mut Node<T>, // where to pop from\n-    tail_prev: AtomicPtr<Node<T>>, // where to pop from\n+    priv tail: *mut Node<T>, // where to pop from\n+    priv tail_prev: AtomicPtr<Node<T>>, // where to pop from\n \n     // producer fields\n-    head: *mut Node<T>,      // where to push to\n-    first: *mut Node<T>,     // where to get new nodes from\n-    tail_copy: *mut Node<T>, // between first/tail\n+    priv head: *mut Node<T>,      // where to push to\n+    priv first: *mut Node<T>,     // where to get new nodes from\n+    priv tail_copy: *mut Node<T>, // between first/tail\n \n     // Cache maintenance fields. Additions and subtractions are stored\n     // separately in order to allow them to use nonatomic addition/subtraction.\n-    cache_bound: uint,\n-    cache_additions: AtomicUint,\n-    cache_subtractions: AtomicUint,\n-\n-    packet: P,\n-}\n-\n-/// Producer half of this queue. This handle is used to push data to the\n-/// consumer.\n-pub struct Producer<T, P> {\n-    priv state: UnsafeArc<State<T, P>>,\n-}\n-\n-/// Consumer half of this queue. This handle is used to receive data from the\n-/// producer.\n-pub struct Consumer<T, P> {\n-    priv state: UnsafeArc<State<T, P>>,\n-}\n-\n-/// Creates a new queue. The producer returned is connected to the consumer to\n-/// push all data to the consumer.\n-///\n-/// # Arguments\n-///\n-///   * `bound` - This queue implementation is implemented with a linked list,\n-///               and this means that a push is always a malloc. In order to\n-///               amortize this cost, an internal cache of nodes is maintained\n-///               to prevent a malloc from always being necessary. This bound is\n-///               the limit on the size of the cache (if desired). If the value\n-///               is 0, then the cache has no bound. Otherwise, the cache will\n-///               never grow larger than `bound` (although the queue itself\n-///               could be much larger.\n-///\n-///   * `p` - This is the user-defined packet of data which will also be shared\n-///           between the producer and consumer.\n-pub fn queue<T: Send, P: Send>(bound: uint,\n-                               p: P) -> (Consumer<T, P>, Producer<T, P>)\n-{\n-    let n1 = Node::new();\n-    let n2 = Node::new();\n-    unsafe { (*n1).next.store(n2, Relaxed) }\n-    let state = State {\n-        tail: n2,\n-        tail_prev: AtomicPtr::new(n1),\n-        head: n2,\n-        first: n1,\n-        tail_copy: n1,\n-        cache_bound: bound,\n-        cache_additions: AtomicUint::new(0),\n-        cache_subtractions: AtomicUint::new(0),\n-        packet: p,\n-    };\n-    let (arc1, arc2) = UnsafeArc::new2(state);\n-    (Consumer { state: arc1 }, Producer { state: arc2 })\n+    priv cache_bound: uint,\n+    priv cache_additions: AtomicUint,\n+    priv cache_subtractions: AtomicUint,\n }\n \n impl<T: Send> Node<T> {\n@@ -132,49 +81,49 @@ impl<T: Send> Node<T> {\n     }\n }\n \n-impl<T: Send, P: Send> Producer<T, P> {\n-    /// Pushes data onto the queue\n-    pub fn push(&mut self, t: T) {\n-        unsafe { (*self.state.get()).push(t) }\n-    }\n-    /// Tests whether the queue is empty. Note that if this function returns\n-    /// `false`, the return value is significant, but if the return value is\n-    /// `true` then almost no meaning can be attached to the return value.\n-    pub fn is_empty(&self) -> bool {\n-        unsafe { (*self.state.get()).is_empty() }\n-    }\n-    /// Acquires an unsafe pointer to the underlying user-defined packet. Note\n-    /// that care must be taken to ensure that the queue outlives the usage of\n-    /// the packet (because it is an unsafe pointer).\n-    pub unsafe fn packet(&self) -> *mut P {\n-        &mut (*self.state.get()).packet as *mut P\n-    }\n-}\n-\n-impl<T: Send, P: Send> Consumer<T, P> {\n-    /// Pops some data from this queue, returning `None` when the queue is\n-    /// empty.\n-    pub fn pop(&mut self) -> Option<T> {\n-        unsafe { (*self.state.get()).pop() }\n-    }\n-    /// Same function as the producer's `packet` method.\n-    pub unsafe fn packet(&self) -> *mut P {\n-        &mut (*self.state.get()).packet as *mut P\n+impl<T: Send> Queue<T> {\n+    /// Creates a new queue. The producer returned is connected to the consumer\n+    /// to push all data to the consumer.\n+    ///\n+    /// # Arguments\n+    ///\n+    ///   * `bound` - This queue implementation is implemented with a linked\n+    ///               list, and this means that a push is always a malloc. In\n+    ///               order to amortize this cost, an internal cache of nodes is\n+    ///               maintained to prevent a malloc from always being\n+    ///               necessary. This bound is the limit on the size of the\n+    ///               cache (if desired). If the value is 0, then the cache has\n+    ///               no bound. Otherwise, the cache will never grow larger than\n+    ///               `bound` (although the queue itself could be much larger.\n+    pub fn new(bound: uint) -> Queue<T> {\n+        let n1 = Node::new();\n+        let n2 = Node::new();\n+        unsafe { (*n1).next.store(n2, Relaxed) }\n+        Queue {\n+            tail: n2,\n+            tail_prev: AtomicPtr::new(n1),\n+            head: n2,\n+            first: n1,\n+            tail_copy: n1,\n+            cache_bound: bound,\n+            cache_additions: AtomicUint::new(0),\n+            cache_subtractions: AtomicUint::new(0),\n+        }\n     }\n-}\n \n-impl<T: Send, P: Send> State<T, P> {\n-    // remember that there is only one thread executing `push` (and only one\n-    // thread executing `pop`)\n-    unsafe fn push(&mut self, t: T) {\n-        // Acquire a node (which either uses a cached one or allocates a new\n-        // one), and then append this to the 'head' node.\n-        let n = self.alloc();\n-        assert!((*n).value.is_none());\n-        (*n).value = Some(t);\n-        (*n).next.store(0 as *mut Node<T>, Relaxed);\n-        (*self.head).next.store(n, Release);\n-        self.head = n;\n+    /// Pushes a new value onto this queue. Note that to use this function\n+    /// safely, it must be externally guaranteed that there is only one pusher.\n+    pub fn push(&mut self, t: T) {\n+        unsafe {\n+            // Acquire a node (which either uses a cached one or allocates a new\n+            // one), and then append this to the 'head' node.\n+            let n = self.alloc();\n+            assert!((*n).value.is_none());\n+            (*n).value = Some(t);\n+            (*n).next.store(0 as *mut Node<T>, Relaxed);\n+            (*self.head).next.store(n, Release);\n+            self.head = n;\n+        }\n     }\n \n     unsafe fn alloc(&mut self) -> *mut Node<T> {\n@@ -208,50 +157,57 @@ impl<T: Send, P: Send> State<T, P> {\n         Node::new()\n     }\n \n-    // remember that there is only one thread executing `pop` (and only one\n-    // thread executing `push`)\n-    unsafe fn pop(&mut self) -> Option<T> {\n-        // The `tail` node is not actually a used node, but rather a\n-        // sentinel from where we should start popping from. Hence, look at\n-        // tail's next field and see if we can use it. If we do a pop, then\n-        // the current tail node is a candidate for going into the cache.\n-        let tail = self.tail;\n-        let next = (*tail).next.load(Acquire);\n-        if next.is_null() { return None }\n-        assert!((*next).value.is_some());\n-        let ret = (*next).value.take();\n-\n-        self.tail = next;\n-        if self.cache_bound == 0 {\n-            self.tail_prev.store(tail, Release);\n-        } else {\n-            // FIXME: this is dubious with overflow.\n-            let additions = self.cache_additions.load(Relaxed);\n-            let subtractions = self.cache_subtractions.load(Relaxed);\n-            let size = additions - subtractions;\n+    /// Attempts to pop a value from this queue. Remember that to use this type\n+    /// safely you must ensure that there is only one popper at a time.\n+    pub fn pop(&mut self) -> Option<T> {\n+        unsafe {\n+            // The `tail` node is not actually a used node, but rather a\n+            // sentinel from where we should start popping from. Hence, look at\n+            // tail's next field and see if we can use it. If we do a pop, then\n+            // the current tail node is a candidate for going into the cache.\n+            let tail = self.tail;\n+            let next = (*tail).next.load(Acquire);\n+            if next.is_null() { return None }\n+            assert!((*next).value.is_some());\n+            let ret = (*next).value.take();\n \n-            if size < self.cache_bound {\n+            self.tail = next;\n+            if self.cache_bound == 0 {\n                 self.tail_prev.store(tail, Release);\n-                self.cache_additions.store(additions + 1, Relaxed);\n             } else {\n-                (*self.tail_prev.load(Relaxed)).next.store(next, Relaxed);\n-                // We have successfully erased all references to 'tail', so\n-                // now we can safely drop it.\n-                let _: ~Node<T> = cast::transmute(tail);\n+                // FIXME: this is dubious with overflow.\n+                let additions = self.cache_additions.load(Relaxed);\n+                let subtractions = self.cache_subtractions.load(Relaxed);\n+                let size = additions - subtractions;\n+\n+                if size < self.cache_bound {\n+                    self.tail_prev.store(tail, Release);\n+                    self.cache_additions.store(additions + 1, Relaxed);\n+                } else {\n+                    (*self.tail_prev.load(Relaxed)).next.store(next, Relaxed);\n+                    // We have successfully erased all references to 'tail', so\n+                    // now we can safely drop it.\n+                    let _: ~Node<T> = cast::transmute(tail);\n+                }\n             }\n+            return ret;\n         }\n-        return ret;\n     }\n \n-    unsafe fn is_empty(&self) -> bool {\n-        let tail = self.tail;\n-        let next = (*tail).next.load(Acquire);\n-        return next.is_null();\n+    /// Tests whether this queue is empty or not. Remember that there can only\n+    /// be one tester/popper, and also keep in mind that the answer returned\n+    /// from this is likely to change if it is `false`.\n+    pub fn is_empty(&self) -> bool {\n+        unsafe {\n+            let tail = self.tail;\n+            let next = (*tail).next.load(Acquire);\n+            return next.is_null();\n+        }\n     }\n }\n \n #[unsafe_destructor]\n-impl<T: Send, P: Send> Drop for State<T, P> {\n+impl<T: Send> Drop for Queue<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let mut cur = self.first;\n@@ -267,44 +223,44 @@ impl<T: Send, P: Send> Drop for State<T, P> {\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use super::queue;\n+    use super::Queue;\n     use native;\n \n     #[test]\n     fn smoke() {\n-        let (mut c, mut p) = queue(0, ());\n-        p.push(1);\n-        p.push(2);\n-        assert_eq!(c.pop(), Some(1));\n-        assert_eq!(c.pop(), Some(2));\n-        assert_eq!(c.pop(), None);\n-        p.push(3);\n-        p.push(4);\n-        assert_eq!(c.pop(), Some(3));\n-        assert_eq!(c.pop(), Some(4));\n-        assert_eq!(c.pop(), None);\n+        let mut q = Queue::new(0);\n+        q.push(1);\n+        q.push(2);\n+        assert_eq!(q.pop(), Some(1));\n+        assert_eq!(q.pop(), Some(2));\n+        assert_eq!(q.pop(), None);\n+        q.push(3);\n+        q.push(4);\n+        assert_eq!(q.pop(), Some(3));\n+        assert_eq!(q.pop(), Some(4));\n+        assert_eq!(q.pop(), None);\n     }\n \n     #[test]\n     fn drop_full() {\n-        let (_, mut p) = queue(0, ());\n-        p.push(~1);\n-        p.push(~2);\n+        let mut q = Queue::new(0);\n+        q.push(~1);\n+        q.push(~2);\n     }\n \n     #[test]\n     fn smoke_bound() {\n-        let (mut c, mut p) = queue(1, ());\n-        p.push(1);\n-        p.push(2);\n-        assert_eq!(c.pop(), Some(1));\n-        assert_eq!(c.pop(), Some(2));\n-        assert_eq!(c.pop(), None);\n-        p.push(3);\n-        p.push(4);\n-        assert_eq!(c.pop(), Some(3));\n-        assert_eq!(c.pop(), Some(4));\n-        assert_eq!(c.pop(), None);\n+        let mut q = Queue::new(1);\n+        q.push(1);\n+        q.push(2);\n+        assert_eq!(q.pop(), Some(1));\n+        assert_eq!(q.pop(), Some(2));\n+        assert_eq!(q.pop(), None);\n+        q.push(3);\n+        q.push(4);\n+        assert_eq!(q.pop(), Some(3));\n+        assert_eq!(q.pop(), Some(4));\n+        assert_eq!(q.pop(), None);\n     }\n \n     #[test]\n@@ -313,13 +269,13 @@ mod test {\n         stress_bound(1);\n \n         fn stress_bound(bound: uint) {\n-            let (c, mut p) = queue(bound, ());\n+            let (a, b) = UnsafeArc::new2(Queue::new(bound));\n             let (port, chan) = Chan::new();\n             native::task::spawn(proc() {\n                 let mut c = c;\n                 for _ in range(0, 100000) {\n                     loop {\n-                        match c.pop() {\n+                        match unsafe { (*b.get()).pop() } {\n                             Some(1) => break,\n                             Some(_) => fail!(),\n                             None => {}\n@@ -329,7 +285,7 @@ mod test {\n                 chan.send(());\n             });\n             for _ in range(0, 100000) {\n-                p.push(1);\n+                unsafe { (*a.get()).push(1); }\n             }\n             port.recv();\n         }"}]}