{"sha": "685fd53ada562658e8ad1a3578efa4a2da4e83f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NWZkNTNhZGE1NjI2NThlOGFkMWEzNTc4ZWZhNGEyZGE0ZTgzZjQ=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-26T09:59:31Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-08T17:58:46Z"}, "message": "BTreeMap: split off most code of append, slightly improve interfaces", "tree": {"sha": "5549020272cdff17f3a18db48ae92013baa51025", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5549020272cdff17f3a18db48ae92013baa51025"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/685fd53ada562658e8ad1a3578efa4a2da4e83f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/685fd53ada562658e8ad1a3578efa4a2da4e83f4", "html_url": "https://github.com/rust-lang/rust/commit/685fd53ada562658e8ad1a3578efa4a2da4e83f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/685fd53ada562658e8ad1a3578efa4a2da4e83f4/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1277d04db0dc8009037e872a1be7cdc2bd74a43", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1277d04db0dc8009037e872a1be7cdc2bd74a43", "html_url": "https://github.com/rust-lang/rust/commit/b1277d04db0dc8009037e872a1be7cdc2bd74a43"}], "stats": {"total": 290, "additions": 176, "deletions": 114}, "files": [{"sha": "e0362b2f37df7d61c71a9a7e9f148d7f98447034", "filename": "library/alloc/src/collections/btree/append.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/685fd53ada562658e8ad1a3578efa4a2da4e83f4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685fd53ada562658e8ad1a3578efa4a2da4e83f4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs?ref=685fd53ada562658e8ad1a3578efa4a2da4e83f4", "patch": "@@ -0,0 +1,124 @@\n+use super::map::MIN_LEN;\n+use super::merge_iter::MergeIterInner;\n+use super::node::{self, ForceResult::*, Root};\n+use core::iter::FusedIterator;\n+\n+impl<K, V> Root<K, V> {\n+    /// Appends all key-value pairs from the union of two ascending iterators,\n+    /// incrementing a `length` variable along the way. The latter makes it\n+    /// easier for the caller to avoid a leak when a drop handler panicks.\n+    ///\n+    /// If both iterators produce the same key, this method drops the pair from\n+    /// the left iterator and appends the pair from the right iterator.\n+    ///\n+    /// If you want the tree to end up in a strictly ascending order, like for\n+    /// a `BTreeMap`, both iterators should produce keys in strictly ascending\n+    /// order, each greater than all keys in the tree, including any keys\n+    /// already in the tree upon entry.\n+    pub fn append_from_sorted_iters<I>(&mut self, left: I, right: I, length: &mut usize)\n+    where\n+        K: Ord,\n+        I: Iterator<Item = (K, V)> + FusedIterator,\n+    {\n+        // We prepare to merge `left` and `right` into a sorted sequence in linear time.\n+        let iter = MergeIter(MergeIterInner::new(left, right));\n+\n+        // Meanwhile, we build a tree from the sorted sequence in linear time.\n+        self.bulk_push(iter, length)\n+    }\n+\n+    /// Pushes all key-value pairs to the end of the tree, incrementing a\n+    /// `length` variable along the way. The latter makes it easier for the\n+    /// caller to avoid a leak when the iterator panicks.\n+    fn bulk_push<I>(&mut self, iter: I, length: &mut usize)\n+    where\n+        I: Iterator<Item = (K, V)>,\n+    {\n+        let mut cur_node = self.node_as_mut().last_leaf_edge().into_node();\n+        // Iterate through all key-value pairs, pushing them into nodes at the right level.\n+        for (key, value) in iter {\n+            // Try to push key-value pair into the current leaf node.\n+            if cur_node.len() < node::CAPACITY {\n+                cur_node.push(key, value);\n+            } else {\n+                // No space left, go up and push there.\n+                let mut open_node;\n+                let mut test_node = cur_node.forget_type();\n+                loop {\n+                    match test_node.ascend() {\n+                        Ok(parent) => {\n+                            let parent = parent.into_node();\n+                            if parent.len() < node::CAPACITY {\n+                                // Found a node with space left, push here.\n+                                open_node = parent;\n+                                break;\n+                            } else {\n+                                // Go up again.\n+                                test_node = parent.forget_type();\n+                            }\n+                        }\n+                        Err(_) => {\n+                            // We are at the top, create a new root node and push there.\n+                            open_node = self.push_internal_level();\n+                            break;\n+                        }\n+                    }\n+                }\n+\n+                // Push key-value pair and new right subtree.\n+                let tree_height = open_node.height() - 1;\n+                let mut right_tree = Root::new_leaf();\n+                for _ in 0..tree_height {\n+                    right_tree.push_internal_level();\n+                }\n+                open_node.push(key, value, right_tree);\n+\n+                // Go down to the right-most leaf again.\n+                cur_node = open_node.forget_type().last_leaf_edge().into_node();\n+            }\n+\n+            // Increment length every iteration, to make sure the map drops\n+            // the appended elements even if advancing the iterator panicks.\n+            *length += 1;\n+        }\n+        self.fix_right_edge();\n+    }\n+\n+    fn fix_right_edge(&mut self) {\n+        // Handle underfull nodes, start from the top.\n+        let mut cur_node = self.node_as_mut();\n+        while let Internal(internal) = cur_node.force() {\n+            // Check if right-most child is underfull.\n+            let mut last_edge = internal.last_edge();\n+            let right_child_len = last_edge.reborrow().descend().len();\n+            if right_child_len < MIN_LEN {\n+                // We need to steal.\n+                let mut last_kv = match last_edge.left_kv() {\n+                    Ok(left) => left,\n+                    Err(_) => unreachable!(),\n+                };\n+                last_kv.bulk_steal_left(MIN_LEN - right_child_len);\n+                last_edge = last_kv.right_edge();\n+            }\n+\n+            // Go further down.\n+            cur_node = last_edge.descend();\n+        }\n+    }\n+}\n+\n+// An iterator for merging two sorted sequences into one\n+struct MergeIter<K, V, I: Iterator<Item = (K, V)>>(MergeIterInner<I>);\n+\n+impl<K: Ord, V, I> Iterator for MergeIter<K, V, I>\n+where\n+    I: Iterator<Item = (K, V)> + FusedIterator,\n+{\n+    type Item = (K, V);\n+\n+    /// If two keys are equal, returns the key-value pair from the right source.\n+    fn next(&mut self) -> Option<(K, V)> {\n+        let (a_next, b_next) = self.0.nexts(|a: &(K, V), b: &(K, V)| K::cmp(&a.0, &b.0));\n+        b_next.or(a_next)\n+    }\n+}"}, {"sha": "49122f53d33ad0a7b2f74be1f9558245d70604b4", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 94, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/685fd53ada562658e8ad1a3578efa4a2da4e83f4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685fd53ada562658e8ad1a3578efa4a2da4e83f4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=685fd53ada562658e8ad1a3578efa4a2da4e83f4", "patch": "@@ -9,7 +9,6 @@ use core::ops::{Index, RangeBounds};\n use core::ptr;\n \n use super::borrow::DormantMutRef;\n-use super::merge_iter::MergeIterInner;\n use super::node::{self, marker, ForceResult::*, Handle, NodeRef};\n use super::search::{self, SearchResult::*};\n use super::unwrap_unchecked;\n@@ -458,9 +457,6 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n     }\n }\n \n-// An iterator for merging two sorted sequences into one\n-struct MergeIter<K, V, I: Iterator<Item = (K, V)>>(MergeIterInner<I>);\n-\n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap.\n     ///\n@@ -908,13 +904,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             return;\n         }\n \n-        // First, we merge `self` and `other` into a sorted sequence in linear time.\n         let self_iter = mem::take(self).into_iter();\n         let other_iter = mem::take(other).into_iter();\n-        let iter = MergeIter(MergeIterInner::new(self_iter, other_iter));\n-\n-        // Second, we build a tree from the sorted sequence in linear time.\n-        self.from_sorted_iter(iter);\n+        let root = BTreeMap::ensure_is_owned(&mut self.root);\n+        root.append_from_sorted_iters(self_iter, other_iter, &mut self.length)\n     }\n \n     /// Constructs a double-ended iterator over a sub-range of elements in the map.\n@@ -1039,78 +1032,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n-    fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n-        let root = Self::ensure_is_owned(&mut self.root);\n-        let mut cur_node = root.node_as_mut().last_leaf_edge().into_node();\n-        // Iterate through all key-value pairs, pushing them into nodes at the right level.\n-        for (key, value) in iter {\n-            // Try to push key-value pair into the current leaf node.\n-            if cur_node.len() < node::CAPACITY {\n-                cur_node.push(key, value);\n-            } else {\n-                // No space left, go up and push there.\n-                let mut open_node;\n-                let mut test_node = cur_node.forget_type();\n-                loop {\n-                    match test_node.ascend() {\n-                        Ok(parent) => {\n-                            let parent = parent.into_node();\n-                            if parent.len() < node::CAPACITY {\n-                                // Found a node with space left, push here.\n-                                open_node = parent;\n-                                break;\n-                            } else {\n-                                // Go up again.\n-                                test_node = parent.forget_type();\n-                            }\n-                        }\n-                        Err(_) => {\n-                            // We are at the top, create a new root node and push there.\n-                            open_node = root.push_internal_level();\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                // Push key-value pair and new right subtree.\n-                let tree_height = open_node.height() - 1;\n-                let mut right_tree = node::Root::new_leaf();\n-                for _ in 0..tree_height {\n-                    right_tree.push_internal_level();\n-                }\n-                open_node.push(key, value, right_tree);\n-\n-                // Go down to the right-most leaf again.\n-                cur_node = open_node.forget_type().last_leaf_edge().into_node();\n-            }\n-\n-            self.length += 1;\n-        }\n-        Self::fix_right_edge(root)\n-    }\n-\n-    fn fix_right_edge(root: &mut node::Root<K, V>) {\n-        // Handle underfull nodes, start from the top.\n-        let mut cur_node = root.node_as_mut();\n-        while let Internal(internal) = cur_node.force() {\n-            // Check if right-most child is underfull.\n-            let mut last_edge = internal.last_edge();\n-            let right_child_len = last_edge.reborrow().descend().len();\n-            if right_child_len < MIN_LEN {\n-                // We need to steal.\n-                let mut last_kv = match last_edge.left_kv() {\n-                    Ok(left) => left,\n-                    Err(_) => unreachable!(),\n-                };\n-                last_kv.bulk_steal_left(MIN_LEN - right_child_len);\n-                last_edge = last_kv.right_edge();\n-            }\n-\n-            // Go further down.\n-            cur_node = last_edge.descend();\n-        }\n-    }\n-\n     /// Splits the collection into two at the given key. Returns everything after the given key,\n     /// including the key.\n     ///\n@@ -2220,18 +2141,5 @@ impl<K, V> BTreeMap<K, V> {\n     }\n }\n \n-impl<K: Ord, V, I> Iterator for MergeIter<K, V, I>\n-where\n-    I: Iterator<Item = (K, V)> + ExactSizeIterator + FusedIterator,\n-{\n-    type Item = (K, V);\n-\n-    /// If two keys are equal, returns the key/value-pair from the right source.\n-    fn next(&mut self) -> Option<(K, V)> {\n-        let (a_next, b_next) = self.0.nexts(|a: &(K, V), b: &(K, V)| K::cmp(&a.0, &b.0));\n-        b_next.or(a_next)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests;"}, {"sha": "89a6e327422bb1eb509c1b0e06f371bad4ac055e", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/685fd53ada562658e8ad1a3578efa4a2da4e83f4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685fd53ada562658e8ad1a3578efa4a2da4e83f4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=685fd53ada562658e8ad1a3578efa4a2da4e83f4", "patch": "@@ -1667,6 +1667,33 @@ create_append_test!(test_append_239, 239);\n #[cfg(not(miri))] // Miri is too slow\n create_append_test!(test_append_1700, 1700);\n \n+#[test]\n+fn test_append_drop_leak() {\n+    static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+    struct D;\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            if DROPS.fetch_add(1, Ordering::SeqCst) == 0 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut left = BTreeMap::new();\n+    let mut right = BTreeMap::new();\n+    left.insert(0, D);\n+    left.insert(1, D); // first to be dropped during append\n+    left.insert(2, D);\n+    right.insert(1, D);\n+    right.insert(2, D);\n+\n+    catch_unwind(move || left.append(&mut right)).unwrap_err();\n+\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 4); // Rust issue #47949 ate one little piggy\n+}\n+\n fn rand_data(len: usize) -> Vec<(u32, u32)> {\n     assert!(len * 2 <= 70029); // from that point on numbers repeat\n     let mut rng = DeterministicRng::new();"}, {"sha": "7f23d93b990f5fb2f8c79ae6aff12ed704fcbc7a", "filename": "library/alloc/src/collections/btree/merge_iter.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/685fd53ada562658e8ad1a3578efa4a2da4e83f4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmerge_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685fd53ada562658e8ad1a3578efa4a2da4e83f4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmerge_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmerge_iter.rs?ref=685fd53ada562658e8ad1a3578efa4a2da4e83f4", "patch": "@@ -2,48 +2,43 @@ use core::cmp::Ordering;\n use core::fmt::{self, Debug};\n use core::iter::FusedIterator;\n \n-/// Core of an iterator that merges the output of two ascending iterators,\n+/// Core of an iterator that merges the output of two strictly ascending iterators,\n /// for instance a union or a symmetric difference.\n-pub struct MergeIterInner<I>\n-where\n-    I: Iterator,\n-{\n+pub struct MergeIterInner<I: Iterator> {\n     a: I,\n     b: I,\n     peeked: Option<Peeked<I>>,\n }\n \n-/// Benchmarks faster than wrapping both iterators in a Peekable.\n+/// Benchmarks faster than wrapping both iterators in a Peekable,\n+/// probably because we can afford to impose a FusedIterator bound.\n #[derive(Clone, Debug)]\n enum Peeked<I: Iterator> {\n     A(I::Item),\n     B(I::Item),\n }\n \n-impl<I> Clone for MergeIterInner<I>\n+impl<I: Iterator> Clone for MergeIterInner<I>\n where\n-    I: Clone + Iterator,\n+    I: Clone,\n     I::Item: Clone,\n {\n     fn clone(&self) -> Self {\n         Self { a: self.a.clone(), b: self.b.clone(), peeked: self.peeked.clone() }\n     }\n }\n \n-impl<I> Debug for MergeIterInner<I>\n+impl<I: Iterator> Debug for MergeIterInner<I>\n where\n-    I: Iterator + Debug,\n+    I: Debug,\n     I::Item: Debug,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"MergeIterInner\").field(&self.a).field(&self.b).finish()\n+        f.debug_tuple(\"MergeIterInner\").field(&self.a).field(&self.b).field(&self.peeked).finish()\n     }\n }\n \n-impl<I> MergeIterInner<I>\n-where\n-    I: ExactSizeIterator + FusedIterator,\n-{\n+impl<I: Iterator> MergeIterInner<I> {\n     /// Creates a new core for an iterator merging a pair of sources.\n     pub fn new(a: I, b: I) -> Self {\n         MergeIterInner { a, b, peeked: None }\n@@ -52,13 +47,17 @@ where\n     /// Returns the next pair of items stemming from the pair of sources\n     /// being merged. If both returned options contain a value, that value\n     /// is equal and occurs in both sources. If one of the returned options\n-    /// contains a value, that value doesn't occur in the other source.\n-    /// If neither returned option contains a value, iteration has finished\n-    /// and subsequent calls will return the same empty pair.\n+    /// contains a value, that value doesn't occur in the other source (or\n+    /// the sources are not strictly ascending). If neither returned option\n+    /// contains a value, iteration has finished and subsequent calls will\n+    /// return the same empty pair.\n     pub fn nexts<Cmp: Fn(&I::Item, &I::Item) -> Ordering>(\n         &mut self,\n         cmp: Cmp,\n-    ) -> (Option<I::Item>, Option<I::Item>) {\n+    ) -> (Option<I::Item>, Option<I::Item>)\n+    where\n+        I: FusedIterator,\n+    {\n         let mut a_next;\n         let mut b_next;\n         match self.peeked.take() {\n@@ -86,7 +85,10 @@ where\n     }\n \n     /// Returns a pair of upper bounds for the `size_hint` of the final iterator.\n-    pub fn lens(&self) -> (usize, usize) {\n+    pub fn lens(&self) -> (usize, usize)\n+    where\n+        I: ExactSizeIterator,\n+    {\n         match self.peeked {\n             Some(Peeked::A(_)) => (1 + self.a.len(), self.b.len()),\n             Some(Peeked::B(_)) => (self.a.len(), 1 + self.b.len()),"}, {"sha": "ebcbb0e467c467b1cb95879bda8328301ec0b908", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/685fd53ada562658e8ad1a3578efa4a2da4e83f4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685fd53ada562658e8ad1a3578efa4a2da4e83f4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=685fd53ada562658e8ad1a3578efa4a2da4e83f4", "patch": "@@ -1,3 +1,4 @@\n+mod append;\n mod borrow;\n pub mod map;\n mod mem;"}]}