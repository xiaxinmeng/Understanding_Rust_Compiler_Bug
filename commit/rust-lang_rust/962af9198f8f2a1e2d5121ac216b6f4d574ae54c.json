{"sha": "962af9198f8f2a1e2d5121ac216b6f4d574ae54c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MmFmOTE5OGY4ZjJhMWUyZDUxMjFhYzIxNmI2ZjRkNTc0YWU1NGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-16T06:19:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-25T03:59:54Z"}, "message": "native: Protect against spurious wakeups on cvars\n\nThis is a very real problem with cvars on normal systems, and all of channels\nwill not work if spurious wakeups are accepted. This problem is just solved with\na synchronized flag (accessed in the cvar's lock) to see whether a signal()\nactually happened or whether it's spurious.", "tree": {"sha": "f990add092e17494929ab8c875254009f58ba069", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f990add092e17494929ab8c875254009f58ba069"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/962af9198f8f2a1e2d5121ac216b6f4d574ae54c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/962af9198f8f2a1e2d5121ac216b6f4d574ae54c", "html_url": "https://github.com/rust-lang/rust/commit/962af9198f8f2a1e2d5121ac216b6f4d574ae54c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/962af9198f8f2a1e2d5121ac216b6f4d574ae54c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04c446b4b66068a6742d29cd34326e520373f83e", "url": "https://api.github.com/repos/rust-lang/rust/commits/04c446b4b66068a6742d29cd34326e520373f83e", "html_url": "https://github.com/rust-lang/rust/commit/04c446b4b66068a6742d29cd34326e520373f83e"}], "stats": {"total": 81, "additions": 54, "deletions": 27}, "files": [{"sha": "0db81c5fea3bdccb4f2c91e641926eeaed992d4e", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/962af9198f8f2a1e2d5121ac216b6f4d574ae54c/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962af9198f8f2a1e2d5121ac216b6f4d574ae54c/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=962af9198f8f2a1e2d5121ac216b6f4d574ae54c", "patch": "@@ -13,14 +13,15 @@\n \n use std::cast;\n use std::rt::Runtime;\n-use std::task::TaskOpts;\n-use std::rt::rtio;\n use std::rt::local::Local;\n+use std::rt::rtio;\n use std::rt::task::{Task, BlockedTask};\n+use std::task::TaskOpts;\n use std::unstable::sync::LittleLock;\n \n struct SimpleTask {\n     lock: LittleLock,\n+    awoken: bool,\n }\n \n impl Runtime for SimpleTask {\n@@ -30,30 +31,37 @@ impl Runtime for SimpleTask {\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n         assert!(times == 1);\n \n-        let my_lock: *mut LittleLock = &mut self.lock;\n+        let me = &mut *self as *mut SimpleTask;\n+        let cur_dupe = &*cur_task as *Task;\n         cur_task.put_runtime(self as ~Runtime);\n+        let task = BlockedTask::block(cur_task);\n \n+        // See libnative/task.rs for what's going on here with the `awoken`\n+        // field and the while loop around wait()\n         unsafe {\n-            let cur_task_dupe = *cast::transmute::<&~Task, &uint>(&cur_task);\n-            let task = BlockedTask::block(cur_task);\n-\n-            let mut guard = (*my_lock).lock();\n+            let mut guard = (*me).lock.lock();\n+            (*me).awoken = false;\n             match f(task) {\n-                Ok(()) => guard.wait(),\n+                Ok(()) => {\n+                    while !(*me).awoken {\n+                        guard.wait();\n+                    }\n+                }\n                 Err(task) => { cast::forget(task.wake()); }\n             }\n             drop(guard);\n-            cur_task = cast::transmute::<uint, ~Task>(cur_task_dupe);\n+            cur_task = cast::transmute(cur_dupe);\n         }\n         Local::put(cur_task);\n     }\n     fn reawaken(mut ~self, mut to_wake: ~Task) {\n-        let lock: *mut LittleLock = &mut self.lock;\n+        let me = &mut *self as *mut SimpleTask;\n         to_wake.put_runtime(self as ~Runtime);\n         unsafe {\n             cast::forget(to_wake);\n-            let _l = (*lock).lock();\n-            (*lock).signal();\n+            let _l = (*me).lock.lock();\n+            (*me).awoken = true;\n+            (*me).lock.signal();\n         }\n     }\n \n@@ -72,6 +80,9 @@ impl Runtime for SimpleTask {\n \n pub fn task() -> ~Task {\n     let mut task = ~Task::new();\n-    task.put_runtime(~SimpleTask { lock: LittleLock::new() } as ~Runtime);\n+    task.put_runtime(~SimpleTask {\n+        lock: LittleLock::new(),\n+        awoken: false,\n+    } as ~Runtime);\n     return task;\n }"}, {"sha": "12e361d8041c86fd599bcfdf3b9609eb174e9907", "filename": "src/libnative/task.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/962af9198f8f2a1e2d5121ac216b6f4d574ae54c/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962af9198f8f2a1e2d5121ac216b6f4d574ae54c/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=962af9198f8f2a1e2d5121ac216b6f4d574ae54c", "patch": "@@ -33,6 +33,7 @@ pub fn new() -> ~Task {\n     let mut task = ~Task::new();\n     task.put_runtime(~Ops {\n         lock: unsafe { Mutex::new() },\n+        awoken: false,\n     } as ~rt::Runtime);\n     return task;\n }\n@@ -85,7 +86,8 @@ pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n // This structure is the glue between channels and the 1:1 scheduling mode. This\n // structure is allocated once per task.\n struct Ops {\n-    lock: Mutex, // native synchronization\n+    lock: Mutex,  // native synchronization\n+    awoken: bool, // used to prevent spurious wakeups\n }\n \n impl rt::Runtime for Ops {\n@@ -139,25 +141,38 @@ impl rt::Runtime for Ops {\n     // reasoning for this is the same logic as above in that the task silently\n     // transfers ownership via the `uint`, not through normal compiler\n     // semantics.\n+    //\n+    // On a mildly unrelated note, it should also be pointed out that OS\n+    // condition variables are susceptible to spurious wakeups, which we need to\n+    // be ready for. In order to accomodate for this fact, we have an extra\n+    // `awoken` field which indicates whether we were actually woken up via some\n+    // invocation of `reawaken`. This flag is only ever accessed inside the\n+    // lock, so there's no need to make it atomic.\n     fn deschedule(mut ~self, times: uint, mut cur_task: ~Task,\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n-        let my_lock: *mut Mutex = &mut self.lock as *mut Mutex;\n+        let me = &mut *self as *mut Ops;\n         cur_task.put_runtime(self as ~rt::Runtime);\n \n         unsafe {\n             let cur_task_dupe = *cast::transmute::<&~Task, &uint>(&cur_task);\n             let task = BlockedTask::block(cur_task);\n \n             if times == 1 {\n-                (*my_lock).lock();\n+                (*me).lock.lock();\n+                (*me).awoken = false;\n                 match f(task) {\n-                    Ok(()) => (*my_lock).wait(),\n+                    Ok(()) => {\n+                        while !(*me).awoken {\n+                            (*me).lock.wait();\n+                        }\n+                    }\n                     Err(task) => { cast::forget(task.wake()); }\n                 }\n-                (*my_lock).unlock();\n+                (*me).lock.unlock();\n             } else {\n                 let mut iter = task.make_selectable(times);\n-                (*my_lock).lock();\n+                (*me).lock.lock();\n+                (*me).awoken = false;\n                 let success = iter.all(|task| {\n                     match f(task) {\n                         Ok(()) => true,\n@@ -167,10 +182,10 @@ impl rt::Runtime for Ops {\n                         }\n                     }\n                 });\n-                if success {\n-                    (*my_lock).wait();\n+                while success && !(*me).awoken {\n+                    (*me).lock.wait();\n                 }\n-                (*my_lock).unlock();\n+                (*me).lock.unlock();\n             }\n             // re-acquire ownership of the task\n             cur_task = cast::transmute::<uint, ~Task>(cur_task_dupe);\n@@ -184,12 +199,13 @@ impl rt::Runtime for Ops {\n     // why it's valid to do so.\n     fn reawaken(mut ~self, mut to_wake: ~Task, _can_resched: bool) {\n         unsafe {\n-            let lock: *mut Mutex = &mut self.lock as *mut Mutex;\n+            let me = &mut *self as *mut Ops;\n             to_wake.put_runtime(self as ~rt::Runtime);\n             cast::forget(to_wake);\n-            (*lock).lock();\n-            (*lock).signal();\n-            (*lock).unlock();\n+            (*me).lock.lock();\n+            (*me).awoken = true;\n+            (*me).lock.signal();\n+            (*me).lock.unlock();\n         }\n     }\n "}, {"sha": "ae440894b4e204f94aeaa0e97d5e550ecf17096d", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962af9198f8f2a1e2d5121ac216b6f4d574ae54c/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962af9198f8f2a1e2d5121ac216b6f4d574ae54c/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=962af9198f8f2a1e2d5121ac216b6f4d574ae54c", "patch": "@@ -875,7 +875,7 @@ impl<T: Send> Port<T> {\n         let data = self.try_recv_inc(false);\n         if data.is_none() &&\n            unsafe { (*packet).cnt.load(SeqCst) } != DISCONNECTED {\n-            fail!(\"bug: woke up too soon\");\n+            fail!(\"bug: woke up too soon {}\", unsafe { (*packet).cnt.load(SeqCst) });\n         }\n         return data;\n     }"}]}