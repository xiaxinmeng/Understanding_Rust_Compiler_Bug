{"sha": "2fa942ad3057bac90869263963daf8b02651d3de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYTk0MmFkMzA1N2JhYzkwODY5MjYzOTYzZGFmOGIwMjY1MWQzZGU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-23T22:12:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-23T22:12:15Z"}, "message": "Merge #6251 #6310\n\n6251: Semantic Highlight: Add Callable modifier for variables r=matklad a=GrayJack\n\nThis PR added the `HighlightModifier::Callable` variant and assigned it to variables and parameters that are fn pointers, closures and implements FnOnce trait.\r\n\r\nThis allows to colorize these variables/parameters when used in call expression.\r\n\r\n\n\n6310: Rewrite algo::diff to support insertion and deletion r=matklad a=Veykril\n\nThis in turn also makes `algo::diff` generate finer diffs(maybe even minimal diffs?) as insertions and deletions aren't always represented as as replacements of parent nodes now.\r\n\r\nRequired for #6287 to go on.\n\nCo-authored-by: GrayJack <gr41.j4ck@gmail.com>\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "a96931f7746e045f30e344101e0cec0b3a1eb5dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a96931f7746e045f30e344101e0cec0b3a1eb5dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fa942ad3057bac90869263963daf8b02651d3de", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfk1U/CRBK7hj4Ov3rIwAAdHIIABi3581FeUX8M6zS9CwbIHCa\nb7Fst8Pd8RZFbXL72dONc9mIvO3Domp6FAUfXDBhCmT1k29mMD2kWYJiAsL+NGk3\ni1Cjq446vODYTdg19T7HRa9uEkEeeVimpZ+GrUiJOrh3A8Q35I5ZKYjmlMpHnjqb\n+pFCKNSHSuhm3sGaEev4YY+dqLfV+6ONay2U5DDW8vBQYnxqyxUVTqMTUlhoeu3F\nQVJzFhfngRIvnBT/MuRn9eP2CrQTmC8eNYrLCXu0ZbKC+Od0qD47DYQ1I4085BpN\nTGms3hhnjS9byhlsoAWDRoO/hWEsALCIIgnM/UnTtv8LkSHatvczxZViUeTwJOM=\n=KKxq\n-----END PGP SIGNATURE-----\n", "payload": "tree a96931f7746e045f30e344101e0cec0b3a1eb5dd\nparent c483212f274e9a5e348451cd4bbd0487e172458b\nparent a35ff6edf44519cc3b07869d8e5754c607b913cd\nparent 0059188e77b4fa6f110785f7938dbfc35623fac8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1603491135 +0000\ncommitter GitHub <noreply@github.com> 1603491135 +0000\n\nMerge #6251 #6310\n\n6251: Semantic Highlight: Add Callable modifier for variables r=matklad a=GrayJack\n\nThis PR added the `HighlightModifier::Callable` variant and assigned it to variables and parameters that are fn pointers, closures and implements FnOnce trait.\r\n\r\nThis allows to colorize these variables/parameters when used in call expression.\r\n\r\n\n\n6310: Rewrite algo::diff to support insertion and deletion r=matklad a=Veykril\n\nThis in turn also makes `algo::diff` generate finer diffs(maybe even minimal diffs?) as insertions and deletions aren't always represented as as replacements of parent nodes now.\r\n\r\nRequired for #6287 to go on.\n\nCo-authored-by: GrayJack <gr41.j4ck@gmail.com>\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fa942ad3057bac90869263963daf8b02651d3de", "html_url": "https://github.com/rust-lang/rust/commit/2fa942ad3057bac90869263963daf8b02651d3de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fa942ad3057bac90869263963daf8b02651d3de/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c483212f274e9a5e348451cd4bbd0487e172458b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c483212f274e9a5e348451cd4bbd0487e172458b", "html_url": "https://github.com/rust-lang/rust/commit/c483212f274e9a5e348451cd4bbd0487e172458b"}, {"sha": "a35ff6edf44519cc3b07869d8e5754c607b913cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a35ff6edf44519cc3b07869d8e5754c607b913cd", "html_url": "https://github.com/rust-lang/rust/commit/a35ff6edf44519cc3b07869d8e5754c607b913cd"}, {"sha": "0059188e77b4fa6f110785f7938dbfc35623fac8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0059188e77b4fa6f110785f7938dbfc35623fac8", "html_url": "https://github.com/rust-lang/rust/commit/0059188e77b4fa6f110785f7938dbfc35623fac8"}], "stats": {"total": 501, "additions": 469, "deletions": 32}, "files": [{"sha": "fe09e4afeba9e8ccdd4e900168f8a56554836bbe", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fa942ad3057bac90869263963daf8b02651d3de/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2fa942ad3057bac90869263963daf8b02651d3de/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2fa942ad3057bac90869263963daf8b02651d3de", "patch": "@@ -1608,6 +1608,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arrayvec\",\n  \"expect-test\",\n+ \"indexmap\",\n  \"itertools\",\n  \"once_cell\",\n  \"parser\","}, {"sha": "63c1a8ebf0eb651e5e72613feb733b4c9a108692", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=2fa942ad3057bac90869263963daf8b02651d3de", "patch": "@@ -31,8 +31,7 @@ use hir_ty::{\n     autoderef,\n     display::{HirDisplayError, HirFormatter},\n     method_resolution,\n-    traits::Solution,\n-    traits::SolutionVariables,\n+    traits::{FnTrait, Solution, SolutionVariables},\n     ApplicationTy, BoundVar, CallableDefId, Canonical, DebruijnIndex, FnSig, GenericPredicate,\n     InEnvironment, Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, Ty,\n     TyDefId, TyKind, TypeCtor,\n@@ -1386,6 +1385,28 @@ impl Type {\n         )\n     }\n \n+    /// Checks that particular type `ty` implements `std::ops::FnOnce`.\n+    ///\n+    /// This function can be used to check if a particular type is callable, since FnOnce is a\n+    /// supertrait of Fn and FnMut, so all callable types implements at least FnOnce.\n+    pub fn impls_fnonce(&self, db: &dyn HirDatabase) -> bool {\n+        let krate = self.krate;\n+\n+        let fnonce_trait = match FnTrait::FnOnce.get_id(db, krate) {\n+            Some(it) => it,\n+            None => return false,\n+        };\n+\n+        let canonical_ty = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+        method_resolution::implements_trait(\n+            &canonical_ty,\n+            db,\n+            self.ty.environment.clone(),\n+            krate,\n+            fnonce_trait,\n+        )\n+    }\n+\n     pub fn impls_trait(&self, db: &dyn HirDatabase, trait_: Trait, args: &[Type]) -> bool {\n         let trait_ref = hir_ty::TraitRef {\n             trait_: trait_.id,"}, {"sha": "76b52fa047ae7b196c1e7294eb4466f13b13c9a9", "filename": "crates/ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2FCargo.toml?ref=2fa942ad3057bac90869263963daf8b02651d3de", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n either = \"1.5.3\"\n-indexmap = \"1.3.2\"\n+indexmap = \"1.4.0\"\n itertools = \"0.9.0\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\""}, {"sha": "232074c3dff5dce0184ac11e310509a176dc1e24", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=2fa942ad3057bac90869263963daf8b02651d3de", "patch": "@@ -613,7 +613,7 @@ fn main() {\n pub struct Foo { pub a: i32, pub b: i32 }\n \"#,\n             r#\"\n-fn {a:42, b: ()} {}\n+fn some(, b: ()} {}\n fn items() {}\n fn here() {}\n "}, {"sha": "75084846762f9da6a33a921d714c278361ab1116", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=2fa942ad3057bac90869263963daf8b02651d3de", "patch": "@@ -763,6 +763,9 @@ fn highlight_def(db: &RootDatabase, def: Definition) -> Highlight {\n             if local.is_mut(db) || local.ty(db).is_mutable_reference() {\n                 h |= HighlightModifier::Mutable;\n             }\n+            if local.ty(db).as_callable(db).is_some() || local.ty(db).impls_fnonce(db) {\n+                h |= HighlightModifier::Callable;\n+            }\n             return h;\n         }\n     }"}, {"sha": "e8f78ad525c39e9dae4e8b606b82814a5cb3dfc9", "filename": "crates/ide/src/syntax_highlighting/tags.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=2fa942ad3057bac90869263963daf8b02651d3de", "patch": "@@ -64,6 +64,7 @@ pub enum HighlightModifier {\n     Mutable,\n     Consuming,\n     Unsafe,\n+    Callable,\n }\n \n impl HighlightTag {\n@@ -122,6 +123,7 @@ impl HighlightModifier {\n         HighlightModifier::Mutable,\n         HighlightModifier::Consuming,\n         HighlightModifier::Unsafe,\n+        HighlightModifier::Callable,\n     ];\n \n     fn as_str(self) -> &'static str {\n@@ -134,6 +136,7 @@ impl HighlightModifier {\n             HighlightModifier::Mutable => \"mutable\",\n             HighlightModifier::Consuming => \"consuming\",\n             HighlightModifier::Unsafe => \"unsafe\",\n+            HighlightModifier::Callable => \"callable\",\n         }\n     }\n "}, {"sha": "0cb84866d64830082304911e62a6b6d8b94f0611", "filename": "crates/ide/src/syntax_highlighting/test_data/highlighting.html", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlighting.html?ref=2fa942ad3057bac90869263963daf8b02651d3de", "patch": "@@ -44,6 +44,17 @@\n     <span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"trait declaration\">Copy</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n <span class=\"punctuation\">}</span>\n \n+<span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> <span class=\"module declaration\">ops</span> <span class=\"punctuation\">{</span>\n+    <span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"function attribute\">lang</span><span class=\"attribute\"> </span><span class=\"operator\">=</span><span class=\"attribute\"> </span><span class=\"string_literal\">\"fn_once\"</span><span class=\"attribute\">]</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"trait declaration\">FnOnce</span><span class=\"punctuation\">&lt;</span><span class=\"type_param declaration\">Args</span><span class=\"punctuation\">&gt;</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n+\n+    <span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"function attribute\">lang</span><span class=\"attribute\"> </span><span class=\"operator\">=</span><span class=\"attribute\"> </span><span class=\"string_literal\">\"fn_mut\"</span><span class=\"attribute\">]</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"trait declaration\">FnMut</span><span class=\"punctuation\">&lt;</span><span class=\"type_param declaration\">Args</span><span class=\"punctuation\">&gt;</span><span class=\"punctuation\">:</span> <span class=\"trait\">FnOnce</span><span class=\"punctuation\">&lt;</span><span class=\"type_param\">Args</span><span class=\"punctuation\">&gt;</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n+\n+    <span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"function attribute\">lang</span><span class=\"attribute\"> </span><span class=\"operator\">=</span><span class=\"attribute\"> </span><span class=\"string_literal\">\"fn\"</span><span class=\"attribute\">]</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"trait declaration\">Fn</span><span class=\"punctuation\">&lt;</span><span class=\"type_param declaration\">Args</span><span class=\"punctuation\">&gt;</span><span class=\"punctuation\">:</span> <span class=\"trait\">FnMut</span><span class=\"punctuation\">&lt;</span><span class=\"type_param\">Args</span><span class=\"punctuation\">&gt;</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n+<span class=\"punctuation\">}</span>\n+\n \n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Foo</span> <span class=\"punctuation\">{</span>\n     <span class=\"keyword\">pub</span> <span class=\"field declaration\">x</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">i32</span><span class=\"punctuation\">,</span>\n@@ -99,6 +110,11 @@\n     <span class=\"function\">foo</span><span class=\"operator\">::</span><span class=\"punctuation\">&lt;</span><span class=\"lifetime\">'a</span><span class=\"punctuation\">,</span> <span class=\"builtin_type\">i32</span><span class=\"punctuation\">&gt;</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span>\n <span class=\"punctuation\">}</span>\n \n+<span class=\"keyword\">use</span> <span class=\"module\">ops</span><span class=\"operator\">::</span><span class=\"trait\">Fn</span><span class=\"punctuation\">;</span>\n+<span class=\"keyword\">fn</span> <span class=\"function declaration\">baz</span><span class=\"punctuation\">&lt;</span><span class=\"type_param declaration\">F</span><span class=\"punctuation\">:</span> <span class=\"trait\">Fn</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">&gt;</span><span class=\"punctuation\">(</span><span class=\"value_param declaration callable\">f</span><span class=\"punctuation\">:</span> <span class=\"type_param\">F</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span>\n+    <span class=\"value_param callable\">f</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span>\n+<span class=\"punctuation\">}</span>\n+\n <span class=\"macro\">macro_rules!</span> <span class=\"macro declaration\">def_fn</span> <span class=\"punctuation\">{</span>\n     <span class=\"punctuation\">(</span><span class=\"punctuation\">$</span><span class=\"punctuation\">(</span><span class=\"punctuation\">$</span>tt<span class=\"punctuation\">:</span>tt<span class=\"punctuation\">)</span><span class=\"punctuation\">*</span><span class=\"punctuation\">)</span> <span class=\"operator\">=</span><span class=\"punctuation\">&gt;</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">$</span><span class=\"punctuation\">(</span><span class=\"punctuation\">$</span>tt<span class=\"punctuation\">)</span><span class=\"punctuation\">*</span><span class=\"punctuation\">}</span>\n <span class=\"punctuation\">}</span>\n@@ -157,6 +173,9 @@\n     <span class=\"variable mutable\">copy</span><span class=\"punctuation\">.</span><span class=\"function\">quop</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n     <span class=\"variable mutable\">copy</span><span class=\"punctuation\">.</span><span class=\"function mutable\">qux</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n     <span class=\"variable mutable\">copy</span><span class=\"punctuation\">.</span><span class=\"function\">baz</span><span class=\"punctuation\">(</span><span class=\"variable mutable\">copy</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration callable\">a</span> <span class=\"operator\">=</span> <span class=\"punctuation\">|</span><span class=\"value_param declaration\">x</span><span class=\"punctuation\">|</span> <span class=\"value_param\">x</span><span class=\"punctuation\">;</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration callable\">bar</span> <span class=\"operator\">=</span> <span class=\"struct\">Foo</span><span class=\"operator\">::</span><span class=\"function\">baz</span><span class=\"punctuation\">;</span>\n <span class=\"punctuation\">}</span>\n \n <span class=\"keyword\">enum</span> <span class=\"enum declaration\">Option</span><span class=\"punctuation\">&lt;</span><span class=\"type_param declaration\">T</span><span class=\"punctuation\">&gt;</span> <span class=\"punctuation\">{</span>"}, {"sha": "da20c300e28bc507222b9b92b279af44619bf20d", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=2fa942ad3057bac90869263963daf8b02651d3de", "patch": "@@ -18,6 +18,17 @@ pub mod marker {\n     pub trait Copy {}\n }\n \n+pub mod ops {\n+    #[lang = \"fn_once\"]\n+    pub trait FnOnce<Args> {}\n+\n+    #[lang = \"fn_mut\"]\n+    pub trait FnMut<Args>: FnOnce<Args> {}\n+\n+    #[lang = \"fn\"]\n+    pub trait Fn<Args>: FnMut<Args> {}\n+}\n+\n \n struct Foo {\n     pub x: i32,\n@@ -73,6 +84,11 @@ fn foo<'a, T>() -> T {\n     foo::<'a, i32>()\n }\n \n+use ops::Fn;\n+fn baz<F: Fn() -> ()>(f: F) {\n+    f()\n+}\n+\n macro_rules! def_fn {\n     ($($tt:tt)*) => {$($tt)*}\n }\n@@ -131,6 +147,9 @@ fn main() {\n     copy.quop();\n     copy.qux();\n     copy.baz(copy);\n+\n+    let a = |x| x;\n+    let bar = Foo::baz;\n }\n \n enum Option<T> {"}, {"sha": "7df28c9ddcc52305191e7b6f26e86421ebbde296", "filename": "crates/rust-analyzer/src/semantic_tokens.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs?ref=2fa942ad3057bac90869263963daf8b02651d3de", "patch": "@@ -77,6 +77,7 @@ define_semantic_token_modifiers![\n     (CONSUMING, \"consuming\"),\n     (UNSAFE, \"unsafe\"),\n     (ATTRIBUTE_MODIFIER, \"attribute\"),\n+    (CALLABLE, \"callable\"),\n ];\n \n #[derive(Default)]"}, {"sha": "0d34970bcaed6a29f7f24ca1800ee946898e69cb", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=2fa942ad3057bac90869263963daf8b02651d3de", "patch": "@@ -425,6 +425,7 @@ fn semantic_token_type_and_modifiers(\n             HighlightModifier::Mutable => semantic_tokens::MUTABLE,\n             HighlightModifier::Consuming => semantic_tokens::CONSUMING,\n             HighlightModifier::Unsafe => semantic_tokens::UNSAFE,\n+            HighlightModifier::Callable => semantic_tokens::CALLABLE,\n         };\n         mods |= modifier;\n     }"}, {"sha": "aa39ce554cff3c6f461a949e486554ebdb8efe2d", "filename": "crates/syntax/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2FCargo.toml?ref=2fa942ad3057bac90869263963daf8b02651d3de", "patch": "@@ -17,6 +17,7 @@ rustc_lexer = { version = \"683.0.0\", package = \"rustc-ap-rustc_lexer\" }\n rustc-hash = \"1.1.0\"\n arrayvec = \"0.5.1\"\n once_cell = \"1.3.1\"\n+indexmap = \"1.4.0\"\n # This crate transitively depends on `smol_str` via `rowan`.\n # ideally, `serde` should be enabled by `rust-analyzer`, but we enable it here\n # to reduce number of compilations\n@@ -26,10 +27,9 @@ serde = { version = \"1.0.106\", features = [\"derive\"] }\n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n text_edit = { path = \"../text_edit\", version = \"0.0.0\" }\n parser = { path = \"../parser\", version = \"0.0.0\" }\n+test_utils = { path = \"../test_utils\" }\n \n [dev-dependencies]\n walkdir = \"2.3.1\"\n rayon = \"1\"\n expect-test = \"1.0\"\n-\n-test_utils = { path = \"../test_utils\" }"}, {"sha": "4f9a7a6e89465454ed2e120483608a23c4bbc08c", "filename": "crates/syntax/src/algo.rs", "status": "modified", "additions": 391, "deletions": 26, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fsyntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa942ad3057bac90869263963daf8b02651d3de/crates%2Fsyntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Falgo.rs?ref=2fa942ad3057bac90869263963daf8b02651d3de", "patch": "@@ -2,11 +2,14 @@\n \n use std::{\n     fmt,\n+    hash::BuildHasherDefault,\n     ops::{self, RangeInclusive},\n };\n \n+use indexmap::IndexMap;\n use itertools::Itertools;\n use rustc_hash::FxHashMap;\n+use test_utils::mark;\n use text_edit::TextEditBuilder;\n \n use crate::{\n@@ -106,42 +109,56 @@ pub enum InsertPosition<T> {\n     After(T),\n }\n \n+type FxIndexMap<K, V> = IndexMap<K, V, BuildHasherDefault<rustc_hash::FxHasher>>;\n+\n+#[derive(Debug)]\n pub struct TreeDiff {\n     replacements: FxHashMap<SyntaxElement, SyntaxElement>,\n+    deletions: Vec<SyntaxElement>,\n+    // the vec as well as the indexmap are both here to preserve order\n+    insertions: FxIndexMap<SyntaxElement, Vec<SyntaxElement>>,\n }\n \n impl TreeDiff {\n     pub fn into_text_edit(&self, builder: &mut TextEditBuilder) {\n+        for (anchor, to) in self.insertions.iter() {\n+            to.iter().for_each(|to| builder.insert(anchor.text_range().end(), to.to_string()));\n+        }\n         for (from, to) in self.replacements.iter() {\n             builder.replace(from.text_range(), to.to_string())\n         }\n+        for text_range in self.deletions.iter().map(SyntaxElement::text_range) {\n+            builder.delete(text_range);\n+        }\n     }\n \n     pub fn is_empty(&self) -> bool {\n-        self.replacements.is_empty()\n+        self.replacements.is_empty() && self.deletions.is_empty() && self.insertions.is_empty()\n     }\n }\n \n /// Finds minimal the diff, which, applied to `from`, will result in `to`.\n ///\n-/// Specifically, returns a map whose keys are descendants of `from` and values\n-/// are descendants of `to`, such that  `replace_descendants(from, map) == to`.\n+/// Specifically, returns a structure that consists of a replacements, insertions and deletions\n+/// such that applying this map on `from` will result in `to`.\n ///\n-/// A trivial solution is a singleton map `{ from: to }`, but this function\n-/// tries to find a more fine-grained diff.\n+/// This function tries to find a fine-grained diff.\n pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> TreeDiff {\n-    let mut buf = FxHashMap::default();\n-    // FIXME: this is both horrible inefficient and gives larger than\n-    // necessary diff. I bet there's a cool algorithm to diff trees properly.\n-    go(&mut buf, from.clone().into(), to.clone().into());\n-    return TreeDiff { replacements: buf };\n-\n-    fn go(\n-        buf: &mut FxHashMap<SyntaxElement, SyntaxElement>,\n-        lhs: SyntaxElement,\n-        rhs: SyntaxElement,\n-    ) {\n-        if lhs.kind() == rhs.kind()\n+    let mut diff = TreeDiff {\n+        replacements: FxHashMap::default(),\n+        insertions: FxIndexMap::default(),\n+        deletions: Vec::new(),\n+    };\n+    let (from, to) = (from.clone().into(), to.clone().into());\n+\n+    // FIXME: this is horrible inefficient. I bet there's a cool algorithm to diff trees properly.\n+    if !syntax_element_eq(&from, &to) {\n+        go(&mut diff, from, to);\n+    }\n+    return diff;\n+\n+    fn syntax_element_eq(lhs: &SyntaxElement, rhs: &SyntaxElement) -> bool {\n+        lhs.kind() == rhs.kind()\n             && lhs.text_range().len() == rhs.text_range().len()\n             && match (&lhs, &rhs) {\n                 (NodeOrToken::Node(lhs), NodeOrToken::Node(rhs)) => {\n@@ -150,18 +167,47 @@ pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> TreeDiff {\n                 (NodeOrToken::Token(lhs), NodeOrToken::Token(rhs)) => lhs.text() == rhs.text(),\n                 _ => false,\n             }\n-        {\n-            return;\n-        }\n-        if let (Some(lhs), Some(rhs)) = (lhs.as_node(), rhs.as_node()) {\n-            if lhs.children_with_tokens().count() == rhs.children_with_tokens().count() {\n-                for (lhs, rhs) in lhs.children_with_tokens().zip(rhs.children_with_tokens()) {\n-                    go(buf, lhs, rhs)\n-                }\n+    }\n+\n+    fn go(diff: &mut TreeDiff, lhs: SyntaxElement, rhs: SyntaxElement) {\n+        let (lhs, rhs) = match lhs.as_node().zip(rhs.as_node()) {\n+            Some((lhs, rhs)) => (lhs, rhs),\n+            _ => {\n+                mark::hit!(diff_node_token_replace);\n+                diff.replacements.insert(lhs, rhs);\n                 return;\n             }\n+        };\n+\n+        let mut rhs_children = rhs.children_with_tokens();\n+        let mut lhs_children = lhs.children_with_tokens();\n+        let mut last_lhs = None;\n+        loop {\n+            let lhs_child = lhs_children.next();\n+            match (lhs_child.clone(), rhs_children.next()) {\n+                (None, None) => break,\n+                (None, Some(element)) => match last_lhs.clone() {\n+                    Some(prev) => {\n+                        mark::hit!(diff_insert);\n+                        diff.insertions.entry(prev).or_insert_with(Vec::new).push(element);\n+                    }\n+                    // first iteration, this means we got no anchor element to insert after\n+                    // therefor replace the parent node instead\n+                    None => {\n+                        mark::hit!(diff_replace_parent);\n+                        diff.replacements.insert(lhs.clone().into(), rhs.clone().into());\n+                        break;\n+                    }\n+                },\n+                (Some(element), None) => {\n+                    mark::hit!(diff_delete);\n+                    diff.deletions.push(element);\n+                }\n+                (Some(ref lhs_ele), Some(ref rhs_ele)) if syntax_element_eq(lhs_ele, rhs_ele) => {}\n+                (Some(lhs_ele), Some(rhs_ele)) => go(diff, lhs_ele, rhs_ele),\n+            }\n+            last_lhs = lhs_child.or(last_lhs);\n         }\n-        buf.insert(lhs, rhs);\n     }\n }\n \n@@ -404,3 +450,322 @@ fn to_green_element(element: SyntaxElement) -> NodeOrToken<rowan::GreenNode, row\n         NodeOrToken::Token(it) => it.green().clone().into(),\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::{expect, Expect};\n+    use itertools::Itertools;\n+    use parser::SyntaxKind;\n+    use test_utils::mark;\n+    use text_edit::TextEdit;\n+\n+    use crate::{AstNode, SyntaxElement};\n+\n+    #[test]\n+    fn replace_node_token() {\n+        mark::check!(diff_node_token_replace);\n+        check_diff(\n+            r#\"use node;\"#,\n+            r#\"ident\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+\n+\n+                replacements:\n+\n+                Line 0: Token(USE_KW@0..3 \"use\") -> ident\n+\n+                deletions:\n+\n+                Line 1: \" \"\n+                Line 1: node\n+                Line 1: ;\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn insert() {\n+        mark::check!(diff_insert);\n+        check_diff(\n+            r#\"use foo;\"#,\n+            r#\"use foo;\n+use bar;\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+                Line 0: Node(USE@0..8)\n+                -> \"\\n\"\n+                -> use bar;\n+\n+                replacements:\n+\n+\n+\n+                deletions:\n+\n+\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_parent() {\n+        mark::check!(diff_replace_parent);\n+        check_diff(\n+            r#\"\"#,\n+            r#\"use foo::bar;\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+\n+\n+                replacements:\n+\n+                Line 0: Node(SOURCE_FILE@0..0) -> use foo::bar;\n+\n+                deletions:\n+\n+\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn delete() {\n+        mark::check!(diff_delete);\n+        check_diff(\n+            r#\"use foo;\n+            use bar;\"#,\n+            r#\"use foo;\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+\n+\n+                replacements:\n+\n+\n+\n+                deletions:\n+\n+                Line 1: \"\\n            \"\n+                Line 2: use bar;\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_use() {\n+        check_diff(\n+            r#\"\n+use expect_test::{expect, Expect};\n+\n+use crate::AstNode;\n+\"#,\n+            r#\"\n+use expect_test::{expect, Expect};\n+use text_edit::TextEdit;\n+\n+use crate::AstNode;\n+\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+                Line 4: Token(WHITESPACE@56..57 \"\\n\")\n+                -> use crate::AstNode;\n+                -> \"\\n\"\n+\n+                replacements:\n+\n+                Line 2: Token(WHITESPACE@35..37 \"\\n\\n\") -> \"\\n\"\n+                Line 4: Token(CRATE_KW@41..46 \"crate\") -> text_edit\n+                Line 4: Token(IDENT@48..55 \"AstNode\") -> TextEdit\n+                Line 4: Token(WHITESPACE@56..57 \"\\n\") -> \"\\n\\n\"\n+\n+                deletions:\n+\n+\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn remove_use() {\n+        check_diff(\n+            r#\"\n+use expect_test::{expect, Expect};\n+use text_edit::TextEdit;\n+\n+use crate::AstNode;\n+\"#,\n+            r#\"\n+use expect_test::{expect, Expect};\n+\n+use crate::AstNode;\n+\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+\n+\n+                replacements:\n+\n+                Line 2: Token(WHITESPACE@35..36 \"\\n\") -> \"\\n\\n\"\n+                Line 3: Node(NAME_REF@40..49) -> crate\n+                Line 3: Token(IDENT@51..59 \"TextEdit\") -> AstNode\n+                Line 3: Token(WHITESPACE@60..62 \"\\n\\n\") -> \"\\n\"\n+\n+                deletions:\n+\n+                Line 4: use crate::AstNode;\n+                Line 5: \"\\n\"\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_use() {\n+        check_diff(\n+            r#\"\n+use std::{\n+    fmt,\n+    hash::BuildHasherDefault,\n+    ops::{self, RangeInclusive},\n+};\n+\"#,\n+            r#\"\n+use std::fmt;\n+use std::hash::BuildHasherDefault;\n+use std::ops::{self, RangeInclusive};\n+\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+                Line 2: Node(PATH_SEGMENT@5..8)\n+                -> ::\n+                -> fmt\n+                Line 6: Token(WHITESPACE@86..87 \"\\n\")\n+                -> use std::hash::BuildHasherDefault;\n+                -> \"\\n\"\n+                -> use std::ops::{self, RangeInclusive};\n+                -> \"\\n\"\n+\n+                replacements:\n+\n+                Line 2: Token(IDENT@5..8 \"std\") -> std\n+\n+                deletions:\n+\n+                Line 2: ::\n+                Line 2: {\n+                    fmt,\n+                    hash::BuildHasherDefault,\n+                    ops::{self, RangeInclusive},\n+                }\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn early_return_assist() {\n+        check_diff(\n+            r#\"\n+fn main() {\n+    if let Ok(x) = Err(92) {\n+        foo(x);\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let x = match Err(92) {\n+        Ok(it) => it,\n+        _ => return,\n+    };\n+    foo(x);\n+}\n+            \"#,\n+            expect![[r#\"\n+                insertions:\n+\n+                Line 3: Node(BLOCK_EXPR@40..63)\n+                -> \" \"\n+                -> match Err(92) {\n+                        Ok(it) => it,\n+                        _ => return,\n+                    }\n+                -> ;\n+                Line 5: Token(R_CURLY@64..65 \"}\")\n+                -> \"\\n\"\n+                -> }\n+\n+                replacements:\n+\n+                Line 3: Token(IF_KW@17..19 \"if\") -> let\n+                Line 3: Token(LET_KW@20..23 \"let\") -> x\n+                Line 3: Node(BLOCK_EXPR@40..63) -> =\n+                Line 5: Token(WHITESPACE@63..64 \"\\n\") -> \"\\n    \"\n+                Line 5: Token(R_CURLY@64..65 \"}\") -> foo(x);\n+\n+                deletions:\n+\n+                Line 3: \" \"\n+                Line 3: Ok(x)\n+                Line 3: \" \"\n+                Line 3: =\n+                Line 3: \" \"\n+                Line 3: Err(92)\n+            \"#]],\n+        )\n+    }\n+\n+    fn check_diff(from: &str, to: &str, expected_diff: Expect) {\n+        let from_node = crate::SourceFile::parse(from).tree().syntax().clone();\n+        let to_node = crate::SourceFile::parse(to).tree().syntax().clone();\n+        let diff = super::diff(&from_node, &to_node);\n+\n+        let line_number =\n+            |syn: &SyntaxElement| from[..syn.text_range().start().into()].lines().count();\n+\n+        let fmt_syntax = |syn: &SyntaxElement| match syn.kind() {\n+            SyntaxKind::WHITESPACE => format!(\"{:?}\", syn.to_string()),\n+            _ => format!(\"{}\", syn),\n+        };\n+\n+        let insertions = diff.insertions.iter().format_with(\"\\n\", |(k, v), f| {\n+            f(&format!(\n+                \"Line {}: {:?}\\n-> {}\",\n+                line_number(k),\n+                k,\n+                v.iter().format_with(\"\\n-> \", |v, f| f(&fmt_syntax(v)))\n+            ))\n+        });\n+\n+        let replacements = diff\n+            .replacements\n+            .iter()\n+            .sorted_by_key(|(syntax, _)| syntax.text_range().start())\n+            .format_with(\"\\n\", |(k, v), f| {\n+                f(&format!(\"Line {}: {:?} -> {}\", line_number(k), k, fmt_syntax(v)))\n+            });\n+\n+        let deletions = diff\n+            .deletions\n+            .iter()\n+            .format_with(\"\\n\", |v, f| f(&format!(\"Line {}: {}\", line_number(v), &fmt_syntax(v))));\n+\n+        let actual = format!(\n+            \"insertions:\\n\\n{}\\n\\nreplacements:\\n\\n{}\\n\\ndeletions:\\n\\n{}\\n\",\n+            insertions, replacements, deletions\n+        );\n+        expected_diff.assert_eq(&actual);\n+\n+        let mut from = from.to_owned();\n+        let mut text_edit = TextEdit::builder();\n+        diff.into_text_edit(&mut text_edit);\n+        text_edit.finish().apply(&mut from);\n+        assert_eq!(&*from, to, \"diff did not turn `from` to `to`\");\n+    }\n+}"}, {"sha": "af845d7bc429aa61e83fea26299f7a441a50cf76", "filename": "editors/code/package.json", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fa942ad3057bac90869263963daf8b02651d3de/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/2fa942ad3057bac90869263963daf8b02651d3de/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=2fa942ad3057bac90869263963daf8b02651d3de", "patch": "@@ -929,6 +929,10 @@\n             {\n                 \"id\": \"consuming\",\n                 \"description\": \"Style for non-Copy lvalues consumed by method/function call\"\n+            },\n+            {\n+                \"id\": \"callable\",\n+                \"description\": \"Style for variables/parameters that can be used in call expressions\"\n             }\n         ],\n         \"semanticTokenScopes\": ["}]}