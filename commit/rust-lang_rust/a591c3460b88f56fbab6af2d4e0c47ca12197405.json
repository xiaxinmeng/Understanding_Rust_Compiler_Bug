{"sha": "a591c3460b88f56fbab6af2d4e0c47ca12197405", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1OTFjMzQ2MGI4OGY1NmZiYWI2YWYyZDRlMGM0N2NhMTIxOTc0MDU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-18T13:21:01Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-18T13:21:01Z"}, "message": "Merge #856\n\n856: Reduce dependnecies of ra_vfs r=pnkfelix a=matklad\n\nIn preparation for moving `ra_vfs` to a separate repo with extensive cross-platform CI, remove dependency on `ra_thread_workder` and `ra_arena`.\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "6c77bfc9ae120e8741ccd3a354c942e8e15b759b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c77bfc9ae120e8741ccd3a354c942e8e15b759b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a591c3460b88f56fbab6af2d4e0c47ca12197405", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a591c3460b88f56fbab6af2d4e0c47ca12197405", "html_url": "https://github.com/rust-lang/rust/commit/a591c3460b88f56fbab6af2d4e0c47ca12197405", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a591c3460b88f56fbab6af2d4e0c47ca12197405/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "bd2b4ef2d1c631215523f79a8138cfa8cbd3f70e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd2b4ef2d1c631215523f79a8138cfa8cbd3f70e", "html_url": "https://github.com/rust-lang/rust/commit/bd2b4ef2d1c631215523f79a8138cfa8cbd3f70e"}, {"sha": "d93097a4936b9eea98e4759fa2fde3a052acfb42", "url": "https://api.github.com/repos/rust-lang/rust/commits/d93097a4936b9eea98e4759fa2fde3a052acfb42", "html_url": "https://github.com/rust-lang/rust/commit/d93097a4936b9eea98e4759fa2fde3a052acfb42"}], "stats": {"total": 304, "additions": 178, "deletions": 126}, "files": [{"sha": "8f087749fce05d9d83c93be4dabdf87aa678b519", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a591c3460b88f56fbab6af2d4e0c47ca12197405/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a591c3460b88f56fbab6af2d4e0c47ca12197405/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a591c3460b88f56fbab6af2d4e0c47ca12197405", "patch": "@@ -1123,16 +1123,13 @@ name = \"ra_vfs\"\n version = \"0.1.0\"\n dependencies = [\n  \"crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flexi_logger 0.10.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"notify 4.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ra_arena 0.1.0\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"thread_worker 0.1.0\",\n  \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n "}, {"sha": "fdaf31b9c6f02997f1efe468e61d2dd0f2a0d705", "filename": "crates/ra_vfs/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2FCargo.toml?ref=a591c3460b88f56fbab6af2d4e0c47ca12197405", "patch": "@@ -11,12 +11,8 @@ rustc-hash = \"1.0\"\n crossbeam-channel = \"0.3.5\"\n log = \"0.4.6\"\n notify = \"4.0.9\"\n-drop_bomb = \"0.1.0\"\n parking_lot = \"0.7.0\"\n \n-thread_worker = { path = \"../thread_worker\" }\n-ra_arena = { path = \"../ra_arena\" }\n-\n [dev-dependencies]\n tempfile = \"3\"\n flexi_logger = \"0.10.0\""}, {"sha": "5969ee0d06191e9d2206e694884472c59c5f2dee", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 113, "deletions": 69, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=a591c3460b88f56fbab6af2d4e0c47ca12197405", "patch": "@@ -3,13 +3,14 @@ use std::{\n     path::{Path, PathBuf},\n     sync::{mpsc, Arc},\n     time::Duration,\n+    thread,\n };\n-use crossbeam_channel::{Sender, unbounded, RecvError, select};\n+use crossbeam_channel::{Sender, Receiver, unbounded, RecvError, select};\n use relative_path::RelativePathBuf;\n use walkdir::WalkDir;\n use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as _Watcher};\n \n-use crate::{Roots, VfsRoot};\n+use crate::{Roots, VfsRoot, VfsTask};\n \n pub(crate) enum Task {\n     AddRoot { root: VfsRoot },\n@@ -18,7 +19,7 @@ pub(crate) enum Task {\n /// `TaskResult` transfers files read on the IO thread to the VFS on the main\n /// thread.\n #[derive(Debug)]\n-pub enum TaskResult {\n+pub(crate) enum TaskResult {\n     /// Emitted when we've recursively scanned a source root during the initial\n     /// load.\n     BulkLoadRoot { root: VfsRoot, files: Vec<(RelativePathBuf, String)> },\n@@ -46,7 +47,46 @@ enum ChangeKind {\n \n const WATCHER_DELAY: Duration = Duration::from_millis(250);\n \n-pub(crate) type Worker = thread_worker::Worker<Task, TaskResult>;\n+// Like thread::JoinHandle, but joins the thread on drop.\n+//\n+// This is useful because it guarantees the absence of run-away threads, even if\n+// code panics. This is important, because we might see panics in the test and\n+// we might be used in an IDE context, where a failed component is just\n+// restarted.\n+//\n+// Because all threads are joined, care must be taken to avoid deadlocks. That\n+// typically means ensuring that channels are dropped before the threads.\n+struct ScopedThread(Option<thread::JoinHandle<()>>);\n+\n+impl ScopedThread {\n+    fn spawn(name: String, f: impl FnOnce() + Send + 'static) -> ScopedThread {\n+        let handle = thread::Builder::new().name(name).spawn(f).unwrap();\n+        ScopedThread(Some(handle))\n+    }\n+}\n+\n+impl Drop for ScopedThread {\n+    fn drop(&mut self) {\n+        let res = self.0.take().unwrap().join();\n+        if !thread::panicking() {\n+            res.unwrap();\n+        }\n+    }\n+}\n+\n+pub(crate) struct Worker {\n+    // XXX: field order is significant here.\n+    //\n+    // In Rust, fields are dropped in the declaration order, and we rely on this\n+    // here. We must close sender first, so that the  `thread` (who holds the\n+    // opposite side of the channel) noticed shutdown. Then, we must join the\n+    // thread, but we must keep receiver alive so that the thread does not\n+    // panic.\n+    pub(crate) sender: Sender<Task>,\n+    _thread: ScopedThread,\n+    pub(crate) receiver: Receiver<VfsTask>,\n+}\n+\n pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n     // This is a pretty elaborate setup of threads & channels! It is\n     // explained by the following concerns:\n@@ -55,74 +95,75 @@ pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n     //    * we want to read all files from a single thread, to guarantee that\n     //      we always get fresher versions and never go back in time.\n     //    * we want to tear down everything neatly during shutdown.\n-    Worker::spawn(\n-        \"vfs\",\n-        128,\n-        // This are the channels we use to communicate with outside world.\n-        // If `input_receiver` is closed we need to tear ourselves down.\n-        // `output_sender` should not be closed unless the parent died.\n-        move |input_receiver, output_sender| {\n-            // Make sure that the destruction order is\n-            //\n-            // * notify_sender\n-            // * _thread\n-            // * watcher_sender\n-            //\n-            // this is required to avoid deadlocks.\n-\n-            // These are the corresponding crossbeam channels\n-            let (watcher_sender, watcher_receiver) = unbounded();\n-            let _thread;\n-            {\n-                // These are `std` channels notify will send events to\n-                let (notify_sender, notify_receiver) = mpsc::channel();\n-\n-                let mut watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n-                    .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n-                    .ok();\n-                // Start a silly thread to transform between two channels\n-                _thread = thread_worker::ScopedThread::spawn(\"notify-convertor\", move || {\n-                    notify_receiver\n-                        .into_iter()\n-                        .for_each(|event| convert_notify_event(event, &watcher_sender))\n-                });\n-\n-                // Process requests from the called or notifications from\n-                // watcher until the caller says stop.\n-                loop {\n-                    select! {\n-                        // Received request from the caller. If this channel is\n-                        // closed, we should shutdown everything.\n-                        recv(input_receiver) -> t => match t {\n-                            Err(RecvError) => {\n-                                drop(input_receiver);\n-                                break\n-                            },\n-                            Ok(Task::AddRoot { root }) => {\n-                                watch_root(watcher.as_mut(), &output_sender, &*roots, root);\n-                            }\n-                        },\n-                        // Watcher send us changes. If **this** channel is\n-                        // closed, the watcher has died, which indicates a bug\n-                        // -- escalate!\n-                        recv(watcher_receiver) -> event => match event {\n-                            Err(RecvError) => panic!(\"watcher is dead\"),\n-                            Ok((path, change)) => {\n-                                handle_change(watcher.as_mut(), &output_sender, &*roots, path, change);\n-                            }\n+    let _thread;\n+    // This are the channels we use to communicate with outside world.\n+    // If `input_receiver` is closed we need to tear ourselves down.\n+    // `output_sender` should not be closed unless the parent died.\n+    let (input_sender, input_receiver) = unbounded();\n+    let (output_sender, output_receiver) = unbounded();\n+\n+    _thread = ScopedThread::spawn(\"vfs\".to_string(), move || {\n+        // Make sure that the destruction order is\n+        //\n+        // * notify_sender\n+        // * _thread\n+        // * watcher_sender\n+        //\n+        // this is required to avoid deadlocks.\n+\n+        // These are the corresponding crossbeam channels\n+        let (watcher_sender, watcher_receiver) = unbounded();\n+        let _notify_thread;\n+        {\n+            // These are `std` channels notify will send events to\n+            let (notify_sender, notify_receiver) = mpsc::channel();\n+\n+            let mut watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n+                .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n+                .ok();\n+            // Start a silly thread to transform between two channels\n+            _notify_thread = ScopedThread::spawn(\"notify-convertor\".to_string(), move || {\n+                notify_receiver\n+                    .into_iter()\n+                    .for_each(|event| convert_notify_event(event, &watcher_sender))\n+            });\n+\n+            // Process requests from the called or notifications from\n+            // watcher until the caller says stop.\n+            loop {\n+                select! {\n+                    // Received request from the caller. If this channel is\n+                    // closed, we should shutdown everything.\n+                    recv(input_receiver) -> t => match t {\n+                        Err(RecvError) => {\n+                            drop(input_receiver);\n+                            break\n                         },\n-                    }\n+                        Ok(Task::AddRoot { root }) => {\n+                            watch_root(watcher.as_mut(), &output_sender, &*roots, root);\n+                        }\n+                    },\n+                    // Watcher send us changes. If **this** channel is\n+                    // closed, the watcher has died, which indicates a bug\n+                    // -- escalate!\n+                    recv(watcher_receiver) -> event => match event {\n+                        Err(RecvError) => panic!(\"watcher is dead\"),\n+                        Ok((path, change)) => {\n+                            handle_change(watcher.as_mut(), &output_sender, &*roots, path, change);\n+                        }\n+                    },\n                 }\n             }\n-            // Drain pending events: we are not interested in them anyways!\n-            watcher_receiver.into_iter().for_each(|_| ());\n-        },\n-    )\n+        }\n+        // Drain pending events: we are not interested in them anyways!\n+        watcher_receiver.into_iter().for_each(|_| ());\n+    });\n+    Worker { sender: input_sender, _thread, receiver: output_receiver }\n }\n \n fn watch_root(\n     watcher: Option<&mut RecommendedWatcher>,\n-    sender: &Sender<TaskResult>,\n+    sender: &Sender<VfsTask>,\n     roots: &Roots,\n     root: VfsRoot,\n ) {\n@@ -136,7 +177,8 @@ fn watch_root(\n             Some((path, text))\n         })\n         .collect();\n-    sender.send(TaskResult::BulkLoadRoot { root, files }).unwrap();\n+    let res = TaskResult::BulkLoadRoot { root, files };\n+    sender.send(VfsTask(res)).unwrap();\n     log::debug!(\"... loaded {}\", root_path.display());\n }\n \n@@ -173,7 +215,7 @@ fn convert_notify_event(event: DebouncedEvent, sender: &Sender<(PathBuf, ChangeK\n \n fn handle_change(\n     watcher: Option<&mut RecommendedWatcher>,\n-    sender: &Sender<TaskResult>,\n+    sender: &Sender<VfsTask>,\n     roots: &Roots,\n     path: PathBuf,\n     kind: ChangeKind,\n@@ -195,13 +237,15 @@ fn handle_change(\n                 .try_for_each(|rel_path| {\n                     let abs_path = rel_path.to_path(&roots.path(root));\n                     let text = read_to_string(&abs_path);\n-                    sender.send(TaskResult::SingleFile { root, path: rel_path, text })\n+                    let res = TaskResult::SingleFile { root, path: rel_path, text };\n+                    sender.send(VfsTask(res))\n                 })\n                 .unwrap()\n         }\n         ChangeKind::Write | ChangeKind::Remove => {\n             let text = read_to_string(&path);\n-            sender.send(TaskResult::SingleFile { root, path: rel_path, text }).unwrap();\n+            let res = TaskResult::SingleFile { root, path: rel_path, text };\n+            sender.send(VfsTask(res)).unwrap();\n         }\n     }\n }"}, {"sha": "808c138dfee19d8c051ed27692acd99afbae5731", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 54, "deletions": 38, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=a591c3460b88f56fbab6af2d4e0c47ca12197405", "patch": "@@ -25,7 +25,6 @@ use std::{\n };\n \n use crossbeam_channel::Receiver;\n-use ra_arena::{impl_arena_id, Arena, RawId, map::ArenaMap};\n use relative_path::{RelativePath, RelativePathBuf};\n use rustc_hash::{FxHashMap, FxHashSet};\n \n@@ -34,14 +33,23 @@ use crate::{\n     roots::Roots,\n };\n \n-pub use crate::{\n-    io::TaskResult as VfsTask,\n-    roots::VfsRoot,\n-};\n+pub use crate::roots::VfsRoot;\n+\n+/// Opaque wrapper around file-system event.\n+///\n+/// Calling code is expected to just pass `VfsTask` to `handle_task` method. It\n+/// is exposed as a public API so that the caller can plug vfs events into the\n+/// main event loop and be notified when changes happen.\n+pub struct VfsTask(TaskResult);\n+\n+impl fmt::Debug for VfsTask {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(\"VfsTask { ... }\")\n+    }\n+}\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct VfsFile(pub RawId);\n-impl_arena_id!(VfsFile);\n+pub struct VfsFile(pub u32);\n \n struct VfsFileData {\n     root: VfsRoot,\n@@ -52,8 +60,8 @@ struct VfsFileData {\n \n pub struct Vfs {\n     roots: Arc<Roots>,\n-    files: Arena<VfsFile, VfsFileData>,\n-    root2files: ArenaMap<VfsRoot, FxHashSet<VfsFile>>,\n+    files: Vec<VfsFileData>,\n+    root2files: FxHashMap<VfsRoot, FxHashSet<VfsFile>>,\n     pending_changes: Vec<VfsChange>,\n     worker: Worker,\n }\n@@ -68,18 +76,25 @@ impl fmt::Debug for Vfs {\n     }\n }\n \n+#[derive(Debug, Clone)]\n+pub enum VfsChange {\n+    AddRoot { root: VfsRoot, files: Vec<(VfsFile, RelativePathBuf, Arc<String>)> },\n+    AddFile { root: VfsRoot, file: VfsFile, path: RelativePathBuf, text: Arc<String> },\n+    RemoveFile { root: VfsRoot, file: VfsFile, path: RelativePathBuf },\n+    ChangeFile { file: VfsFile, text: Arc<String> },\n+}\n+\n impl Vfs {\n     pub fn new(roots: Vec<PathBuf>) -> (Vfs, Vec<VfsRoot>) {\n         let roots = Arc::new(Roots::new(roots));\n         let worker = io::start(Arc::clone(&roots));\n-        let mut root2files = ArenaMap::default();\n+        let mut root2files = FxHashMap::default();\n \n         for root in roots.iter() {\n             root2files.insert(root, Default::default());\n-            worker.sender().send(io::Task::AddRoot { root }).unwrap();\n+            worker.sender.send(io::Task::AddRoot { root }).unwrap();\n         }\n-        let res =\n-            Vfs { roots, files: Arena::default(), root2files, worker, pending_changes: Vec::new() };\n+        let res = Vfs { roots, files: Vec::new(), root2files, worker, pending_changes: Vec::new() };\n         let vfs_roots = res.roots.iter().collect();\n         (res, vfs_roots)\n     }\n@@ -96,8 +111,8 @@ impl Vfs {\n     }\n \n     pub fn file2path(&self, file: VfsFile) -> PathBuf {\n-        let rel_path = &self.files[file].path;\n-        let root_path = &self.roots.path(self.files[file].root);\n+        let rel_path = &self.file(file).path;\n+        let root_path = &self.roots.path(self.file(file).root);\n         rel_path.to_path(root_path)\n     }\n \n@@ -154,23 +169,23 @@ impl Vfs {\n         mem::replace(&mut self.pending_changes, Vec::new())\n     }\n \n-    pub fn task_receiver(&self) -> &Receiver<io::TaskResult> {\n-        self.worker.receiver()\n+    pub fn task_receiver(&self) -> &Receiver<VfsTask> {\n+        &self.worker.receiver\n     }\n \n-    pub fn handle_task(&mut self, task: io::TaskResult) {\n-        match task {\n+    pub fn handle_task(&mut self, task: VfsTask) {\n+        match task.0 {\n             TaskResult::BulkLoadRoot { root, files } => {\n                 let mut cur_files = Vec::new();\n                 // While we were scanning the root in the background, a file might have\n                 // been open in the editor, so we need to account for that.\n-                let existing = self.root2files[root]\n+                let existing = self.root2files[&root]\n                     .iter()\n-                    .map(|&file| (self.files[file].path.clone(), file))\n+                    .map(|&file| (self.file(file).path.clone(), file))\n                     .collect::<FxHashMap<_, _>>();\n                 for (path, text) in files {\n                     if let Some(&file) = existing.get(&path) {\n-                        let text = Arc::clone(&self.files[file].text);\n+                        let text = Arc::clone(&self.file(file).text);\n                         cur_files.push((file, path, text));\n                         continue;\n                     }\n@@ -184,7 +199,7 @@ impl Vfs {\n             }\n             TaskResult::SingleFile { root, path, text } => {\n                 let existing_file = self.find_file(root, &path);\n-                if existing_file.map(|file| self.files[file].is_overlayed) == Some(true) {\n+                if existing_file.map(|file| self.file(file).is_overlayed) == Some(true) {\n                     return;\n                 }\n                 match (existing_file, text) {\n@@ -240,23 +255,24 @@ impl Vfs {\n         is_overlayed: bool,\n     ) -> VfsFile {\n         let data = VfsFileData { root, path, text, is_overlayed };\n-        let file = self.files.alloc(data);\n-        self.root2files.get_mut(root).unwrap().insert(file);\n+        let file = VfsFile(self.files.len() as u32);\n+        self.files.push(data);\n+        self.root2files.get_mut(&root).unwrap().insert(file);\n         file\n     }\n \n     fn raw_change_file(&mut self, file: VfsFile, new_text: Arc<String>, is_overlayed: bool) {\n-        let mut file_data = &mut self.files[file];\n+        let mut file_data = &mut self.file_mut(file);\n         file_data.text = new_text;\n         file_data.is_overlayed = is_overlayed;\n     }\n \n     fn raw_remove_file(&mut self, file: VfsFile) {\n         // FIXME: use arena with removal\n-        self.files[file].text = Default::default();\n-        self.files[file].path = Default::default();\n-        let root = self.files[file].root;\n-        let removed = self.root2files.get_mut(root).unwrap().remove(&file);\n+        self.file_mut(file).text = Default::default();\n+        self.file_mut(file).path = Default::default();\n+        let root = self.file(file).root;\n+        let removed = self.root2files.get_mut(&root).unwrap().remove(&file);\n         assert!(removed);\n     }\n \n@@ -267,14 +283,14 @@ impl Vfs {\n     }\n \n     fn find_file(&self, root: VfsRoot, path: &RelativePath) -> Option<VfsFile> {\n-        self.root2files[root].iter().map(|&it| it).find(|&file| self.files[file].path == path)\n+        self.root2files[&root].iter().map(|&it| it).find(|&file| self.file(file).path == path)\n     }\n-}\n \n-#[derive(Debug, Clone)]\n-pub enum VfsChange {\n-    AddRoot { root: VfsRoot, files: Vec<(VfsFile, RelativePathBuf, Arc<String>)> },\n-    AddFile { root: VfsRoot, file: VfsFile, path: RelativePathBuf, text: Arc<String> },\n-    RemoveFile { root: VfsRoot, file: VfsFile, path: RelativePathBuf },\n-    ChangeFile { file: VfsFile, text: Arc<String> },\n+    fn file(&self, file: VfsFile) -> &VfsFileData {\n+        &self.files[file.0 as usize]\n+    }\n+\n+    fn file_mut(&mut self, file: VfsFile) -> &mut VfsFileData {\n+        &mut self.files[file.0 as usize]\n+    }\n }"}, {"sha": "4503458eed173e62513a180a3e96edf607046ee6", "filename": "crates/ra_vfs/src/roots.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a591c3460b88f56fbab6af2d4e0c47ca12197405/crates%2Fra_vfs%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Froots.rs?ref=a591c3460b88f56fbab6af2d4e0c47ca12197405", "patch": "@@ -1,16 +1,13 @@\n use std::{\n     iter,\n-    sync::Arc,\n     path::{Path, PathBuf},\n };\n \n use relative_path::{ RelativePath, RelativePathBuf};\n-use ra_arena::{impl_arena_id, Arena, RawId};\n \n /// VfsRoot identifies a watched directory on the file system.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct VfsRoot(pub RawId);\n-impl_arena_id!(VfsRoot);\n+pub struct VfsRoot(pub u32);\n \n /// Describes the contents of a single source root.\n ///\n@@ -25,22 +22,20 @@ struct RootData {\n }\n \n pub(crate) struct Roots {\n-    roots: Arena<VfsRoot, Arc<RootData>>,\n+    roots: Vec<RootData>,\n }\n \n impl Roots {\n     pub(crate) fn new(mut paths: Vec<PathBuf>) -> Roots {\n-        let mut roots = Arena::default();\n+        let mut roots = Vec::new();\n         // A hack to make nesting work.\n         paths.sort_by_key(|it| std::cmp::Reverse(it.as_os_str().len()));\n         paths.dedup();\n         for (i, path) in paths.iter().enumerate() {\n             let nested_roots =\n                 paths[..i].iter().filter_map(|it| rel_path(path, it)).collect::<Vec<_>>();\n \n-            let config = Arc::new(RootData::new(path.clone(), nested_roots));\n-\n-            roots.alloc(config.clone());\n+            roots.push(RootData::new(path.clone(), nested_roots));\n         }\n         Roots { roots }\n     }\n@@ -54,20 +49,24 @@ impl Roots {\n         self.roots.len()\n     }\n     pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = VfsRoot> + 'a {\n-        self.roots.iter().map(|(id, _)| id)\n+        (0..self.roots.len()).into_iter().map(|idx| VfsRoot(idx as u32))\n     }\n     pub(crate) fn path(&self, root: VfsRoot) -> &Path {\n-        self.roots[root].path.as_path()\n+        self.root(root).path.as_path()\n     }\n     /// Checks if root contains a path and returns a root-relative path.\n     pub(crate) fn contains(&self, root: VfsRoot, path: &Path) -> Option<RelativePathBuf> {\n-        let data = &self.roots[root];\n+        let data = self.root(root);\n         iter::once(&data.path)\n             .chain(data.canonical_path.as_ref().into_iter())\n             .find_map(|base| rel_path(base, path))\n             .filter(|path| !data.excluded_dirs.contains(path))\n             .filter(|path| !data.is_excluded(path))\n     }\n+\n+    fn root(&self, root: VfsRoot) -> &RootData {\n+        &self.roots[root.0 as usize]\n+    }\n }\n \n impl RootData {"}]}