{"sha": "6377c5223307e6bff3d1555c0cddd34bef1b68a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNzdjNTIyMzMwN2U2YmZmM2QxNTU1YzBjZGRkMzRiZWYxYjY4YTA=", "commit": {"author": {"name": "Ingvar Stepanyan", "email": "me@rreverser.com", "date": "2018-01-30T17:05:31Z"}, "committer": {"name": "Ingvar Stepanyan", "email": "me@rreverser.com", "date": "2018-02-04T11:54:03Z"}, "message": "Fix comment handling in macros", "tree": {"sha": "7119e2f118948772c4a2ed7bcc49cff4ad397185", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7119e2f118948772c4a2ed7bcc49cff4ad397185"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6377c5223307e6bff3d1555c0cddd34bef1b68a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6377c5223307e6bff3d1555c0cddd34bef1b68a0", "html_url": "https://github.com/rust-lang/rust/commit/6377c5223307e6bff3d1555c0cddd34bef1b68a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6377c5223307e6bff3d1555c0cddd34bef1b68a0/comments", "author": {"login": "RReverser", "id": 557590, "node_id": "MDQ6VXNlcjU1NzU5MA==", "avatar_url": "https://avatars.githubusercontent.com/u/557590?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RReverser", "html_url": "https://github.com/RReverser", "followers_url": "https://api.github.com/users/RReverser/followers", "following_url": "https://api.github.com/users/RReverser/following{/other_user}", "gists_url": "https://api.github.com/users/RReverser/gists{/gist_id}", "starred_url": "https://api.github.com/users/RReverser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RReverser/subscriptions", "organizations_url": "https://api.github.com/users/RReverser/orgs", "repos_url": "https://api.github.com/users/RReverser/repos", "events_url": "https://api.github.com/users/RReverser/events{/privacy}", "received_events_url": "https://api.github.com/users/RReverser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RReverser", "id": 557590, "node_id": "MDQ6VXNlcjU1NzU5MA==", "avatar_url": "https://avatars.githubusercontent.com/u/557590?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RReverser", "html_url": "https://github.com/RReverser", "followers_url": "https://api.github.com/users/RReverser/followers", "following_url": "https://api.github.com/users/RReverser/following{/other_user}", "gists_url": "https://api.github.com/users/RReverser/gists{/gist_id}", "starred_url": "https://api.github.com/users/RReverser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RReverser/subscriptions", "organizations_url": "https://api.github.com/users/RReverser/orgs", "repos_url": "https://api.github.com/users/RReverser/repos", "events_url": "https://api.github.com/users/RReverser/events{/privacy}", "received_events_url": "https://api.github.com/users/RReverser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70e77162621c7cde2435224cf1decdee088be27e", "url": "https://api.github.com/repos/rust-lang/rust/commits/70e77162621c7cde2435224cf1decdee088be27e", "html_url": "https://github.com/rust-lang/rust/commit/70e77162621c7cde2435224cf1decdee088be27e"}], "stats": {"total": 112, "additions": 88, "deletions": 24}, "files": [{"sha": "bd1523f2deaf1267e11b0cfd7dfe81459d856853", "filename": "src/macros.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6377c5223307e6bff3d1555c0cddd34bef1b68a0/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6377c5223307e6bff3d1555c0cddd34bef1b68a0/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=6377c5223307e6bff3d1555c0cddd34bef1b68a0", "patch": "@@ -311,7 +311,6 @@ pub fn rewrite_macro_def(\n     let multi_branch_style = def.legacy || parsed_def.branches.len() != 1;\n \n     let mac_indent = if multi_branch_style {\n-        result += \" {\";\n         indent.block_indent(context.config)\n     } else {\n         indent\n@@ -322,28 +321,25 @@ pub fn rewrite_macro_def(\n     let branch_items = itemize_list(\n         context.codemap,\n         parsed_def.branches.iter(),\n-        \"\",\n-        \"\",\n-        |branch| branch.args_span.lo(),\n-        |branch| branch.body.hi(),\n+        \"}\",\n+        \";\",\n+        |branch| {\n+            branch.span.lo()\n+        },\n+        |branch| {\n+            branch.span.hi()\n+        },\n         |branch| {\n-            let mut result = String::new();\n-\n             // Only attempt to format function-like macros.\n             if branch.args_paren_kind != DelimToken::Paren {\n                 // FIXME(#1539): implement for non-sugared macros.\n                 return None;\n             }\n \n-            let args = format_macro_args(branch.args.clone())?;\n+            let mut result = format_macro_args(branch.args.clone())?;\n \n             if multi_branch_style {\n-                result += \"\\n\";\n-                result += &mac_indent_str;\n-                result += &args;\n                 result += \" =>\";\n-            } else {\n-                result += &args;\n             }\n \n             // The macro body is the most interesting part. It might end up as various\n@@ -418,13 +414,14 @@ pub fn rewrite_macro_def(\n             }\n \n             result += \"}\";\n+\n             if def.legacy {\n                 result += \";\";\n             }\n-            result += \"\\n\";\n+\n             Some(result)\n         },\n-        span.lo(),\n+        context.codemap.span_after(span, \"{\"),\n         span.hi(),\n         false\n     ).collect::<Vec<_>>();\n@@ -439,14 +436,20 @@ pub fn rewrite_macro_def(\n         trailing_separator: SeparatorTactic::Never,\n         separator_place: SeparatorPlace::Back,\n         shape: arm_shape,\n-        ends_with_newline: false,\n+        ends_with_newline: true,\n         preserve_newline: true,\n         config: context.config,\n     };\n \n+    if multi_branch_style {\n+        result += \" {\\n\";\n+        result += &mac_indent_str;\n+    }\n+\n     result += write_list(&branch_items, &fmt)?.as_str();\n \n     if multi_branch_style {\n+        result += \"\\n\";\n         result += &indent.to_string(context.config);\n         result += \"}\";\n     }\n@@ -792,28 +795,29 @@ impl MacroParser {\n     // `(` ... `)` `=>` `{` ... `}`\n     fn parse_branch(&mut self) -> Option<MacroBranch> {\n         let tok = self.toks.next()?;\n-        let (args_span, args_paren_kind) = match tok {\n+        let (lo, args_paren_kind) = match tok {\n             TokenTree::Token(..) => return None,\n-            TokenTree::Delimited(sp, ref d) => (sp, d.delim),\n+            TokenTree::Delimited(sp, ref d) => (sp.lo(), d.delim),\n         };\n         let args = tok.joint().into();\n         match self.toks.next()? {\n             TokenTree::Token(_, Token::FatArrow) => {}\n             _ => return None,\n         }\n-        let body = match self.toks.next()? {\n+        let (mut hi, body) = match self.toks.next()? {\n             TokenTree::Token(..) => return None,\n             TokenTree::Delimited(sp, _) => {\n                 let data = sp.data();\n-                Span::new(data.lo + BytePos(1), data.hi - BytePos(1), data.ctxt)\n+                (data.hi, Span::new(data.lo + BytePos(1), data.hi - BytePos(1), data.ctxt))\n             }\n         };\n-        if let Some(TokenTree::Token(_, Token::Semi)) = self.toks.look_ahead(0) {\n+        if let Some(TokenTree::Token(sp, Token::Semi)) = self.toks.look_ahead(0) {\n             self.toks.next();\n+            hi = sp.hi();\n         }\n         Some(MacroBranch {\n+            span: mk_sp(lo, hi),\n             args_paren_kind,\n-            args_span,\n             args,\n             body,\n         })\n@@ -828,8 +832,8 @@ struct Macro {\n // FIXME: it would be more efficient to use references to the token streams\n // rather than clone them, if we can make the borrowing work out.\n struct MacroBranch {\n+    span: Span,\n     args_paren_kind: DelimToken,\n-    args_span: Span,\n     args: ThinTokenStream,\n     body: Span,\n }"}, {"sha": "7d14f44971d5827f8d1f5f5ebcec2cfc9d23e802", "filename": "tests/source/macro_rules.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6377c5223307e6bff3d1555c0cddd34bef1b68a0/tests%2Fsource%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6377c5223307e6bff3d1555c0cddd34bef1b68a0/tests%2Fsource%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmacro_rules.rs?ref=6377c5223307e6bff3d1555c0cddd34bef1b68a0", "patch": "@@ -13,8 +13,39 @@ macro_rules! m {\n \n    \t()           => {/* c */};\n \n+\t\t \t\t\t\t(@tag)   =>\n+\t\t\t\t\t\t {\n+\n+\t\t\t\t\t\t };\n+\n // d\n ( $item:ident  ) =>      {\n \tmod macro_item    {  struct $item ; }\n };\n }\n+\n+macro m2 {\n+\t// a\n+\t($expr :expr,  $( $func : ident    ) *   ) => {\n+\t\t{\n+\t\tlet    x =    $expr;\n+\t\t\t\t\t\t\t\t\t                $func (\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tx\n+\t\t\t\t\t\t\t\t\t\t\t)\n+\t}\n+\t}\n+\n+\t\t\t\t/* b */\n+\n+   \t()           => {/* c */}\n+\n+\t\t \t\t\t\t(@tag)   =>\n+\t\t\t\t\t\t {\n+\n+\t\t\t\t\t\t }\n+\n+// d\n+( $item:ident  ) =>      {\n+\tmod macro_item    {  struct $item ; }\n+}\n+}"}, {"sha": "647d442034fae98c2b6f76ef727d7fcb265d33c3", "filename": "tests/target/macro_rules.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6377c5223307e6bff3d1555c0cddd34bef1b68a0/tests%2Ftarget%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6377c5223307e6bff3d1555c0cddd34bef1b68a0/tests%2Ftarget%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmacro_rules.rs?ref=6377c5223307e6bff3d1555c0cddd34bef1b68a0", "patch": "@@ -1,14 +1,43 @@\n macro_rules! m {\n+    // a\n     ($expr: expr, $($func: ident)*) => {{\n         let x = $expr;\n         $func(x)\n     }};\n \n-    () => {};\n+    /* b */\n+    () => {\n+        /* c */\n+    };\n+\n+    (@tag) => {};\n \n+    // d\n     ($item: ident) => {\n         mod macro_item {\n             struct $item;\n         }\n     };\n }\n+\n+macro m2 {\n+    // a\n+    ($expr: expr, $($func: ident)*) => {{\n+        let x = $expr;\n+        $func(x)\n+    }}\n+\n+    /* b */\n+    () => {\n+        /* c */\n+    }\n+\n+    (@tag) => {}\n+\n+    // d\n+    ($item: ident) => {\n+        mod macro_item {\n+            struct $item;\n+        }\n+    }\n+}"}]}