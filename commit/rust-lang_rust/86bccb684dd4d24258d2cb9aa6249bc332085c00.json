{"sha": "86bccb684dd4d24258d2cb9aa6249bc332085c00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YmNjYjY4NGRkNGQyNDI1OGQyY2I5YWE2MjQ5YmMzMzIwODVjMDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-16T02:39:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-16T02:39:21Z"}, "message": "Auto merge of #75541 - camelid:intra-doc-links-for-core-option, r=jyn514\n\nSwitch to intra-doc links in `core::option`\n\nPart of #75080.\n\nI didn't change some of the links since they link into `std` and you can't link from `core` to `std` (#74481).\n\nAlso, at least one other link can't be switched to an intra-doc link because it's not supported yet (#74489).", "tree": {"sha": "a9d485a886e5bfcd181e9dc367b6cc6b8da28c1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9d485a886e5bfcd181e9dc367b6cc6b8da28c1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86bccb684dd4d24258d2cb9aa6249bc332085c00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86bccb684dd4d24258d2cb9aa6249bc332085c00", "html_url": "https://github.com/rust-lang/rust/commit/86bccb684dd4d24258d2cb9aa6249bc332085c00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86bccb684dd4d24258d2cb9aa6249bc332085c00/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f032cba02e53a8538f3c1cd431edc01a9fa1b3f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f032cba02e53a8538f3c1cd431edc01a9fa1b3f8", "html_url": "https://github.com/rust-lang/rust/commit/f032cba02e53a8538f3c1cd431edc01a9fa1b3f8"}, {"sha": "8227b3b0b26be72874321fd2f7f416f0d5447737", "url": "https://api.github.com/repos/rust-lang/rust/commits/8227b3b0b26be72874321fd2f7f416f0d5447737", "html_url": "https://github.com/rust-lang/rust/commit/8227b3b0b26be72874321fd2f7f416f0d5447737"}], "stats": {"total": 112, "additions": 22, "deletions": 90}, "files": [{"sha": "6d078fb0a54d61d89173b25fa047e00ab2550cd9", "filename": "library/core/src/option.rs", "status": "modified", "additions": 22, "deletions": 90, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/86bccb684dd4d24258d2cb9aa6249bc332085c00/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86bccb684dd4d24258d2cb9aa6249bc332085c00/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=86bccb684dd4d24258d2cb9aa6249bc332085c00", "patch": "@@ -127,11 +127,7 @@\n //! }\n //! ```\n //!\n-//! [`Option`]: enum.Option.html\n-//! [`Some`]: enum.Option.html#variant.Some\n-//! [`None`]: enum.Option.html#variant.None\n //! [`Box<T>`]: ../../std/boxed/struct.Box.html\n-//! [`i32`]: ../../std/primitive.i32.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -142,7 +138,7 @@ use crate::{\n     ops::{self, Deref, DerefMut},\n };\n \n-/// The `Option` type. See [the module level documentation](index.html) for more.\n+/// The `Option` type. See [the module level documentation](self) for more.\n #[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n #[rustc_diagnostic_item = \"option_type\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -175,8 +171,6 @@ impl<T> Option<T> {\n     /// let x: Option<u32> = None;\n     /// assert_eq!(x.is_some(), false);\n     /// ```\n-    ///\n-    /// [`Some`]: #variant.Some\n     #[must_use = \"if you intended to assert that this has a value, consider `.unwrap()` instead\"]\n     #[inline]\n     #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n@@ -196,8 +190,6 @@ impl<T> Option<T> {\n     /// let x: Option<u32> = None;\n     /// assert_eq!(x.is_none(), true);\n     /// ```\n-    ///\n-    /// [`None`]: #variant.None\n     #[must_use = \"if you intended to assert that this doesn't have a value, consider \\\n                   `.and_then(|| panic!(\\\"`Option` had a value when expected `None`\\\"))` instead\"]\n     #[inline]\n@@ -249,9 +241,8 @@ impl<T> Option<T> {\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n     ///\n-    /// [`map`]: enum.Option.html#method.map\n+    /// [`map`]: Option::map\n     /// [`String`]: ../../std/string/struct.String.html\n-    /// [`usize`]: ../../std/primitive.usize.html\n     ///\n     /// ```\n     /// let text: Option<String> = Some(\"Hello, world!\".to_string());\n@@ -292,8 +283,6 @@ impl<T> Option<T> {\n     }\n \n     /// Converts from [`Pin`]`<&Option<T>>` to `Option<`[`Pin`]`<&T>>`.\n-    ///\n-    /// [`Pin`]: ../pin/struct.Pin.html\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {\n@@ -303,8 +292,6 @@ impl<T> Option<T> {\n     }\n \n     /// Converts from [`Pin`]`<&mut Option<T>>` to `Option<`[`Pin`]`<&mut T>>`.\n-    ///\n-    /// [`Pin`]: ../pin/struct.Pin.html\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {\n@@ -324,9 +311,6 @@ impl<T> Option<T> {\n     /// Panics if the value is a [`None`] with a custom panic message provided by\n     /// `msg`.\n     ///\n-    /// [`Some`]: #variant.Some\n-    /// [`None`]: #variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -355,17 +339,14 @@ impl<T> Option<T> {\n     /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n     /// [`unwrap_or_default`].\n     ///\n-    /// [`unwrap_or`]: #method.unwrap_or\n-    /// [`unwrap_or_else`]: #method.unwrap_or_else\n-    /// [`unwrap_or_default`]: #method.unwrap_or_default\n+    /// [`unwrap_or`]: Option::unwrap_or\n+    /// [`unwrap_or_else`]: Option::unwrap_or_else\n+    /// [`unwrap_or_default`]: Option::unwrap_or_default\n     ///\n     /// # Panics\n     ///\n     /// Panics if the self value equals [`None`].\n     ///\n-    /// [`Some`]: #variant.Some\n-    /// [`None`]: #variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -394,8 +375,7 @@ impl<T> Option<T> {\n     /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n     /// which is lazily evaluated.\n     ///\n-    /// [`Some`]: #variant.Some\n-    /// [`unwrap_or_else`]: #method.unwrap_or_else\n+    /// [`unwrap_or_else`]: Option::unwrap_or_else\n     ///\n     /// # Examples\n     ///\n@@ -441,8 +421,6 @@ impl<T> Option<T> {\n     /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n     ///\n     /// [`String`]: ../../std/string/struct.String.html\n-    /// [`usize`]: ../../std/primitive.usize.html\n-    ///\n     /// ```\n     /// let maybe_some_string = Some(String::from(\"Hello, World!\"));\n     /// // `Option::map` takes self *by value*, consuming `maybe_some_string`\n@@ -466,7 +444,7 @@ impl<T> Option<T> {\n     /// the result of a function call, it is recommended to use [`map_or_else`],\n     /// which is lazily evaluated.\n     ///\n-    /// [`map_or_else`]: #method.map_or_else\n+    /// [`map_or_else`]: Option::map_or_else\n     ///\n     /// # Examples\n     ///\n@@ -516,12 +494,11 @@ impl<T> Option<T> {\n     /// result of a function call, it is recommended to use [`ok_or_else`], which is\n     /// lazily evaluated.\n     ///\n-    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n-    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`Err(err)`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`None`]: #variant.None\n-    /// [`Some(v)`]: #variant.Some\n-    /// [`ok_or_else`]: #method.ok_or_else\n+    /// [`Result<T, E>`]: Result\n+    /// [`Ok(v)`]: Ok\n+    /// [`Err(err)`]: Err\n+    /// [`Some(v)`]: Some\n+    /// [`ok_or_else`]: Option::ok_or_else\n     ///\n     /// # Examples\n     ///\n@@ -544,11 +521,10 @@ impl<T> Option<T> {\n     /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n     /// [`Ok(v)`] and [`None`] to [`Err(err())`].\n     ///\n-    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n-    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`Err(err())`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`None`]: #variant.None\n-    /// [`Some(v)`]: #variant.Some\n+    /// [`Result<T, E>`]: Result\n+    /// [`Ok(v)`]: Ok\n+    /// [`Err(err())`]: Err\n+    /// [`Some(v)`]: Some\n     ///\n     /// # Examples\n     ///\n@@ -617,8 +593,6 @@ impl<T> Option<T> {\n \n     /// Returns [`None`] if the option is [`None`], otherwise returns `optb`.\n     ///\n-    /// [`None`]: #variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -652,8 +626,6 @@ impl<T> Option<T> {\n     ///\n     /// Some languages call this operation flatmap.\n     ///\n-    /// [`None`]: #variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -697,9 +669,6 @@ impl<T> Option<T> {\n     /// assert_eq!(Some(4).filter(is_even), Some(4));\n     /// ```\n     ///\n-    /// [`None`]: #variant.None\n-    /// [`Some(t)`]: #variant.Some\n-    /// [`Iterator::filter()`]: ../../std/iter/trait.Iterator.html#method.filter\n     #[inline]\n     #[stable(feature = \"option_filter\", since = \"1.27.0\")]\n     pub fn filter<P: FnOnce(&T) -> bool>(self, predicate: P) -> Self {\n@@ -717,7 +686,7 @@ impl<T> Option<T> {\n     /// result of a function call, it is recommended to use [`or_else`], which is\n     /// lazily evaluated.\n     ///\n-    /// [`or_else`]: #method.or_else\n+    /// [`or_else`]: Option::or_else\n     ///\n     /// # Examples\n     ///\n@@ -771,9 +740,6 @@ impl<T> Option<T> {\n \n     /// Returns [`Some`] if exactly one of `self`, `optb` is [`Some`], otherwise returns [`None`].\n     ///\n-    /// [`Some`]: #variant.Some\n-    /// [`None`]: #variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -810,8 +776,6 @@ impl<T> Option<T> {\n     /// Inserts `v` into the option if it is [`None`], then\n     /// returns a mutable reference to the contained value.\n     ///\n-    /// [`None`]: #variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -835,8 +799,6 @@ impl<T> Option<T> {\n     /// Inserts a value computed from `f` into the option if it is [`None`], then\n     /// returns a mutable reference to the contained value.\n     ///\n-    /// [`None`]: #variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -872,8 +834,6 @@ impl<T> Option<T> {\n \n     /// Takes the value out of the option, leaving a [`None`] in its place.\n     ///\n-    /// [`None`]: #variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -897,8 +857,6 @@ impl<T> Option<T> {\n     /// returning the old value if present,\n     /// leaving a [`Some`] in its place without deinitializing either one.\n     ///\n-    /// [`Some`]: #variant.Some\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1062,9 +1020,6 @@ impl<T: fmt::Debug> Option<T> {\n     /// Panics if the value is a [`Some`], with a panic message including the\n     /// passed message, and the content of the [`Some`].\n     ///\n-    /// [`Some`]: #variant.Some\n-    /// [`None`]: #variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1105,8 +1060,7 @@ impl<T: fmt::Debug> Option<T> {\n     /// Panics if the value is a [`Some`], with a custom panic message provided\n     /// by the [`Some`]'s value.\n     ///\n-    /// [`Some(v)`]: #variant.Some\n-    /// [`None`]: #variant.None\n+    /// [`Some(v)`]: Some\n     ///\n     /// # Examples\n     ///\n@@ -1166,11 +1120,9 @@ impl<T: Default> Option<T> {\n     /// assert_eq!(0, bad_year);\n     /// ```\n     ///\n-    /// [`Some`]: #variant.Some\n-    /// [`None`]: #variant.None\n-    /// [default value]: ../default/trait.Default.html#tymethod.default\n-    /// [`parse`]: ../../std/primitive.str.html#method.parse\n-    /// [`FromStr`]: ../../std/str/trait.FromStr.html\n+    /// [default value]: Default::default\n+    /// [`parse`]: str::parse\n+    /// [`FromStr`]: crate::str::FromStr\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_or_default(self) -> T {\n@@ -1187,8 +1139,6 @@ impl<T: Deref> Option<T> {\n     /// Leaves the original Option in-place, creating a new one with a reference\n     /// to the original one, additionally coercing the contents via [`Deref`].\n     ///\n-    /// [`Deref`]: ../../std/ops/trait.Deref.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1232,11 +1182,6 @@ impl<T, E> Option<Result<T, E>> {\n     /// [`Some`]`(`[`Ok`]`(_))` and [`Some`]`(`[`Err`]`(_))` will be mapped to\n     /// [`Ok`]`(`[`Some`]`(_))` and [`Err`]`(_)`.\n     ///\n-    /// [`None`]: #variant.None\n-    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`Some`]: #variant.Some\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1384,9 +1329,8 @@ impl<'a, T> From<&'a Option<T>> for Option<&'a T> {\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n     ///\n-    /// [`map`]: ../../std/option/enum.Option.html#method.map\n+    /// [`map`]: Option::map\n     /// [`String`]: ../../std/string/struct.String.html\n-    /// [`usize`]: ../../std/primitive.usize.html\n     ///\n     /// ```\n     /// let s: Option<String> = Some(String::from(\"Hello, Rustaceans!\"));\n@@ -1465,10 +1409,6 @@ unsafe impl<A> TrustedLen for Item<A> {}\n /// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n ///\n /// This `struct` is created by the [`Option::iter`] function.\n-///\n-/// [`Option`]: enum.Option.html\n-/// [`Some`]: enum.Option.html#variant.Some\n-/// [`Option::iter`]: enum.Option.html#method.iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Iter<'a, A: 'a> {\n@@ -1519,10 +1459,6 @@ impl<A> Clone for Iter<'_, A> {\n /// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n ///\n /// This `struct` is created by the [`Option::iter_mut`] function.\n-///\n-/// [`Option`]: enum.Option.html\n-/// [`Some`]: enum.Option.html#variant.Some\n-/// [`Option::iter_mut`]: enum.Option.html#method.iter_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IterMut<'a, A: 'a> {\n@@ -1565,8 +1501,6 @@ unsafe impl<A> TrustedLen for IterMut<'_, A> {}\n ///\n /// This `struct` is created by the [`Option::into_iter`] function.\n ///\n-/// [`Option`]: enum.Option.html\n-/// [`Some`]: enum.Option.html#variant.Some\n /// [`Option::into_iter`]: enum.Option.html#method.into_iter\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1671,8 +1605,6 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     ///\n     /// Since the third element caused an underflow, no further elements were taken,\n     /// so the final value of `shared` is 6 (= `3 + 2 + 1`), not 16.\n-    ///\n-    /// [`Iterator`]: ../iter/trait.Iterator.html\n     #[inline]\n     fn from_iter<I: IntoIterator<Item = Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this"}]}