{"sha": "ce66f5d9185aa2b81159fa61597bbb6e4cf2847f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNjZmNWQ5MTg1YWEyYjgxMTU5ZmE2MTU5N2JiYjZlNGNmMjg0N2Y=", "commit": {"author": {"name": "Michael Lamparski", "email": "diagonaldevice@gmail.com", "date": "2018-04-30T11:37:08Z"}, "committer": {"name": "Michael Lamparski", "email": "diagonaldevice@gmail.com", "date": "2018-04-30T11:37:08Z"}, "message": "flesh out tests for SliceIndex\n\nm*n lines of implementation deserves m*n lines of tests", "tree": {"sha": "43701b16ff756b8023a23dc32ebce2407f8bcba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43701b16ff756b8023a23dc32ebce2407f8bcba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce66f5d9185aa2b81159fa61597bbb6e4cf2847f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce66f5d9185aa2b81159fa61597bbb6e4cf2847f", "html_url": "https://github.com/rust-lang/rust/commit/ce66f5d9185aa2b81159fa61597bbb6e4cf2847f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce66f5d9185aa2b81159fa61597bbb6e4cf2847f/comments", "author": {"login": "ExpHP", "id": 1411280, "node_id": "MDQ6VXNlcjE0MTEyODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1411280?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ExpHP", "html_url": "https://github.com/ExpHP", "followers_url": "https://api.github.com/users/ExpHP/followers", "following_url": "https://api.github.com/users/ExpHP/following{/other_user}", "gists_url": "https://api.github.com/users/ExpHP/gists{/gist_id}", "starred_url": "https://api.github.com/users/ExpHP/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ExpHP/subscriptions", "organizations_url": "https://api.github.com/users/ExpHP/orgs", "repos_url": "https://api.github.com/users/ExpHP/repos", "events_url": "https://api.github.com/users/ExpHP/events{/privacy}", "received_events_url": "https://api.github.com/users/ExpHP/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ExpHP", "id": 1411280, "node_id": "MDQ6VXNlcjE0MTEyODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1411280?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ExpHP", "html_url": "https://github.com/ExpHP", "followers_url": "https://api.github.com/users/ExpHP/followers", "following_url": "https://api.github.com/users/ExpHP/following{/other_user}", "gists_url": "https://api.github.com/users/ExpHP/gists{/gist_id}", "starred_url": "https://api.github.com/users/ExpHP/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ExpHP/subscriptions", "organizations_url": "https://api.github.com/users/ExpHP/orgs", "repos_url": "https://api.github.com/users/ExpHP/repos", "events_url": "https://api.github.com/users/ExpHP/events{/privacy}", "received_events_url": "https://api.github.com/users/ExpHP/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0842dc67238969e39b0a08d2c4314ceefd19caa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0842dc67238969e39b0a08d2c4314ceefd19caa2", "html_url": "https://github.com/rust-lang/rust/commit/0842dc67238969e39b0a08d2c4314ceefd19caa2"}], "stats": {"total": 759, "additions": 622, "deletions": 137}, "files": [{"sha": "bfba9a6b3935568b50673d6ed72c2622a0723730", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 378, "deletions": 99, "changes": 477, "blob_url": "https://github.com/rust-lang/rust/blob/ce66f5d9185aa2b81159fa61597bbb6e4cf2847f/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce66f5d9185aa2b81159fa61597bbb6e4cf2847f/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=ce66f5d9185aa2b81159fa61597bbb6e4cf2847f", "patch": "@@ -292,19 +292,194 @@ fn test_replace_pattern() {\n }\n \n mod slice_index {\n+    // Test a slicing operation **that should succeed,**\n+    // testing it on all of the indexing methods.\n+    //\n+    // DO NOT use this in `should_panic` tests, unless you are testing the macro itself.\n+    macro_rules! assert_range_eq {\n+        ($s:expr, $range:expr, $expected:expr)\n+        => {\n+            let mut s: String = $s.to_owned();\n+            let mut expected: String = $expected.to_owned();\n+            {\n+                let s: &str = &s;\n+                let expected: &str = &expected;\n+\n+                assert_eq!(&s[$range], expected, \"(in assertion for: index)\");\n+                assert_eq!(s.get($range), Some(expected), \"(in assertion for: get)\");\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked($range), expected,\n+                        \"(in assertion for: get_unchecked)\",\n+                    );\n+                }\n+            }\n+            {\n+                let s: &mut str = &mut s;\n+                let expected: &mut str = &mut expected;\n+\n+                assert_eq!(\n+                    &mut s[$range], expected,\n+                    \"(in assertion for: index_mut)\",\n+                );\n+                assert_eq!(\n+                    s.get_mut($range), Some(&mut expected[..]),\n+                    \"(in assertion for: get_mut)\",\n+                );\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked_mut($range), expected,\n+                        \"(in assertion for: get_unchecked_mut)\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    // Make sure the macro can actually detect bugs,\n+    // because if it can't, then what are we even doing here?\n+    //\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method it calls, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"out of bounds\")]\n+    fn assert_range_eq_can_fail_by_panic() {\n+        assert_range_eq!(\"abc\", 0..5, \"abc\");\n+    }\n+\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method it calls, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"==\")]\n+    fn assert_range_eq_can_fail_by_inequality() {\n+        assert_range_eq!(\"abc\", 0..2, \"abc\");\n+    }\n+\n+    // Generates test cases for bad index operations.\n+    //\n+    // This generates `should_panic` test cases for Index/IndexMut\n+    // and `None` test cases for get/get_mut.\n+    macro_rules! panic_cases {\n+        ($(\n+            mod $case_name:ident {\n+                let DATA = $data:expr;\n+\n+                // optional:\n+                //\n+                // a similar input for which DATA[input] succeeds, and the corresponding\n+                // output str. This helps validate \"critical points\" where an input range\n+                // straddles the boundary between valid and invalid.\n+                // (such as the input `len..len`, which is just barely valid)\n+                $(\n+                    let GOOD_INPUT = $good:expr;\n+                    let GOOD_OUTPUT = $output:expr;\n+                )*\n+\n+                let BAD_INPUT = $bad:expr;\n+                const EXPECT_MSG = $expect_msg:expr; // must be a literal\n+\n+                !!generate_tests!!\n+            }\n+        )*) => {$(\n+            mod $case_name {\n+                #[test]\n+                fn pass() {\n+                    let mut v: String = $data.into();\n+\n+                    $( assert_range_eq!(v, $good, $output); )*\n+\n+                    {\n+                        let v: &str = &v;\n+                        assert_eq!(v.get($bad), None, \"(in None assertion for get)\");\n+                    }\n+\n+                    {\n+                        let v: &mut str = &mut v;\n+                        assert_eq!(v.get_mut($bad), None, \"(in None assertion for get_mut)\");\n+                    }\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_fail() {\n+                    let v: String = $data.into();\n+                    let v: &str = &v;\n+                    let _v = &v[$bad];\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_mut_fail() {\n+                    let mut v: String = $data.into();\n+                    let v: &mut str = &mut v;\n+                    let _v = &mut v[$bad];\n+                }\n+            }\n+        )*};\n+    }\n+\n+    #[test]\n+    fn simple_ascii() {\n+        assert_range_eq!(\"abc\", .., \"abc\");\n+\n+        assert_range_eq!(\"abc\", 0..2, \"ab\");\n+        assert_range_eq!(\"abc\", 0..=1, \"ab\");\n+        assert_range_eq!(\"abc\", ..2, \"ab\");\n+        assert_range_eq!(\"abc\", ..=1, \"ab\");\n+\n+        assert_range_eq!(\"abc\", 1..3, \"bc\");\n+        assert_range_eq!(\"abc\", 1..=2, \"bc\");\n+        assert_range_eq!(\"abc\", 1..1, \"\");\n+        assert_range_eq!(\"abc\", 1..=0, \"\");\n+    }\n+\n     #[test]\n-    fn test_slice() {\n-        assert_eq!(\"ab\", &\"abc\"[0..2]);\n-        assert_eq!(\"bc\", &\"abc\"[1..3]);\n-        assert_eq!(\"\", &\"abc\"[1..1]);\n-        assert_eq!(\"\\u{65e5}\", &\"\\u{65e5}\\u{672c}\"[0..3]);\n+    fn simple_unicode() {\n+        // \u65e5\u672c\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", .., \"\\u{65e5}\\u{672c}\");\n+\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 0..3, \"\\u{65e5}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 0..=2, \"\\u{65e5}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", ..3, \"\\u{65e5}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", ..=2, \"\\u{65e5}\");\n+\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 3..6, \"\\u{672c}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 3..=5, \"\\u{672c}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 3.., \"\\u{672c}\");\n \n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert_eq!(\"\u0e1b\", &data[0..3]);\n-        assert_eq!(\"\u0e23\", &data[3..6]);\n-        assert_eq!(\"\", &data[3..3]);\n-        assert_eq!(\"\u534e\", &data[30..33]);\n+        assert_range_eq!(data, 0..3, \"\u0e1b\");\n+        assert_range_eq!(data, 3..6, \"\u0e23\");\n+        assert_range_eq!(data, 3..3, \"\");\n+        assert_range_eq!(data, 30..33, \"\u534e\");\n \n+        /*0: \u4e2d\n+          3: \u534e\n+          6: V\n+          7: i\n+          8: \u1ec7\n+         11: t\n+         12:\n+         13: N\n+         14: a\n+         15: m */\n+        let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert_range_eq!(ss, 3..6, \"\u534e\");\n+        assert_range_eq!(ss, 6..16, \"Vi\u1ec7t Nam\");\n+        assert_range_eq!(ss, 6..=15, \"Vi\u1ec7t Nam\");\n+        assert_range_eq!(ss, 6.., \"Vi\u1ec7t Nam\");\n+\n+        assert_range_eq!(ss, 0..3, \"\u4e2d\");\n+        assert_range_eq!(ss, 3..7, \"\u534eV\");\n+        assert_range_eq!(ss, 3..=6, \"\u534eV\");\n+        assert_range_eq!(ss, 3..3, \"\");\n+        assert_range_eq!(ss, 3..=2, \"\");\n+    }\n+\n+    #[test]\n+    fn simple_big() {\n         fn a_million_letter_x() -> String {\n             let mut i = 0;\n             let mut rs = String::new();\n@@ -324,33 +499,7 @@ mod slice_index {\n             rs\n         }\n         let letters = a_million_letter_x();\n-        assert_eq!(half_a_million_letter_x(), &letters[0..3 * 500000]);\n-    }\n-\n-    #[test]\n-    fn test_slice_2() {\n-        let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-\n-        assert_eq!(\"\u534e\", &ss[3..6]);\n-        assert_eq!(\"Vi\u1ec7t Nam\", &ss[6..16]);\n-\n-        assert_eq!(\"ab\", &\"abc\"[0..2]);\n-        assert_eq!(\"bc\", &\"abc\"[1..3]);\n-        assert_eq!(\"\", &\"abc\"[1..1]);\n-\n-        assert_eq!(\"\u4e2d\", &ss[0..3]);\n-        assert_eq!(\"\u534eV\", &ss[3..7]);\n-        assert_eq!(\"\", &ss[3..3]);\n-        /*0: \u4e2d\n-          3: \u534e\n-          6: V\n-          7: i\n-          8: \u1ec7\n-         11: t\n-         12:\n-         13: N\n-         14: a\n-         15: m */\n+        assert_range_eq!(letters, 0..3 * 500000, half_a_million_letter_x());\n     }\n \n     #[test]\n@@ -359,55 +508,210 @@ mod slice_index {\n         &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n     }\n \n-    #[test]\n-    #[should_panic]\n-    fn test_str_slice_rangetoinclusive_max_panics() {\n-        &\"hello\"[..=usize::max_value()];\n-    }\n+    panic_cases! {\n+        mod rangefrom_len {\n+            let DATA = \"abcdef\";\n \n-    #[test]\n-    #[should_panic]\n-    fn test_str_slice_rangeinclusive_max_panics() {\n-        &\"hello\"[1..=usize::max_value()];\n-    }\n+            let GOOD_INPUT = 6..;\n+            let GOOD_OUTPUT = \"\";\n \n-    #[test]\n-    #[should_panic]\n-    fn test_str_slicemut_rangetoinclusive_max_panics() {\n-        let mut s = \"hello\".to_owned();\n-        let s: &mut str = &mut s;\n-        &mut s[..=usize::max_value()];\n+            let BAD_INPUT = 7..;\n+            const EXPECT_MSG = \"out of bounds\";\n+\n+            !!generate_tests!!\n+        }\n+\n+        mod rangeto_len {\n+            let DATA = \"abcdef\";\n+\n+            let GOOD_INPUT = ..6;\n+            let GOOD_OUTPUT = \"abcdef\";\n+\n+            let BAD_INPUT = ..7;\n+            const EXPECT_MSG = \"out of bounds\";\n+\n+            !!generate_tests!!\n+        }\n+\n+        mod rangetoinclusive_len {\n+            let DATA = \"abcdef\";\n+\n+            let GOOD_INPUT = ..=5;\n+            let GOOD_OUTPUT = \"abcdef\";\n+\n+            let BAD_INPUT = ..=6;\n+            const EXPECT_MSG = \"out of bounds\";\n+\n+            !!generate_tests!!\n+        }\n+\n+        mod range_len_len {\n+            let DATA = \"abcdef\";\n+\n+            let GOOD_INPUT = 6..6;\n+            let GOOD_OUTPUT = \"\";\n+\n+            let BAD_INPUT = 7..7;\n+            const EXPECT_MSG = \"out of bounds\";\n+\n+            !!generate_tests!!\n+        }\n+\n+        mod rangeinclusive_len_len {\n+            let DATA = \"abcdef\";\n+\n+            let GOOD_INPUT = 6..=5;\n+            let GOOD_OUTPUT = \"\";\n+\n+            let BAD_INPUT = 7..=6;\n+            const EXPECT_MSG = \"out of bounds\";\n+\n+            !!generate_tests!!\n+        }\n     }\n \n-    #[test]\n-    #[should_panic]\n-    fn test_str_slicemut_rangeinclusive_max_panics() {\n-        let mut s = \"hello\".to_owned();\n-        let s: &mut str = &mut s;\n-        &mut s[1..=usize::max_value()];\n+    panic_cases! {\n+        mod range_neg_width {\n+            let DATA = \"abcdef\";\n+\n+            let GOOD_INPUT = 4..4;\n+            let GOOD_OUTPUT = \"\";\n+\n+            let BAD_INPUT = 4..3;\n+            const EXPECT_MSG = \"begin <= end (4 <= 3)\";\n+\n+            !!generate_tests!!\n+        }\n+\n+        mod rangeinclusive_neg_width {\n+            let DATA = \"abcdef\";\n+\n+            let GOOD_INPUT = 4..=3;\n+            let GOOD_OUTPUT = \"\";\n+\n+            let BAD_INPUT = 4..=2;\n+            const EXPECT_MSG = \"begin <= end (4 <= 3)\";\n+\n+            !!generate_tests!!\n+        }\n     }\n \n-    #[test]\n-    fn test_str_get_maxinclusive() {\n-        let mut s = \"hello\".to_owned();\n-        {\n-            let s: &str = &s;\n-            assert_eq!(s.get(..=usize::max_value()), None);\n-            assert_eq!(s.get(1..=usize::max_value()), None);\n+    mod overflow {\n+        panic_cases! {\n+\n+            mod rangeinclusive {\n+                let DATA = \"hello\";\n+\n+                let BAD_INPUT = 1..=usize::max_value();\n+                const EXPECT_MSG = \"maximum usize\";\n+\n+                !!generate_tests!!\n+            }\n+\n+            mod rangetoinclusive {\n+                let DATA = \"hello\";\n+\n+                let BAD_INPUT = ..=usize::max_value();\n+                const EXPECT_MSG = \"maximum usize\";\n+\n+                !!generate_tests!!\n+            }\n         }\n-        {\n-            let s: &mut str = &mut s;\n-            assert_eq!(s.get(..=usize::max_value()), None);\n-            assert_eq!(s.get(1..=usize::max_value()), None);\n+    }\n+\n+    mod boundary {\n+        const DATA: &'static str = \"abc\u03b1\u03b2\u03b3\";\n+\n+        const BAD_START: usize = 4;\n+        const GOOD_START: usize = 3;\n+        const BAD_END: usize = 6;\n+        const GOOD_END: usize = 7;\n+        const BAD_END_INCL: usize = BAD_END - 1;\n+        const GOOD_END_INCL: usize = GOOD_END - 1;\n+\n+        // it is especially important to test all of the different range types here\n+        // because some of the logic may be duplicated as part of micro-optimizations\n+        // to dodge unicode boundary checks on half-ranges.\n+        panic_cases! {\n+            mod range_1 {\n+                let DATA = super::DATA;\n+\n+                let BAD_INPUT = super::BAD_START..super::GOOD_END;\n+                const EXPECT_MSG =\n+                    \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n+\n+                !!generate_tests!!\n+            }\n+\n+            mod range_2 {\n+                let DATA = super::DATA;\n+\n+                let BAD_INPUT = super::GOOD_START..super::BAD_END;\n+                const EXPECT_MSG =\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+\n+                !!generate_tests!!\n+            }\n+\n+            mod rangefrom {\n+                let DATA = super::DATA;\n+\n+                let BAD_INPUT = super::BAD_START..;\n+                const EXPECT_MSG =\n+                    \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n+\n+                !!generate_tests!!\n+            }\n+\n+            mod rangeto {\n+                let DATA = super::DATA;\n+\n+                let BAD_INPUT = ..super::BAD_END;\n+                const EXPECT_MSG =\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+\n+                !!generate_tests!!\n+            }\n+\n+            mod rangeinclusive_1 {\n+                let DATA = super::DATA;\n+\n+                let BAD_INPUT = super::BAD_START..=super::GOOD_END_INCL;\n+                const EXPECT_MSG =\n+                    \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n+\n+                !!generate_tests!!\n+            }\n+\n+            mod rangeinclusive_2 {\n+                let DATA = super::DATA;\n+\n+                let BAD_INPUT = super::GOOD_START..=super::BAD_END_INCL;\n+                const EXPECT_MSG =\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+\n+                !!generate_tests!!\n+            }\n+\n+            mod rangetoinclusive {\n+                let DATA = super::DATA;\n+\n+                let BAD_INPUT = ..=super::BAD_END_INCL;\n+                const EXPECT_MSG =\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+\n+                !!generate_tests!!\n+            }\n         }\n     }\n \n     const LOREM_PARAGRAPH: &'static str = \"\\\n-    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n-    ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n-    eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n-    sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n-    tempus vel, gravida nec quam.\";\n+    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem \\\n+    sit amet dolor ultricies condimentum. Praesent iaculis purus elit, ac malesuada \\\n+    quam malesuada in. Duis sed orci eros. Suspendisse sit amet magna mollis, mollis \\\n+    nunc luctus, imperdiet mi. Integer fringilla non sem ut lacinia. Fusce varius \\\n+    tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec tempus vel, \\\n+    gravida nec quam.\";\n \n     // check the panic includes the prefix of the sliced string\n     #[test]\n@@ -421,31 +725,6 @@ mod slice_index {\n     fn test_slice_fail_truncated_2() {\n         &LOREM_PARAGRAPH[..1024];\n     }\n-\n-    #[test]\n-    #[should_panic(expected=\"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\")]\n-    fn test_slice_fail_boundary_1() {\n-        &\"abc\u03b1\u03b2\u03b3\"[4..];\n-    }\n-\n-    #[test]\n-    #[should_panic(expected=\"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\")]\n-    fn test_slice_fail_boundary_2() {\n-        &\"abc\u03b1\u03b2\u03b3\"[2..6];\n-    }\n-\n-    #[test]\n-    fn test_slice_from() {\n-        assert_eq!(&\"abcd\"[0..], \"abcd\");\n-        assert_eq!(&\"abcd\"[2..], \"cd\");\n-        assert_eq!(&\"abcd\"[4..], \"\");\n-    }\n-    #[test]\n-    fn test_slice_to() {\n-        assert_eq!(&\"abcd\"[..0], \"\");\n-        assert_eq!(&\"abcd\"[..2], \"ab\");\n-        assert_eq!(&\"abcd\"[..4], \"abcd\");\n-    }\n }\n \n #[test]"}, {"sha": "5272c7427d91d58d45a4f4023ad945c48669b517", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 244, "deletions": 38, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/ce66f5d9185aa2b81159fa61597bbb6e4cf2847f/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce66f5d9185aa2b81159fa61597bbb6e4cf2847f/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=ce66f5d9185aa2b81159fa61597bbb6e4cf2847f", "patch": "@@ -376,48 +376,254 @@ fn test_windows_zip() {\n     assert_eq!(res, [14, 18, 22, 26]);\n }\n \n-#[test]\n-fn get_range() {\n-    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n-    assert_eq!(v.get(..), Some(&[0, 1, 2, 3, 4, 5][..]));\n-    assert_eq!(v.get(..2), Some(&[0, 1][..]));\n-    assert_eq!(v.get(2..), Some(&[2, 3, 4, 5][..]));\n-    assert_eq!(v.get(1..4), Some(&[1, 2, 3][..]));\n-    assert_eq!(v.get(7..), None);\n-    assert_eq!(v.get(7..10), None);\n-}\n+mod slice_index {\n+    // Test a slicing operation that should succeed,\n+    // testing it on all of the indexing methods.\n+    macro_rules! assert_range_eq {\n+        ($arr:expr, $range:expr, $expected:expr)\n+        => {\n+            let mut arr = $arr;\n+            let mut expected = $expected;\n+            {\n+                let s: &[_] = &arr;\n+                let expected: &[_] = &expected;\n+\n+                assert_eq!(&s[$range], expected, \"(in assertion for: index)\");\n+                assert_eq!(s.get($range), Some(expected), \"(in assertion for: get)\");\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked($range), expected,\n+                        \"(in assertion for: get_unchecked)\",\n+                    );\n+                }\n+            }\n+            {\n+                let s: &mut [_] = &mut arr;\n+                let expected: &mut [_] = &mut expected;\n+\n+                assert_eq!(\n+                    &mut s[$range], expected,\n+                    \"(in assertion for: index_mut)\",\n+                );\n+                assert_eq!(\n+                    s.get_mut($range), Some(&mut expected[..]),\n+                    \"(in assertion for: get_mut)\",\n+                );\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked_mut($range), expected,\n+                        \"(in assertion for: get_unchecked_mut)\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n \n-#[test]\n-fn get_mut_range() {\n-    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n-    assert_eq!(v.get_mut(..), Some(&mut [0, 1, 2, 3, 4, 5][..]));\n-    assert_eq!(v.get_mut(..2), Some(&mut [0, 1][..]));\n-    assert_eq!(v.get_mut(2..), Some(&mut [2, 3, 4, 5][..]));\n-    assert_eq!(v.get_mut(1..4), Some(&mut [1, 2, 3][..]));\n-    assert_eq!(v.get_mut(7..), None);\n-    assert_eq!(v.get_mut(7..10), None);\n-}\n-\n-#[test]\n-fn get_unchecked_range() {\n-    unsafe {\n-        let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n-        assert_eq!(v.get_unchecked(..), &[0, 1, 2, 3, 4, 5][..]);\n-        assert_eq!(v.get_unchecked(..2), &[0, 1][..]);\n-        assert_eq!(v.get_unchecked(2..), &[2, 3, 4, 5][..]);\n-        assert_eq!(v.get_unchecked(1..4), &[1, 2, 3][..]);\n+    // Make sure the macro can actually detect bugs,\n+    // because if it can't, then what are we even doing here?\n+    //\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method it calls, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"out of range\")]\n+    fn assert_range_eq_can_fail_by_panic() {\n+        assert_range_eq!([0, 1, 2], 0..5, [0, 1, 2]);\n     }\n-}\n \n-#[test]\n-fn get_unchecked_mut_range() {\n-    unsafe {\n-        let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n-        assert_eq!(v.get_unchecked_mut(..), &mut [0, 1, 2, 3, 4, 5][..]);\n-        assert_eq!(v.get_unchecked_mut(..2), &mut [0, 1][..]);\n-        assert_eq!(v.get_unchecked_mut(2..), &mut[2, 3, 4, 5][..]);\n-        assert_eq!(v.get_unchecked_mut(1..4), &mut [1, 2, 3][..]);\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method it calls, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"==\")]\n+    fn assert_range_eq_can_fail_by_inequality() {\n+        assert_range_eq!([0, 1, 2], 0..2, [0, 1, 2]);\n+    }\n+\n+    // Test cases for bad index operations.\n+    //\n+    // This generates `should_panic` test cases for Index/IndexMut\n+    // and `None` test cases for get/get_mut.\n+    macro_rules! panic_cases {\n+        ($(\n+            mod $case_name:ident {\n+                let DATA: $Data: ty = $data:expr;\n+\n+                // optional:\n+                //\n+                // a similar input for which DATA[input] succeeds, and the corresponding\n+                // output as an array.  This helps validate \"critical points\" where an\n+                // input range straddles the boundary between valid and invalid.\n+                // (such as the input `len..len`, which is just barely valid)\n+                $(\n+                    let GOOD_INPUT = $good:expr;\n+                    let GOOD_OUTPUT = $output:expr;\n+                )*\n+\n+                let BAD_INPUT = $bad:expr;\n+                const EXPECT_MSG = $expect_msg:expr;\n+\n+                !!generate_tests!!\n+            }\n+        )*) => {$(\n+            mod $case_name {\n+                #[test]\n+                fn pass() {\n+                    let mut v: $Data = $data;\n+\n+                    $( assert_range_eq!($data, $good, $output); )*\n+\n+                    {\n+                        let v: &[_] = &v;\n+                        assert_eq!(v.get($bad), None, \"(in None assertion for get)\");\n+                    }\n+\n+                    {\n+                        let v: &mut [_] = &mut v;\n+                        assert_eq!(v.get_mut($bad), None, \"(in None assertion for get_mut)\");\n+                    }\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_fail() {\n+                    let v: $Data = $data;\n+                    let v: &[_] = &v;\n+                    let _v = &v[$bad];\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_mut_fail() {\n+                    let mut v: $Data = $data;\n+                    let v: &mut [_] = &mut v;\n+                    let _v = &mut v[$bad];\n+                }\n+            }\n+        )*};\n+    }\n+\n+    #[test]\n+    fn simple() {\n+        let v = [0, 1, 2, 3, 4, 5];\n+\n+        assert_range_eq!(v, .., [0, 1, 2, 3, 4, 5]);\n+        assert_range_eq!(v, ..2, [0, 1]);\n+        assert_range_eq!(v, ..=1, [0, 1]);\n+        assert_range_eq!(v, 2.., [2, 3, 4, 5]);\n+        assert_range_eq!(v, 1..4, [1, 2, 3]);\n+        assert_range_eq!(v, 1..=3, [1, 2, 3]);\n+    }\n+\n+    panic_cases! {\n+        mod rangefrom_len {\n+            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n+\n+            let GOOD_INPUT = 6..;\n+            let GOOD_OUTPUT = [];\n+\n+            let BAD_INPUT = 7..;\n+            const EXPECT_MSG = \"but ends at\"; // perhaps not ideal\n+\n+            !!generate_tests!!\n+        }\n+\n+        mod rangeto_len {\n+            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n+\n+            let GOOD_INPUT = ..6;\n+            let GOOD_OUTPUT = [0, 1, 2, 3, 4, 5];\n+\n+            let BAD_INPUT = ..7;\n+            const EXPECT_MSG = \"out of range\";\n+\n+            !!generate_tests!!\n+        }\n+\n+        mod rangetoinclusive_len {\n+            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n+\n+            let GOOD_INPUT = ..=5;\n+            let GOOD_OUTPUT = [0, 1, 2, 3, 4, 5];\n+\n+            let BAD_INPUT = ..=6;\n+            const EXPECT_MSG = \"out of range\";\n+\n+            !!generate_tests!!\n+        }\n+\n+        mod range_len_len {\n+            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n+\n+            let GOOD_INPUT = 6..6;\n+            let GOOD_OUTPUT = [];\n+\n+            let BAD_INPUT = 7..7;\n+            const EXPECT_MSG = \"out of range\";\n+\n+            !!generate_tests!!\n+        }\n+\n+        mod rangeinclusive_len_len{\n+            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n+\n+            let GOOD_INPUT = 6..=5;\n+            let GOOD_OUTPUT = [];\n+\n+            let BAD_INPUT = 7..=6;\n+            const EXPECT_MSG = \"out of range\";\n+\n+            !!generate_tests!!\n+        }\n     }\n+\n+    panic_cases! {\n+        mod range_neg_width {\n+            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n+\n+            let GOOD_INPUT = 4..4;\n+            let GOOD_OUTPUT = [];\n+\n+            let BAD_INPUT = 4..3;\n+            const EXPECT_MSG = \"but ends at\";\n+\n+            !!generate_tests!!\n+        }\n+\n+        mod rangeinclusive_neg_width {\n+            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n+\n+            let GOOD_INPUT = 4..=3;\n+            let GOOD_OUTPUT = [];\n+\n+            let BAD_INPUT = 4..=2;\n+            const EXPECT_MSG = \"but ends at\";\n+\n+            !!generate_tests!!\n+        }\n+    }\n+\n+    panic_cases! {\n+        mod rangeinclusive_overflow {\n+            let DATA: [i32; 2] = [0, 1];\n+\n+            // note: using 0 specifically ensures that the result of overflowing is 0..0,\n+            //       so that `get` doesn't simply return None for the wrong reason.\n+            let BAD_INPUT = 0 ..= ::std::usize::MAX;\n+            const EXPECT_MSG = \"maximum usize\";\n+\n+            !!generate_tests!!\n+        }\n+\n+        mod rangetoinclusive_overflow {\n+            let DATA: [i32; 2] = [0, 1];\n+\n+            let BAD_INPUT = ..= ::std::usize::MAX;\n+            const EXPECT_MSG = \"maximum usize\";\n+\n+            !!generate_tests!!\n+        }\n+    } // panic_cases!\n }\n \n #[test]"}]}