{"sha": "52c38ba8860a09f3810fe56679f154b58654f433", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYzM4YmE4ODYwYTA5ZjM4MTBmZTU2Njc5ZjE1NGI1ODY1NGY0MzM=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-15T02:36:22Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-15T02:36:22Z"}, "message": "Merge branch 'incoming' into newsnap", "tree": {"sha": "5573393332223475864588f8bcc4656e21d156d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5573393332223475864588f8bcc4656e21d156d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52c38ba8860a09f3810fe56679f154b58654f433", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52c38ba8860a09f3810fe56679f154b58654f433", "html_url": "https://github.com/rust-lang/rust/commit/52c38ba8860a09f3810fe56679f154b58654f433", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52c38ba8860a09f3810fe56679f154b58654f433/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5dea1412223f8ed1389c385198bdbc4c5d454ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5dea1412223f8ed1389c385198bdbc4c5d454ea", "html_url": "https://github.com/rust-lang/rust/commit/e5dea1412223f8ed1389c385198bdbc4c5d454ea"}, {"sha": "a214e3abd23fa68e358ff4647aab6c34f91f3d9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a214e3abd23fa68e358ff4647aab6c34f91f3d9b", "html_url": "https://github.com/rust-lang/rust/commit/a214e3abd23fa68e358ff4647aab6c34f91f3d9b"}], "stats": {"total": 587, "additions": 335, "deletions": 252}, "files": [{"sha": "b5ce96ef2bedcc823ee5a5fed18e44ff86af30da", "filename": "Makefile.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -55,6 +55,10 @@ rwildcard=$(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2) \\\n \n include config.mk\n \n+# We track all of the object files we might build so that we can find\n+# and include all of the .d files in one fell swoop.\n+ALL_OBJ_FILES :=\n+\n MKFILE_DEPS := config.stamp $(call rwildcard,$(CFG_SRC_DIR)mk/,*)\n NON_HOST_TRIPLES = $(filter-out $(CFG_HOST_TRIPLE),$(CFG_TARGET_TRIPLES))\n \n@@ -527,3 +531,8 @@ ifneq ($(strip $(findstring TAGS.emacs,$(MAKECMDGOALS)) \\\n   CFG_INFO := $(info cfg: including ctags rules)\n   include $(CFG_SRC_DIR)mk/ctags.mk\n endif\n+\n+# Find all of the .d files and include them to add information about\n+# header file dependencies.\n+ALL_DEP_FILES := $(ALL_OBJ_FILES:%.o=%.d)\n+-include $(ALL_DEP_FILES)"}, {"sha": "6216f867bc88693141ec1c6b9270572c1f3ea097", "filename": "mk/platform.mk", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -210,18 +210,20 @@ ifeq ($(CFG_C_COMPILER),clang)\n     CXX=clang++\n   endif\n   ifeq ($(origin CPP),default)\n-    CPP=cpp\n+    CPP=clang -E\n   endif\n   CFG_GCCISH_CFLAGS += -Wall -Werror -fno-rtti -g\n   CFG_GCCISH_LINK_FLAGS += -g\n-  CFG_DEPEND_C = $(CFG_GCCISH_CROSS)$(CXX) $(CFG_GCCISH_CFLAGS) -MT \"$(1)\" \\\n-    -MM $(2)\n+  # These flags will cause the compiler to produce a .d file\n+  # next to the .o file that lists header deps.\n+  CFG_DEPEND_FLAGS = -MMD -MP -MT $(1) -MF $(1:%.o=%.d)\n \n   define CFG_MAKE_CC\n \tCFG_COMPILE_C_$(1) = $$(CFG_GCCISH_CROSS)$$(CXX)\t\\\n \t\t$$(CFG_GCCISH_CFLAGS) $$(CFG_CLANG_CFLAGS)\t\t\\\n \t\t$$(CFG_GCCISH_CFLAGS_$$(HOST_$(1)))\t\t\t\t\\\n \t    $$(CFG_CLANG_CFLAGS_$$(HOST_$(1)))\t\t\t\t\\\n+        $$(CFG_DEPEND_FLAGS)                            \\\n \t\t-c -o $$(1) $$(2)\n     CFG_LINK_C_$(1) = $$(CFG_GCCISH_CROSS)$$(CXX)\t\\\n \t\t$$(CFG_GCCISH_LINK_FLAGS) -o $$(1)\t\t\t\\\n@@ -241,19 +243,21 @@ ifeq ($(CFG_C_COMPILER),gcc)\n     CXX=g++\n   endif\n   ifeq ($(origin CPP),default)\n-    CPP=cpp\n+    CPP=gcc -E\n   endif\n   CFG_GCCISH_CFLAGS += -Wall -Werror -fno-rtti -g\n   CFG_GCCISH_LINK_FLAGS += -g\n-  CFG_DEPEND_C = $(CFG_GCCISH_CROSS)$(CXX) $(CFG_GCCISH_CFLAGS) -MT \"$(1)\" \\\n-    -MM $(2)\n+  # These flags will cause the compiler to produce a .d file\n+  # next to the .o file that lists header deps.\n+  CFG_DEPEND_FLAGS = -MMD -MP -MT $(1) -MF $(1:%.o=%.d)\n \n   define CFG_MAKE_CC\n \tCFG_COMPILE_C_$(1) = $$(CFG_GCCISH_CROSS)$$(CXX)\t\\\n         $$(CFG_GCCISH_CFLAGS)\t\t\t\t\t\t\t\\\n \t    $$(CFG_GCCISH_CFLAGS_$$(HOST_$(1)))\t\t\t\t\\\n         $$(CFG_GCC_CFLAGS)\t\t\t\t\t\t\t\t\\\n         $$(CFG_GCC_CFLAGS_$$(HOST_$(1)))\t\t\t\t\\\n+        $$(CFG_DEPEND_FLAGS)                            \\\n         -c -o $$(1) $$(2)\n     CFG_LINK_C_$(1) = $$(CFG_GCCISH_CROSS)$$(CXX)\t\\\n         $$(CFG_GCCISH_LINK_FLAGS) -o $$(1)\t\t\t\\\n@@ -272,7 +276,7 @@ endif\n # We're using llvm-mc as our assembler because it supports\n # .cfi pseudo-ops on mac\n define CFG_MAKE_ASSEMBLER\n-  CFG_ASSEMBLE_$(1)=$$(CPP) $$(2) | \\\n+  CFG_ASSEMBLE_$(1)=$$(CPP) $$(CFG_DEPEND_FLAGS) $$(2) | \\\n                     $$(LLVM_MC_$$(CFG_HOST_TRIPLE)) \\\n                     -assemble \\\n                     -filetype=obj \\"}, {"sha": "02fcdc0def60992e03aaa470c84de611d08a4422", "filename": "mk/rt.mk", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -79,17 +79,6 @@ RUNTIME_S_$(1) := rt/arch/$$(HOST_$(1))/_context.S \\\n                   rt/arch/$$(HOST_$(1))/ccall.S \\\n                   rt/arch/$$(HOST_$(1))/record_sp.S\n \n-RUNTIME_HDR_$(1) := $$(wildcard \\\n-                       rt/*.h \\\n-                       rt/bigint/*.h \\\n-                       rt/isaac/*.h \\\n-                       rt/msvc/*.h \\\n-                       rt/sync/*.h \\\n-                       rt/uthash/*.h \\\n-                       rt/util/*.h \\\n-                       rt/vg/*.h \\\n-                       rt/arch/$$(HOST_$(1))/*.h)\n-\n ifeq ($$(HOST_$(1)), i386)\n   LIBUV_ARCH_$(1) := ia32\n else\n@@ -116,25 +105,28 @@ RUNTIME_INCS_$(1) := -I $$(S)src/rt -I $$(S)src/rt/isaac -I $$(S)src/rt/uthash \\\n \t\t\t\t-I $$(S)src/libuv/include\n RUNTIME_OBJS_$(1) := $$(RUNTIME_CS_$(1):rt/%.cpp=rt/$(1)/%.o) \\\n                      $$(RUNTIME_S_$(1):rt/%.S=rt/$(1)/%.o)\n+ALL_OBJ_FILES += $$(RUNTIME_OBJS_$(1))\n+\n+MORESTACK_OBJ_$(1) := rt/$(1)/arch/$$(HOST_$(1))/morestack.o\n+ALL_OBJ_FILES += $$(MORESTACK_OBJS_$(1))\n+\n RUNTIME_LIBS_$(1) := $$(LIBUV_LIB_$(1))\n \n-rt/$(1)/%.o: rt/%.cpp $$(RUNTIME_HDR_$(1)) $$(MKFILE_DEPS)\n+rt/$(1)/%.o: rt/%.cpp $$(MKFILE_DEPS)\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(call CFG_COMPILE_C_$(1), $$@, $$(RUNTIME_INCS_$(1)) \\\n                  $$(SNAP_DEFINES)) $$<\n \n-rt/$(1)/%.o: rt/%.S  $$(RUNTIME_HDR_$(1)) $$(MKFILE_DEPS) \\\n+rt/$(1)/%.o: rt/%.S  $$(MKFILE_DEPS) \\\n                      $$(LLVM_CONFIG_$$(CFG_HOST_TRIPLE))\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(call CFG_ASSEMBLE_$(1),$$@,$$<)\n \n-rt/$(1)/arch/$$(HOST_$(1))/libmorestack.a: \\\n-\t\trt/$(1)/arch/$$(HOST_$(1))/morestack.o\n+rt/$(1)/arch/$$(HOST_$(1))/libmorestack.a: $$(MORESTACK_OBJ_$(1))\n \t@$$(call E, link: $$@)\n \t$$(Q)ar rcs $$@ $$<\n \n rt/$(1)/$(CFG_RUNTIME): $$(RUNTIME_OBJS_$(1)) $$(MKFILE_DEPS) \\\n-                        $$(RUNTIME_HDR_$(1)) \\\n                         $$(RUNTIME_DEF_$(1)) \\\n                         $$(RUNTIME_LIBS_$(1))\n \t@$$(call E, link: $$@)"}, {"sha": "622f7d4fa090a757820ba1ebb12a9f02334f9afb", "filename": "mk/rustllvm.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/mk%2Frustllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/mk%2Frustllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frustllvm.mk?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -20,6 +20,7 @@ RUSTLLVM_INCS_$(1) = $$(LLVM_EXTRA_INCDIRS_$(1)) \\\n                      -iquote $$(LLVM_INCDIR_$(1)) \\\n                      -iquote $$(S)src/rustllvm/include\n RUSTLLVM_OBJS_OBJS_$(1) := $$(RUSTLLVM_OBJS_CS_$(1):rustllvm/%.cpp=rustllvm/$(1)/%.o)\n+ALL_OBJ_FILES += $$(RUSTLLVM_OBJS_OBJS_$(1))\n \n rustllvm/$(1)/$(CFG_RUSTLLVM): $$(RUSTLLVM_OBJS_OBJS_$(1)) \\\n                           $$(MKFILE_DEPS) $$(RUSTLLVM_DEF_$(1))"}, {"sha": "730206e35746cba97cab3521bafb9e39b8914e6c", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -129,7 +129,7 @@ impl extensions<A> for dvec<A> {\n     #[doc = \"Overwrite the current contents\"]\n     fn set(+w: [mut A]) {\n         self.check_not_borrowed();\n-        self.data <- w; //FIXME check for recursive use\n+        self.data <- w; //FIXME check for recursive use (#2607)\n     }\n }\n \n@@ -177,25 +177,28 @@ impl extensions<A:copy> for dvec<A> {\n         }\n     }\n \n-    //FIXME--\n-    //#[doc = \"\n-    //    Append all elements of an iterable.\n-    //\n-    //    Failure will occur if the iterable's `each()` method\n-    //    attempts to access this vector.\n-    //\"]\n-    //fn append_iter<I:iter::base<A>>(ts: I) {\n-    //    self.data.swap { |v|\n-    //        alt ts.size_hint() {\n-    //          none {}\n-    //          some(h) { vec::reserve(v, len(v) + h) }\n-    //        }\n-    //\n-    //        for ts.each { |t| v = v + [t] };\n-    //\n-    //        v\n-    //    }\n-    //}\n+    #[doc = \"\n+        Append all elements of an iterable.\n+\n+        Failure will occur if the iterable's `each()` method\n+        attempts to access this vector.\n+    \"]\n+    fn append_iter<A, I:iter::base_iter<A>>(ts: I) {\n+       self.swap { |v|\n+           let mut v = alt ts.size_hint() {\n+             none { v }\n+             some(h) {\n+               let len = v.len() + h;\n+               let mut v <- v;\n+               vec::reserve(v, len);\n+               v\n+            }\n+           };\n+\n+           for ts.each { |t| v += [t] };\n+           v\n+        }\n+    }\n \n     #[doc = \"\n         Gets a copy of the current contents."}, {"sha": "f50719408d0f444384bf0f26715f6466c84841af", "filename": "src/libcore/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -109,7 +109,7 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n     // stack of digits\n     let mut fractionalParts = [];\n \n-    // FIXME:\n+    // FIXME: (#2608)\n     // This used to return right away without rounding, as \"[-]num\",\n     // but given epsilon like in f64.rs, I don't see how the comparison\n     // to epsilon did much when only used there."}, {"sha": "1ee91495c572c939e44ff14f31abd9ef4130e310", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -137,7 +137,7 @@ impl num of num::num for T {\n }\n \n \n-// FIXME: Has alignment issues on windows and 32-bit linux\n+// FIXME: Has alignment issues on windows and 32-bit linux (#2609)\n #[test]\n #[ignore]\n fn test_from_str() {\n@@ -157,7 +157,7 @@ fn test_from_str() {\n     assert from_str(\"x\") == none;\n }\n \n-// FIXME: Has alignment issues on windows and 32-bit linux\n+// FIXME: Has alignment issues on windows and 32-bit linux (#2609)\n #[test]\n #[ignore]\n fn test_parse_buf() {"}, {"sha": "e58aa05f079fa484fffb19b553a7c74490c75e39", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -25,7 +25,7 @@ impl extensions<A:copy> for IMPL_T<A> {\n     fn map_to_vec<B>(op: fn(A) -> B) -> [B] { iter::map_to_vec(self, op) }\n     fn to_vec() -> [A] { iter::to_vec(self) }\n \n-    // FIXME--bug in resolve prevents this from working\n+    // FIXME--bug in resolve prevents this from working (#2611)\n     // fn flat_map_to_vec<B:copy,IB:base_iter<B>>(op: fn(A) -> IB) -> [B] {\n     //     iter::flat_map_to_vec(self, op)\n     // }"}, {"sha": "2d192b4aab1dd510fc51be685749d66dbaf810d2", "filename": "src/libcore/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -1,8 +1,8 @@\n #[doc=\"An interface for numbers.\"]\n \n iface num {\n-    // FIXME: Cross-crate overloading doesn't work yet.\n-    // FIXME: Interface inheritance.\n+    // FIXME: Cross-crate overloading doesn't work yet. (#2615)\n+    // FIXME: Interface inheritance. (#2616)\n     fn add(&&other: self) -> self;\n     fn sub(&&other: self) -> self;\n     fn mul(&&other: self) -> self;"}, {"sha": "34c38321f47139bb42907aeb30901f0ed92a1055", "filename": "src/libcore/os.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -36,7 +36,7 @@ export last_os_error;\n export set_exit_status;\n export walk_dir;\n \n-// FIXME: move these to str perhaps?\n+// FIXME: move these to str perhaps? #2620\n export as_c_charp, fill_charp_buf;\n \n native mod rustrt {\n@@ -86,7 +86,7 @@ mod win32 {\n     fn fill_utf16_buf_and_decode(f: fn(*mut u16, dword) -> dword)\n         -> option<str> {\n \n-        // FIXME: remove these when export globs work properly.\n+        // FIXME: remove these when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::consts::os::extra::*;\n \n@@ -167,7 +167,7 @@ mod global_env {\n                 sched:  some({\n                     mode: task::single_threaded,\n                     // FIXME: This would be a good place to use\n-                    // a very small native stack\n+                    // a very small native stack (#2621)\n                     native_stack_size: none\n                 })\n                 with task::get_opts(builder)\n@@ -227,7 +227,7 @@ mod global_env {\n         #[cfg(unix)]\n         fn setenv(n: str, v: str) {\n \n-            // FIXME: remove this when export globs work properly.\n+            // FIXME: remove this when export globs work properly. #1238\n             import libc::funcs::posix01::unistd::setenv;\n             str::as_c_str(n) {|nbuf|\n                 str::as_c_str(v) {|vbuf|\n@@ -239,7 +239,7 @@ mod global_env {\n \n         #[cfg(windows)]\n         fn setenv(n: str, v: str) {\n-            // FIXME: remove imports when export globs work properly.\n+            // FIXME: remove imports when export globs work properly. #1238\n             import libc::funcs::extra::kernel32::*;\n             import win32::*;\n             as_utf16_p(n) {|nbuf|\n@@ -329,7 +329,7 @@ fn pipe() -> {in: c_int, out: c_int} {\n \n #[cfg(windows)]\n fn pipe() -> {in: c_int, out: c_int} {\n-    // FIXME: remove this when export globs work properly.\n+    // FIXME: remove this when export globs work properly. #1238\n     import libc::consts::os::extra::*;\n     // Windows pipes work subtly differently than unix pipes, and their\n     // inheritance has to be handled in a different way that I do not fully\n@@ -387,7 +387,7 @@ fn self_exe_path() -> option<path> {\n \n     #[cfg(target_os = \"macos\")]\n     fn load_self() -> option<path> unsafe {\n-        // FIXME: remove imports when export globs work properly.\n+        // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::*;\n         fill_charp_buf() {|buf, sz|\n             _NSGetExecutablePath(buf, ptr::mut_addr_of(sz as u32))\n@@ -397,7 +397,7 @@ fn self_exe_path() -> option<path> {\n \n     #[cfg(windows)]\n     fn load_self() -> option<path> unsafe {\n-        // FIXME: remove imports when export globs work properly.\n+        // FIXME: remove imports when export globs work properly. #1238\n         import libc::types::os::arch::extra::*;\n         import libc::funcs::extra::kernel32::*;\n         import win32::*;\n@@ -500,7 +500,7 @@ fn path_exists(p: path) -> bool {\n }\n \n // FIXME: under Windows, we should prepend the current drive letter to paths\n-// that start with a slash.\n+// that start with a slash. #2622\n #[doc = \"\n Convert a relative path to an absolute path\n \n@@ -526,11 +526,11 @@ fn make_dir(p: path, mode: c_int) -> bool {\n \n     #[cfg(windows)]\n     fn mkdir(p: path, _mode: c_int) -> bool unsafe {\n-        // FIXME: remove imports when export globs work properly.\n+        // FIXME: remove imports when export globs work properly. #1238\n         import libc::types::os::arch::extra::*;\n         import libc::funcs::extra::kernel32::*;\n         import win32::*;\n-        // FIXME: turn mode into something useful?\n+        // FIXME: turn mode into something useful? #2623\n         as_utf16_p(p) {|buf|\n             CreateDirectoryW(buf, unsafe::reinterpret_cast(0))\n                 != (0 as BOOL)\n@@ -588,7 +588,7 @@ fn remove_dir(p: path) -> bool {\n \n     #[cfg(windows)]\n     fn rmdir(p: path) -> bool {\n-        // FIXME: remove imports when export globs work properly.\n+        // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n@@ -610,7 +610,7 @@ fn change_dir(p: path) -> bool {\n \n     #[cfg(windows)]\n     fn chdir(p: path) -> bool {\n-        // FIXME: remove imports when export globs work properly.\n+        // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;\n@@ -633,7 +633,7 @@ fn copy_file(from: path, to: path) -> bool {\n \n     #[cfg(windows)]\n     fn do_copy_file(from: path, to: path) -> bool {\n-        // FIXME: remove imports when export globs work properly.\n+        // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n         import win32::*;"}, {"sha": "560e4282411a7109441580903860d02337dce97c", "filename": "src/libcore/path.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -12,20 +12,20 @@ export split;\n export splitext;\n export normalize;\n \n-// FIXME: This type should probably be constrained\n+// FIXME: This type should probably be constrained (#2624)\n #[doc = \"A path or fragment of a filesystem path\"]\n type path = str;\n \n #[cfg(unix)]\n mod consts {\n     #[doc = \"\n-    The primary path seperator character for the platform\n+    The primary path separator character for the platform\n \n     On all platforms it is '/'\n     \"]\n     const path_sep: char = '/';\n     #[doc = \"\n-    The secondary path seperator character for the platform\n+    The secondary path separator character for the platform\n \n     On Unixes it is '/'. On Windows it is '\\\\'.\n     \"]\n@@ -98,7 +98,6 @@ fn basename(pp: path) -> path {\n     ret split_dirname_basename(pp).basename;\n }\n \n-// FIXME: Need some typestate to avoid bounds check when len(pre) == 0\n #[doc = \"\n Connects to path segments\n "}, {"sha": "d8905730dc2d71411a16708482b7f589c59ad66f", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -287,7 +287,7 @@ fn program_output(prog: str, args: [str]) ->\n     // Spawn two entire schedulers to read both stdout and sterr\n     // in parallel so we don't deadlock while blocking on one\n     // or the other. FIXME: Surely there's a much more clever way\n-    // to do this.\n+    // to do this. (#2625)\n     let p = comm::port();\n     let ch = comm::chan(p);\n     task::spawn_sched(task::single_threaded) {||\n@@ -387,7 +387,7 @@ mod tests {\n     import io::writer_util;\n \n     // Regression test for memory leaks\n-    #[ignore(cfg(windows))] // FIXME\n+    #[ignore(cfg(windows))] // FIXME (#2626)\n     fn test_leaks() {\n         run::run_program(\"echo\", []);\n         run::start_program(\"echo\", []);"}, {"sha": "8f68ff8d4da814d013dd12f95144a56b6065ba97", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -594,7 +594,7 @@ Section: Comparing strings\n #[doc = \"Bytewise string equality\"]\n pure fn eq(&&a: str, &&b: str) -> bool {\n     // FIXME: This should just be \"a == b\" but that calls into the shape code\n-    // :(\n+    // :( (#2627)\n     let a_len = a.len();\n     let b_len = b.len();\n     if a_len != b_len { ret false; }"}, {"sha": "5f31b5090f0580f675bee86658b8536d4d49099c", "filename": "src/libcore/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -879,7 +879,7 @@ fn test_avoid_copying_the_body_spawn() {\n #[test]\n fn test_avoid_copying_the_body_spawn_listener() {\n     avoid_copying_the_body {|f|\n-        spawn_listener(fn~[move f](_po: comm::port<int>) {\n+        spawn_listener(fn~(move f, _po: comm::port<int>) {\n             f();\n         });\n     }\n@@ -899,7 +899,7 @@ fn test_avoid_copying_the_body_run() {\n fn test_avoid_copying_the_body_run_listener() {\n     avoid_copying_the_body {|f|\n         let buildr = builder();\n-        run_listener(buildr, fn~[move f](_po: comm::port<int>) {\n+        run_listener(buildr, fn~(move f, _po: comm::port<int>) {\n             f();\n         });\n     }"}, {"sha": "1eab5b12ea006804ba3cbf7cea781e0b93ee45fd", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -1249,8 +1249,7 @@ mod unsafe {\n     #[inline(always)]\n     unsafe fn form_slice<T,U>(p: *T, len: uint, f: fn([T]/&) -> U) -> U {\n         let pair = (p, len * sys::size_of::<T>());\n-        // FIXME: should use &blk not &static here, but a snapshot is req'd\n-        let v : *([T]/&static) =\n+        let v : *([T]/&blk) =\n             ::unsafe::reinterpret_cast(ptr::addr_of(pair));\n         f(*v)\n     }\n@@ -1335,7 +1334,7 @@ impl extensions/&<A:copy> for [const A]/& {\n     fn map_to_vec<B>(op: fn(A) -> B) -> [B] { iter::map_to_vec(self, op) }\n     fn to_vec() -> [A] { iter::to_vec(self) }\n \n-    // FIXME--bug in resolve prevents this from working\n+    // FIXME--bug in resolve prevents this from working (#2611)\n     // fn flat_map_to_vec<B:copy,IB:base_iter<B>>(op: fn(A) -> IB) -> [B] {\n     //     iter::flat_map_to_vec(self, op)\n     // }"}, {"sha": "ffca598985755d13849581941e036390416a1de5", "filename": "src/libstd/par.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -39,7 +39,7 @@ fn map_slices<A: copy send, B: copy send>(\n         log(info, \"spawning tasks\");\n         while base < len {\n             let end = uint::min(len, base + items_per_task);\n-            // FIXME: why is the ::<A, ()> annotation required here?\n+            // FIXME: why is the ::<A, ()> annotation required here? (#2617)\n             vec::unpack_slice::<A, ()>(xs) {|p, _len|\n                 let f = f();\n                 futures += [future::spawn() {|copy base|"}, {"sha": "3ee92e5f07437202875ad3251398b113ff5db183", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -25,8 +25,6 @@ for *at least* that period of time.\n \"]\n fn delayed_send<T: copy send>(iotask: iotask,\n                               msecs: uint, ch: comm::chan<T>, val: T) {\n-    // FIME: Looks like we don't need to spawn here\n-    task::spawn() {||\n         unsafe {\n             let timer_done_po = comm::port::<()>();\n             let timer_done_ch = comm::chan(timer_done_po);\n@@ -59,7 +57,6 @@ fn delayed_send<T: copy send>(iotask: iotask,\n             comm::send(ch, copy(val));\n             // uv_close for this timer has been processed\n             comm::recv(timer_done_po);\n-        }\n     };\n }\n \n@@ -106,7 +103,7 @@ fn recv_timeout<T: copy send>(iotask: iotask,\n     let timeout_po = comm::port::<()>();\n     let timeout_ch = comm::chan(timeout_po);\n     delayed_send(iotask, msecs, timeout_ch, ());\n-    // FIXME: This could be written clearer\n+    // FIXME: This could be written clearer (#2618)\n     either::either(\n         {|left_val|\n             log(debug, #fmt(\"recv_time .. left_val %?\","}, {"sha": "e11e673494c76b38067c183fa14997e2907b9a89", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -9,6 +9,7 @@ import diagnostic::span_handler;\n enum path_elt { path_mod(ident), path_name(ident) }\n type path = [path_elt];\n \n+/* FIXMEs that say \"bad\" are as per #2543 */\n fn path_to_str_with_sep(p: path, sep: str) -> str {\n     let strs = vec::map(p) {|e|\n         alt e {\n@@ -291,6 +292,7 @@ fn node_id_to_str(map: map, id: node_id) -> str {\n         #fmt[\"expr %s (id=%?)\",\n              pprust::expr_to_str(expr), id]\n       }\n+      // FIXMEs are as per #2410\n       some(node_export(_, path)) {\n         #fmt[\"export %s (id=%?)\", // FIXME: add more info here\n              path_to_str(*path), id]"}, {"sha": "ef3b0332f198e456795025eb9e8c6bd76b6e063e", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -24,7 +24,7 @@ pure fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n pure fn path_name(p: @path) -> str { path_name_i(p.idents) }\n \n pure fn path_name_i(idents: [ident]) -> str {\n-    // FIXME: Bad copies\n+    // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     str::connect(idents.map({|i|*i}), \"::\")\n }\n "}, {"sha": "5dfe40b7ee088ac01ccb5ed11f09e8a284132898", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -88,6 +88,7 @@ fn get_attr_name(attr: ast::attribute) -> ast::ident {\n     get_meta_item_name(@attr.node.value)\n }\n \n+// All \"bad\" FIXME copies are as per #2543\n fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n     alt meta.node {\n       ast::meta_word(n) { /* FIXME bad */ copy n }\n@@ -372,7 +373,7 @@ fn require_unique_names(diagnostic: span_handler,\n     for metas.each {|meta|\n         let name = get_meta_item_name(meta);\n \n-        // FIXME: How do I silence the warnings? --pcw\n+        // FIXME: How do I silence the warnings? --pcw (#2619)\n         if map.contains_key(*name) {\n             diagnostic.span_fatal(meta.span,\n                                   #fmt[\"duplicate meta item `%s`\", *name]);"}, {"sha": "ae76cbafef795e736865c4485eb8db65f50ea307", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -59,7 +59,7 @@ fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n     let p = parse::new_parser_from_file(cx.parse_sess(), cx.cfg(),\n                                         res_rel_file(cx, sp, file),\n                                         parse::parser::SOURCE_FILE);\n-    ret parse::parser::parse_expr(p)\n+    ret p.parse_expr();\n }\n \n fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,"}, {"sha": "20452cd8724a0930ec0247916be59ade3ad90715", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 61, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -16,8 +16,6 @@ import dvec::{dvec, extensions};\n \n export file_type;\n export parser;\n-export parse_expr;\n-export parse_pat;\n \n // FIXME: #ast expects to find this here but it's actually defined in `parse`\n // Fixing this will be easier when we have export decls on individual items --\n@@ -26,12 +24,6 @@ export parse_pat;\n import parse_from_source_str;\n export parse_from_source_str;\n \n-// TODO: remove these once we go around a snapshot cycle.\n-// These are here for the old way that #ast (qquote.rs) worked\n-fn parse_expr(p: parser) -> @ast::expr { p.parse_expr() }\n-fn parse_pat(p: parser) -> @ast::pat { p.parse_pat() }\n-\n-\n enum restriction {\n     UNRESTRICTED,\n     RESTRICT_STMT_EXPR,\n@@ -1231,8 +1223,6 @@ class parser {\n     fn parse_fn_expr(proto: proto) -> @expr {\n         let lo = self.last_span.lo;\n \n-        let cc_old = self.parse_old_skool_capture_clause();\n-\n         // if we want to allow fn expression argument types to be inferred in\n         // the future, just have to change parse_arg to parse_fn_block_arg.\n         let (decl, capture_clause) =\n@@ -1241,8 +1231,7 @@ class parser {\n \n         let body = self.parse_block();\n         ret self.mk_expr(lo, body.span.hi,\n-                         expr_fn(proto, decl, body,\n-                                 @(*capture_clause + cc_old)));\n+                         expr_fn(proto, decl, body, capture_clause));\n     }\n \n     fn parse_fn_block_expr() -> @expr {\n@@ -1731,55 +1720,6 @@ class parser {\n         } else { [] }\n     }\n \n-    // FIXME Remove after snapshot\n-    fn parse_old_skool_capture_clause() -> [capture_item] {\n-        fn expect_opt_trailing_semi(p: parser) {\n-            if !p.eat(token::SEMI) {\n-                if p.token != token::RBRACKET {\n-                    p.fatal(\"expecting ; or ]\");\n-                }\n-            }\n-        }\n-\n-        fn eat_ident_list(p: parser, is_move: bool) -> [capture_item] {\n-            let mut res = [];\n-            loop {\n-                alt p.token {\n-                  token::IDENT(_, _) {\n-                    let id = p.get_id();\n-                    let sp = mk_sp(p.span.lo, p.span.hi);\n-                    let ident = p.parse_ident();\n-                    res += [@{id:id, is_move: is_move, name:ident, span:sp}];\n-                    if !p.eat(token::COMMA) {\n-                        ret res;\n-                    }\n-                  }\n-\n-                  _ { ret res; }\n-                }\n-            };\n-        }\n-\n-        let mut cap_items = [];\n-\n-        if self.eat(token::LBRACKET) {\n-            while !self.eat(token::RBRACKET) {\n-                if self.eat_keyword(\"copy\") {\n-                    cap_items += eat_ident_list(self, false);\n-                    expect_opt_trailing_semi(self);\n-                } else if self.eat_keyword(\"move\") {\n-                    cap_items += eat_ident_list(self, true);\n-                    expect_opt_trailing_semi(self);\n-                } else {\n-                    let s: str = \"expecting send, copy, or move clause\";\n-                    self.fatal(s);\n-                }\n-            }\n-        }\n-\n-        ret cap_items;\n-    }\n-\n     fn parse_fn_decl(purity: purity,\n                      parse_arg_fn: fn(parser) -> arg_or_capture_item)\n         -> (fn_decl, capture_clause) {"}, {"sha": "d46a47f0bd0e7d6d98eed38bedfc016f447be13b", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 61, "deletions": 18, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -706,12 +706,6 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         let bcx = drop_ty(bcx, body, body_mt.ty);\n         trans_free(bcx, v)\n       }\n-\n-      ty::ty_estr(ty::vstore_box) {\n-        let v = PointerCast(bcx, v, type_of(ccx, t));\n-        trans_free(bcx, v)\n-      }\n-\n       ty::ty_opaque_box {\n         let v = PointerCast(bcx, v, type_of(ccx, t));\n         let td = Load(bcx, GEPi(bcx, v, [0u, abi::box_field_tydesc]));\n@@ -725,8 +719,11 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         uniq::make_free_glue(bcx, v, t)\n       }\n       ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n+      ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) |\n       ty::ty_vec(_) | ty::ty_str {\n-        tvec::make_free_glue(bcx, PointerCast(bcx, v, type_of(ccx, t)), t)\n+        make_free_glue(bcx, v,\n+                       tvec::expand_boxed_vec_ty(bcx.tcx(), t));\n+        ret;\n       }\n       ty::ty_evec(_, _) {\n           bcx.sess().unimpl(\"trans::base::make_free_glue on other evec\");\n@@ -794,6 +791,9 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) {\n         free_ty(bcx, Load(bcx, v0), t)\n       }\n+      ty::ty_unboxed_vec(_) {\n+        tvec::make_drop_glue_unboxed(bcx, v0, t)\n+      }\n       ty::ty_res(did, inner, substs) {\n         trans_res_drop(bcx, v0, did, inner, substs.tps)\n       }\n@@ -1634,11 +1634,38 @@ fn cast_shift_rhs(op: ast::binop,\n     }\n }\n \n+fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n+                rhs: ValueRef, rhs_t: ty::t) -> block {\n+    let text = if divmod == ast::div {\n+        \"divide by zero\"\n+    } else {\n+        \"modulo zero\"\n+    };\n+    let is_zero = alt ty::get(rhs_t).struct {\n+      ty::ty_int(t) {\n+        let zero = C_integral(T_int_ty(cx.ccx(), t), 0u64, False);\n+        ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n+      }\n+      ty::ty_uint(t) {\n+        let zero = C_integral(T_uint_ty(cx.ccx(), t), 0u64, False);\n+        ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n+      }\n+      _ {\n+        cx.tcx().sess.bug(\"fail-if-zero on unexpected type: \" +\n+                          ty_to_str(cx.ccx().tcx, rhs_t));\n+      }\n+    };\n+    with_cond(cx, is_zero) {|bcx|\n+        trans_fail(bcx, some(span), text)\n+    }\n+}\n+\n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n-fn trans_eager_binop(cx: block, op: ast::binop, lhs: ValueRef,\n+fn trans_eager_binop(cx: block, span: span, op: ast::binop, lhs: ValueRef,\n                      lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t, dest: dest)\n     -> block {\n+    let mut cx = cx;\n     let _icx = cx.insn_ctxt(\"trans_eager_binop\");\n     if dest == ignore { ret cx; }\n     let intype = {\n@@ -1667,16 +1694,30 @@ fn trans_eager_binop(cx: block, op: ast::binop, lhs: ValueRef,\n         else { Mul(cx, lhs, rhs) }\n       }\n       ast::div {\n-        if is_float { FDiv(cx, lhs, rhs) }\n-        else if ty::type_is_signed(intype) {\n-            SDiv(cx, lhs, rhs)\n-        } else { UDiv(cx, lhs, rhs) }\n+        if is_float {\n+            FDiv(cx, lhs, rhs)\n+        } else {\n+            // Only zero-check integers; fp /0 is NaN\n+            cx = fail_if_zero(cx, span, op, rhs, rhs_t);\n+            if ty::type_is_signed(intype) {\n+                SDiv(cx, lhs, rhs)\n+            } else {\n+                UDiv(cx, lhs, rhs)\n+            }\n+        }\n       }\n       ast::rem {\n-        if is_float { FRem(cx, lhs, rhs) }\n-        else if ty::type_is_signed(intype) {\n-            SRem(cx, lhs, rhs)\n-        } else { URem(cx, lhs, rhs) }\n+        if is_float {\n+            FRem(cx, lhs, rhs)\n+        } else {\n+            // Only zero-check integers; fp %0 is NaN\n+            cx = fail_if_zero(cx, span, op, rhs, rhs_t);\n+            if ty::type_is_signed(intype) {\n+                SRem(cx, lhs, rhs)\n+            } else {\n+                URem(cx, lhs, rhs)\n+            }\n+        }\n       }\n       ast::bitor { Or(cx, lhs, rhs) }\n       ast::bitand { And(cx, lhs, rhs) }\n@@ -1744,7 +1785,8 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n           _ { }\n         }\n     }\n-    ret trans_eager_binop(bcx, op, Load(bcx, lhs_res.val), t, rhs_val, t,\n+    ret trans_eager_binop(bcx, ex.span,\n+                          op, Load(bcx, lhs_res.val), t, rhs_val, t,\n                           save_in(lhs_res.val));\n }\n \n@@ -1885,7 +1927,8 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n         // Remaining cases are eager:\n         let lhs_res = trans_temp_expr(bcx, lhs);\n         let rhs_res = trans_temp_expr(lhs_res.bcx, rhs);\n-        ret trans_eager_binop(rhs_res.bcx, op, lhs_res.val,\n+        ret trans_eager_binop(rhs_res.bcx, ex.span,\n+                              op, lhs_res.val,\n                               expr_ty(bcx, lhs), rhs_res.val,\n                               expr_ty(bcx, rhs), dest);\n       }"}, {"sha": "c2f804d42cd86024023a7d08ddb96c643e7f81b0", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -156,6 +156,7 @@ impl methods for reflector {\n           }\n \n           // FIXME: fetch constants out of intrinsic:: for the numbers.\n+          // (#2594)\n           ty::ty_fn(fty) {\n             let pureval = alt fty.purity {\n               ast::pure_fn { 0u }\n@@ -217,7 +218,7 @@ impl methods for reflector {\n           // FIXME: visiting all the variants in turn is probably\n           // not ideal. It'll work but will get costly on big enums.\n           // Maybe let the visitor tell us if it wants to visit only\n-          // a particular variant?\n+          // a particular variant? (#2595)\n           ty::ty_enum(did, substs) {\n             let bcx = self.bcx;\n             let tcx = bcx.ccx().tcx;"}, {"sha": "1d35d6548ae001fbf670c26dd05a35b88d419301", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -277,8 +277,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n       }\n       ty::ty_evec(mt, ty::vstore_uniq) |\n       ty::ty_vec(mt) {\n-        shape_of(ccx,\n-                 ty::mk_imm_uniq(ccx.tcx, ty::mk_unboxed_vec(ccx.tcx, mt)))\n+        shape_of(ccx, tvec::expand_boxed_vec_ty(ccx.tcx, t))\n       }\n \n       ty::ty_estr(ty::vstore_fixed(n)) {"}, {"sha": "3a543b968b762becd3677b92dc64bdefadba0a00", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -5,13 +5,35 @@ import back::abi;\n import base::{call_memmove,\n                INIT, copy_val, load_if_immediate, get_tydesc,\n                sub_block, do_spill_noroot,\n-               dest, bcx_icx, non_gc_box_cast};\n+               dest, bcx_icx, non_gc_box_cast,\n+               heap, heap_exchange, heap_shared};\n import syntax::codemap::span;\n import shape::llsize_of;\n import build::*;\n import common::*;\n import util::ppaux::ty_to_str;\n \n+// Boxed vector types are in some sense currently a \"shorthand\" for a box\n+// containing an unboxed vector. This expands a boxed vector type into such an\n+// expanded type. It doesn't respect mutability, but that doesn't matter at\n+// this point.\n+fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n+    let unit_ty = ty::sequence_element_type(tcx, t);\n+    let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n+    alt ty::get(t).struct {\n+      ty::ty_vec(_) | ty::ty_str |\n+      ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) {\n+        ty::mk_imm_uniq(tcx, unboxed_vec_ty)\n+      }\n+      ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) {\n+        ty::mk_imm_box(tcx, unboxed_vec_ty)\n+      }\n+      _ { tcx.sess.bug(\"non boxed-vec type \\\n+                        in tvec::expand_boxed_vec_ty\");\n+      }\n+    }\n+}\n+\n fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_fill\");\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n@@ -40,21 +62,25 @@ fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     ret PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n-                  fill: ValueRef, alloc: ValueRef) -> result {\n-    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq_raw\");\n+fn alloc_raw(bcx: block, unit_ty: ty::t,\n+              fill: ValueRef, alloc: ValueRef, heap: heap) -> result {\n+    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n \n     let vecbodyty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, ccx.opaque_vec_type));\n \n-    let {box, body} = base::malloc_unique_dyn(bcx, vecbodyty, vecsize);\n+    let {box, body} = base::malloc_general_dyn(bcx, vecbodyty, heap, vecsize);\n     Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n     Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n     ret {bcx: bcx, val: box};\n }\n+fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n+                  fill: ValueRef, alloc: ValueRef) -> result {\n+    alloc_raw(bcx, unit_ty, fill, alloc, heap_exchange)\n+}\n \n-fn alloc_uniq(bcx: block, unit_ty: ty::t, elts: uint) -> result {\n+fn alloc_vec(bcx: block, unit_ty: ty::t, elts: uint, heap: heap) -> result {\n     let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n     let llunitty = type_of::type_of(ccx, unit_ty);\n@@ -63,7 +89,7 @@ fn alloc_uniq(bcx: block, unit_ty: ty::t, elts: uint) -> result {\n     let fill = Mul(bcx, C_uint(ccx, elts), unit_sz);\n     let alloc = if elts < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n                 else { fill };\n-    let {bcx: bcx, val: vptr} = alloc_uniq_raw(bcx, unit_ty, fill, alloc);\n+    let {bcx: bcx, val: vptr} = alloc_raw(bcx, unit_ty, fill, alloc, heap);\n     ret {bcx: bcx, val: vptr};\n }\n \n@@ -79,20 +105,18 @@ fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n     call_memmove(bcx, new_data_ptr, data_ptr, fill);\n \n     let bcx = if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n-        iter_vec(bcx, newptr, vec_ty, base::take_ty)\n+        iter_vec_raw(bcx, new_data_ptr, vec_ty, fill, base::take_ty)\n     } else { bcx };\n     ret rslt(bcx, newptr);\n }\n-fn make_free_glue(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n+\n+fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n    block {\n-    let _icx = bcx.insn_ctxt(\"tvec::make_free_glue\");\n+    let _icx = bcx.insn_ctxt(\"tvec::make_drop_glue_unboxed\");\n     let tcx = bcx.tcx(), unit_ty = ty::sequence_element_type(tcx, vec_ty);\n-    base::with_cond(bcx, IsNotNull(bcx, vptr)) {|bcx|\n-        let bcx = if ty::type_needs_drop(tcx, unit_ty) {\n-            iter_vec(bcx, vptr, vec_ty, base::drop_ty)\n-        } else { bcx };\n-        base::trans_unique_free(bcx, vptr)\n-    }\n+    if ty::type_needs_drop(tcx, unit_ty) {\n+        iter_vec_unboxed(bcx, vptr, vec_ty, base::drop_ty)\n+    } else { bcx }\n }\n \n fn trans_evec(bcx: block, args: [@ast::expr],\n@@ -141,13 +165,18 @@ fn trans_evec(bcx: block, args: [@ast::expr],\n             {bcx: bcx, val: p, dataptr: vp}\n           }\n           ast::vstore_uniq {\n-            let {bcx, val} = alloc_uniq(bcx, unit_ty, args.len());\n+            let {bcx, val} = alloc_vec(bcx, unit_ty, args.len(),\n+                                       heap_exchange);\n             add_clean_free(bcx, val, true);\n             let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n             {bcx: bcx, val: val, dataptr: dataptr}\n           }\n           ast::vstore_box {\n-            bcx.ccx().sess.unimpl(\"unhandled tvec::trans_evec\");\n+            let {bcx, val} = alloc_vec(bcx, unit_ty, args.len(),\n+                                       heap_shared);\n+            add_clean_free(bcx, val, true);\n+            let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n+            {bcx: bcx, val: val, dataptr: dataptr}\n           }\n         };\n \n@@ -223,13 +252,11 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n         let len = Load(cx, GEPi(cx, v, [0u, abi::slice_elt_len]));\n         (base, len)\n       }\n-      ty::vstore_uniq {\n+      ty::vstore_uniq | ty::vstore_box {\n+        #debug[\"get_base_and_len: %s\", val_str(ccx.tn, v)];\n         let body = tvec::get_bodyptr(cx, v);\n         (tvec::get_dataptr(cx, body), tvec::get_fill(cx, body))\n       }\n-      ty::vstore_box {\n-        cx.ccx().sess.unimpl(\"unhandled tvec::get_base_and_len\");\n-      }\n     }\n }\n \n@@ -388,7 +415,7 @@ type iter_vec_block = fn(block, ValueRef, ty::t) -> block;\n \n fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n                 fill: ValueRef, f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_uniq\");\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_raw\");\n \n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n \n@@ -422,11 +449,12 @@ fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n-fn iter_vec(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n-            f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(\"tvec::iter_vec\");\n-    let fill = get_fill(bcx, get_bodyptr(bcx, vptr));\n-    ret iter_vec_uniq(bcx, vptr, vec_ty, fill, f);\n+fn iter_vec_unboxed(bcx: block, body_ptr: ValueRef, vec_ty: ty::t,\n+                    f: iter_vec_block) -> block {\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_unboxed\");\n+    let fill = get_fill(bcx, body_ptr);\n+    let dataptr = get_dataptr(bcx, body_ptr);\n+    ret iter_vec_raw(bcx, dataptr, vec_ty, fill, f);\n }\n \n //"}, {"sha": "0d6ef8c6d12c1dc9dbf81c5fbe24b279fe28fe39", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -76,10 +76,13 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     // this then, e.g. `option<{myfield: bool}>` would be a different\n     // type than `option<myrec>`.\n     let t_norm = ty::normalize_ty(cx.tcx, t);\n-    let llty = if t != t_norm {\n-        type_of(cx, t_norm)\n+\n+    let mut llty;\n+    if t != t_norm {\n+        llty = type_of(cx, t_norm);\n+        cx.lltypes.insert(t, llty);\n     } else {\n-        alt ty::get(t).struct {\n+        llty = alt ty::get(t).struct {\n           ty::ty_nil | ty::ty_bot { T_nil() }\n           ty::ty_bool { T_bool() }\n           ty::ty_int(t) { T_int_ty(cx, t) }\n@@ -91,7 +94,9 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           }\n           ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n           ty::ty_estr(ty::vstore_box) { T_box_ptr(T_box(cx, T_i8())) }\n-          ty::ty_evec(mt, ty::vstore_box) |\n+          ty::ty_evec(mt, ty::vstore_box) {\n+            T_box_ptr(T_box(cx, T_vec(cx, type_of(cx, mt.ty))))\n+          }\n           ty::ty_box(mt) { T_box_ptr(T_box(cx, type_of(cx, mt.ty))) }\n           ty::ty_opaque_box { T_box_ptr(T_box(cx, T_i8())) }\n           ty::ty_uniq(mt) { T_unique_ptr(T_unique(cx, type_of(cx, mt.ty))) }\n@@ -147,30 +152,46 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           }\n           ty::ty_opaque_closure_ptr(_) { T_opaque_box_ptr(cx) }\n           ty::ty_constr(subt,_) { type_of(cx, subt) }\n+          ty::ty_class(*) {\n+            // Only create the named struct, but don't fill it in. We fill it\n+            // in *after* placing it into the type cache. This prevents\n+            // infinite recursion with recursive class types.\n+\n+            common::T_named_struct(llvm_type_name(cx, t))\n+          }\n+          ty::ty_self { cx.tcx.sess.unimpl(\"type_of: ty_self\"); }\n+          ty::ty_var(_) { cx.tcx.sess.bug(\"type_of shouldn't see a ty_var\"); }\n+          ty::ty_param(*) { cx.tcx.sess.bug(\"type_of with ty_param\"); }\n+          ty::ty_var_integral(_) {\n+            cx.tcx.sess.bug(\"type_of shouldn't see a ty_var_integral\");\n+          }\n+        };\n+\n+        cx.lltypes.insert(t, llty);\n+\n+        // If this was a class, fill in the type now.\n+        alt ty::get(t).struct {\n           ty::ty_class(did, ts) {\n-            // only instance vars are record fields at runtime\n+            // Only instance vars are record fields at runtime.\n             let fields = lookup_class_fields(cx.tcx, did);\n-            let tys = vec::map(fields) {|f|\n+            let mut tys = vec::map(fields) {|f|\n                 let t = ty::lookup_field_type(cx.tcx, did, f.id, ts);\n                 type_of(cx, t)\n             };\n-            if ty::ty_dtor(cx.tcx, did) == none {\n-              T_struct(tys)\n-            }\n-            else {\n+\n+            if ty::ty_dtor(cx.tcx, did) != none {\n               // resource type\n-              T_struct([T_i8(), T_struct(tys)])\n+              tys = [T_i8(), T_struct(tys)];\n             }\n+\n+            common::set_struct_body(llty, tys);\n           }\n-          ty::ty_self { cx.tcx.sess.unimpl(\"type_of: ty_self\"); }\n-          ty::ty_var(_) { cx.tcx.sess.bug(\"type_of shouldn't see a ty_var\"); }\n-          ty::ty_param(*) { cx.tcx.sess.bug(\"type_of with ty_param\"); }\n-          ty::ty_var_integral(_) {\n-            cx.tcx.sess.bug(\"type_of shouldn't see a ty_var_integral\");\n+          _ {\n+            // Nothing more to do.\n           }\n         }\n     };\n-    cx.lltypes.insert(t, llty);\n+\n     ret llty;\n }\n \n@@ -212,6 +233,9 @@ fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> str {\n       ty::ty_enum(did, substs) {\n         (\"enum\", did, substs.tps)\n       }\n+      ty::ty_class(did, substs) {\n+        (\"class\", did, substs.tps)\n+      }\n     };\n     ret #fmt(\n         \"%s %s[#%d]\","}, {"sha": "421bbf38e14d6170ca32765f6a1e9dc92574a205", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -1112,7 +1112,7 @@ fn type_is_str(ty: t) -> bool {\n fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     alt get(ty).struct {\n       ty_str | ty_estr(_) { ret mk_mach_uint(cx, ast::ty_u8); }\n-      ty_vec(mt) | ty_evec(mt, _) { ret mt.ty; }\n+      ty_vec(mt) | ty_evec(mt, _) | ty_unboxed_vec(mt) { ret mt.ty; }\n       _ { cx.sess.bug(\"sequence_element_type called on non-sequence value\"); }\n     }\n }\n@@ -1134,7 +1134,8 @@ pure fn type_is_box(ty: t) -> bool {\n \n pure fn type_is_boxed(ty: t) -> bool {\n     alt get(ty).struct {\n-      ty_box(_) | ty_opaque_box { true }\n+      ty_box(_) | ty_opaque_box |\n+      ty_evec(_, vstore_box) | ty_estr(vstore_box) { true }\n       _ { false }\n     }\n }\n@@ -1212,6 +1213,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       ty_estr(vstore_fixed(_)) | ty_estr(vstore_slice(_)) |\n       ty_evec(_, vstore_slice(_)) { false }\n       ty_evec(mt, vstore_fixed(_)) { type_needs_drop(cx, mt.ty) }\n+      ty_unboxed_vec(mt) { type_needs_drop(cx, mt.ty) }\n       ty_rec(flds) {\n         for flds.each {|f| if type_needs_drop(cx, f.mt.ty) { accum = true; } }\n         accum\n@@ -2693,9 +2695,11 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n     let result = if ast::local_crate != id.crate {\n         @csearch::get_enum_variants(cx, id)\n     } else {\n-        // FIXME: Now that the variants are run through the type checker (to\n-        // check the disr_expr if it exists), this code should likely be\n-        // moved there to avoid having to call eval_const_expr twice.\n+        /*\n+          Although both this code and check_enum_variants in typeck/check\n+          call eval_const_expr, it should never get called twice for the same\n+          expr, since check_enum_variants also updates the enum_var_cache\n+         */\n         alt cx.items.get(id.node) {\n           ast_map::node_item(@{node: ast::item_enum(variants, _, _), _}, _) {\n             let mut disr_val = -1;\n@@ -3032,9 +3036,16 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n             alt r.self_r {\n               some(_) {\n                 // This enum has a self region. Get rid of it\n-                mk_enum(cx, did, {self_r: none,\n-                                  self_ty: none,\n-                                  tps: r.tps})\n+                mk_enum(cx, did, {self_r: none, self_ty: none, tps: r.tps})\n+              }\n+              none { t }\n+            }\n+        }\n+        ty_class(did, r) {\n+            alt r.self_r {\n+              some(_) {\n+                // Ditto.\n+                mk_class(cx, did, {self_r: none, self_ty: none, tps: r.tps})\n               }\n               none { t }\n             }"}, {"sha": "c142b22452f894503786c1ca402b71c08681ad51", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -1201,14 +1201,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               none {\n                 alt sty {\n                   ty::ty_enum(*) {\n-                    tcx.sess.span_fatal(\n+                    tcx.sess.span_err(\n                         expr.span,\n                         \"can only dereference enums \\\n                          with a single variant which has a \\\n                          single argument\");\n                   }\n                   _ {\n-                    tcx.sess.span_fatal(\n+                    tcx.sess.span_err(\n                         expr.span,\n                         #fmt[\"type %s cannot be dereferenced\",\n                              fcx.infcx.ty_to_str(oper_t)]);\n@@ -1893,6 +1893,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n     let fcx = blank_fn_ctxt(ccx, rty);\n     let mut disr_vals: [int] = [];\n     let mut disr_val = 0;\n+    let mut variants = [];\n     for vs.each {|v|\n         alt v.node.disr_expr {\n           some(e) {\n@@ -1921,9 +1922,19 @@ fn check_enum_variants(ccx: @crate_ctxt,\n                                   \"discriminator value already exists.\");\n         }\n         disr_vals += [disr_val];\n+        let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n+        let arg_tys = if v.node.args.len() > 0u {\n+            ty::ty_fn_args(ctor_ty).map {|a| a.ty }\n+          } else { [] };\n+        variants += [@{args: arg_tys, ctor_ty: ctor_ty,\n+              name: v.node.name, id: local_def(v.node.id),\n+              disr_val: disr_val}];\n         disr_val += 1;\n     }\n \n+    // cache so that ty::enum_variants won't repeat this work\n+    ccx.tcx.enum_var_cache.insert(local_def(id), @variants);\n+\n     // Check that it is possible to represent this enum:\n     let mut outer = true, did = local_def(id);\n     if ty::type_structurally_contains(ccx.tcx, rty, {|sty|"}, {"sha": "7d8b5e1f7d58824ae1913f4b573fc8a5daff200d", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -97,7 +97,7 @@ fn exec<T:send>(\n ) -> T {\n     let po = comm::port();\n     let ch = comm::chan(po);\n-    let msg = handle_request(fn~[move f](ctxt: ctxt) {\n+    let msg = handle_request(fn~(move f, ctxt: ctxt) {\n         comm::send(ch, f(ctxt))\n     });\n     comm::send(srv.ch, msg);"}, {"sha": "7f4c8aa698817f9715942d24b804f97423c7806c", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -22,7 +22,7 @@ type section = {\n \n // FIXME: We currently give topmod the name of the crate.  There would\n // probably be fewer special cases if the crate had its own name and\n-// topmod's name was the empty string.\n+// topmod's name was the empty string. (#2596)\n type cratedoc = {\n     topmod: moddoc,\n };"}, {"sha": "ea58eea76cb2274ffee54487fa3cbfaff0738cac", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -122,7 +122,7 @@ fn build_reexport_def_map(\n         def_map: ast_util::new_def_hash()\n     };\n \n-    // FIXME: Do a parallel fold\n+    // FIXME: Do a parallel fold (#2597)\n     let fold = fold::fold({\n         fold_mod: fold_mod,\n         fold_nmod: fold_nmod"}, {"sha": "4c6cd7d9ae636154ba993a7209a611b40469c98e", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -122,7 +122,7 @@ fn make_sequence_processor(sz: uint, from_parent: comm::port<[u8]>, to_parent: c\n fn main(args: [str]) {\n    let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n        // FIXME: Using this compile-time env variable is a crummy way to\n-       // get to this massive data set, but #include_bin chokes on it\n+       // get to this massive data set, but #include_bin chokes on it (#2598)\n        let path = path::connect(\n            #env(\"CFG_SRC_DIR\"),\n            \"src/test/bench/shootout-k-nucleotide.data\""}, {"sha": "dee7ef70d817e5d810afbbf792ec94641c60e267", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -59,14 +59,12 @@ fn solve_grid(g: grid_t) {\n             drop_colors(g, avail, row, col);\n \n             // find first remaining color that is available\n-            let mut i = 1 as uint;\n-            while i < (10 as uint) { /* FIXME llvm ctlhd */\n+            for uint::range(1u, 10u) {|i|\n                 if bitv::get(avail, i) {\n                     g[row][col] = i as u8;\n                     ret true;\n                 }\n-                i += 1 as uint; /* else */\n-            }\n+            };\n         }\n         g[row][col] = 0u8;\n         ret false;\n@@ -131,6 +129,7 @@ fn write_grid(f: io::writer, g: grid_t) {\n fn main(args: [str]) {\n     let grid = if vec::len(args) == 1u {\n         // FIXME create sudoku inline since nested vec consts dont work yet\n+        // (#571)\n         let g = vec::from_fn(10u, {|_i|\n             vec::to_mut(vec::from_elem(10u, 0 as u8))\n         });"}, {"sha": "71023b8207bd2f74ddf686d8a57b4b968c10dc79", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -77,8 +77,7 @@ mod map_reduce {\n \n     type putter<K: send, V: send> = fn(K, V);\n \n-    // FIXME: the first K1 parameter should probably be a -, but that\n-    // doesn't parse at the moment.\n+    // FIXME: the first K1 parameter should probably be a - (#2599)\n     type mapper<K1: send, K2: send, V: send> = fn~(K1, putter<K2, V>);\n \n     type getter<V: send> = fn() -> option<V>;"}, {"sha": "8eb0d427ca43ea75096e5040134fe9d92d72d4c4", "filename": "src/test/run-fail/divide-by-zero.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -0,0 +1,5 @@\n+// error-pattern:divide by zero\n+fn main() {\n+    let y = 0;\n+    let z = 1 / y;\n+}"}, {"sha": "7a10ed05aafe53303dd9a8e7291adebc2a8cd2e2", "filename": "src/test/run-fail/mod-zero.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmod-zero.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -0,0 +1,5 @@\n+// error-pattern:modulo zero\n+fn main() {\n+    let y = 0;\n+    let z = 1 % y;\n+}"}, {"sha": "3269af16afa7ae5e652bc2a966831aa3af734529", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -1,8 +1,4 @@\n-// FIXME: Autobind doesn't work for bare functions currently\n-// because it would have to convert them to shared closures\n-// xfail-test\n-\n-fn f<T>(x: [T]) -> T { ret x[0]; }\n+fn f<T: copy>(x: [T]) -> T { ret x[0]; }\n \n fn g(act: fn([int]) -> int) -> int { ret act([1, 2, 3]); }\n "}, {"sha": "2b0dab5d1a8793422a6d731095f9dd7c1679472f", "filename": "src/test/run-pass/basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -39,7 +39,7 @@ fn main() {\n     log(debug, x);\n     n = recv(p);\n     n = recv(p);\n-    // FIXME: use signal-channel for this.\n+    // FIXME: use signal-channel for this. (#2600)\n     #debug(\"children finished, root finishing\");\n }\n "}, {"sha": "047e0d41e232663cbf46a8047135c5325b80f4dd", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -60,7 +60,7 @@ fn test_box() {\n }\n \n fn test_port() {\n-    // FIXME: Re-enable this once we can compare resources.\n+    // FIXME: Re-enable this once we can compare resources. (#2601)\n     /*\n     let p1 = comm::port::<int>();\n     let p2 = comm::port::<int>();"}, {"sha": "d4cb382254224094daf6ec3d890d20c170297007", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -1,5 +1,3 @@\n-// xfail-fast\n-// (Not sure why, though -- FIXME (tjc)\n import to_str::*;\n import to_str::to_str;\n "}, {"sha": "7add8fec1b1ee82d73a2f3b765c3c30aa55558e7", "filename": "src/test/run-pass/classes-self-referential.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fclasses-self-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fclasses-self-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-self-referential.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -0,0 +1,10 @@\n+class kitten {\n+    let cat: option<cat>;\n+    new(cat: option<cat>) {\n+       self.cat = cat;\n+    }\n+}\n+\n+type cat = @kitten;\n+\n+fn main() {}"}, {"sha": "21938a9594a06979b5a164970e5298943634e1bd", "filename": "src/test/run-pass/issue-1895.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fissue-1895.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fissue-1895.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1895.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n   let x = 1;\n-  let y = fn@[move x]() -> int {\n+  let y = fn@(move x) -> int {\n              x\n           }();\n }"}, {"sha": "ebd777493543053228b51e402ce9ff9f62b52c7d", "filename": "src/test/run-pass/issue-2611.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2611.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -0,0 +1,11 @@\n+// xfail-test\n+import iter;\n+import iter::base_iter;\n+\n+impl Q<A> for base_iter<A> {\n+   fn flat_map_to_vec<B:copy, IB:base_iter<B>>(op: fn(B) -> IB) -> [B] {\n+      iter::flat_map_to_vec(self, op)\n+   }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "6fc5b5ea6ebcfcf32d68f1eb07130d2af3911b91", "filename": "src/test/run-pass/issue-506.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fissue-506.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fissue-506.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-506.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -2,6 +2,7 @@\n // FIXME: This test is no longer testing what it was intended to. It should\n // be testing spawning of a native function, but is actually testing\n // spawning some other function, then executing a native function.\n+// #2602\n \n /*\n   A reduced test case for Issue #506, provided by Rob Arnold."}, {"sha": "288be15c3857c06a8c66ae8f63635d04753f66c9", "filename": "src/test/run-pass/native-lib-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fnative-lib-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fnative-lib-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-lib-path.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -1,4 +1,4 @@\n-// xfail-test FIXME I don't know how to test this\n+// xfail-test FIXME I don't know how to test this (#2604)\n // compile-flags:-L.\n // The -L flag is also used for linking native libraries\n "}, {"sha": "58281b40b5e6175e09606e72779f98c5ee19607a", "filename": "src/test/run-pass/pred-not-bool.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fpred-not-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fpred-not-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpred-not-bool.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -1,12 +1,6 @@\n-// FIXME should be in run-pass\n-\n-// -*- rust -*-\n-\n-// error-pattern: Non-boolean return type\n-\n // this checks that a pred with a non-bool return\n // type is rejected, even if the pred is never used\n \n-pure fn bad(a: int) -> int { ret 37; }\n+pure fn bad(a: int) -> int { ret 37; } //! ERROR Non-boolean return type\n \n fn main() { }"}, {"sha": "6272b20163cbcfa6cb8e7c30abc2641aa54ac8bb", "filename": "src/test/run-pass/sendfn-spawn-with-fn-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -15,7 +15,7 @@ fn test05() {\n         log(error, *three + n); // will copy x into the closure\n         assert(*three == 3);\n     };\n-    task::spawn(fn~[move fn_to_send]() {\n+    task::spawn(fn~(move fn_to_send) {\n         test05_start(fn_to_send);\n     });\n }"}, {"sha": "40936ce3a06781a1b2670ee9b0ce1a6384ca22a0", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -53,6 +53,7 @@ fn test_tag() {\n     send(ch, tag2(10));\n     send(ch, tag3(10, 11u8, 'A'));\n     // FIXME: Do port semantics really guarantee these happen in order?\n+    // (#2605)\n     let mut t1: t;\n     t1 = recv(po);\n     assert (t1 == tag1);"}, {"sha": "9a8b5661e87273579d7f7148f7eae7793b75cc29", "filename": "src/test/run-pass/task-compare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Ftask-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Ftask-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-compare.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -2,7 +2,7 @@\n    A test case for issue #577, which also exposes #588\n */\n \n-// FIXME: This won't work until we can compare resources\n+// FIXME: This won't work until we can compare resources (#2601)\n // xfail-test\n \n use std;"}, {"sha": "cf98be6effb9ab446a0e87e02fd88e67b4a1f0f5", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -8,7 +8,7 @@ fn main() {\n     let y = ~2;\n     let y_in_parent = ptr::addr_of(*y) as uint;\n \n-    task::spawn(fn~[copy ch, y; move x]() {\n+    task::spawn(fn~(copy ch, copy y, move x) {\n         let x_in_child = ptr::addr_of(*x) as uint;\n         comm::send(ch, x_in_child);\n "}, {"sha": "8e81e5277bf420eed241087561bf122bbedbce3f", "filename": "src/test/run-pass/unused-move-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Funused-move-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c38ba8860a09f3810fe56679f154b58654f433/src%2Ftest%2Frun-pass%2Funused-move-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funused-move-capture.rs?ref=52c38ba8860a09f3810fe56679f154b58654f433", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let x = ~1;\n-    let lam_move = fn@[move x]() { };\n+    let lam_move = fn@(move x) { };\n     lam_move();\n }"}]}