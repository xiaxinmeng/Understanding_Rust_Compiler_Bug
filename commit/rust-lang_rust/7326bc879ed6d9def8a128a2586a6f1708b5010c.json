{"sha": "7326bc879ed6d9def8a128a2586a6f1708b5010c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMjZiYzg3OWVkNmQ5ZGVmOGExMjhhMjU4NmE2ZjE3MDhiNTAxMGM=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-18T18:20:14Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-29T20:04:16Z"}, "message": "Optimize try_recv to not require the two context switches when data is available.", "tree": {"sha": "5ab0677c3da22656c2f015a5d2438ebf59b82ab2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ab0677c3da22656c2f015a5d2438ebf59b82ab2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7326bc879ed6d9def8a128a2586a6f1708b5010c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7326bc879ed6d9def8a128a2586a6f1708b5010c", "html_url": "https://github.com/rust-lang/rust/commit/7326bc879ed6d9def8a128a2586a6f1708b5010c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7326bc879ed6d9def8a128a2586a6f1708b5010c/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1137fbd9abe7ba941b973c9fdc18845686e02ed6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1137fbd9abe7ba941b973c9fdc18845686e02ed6", "html_url": "https://github.com/rust-lang/rust/commit/1137fbd9abe7ba941b973c9fdc18845686e02ed6"}], "stats": {"total": 65, "additions": 34, "deletions": 31}, "files": [{"sha": "b1533237b156e1a1f4ce28172fe3ec07b1131221", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7326bc879ed6d9def8a128a2586a6f1708b5010c/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7326bc879ed6d9def8a128a2586a6f1708b5010c/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=7326bc879ed6d9def8a128a2586a6f1708b5010c", "patch": "@@ -18,7 +18,7 @@ use rt::kill::BlockedTask;\n use kinds::Send;\n use rt::sched::Scheduler;\n use rt::local::Local;\n-use unstable::atomics::{AtomicUint, AtomicOption, SeqCst};\n+use unstable::atomics::{AtomicUint, AtomicOption, Acquire, SeqCst};\n use unstable::sync::UnsafeAtomicRcBox;\n use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n@@ -164,36 +164,39 @@ impl<T> PortOne<T> {\n         let mut this = self;\n         let packet = this.packet();\n \n-        // XXX: Optimize this to not require the two context switches when data is available\n-\n-        // Switch to the scheduler to put the ~Task into the Packet state.\n-        let sched = Local::take::<Scheduler>();\n-        do sched.deschedule_running_task_and_then |sched, task| {\n-            unsafe {\n-                // Atomically swap the task pointer into the Packet state, issuing\n-                // an acquire barrier to prevent reordering of the subsequent read\n-                // of the payload. Also issues a release barrier to prevent reordering\n-                // of any previous writes to the task structure.\n-                let task_as_state = task.cast_to_uint();\n-                let oldstate = (*packet).state.swap(task_as_state, SeqCst);\n-                match oldstate {\n-                    STATE_BOTH => {\n-                        // Data has not been sent. Now we're blocked.\n-                        rtdebug!(\"non-rendezvous recv\");\n-                        sched.metrics.non_rendezvous_recvs += 1;\n+        // Optimistic check. If data was sent already, we don't even need to block.\n+        // No release barrier needed here; we're not handing off our task pointer yet.\n+        if unsafe { (*packet).state.load(Acquire) } != STATE_ONE {\n+            // No data available yet.\n+            // Switch to the scheduler to put the ~Task into the Packet state.\n+            let sched = Local::take::<Scheduler>();\n+            do sched.deschedule_running_task_and_then |sched, task| {\n+                unsafe {\n+                    // Atomically swap the task pointer into the Packet state, issuing\n+                    // an acquire barrier to prevent reordering of the subsequent read\n+                    // of the payload. Also issues a release barrier to prevent\n+                    // reordering of any previous writes to the task structure.\n+                    let task_as_state = task.cast_to_uint();\n+                    let oldstate = (*packet).state.swap(task_as_state, SeqCst);\n+                    match oldstate {\n+                        STATE_BOTH => {\n+                            // Data has not been sent. Now we're blocked.\n+                            rtdebug!(\"non-rendezvous recv\");\n+                            sched.metrics.non_rendezvous_recvs += 1;\n+                        }\n+                        STATE_ONE => {\n+                            rtdebug!(\"rendezvous recv\");\n+                            sched.metrics.rendezvous_recvs += 1;\n+\n+                            // Channel is closed. Switch back and check the data.\n+                            // NB: We have to drop back into the scheduler event loop here\n+                            // instead of switching immediately back or we could end up\n+                            // triggering infinite recursion on the scheduler's stack.\n+                            let recvr = BlockedTask::cast_from_uint(task_as_state);\n+                            sched.enqueue_blocked_task(recvr);\n+                        }\n+                        _ => util::unreachable()\n                     }\n-                    STATE_ONE => {\n-                        rtdebug!(\"rendezvous recv\");\n-                        sched.metrics.rendezvous_recvs += 1;\n-\n-                        // Channel is closed. Switch back and check the data.\n-                        // NB: We have to drop back into the scheduler event loop here\n-                        // instead of switching immediately back or we could end up\n-                        // triggering infinite recursion on the scheduler's stack.\n-                        let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                        sched.enqueue_blocked_task(recvr);\n-                    }\n-                    _ => util::unreachable()\n                 }\n             }\n         }\n@@ -212,7 +215,7 @@ impl<T> PortOne<T> {\n         //    a different scheduler for resuming. That send synchronized memory.\n \n         unsafe {\n-            let payload = util::replace(&mut (*packet).payload, None);\n+            let payload = (*packet).payload.take();\n \n             // The sender has closed up shop. Drop the packet.\n             let _packet: ~Packet<T> = cast::transmute(this.void_packet);"}]}