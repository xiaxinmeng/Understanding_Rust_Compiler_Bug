{"sha": "38528d4dc0a0c079069764f23f11ef9f4fba2f95", "node_id": "C_kwDOAAsO6NoAKDM4NTI4ZDRkYzBhMGMwNzkwNjk3NjRmMjNmMTFlZjlmNGZiYTJmOTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-23T05:22:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-23T05:22:05Z"}, "message": "Auto merge of #100904 - matthiaskrgr:rollup-z3yzivj, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #100382 (Make the GATS self outlives error take into GATs in the inputs)\n - #100565 (Suggest adding a missing semicolon before an item)\n - #100641 (Add the armv4t-none-eabi target to the supported_targets)\n - #100789 (Use separate infcx to solve obligations during negative coherence)\n - #100832 (Some small bootstrap cleanup)\n - #100861 (fix ICE with extra-const-ub-checks)\n - #100862 (tidy: remove crossbeam-utils)\n - #100887 (Refactor part of codegen_call_terminator)\n - #100893 (Remove out-of-context comment in `mem::MaybeUninit` documentation)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e586ec664aa338e03b1dcdccf1e276e690697d82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e586ec664aa338e03b1dcdccf1e276e690697d82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38528d4dc0a0c079069764f23f11ef9f4fba2f95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38528d4dc0a0c079069764f23f11ef9f4fba2f95", "html_url": "https://github.com/rust-lang/rust/commit/38528d4dc0a0c079069764f23f11ef9f4fba2f95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38528d4dc0a0c079069764f23f11ef9f4fba2f95/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e3e8a816f91fda5c6e05c659d7038747aff0b55", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e3e8a816f91fda5c6e05c659d7038747aff0b55", "html_url": "https://github.com/rust-lang/rust/commit/7e3e8a816f91fda5c6e05c659d7038747aff0b55"}, {"sha": "683a08af6a510c12c5df596de53046ba5afd2cfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/683a08af6a510c12c5df596de53046ba5afd2cfd", "html_url": "https://github.com/rust-lang/rust/commit/683a08af6a510c12c5df596de53046ba5afd2cfd"}], "stats": {"total": 514, "additions": 403, "deletions": 111}, "files": [{"sha": "ebacd32db4fc716aeebeb59c360cc0ab555ca552", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -5295,7 +5295,6 @@ name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata 0.14.0\",\n- \"crossbeam-utils\",\n  \"lazy_static\",\n  \"regex\",\n  \"walkdir\","}, {"sha": "dd98946b4cc5e8833b77f64645702d26cde6f5a1", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -436,6 +436,30 @@ impl Token {\n             || self == &OpenDelim(Delimiter::Parenthesis)\n     }\n \n+    /// Returns `true` if the token can appear at the start of an item.\n+    pub fn can_begin_item(&self) -> bool {\n+        match self.kind {\n+            Ident(name, _) => [\n+                kw::Fn,\n+                kw::Use,\n+                kw::Struct,\n+                kw::Enum,\n+                kw::Pub,\n+                kw::Trait,\n+                kw::Extern,\n+                kw::Impl,\n+                kw::Unsafe,\n+                kw::Static,\n+                kw::Union,\n+                kw::Macro,\n+                kw::Mod,\n+                kw::Type,\n+            ]\n+            .contains(&name),\n+            _ => false,\n+        }\n+    }\n+\n     /// Returns `true` if the token is any literal.\n     pub fn is_lit(&self) -> bool {\n         matches!(self.kind, Literal(..))"}, {"sha": "47a40be5d8c5b9df7f478a89c55b45cdac8969d8", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -798,58 +798,55 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let mut op = self.codegen_operand(&mut bx, arg);\n \n             if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n-                if let Pair(..) = op.val {\n-                    // In the case of Rc<Self>, we need to explicitly pass a\n-                    // *mut RcBox<Self> with a Scalar (not ScalarPair) ABI. This is a hack\n-                    // that is understood elsewhere in the compiler as a method on\n-                    // `dyn Trait`.\n-                    // To get a `*mut RcBox<Self>`, we just keep unwrapping newtypes until\n-                    // we get a value of a built-in pointer type\n-                    'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n-                        && !op.layout.ty.is_region_ptr()\n-                    {\n-                        for i in 0..op.layout.fields.count() {\n-                            let field = op.extract_field(&mut bx, i);\n-                            if !field.layout.is_zst() {\n-                                // we found the one non-zero-sized field that is allowed\n-                                // now find *its* non-zero-sized field, or stop if it's a\n-                                // pointer\n-                                op = field;\n-                                continue 'descend_newtypes;\n+                match op.val {\n+                    Pair(data_ptr, meta) => {\n+                        // In the case of Rc<Self>, we need to explicitly pass a\n+                        // *mut RcBox<Self> with a Scalar (not ScalarPair) ABI. This is a hack\n+                        // that is understood elsewhere in the compiler as a method on\n+                        // `dyn Trait`.\n+                        // To get a `*mut RcBox<Self>`, we just keep unwrapping newtypes until\n+                        // we get a value of a built-in pointer type\n+                        'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n+                            && !op.layout.ty.is_region_ptr()\n+                        {\n+                            for i in 0..op.layout.fields.count() {\n+                                let field = op.extract_field(&mut bx, i);\n+                                if !field.layout.is_zst() {\n+                                    // we found the one non-zero-sized field that is allowed\n+                                    // now find *its* non-zero-sized field, or stop if it's a\n+                                    // pointer\n+                                    op = field;\n+                                    continue 'descend_newtypes;\n+                                }\n                             }\n+\n+                            span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n                         }\n \n-                        span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n+                        // now that we have `*dyn Trait` or `&dyn Trait`, split it up into its\n+                        // data pointer and vtable. Look up the method in the vtable, and pass\n+                        // the data pointer as the first argument\n+                        llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n+                            &mut bx,\n+                            meta,\n+                            op.layout.ty,\n+                            &fn_abi,\n+                        ));\n+                        llargs.push(data_ptr);\n+                        continue 'make_args;\n                     }\n-\n-                    // now that we have `*dyn Trait` or `&dyn Trait`, split it up into its\n-                    // data pointer and vtable. Look up the method in the vtable, and pass\n-                    // the data pointer as the first argument\n-                    match op.val {\n-                        Pair(data_ptr, meta) => {\n-                            llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                                &mut bx,\n-                                meta,\n-                                op.layout.ty,\n-                                &fn_abi,\n-                            ));\n-                            llargs.push(data_ptr);\n-                            continue 'make_args;\n-                        }\n-                        other => bug!(\"expected a Pair, got {:?}\", other),\n+                    Ref(data_ptr, Some(meta), _) => {\n+                        // by-value dynamic dispatch\n+                        llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n+                            &mut bx,\n+                            meta,\n+                            op.layout.ty,\n+                            &fn_abi,\n+                        ));\n+                        llargs.push(data_ptr);\n+                        continue;\n                     }\n-                } else if let Ref(data_ptr, Some(meta), _) = op.val {\n-                    // by-value dynamic dispatch\n-                    llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                        &mut bx,\n-                        meta,\n-                        op.layout.ty,\n-                        &fn_abi,\n-                    ));\n-                    llargs.push(data_ptr);\n-                    continue;\n-                } else {\n-                    span_bug!(span, \"can't codegen a virtual call on {:?}\", op);\n+                    _ => span_bug!(span, \"can't codegen a virtual call on {:?}\", op),\n                 }\n             }\n "}, {"sha": "5cfa63bd105c48ca0e2da0efc6e54b8c6f8b82fb", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -81,7 +81,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n }\n \n /// The `InterpCx` is only meant to be used to do field and index projections into constants for\n-/// `simd_shuffle` and const patterns in match arms.\n+/// `simd_shuffle` and const patterns in match arms. It never performs alignment checks.\n ///\n /// The function containing the `match` that is currently being analyzed may have generic bounds\n /// that inform us about the generic bounds of the constant. E.g., using an associated constant\n@@ -98,7 +98,11 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n         tcx,\n         root_span,\n         param_env,\n-        CompileTimeInterpreter::new(tcx.const_eval_limit(), can_access_statics),\n+        CompileTimeInterpreter::new(\n+            tcx.const_eval_limit(),\n+            can_access_statics,\n+            /*check_alignment:*/ false,\n+        ),\n     )\n }\n \n@@ -203,7 +207,13 @@ pub(crate) fn turn_into_const_value<'tcx>(\n     let cid = key.value;\n     let def_id = cid.instance.def.def_id();\n     let is_static = tcx.is_static(def_id);\n-    let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env, is_static);\n+    // This is just accessing an already computed constant, so no need to check alginment here.\n+    let ecx = mk_eval_cx(\n+        tcx,\n+        tcx.def_span(key.value.instance.def_id()),\n+        key.param_env,\n+        /*can_access_statics:*/ is_static,\n+    );\n \n     let mplace = ecx.raw_const_to_mplace(constant).expect(\n         \"can only fail if layout computation failed, \\\n@@ -300,7 +310,11 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n         key.param_env,\n         // Statics (and promoteds inside statics) may access other statics, because unlike consts\n         // they do not have to behave \"as if\" they were evaluated at runtime.\n-        CompileTimeInterpreter::new(tcx.const_eval_limit(), /*can_access_statics:*/ is_static),\n+        CompileTimeInterpreter::new(\n+            tcx.const_eval_limit(),\n+            /*can_access_statics:*/ is_static,\n+            /*check_alignment:*/ tcx.sess.opts.unstable_opts.extra_const_ub_checks,\n+        ),\n     );\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);"}, {"sha": "f24b19089c113e1e651b3532bad116826c641686", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -101,14 +101,22 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     /// * Pointers to allocations inside of statics can never leak outside, to a non-static global.\n     /// This boolean here controls the second part.\n     pub(super) can_access_statics: bool,\n+\n+    /// Whether to check alignment during evaluation.\n+    check_alignment: bool,\n }\n \n impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n-    pub(crate) fn new(const_eval_limit: Limit, can_access_statics: bool) -> Self {\n+    pub(crate) fn new(\n+        const_eval_limit: Limit,\n+        can_access_statics: bool,\n+        check_alignment: bool,\n+    ) -> Self {\n         CompileTimeInterpreter {\n             steps_remaining: const_eval_limit.0,\n             stack: Vec::new(),\n             can_access_statics,\n+            check_alignment,\n         }\n     }\n }\n@@ -238,7 +246,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     #[inline(always)]\n     fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n-        ecx.tcx.sess.opts.unstable_opts.extra_const_ub_checks\n+        ecx.machine.check_alignment\n     }\n \n     #[inline(always)]"}, {"sha": "37ffa19ccd6b9d7097c431545641129fdac547b6", "filename": "compiler/rustc_const_eval/src/might_permit_raw_init.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -13,7 +13,11 @@ pub fn might_permit_raw_init<'tcx>(\n     let strict = tcx.sess.opts.unstable_opts.strict_init_checks;\n \n     if strict {\n-        let machine = CompileTimeInterpreter::new(Limit::new(0), false);\n+        let machine = CompileTimeInterpreter::new(\n+            Limit::new(0),\n+            /*can_access_statics:*/ false,\n+            /*check_alignment:*/ true,\n+        );\n \n         let mut cx = InterpCx::new(tcx, rustc_span::DUMMY_SP, ParamEnv::reveal_all(), machine);\n "}, {"sha": "b8884dd32d621c5fa1faa01fc43de9000b68c60a", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -927,10 +927,12 @@ impl<'a> Parser<'a> {\n                 return Ok(true);\n             } else if self.look_ahead(0, |t| {\n                 t == &token::CloseDelim(Delimiter::Brace)\n-                    || (t.can_begin_expr() && t != &token::Semi && t != &token::Pound)\n+                    || ((t.can_begin_expr() || t.can_begin_item())\n+                        && t != &token::Semi\n+                        && t != &token::Pound)\n                     // Avoid triggering with too many trailing `#` in raw string.\n                     || (sm.is_multiline(\n-                        self.prev_token.span.shrink_to_hi().until(self.token.span.shrink_to_lo())\n+                        self.prev_token.span.shrink_to_hi().until(self.token.span.shrink_to_lo()),\n                     ) && t == &token::Pound)\n             }) && !expected.contains(&TokenType::Token(token::Comma))\n             {"}, {"sha": "cf6cb75d49a5045c21236f4a3108ef71dad84da0", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -1028,6 +1028,7 @@ supported_targets! {\n     (\"mipsel-sony-psp\", mipsel_sony_psp),\n     (\"mipsel-unknown-none\", mipsel_unknown_none),\n     (\"thumbv4t-none-eabi\", thumbv4t_none_eabi),\n+    (\"armv4t-none-eabi\", armv4t_none_eabi),\n \n     (\"aarch64_be-unknown-linux-gnu\", aarch64_be_unknown_linux_gnu),\n     (\"aarch64-unknown-linux-gnu_ilp32\", aarch64_unknown_linux_gnu_ilp32),"}, {"sha": "3bc08fba91a10bd8a94a5d61f49946714add6067", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -342,10 +342,8 @@ fn equate<'cx, 'tcx>(\n     };\n \n     let selcx = &mut SelectionContext::new(&infcx);\n-    let opt_failing_obligation = obligations\n-        .into_iter()\n-        .chain(more_obligations)\n-        .find(|o| negative_impl_exists(selcx, impl_env, o));\n+    let opt_failing_obligation =\n+        obligations.into_iter().chain(more_obligations).find(|o| negative_impl_exists(selcx, o));\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n         debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n@@ -359,18 +357,15 @@ fn equate<'cx, 'tcx>(\n #[instrument(level = \"debug\", skip(selcx))]\n fn negative_impl_exists<'cx, 'tcx>(\n     selcx: &SelectionContext<'cx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     o: &PredicateObligation<'tcx>,\n ) -> bool {\n-    let infcx = &selcx.infcx().fork();\n-\n-    if resolve_negative_obligation(infcx, param_env, o) {\n+    if resolve_negative_obligation(selcx.infcx().fork(), o) {\n         return true;\n     }\n \n     // Try to prove a negative obligation exists for super predicates\n-    for o in util::elaborate_predicates(infcx.tcx, iter::once(o.predicate)) {\n-        if resolve_negative_obligation(infcx, param_env, &o) {\n+    for o in util::elaborate_predicates(selcx.tcx(), iter::once(o.predicate)) {\n+        if resolve_negative_obligation(selcx.infcx().fork(), &o) {\n             return true;\n         }\n     }\n@@ -380,8 +375,7 @@ fn negative_impl_exists<'cx, 'tcx>(\n \n #[instrument(level = \"debug\", skip(infcx))]\n fn resolve_negative_obligation<'cx, 'tcx>(\n-    infcx: &InferCtxt<'cx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n+    infcx: InferCtxt<'cx, 'tcx>,\n     o: &PredicateObligation<'tcx>,\n ) -> bool {\n     let tcx = infcx.tcx;\n@@ -390,7 +384,8 @@ fn resolve_negative_obligation<'cx, 'tcx>(\n         return false;\n     };\n \n-    let errors = super::fully_solve_obligation(infcx, o);\n+    let param_env = o.param_env;\n+    let errors = super::fully_solve_obligation(&infcx, o);\n     if !errors.is_empty() {\n         return false;\n     }"}, {"sha": "e8243d666b641536bffb4c14af9f0588d04dbb56", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -387,7 +387,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                             tcx,\n                             param_env,\n                             item_hir_id,\n-                            sig.output(),\n+                            sig.inputs_and_output,\n                             // We also assume that all of the function signature's parameter types\n                             // are well formed.\n                             &sig.inputs().iter().copied().collect(),"}, {"sha": "997494c769ec7eabe630cdaabba62eb54b919a50", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -130,11 +130,8 @@ use crate::slice;\n ///         MaybeUninit::uninit().assume_init()\n ///     };\n ///\n-///     // Dropping a `MaybeUninit` does nothing. Thus using raw pointer\n-///     // assignment instead of `ptr::write` does not cause the old\n-///     // uninitialized value to be dropped. Also if there is a panic during\n-///     // this loop, we have a memory leak, but there is no memory safety\n-///     // issue.\n+///     // Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n+///     // we have a memory leak, but there is no memory safety issue.\n ///     for elem in &mut data[..] {\n ///         elem.write(vec![42]);\n ///     }"}, {"sha": "6bf57a89e896f371941b7f65c1290f24dbe05b9a", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -1226,17 +1226,10 @@ impl Step for Rustfmt {\n \n         let rustfmt = builder\n             .ensure(tool::Rustfmt { compiler, target, extra_features: Vec::new() })\n-            .or_else(|| {\n-                missing_tool(\"Rustfmt\", builder.build.config.missing_tools);\n-                None\n-            })?;\n+            .expect(\"rustfmt expected to build - essential tool\");\n         let cargofmt = builder\n             .ensure(tool::Cargofmt { compiler, target, extra_features: Vec::new() })\n-            .or_else(|| {\n-                missing_tool(\"Cargofmt\", builder.build.config.missing_tools);\n-                None\n-            })?;\n-\n+            .expect(\"cargo fmt expected to build - essential tool\");\n         let mut tarball = Tarball::new(builder, \"rustfmt\", &target.triple);\n         tarball.set_overlay(OverlayKind::Rustfmt);\n         tarball.is_preview(true);"}, {"sha": "570da20e7d60dc9aab12314ecea4dc65d0b0dac6", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -778,12 +778,10 @@ impl Step for RustAnalyzerProcMacroSrv {\n macro_rules! tool_extended {\n     (($sel:ident, $builder:ident),\n        $($name:ident,\n-       $toolstate:ident,\n        $path:expr,\n        $tool_name:expr,\n        stable = $stable:expr,\n        $(in_tree = $in_tree:expr,)?\n-       $(submodule = $submodule:literal,)?\n        $(tool_std = $tool_std:literal,)?\n        $extra_deps:block;)+) => {\n         $(\n@@ -828,7 +826,6 @@ macro_rules! tool_extended {\n             #[allow(unused_mut)]\n             fn run(mut $sel, $builder: &Builder<'_>) -> Option<PathBuf> {\n                 $extra_deps\n-                $( $builder.update_submodule(&Path::new(\"src\").join(\"tools\").join($submodule)); )?\n                 $builder.ensure(ToolBuild {\n                     compiler: $sel.compiler,\n                     target: $sel.target,\n@@ -854,12 +851,12 @@ macro_rules! tool_extended {\n // Note: Most submodule updates for tools are handled by bootstrap.py, since they're needed just to\n // invoke Cargo to build bootstrap. See the comment there for more details.\n tool_extended!((self, builder),\n-    Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", stable=true, in_tree=true, {};\n-    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", stable=true, in_tree=true, {};\n-    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", stable=true, in_tree=true, {};\n-    Miri, miri, \"src/tools/miri\", \"miri\", stable=false, {};\n-    CargoMiri, miri, \"src/tools/miri/cargo-miri\", \"cargo-miri\", stable=false, {};\n-    Rls, rls, \"src/tools/rls\", \"rls\", stable=true, {\n+    Cargofmt, \"src/tools/rustfmt\", \"cargo-fmt\", stable=true, in_tree=true, {};\n+    CargoClippy, \"src/tools/clippy\", \"cargo-clippy\", stable=true, in_tree=true, {};\n+    Clippy, \"src/tools/clippy\", \"clippy-driver\", stable=true, in_tree=true, {};\n+    Miri, \"src/tools/miri\", \"miri\", stable=false, {};\n+    CargoMiri, \"src/tools/miri/cargo-miri\", \"cargo-miri\", stable=false, {};\n+    Rls, \"src/tools/rls\", \"rls\", stable=true, {\n         builder.ensure(Clippy {\n             compiler: self.compiler,\n             target: self.target,\n@@ -870,8 +867,8 @@ tool_extended!((self, builder),\n     // FIXME: tool_std is not quite right, we shouldn't allow nightly features.\n     // But `builder.cargo` doesn't know how to handle ToolBootstrap in stages other than 0,\n     // and this is close enough for now.\n-    RustDemangler, rust_demangler, \"src/tools/rust-demangler\", \"rust-demangler\", stable=false, in_tree=true, tool_std=true, {};\n-    Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", stable=true, in_tree=true, {};\n+    RustDemangler, \"src/tools/rust-demangler\", \"rust-demangler\", stable=false, in_tree=true, tool_std=true, {};\n+    Rustfmt, \"src/tools/rustfmt\", \"rustfmt\", stable=true, in_tree=true, {};\n );\n \n impl<'a> Builder<'a> {"}, {"sha": "f0f57f9338672e98ce41f99f09c5a34f6138e834", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -223,6 +223,7 @@ target | std | host | notes\n `aarch64_be-unknown-linux-gnu_ilp32` | \u2713 | \u2713 | ARM64 Linux (big-endian, ILP32 ABI)\n `aarch64_be-unknown-linux-gnu` | \u2713 | \u2713 | ARM64 Linux (big-endian)\n [`arm64_32-apple-watchos`](platform-support/apple-watchos.md) | \u2713 | | ARM Apple WatchOS 64-bit with 32-bit pointers\n+`armv4t-none-eabi` | * |  | ARMv4T A32\n `armv4t-unknown-linux-gnueabi` | ? |  |\n `armv5te-unknown-linux-uclibceabi` | ? |  | ARMv5TE Linux with uClibc\n `armv6-unknown-freebsd` | \u2713 | \u2713 | ARMv6 FreeBSD"}, {"sha": "221c1bc23b3f4578347d66125e1b65f5b3d76ebc", "filename": "src/test/ui/coherence/coherence-negative-outlives-lifetimes.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-outlives-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-outlives-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-outlives-lifetimes.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -1,10 +1,15 @@\n+// revisions: stock with_negative_coherence\n #![feature(negative_impls)]\n+#![cfg_attr(with_negative_coherence, feature(with_negative_coherence))]\n \n // FIXME: this should compile\n \n trait MyPredicate<'a> {}\n-impl<'a, T> !MyPredicate<'a> for &T where T: 'a {}\n+\n+impl<'a, T> !MyPredicate<'a> for &'a T where T: 'a {}\n+\n trait MyTrait<'a> {}\n+\n impl<'a, T: MyPredicate<'a>> MyTrait<'a> for T {}\n impl<'a, T> MyTrait<'a> for &'a T {}\n //~^ ERROR: conflicting implementations of trait `MyTrait<'_>` for type `&_`"}, {"sha": "097cc4e0fe3e67ef63d66d392917c57087fbb2c1", "filename": "src/test/ui/coherence/coherence-negative-outlives-lifetimes.stock.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-outlives-lifetimes.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-outlives-lifetimes.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-outlives-lifetimes.stock.stderr?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -1,5 +1,5 @@\n error[E0119]: conflicting implementations of trait `MyTrait<'_>` for type `&_`\n-  --> $DIR/coherence-negative-outlives-lifetimes.rs:9:1\n+  --> $DIR/coherence-negative-outlives-lifetimes.rs:14:1\n    |\n LL | impl<'a, T: MyPredicate<'a>> MyTrait<'a> for T {}\n    | ---------------------------------------------- first implementation here", "previous_filename": "src/test/ui/coherence/coherence-negative-outlives-lifetimes.stderr"}, {"sha": "097cc4e0fe3e67ef63d66d392917c57087fbb2c1", "filename": "src/test/ui/coherence/coherence-negative-outlives-lifetimes.with_negative_coherence.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-outlives-lifetimes.with_negative_coherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-outlives-lifetimes.with_negative_coherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-outlives-lifetimes.with_negative_coherence.stderr?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -0,0 +1,11 @@\n+error[E0119]: conflicting implementations of trait `MyTrait<'_>` for type `&_`\n+  --> $DIR/coherence-negative-outlives-lifetimes.rs:14:1\n+   |\n+LL | impl<'a, T: MyPredicate<'a>> MyTrait<'a> for T {}\n+   | ---------------------------------------------- first implementation here\n+LL | impl<'a, T> MyTrait<'a> for &'a T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `&_`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "a3296032841fdf278a2f7576618e3e1011d31ceb", "filename": "src/test/ui/consts/extra-const-ub/issue-100771.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fissue-100771.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fissue-100771.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fissue-100771.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+// compile-flags: -Zextra-const-ub-checks\n+\n+#[derive(PartialEq, Eq, Copy, Clone)]\n+#[repr(packed)]\n+struct Foo {\n+    field: (i64, u32, u32, u32),\n+}\n+\n+const FOO: Foo = Foo {\n+    field: (5, 6, 7, 8),\n+};\n+\n+fn main() {\n+    match FOO {\n+        Foo { field: (5, 6, 7, 8) } => {},\n+        FOO => unreachable!(),\n+        _ => unreachable!(),\n+    }\n+}"}, {"sha": "9bb42d4ff1c1ba466ee496b03af16d55a3bc51cb", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -210,4 +210,17 @@ trait StaticReturnAndTakes<'a> {\n     fn bar<'b>(&self, arg: Self::Y<'b>);\n }\n \n+// We require bounds when the GAT appears in the inputs\n+trait Input {\n+    type Item<'a>;\n+    //~^ missing required\n+    fn takes_item<'a>(&'a self, item: Self::Item<'a>);\n+}\n+\n+// We don't require bounds when the GAT appears in the where clauses\n+trait WhereClause {\n+    type Item<'a>;\n+    fn takes_item<'a>(&'a self) where Self::Item<'a>: ;\n+}\n+\n fn main() {}"}, {"sha": "a43b35bd79c95977c55befb57b9df408a6a40905", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -163,5 +163,16 @@ LL |     type Fut<'out>;\n    = note: this bound is currently required to ensure that impls have maximum flexibility\n    = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: aborting due to 15 previous errors\n+error: missing required bound on `Item`\n+  --> $DIR/self-outlives-lint.rs:215:5\n+   |\n+LL |     type Item<'a>;\n+   |     ^^^^^^^^^^^^^-\n+   |                  |\n+   |                  help: add the required where clause: `where Self: 'a`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n+\n+error: aborting due to 16 previous errors\n "}, {"sha": "0be17e69e8ff72fe0add93c5476b1cb0ed90e3a8", "filename": "src/test/ui/parser/recover-missing-semi-before-item.fixed", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fparser%2Frecover-missing-semi-before-item.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fparser%2Frecover-missing-semi-before-item.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-missing-semi-before-item.fixed?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -0,0 +1,61 @@\n+// run-rustfix\n+\n+#![allow(unused_variables, dead_code)]\n+\n+fn for_struct() {\n+    let foo = 3; //~ ERROR expected `;`, found keyword `struct`\n+    struct Foo;\n+}\n+\n+fn for_union() {\n+    let foo = 3; //~ ERROR expected `;`, found `union`\n+    union Foo {\n+        foo: usize,\n+    }\n+}\n+\n+fn for_enum() {\n+    let foo = 3; //~ ERROR expected `;`, found keyword `enum`\n+    enum Foo {\n+        Bar,\n+    }\n+}\n+\n+fn for_fn() {\n+    let foo = 3; //~ ERROR expected `;`, found keyword `fn`\n+    fn foo() {}\n+}\n+\n+fn for_extern() {\n+    let foo = 3; //~ ERROR expected `;`, found keyword `extern`\n+    extern fn foo() {}\n+}\n+\n+fn for_impl() {\n+    struct Foo;\n+    let foo = 3; //~ ERROR expected `;`, found keyword `impl`\n+    impl Foo {}\n+}\n+\n+fn for_use() {\n+    let foo = 3; //~ ERROR expected `;`, found keyword `pub`\n+    pub use bar::Bar;\n+}\n+\n+fn for_mod() {\n+    let foo = 3; //~ ERROR expected `;`, found keyword `mod`\n+    mod foo {}\n+}\n+\n+fn for_type() {\n+    let foo = 3; //~ ERROR expected `;`, found keyword `type`\n+    type Foo = usize;\n+}\n+\n+mod bar {\n+    pub struct Bar;\n+}\n+\n+const X: i32 = 123; //~ ERROR expected `;`, found keyword `fn`\n+\n+fn main() {}"}, {"sha": "867b7b749bb1f318a99cdeeb5b4df3f314dcc569", "filename": "src/test/ui/parser/recover-missing-semi-before-item.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fparser%2Frecover-missing-semi-before-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fparser%2Frecover-missing-semi-before-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-missing-semi-before-item.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -0,0 +1,61 @@\n+// run-rustfix\n+\n+#![allow(unused_variables, dead_code)]\n+\n+fn for_struct() {\n+    let foo = 3 //~ ERROR expected `;`, found keyword `struct`\n+    struct Foo;\n+}\n+\n+fn for_union() {\n+    let foo = 3 //~ ERROR expected `;`, found `union`\n+    union Foo {\n+        foo: usize,\n+    }\n+}\n+\n+fn for_enum() {\n+    let foo = 3 //~ ERROR expected `;`, found keyword `enum`\n+    enum Foo {\n+        Bar,\n+    }\n+}\n+\n+fn for_fn() {\n+    let foo = 3 //~ ERROR expected `;`, found keyword `fn`\n+    fn foo() {}\n+}\n+\n+fn for_extern() {\n+    let foo = 3 //~ ERROR expected `;`, found keyword `extern`\n+    extern fn foo() {}\n+}\n+\n+fn for_impl() {\n+    struct Foo;\n+    let foo = 3 //~ ERROR expected `;`, found keyword `impl`\n+    impl Foo {}\n+}\n+\n+fn for_use() {\n+    let foo = 3 //~ ERROR expected `;`, found keyword `pub`\n+    pub use bar::Bar;\n+}\n+\n+fn for_mod() {\n+    let foo = 3 //~ ERROR expected `;`, found keyword `mod`\n+    mod foo {}\n+}\n+\n+fn for_type() {\n+    let foo = 3 //~ ERROR expected `;`, found keyword `type`\n+    type Foo = usize;\n+}\n+\n+mod bar {\n+    pub struct Bar;\n+}\n+\n+const X: i32 = 123 //~ ERROR expected `;`, found keyword `fn`\n+\n+fn main() {}"}, {"sha": "61c43f2f189989a2bf9a3ca99d32832da7fb0916", "filename": "src/test/ui/parser/recover-missing-semi-before-item.stderr", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fparser%2Frecover-missing-semi-before-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftest%2Fui%2Fparser%2Frecover-missing-semi-before-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-missing-semi-before-item.stderr?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -0,0 +1,83 @@\n+error: expected `;`, found keyword `struct`\n+  --> $DIR/recover-missing-semi-before-item.rs:6:16\n+   |\n+LL |     let foo = 3\n+   |                ^ help: add `;` here\n+LL |     struct Foo;\n+   |     ------ unexpected token\n+\n+error: expected `;`, found `union`\n+  --> $DIR/recover-missing-semi-before-item.rs:11:16\n+   |\n+LL |     let foo = 3\n+   |                ^ help: add `;` here\n+LL |     union Foo {\n+   |     ----- unexpected token\n+\n+error: expected `;`, found keyword `enum`\n+  --> $DIR/recover-missing-semi-before-item.rs:18:16\n+   |\n+LL |     let foo = 3\n+   |                ^ help: add `;` here\n+LL |     enum Foo {\n+   |     ---- unexpected token\n+\n+error: expected `;`, found keyword `fn`\n+  --> $DIR/recover-missing-semi-before-item.rs:25:16\n+   |\n+LL |     let foo = 3\n+   |                ^ help: add `;` here\n+LL |     fn foo() {}\n+   |     -- unexpected token\n+\n+error: expected `;`, found keyword `extern`\n+  --> $DIR/recover-missing-semi-before-item.rs:30:16\n+   |\n+LL |     let foo = 3\n+   |                ^ help: add `;` here\n+LL |     extern fn foo() {}\n+   |     ------ unexpected token\n+\n+error: expected `;`, found keyword `impl`\n+  --> $DIR/recover-missing-semi-before-item.rs:36:16\n+   |\n+LL |     let foo = 3\n+   |                ^ help: add `;` here\n+LL |     impl Foo {}\n+   |     ---- unexpected token\n+\n+error: expected `;`, found keyword `pub`\n+  --> $DIR/recover-missing-semi-before-item.rs:41:16\n+   |\n+LL |     let foo = 3\n+   |                ^ help: add `;` here\n+LL |     pub use bar::Bar;\n+   |     --- unexpected token\n+\n+error: expected `;`, found keyword `mod`\n+  --> $DIR/recover-missing-semi-before-item.rs:46:16\n+   |\n+LL |     let foo = 3\n+   |                ^ help: add `;` here\n+LL |     mod foo {}\n+   |     --- unexpected token\n+\n+error: expected `;`, found keyword `type`\n+  --> $DIR/recover-missing-semi-before-item.rs:51:16\n+   |\n+LL |     let foo = 3\n+   |                ^ help: add `;` here\n+LL |     type Foo = usize;\n+   |     ---- unexpected token\n+\n+error: expected `;`, found keyword `fn`\n+  --> $DIR/recover-missing-semi-before-item.rs:59:19\n+   |\n+LL | const X: i32 = 123\n+   |                   ^ help: add `;` here\n+LL |\n+LL | fn main() {}\n+   | -- unexpected token\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "1c57b731aaa3f82b9af2534d6c5254d078c8bd4d", "filename": "src/tools/publish_toolstate.py", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftools%2Fpublish_toolstate.py", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftools%2Fpublish_toolstate.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fpublish_toolstate.py?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -32,20 +32,18 @@\n MAINTAINERS = {\n     'miri': {'oli-obk', 'RalfJung'},\n     'rls': {'Xanewok'},\n-    'rustfmt': {'topecongiro', 'calebcartwright'},\n-    'book': {'carols10cents', 'steveklabnik'},\n+    'book': {'carols10cents'},\n     'nomicon': {'frewsxcv', 'Gankra', 'JohnTitor'},\n-    'reference': {'steveklabnik', 'Havvy', 'matthewjasper', 'ehuss'},\n-    'rust-by-example': {'steveklabnik', 'marioidival'},\n+    'reference': {'Havvy', 'matthewjasper', 'ehuss'},\n+    'rust-by-example': {'marioidival'},\n     'embedded-book': {'adamgreig', 'andre-richter', 'jamesmunns', 'therealprof'},\n-    'edition-guide': {'ehuss', 'steveklabnik'},\n+    'edition-guide': {'ehuss'},\n     'rustc-dev-guide': {'spastorino', 'amanjeev', 'JohnTitor'},\n }\n \n LABELS = {\n     'miri': ['A-miri', 'C-bug'],\n     'rls': ['A-rls', 'C-bug'],\n-    'rustfmt': ['A-rustfmt', 'C-bug'],\n     'book': ['C-bug'],\n     'nomicon': ['C-bug'],\n     'reference': ['C-bug'],\n@@ -58,7 +56,6 @@\n REPOS = {\n     'miri': 'https://github.com/rust-lang/miri',\n     'rls': 'https://github.com/rust-lang/rls',\n-    'rustfmt': 'https://github.com/rust-lang/rustfmt',\n     'book': 'https://github.com/rust-lang/book',\n     'nomicon': 'https://github.com/rust-lang/nomicon',\n     'reference': 'https://github.com/rust-lang/reference',"}, {"sha": "471d78a2922a0efed881b1c51d6832410c167d04", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -9,7 +9,6 @@ cargo_metadata = \"0.14\"\n regex = \"1\"\n lazy_static = \"1\"\n walkdir = \"2\"\n-crossbeam-utils = \"0.8.0\"\n \n [[bin]]\n name = \"rust-tidy\""}, {"sha": "c1ce94f4705591208438bc3ae363efa1a4a1c0e5", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38528d4dc0a0c079069764f23f11ef9f4fba2f95/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=38528d4dc0a0c079069764f23f11ef9f4fba2f95", "patch": "@@ -6,14 +6,14 @@\n \n use tidy::*;\n \n-use crossbeam_utils::thread::{scope, ScopedJoinHandle};\n use std::collections::VecDeque;\n use std::env;\n use std::num::NonZeroUsize;\n use std::path::PathBuf;\n use std::process;\n use std::str::FromStr;\n use std::sync::atomic::{AtomicBool, Ordering};\n+use std::thread::{scope, ScopedJoinHandle};\n \n fn main() {\n     let root_path: PathBuf = env::args_os().nth(1).expect(\"need path to root of repo\").into();\n@@ -44,7 +44,7 @@ fn main() {\n                     handles.pop_front().unwrap().join().unwrap();\n                 }\n \n-                let handle = s.spawn(|_| {\n+                let handle = s.spawn(|| {\n                     let mut flag = false;\n                     $p::check($($args),* , &mut flag);\n                     if (flag) {\n@@ -102,8 +102,7 @@ fn main() {\n             r\n         };\n         check!(unstable_book, &src_path, collected);\n-    })\n-    .unwrap();\n+    });\n \n     if bad.load(Ordering::Relaxed) {\n         eprintln!(\"some tidy checks failed\");"}]}