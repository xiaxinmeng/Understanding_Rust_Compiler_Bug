{"sha": "a73288371e3fa0a610fbc11e7e8418017bdfde42", "node_id": "C_kwDOAAsO6NoAKGE3MzI4ODM3MWUzZmEwYTYxMGZiYzExZTdlODQxODAxN2JkZmRlNDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-10T14:09:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-10T14:09:09Z"}, "message": "Auto merge of #107007 - TDecking:float_parsing_improvments, r=Mark-Simulacrum\n\nImprove the floating point parser in dec2flt.\n\nGreetings everyone,\n\nI've benn studying the rust floating point parser recently and made the following tweaks:\n\n* Remove all remaining traces of `unsafe`. The parser is now 100% safe Rust.\n* The trick in which eight digits are processed in parallel is now in a loop.\n* Parsing of inf/NaN values has been reworked.\n\nOn my system, the changes result in performance improvements for some input values.", "tree": {"sha": "11d1ed6aa63b74432df5424a2026e0813fc77149", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11d1ed6aa63b74432df5424a2026e0813fc77149"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a73288371e3fa0a610fbc11e7e8418017bdfde42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a73288371e3fa0a610fbc11e7e8418017bdfde42", "html_url": "https://github.com/rust-lang/rust/commit/a73288371e3fa0a610fbc11e7e8418017bdfde42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a73288371e3fa0a610fbc11e7e8418017bdfde42/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a198c7f62a6dea507ba950750bc928237ad7a00", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a198c7f62a6dea507ba950750bc928237ad7a00", "html_url": "https://github.com/rust-lang/rust/commit/2a198c7f62a6dea507ba950750bc928237ad7a00"}, {"sha": "0f96c717924178c47491e94e802cca8a4a3a7175", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f96c717924178c47491e94e802cca8a4a3a7175", "html_url": "https://github.com/rust-lang/rust/commit/0f96c717924178c47491e94e802cca8a4a3a7175"}], "stats": {"total": 476, "additions": 188, "deletions": 288}, "files": [{"sha": "11a626485191ca4198db9761a9603f0375e654fc", "filename": "library/core/src/num/dec2flt/common.rs", "status": "modified", "additions": 30, "deletions": 148, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/a73288371e3fa0a610fbc11e7e8418017bdfde42/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73288371e3fa0a610fbc11e7e8418017bdfde42/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fcommon.rs?ref=a73288371e3fa0a610fbc11e7e8418017bdfde42", "patch": "@@ -1,165 +1,60 @@\n //! Common utilities, for internal use only.\n \n-use crate::ptr;\n-\n /// Helper methods to process immutable bytes.\n-pub(crate) trait ByteSlice: AsRef<[u8]> {\n-    unsafe fn first_unchecked(&self) -> u8 {\n-        debug_assert!(!self.is_empty());\n-        // SAFETY: safe as long as self is not empty\n-        unsafe { *self.as_ref().get_unchecked(0) }\n-    }\n-\n-    /// Get if the slice contains no elements.\n-    fn is_empty(&self) -> bool {\n-        self.as_ref().is_empty()\n-    }\n-\n-    /// Check if the slice at least `n` length.\n-    fn check_len(&self, n: usize) -> bool {\n-        n <= self.as_ref().len()\n-    }\n-\n-    /// Check if the first character in the slice is equal to c.\n-    fn first_is(&self, c: u8) -> bool {\n-        self.as_ref().first() == Some(&c)\n-    }\n-\n-    /// Check if the first character in the slice is equal to c1 or c2.\n-    fn first_is2(&self, c1: u8, c2: u8) -> bool {\n-        if let Some(&c) = self.as_ref().first() { c == c1 || c == c2 } else { false }\n-    }\n-\n-    /// Bounds-checked test if the first character in the slice is a digit.\n-    fn first_isdigit(&self) -> bool {\n-        if let Some(&c) = self.as_ref().first() { c.is_ascii_digit() } else { false }\n-    }\n-\n-    /// Check if self starts with u with a case-insensitive comparison.\n-    fn starts_with_ignore_case(&self, u: &[u8]) -> bool {\n-        debug_assert!(self.as_ref().len() >= u.len());\n-        let iter = self.as_ref().iter().zip(u.iter());\n-        let d = iter.fold(0, |i, (&x, &y)| i | (x ^ y));\n-        d == 0 || d == 32\n-    }\n-\n-    /// Get the remaining slice after the first N elements.\n-    fn advance(&self, n: usize) -> &[u8] {\n-        &self.as_ref()[n..]\n-    }\n-\n-    /// Get the slice after skipping all leading characters equal c.\n-    fn skip_chars(&self, c: u8) -> &[u8] {\n-        let mut s = self.as_ref();\n-        while s.first_is(c) {\n-            s = s.advance(1);\n-        }\n-        s\n-    }\n-\n-    /// Get the slice after skipping all leading characters equal c1 or c2.\n-    fn skip_chars2(&self, c1: u8, c2: u8) -> &[u8] {\n-        let mut s = self.as_ref();\n-        while s.first_is2(c1, c2) {\n-            s = s.advance(1);\n-        }\n-        s\n-    }\n-\n+pub(crate) trait ByteSlice {\n     /// Read 8 bytes as a 64-bit integer in little-endian order.\n-    unsafe fn read_u64_unchecked(&self) -> u64 {\n-        debug_assert!(self.check_len(8));\n-        let src = self.as_ref().as_ptr() as *const u64;\n-        // SAFETY: safe as long as self is at least 8 bytes\n-        u64::from_le(unsafe { ptr::read_unaligned(src) })\n-    }\n+    fn read_u64(&self) -> u64;\n \n-    /// Try to read the next 8 bytes from the slice.\n-    fn read_u64(&self) -> Option<u64> {\n-        if self.check_len(8) {\n-            // SAFETY: self must be at least 8 bytes.\n-            Some(unsafe { self.read_u64_unchecked() })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Calculate the offset of slice from another.\n-    fn offset_from(&self, other: &Self) -> isize {\n-        other.as_ref().len() as isize - self.as_ref().len() as isize\n-    }\n-}\n-\n-impl ByteSlice for [u8] {}\n-\n-/// Helper methods to process mutable bytes.\n-pub(crate) trait ByteSliceMut: AsMut<[u8]> {\n     /// Write a 64-bit integer as 8 bytes in little-endian order.\n-    unsafe fn write_u64_unchecked(&mut self, value: u64) {\n-        debug_assert!(self.as_mut().len() >= 8);\n-        let dst = self.as_mut().as_mut_ptr() as *mut u64;\n-        // NOTE: we must use `write_unaligned`, since dst is not\n-        // guaranteed to be properly aligned. Miri will warn us\n-        // if we use `write` instead of `write_unaligned`, as expected.\n-        // SAFETY: safe as long as self is at least 8 bytes\n-        unsafe {\n-            ptr::write_unaligned(dst, u64::to_le(value));\n-        }\n-    }\n-}\n+    fn write_u64(&mut self, value: u64);\n \n-impl ByteSliceMut for [u8] {}\n+    /// Calculate the offset of a slice from another.\n+    fn offset_from(&self, other: &Self) -> isize;\n \n-/// Bytes wrapper with specialized methods for ASCII characters.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub(crate) struct AsciiStr<'a> {\n-    slc: &'a [u8],\n+    /// Iteratively parse and consume digits from bytes.\n+    /// Returns the same bytes with consumed digits being\n+    /// elided.\n+    fn parse_digits(&self, func: impl FnMut(u8)) -> &Self;\n }\n \n-impl<'a> AsciiStr<'a> {\n-    pub fn new(slc: &'a [u8]) -> Self {\n-        Self { slc }\n+impl ByteSlice for [u8] {\n+    #[inline(always)] // inlining this is crucial to remove bound checks\n+    fn read_u64(&self) -> u64 {\n+        let mut tmp = [0; 8];\n+        tmp.copy_from_slice(&self[..8]);\n+        u64::from_le_bytes(tmp)\n     }\n \n-    /// Advance the view by n, advancing it in-place to (n..).\n-    pub unsafe fn step_by(&mut self, n: usize) -> &mut Self {\n-        // SAFETY: safe as long n is less than the buffer length\n-        self.slc = unsafe { self.slc.get_unchecked(n..) };\n-        self\n+    #[inline(always)] // inlining this is crucial to remove bound checks\n+    fn write_u64(&mut self, value: u64) {\n+        self[..8].copy_from_slice(&value.to_le_bytes())\n     }\n \n-    /// Advance the view by n, advancing it in-place to (1..).\n-    pub unsafe fn step(&mut self) -> &mut Self {\n-        // SAFETY: safe as long as self is not empty\n-        unsafe { self.step_by(1) }\n+    #[inline]\n+    fn offset_from(&self, other: &Self) -> isize {\n+        other.len() as isize - self.len() as isize\n     }\n \n-    /// Iteratively parse and consume digits from bytes.\n-    pub fn parse_digits(&mut self, mut func: impl FnMut(u8)) {\n-        while let Some(&c) = self.as_ref().first() {\n+    #[inline]\n+    fn parse_digits(&self, mut func: impl FnMut(u8)) -> &Self {\n+        let mut s = self;\n+\n+        // FIXME: Can't use s.split_first() here yet,\n+        // see https://github.com/rust-lang/rust/issues/109328\n+        while let [c, s_next @ ..] = s {\n             let c = c.wrapping_sub(b'0');\n             if c < 10 {\n                 func(c);\n-                // SAFETY: self cannot be empty\n-                unsafe {\n-                    self.step();\n-                }\n+                s = s_next;\n             } else {\n                 break;\n             }\n         }\n-    }\n-}\n \n-impl<'a> AsRef<[u8]> for AsciiStr<'a> {\n-    #[inline]\n-    fn as_ref(&self) -> &[u8] {\n-        self.slc\n+        s\n     }\n }\n \n-impl<'a> ByteSlice for AsciiStr<'a> {}\n-\n /// Determine if 8 bytes are all decimal digits.\n /// This does not care about the order in which the bytes were loaded.\n pub(crate) fn is_8digits(v: u64) -> bool {\n@@ -168,19 +63,6 @@ pub(crate) fn is_8digits(v: u64) -> bool {\n     (a | b) & 0x8080_8080_8080_8080 == 0\n }\n \n-/// Iteratively parse and consume digits from bytes.\n-pub(crate) fn parse_digits(s: &mut &[u8], mut f: impl FnMut(u8)) {\n-    while let Some(&c) = s.get(0) {\n-        let c = c.wrapping_sub(b'0');\n-        if c < 10 {\n-            f(c);\n-            *s = s.advance(1);\n-        } else {\n-            break;\n-        }\n-    }\n-}\n-\n /// A custom 64-bit floating point type, representing `f * 2^e`.\n /// e is biased, so it be directly shifted into the exponent bits.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]"}, {"sha": "350f64bb4f7a3fb06912459f3d15b4a6e475acfa", "filename": "library/core/src/num/dec2flt/decimal.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a73288371e3fa0a610fbc11e7e8418017bdfde42/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73288371e3fa0a610fbc11e7e8418017bdfde42/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs?ref=a73288371e3fa0a610fbc11e7e8418017bdfde42", "patch": "@@ -9,7 +9,7 @@\n //! algorithm can be found in \"ParseNumberF64 by Simple Decimal Conversion\",\n //! available online: <https://nigeltao.github.io/blog/2020/parse-number-f64-simple.html>.\n \n-use crate::num::dec2flt::common::{is_8digits, parse_digits, ByteSlice, ByteSliceMut};\n+use crate::num::dec2flt::common::{is_8digits, ByteSlice};\n \n #[derive(Clone)]\n pub struct Decimal {\n@@ -205,29 +205,32 @@ impl Decimal {\n pub fn parse_decimal(mut s: &[u8]) -> Decimal {\n     let mut d = Decimal::default();\n     let start = s;\n-    s = s.skip_chars(b'0');\n-    parse_digits(&mut s, |digit| d.try_add_digit(digit));\n-    if s.first_is(b'.') {\n-        s = s.advance(1);\n+\n+    while let Some((&b'0', s_next)) = s.split_first() {\n+        s = s_next;\n+    }\n+\n+    s = s.parse_digits(|digit| d.try_add_digit(digit));\n+\n+    if let Some((b'.', s_next)) = s.split_first() {\n+        s = s_next;\n         let first = s;\n         // Skip leading zeros.\n         if d.num_digits == 0 {\n-            s = s.skip_chars(b'0');\n+            while let Some((&b'0', s_next)) = s.split_first() {\n+                s = s_next;\n+            }\n         }\n         while s.len() >= 8 && d.num_digits + 8 < Decimal::MAX_DIGITS {\n-            // SAFETY: s is at least 8 bytes.\n-            let v = unsafe { s.read_u64_unchecked() };\n+            let v = s.read_u64();\n             if !is_8digits(v) {\n                 break;\n             }\n-            // SAFETY: d.num_digits + 8 is less than d.digits.len()\n-            unsafe {\n-                d.digits[d.num_digits..].write_u64_unchecked(v - 0x3030_3030_3030_3030);\n-            }\n+            d.digits[d.num_digits..].write_u64(v - 0x3030_3030_3030_3030);\n             d.num_digits += 8;\n-            s = s.advance(8);\n+            s = &s[8..];\n         }\n-        parse_digits(&mut s, |digit| d.try_add_digit(digit));\n+        s = s.parse_digits(|digit| d.try_add_digit(digit));\n         d.decimal_point = s.len() as i32 - first.len() as i32;\n     }\n     if d.num_digits != 0 {\n@@ -248,22 +251,26 @@ pub fn parse_decimal(mut s: &[u8]) -> Decimal {\n             d.num_digits = Decimal::MAX_DIGITS;\n         }\n     }\n-    if s.first_is2(b'e', b'E') {\n-        s = s.advance(1);\n-        let mut neg_exp = false;\n-        if s.first_is(b'-') {\n-            neg_exp = true;\n-            s = s.advance(1);\n-        } else if s.first_is(b'+') {\n-            s = s.advance(1);\n-        }\n-        let mut exp_num = 0_i32;\n-        parse_digits(&mut s, |digit| {\n-            if exp_num < 0x10000 {\n-                exp_num = 10 * exp_num + digit as i32;\n+    if let Some((&ch, s_next)) = s.split_first() {\n+        if ch == b'e' || ch == b'E' {\n+            s = s_next;\n+            let mut neg_exp = false;\n+            if let Some((&ch, s_next)) = s.split_first() {\n+                neg_exp = ch == b'-';\n+                if ch == b'-' || ch == b'+' {\n+                    s = s_next;\n+                }\n             }\n-        });\n-        d.decimal_point += if neg_exp { -exp_num } else { exp_num };\n+            let mut exp_num = 0_i32;\n+\n+            s.parse_digits(|digit| {\n+                if exp_num < 0x10000 {\n+                    exp_num = 10 * exp_num + digit as i32;\n+                }\n+            });\n+\n+            d.decimal_point += if neg_exp { -exp_num } else { exp_num };\n+        }\n     }\n     for i in d.num_digits..Decimal::MAX_DIGITS_WITHOUT_OVERFLOW {\n         d.digits[i] = 0;"}, {"sha": "a4bc8b1c9b0c31bbdd89164adda26c649ab93281", "filename": "library/core/src/num/dec2flt/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a73288371e3fa0a610fbc11e7e8418017bdfde42/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73288371e3fa0a610fbc11e7e8418017bdfde42/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs?ref=a73288371e3fa0a610fbc11e7e8418017bdfde42", "patch": "@@ -79,7 +79,7 @@ use crate::error::Error;\n use crate::fmt;\n use crate::str::FromStr;\n \n-use self::common::{BiasedFp, ByteSlice};\n+use self::common::BiasedFp;\n use self::float::RawFloat;\n use self::lemire::compute_float;\n use self::parse::{parse_inf_nan, parse_number};\n@@ -238,17 +238,18 @@ pub fn dec2flt<F: RawFloat>(s: &str) -> Result<F, ParseFloatError> {\n     };\n     let negative = c == b'-';\n     if c == b'-' || c == b'+' {\n-        s = s.advance(1);\n+        s = &s[1..];\n     }\n     if s.is_empty() {\n         return Err(pfe_invalid());\n     }\n \n-    let num = match parse_number(s, negative) {\n+    let mut num = match parse_number(s) {\n         Some(r) => r,\n         None if let Some(value) = parse_inf_nan(s, negative) => return Ok(value),\n         None => return Err(pfe_invalid()),\n     };\n+    num.negative = negative;\n     if let Some(value) = num.try_fast_path::<F>() {\n         return Ok(value);\n     }"}, {"sha": "b0a23835c5bd47258ba3bc46ca6cc0d355e953bd", "filename": "library/core/src/num/dec2flt/parse.rs", "status": "modified", "additions": 117, "deletions": 107, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/a73288371e3fa0a610fbc11e7e8418017bdfde42/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73288371e3fa0a610fbc11e7e8418017bdfde42/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fparse.rs?ref=a73288371e3fa0a610fbc11e7e8418017bdfde42", "patch": "@@ -1,6 +1,6 @@\n //! Functions to parse floating-point numbers.\n \n-use crate::num::dec2flt::common::{is_8digits, AsciiStr, ByteSlice};\n+use crate::num::dec2flt::common::{is_8digits, ByteSlice};\n use crate::num::dec2flt::float::RawFloat;\n use crate::num::dec2flt::number::Number;\n \n@@ -26,78 +26,74 @@ fn parse_8digits(mut v: u64) -> u64 {\n }\n \n /// Parse digits until a non-digit character is found.\n-fn try_parse_digits(s: &mut AsciiStr<'_>, x: &mut u64) {\n+fn try_parse_digits(mut s: &[u8], mut x: u64) -> (&[u8], u64) {\n     // may cause overflows, to be handled later\n-    s.parse_digits(|digit| {\n-        *x = x.wrapping_mul(10).wrapping_add(digit as _);\n+\n+    while s.len() >= 8 {\n+        let num = s.read_u64();\n+        if is_8digits(num) {\n+            x = x.wrapping_mul(1_0000_0000).wrapping_add(parse_8digits(num));\n+            s = &s[8..];\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    s = s.parse_digits(|digit| {\n+        x = x.wrapping_mul(10).wrapping_add(digit as _);\n     });\n+\n+    (s, x)\n }\n \n /// Parse up to 19 digits (the max that can be stored in a 64-bit integer).\n-fn try_parse_19digits(s: &mut AsciiStr<'_>, x: &mut u64) {\n+fn try_parse_19digits(s_ref: &mut &[u8], x: &mut u64) {\n+    let mut s = *s_ref;\n+\n     while *x < MIN_19DIGIT_INT {\n-        if let Some(&c) = s.as_ref().first() {\n+        // FIXME: Can't use s.split_first() here yet,\n+        // see https://github.com/rust-lang/rust/issues/109328\n+        if let [c, s_next @ ..] = s {\n             let digit = c.wrapping_sub(b'0');\n+\n             if digit < 10 {\n                 *x = (*x * 10) + digit as u64; // no overflows here\n-                // SAFETY: cannot be empty\n-                unsafe {\n-                    s.step();\n-                }\n+                s = s_next;\n             } else {\n                 break;\n             }\n         } else {\n             break;\n         }\n     }\n-}\n \n-/// Try to parse 8 digits at a time, using an optimized algorithm.\n-fn try_parse_8digits(s: &mut AsciiStr<'_>, x: &mut u64) {\n-    // may cause overflows, to be handled later\n-    if let Some(v) = s.read_u64() {\n-        if is_8digits(v) {\n-            *x = x.wrapping_mul(1_0000_0000).wrapping_add(parse_8digits(v));\n-            // SAFETY: already ensured the buffer was >= 8 bytes in read_u64.\n-            unsafe {\n-                s.step_by(8);\n-            }\n-            if let Some(v) = s.read_u64() {\n-                if is_8digits(v) {\n-                    *x = x.wrapping_mul(1_0000_0000).wrapping_add(parse_8digits(v));\n-                    // SAFETY: already ensured the buffer was >= 8 bytes in try_read_u64.\n-                    unsafe {\n-                        s.step_by(8);\n-                    }\n-                }\n-            }\n-        }\n-    }\n+    *s_ref = s;\n }\n \n /// Parse the scientific notation component of a float.\n-fn parse_scientific(s: &mut AsciiStr<'_>) -> Option<i64> {\n-    let mut exponent = 0_i64;\n+fn parse_scientific(s_ref: &mut &[u8]) -> Option<i64> {\n+    let mut exponent = 0i64;\n     let mut negative = false;\n-    if let Some(&c) = s.as_ref().get(0) {\n+\n+    let mut s = *s_ref;\n+\n+    if let Some((&c, s_next)) = s.split_first() {\n         negative = c == b'-';\n         if c == b'-' || c == b'+' {\n-            // SAFETY: s cannot be empty\n-            unsafe {\n-                s.step();\n-            }\n+            s = s_next;\n         }\n     }\n-    if s.first_isdigit() {\n-        s.parse_digits(|digit| {\n+\n+    if matches!(s.first(), Some(&x) if x.is_ascii_digit()) {\n+        *s_ref = s.parse_digits(|digit| {\n             // no overflows here, saturate well before overflow\n             if exponent < 0x10000 {\n                 exponent = 10 * exponent + digit as i64;\n             }\n         });\n         if negative { Some(-exponent) } else { Some(exponent) }\n     } else {\n+        *s_ref = s;\n         None\n     }\n }\n@@ -106,28 +102,29 @@ fn parse_scientific(s: &mut AsciiStr<'_>) -> Option<i64> {\n ///\n /// This creates a representation of the float as the\n /// significant digits and the decimal exponent.\n-fn parse_partial_number(s: &[u8], negative: bool) -> Option<(Number, usize)> {\n-    let mut s = AsciiStr::new(s);\n-    let start = s;\n+fn parse_partial_number(mut s: &[u8]) -> Option<(Number, usize)> {\n     debug_assert!(!s.is_empty());\n \n     // parse initial digits before dot\n     let mut mantissa = 0_u64;\n-    let digits_start = s;\n-    try_parse_digits(&mut s, &mut mantissa);\n-    let mut n_digits = s.offset_from(&digits_start);\n+    let start = s;\n+    let tmp = try_parse_digits(s, mantissa);\n+    s = tmp.0;\n+    mantissa = tmp.1;\n+    let mut n_digits = s.offset_from(start);\n \n     // handle dot with the following digits\n     let mut n_after_dot = 0;\n     let mut exponent = 0_i64;\n     let int_end = s;\n-    if s.first_is(b'.') {\n-        // SAFETY: s cannot be empty due to first_is\n-        unsafe { s.step() };\n+\n+    if let Some((&b'.', s_next)) = s.split_first() {\n+        s = s_next;\n         let before = s;\n-        try_parse_8digits(&mut s, &mut mantissa);\n-        try_parse_digits(&mut s, &mut mantissa);\n-        n_after_dot = s.offset_from(&before);\n+        let tmp = try_parse_digits(s, mantissa);\n+        s = tmp.0;\n+        mantissa = tmp.1;\n+        n_after_dot = s.offset_from(before);\n         exponent = -n_after_dot as i64;\n     }\n \n@@ -138,96 +135,109 @@ fn parse_partial_number(s: &[u8], negative: bool) -> Option<(Number, usize)> {\n \n     // handle scientific format\n     let mut exp_number = 0_i64;\n-    if s.first_is2(b'e', b'E') {\n-        // SAFETY: s cannot be empty\n-        unsafe {\n-            s.step();\n+    if let Some((&c, s_next)) = s.split_first() {\n+        if c == b'e' || c == b'E' {\n+            s = s_next;\n+            // If None, we have no trailing digits after exponent, or an invalid float.\n+            exp_number = parse_scientific(&mut s)?;\n+            exponent += exp_number;\n         }\n-        // If None, we have no trailing digits after exponent, or an invalid float.\n-        exp_number = parse_scientific(&mut s)?;\n-        exponent += exp_number;\n     }\n \n-    let len = s.offset_from(&start) as _;\n+    let len = s.offset_from(start) as _;\n \n     // handle uncommon case with many digits\n     if n_digits <= 19 {\n-        return Some((Number { exponent, mantissa, negative, many_digits: false }, len));\n+        return Some((Number { exponent, mantissa, negative: false, many_digits: false }, len));\n     }\n \n     n_digits -= 19;\n     let mut many_digits = false;\n-    let mut p = digits_start;\n-    while p.first_is2(b'0', b'.') {\n-        // SAFETY: p cannot be empty due to first_is2\n-        unsafe {\n-            // '0' = b'.' + 2\n-            n_digits -= p.first_unchecked().saturating_sub(b'0' - 1) as isize;\n-            p.step();\n+    let mut p = start;\n+    while let Some((&c, p_next)) = p.split_first() {\n+        if c == b'.' || c == b'0' {\n+            n_digits -= c.saturating_sub(b'0' - 1) as isize;\n+            p = p_next;\n+        } else {\n+            break;\n         }\n     }\n     if n_digits > 0 {\n         // at this point we have more than 19 significant digits, let's try again\n         many_digits = true;\n         mantissa = 0;\n-        let mut s = digits_start;\n+        let mut s = start;\n         try_parse_19digits(&mut s, &mut mantissa);\n         exponent = if mantissa >= MIN_19DIGIT_INT {\n             // big int\n-            int_end.offset_from(&s)\n+            int_end.offset_from(s)\n         } else {\n-            // SAFETY: the next byte must be present and be '.'\n-            // We know this is true because we had more than 19\n-            // digits previously, so we overflowed a 64-bit integer,\n-            // but parsing only the integral digits produced less\n-            // than 19 digits. That means we must have a decimal\n-            // point, and at least 1 fractional digit.\n-            unsafe { s.step() };\n+            s = &s[1..];\n             let before = s;\n             try_parse_19digits(&mut s, &mut mantissa);\n-            -s.offset_from(&before)\n+            -s.offset_from(before)\n         } as i64;\n         // add back the explicit part\n         exponent += exp_number;\n     }\n \n-    Some((Number { exponent, mantissa, negative, many_digits }, len))\n+    Some((Number { exponent, mantissa, negative: false, many_digits }, len))\n }\n \n-/// Try to parse a non-special floating point number.\n-pub fn parse_number(s: &[u8], negative: bool) -> Option<Number> {\n-    if let Some((float, rest)) = parse_partial_number(s, negative) {\n+/// Try to parse a non-special floating point number,\n+/// as well as two slices with integer and fractional parts\n+/// and the parsed exponent.\n+pub fn parse_number(s: &[u8]) -> Option<Number> {\n+    if let Some((float, rest)) = parse_partial_number(s) {\n         if rest == s.len() {\n             return Some(float);\n         }\n     }\n     None\n }\n \n-/// Parse a partial representation of a special, non-finite float.\n-fn parse_partial_inf_nan<F: RawFloat>(s: &[u8]) -> Option<(F, usize)> {\n-    fn parse_inf_rest(s: &[u8]) -> usize {\n-        if s.len() >= 8 && s[3..].as_ref().starts_with_ignore_case(b\"inity\") { 8 } else { 3 }\n-    }\n-    if s.len() >= 3 {\n-        if s.starts_with_ignore_case(b\"nan\") {\n-            return Some((F::NAN, 3));\n-        } else if s.starts_with_ignore_case(b\"inf\") {\n-            return Some((F::INFINITY, parse_inf_rest(s)));\n-        }\n-    }\n-    None\n-}\n-\n /// Try to parse a special, non-finite float.\n-pub fn parse_inf_nan<F: RawFloat>(s: &[u8], negative: bool) -> Option<F> {\n-    if let Some((mut float, rest)) = parse_partial_inf_nan::<F>(s) {\n-        if rest == s.len() {\n-            if negative {\n-                float = -float;\n-            }\n-            return Some(float);\n-        }\n+pub(crate) fn parse_inf_nan<F: RawFloat>(s: &[u8], negative: bool) -> Option<F> {\n+    // Since a valid string has at most the length 8, we can load\n+    // all relevant characters into a u64 and work from there.\n+    // This also generates much better code.\n+\n+    let mut register;\n+    let len: usize;\n+\n+    // All valid strings are either of length 8 or 3.\n+    if s.len() == 8 {\n+        register = s.read_u64();\n+        len = 8;\n+    } else if s.len() == 3 {\n+        let a = s[0] as u64;\n+        let b = s[1] as u64;\n+        let c = s[2] as u64;\n+        register = (c << 16) | (b << 8) | a;\n+        len = 3;\n+    } else {\n+        return None;\n     }\n-    None\n+\n+    // Clear out the bits which turn ASCII uppercase characters into\n+    // lowercase characters. The resulting string is all uppercase.\n+    // What happens to other characters is irrelevant.\n+    register &= 0xDFDFDFDFDFDFDFDF;\n+\n+    // u64 values corresponding to relevant cases\n+    const INF_3: u64 = 0x464E49; // \"INF\"\n+    const INF_8: u64 = 0x5954494E49464E49; // \"INFINITY\"\n+    const NAN: u64 = 0x4E414E; // \"NAN\"\n+\n+    // Match register value to constant to parse string.\n+    // Also match on the string length to catch edge cases\n+    // like \"inf\\0\\0\\0\\0\\0\".\n+    let float = match (register, len) {\n+        (INF_3, 3) => F::INFINITY,\n+        (INF_8, 8) => F::INFINITY,\n+        (NAN, 3) => F::NAN,\n+        _ => return None,\n+    };\n+\n+    if negative { Some(-float) } else { Some(float) }\n }"}, {"sha": "4a5d24ba7d5fa5146cd4e21899a2444f03ea7fc3", "filename": "library/core/tests/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a73288371e3fa0a610fbc11e7e8418017bdfde42/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73288371e3fa0a610fbc11e7e8418017bdfde42/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs?ref=a73288371e3fa0a610fbc11e7e8418017bdfde42", "patch": "@@ -32,7 +32,7 @@ fn invalid_chars() {\n }\n \n fn parse_positive(s: &[u8]) -> Option<Number> {\n-    parse_number(s, false)\n+    parse_number(s)\n }\n \n #[test]"}]}