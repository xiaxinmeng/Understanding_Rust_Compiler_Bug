{"sha": "1173db00628882300c2651e6e5d8eb6ddbcb5057", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNzNkYjAwNjI4ODgyMzAwYzI2NTFlNmU1ZDhlYjZkZGJjYjUwNTc=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-18T16:42:50Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:03:31Z"}, "message": "Inline last remaining use of Callee::call and delete unused code", "tree": {"sha": "b8bdecf6284737e9c2d062654bc88774fa921c51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8bdecf6284737e9c2d062654bc88774fa921c51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1173db00628882300c2651e6e5d8eb6ddbcb5057", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1173db00628882300c2651e6e5d8eb6ddbcb5057", "html_url": "https://github.com/rust-lang/rust/commit/1173db00628882300c2651e6e5d8eb6ddbcb5057", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1173db00628882300c2651e6e5d8eb6ddbcb5057/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97a2096e5e779fe2473c77b051725bf9f0f8b01d", "url": "https://api.github.com/repos/rust-lang/rust/commits/97a2096e5e779fe2473c77b051725bf9f0f8b01d", "html_url": "https://github.com/rust-lang/rust/commit/97a2096e5e779fe2473c77b051725bf9f0f8b01d"}], "stats": {"total": 323, "additions": 19, "deletions": 304}, "files": [{"sha": "50246a1c5b35ab6ac9e779c47ab94bc7bbdba75a", "filename": "src/librustc_trans/basic_block.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/97a2096e5e779fe2473c77b051725bf9f0f8b01d/src%2Flibrustc_trans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97a2096e5e779fe2473c77b051725bf9f0f8b01d/src%2Flibrustc_trans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbasic_block.rs?ref=97a2096e5e779fe2473c77b051725bf9f0f8b01d", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use llvm;\n-use llvm::BasicBlockRef;\n-use value::Value;\n-\n-#[derive(Copy, Clone)]\n-pub struct BasicBlock(pub BasicBlockRef);\n-\n-/// Wrapper for LLVM BasicBlockRef\n-impl BasicBlock {\n-    pub fn get(&self) -> BasicBlockRef {\n-        self.0\n-    }\n-\n-    pub fn as_value(self) -> Value {\n-        unsafe {\n-            Value(llvm::LLVMBasicBlockAsValue(self.get()))\n-        }\n-    }\n-\n-    pub fn pred_iter(self) -> impl Iterator<Item=BasicBlock> {\n-        self.as_value().user_iter()\n-            .filter(|user| user.is_a_terminator_inst())\n-            .map(|user| user.get_parent().unwrap())\n-    }\n-\n-    pub fn get_single_predecessor(self) -> Option<BasicBlock> {\n-        let mut iter = self.pred_iter();\n-        match (iter.next(), iter.next()) {\n-            (Some(first), None) => Some(first),\n-            _ => None\n-        }\n-    }\n-\n-    pub fn delete(self) {\n-        unsafe {\n-            llvm::LLVMDeleteBasicBlock(self.0);\n-        }\n-    }\n-}"}, {"sha": "4dbfdc9d4999efdd93c24ad5e83351ca829aae41", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 93, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1173db00628882300c2651e6e5d8eb6ddbcb5057/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1173db00628882300c2651e6e5d8eb6ddbcb5057/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=1173db00628882300c2651e6e5d8eb6ddbcb5057", "patch": "@@ -25,7 +25,7 @@ use attributes;\n use base;\n use base::*;\n use common::{\n-    self, BlockAndBuilder, CrateContext, FunctionContext, SharedCrateContext\n+    self, CrateContext, FunctionContext, SharedCrateContext\n };\n use consts;\n use declare;\n@@ -178,26 +178,6 @@ impl<'tcx> Callee<'tcx> {\n         fn_ty\n     }\n \n-    /// This behemoth of a function translates function calls. Unfortunately, in\n-    /// order to generate more efficient LLVM output at -O0, it has quite a complex\n-    /// signature (refactoring this into two functions seems like a good idea).\n-    ///\n-    /// In particular, for lang items, it is invoked with a dest of None, and in\n-    /// that case the return value contains the result of the fn. The lang item must\n-    /// not return a structural type or else all heck breaks loose.\n-    ///\n-    /// For non-lang items, `dest` is always Some, and hence the result is written\n-    /// into memory somewhere. Nonetheless we return the actual return value of the\n-    /// function.\n-    pub fn call<'a>(self,\n-        bcx: &BlockAndBuilder<'a, 'tcx>,\n-        args: &[ValueRef],\n-        dest: Option<ValueRef>,\n-        lpad: Option<&'a llvm::OperandBundleDef>\n-    ) {\n-        trans_call_inner(bcx, self, args, dest, lpad)\n-    }\n-\n     /// Turn the callee into a function pointer.\n     pub fn reify<'a>(self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         match self.data {\n@@ -666,75 +646,3 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     (llfn, fn_ty)\n }\n-\n-// ______________________________________________________________________\n-// Translating calls\n-\n-fn trans_call_inner<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n-    callee: Callee<'tcx>,\n-    args: &[ValueRef],\n-    dest: Option<ValueRef>,\n-    lpad: Option<&'a llvm::OperandBundleDef>\n-) {\n-    // Introduce a temporary cleanup scope that will contain cleanups\n-    // for the arguments while they are being evaluated. The purpose\n-    // this cleanup is to ensure that, should a panic occur while\n-    // evaluating argument N, the values for arguments 0...N-1 are all\n-    // cleaned up. If no panic occurs, the values are handed off to\n-    // the callee, and hence none of the cleanups in this temporary\n-    // scope will ever execute.\n-    let ccx = bcx.ccx();\n-    let fn_ret = callee.ty.fn_ret();\n-    let fn_ty = callee.direct_fn_type(ccx, &[]);\n-\n-    // If there no destination, return must be direct, with no cast.\n-    if dest.is_none() {\n-        assert!(!fn_ty.ret.is_indirect() && fn_ty.ret.cast.is_none());\n-    }\n-\n-    let mut llargs = Vec::new();\n-\n-    if fn_ty.ret.is_indirect() {\n-        let dest = dest.unwrap();\n-        let llretslot = if let Some(ty) = fn_ty.ret.cast {\n-            bcx.pointercast(dest, ty.ptr_to())\n-        } else {\n-            dest\n-        };\n-        llargs.push(llretslot);\n-    }\n-\n-    let llfn = match callee.data {\n-        NamedTupleConstructor(_) | Intrinsic => {\n-            bug!(\"{:?} calls should not go through Callee::call\", callee);\n-        }\n-        Virtual(idx) => {\n-            llargs.push(args[0]);\n-\n-            let fn_ptr = meth::get_virtual_method(&bcx, args[1], idx);\n-            let llty = fn_ty.llvm_type(&bcx.ccx()).ptr_to();\n-            llargs.extend_from_slice(&args[2..]);\n-            bcx.pointercast(fn_ptr, llty)\n-        }\n-        Fn(f) => {\n-            llargs.extend_from_slice(args);\n-            f\n-        }\n-    };\n-\n-    let llret = bcx.call(llfn, &llargs[..], lpad);\n-    fn_ty.apply_attrs_callsite(llret);\n-\n-    // If the function we just called does not use an outpointer,\n-    // store the result into the Rust outpointer.\n-    if !fn_ty.ret.is_indirect() {\n-        if let Some(llretslot) = dest {\n-            fn_ty.ret.store(&bcx, llret, llretslot);\n-        }\n-    }\n-\n-    if fn_ret.0.is_never() {\n-        bcx.unreachable();\n-    }\n-}"}, {"sha": "b1d5955c18d8e2fb99e79bd295bc09284017bd58", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1173db00628882300c2651e6e5d8eb6ddbcb5057/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1173db00628882300c2651e6e5d8eb6ddbcb5057/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=1173db00628882300c2651e6e5d8eb6ddbcb5057", "patch": "@@ -44,7 +44,20 @@ pub fn trans_exchange_free_dyn<'a, 'tcx>(\n ) {\n     let def_id = langcall(bcx.tcx(), None, \"\", ExchangeFreeFnLangItem);\n     let args = [bcx.pointercast(v, Type::i8p(bcx.ccx())), size, align];\n-    Callee::def(bcx.ccx(), def_id, bcx.tcx().intern_substs(&[])).call(&bcx, &args, None, None)\n+    let callee = Callee::def(bcx.ccx(), def_id, bcx.tcx().intern_substs(&[]));\n+\n+    let ccx = bcx.ccx();\n+    let fn_ret = callee.ty.fn_ret();\n+    let fn_ty = callee.direct_fn_type(ccx, &[]);\n+\n+    assert!(!fn_ty.ret.is_indirect() && fn_ty.ret.cast.is_none());\n+\n+    let llret = bcx.call(callee.reify(ccx), &args[..], None);\n+    fn_ty.apply_attrs_callsite(llret);\n+\n+    if fn_ret.0.is_never() {\n+        bcx.unreachable();\n+    }\n }\n \n pub fn trans_exchange_free_ty<'a, 'tcx>("}, {"sha": "2fb0e8c24c540de4200c1c78074b316772837125", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1173db00628882300c2651e6e5d8eb6ddbcb5057/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1173db00628882300c2651e6e5d8eb6ddbcb5057/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=1173db00628882300c2651e6e5d8eb6ddbcb5057", "patch": "@@ -96,7 +96,6 @@ mod asm;\n mod assert_module_sources;\n mod attributes;\n mod base;\n-mod basic_block;\n mod builder;\n mod cabi_aarch64;\n mod cabi_arm;"}, {"sha": "496e14ff2d9d544ae52555059636022dc997deb3", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1173db00628882300c2651e6e5d8eb6ddbcb5057/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1173db00628882300c2651e6e5d8eb6ddbcb5057/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=1173db00628882300c2651e6e5d8eb6ddbcb5057", "patch": "@@ -26,8 +26,6 @@ use syntax::symbol::keywords;\n \n use std::iter;\n \n-use basic_block::BasicBlock;\n-\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n@@ -296,12 +294,12 @@ pub fn trans_mir<'a, 'tcx: 'a>(fcx: &'a FunctionContext<'a, 'tcx>, mir: &'a Mir<\n     // Remove blocks that haven't been visited, or have no\n     // predecessors.\n     for bb in mir.basic_blocks().indices() {\n-        let block = mircx.blocks[bb];\n-        let block = BasicBlock(block);\n         // Unreachable block\n         if !visited.contains(bb.index()) {\n             debug!(\"trans_mir: block {:?} was not visited\", bb);\n-            block.delete();\n+            unsafe {\n+                llvm::LLVMDeleteBasicBlock(mircx.blocks[bb]);\n+            }\n         }\n     }\n }"}, {"sha": "287ad87caacf94e6398c9e6bc8e1ebd9abb063e7", "filename": "src/librustc_trans/value.rs", "status": "modified", "additions": 1, "deletions": 155, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/1173db00628882300c2651e6e5d8eb6ddbcb5057/src%2Flibrustc_trans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1173db00628882300c2651e6e5d8eb6ddbcb5057/src%2Flibrustc_trans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fvalue.rs?ref=1173db00628882300c2651e6e5d8eb6ddbcb5057", "patch": "@@ -9,16 +9,11 @@\n // except according to those terms.\n \n use llvm;\n-use llvm::{UseRef, ValueRef};\n-use basic_block::BasicBlock;\n-use common::BlockAndBuilder;\n \n use std::fmt;\n \n-use libc::c_uint;\n-\n #[derive(Copy, Clone, PartialEq)]\n-pub struct Value(pub ValueRef);\n+pub struct Value(pub llvm::ValueRef);\n \n impl fmt::Debug for Value {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -27,152 +22,3 @@ impl fmt::Debug for Value {\n         }).expect(\"nun-UTF8 value description from LLVM\"))\n     }\n }\n-\n-macro_rules! opt_val { ($e:expr) => (\n-    unsafe {\n-        match $e {\n-            p if !p.is_null() => Some(Value(p)),\n-            _ => None\n-        }\n-    }\n-) }\n-\n-/// Wrapper for LLVM ValueRef\n-impl Value {\n-    /// Returns the native ValueRef\n-    pub fn get(&self) -> ValueRef {\n-        let Value(v) = *self; v\n-    }\n-\n-    /// Returns the BasicBlock that contains this value\n-    pub fn get_parent(self) -> Option<BasicBlock> {\n-        unsafe {\n-            match llvm::LLVMGetInstructionParent(self.get()) {\n-                p if !p.is_null() => Some(BasicBlock(p)),\n-                _ => None\n-            }\n-        }\n-    }\n-\n-    /// Removes this value from its containing BasicBlock\n-    pub fn erase_from_parent(self) {\n-        unsafe {\n-            llvm::LLVMInstructionEraseFromParent(self.get());\n-        }\n-    }\n-\n-    /// Returns the single dominating store to this value, if any\n-    /// This only performs a search for a trivially dominating store. The store\n-    /// must be the only user of this value, and there must not be any conditional\n-    /// branches between the store and the given block.\n-    pub fn get_dominating_store(self, bcx: &BlockAndBuilder) -> Option<Value> {\n-        match self.get_single_user().and_then(|user| user.as_store_inst()) {\n-            Some(store) => {\n-                store.get_parent().and_then(|store_bb| {\n-                    let mut bb = BasicBlock(bcx.llbb());\n-                    let mut ret = Some(store);\n-                    while bb.get() != store_bb.get() {\n-                        match bb.get_single_predecessor() {\n-                            Some(pred) => bb = pred,\n-                            None => { ret = None; break }\n-                        }\n-                    }\n-                    ret\n-                })\n-            }\n-            _ => None\n-        }\n-    }\n-\n-    /// Returns the first use of this value, if any\n-    pub fn get_first_use(self) -> Option<Use> {\n-        unsafe {\n-            match llvm::LLVMGetFirstUse(self.get()) {\n-                u if !u.is_null() => Some(Use(u)),\n-                _ => None\n-            }\n-        }\n-    }\n-\n-    /// Tests if there are no uses of this value\n-    pub fn has_no_uses(self) -> bool {\n-        self.get_first_use().is_none()\n-    }\n-\n-    /// Returns the single user of this value\n-    /// If there are no users or multiple users, this returns None\n-    pub fn get_single_user(self) -> Option<Value> {\n-        let mut iter = self.user_iter();\n-        match (iter.next(), iter.next()) {\n-            (Some(first), None) => Some(first),\n-            _ => None\n-        }\n-    }\n-\n-    /// Returns an iterator for the users of this value\n-    pub fn user_iter(self) -> Users {\n-        Users {\n-            next: self.get_first_use()\n-        }\n-    }\n-\n-    /// Returns the requested operand of this instruction\n-    /// Returns None, if there's no operand at the given index\n-    pub fn get_operand(self, i: usize) -> Option<Value> {\n-        opt_val!(llvm::LLVMGetOperand(self.get(), i as c_uint))\n-    }\n-\n-    /// Returns the Store represent by this value, if any\n-    pub fn as_store_inst(self) -> Option<Value> {\n-        opt_val!(llvm::LLVMIsAStoreInst(self.get()))\n-    }\n-\n-    /// Tests if this value is a terminator instruction\n-    pub fn is_a_terminator_inst(self) -> bool {\n-        unsafe {\n-            !llvm::LLVMIsATerminatorInst(self.get()).is_null()\n-        }\n-    }\n-}\n-\n-/// Wrapper for LLVM UseRef\n-#[derive(Copy, Clone)]\n-pub struct Use(UseRef);\n-\n-impl Use {\n-    pub fn get(&self) -> UseRef {\n-        let Use(v) = *self; v\n-    }\n-\n-    pub fn get_user(self) -> Value {\n-        unsafe {\n-            Value(llvm::LLVMGetUser(self.get()))\n-        }\n-    }\n-\n-    pub fn get_next_use(self) -> Option<Use> {\n-        unsafe {\n-            match llvm::LLVMGetNextUse(self.get()) {\n-                u if !u.is_null() => Some(Use(u)),\n-                _ => None\n-            }\n-        }\n-    }\n-}\n-\n-/// Iterator for the users of a value\n-pub struct Users {\n-    next: Option<Use>\n-}\n-\n-impl Iterator for Users {\n-    type Item = Value;\n-\n-    fn next(&mut self) -> Option<Value> {\n-        let current = self.next;\n-\n-        self.next = current.and_then(|u| u.get_next_use());\n-\n-        current.map(|u| u.get_user())\n-    }\n-}"}]}