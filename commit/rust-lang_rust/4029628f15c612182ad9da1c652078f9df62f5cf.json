{"sha": "4029628f15c612182ad9da1c652078f9df62f5cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMjk2MjhmMTVjNjEyMTgyYWQ5ZGExYzY1MjA3OGY5ZGY2MmY1Y2Y=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-05T15:14:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-05T15:14:35Z"}, "message": "Merge #4729 #4748\n\n4729: Hover actions r=matklad a=vsrs\n\nThis PR adds a `hoverActions` LSP extension and a `Go to Implementations` action as an example:\r\n![hover_actions_impl](https://user-images.githubusercontent.com/62505555/83335732-6d9de280-a2b7-11ea-8cc3-75253d062fe0.gif)\r\n\r\n\n\n4748: Add an `ImportMap` and use it to resolve item paths in `find_path` r=matklad a=jonas-schievink\n\nRemoves the \"go faster\" queries I added in https://github.com/rust-analyzer/rust-analyzer/pull/4501 and https://github.com/rust-analyzer/rust-analyzer/pull/4506. I've checked this PR on the rustc code base and the assists are still fast.\r\n\r\nThis should fix https://github.com/rust-analyzer/rust-analyzer/issues/4515.\r\n\r\nNote that this does introduce a change in behavior: We now always refer to items defined in external crates using paths through the external crate. Previously we could also use a local path (if for example the extern crate was reexported locally), as seen in the changed test. If that is undesired I can fix that, but the test didn't say why the previous behavior would be preferable.\n\nCo-authored-by: vsrs <vit@conrlab.com>\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "1cbc69d7d801ca755516daec8894c8e0f20a2769", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cbc69d7d801ca755516daec8894c8e0f20a2769"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4029628f15c612182ad9da1c652078f9df62f5cf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe2mFbCRBK7hj4Ov3rIwAAdHIIAIZ3uAuNDJJorJMRVM9iW1Cv\nsG1gXSan22PO2ZhitfSR9Mq3G88ZlzwtFqXiF3LaLKbfsR7V98h1Y4udwkquL36q\nkas2arrvrQJ3kMZCctHxRVRgVyLKPQ/KIymW2tfmi6jl5N4yCZo2klJ0lFns3z/A\nHhXs76TQABbcv4oJETiajMvULxaVolGch5PfeapjOe1V4AXabWGtL0Y1q6SYjUL9\nEPRE2sIf8xEW/KaO2F6oWT/R+UwGmZkwOZx83nROreckmyYO/PC4NLoXVDt1PSZ8\nMg1TevxIi3ldS2+XaG3fuiUMijpMZFXcw5gC/s6NxOx2MO+hIxAAgKIo2C2Anwk=\n=DhsO\n-----END PGP SIGNATURE-----\n", "payload": "tree 1cbc69d7d801ca755516daec8894c8e0f20a2769\nparent 9c52f527a1cef7d39c2b1c55b49dc5459d392a4d\nparent bd9d7b6ad885f775df91ff3dfebd8927c8e272b2\nparent bc2d1729957a25bf5ee8e2213d07460e22c76def\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1591370075 +0000\ncommitter GitHub <noreply@github.com> 1591370075 +0000\n\nMerge #4729 #4748\n\n4729: Hover actions r=matklad a=vsrs\n\nThis PR adds a `hoverActions` LSP extension and a `Go to Implementations` action as an example:\r\n![hover_actions_impl](https://user-images.githubusercontent.com/62505555/83335732-6d9de280-a2b7-11ea-8cc3-75253d062fe0.gif)\r\n\r\n\n\n4748: Add an `ImportMap` and use it to resolve item paths in `find_path` r=matklad a=jonas-schievink\n\nRemoves the \"go faster\" queries I added in https://github.com/rust-analyzer/rust-analyzer/pull/4501 and https://github.com/rust-analyzer/rust-analyzer/pull/4506. I've checked this PR on the rustc code base and the assists are still fast.\r\n\r\nThis should fix https://github.com/rust-analyzer/rust-analyzer/issues/4515.\r\n\r\nNote that this does introduce a change in behavior: We now always refer to items defined in external crates using paths through the external crate. Previously we could also use a local path (if for example the extern crate was reexported locally), as seen in the changed test. If that is undesired I can fix that, but the test didn't say why the previous behavior would be preferable.\n\nCo-authored-by: vsrs <vit@conrlab.com>\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4029628f15c612182ad9da1c652078f9df62f5cf", "html_url": "https://github.com/rust-lang/rust/commit/4029628f15c612182ad9da1c652078f9df62f5cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4029628f15c612182ad9da1c652078f9df62f5cf/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c52f527a1cef7d39c2b1c55b49dc5459d392a4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c52f527a1cef7d39c2b1c55b49dc5459d392a4d", "html_url": "https://github.com/rust-lang/rust/commit/9c52f527a1cef7d39c2b1c55b49dc5459d392a4d"}, {"sha": "bd9d7b6ad885f775df91ff3dfebd8927c8e272b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd9d7b6ad885f775df91ff3dfebd8927c8e272b2", "html_url": "https://github.com/rust-lang/rust/commit/bd9d7b6ad885f775df91ff3dfebd8927c8e272b2"}, {"sha": "bc2d1729957a25bf5ee8e2213d07460e22c76def", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc2d1729957a25bf5ee8e2213d07460e22c76def", "html_url": "https://github.com/rust-lang/rust/commit/bc2d1729957a25bf5ee8e2213d07460e22c76def"}], "stats": {"total": 1068, "additions": 899, "deletions": 169}, "files": [{"sha": "fcfa2788c6e033d2196b46c77915af30d42c145d", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -11,8 +11,8 @@ use ra_syntax::{ast, Parse, SourceFile, TextRange, TextSize};\n pub use crate::{\n     cancellation::Canceled,\n     input::{\n-        CrateGraph, CrateId, CrateName, Dependency, Edition, Env, ExternSource, ExternSourceId,\n-        FileId, ProcMacroId, SourceRoot, SourceRootId,\n+        CrateData, CrateGraph, CrateId, CrateName, Dependency, Edition, Env, ExternSource,\n+        ExternSourceId, FileId, ProcMacroId, SourceRoot, SourceRootId,\n     },\n };\n pub use relative_path::{RelativePath, RelativePathBuf};"}, {"sha": "098b665292c6f7cecd716a89ab8095fcf84187cd", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -3,11 +3,11 @@\n pub use hir_def::db::{\n     AttrsQuery, BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQueryQuery,\n     CrateLangItemsQuery, DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery,\n-    ExprScopesQuery, FunctionDataQuery, GenericParamsQuery, ImplDataQuery, InternConstQuery,\n-    InternDatabase, InternDatabaseStorage, InternEnumQuery, InternFunctionQuery, InternImplQuery,\n-    InternStaticQuery, InternStructQuery, InternTraitQuery, InternTypeAliasQuery, InternUnionQuery,\n-    LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, StaticDataQuery, StructDataQuery,\n-    TraitDataQuery, TypeAliasDataQuery, UnionDataQuery,\n+    ExprScopesQuery, FunctionDataQuery, GenericParamsQuery, ImplDataQuery, ImportMapQuery,\n+    InternConstQuery, InternDatabase, InternDatabaseStorage, InternEnumQuery, InternFunctionQuery,\n+    InternImplQuery, InternStaticQuery, InternStructQuery, InternTraitQuery, InternTypeAliasQuery,\n+    InternUnionQuery, LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, StaticDataQuery,\n+    StructDataQuery, TraitDataQuery, TypeAliasDataQuery, UnionDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, InternEagerExpansionQuery, InternMacroQuery,"}, {"sha": "10cc26480f365271c801cfd3e29559fbc8b0a835", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -1,7 +1,7 @@\n //! Defines database & queries for name resolution.\n use std::sync::Arc;\n \n-use hir_expand::{db::AstDatabase, name::Name, HirFileId};\n+use hir_expand::{db::AstDatabase, HirFileId};\n use ra_db::{salsa, CrateId, SourceDatabase, Upcast};\n use ra_prof::profile;\n use ra_syntax::SmolStr;\n@@ -12,13 +12,10 @@ use crate::{\n     body::{scope::ExprScopes, Body, BodySourceMap},\n     data::{ConstData, FunctionData, ImplData, StaticData, TraitData, TypeAliasData},\n     docs::Documentation,\n-    find_path,\n     generics::GenericParams,\n-    item_scope::ItemInNs,\n+    import_map::ImportMap,\n     lang_item::{LangItemTarget, LangItems},\n     nameres::{raw::RawItems, CrateDefMap},\n-    path::ModPath,\n-    visibility::Visibility,\n     AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, FunctionId, FunctionLoc,\n     GenericDefId, ImplId, ImplLoc, ModuleId, StaticId, StaticLoc, StructId, StructLoc, TraitId,\n     TraitLoc, TypeAliasId, TypeAliasLoc, UnionId, UnionLoc,\n@@ -113,15 +110,8 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(Documentation::documentation_query)]\n     fn documentation(&self, def: AttrDefId) -> Option<Documentation>;\n \n-    #[salsa::invoke(find_path::importable_locations_of_query)]\n-    fn importable_locations_of(\n-        &self,\n-        item: ItemInNs,\n-        krate: CrateId,\n-    ) -> Arc<[(ModuleId, Name, Visibility)]>;\n-\n-    #[salsa::invoke(find_path::find_path_inner_query)]\n-    fn find_path_inner(&self, item: ItemInNs, from: ModuleId, max_len: usize) -> Option<ModPath>;\n+    #[salsa::invoke(ImportMap::import_map_query)]\n+    fn import_map(&self, krate: CrateId) -> Arc<ImportMap>;\n }\n \n fn crate_def_map_wait(db: &impl DefDatabase, krate: CrateId) -> Arc<CrateDefMap> {"}, {"sha": "a7f59e0287ff7b9d384ac351d785c48a86936456", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 119, "deletions": 83, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -1,17 +1,16 @@\n //! An algorithm to find a path to refer to a certain item.\n \n-use std::sync::Arc;\n-\n use hir_expand::name::{known, AsName, Name};\n use ra_prof::profile;\n+use rustc_hash::FxHashSet;\n use test_utils::mark;\n \n use crate::{\n     db::DefDatabase,\n     item_scope::ItemInNs,\n     path::{ModPath, PathKind},\n     visibility::Visibility,\n-    CrateId, ModuleDefId, ModuleId,\n+    ModuleDefId, ModuleId,\n };\n \n // FIXME: handle local items\n@@ -20,7 +19,7 @@ use crate::{\n /// *from where* you're referring to the item, hence the `from` parameter.\n pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n     let _p = profile(\"find_path\");\n-    db.find_path_inner(item, from, MAX_PATH_LEN)\n+    find_path_inner(db, item, from, MAX_PATH_LEN)\n }\n \n const MAX_PATH_LEN: usize = 15;\n@@ -36,20 +35,9 @@ impl ModPath {\n         let first_segment = self.segments.first();\n         first_segment == Some(&known::alloc) || first_segment == Some(&known::core)\n     }\n-\n-    fn len(&self) -> usize {\n-        self.segments.len()\n-            + match self.kind {\n-                PathKind::Plain => 0,\n-                PathKind::Super(i) => i as usize,\n-                PathKind::Crate => 1,\n-                PathKind::Abs => 0,\n-                PathKind::DollarCrate(_) => 1,\n-            }\n-    }\n }\n \n-pub(crate) fn find_path_inner_query(\n+fn find_path_inner(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n@@ -133,31 +121,61 @@ pub(crate) fn find_path_inner_query(\n     }\n \n     // - otherwise, look for modules containing (reexporting) it and import it from one of those\n+\n     let crate_root = ModuleId { local_id: def_map.root, krate: from.krate };\n     let crate_attrs = db.attrs(crate_root.into());\n     let prefer_no_std = crate_attrs.by_key(\"no_std\").exists();\n-    let importable_locations = find_importable_locations(db, item, from);\n     let mut best_path = None;\n     let mut best_path_len = max_len;\n-    for (module_id, name) in importable_locations {\n-        let mut path = match db.find_path_inner(\n-            ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n-            from,\n-            best_path_len - 1,\n-        ) {\n-            None => continue,\n-            Some(path) => path,\n-        };\n-        path.segments.push(name);\n \n-        let new_path = if let Some(best_path) = best_path {\n-            select_best_path(best_path, path, prefer_no_std)\n-        } else {\n-            path\n-        };\n-        best_path_len = new_path.len();\n-        best_path = Some(new_path);\n+    if item.krate(db) == Some(from.krate) {\n+        // Item was defined in the same crate that wants to import it. It cannot be found in any\n+        // dependency in this case.\n+\n+        let local_imports = find_local_import_locations(db, item, from);\n+        for (module_id, name) in local_imports {\n+            if let Some(mut path) = find_path_inner(\n+                db,\n+                ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n+                from,\n+                best_path_len - 1,\n+            ) {\n+                path.segments.push(name);\n+\n+                let new_path = if let Some(best_path) = best_path {\n+                    select_best_path(best_path, path, prefer_no_std)\n+                } else {\n+                    path\n+                };\n+                best_path_len = new_path.len();\n+                best_path = Some(new_path);\n+            }\n+        }\n+    } else {\n+        // Item was defined in some upstream crate. This means that it must be exported from one,\n+        // too (unless we can't name it at all). It could *also* be (re)exported by the same crate\n+        // that wants to import it here, but we always prefer to use the external path here.\n+\n+        let crate_graph = db.crate_graph();\n+        let extern_paths = crate_graph[from.krate].dependencies.iter().filter_map(|dep| {\n+            let import_map = db.import_map(dep.crate_id);\n+            import_map.path_of(item).map(|modpath| {\n+                let mut modpath = modpath.clone();\n+                modpath.segments.insert(0, dep.as_name());\n+                modpath\n+            })\n+        });\n+\n+        for path in extern_paths {\n+            let new_path = if let Some(best_path) = best_path {\n+                select_best_path(best_path, path, prefer_no_std)\n+            } else {\n+                path\n+            };\n+            best_path = Some(new_path);\n+        }\n     }\n+\n     best_path\n }\n \n@@ -185,69 +203,86 @@ fn select_best_path(old_path: ModPath, new_path: ModPath, prefer_no_std: bool) -\n     }\n }\n \n-fn find_importable_locations(\n+/// Finds locations in `from.krate` from which `item` can be imported by `from`.\n+fn find_local_import_locations(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n ) -> Vec<(ModuleId, Name)> {\n-    let crate_graph = db.crate_graph();\n-    let mut result = Vec::new();\n-    // We only look in the crate from which we are importing, and the direct\n-    // dependencies. We cannot refer to names from transitive dependencies\n-    // directly (only through reexports in direct dependencies).\n-    for krate in Some(from.krate)\n-        .into_iter()\n-        .chain(crate_graph[from.krate].dependencies.iter().map(|dep| dep.crate_id))\n-    {\n-        result.extend(\n-            db.importable_locations_of(item, krate)\n-                .iter()\n-                .filter(|(_, _, vis)| vis.is_visible_from(db, from))\n-                .map(|(m, n, _)| (*m, n.clone())),\n-        );\n-    }\n-    result\n-}\n+    let _p = profile(\"find_local_import_locations\");\n+\n+    // `from` can import anything below `from` with visibility of at least `from`, and anything\n+    // above `from` with any visibility. That means we do not need to descend into private siblings\n+    // of `from` (and similar).\n+\n+    let def_map = db.crate_def_map(from.krate);\n+\n+    // Compute the initial worklist. We start with all direct child modules of `from` as well as all\n+    // of its (recursive) parent modules.\n+    let data = &def_map.modules[from.local_id];\n+    let mut worklist = data\n+        .children\n+        .values()\n+        .map(|child| ModuleId { krate: from.krate, local_id: *child })\n+        .collect::<Vec<_>>();\n+    let mut parent = data.parent;\n+    while let Some(p) = parent {\n+        worklist.push(ModuleId { krate: from.krate, local_id: p });\n+        parent = def_map.modules[p].parent;\n+    }\n+\n+    let mut seen: FxHashSet<_> = FxHashSet::default();\n+\n+    let mut locations = Vec::new();\n+    while let Some(module) = worklist.pop() {\n+        if !seen.insert(module) {\n+            continue; // already processed this module\n+        }\n+\n+        let ext_def_map;\n+        let data = if module.krate == from.krate {\n+            &def_map[module.local_id]\n+        } else {\n+            // The crate might reexport a module defined in another crate.\n+            ext_def_map = db.crate_def_map(module.krate);\n+            &ext_def_map[module.local_id]\n+        };\n \n-/// Collects all locations from which we might import the item in a particular\n-/// crate. These include the original definition of the item, and any\n-/// non-private `use`s.\n-///\n-/// Note that the crate doesn't need to be the one in which the item is defined;\n-/// it might be re-exported in other crates.\n-pub(crate) fn importable_locations_of_query(\n-    db: &dyn DefDatabase,\n-    item: ItemInNs,\n-    krate: CrateId,\n-) -> Arc<[(ModuleId, Name, Visibility)]> {\n-    let _p = profile(\"importable_locations_of_query\");\n-    let def_map = db.crate_def_map(krate);\n-    let mut result = Vec::new();\n-    for (local_id, data) in def_map.modules.iter() {\n         if let Some((name, vis)) = data.scope.name_of(item) {\n-            let is_private = if let Visibility::Module(private_to) = vis {\n-                private_to.local_id == local_id\n-            } else {\n-                false\n-            };\n-            let is_original_def = if let Some(module_def_id) = item.as_module_def_id() {\n-                data.scope.declarations().any(|it| it == module_def_id)\n-            } else {\n-                false\n-            };\n-            if is_private && !is_original_def {\n+            if vis.is_visible_from(db, from) {\n+                let is_private = if let Visibility::Module(private_to) = vis {\n+                    private_to.local_id == module.local_id\n+                } else {\n+                    false\n+                };\n+                let is_original_def = if let Some(module_def_id) = item.as_module_def_id() {\n+                    data.scope.declarations().any(|it| it == module_def_id)\n+                } else {\n+                    false\n+                };\n+\n                 // Ignore private imports. these could be used if we are\n                 // in a submodule of this module, but that's usually not\n                 // what the user wants; and if this module can import\n                 // the item and we're a submodule of it, so can we.\n                 // Also this keeps the cached data smaller.\n-                continue;\n+                if !is_private || is_original_def {\n+                    locations.push((module, name.clone()));\n+                }\n+            }\n+        }\n+\n+        // Descend into all modules visible from `from`.\n+        for (_, per_ns) in data.scope.entries() {\n+            if let Some((ModuleDefId::ModuleId(module), vis)) = per_ns.take_types_vis() {\n+                if vis.is_visible_from(db, from) {\n+                    worklist.push(module);\n+                }\n             }\n-            result.push((ModuleId { krate, local_id }, name.clone(), vis));\n         }\n     }\n \n-    Arc::from(result)\n+    locations\n }\n \n #[cfg(test)]\n@@ -385,14 +420,15 @@ mod tests {\n \n     #[test]\n     fn different_crate_renamed() {\n+        // Even if a local path exists, if the item is defined externally, prefer an external path.\n         let code = r#\"\n             //- /main.rs crate:main deps:std\n             extern crate std as std_renamed;\n             <|>\n             //- /std.rs crate:std\n             pub struct S;\n         \"#;\n-        check_found_path(code, \"std_renamed::S\");\n+        check_found_path(code, \"std::S\");\n     }\n \n     #[test]"}, {"sha": "4284a0a9120a768037eea57d3ad42b82a98b0b2c", "filename": "crates/ra_hir_def/src/import_map.rs", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -0,0 +1,331 @@\n+//! A map of all publicly exported items in a crate.\n+\n+use std::{collections::hash_map::Entry, fmt, sync::Arc};\n+\n+use ra_db::CrateId;\n+use rustc_hash::FxHashMap;\n+\n+use crate::{\n+    db::DefDatabase,\n+    item_scope::ItemInNs,\n+    path::{ModPath, PathKind},\n+    visibility::Visibility,\n+    ModuleDefId, ModuleId,\n+};\n+\n+/// A map from publicly exported items to the path needed to import/name them from a downstream\n+/// crate.\n+///\n+/// Reexports of items are taken into account, ie. if something is exported under multiple\n+/// names, the one with the shortest import path will be used.\n+///\n+/// Note that all paths are relative to the containing crate's root, so the crate name still needs\n+/// to be prepended to the `ModPath` before the path is valid.\n+#[derive(Eq, PartialEq)]\n+pub struct ImportMap {\n+    map: FxHashMap<ItemInNs, ModPath>,\n+}\n+\n+impl ImportMap {\n+    pub fn import_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<Self> {\n+        let _p = ra_prof::profile(\"import_map_query\");\n+        let def_map = db.crate_def_map(krate);\n+        let mut import_map = FxHashMap::with_capacity_and_hasher(64, Default::default());\n+\n+        // We look only into modules that are public(ly reexported), starting with the crate root.\n+        let empty = ModPath { kind: PathKind::Plain, segments: vec![] };\n+        let root = ModuleId { krate, local_id: def_map.root };\n+        let mut worklist = vec![(root, empty)];\n+        while let Some((module, mod_path)) = worklist.pop() {\n+            let ext_def_map;\n+            let mod_data = if module.krate == krate {\n+                &def_map[module.local_id]\n+            } else {\n+                // The crate might reexport a module defined in another crate.\n+                ext_def_map = db.crate_def_map(module.krate);\n+                &ext_def_map[module.local_id]\n+            };\n+\n+            let visible_items = mod_data.scope.entries().filter_map(|(name, per_ns)| {\n+                let per_ns = per_ns.filter_visibility(|vis| vis == Visibility::Public);\n+                if per_ns.is_none() {\n+                    None\n+                } else {\n+                    Some((name, per_ns))\n+                }\n+            });\n+\n+            for (name, per_ns) in visible_items {\n+                let mk_path = || {\n+                    let mut path = mod_path.clone();\n+                    path.segments.push(name.clone());\n+                    path\n+                };\n+\n+                for item in per_ns.iter_items() {\n+                    let path = mk_path();\n+                    match import_map.entry(item) {\n+                        Entry::Vacant(entry) => {\n+                            entry.insert(path);\n+                        }\n+                        Entry::Occupied(mut entry) => {\n+                            // If the new path is shorter, prefer that one.\n+                            if path.len() < entry.get().len() {\n+                                *entry.get_mut() = path;\n+                            } else {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+\n+                    // If we've just added a path to a module, descend into it. We might traverse\n+                    // modules multiple times, but only if the new path to it is shorter than the\n+                    // first (else we `continue` above).\n+                    if let Some(ModuleDefId::ModuleId(mod_id)) = item.as_module_def_id() {\n+                        worklist.push((mod_id, mk_path()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        Arc::new(Self { map: import_map })\n+    }\n+\n+    /// Returns the `ModPath` needed to import/mention `item`, relative to this crate's root.\n+    pub fn path_of(&self, item: ItemInNs) -> Option<&ModPath> {\n+        self.map.get(&item)\n+    }\n+}\n+\n+impl fmt::Debug for ImportMap {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut importable_paths: Vec<_> = self\n+            .map\n+            .iter()\n+            .map(|(item, modpath)| {\n+                let ns = match item {\n+                    ItemInNs::Types(_) => \"t\",\n+                    ItemInNs::Values(_) => \"v\",\n+                    ItemInNs::Macros(_) => \"m\",\n+                };\n+                format!(\"- {} ({})\", modpath, ns)\n+            })\n+            .collect();\n+\n+        importable_paths.sort();\n+        f.write_str(&importable_paths.join(\"\\n\"))\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::test_db::TestDB;\n+    use insta::assert_snapshot;\n+    use ra_db::fixture::WithFixture;\n+    use ra_db::SourceDatabase;\n+\n+    fn import_map(ra_fixture: &str) -> String {\n+        let db = TestDB::with_files(ra_fixture);\n+        let crate_graph = db.crate_graph();\n+\n+        let import_maps: Vec<_> = crate_graph\n+            .iter()\n+            .filter_map(|krate| {\n+                let cdata = &crate_graph[krate];\n+                let name = cdata.display_name.as_ref()?;\n+\n+                let map = db.import_map(krate);\n+\n+                Some(format!(\"{}:\\n{:?}\", name, map))\n+            })\n+            .collect();\n+\n+        import_maps.join(\"\\n\")\n+    }\n+\n+    #[test]\n+    fn smoke() {\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+\n+            mod private {\n+                pub use lib::Pub;\n+                pub struct InPrivateModule;\n+            }\n+\n+            pub mod publ1 {\n+                use lib::Pub;\n+            }\n+\n+            pub mod real_pub {\n+                pub use lib::Pub;\n+            }\n+            pub mod real_pu2 { // same path length as above\n+                pub use lib::Pub;\n+            }\n+\n+            //- /lib.rs crate:lib\n+            pub struct Pub {}\n+            pub struct Pub2; // t + v\n+            struct Priv;\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - publ1 (t)\n+        - real_pu2 (t)\n+        - real_pub (t)\n+        - real_pub::Pub (t)\n+        lib:\n+        - Pub (t)\n+        - Pub2 (t)\n+        - Pub2 (v)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn prefers_shortest_path() {\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main\n+\n+            pub mod sub {\n+                pub mod subsub {\n+                    pub struct Def {}\n+                }\n+\n+                pub use super::sub::subsub::Def;\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - sub (t)\n+        - sub::Def (t)\n+        - sub::subsub (t)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn type_reexport_cross_crate() {\n+        // Reexports need to be visible from a crate, even if the original crate exports the item\n+        // at a shorter path.\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+            pub mod m {\n+                pub use lib::S;\n+            }\n+            //- /lib.rs crate:lib\n+            pub struct S;\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - m (t)\n+        - m::S (t)\n+        - m::S (v)\n+        lib:\n+        - S (t)\n+        - S (v)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn macro_reexport() {\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+            pub mod m {\n+                pub use lib::pub_macro;\n+            }\n+            //- /lib.rs crate:lib\n+            #[macro_export]\n+            macro_rules! pub_macro {\n+                () => {};\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - m (t)\n+        - m::pub_macro (m)\n+        lib:\n+        - pub_macro (m)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn module_reexport() {\n+        // Reexporting modules from a dependency adds all contents to the import map.\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+            pub use lib::module as reexported_module;\n+            //- /lib.rs crate:lib\n+            pub mod module {\n+                pub struct S;\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - reexported_module (t)\n+        - reexported_module::S (t)\n+        - reexported_module::S (v)\n+        lib:\n+        - module (t)\n+        - module::S (t)\n+        - module::S (v)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn cyclic_module_reexport() {\n+        // A cyclic reexport does not hang.\n+        let map = import_map(\n+            r\"\n+            //- /lib.rs crate:lib\n+            pub mod module {\n+                pub struct S;\n+                pub use super::sub::*;\n+            }\n+\n+            pub mod sub {\n+                pub use super::module;\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        lib:\n+        - module (t)\n+        - module::S (t)\n+        - module::S (v)\n+        - sub (t)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn private_macro() {\n+        let map = import_map(\n+            r\"\n+            //- /lib.rs crate:lib\n+            macro_rules! private_macro {\n+                () => {};\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        lib:\n+        \"###);\n+    }\n+}"}, {"sha": "b03ba939a5a575a0b49965297c10164a5bb8f95b", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -3,11 +3,12 @@\n \n use hir_expand::name::Name;\n use once_cell::sync::Lazy;\n+use ra_db::CrateId;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, ImplId, MacroDefId, ModuleDefId,\n-    TraitId,\n+    db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, HasModule, ImplId,\n+    Lookup, MacroDefId, ModuleDefId, TraitId,\n };\n \n #[derive(Debug, Default, PartialEq, Eq)]\n@@ -203,4 +204,22 @@ impl ItemInNs {\n             ItemInNs::Macros(_) => None,\n         }\n     }\n+\n+    /// Returns the crate defining this item (or `None` if `self` is built-in).\n+    pub fn krate(&self, db: &dyn DefDatabase) -> Option<CrateId> {\n+        Some(match self {\n+            ItemInNs::Types(did) | ItemInNs::Values(did) => match did {\n+                ModuleDefId::ModuleId(id) => id.krate,\n+                ModuleDefId::FunctionId(id) => id.lookup(db).module(db).krate,\n+                ModuleDefId::AdtId(id) => id.module(db).krate,\n+                ModuleDefId::EnumVariantId(id) => id.parent.lookup(db).container.module(db).krate,\n+                ModuleDefId::ConstId(id) => id.lookup(db).container.module(db).krate,\n+                ModuleDefId::StaticId(id) => id.lookup(db).container.module(db).krate,\n+                ModuleDefId::TraitId(id) => id.lookup(db).container.module(db).krate,\n+                ModuleDefId::TypeAliasId(id) => id.lookup(db).module(db).krate,\n+                ModuleDefId::BuiltinType(_) => return None,\n+            },\n+            ItemInNs::Macros(id) => return id.krate,\n+        })\n+    }\n }"}, {"sha": "de490fcc58af295ec07d424046ebc7ba1e1c9e48", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -43,6 +43,7 @@ pub mod child_by_source;\n \n pub mod visibility;\n pub mod find_path;\n+pub mod import_map;\n \n #[cfg(test)]\n mod test_db;"}, {"sha": "bfa921de2220aafc92f24626cc07f3a24e13cc35", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -76,6 +76,19 @@ impl ModPath {\n         }\n     }\n \n+    /// Returns the number of segments in the path (counting special segments like `$crate` and\n+    /// `super`).\n+    pub fn len(&self) -> usize {\n+        self.segments.len()\n+            + match self.kind {\n+                PathKind::Plain => 0,\n+                PathKind::Super(i) => i as usize,\n+                PathKind::Crate => 1,\n+                PathKind::Abs => 0,\n+                PathKind::DollarCrate(_) => 1,\n+            }\n+    }\n+\n     pub fn is_ident(&self) -> bool {\n         self.kind == PathKind::Plain && self.segments.len() == 1\n     }"}, {"sha": "74665c58851c909417bbd2efe9a24b180b1a39dc", "filename": "crates/ra_hir_def/src/per_ns.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -5,7 +5,7 @@\n \n use hir_expand::MacroDefId;\n \n-use crate::{visibility::Visibility, ModuleDefId};\n+use crate::{item_scope::ItemInNs, visibility::Visibility, ModuleDefId};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub struct PerNs {\n@@ -84,4 +84,12 @@ impl PerNs {\n             macros: self.macros.or(other.macros),\n         }\n     }\n+\n+    pub fn iter_items(self) -> impl Iterator<Item = ItemInNs> {\n+        self.types\n+            .map(|it| ItemInNs::Types(it.0))\n+            .into_iter()\n+            .chain(self.values.map(|it| ItemInNs::Values(it.0)).into_iter())\n+            .chain(self.macros.map(|it| ItemInNs::Macros(it.0)).into_iter())\n+    }\n }"}, {"sha": "62df074594b5116746ff1abc735169e647553f1b", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 136, "deletions": 12, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -13,14 +13,43 @@ use ra_ide_db::{\n use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset};\n \n use crate::{\n-    display::{macro_label, rust_code_markup, rust_code_markup_with_doc, ShortLabel},\n-    FilePosition, RangeInfo,\n+    display::{macro_label, rust_code_markup, rust_code_markup_with_doc, ShortLabel, ToNav},\n+    FilePosition, NavigationTarget, RangeInfo,\n };\n \n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct HoverConfig {\n+    pub implementations: bool,\n+}\n+\n+impl Default for HoverConfig {\n+    fn default() -> Self {\n+        Self { implementations: true }\n+    }\n+}\n+\n+impl HoverConfig {\n+    pub const NO_ACTIONS: Self = Self { implementations: false };\n+\n+    pub fn any(&self) -> bool {\n+        self.implementations\n+    }\n+\n+    pub fn none(&self) -> bool {\n+        !self.any()\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum HoverAction {\n+    Implementaion(FilePosition),\n+}\n+\n /// Contains the results when hovering over an item\n #[derive(Debug, Default)]\n pub struct HoverResult {\n     results: Vec<String>,\n+    actions: Vec<HoverAction>,\n }\n \n impl HoverResult {\n@@ -48,10 +77,20 @@ impl HoverResult {\n         &self.results\n     }\n \n+    pub fn actions(&self) -> &[HoverAction] {\n+        &self.actions\n+    }\n+\n+    pub fn push_action(&mut self, action: HoverAction) {\n+        self.actions.push(action);\n+    }\n+\n     /// Returns the results converted into markup\n     /// for displaying in a UI\n+    ///\n+    /// Does not process actions!\n     pub fn to_markup(&self) -> String {\n-        self.results.join(\"\\n\\n---\\n\")\n+        self.results.join(\"\\n\\n___\\n\")\n     }\n }\n \n@@ -82,6 +121,10 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         res.extend(hover_text_from_name_kind(db, name_kind));\n \n         if !res.is_empty() {\n+            if let Some(action) = show_implementations_action(db, name_kind) {\n+                res.push_action(action);\n+            }\n+\n             return Some(RangeInfo::new(range, res));\n         }\n     }\n@@ -112,6 +155,26 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n     Some(RangeInfo::new(range, res))\n }\n \n+fn show_implementations_action(db: &RootDatabase, def: Definition) -> Option<HoverAction> {\n+    fn to_action(nav_target: NavigationTarget) -> HoverAction {\n+        HoverAction::Implementaion(FilePosition {\n+            file_id: nav_target.file_id(),\n+            offset: nav_target.range().start(),\n+        })\n+    }\n+\n+    match def {\n+        Definition::ModuleDef(it) => match it {\n+            ModuleDef::Adt(Adt::Struct(it)) => Some(to_action(it.to_nav(db))),\n+            ModuleDef::Adt(Adt::Union(it)) => Some(to_action(it.to_nav(db))),\n+            ModuleDef::Adt(Adt::Enum(it)) => Some(to_action(it.to_nav(db))),\n+            ModuleDef::Trait(it) => Some(to_action(it.to_nav(db))),\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}\n+\n fn hover_text(\n     docs: Option<String>,\n     desc: Option<String>,\n@@ -228,6 +291,8 @@ fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n \n #[cfg(test)]\n mod tests {\n+    use super::*;\n+\n     use ra_db::FileLoader;\n     use ra_syntax::TextRange;\n \n@@ -241,7 +306,14 @@ mod tests {\n         s.map(trim_markup)\n     }\n \n-    fn check_hover_result(fixture: &str, expected: &[&str]) -> String {\n+    fn assert_impl_action(action: &HoverAction, position: u32) {\n+        let offset = match action {\n+            HoverAction::Implementaion(pos) => pos.offset,\n+        };\n+        assert_eq!(offset, position.into());\n+    }\n+\n+    fn check_hover_result(fixture: &str, expected: &[&str]) -> (String, Vec<HoverAction>) {\n         let (analysis, position) = analysis_and_position(fixture);\n         let hover = analysis.hover(position).unwrap().unwrap();\n         let mut results = Vec::from(hover.info.results());\n@@ -256,7 +328,7 @@ mod tests {\n         assert_eq!(hover.info.len(), expected.len());\n \n         let content = analysis.db.file_text(position.file_id);\n-        content[hover.range].to_string()\n+        (content[hover.range].to_string(), hover.info.actions().to_vec())\n     }\n \n     fn check_hover_no_result(fixture: &str) {\n@@ -746,7 +818,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_through_macro() {\n-        let hover_on = check_hover_result(\n+        let (hover_on, _) = check_hover_result(\n             \"\n             //- /lib.rs\n             macro_rules! id {\n@@ -767,7 +839,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_through_expr_in_macro() {\n-        let hover_on = check_hover_result(\n+        let (hover_on, _) = check_hover_result(\n             \"\n             //- /lib.rs\n             macro_rules! id {\n@@ -785,7 +857,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_through_expr_in_macro_recursive() {\n-        let hover_on = check_hover_result(\n+        let (hover_on, _) = check_hover_result(\n             \"\n             //- /lib.rs\n             macro_rules! id_deep {\n@@ -806,7 +878,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_through_func_in_macro_recursive() {\n-        let hover_on = check_hover_result(\n+        let (hover_on, _) = check_hover_result(\n             \"\n             //- /lib.rs\n             macro_rules! id_deep {\n@@ -830,7 +902,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_through_literal_string_in_macro() {\n-        let hover_on = check_hover_result(\n+        let (hover_on, _) = check_hover_result(\n             r#\"\n             //- /lib.rs\n             macro_rules! arr {\n@@ -849,7 +921,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_through_assert_macro() {\n-        let hover_on = check_hover_result(\n+        let (hover_on, _) = check_hover_result(\n             r#\"\n             //- /lib.rs\n             #[rustc_builtin_macro]\n@@ -925,13 +997,14 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_trait_show_qualifiers() {\n-        check_hover_result(\n+        let (_, actions) = check_hover_result(\n             \"\n             //- /lib.rs\n             unsafe trait foo<|>() {}\n             \",\n             &[\"unsafe trait foo\"],\n         );\n+        assert_impl_action(&actions[0], 13);\n     }\n \n     #[test]\n@@ -1052,4 +1125,55 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             &[\"Bar\\n```\\n\\n```rust\\nfn foo(&self)\\n```\\n___\\n\\nDo the foo\"],\n         );\n     }\n+\n+    #[test]\n+    fn test_hover_trait_has_impl_action() {\n+        let (_, actions) = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            trait foo<|>() {}\n+            \",\n+            &[\"trait foo\"],\n+        );\n+        assert_impl_action(&actions[0], 6);\n+    }\n+\n+    #[test]\n+    fn test_hover_struct_has_impl_action() {\n+        let (_, actions) = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            struct foo<|>() {}\n+            \",\n+            &[\"struct foo\"],\n+        );\n+        assert_impl_action(&actions[0], 7);\n+    }\n+\n+    #[test]\n+    fn test_hover_union_has_impl_action() {\n+        let (_, actions) = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            union foo<|>() {}\n+            \",\n+            &[\"union foo\"],\n+        );\n+        assert_impl_action(&actions[0], 6);\n+    }\n+\n+    #[test]\n+    fn test_hover_enum_has_impl_action() {\n+        let (_, actions) = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            enum foo<|>() {\n+                A,\n+                B\n+            }\n+            \",\n+            &[\"enum foo\"],\n+        );\n+        assert_impl_action(&actions[0], 5);\n+    }\n }"}, {"sha": "a56718d3f5958eaa48afc6702a9427f35236b445", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -66,7 +66,7 @@ pub use crate::{\n     display::{file_structure, FunctionSignature, NavigationTarget, StructureNode},\n     expand_macro::ExpandedMacro,\n     folding_ranges::{Fold, FoldKind},\n-    hover::HoverResult,\n+    hover::{HoverAction, HoverConfig, HoverResult},\n     inlay_hints::{InlayHint, InlayHintsConfig, InlayKind},\n     references::{Declaration, Reference, ReferenceAccess, ReferenceKind, ReferenceSearchResult},\n     runnables::{Runnable, RunnableKind, TestId},"}, {"sha": "ea78e49e050edccda16cc9aad6906e4d577c9cd8", "filename": "crates/ra_ide_db/src/change.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fchange.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -334,6 +334,7 @@ impl RootDatabase {\n             hir::db::CrateLangItemsQuery\n             hir::db::LangItemQuery\n             hir::db::DocumentationQuery\n+            hir::db::ImportMapQuery\n \n             // InternDatabase\n             hir::db::InternFunctionQuery"}, {"sha": "1db60b87fb82b9a6804b0d5817ee7081df872285", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -18,7 +18,7 @@ use ra_syntax::{\n use crate::RootDatabase;\n \n // FIXME: a more precise name would probably be `Symbol`?\n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub enum Definition {\n     Macro(MacroDef),\n     Field(Field),"}, {"sha": "8d6efdbe8cf970775f15a7f241c5af720e0b3381", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -11,7 +11,7 @@ use std::{ffi::OsString, path::PathBuf};\n \n use lsp_types::ClientCapabilities;\n use ra_flycheck::FlycheckConfig;\n-use ra_ide::{AssistConfig, CompletionConfig, InlayHintsConfig};\n+use ra_ide::{AssistConfig, CompletionConfig, HoverConfig, InlayHintsConfig};\n use ra_project_model::{CargoConfig, JsonProject, ProjectManifest};\n use serde::Deserialize;\n \n@@ -34,6 +34,7 @@ pub struct Config {\n     pub assist: AssistConfig,\n     pub call_info_full: bool,\n     pub lens: LensConfig,\n+    pub hover: HoverConfig,\n \n     pub with_sysroot: bool,\n     pub linked_projects: Vec<LinkedProject>,\n@@ -124,6 +125,7 @@ pub struct ClientCapsConfig {\n     pub work_done_progress: bool,\n     pub code_action_group: bool,\n     pub resolve_code_action: bool,\n+    pub hover_actions: bool,\n }\n \n impl Default for Config {\n@@ -162,6 +164,7 @@ impl Default for Config {\n             assist: AssistConfig::default(),\n             call_info_full: true,\n             lens: LensConfig::default(),\n+            hover: HoverConfig::default(),\n             linked_projects: Vec::new(),\n         }\n     }\n@@ -278,6 +281,14 @@ impl Config {\n             }\n         }\n \n+        let mut use_hover_actions = false;\n+        set(value, \"/hoverActions/enable\", &mut use_hover_actions);\n+        if use_hover_actions {\n+            set(value, \"/hoverActions/implementations\", &mut self.hover.implementations);\n+        } else {\n+            self.hover = HoverConfig::NO_ACTIONS;\n+        }\n+\n         log::info!(\"Config::update() = {:#?}\", self);\n \n         fn get<'a, T: Deserialize<'a>>(value: &'a serde_json::Value, pointer: &str) -> Option<T> {\n@@ -331,17 +342,15 @@ impl Config {\n \n         self.assist.allow_snippets(false);\n         if let Some(experimental) = &caps.experimental {\n-            let snippet_text_edit =\n-                experimental.get(\"snippetTextEdit\").and_then(|it| it.as_bool()) == Some(true);\n-            self.assist.allow_snippets(snippet_text_edit);\n+            let get_bool =\n+                |index: &str| experimental.get(index).and_then(|it| it.as_bool()) == Some(true);\n \n-            let code_action_group =\n-                experimental.get(\"codeActionGroup\").and_then(|it| it.as_bool()) == Some(true);\n-            self.client_caps.code_action_group = code_action_group;\n+            let snippet_text_edit = get_bool(\"snippetTextEdit\");\n+            self.assist.allow_snippets(snippet_text_edit);\n \n-            let resolve_code_action =\n-                experimental.get(\"resolveCodeAction\").and_then(|it| it.as_bool()) == Some(true);\n-            self.client_caps.resolve_code_action = resolve_code_action;\n+            self.client_caps.code_action_group = get_bool(\"codeActionGroup\");\n+            self.client_caps.resolve_code_action = get_bool(\"resolveCodeAction\");\n+            self.client_caps.hover_actions = get_bool(\"hoverActions\");\n         }\n     }\n }"}, {"sha": "1371f6cb4a416d334fd72ea310de0f412d7875d3", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -260,3 +260,35 @@ pub struct SnippetTextEdit {\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n     pub insert_text_format: Option<lsp_types::InsertTextFormat>,\n }\n+\n+pub enum HoverRequest {}\n+\n+impl Request for HoverRequest {\n+    type Params = lsp_types::HoverParams;\n+    type Result = Option<Hover>;\n+    const METHOD: &'static str = \"textDocument/hover\";\n+}\n+\n+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]\n+pub struct Hover {\n+    #[serde(flatten)]\n+    pub hover: lsp_types::Hover,\n+    #[serde(skip_serializing_if = \"Vec::is_empty\")]\n+    pub actions: Vec<CommandLinkGroup>,\n+}\n+\n+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]\n+pub struct CommandLinkGroup {\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub title: Option<String>,\n+    pub commands: Vec<CommandLink>,\n+}\n+\n+// LSP v3.15 Command does not have a `tooltip` field, vscode supports one.\n+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]\n+pub struct CommandLink {\n+    #[serde(flatten)]\n+    pub command: lsp_types::Command,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub tooltip: Option<String>,\n+}"}, {"sha": "752dbf145298add27dddd11e7f4a0802880587fe", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -510,6 +510,7 @@ fn on_request(\n         .on::<lsp_ext::InlayHints>(handlers::handle_inlay_hints)?\n         .on::<lsp_ext::CodeActionRequest>(handlers::handle_code_action)?\n         .on::<lsp_ext::ResolveCodeActionRequest>(handlers::handle_resolve_code_action)?\n+        .on::<lsp_ext::HoverRequest>(handlers::handle_hover)?\n         .on::<lsp_types::request::OnTypeFormatting>(handlers::handle_on_type_formatting)?\n         .on::<lsp_types::request::DocumentSymbolRequest>(handlers::handle_document_symbol)?\n         .on::<lsp_types::request::WorkspaceSymbol>(handlers::handle_workspace_symbol)?\n@@ -521,7 +522,6 @@ fn on_request(\n         .on::<lsp_types::request::CodeLensResolve>(handlers::handle_code_lens_resolve)?\n         .on::<lsp_types::request::FoldingRangeRequest>(handlers::handle_folding_range)?\n         .on::<lsp_types::request::SignatureHelpRequest>(handlers::handle_signature_help)?\n-        .on::<lsp_types::request::HoverRequest>(handlers::handle_hover)?\n         .on::<lsp_types::request::PrepareRenameRequest>(handlers::handle_prepare_rename)?\n         .on::<lsp_types::request::Rename>(handlers::handle_rename)?\n         .on::<lsp_types::request::References>(handlers::handle_references)?"}, {"sha": "3ff7797024cf5fab380870df1d21a2ca50375e7d", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 99, "deletions": 30, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -12,13 +12,14 @@ use lsp_types::{\n     CallHierarchyIncomingCall, CallHierarchyIncomingCallsParams, CallHierarchyItem,\n     CallHierarchyOutgoingCall, CallHierarchyOutgoingCallsParams, CallHierarchyPrepareParams,\n     CodeLens, Command, CompletionItem, Diagnostic, DocumentFormattingParams, DocumentHighlight,\n-    DocumentSymbol, FoldingRange, FoldingRangeParams, Hover, HoverContents, Location,\n-    MarkupContent, MarkupKind, Position, PrepareRenameResponse, Range, RenameParams,\n-    SemanticTokensParams, SemanticTokensRangeParams, SemanticTokensRangeResult,\n-    SemanticTokensResult, SymbolInformation, TextDocumentIdentifier, Url, WorkspaceEdit,\n+    DocumentSymbol, FoldingRange, FoldingRangeParams, HoverContents, Location, MarkupContent,\n+    MarkupKind, Position, PrepareRenameResponse, Range, RenameParams, SemanticTokensParams,\n+    SemanticTokensRangeParams, SemanticTokensRangeResult, SemanticTokensResult, SymbolInformation,\n+    TextDocumentIdentifier, Url, WorkspaceEdit,\n };\n use ra_ide::{\n-    FileId, FilePosition, FileRange, Query, RangeInfo, RunnableKind, SearchScope, TextEdit,\n+    FileId, FilePosition, FileRange, HoverAction, Query, RangeInfo, RunnableKind, SearchScope,\n+    TextEdit,\n };\n use ra_prof::profile;\n use ra_project_model::TargetKind;\n@@ -537,7 +538,7 @@ pub fn handle_signature_help(\n pub fn handle_hover(\n     snap: GlobalStateSnapshot,\n     params: lsp_types::HoverParams,\n-) -> Result<Option<Hover>> {\n+) -> Result<Option<lsp_ext::Hover>> {\n     let _p = profile(\"handle_hover\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n     let info = match snap.analysis().hover(position)? {\n@@ -546,14 +547,18 @@ pub fn handle_hover(\n     };\n     let line_index = snap.analysis.file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, info.range);\n-    let res = Hover {\n-        contents: HoverContents::Markup(MarkupContent {\n-            kind: MarkupKind::Markdown,\n-            value: crate::markdown::format_docs(&info.info.to_markup()),\n-        }),\n-        range: Some(range),\n+    let hover = lsp_ext::Hover {\n+        hover: lsp_types::Hover {\n+            contents: HoverContents::Markup(MarkupContent {\n+                kind: MarkupKind::Markdown,\n+                value: crate::markdown::format_docs(&info.info.to_markup()),\n+            }),\n+            range: Some(range),\n+        },\n+        actions: prepare_hover_actions(&snap, info.info.actions()),\n     };\n-    Ok(Some(res))\n+\n+    Ok(Some(hover))\n }\n \n pub fn handle_prepare_rename(\n@@ -924,24 +929,13 @@ pub fn handle_code_lens_resolve(\n                     _ => vec![],\n                 };\n \n-            let title = if locations.len() == 1 {\n-                \"1 implementation\".into()\n-            } else {\n-                format!(\"{} implementations\", locations.len())\n-            };\n-\n-            // We cannot use the 'editor.action.showReferences' command directly\n-            // because that command requires vscode types which we convert in the handler\n-            // on the client side.\n-            let cmd = Command {\n+            let title = implementation_title(locations.len());\n+            let cmd = show_references_command(\n                 title,\n-                command: \"rust-analyzer.showReferences\".into(),\n-                arguments: Some(vec![\n-                    to_value(&lens_params.text_document_position_params.text_document.uri).unwrap(),\n-                    to_value(code_lens.range.start).unwrap(),\n-                    to_value(locations).unwrap(),\n-                ]),\n-            };\n+                &lens_params.text_document_position_params.text_document.uri,\n+                code_lens.range.start,\n+                locations,\n+            );\n             Ok(CodeLens { range: code_lens.range, command: Some(cmd), data: None })\n         }\n         None => Ok(CodeLens {\n@@ -1145,3 +1139,78 @@ pub fn handle_semantic_tokens_range(\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }\n+\n+fn implementation_title(count: usize) -> String {\n+    if count == 1 {\n+        \"1 implementation\".into()\n+    } else {\n+        format!(\"{} implementations\", count)\n+    }\n+}\n+\n+fn show_references_command(\n+    title: String,\n+    uri: &lsp_types::Url,\n+    position: lsp_types::Position,\n+    locations: Vec<lsp_types::Location>,\n+) -> Command {\n+    // We cannot use the 'editor.action.showReferences' command directly\n+    // because that command requires vscode types which we convert in the handler\n+    // on the client side.\n+\n+    Command {\n+        title,\n+        command: \"rust-analyzer.showReferences\".into(),\n+        arguments: Some(vec![\n+            to_value(uri).unwrap(),\n+            to_value(position).unwrap(),\n+            to_value(locations).unwrap(),\n+        ]),\n+    }\n+}\n+\n+fn to_command_link(command: Command, tooltip: String) -> lsp_ext::CommandLink {\n+    lsp_ext::CommandLink { tooltip: Some(tooltip), command }\n+}\n+\n+fn show_impl_command_link(\n+    snap: &GlobalStateSnapshot,\n+    position: &FilePosition,\n+) -> Option<lsp_ext::CommandLinkGroup> {\n+    if snap.config.hover.implementations {\n+        if let Some(nav_data) = snap.analysis().goto_implementation(*position).unwrap_or(None) {\n+            let uri = to_proto::url(snap, position.file_id).ok()?;\n+            let line_index = snap.analysis().file_line_index(position.file_id).ok()?;\n+            let position = to_proto::position(&line_index, position.offset);\n+            let locations: Vec<_> = nav_data\n+                .info\n+                .iter()\n+                .filter_map(|it| to_proto::location(snap, it.file_range()).ok())\n+                .collect();\n+            let title = implementation_title(locations.len());\n+            let command = show_references_command(title, &uri, position, locations);\n+\n+            return Some(lsp_ext::CommandLinkGroup {\n+                commands: vec![to_command_link(command, \"Go to implementations\".into())],\n+                ..Default::default()\n+            });\n+        }\n+    }\n+    None\n+}\n+\n+fn prepare_hover_actions(\n+    snap: &GlobalStateSnapshot,\n+    actions: &[HoverAction],\n+) -> Vec<lsp_ext::CommandLinkGroup> {\n+    if snap.config.hover.none() || !snap.config.client_caps.hover_actions {\n+        return Vec::new();\n+    }\n+\n+    actions\n+        .iter()\n+        .filter_map(|it| match it {\n+            HoverAction::Implementaion(position) => show_impl_command_link(snap, position),\n+        })\n+        .collect()\n+}"}, {"sha": "a0847dad3a8f158a4d17b281286df12c00fb9de0", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -467,3 +467,41 @@ interface InlayHint {\n     label: string,\n }\n ```\n+\n+## Hover Actions\n+\n+**Client Capability:** `{ \"hoverActions\": boolean }`\n+\n+If this capability is set, `Hover` request returned from the server might contain an additional field, `actions`:\n+\n+```typescript\n+interface Hover {\n+    ...\n+    actions?: CommandLinkGroup[];\n+}\n+\n+interface CommandLink extends Command {\n+    /**\n+     * A tooltip for the command, when represented in the UI.\n+     */\n+    tooltip?: string;\n+}\n+\n+interface CommandLinkGroup {\n+    title?: string;\n+    commands: CommandLink[];\n+}\n+```\n+\n+Such actions on the client side are appended to a hover bottom as command links:\n+```\n+  +-----------------------------+\n+  | Hover content               |\n+  |                             |\n+  +-----------------------------+\n+  | _Action1_ | _Action2_       |  <- first group, no TITLE\n+  +-----------------------------+\n+  | TITLE _Action1_ | _Action2_ |  <- second group\n+  +-----------------------------+\n+  ...\n+```\n\\ No newline at end of file"}, {"sha": "b9c57db3bcf74485248c99de1e9b9c72b92e190b", "filename": "editors/code/package.json", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -462,17 +462,27 @@\n                     \"default\": true\n                 },\n                 \"rust-analyzer.lens.run\": {\n-                    \"markdownDescription\": \"Whether to show Run lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n+                    \"markdownDescription\": \"Whether to show `Run` lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n                     \"type\": \"boolean\",\n                     \"default\": true\n                 },\n                 \"rust-analyzer.lens.debug\": {\n-                    \"markdownDescription\": \"Whether to show Debug lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n+                    \"markdownDescription\": \"Whether to show `Debug` lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n                     \"type\": \"boolean\",\n                     \"default\": true\n                 },\n                 \"rust-analyzer.lens.implementations\": {\n-                    \"markdownDescription\": \"Whether to show Implementations lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n+                    \"markdownDescription\": \"Whether to show `Implementations` lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n+                    \"type\": \"boolean\",\n+                    \"default\": true\n+                },\n+                \"rust-analyzer.hoverActions.enable\": {\n+                    \"description\": \"Whether to show HoverActions in Rust files.\",\n+                    \"type\": \"boolean\",\n+                    \"default\": true\n+                },\n+                \"rust-analyzer.hoverActions.implementations\": {\n+                    \"markdownDescription\": \"Whether to show `Implementations` action. Only applies when `#rust-analyzer.hoverActions.enable#` is set.\",\n                     \"type\": \"boolean\",\n                     \"default\": true\n                 },"}, {"sha": "65ad573d8c919ec4e1577a72d60e2150cca94524", "filename": "editors/code/src/client.ts", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/editors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/editors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fclient.ts?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -7,6 +7,20 @@ import { CallHierarchyFeature } from 'vscode-languageclient/lib/callHierarchy.pr\n import { SemanticTokensFeature, DocumentSemanticsTokensSignature } from 'vscode-languageclient/lib/semanticTokens.proposed';\n import { assert } from './util';\n \n+function renderCommand(cmd: ra.CommandLink) {\n+    return `[${cmd.title}](command:${cmd.command}?${encodeURIComponent(JSON.stringify(cmd.arguments))} '${cmd.tooltip!}')`;\n+}\n+\n+function renderHoverActions(actions: ra.CommandLinkGroup[]): vscode.MarkdownString {\n+    const text = actions.map(group =>\n+        (group.title ? (group.title + \" \") : \"\") + group.commands.map(renderCommand).join(' | ')\n+    ).join('___');\n+\n+    const result = new vscode.MarkdownString(text);\n+    result.isTrusted = true;\n+    return result;\n+}\n+\n export function createClient(serverPath: string, cwd: string): lc.LanguageClient {\n     // '.' Is the fallback if no folder is open\n     // TODO?: Workspace folders support Uri's (eg: file://test.txt).\n@@ -35,6 +49,23 @@ export function createClient(serverPath: string, cwd: string): lc.LanguageClient\n                 if (res === undefined) throw new Error('busy');\n                 return res;\n             },\n+            async provideHover(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken, _next: lc.ProvideHoverSignature) {\n+                return client.sendRequest(lc.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(\n+                    (result) => {\n+                        const hover = client.protocol2CodeConverter.asHover(result);\n+                        if (hover) {\n+                            const actions = (<any>result).actions;\n+                            if (actions) {\n+                                hover.contents.push(renderHoverActions(actions));\n+                            }\n+                        }\n+                        return hover;\n+                    },\n+                    (error) => {\n+                        client.logFailedRequest(lc.HoverRequest.type, error);\n+                        return Promise.resolve(null);\n+                    });\n+            },\n             // Using custom handling of CodeActions where each code action is resloved lazily\n             // That's why we are not waiting for any command or edits\n             async provideCodeActions(document: vscode.TextDocument, range: vscode.Range, context: vscode.CodeActionContext, token: vscode.CancellationToken, _next: lc.ProvideCodeActionsSignature) {\n@@ -129,6 +160,7 @@ class ExperimentalFeatures implements lc.StaticFeature {\n         caps.snippetTextEdit = true;\n         caps.codeActionGroup = true;\n         caps.resolveCodeAction = true;\n+        caps.hoverActions = true;\n         capabilities.experimental = caps;\n     }\n     initialize(_capabilities: lc.ServerCapabilities<any>, _documentSelector: lc.DocumentSelector | undefined): void {"}, {"sha": "d8f0037d4c9516b27b71eb1a86443a7093ad6600", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -16,10 +16,8 @@ export class Config {\n         \"files\",\n         \"highlighting\",\n         \"updates.channel\",\n-        \"lens.enable\",\n-        \"lens.run\",\n-        \"lens.debug\",\n-        \"lens.implementations\",\n+        \"lens\", // works as lens.*\n+        \"hoverActions\", // works as hoverActions.*\n     ]\n         .map(opt => `${this.rootSection}.${opt}`);\n \n@@ -132,4 +130,11 @@ export class Config {\n             implementations: this.get<boolean>(\"lens.implementations\"),\n         };\n     }\n+\n+    get hoverActions() {\n+        return {\n+            enable: this.get<boolean>(\"hoverActions.enable\"),\n+            implementations: this.get<boolean>(\"hoverActions.implementations\"),\n+        };\n+    }\n }"}, {"sha": "e16ea799ce015bef81a14cb22785e24cd2eee351", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4029628f15c612182ad9da1c652078f9df62f5cf/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4029628f15c612182ad9da1c652078f9df62f5cf/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=4029628f15c612182ad9da1c652078f9df62f5cf", "patch": "@@ -90,3 +90,15 @@ export interface SsrParams {\n     parseOnly: boolean;\n }\n export const ssr = new lc.RequestType<SsrParams, lc.WorkspaceEdit, void>('experimental/ssr');\n+\n+export interface CommandLink extends lc.Command {\n+    /**\n+     * A tooltip for the command, when represented in the UI.\n+     */\n+    tooltip?: string;\n+}\n+\n+export interface CommandLinkGroup {\n+    title?: string;\n+    commands: CommandLink[];\n+}"}]}