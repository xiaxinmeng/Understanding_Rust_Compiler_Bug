{"sha": "bea28ea5376cba26713c4e49bc1d6fa2642ab419", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlYTI4ZWE1Mzc2Y2JhMjY3MTNjNGU0OWJjMWQ2ZmEyNjQyYWI0MTk=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-06-27T15:52:23Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-06-27T15:52:23Z"}, "message": "Easy fix for using newer LLVMs: just use the MachOObjectFile.cpp they provide.", "tree": {"sha": "eeb3ce26e75d51ae1d71651453ea44e8be792271", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeb3ce26e75d51ae1d71651453ea44e8be792271"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bea28ea5376cba26713c4e49bc1d6fa2642ab419", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bea28ea5376cba26713c4e49bc1d6fa2642ab419", "html_url": "https://github.com/rust-lang/rust/commit/bea28ea5376cba26713c4e49bc1d6fa2642ab419", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bea28ea5376cba26713c4e49bc1d6fa2642ab419/comments", "author": null, "committer": null, "parents": [{"sha": "fcbdac96dd261eb3433e8bee52db8860d6e3416a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcbdac96dd261eb3433e8bee52db8860d6e3416a", "html_url": "https://github.com/rust-lang/rust/commit/fcbdac96dd261eb3433e8bee52db8860d6e3416a"}], "stats": {"total": 332, "additions": 1, "deletions": 331}, "files": [{"sha": "876cb6766e869a877059ab0f82f543519a420559", "filename": "mk/rustllvm.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bea28ea5376cba26713c4e49bc1d6fa2642ab419/mk%2Frustllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bea28ea5376cba26713c4e49bc1d6fa2642ab419/mk%2Frustllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frustllvm.mk?ref=bea28ea5376cba26713c4e49bc1d6fa2642ab419", "patch": "@@ -3,7 +3,7 @@\n ######################################################################\n \n RUSTLLVM_LIB_CS := $(addprefix rustllvm/, \\\n-                     MachOObjectFile.cpp Passes.cpp Passes2.cpp)\n+                     Passes.cpp Passes2.cpp)\n \n RUSTLLVM_OBJS_CS := $(addprefix rustllvm/, RustWrapper.cpp)\n "}, {"sha": "4a003249191e29d07f6c830847ba928fa81b64f6", "filename": "src/rustllvm/MachOObjectFile.cpp", "status": "removed", "additions": 0, "deletions": 330, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/fcbdac96dd261eb3433e8bee52db8860d6e3416a/src%2Frustllvm%2FMachOObjectFile.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/fcbdac96dd261eb3433e8bee52db8860d6e3416a/src%2Frustllvm%2FMachOObjectFile.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FMachOObjectFile.cpp?ref=fcbdac96dd261eb3433e8bee52db8860d6e3416a", "patch": "@@ -1,330 +0,0 @@\n-//===- MachOObjectFile.cpp - Mach-O object file binding ---------*- C++ -*-===//\n-//\n-//                     The LLVM Compiler Infrastructure\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file defines the MachOObjectFile class, which binds the MachOObject\n-// class to the generic ObjectFile wrapper.\n-//\n-//===----------------------------------------------------------------------===//\n-\n-#include \"llvm/ADT/Triple.h\"\n-#include \"llvm/Object/MachOFormat.h\"\n-#include \"llvm/Object/MachOObject.h\"\n-#include \"llvm/Object/ObjectFile.h\"\n-#include \"llvm/Support/MemoryBuffer.h\"\n-\n-#include <cctype>\n-#include <cstring>\n-#include <limits>\n-\n-using namespace llvm;\n-using namespace object;\n-\n-namespace llvm {\n-\n-typedef MachOObject::LoadCommandInfo LoadCommandInfo;\n-\n-class MachOObjectFile : public ObjectFile {\n-public:\n-  MachOObjectFile(MemoryBuffer *Object, MachOObject *MOO)\n-    : ObjectFile(Object),\n-      MachOObj(MOO),\n-      RegisteredStringTable(std::numeric_limits<uint32_t>::max()) {}\n-\n-  virtual symbol_iterator begin_symbols() const;\n-  virtual symbol_iterator end_symbols() const;\n-  virtual section_iterator begin_sections() const;\n-  virtual section_iterator end_sections() const;\n-\n-  virtual uint8_t getBytesInAddress() const;\n-  virtual StringRef getFileFormatName() const;\n-  virtual unsigned getArch() const;\n-\n-protected:\n-  virtual SymbolRef getSymbolNext(DataRefImpl Symb) const;\n-  virtual StringRef getSymbolName(DataRefImpl Symb) const;\n-  virtual uint64_t  getSymbolAddress(DataRefImpl Symb) const;\n-  virtual uint64_t  getSymbolSize(DataRefImpl Symb) const;\n-  virtual char      getSymbolNMTypeChar(DataRefImpl Symb) const;\n-  virtual bool      isSymbolInternal(DataRefImpl Symb) const;\n-\n-  virtual SectionRef getSectionNext(DataRefImpl Sec) const;\n-  virtual StringRef  getSectionName(DataRefImpl Sec) const;\n-  virtual uint64_t   getSectionAddress(DataRefImpl Sec) const;\n-  virtual uint64_t   getSectionSize(DataRefImpl Sec) const;\n-  virtual StringRef  getSectionContents(DataRefImpl Sec) const;\n-  virtual bool       isSectionText(DataRefImpl Sec) const;\n-\n-private:\n-  MachOObject *MachOObj;\n-  mutable uint32_t RegisteredStringTable;\n-\n-  void moveToNextSection(DataRefImpl &DRI) const;\n-  void getSymbolTableEntry(DataRefImpl DRI,\n-                           InMemoryStruct<macho::SymbolTableEntry> &Res) const;\n-  void moveToNextSymbol(DataRefImpl &DRI) const;\n-  void getSection(DataRefImpl DRI, InMemoryStruct<macho::Section> &Res) const;\n-};\n-\n-ObjectFile *ObjectFile::createMachOObjectFile(MemoryBuffer *Buffer) {\n-  std::string Err;\n-  MachOObject *MachOObj = MachOObject::LoadFromBuffer(Buffer, &Err);\n-  if (!MachOObj)\n-    return NULL;\n-  return new MachOObjectFile(Buffer, MachOObj);\n-}\n-\n-/*===-- Symbols -----------------------------------------------------------===*/\n-\n-void MachOObjectFile::moveToNextSymbol(DataRefImpl &DRI) const {\n-  uint32_t LoadCommandCount = MachOObj->getHeader().NumLoadCommands;\n-  while (DRI.d.a < LoadCommandCount) {\n-    LoadCommandInfo LCI = MachOObj->getLoadCommandInfo(DRI.d.a);\n-    if (LCI.Command.Type == macho::LCT_Symtab) {\n-      InMemoryStruct<macho::SymtabLoadCommand> SymtabLoadCmd;\n-      MachOObj->ReadSymtabLoadCommand(LCI, SymtabLoadCmd);\n-      if (DRI.d.b < SymtabLoadCmd->NumSymbolTableEntries)\n-        return;\n-    }\n-\n-    DRI.d.a++;\n-    DRI.d.b = 0;\n-  }\n-}\n-\n-void MachOObjectFile::getSymbolTableEntry(DataRefImpl DRI,\n-    InMemoryStruct<macho::SymbolTableEntry> &Res) const {\n-  InMemoryStruct<macho::SymtabLoadCommand> SymtabLoadCmd;\n-  LoadCommandInfo LCI = MachOObj->getLoadCommandInfo(DRI.d.a);\n-  MachOObj->ReadSymtabLoadCommand(LCI, SymtabLoadCmd);\n-\n-  if (RegisteredStringTable != DRI.d.a) {\n-    MachOObj->RegisterStringTable(*SymtabLoadCmd);\n-    RegisteredStringTable = DRI.d.a;\n-  }\n-\n-  MachOObj->ReadSymbolTableEntry(SymtabLoadCmd->SymbolTableOffset, DRI.d.b,\n-                                 Res);\n-}\n-\n-\n-SymbolRef MachOObjectFile::getSymbolNext(DataRefImpl DRI) const {\n-  DRI.d.b++;\n-  moveToNextSymbol(DRI);\n-  return SymbolRef(DRI, this);\n-}\n-\n-StringRef MachOObjectFile::getSymbolName(DataRefImpl DRI) const {\n-  InMemoryStruct<macho::SymbolTableEntry> Entry;\n-  getSymbolTableEntry(DRI, Entry);\n-  return MachOObj->getStringAtIndex(Entry->StringIndex);\n-}\n-\n-uint64_t MachOObjectFile::getSymbolAddress(DataRefImpl DRI) const {\n-  InMemoryStruct<macho::SymbolTableEntry> Entry;\n-  getSymbolTableEntry(DRI, Entry);\n-  return Entry->Value;\n-}\n-\n-uint64_t MachOObjectFile::getSymbolSize(DataRefImpl DRI) const {\n-  return UnknownAddressOrSize;\n-}\n-\n-char MachOObjectFile::getSymbolNMTypeChar(DataRefImpl DRI) const {\n-  InMemoryStruct<macho::SymbolTableEntry> Entry;\n-  getSymbolTableEntry(DRI, Entry);\n-\n-  char Char;\n-  switch (Entry->Type & macho::STF_TypeMask) {\n-    case macho::STT_Undefined:\n-      Char = 'u';\n-      break;\n-    case macho::STT_Absolute:\n-    case macho::STT_Section:\n-      Char = 's';\n-      break;\n-    default:\n-      Char = '?';\n-      break;\n-  }\n-\n-  if (Entry->Flags & (macho::STF_External | macho::STF_PrivateExtern))\n-    Char = toupper(Char);\n-  return Char;\n-}\n-\n-bool MachOObjectFile::isSymbolInternal(DataRefImpl DRI) const {\n-  InMemoryStruct<macho::SymbolTableEntry> Entry;\n-  getSymbolTableEntry(DRI, Entry);\n-  return Entry->Flags & macho::STF_StabsEntryMask;\n-}\n-\n-ObjectFile::symbol_iterator MachOObjectFile::begin_symbols() const {\n-  // DRI.d.a = segment number; DRI.d.b = symbol index.\n-  DataRefImpl DRI;\n-  DRI.d.a = DRI.d.b = 0;\n-  moveToNextSymbol(DRI);\n-  return symbol_iterator(SymbolRef(DRI, this));\n-}\n-\n-ObjectFile::symbol_iterator MachOObjectFile::end_symbols() const {\n-  DataRefImpl DRI;\n-  DRI.d.a = MachOObj->getHeader().NumLoadCommands;\n-  DRI.d.b = 0;\n-  return symbol_iterator(SymbolRef(DRI, this));\n-}\n-\n-\n-/*===-- Sections ----------------------------------------------------------===*/\n-\n-void MachOObjectFile::moveToNextSection(DataRefImpl &DRI) const {\n-  uint32_t LoadCommandCount = MachOObj->getHeader().NumLoadCommands;\n-  while (DRI.d.a < LoadCommandCount) {\n-    LoadCommandInfo LCI = MachOObj->getLoadCommandInfo(DRI.d.a);\n-    if (LCI.Command.Type == macho::LCT_Segment) {\n-      InMemoryStruct<macho::SegmentLoadCommand> SegmentLoadCmd;\n-      MachOObj->ReadSegmentLoadCommand(LCI, SegmentLoadCmd);\n-      if (DRI.d.b < SegmentLoadCmd->NumSections)\n-        return;\n-    } else if (LCI.Command.Type == macho::LCT_Segment64) {\n-      InMemoryStruct<macho::Segment64LoadCommand> Segment64LoadCmd;\n-      MachOObj->ReadSegment64LoadCommand(LCI, Segment64LoadCmd);\n-      if (DRI.d.b < Segment64LoadCmd->NumSections)\n-        return;\n-    }\n-\n-    DRI.d.a++;\n-    DRI.d.b = 0;\n-  }\n-}\n-\n-SectionRef MachOObjectFile::getSectionNext(DataRefImpl DRI) const {\n-  DRI.d.b++;\n-  moveToNextSection(DRI);\n-  return SectionRef(DRI, this);\n-}\n-\n-void\n-MachOObjectFile::getSection(DataRefImpl DRI,\n-                            InMemoryStruct<macho::Section> &Res) const {\n-  InMemoryStruct<macho::SegmentLoadCommand> SLC;\n-  LoadCommandInfo LCI = MachOObj->getLoadCommandInfo(DRI.d.a);\n-  MachOObj->ReadSegmentLoadCommand(LCI, SLC);\n-  MachOObj->ReadSection(LCI, DRI.d.b, Res);\n-}\n-\n-StringRef MachOObjectFile::getSectionName(DataRefImpl DRI) const {\n-  InMemoryStruct<macho::SegmentLoadCommand> SLC;\n-  LoadCommandInfo LCI = MachOObj->getLoadCommandInfo(DRI.d.a);\n-  MachOObj->ReadSegmentLoadCommand(LCI, SLC);\n-  InMemoryStruct<macho::Section> Sect;\n-  MachOObj->ReadSection(LCI, DRI.d.b, Sect);\n-\n-  static char Result[34];\n-  strcpy(Result, SLC->Name);\n-  strcat(Result, \",\");\n-  strcat(Result, Sect->Name);\n-  return StringRef(Result);\n-}\n-\n-uint64_t MachOObjectFile::getSectionAddress(DataRefImpl DRI) const {\n-  InMemoryStruct<macho::Section> Sect;\n-  getSection(DRI, Sect);\n-  return Sect->Address;\n-}\n-\n-uint64_t MachOObjectFile::getSectionSize(DataRefImpl DRI) const {\n-  InMemoryStruct<macho::Section> Sect;\n-  getSection(DRI, Sect);\n-  return Sect->Size;\n-}\n-\n-StringRef MachOObjectFile::getSectionContents(DataRefImpl DRI) const {\n-  InMemoryStruct<macho::Section> Sect;\n-  getSection(DRI, Sect);\n-  return MachOObj->getData(Sect->Offset, Sect->Size);\n-}\n-\n-bool MachOObjectFile::isSectionText(DataRefImpl DRI) const {\n-  InMemoryStruct<macho::SegmentLoadCommand> SLC;\n-  LoadCommandInfo LCI = MachOObj->getLoadCommandInfo(DRI.d.a);\n-  MachOObj->ReadSegmentLoadCommand(LCI, SLC);\n-  return !strcmp(SLC->Name, \"__TEXT\");\n-}\n-\n-ObjectFile::section_iterator MachOObjectFile::begin_sections() const {\n-  DataRefImpl DRI;\n-  DRI.d.a = DRI.d.b = 0;\n-  moveToNextSection(DRI);\n-  return section_iterator(SectionRef(DRI, this));\n-}\n-\n-ObjectFile::section_iterator MachOObjectFile::end_sections() const {\n-  DataRefImpl DRI;\n-  DRI.d.a = MachOObj->getHeader().NumLoadCommands;\n-  DRI.d.b = 0;\n-  return section_iterator(SectionRef(DRI, this));\n-}\n-\n-/*===-- Miscellaneous -----------------------------------------------------===*/\n-\n-uint8_t MachOObjectFile::getBytesInAddress() const {\n-  return MachOObj->is64Bit() ? 8 : 4;\n-}\n-\n-StringRef MachOObjectFile::getFileFormatName() const {\n-  if (!MachOObj->is64Bit()) {\n-    switch (MachOObj->getHeader().CPUType) {\n-    case 0x00000007:\n-      return \"MACHO32-i386\";\n-    case 0x01000007:\n-      return \"MACHO32-x86-64\";\n-    case 0x0000000c:\n-      return \"MACHO32-arm\";\n-    case 0x00000012:\n-      return \"MACHO32-ppc\";\n-    case 0x01000012:\n-      return \"MACHO32-ppc64\";\n-    }\n-  }\n-\n-  switch (MachOObj->getHeader().CPUType) {\n-  case 0x00000007:\n-    return \"MACHO64-i386\";\n-  case 0x01000007:\n-    return \"MACHO64-x86-64\";\n-  case 0x0000000c:\n-    return \"MACHO64-arm\";\n-  case 0x00000012:\n-    return \"MACHO64-ppc\";\n-  case 0x01000012:\n-    return \"MACHO64-ppc64\";\n-  default:\n-    return \"MACHO64-unknown\";\n-  }\n-}\n-\n-unsigned MachOObjectFile::getArch() const {\n-  switch (MachOObj->getHeader().CPUType) {\n-  case 0x00000007:\n-    return Triple::x86;\n-  case 0x01000007:\n-    return Triple::x86_64;\n-  case 0x0000000c:\n-    return Triple::arm;\n-  case 0x00000012:\n-    return Triple::ppc;\n-  case 0x01000012:\n-    return Triple::ppc64;\n-  default:\n-    return Triple::UnknownArch;\n-  }\n-}\n-\n-} // end namespace llvm\n-"}]}