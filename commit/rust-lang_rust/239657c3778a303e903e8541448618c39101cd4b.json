{"sha": "239657c3778a303e903e8541448618c39101cd4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzOTY1N2MzNzc4YTMwM2U5MDNlODU0MTQ0ODYxOGMzOTEwMWNkNGI=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-22T16:56:49Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-22T16:56:49Z"}, "message": "Rollup merge of #27155 - steveklabnik:doc_std_io_buf_writer, r=alexcrichton\n\nMostly through adding examples.\r\n\r\nr? @alexcrichton \r\n\r\nI'm going to be doing a bunch of these today, but I figured I'd keep it one PR per struct, since the last 'all the things in one PR' ended up taking a week to actually land.", "tree": {"sha": "4c466f27b017cafbb6e991589025254816749722", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c466f27b017cafbb6e991589025254816749722"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/239657c3778a303e903e8541448618c39101cd4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/239657c3778a303e903e8541448618c39101cd4b", "html_url": "https://github.com/rust-lang/rust/commit/239657c3778a303e903e8541448618c39101cd4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/239657c3778a303e903e8541448618c39101cd4b/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2375ef532723b1fb3865c4ee9b434c4ea812c1bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2375ef532723b1fb3865c4ee9b434c4ea812c1bc", "html_url": "https://github.com/rust-lang/rust/commit/2375ef532723b1fb3865c4ee9b434c4ea812c1bc"}, {"sha": "e22c6f7caa61f3bb47df694944a3515e725dea9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e22c6f7caa61f3bb47df694944a3515e725dea9e", "html_url": "https://github.com/rust-lang/rust/commit/e22c6f7caa61f3bb47df694944a3515e725dea9e"}], "stats": {"total": 102, "additions": 97, "deletions": 5}, "files": [{"sha": "780b4f86c0e82b10250375b9c66e62038e21969f", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 97, "deletions": 5, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/239657c3778a303e903e8541448618c39101cd4b/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/239657c3778a303e903e8541448618c39101cd4b/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=239657c3778a303e903e8541448618c39101cd4b", "patch": "@@ -252,14 +252,49 @@ impl<R: Seek> Seek for BufReader<R> {\n     }\n }\n \n-/// Wraps a Writer and buffers output to it.\n+/// Wraps a writer and buffers its output.\n ///\n-/// It can be excessively inefficient to work directly with a `Write`. For\n-/// example, every call to `write` on `TcpStream` results in a system call. A\n-/// `BufWriter` keeps an in memory buffer of data and writes it to the\n-/// underlying `Write` in large, infrequent batches.\n+/// It can be excessively inefficient to work directly with something that\n+/// implements `Write`. For example, every call to `write` on `TcpStream`\n+/// results in a system call. A `BufWriter` keeps an in-memory buffer of data\n+/// and writes it to an underlying writer in large, infrequent batches.\n ///\n /// The buffer will be written out when the writer is dropped.\n+///\n+/// # Examples\n+///\n+/// Let's write the numbers one through ten to a `TcpStream`:\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::net::TcpStream;\n+///\n+/// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n+///\n+/// for i in 1..10 {\n+///     stream.write(&[i]).unwrap();\n+/// }\n+/// ```\n+///\n+/// Because we're not buffering, we write each one in turn, incurring the\n+/// overhead of a system call per byte written. We can fix this with a\n+/// `BufWriter`:\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::io::BufWriter;\n+/// use std::net::TcpStream;\n+///\n+/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+///\n+/// for i in 1..10 {\n+///     stream.write(&[i]).unwrap();\n+/// }\n+/// ```\n+///\n+/// By wrapping the stream with a `BufWriter`, these ten writes are all grouped\n+/// together by the buffer, and will all be written out in one system call when\n+/// the `stream` is dropped.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufWriter<W: Write> {\n     inner: Option<W>,\n@@ -275,12 +310,33 @@ pub struct IntoInnerError<W>(W, Error);\n \n impl<W: Write> BufWriter<W> {\n     /// Creates a new `BufWriter` with a default buffer capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: W) -> BufWriter<W> {\n         BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n     }\n \n     /// Creates a new `BufWriter` with the specified buffer capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Creating a buffer with a buffer of a hundred bytes.\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n+    /// let mut buffer = BufWriter::with_capacity(100, stream);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(cap: usize, inner: W) -> BufWriter<W> {\n         BufWriter {\n@@ -313,6 +369,18 @@ impl<W: Write> BufWriter<W> {\n     }\n \n     /// Gets a reference to the underlying writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // we can use reference just like buffer\n+    /// let reference = buffer.get_ref();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }\n \n@@ -321,12 +389,36 @@ impl<W: Write> BufWriter<W> {\n     /// # Warning\n     ///\n     /// It is inadvisable to directly write to the underlying writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // we can use reference just like buffer\n+    /// let reference = buffer.get_mut();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }\n \n     /// Unwraps this `BufWriter`, returning the underlying writer.\n     ///\n     /// The buffer is written out before returning the writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // unwrap the TcpStream and flush the buffer\n+    /// let stream = buffer.into_inner().unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n         match self.flush_buf() {"}]}