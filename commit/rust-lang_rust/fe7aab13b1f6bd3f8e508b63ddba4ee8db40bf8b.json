{"sha": "fe7aab13b1f6bd3f8e508b63ddba4ee8db40bf8b", "node_id": "C_kwDOAAsO6NoAKGZlN2FhYjEzYjFmNmJkM2Y4ZTUwOGI2M2RkYmE0ZWU4ZGI0MGJmOGI", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-20T15:46:43Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-11-12T20:02:33Z"}, "message": "linker: Move some inner functions to the outside\n\nInline `fn unlib`", "tree": {"sha": "beb2ba8102715580ec990297474b2f1801e253de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/beb2ba8102715580ec990297474b2f1801e253de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe7aab13b1f6bd3f8e508b63ddba4ee8db40bf8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe7aab13b1f6bd3f8e508b63ddba4ee8db40bf8b", "html_url": "https://github.com/rust-lang/rust/commit/fe7aab13b1f6bd3f8e508b63ddba4ee8db40bf8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe7aab13b1f6bd3f8e508b63ddba4ee8db40bf8b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e792de28c8f753b43d2af5fce662eddef1517aa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e792de28c8f753b43d2af5fce662eddef1517aa4", "html_url": "https://github.com/rust-lang/rust/commit/e792de28c8f753b43d2af5fce662eddef1517aa4"}], "stats": {"total": 260, "additions": 127, "deletions": 133}, "files": [{"sha": "071c221a188e1f2129f0f24da703078b8bcd4d8b", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 127, "deletions": 133, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/fe7aab13b1f6bd3f8e508b63ddba4ee8db40bf8b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7aab13b1f6bd3f8e508b63ddba4ee8db40bf8b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=fe7aab13b1f6bd3f8e508b63ddba4ee8db40bf8b", "patch": "@@ -24,7 +24,7 @@ use rustc_span::symbol::Symbol;\n use rustc_span::DebuggerVisualizerFile;\n use rustc_target::spec::crt_objects::{CrtObjects, LinkSelfContainedDefault};\n use rustc_target::spec::{Cc, LinkOutputKind, LinkerFlavor, LinkerFlavorCli, Lld, PanicStrategy};\n-use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo, Target};\n+use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo};\n \n use super::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use super::command::Command;\n@@ -2512,138 +2512,6 @@ fn add_upstream_rust_crates<'a>(\n             link_dynamic,\n         );\n     }\n-\n-    // Converts a library file-stem into a cc -l argument\n-    fn unlib<'a>(target: &Target, stem: &'a str) -> &'a str {\n-        if stem.starts_with(\"lib\") && !target.is_like_windows { &stem[3..] } else { stem }\n-    }\n-\n-    // Adds the static \"rlib\" versions of all crates to the command line.\n-    // There's a bit of magic which happens here specifically related to LTO,\n-    // namely that we remove upstream object files.\n-    //\n-    // When performing LTO, almost(*) all of the bytecode from the upstream\n-    // libraries has already been included in our object file output. As a\n-    // result we need to remove the object files in the upstream libraries so\n-    // the linker doesn't try to include them twice (or whine about duplicate\n-    // symbols). We must continue to include the rest of the rlib, however, as\n-    // it may contain static native libraries which must be linked in.\n-    //\n-    // (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n-    // their bytecode wasn't included. The object files in those libraries must\n-    // still be passed to the linker.\n-    //\n-    // Note, however, that if we're not doing LTO we can just pass the rlib\n-    // blindly to the linker (fast) because it's fine if it's not actually\n-    // included as we're at the end of the dependency chain.\n-    fn add_static_crate<'a>(\n-        cmd: &mut dyn Linker,\n-        sess: &'a Session,\n-        archive_builder_builder: &dyn ArchiveBuilderBuilder,\n-        codegen_results: &CodegenResults,\n-        tmpdir: &Path,\n-        cnum: CrateNum,\n-        bundled_lib_file_names: &FxHashSet<Symbol>,\n-    ) {\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        let cratepath = &src.rlib.as_ref().unwrap().0;\n-\n-        let mut link_upstream = |path: &Path| {\n-            cmd.link_rlib(&fix_windows_verbatim_for_gcc(path));\n-        };\n-\n-        // See the comment above in `link_staticlib` and `link_rlib` for why if\n-        // there's a static library that's not relevant we skip all object\n-        // files.\n-        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n-        let skip_native = native_libs.iter().any(|lib| {\n-            matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n-                && !relevant_lib(sess, lib)\n-        });\n-\n-        if (!are_upstream_rust_objects_already_included(sess)\n-            || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n-            && !skip_native\n-        {\n-            link_upstream(cratepath);\n-            return;\n-        }\n-\n-        let dst = tmpdir.join(cratepath.file_name().unwrap());\n-        let name = cratepath.file_name().unwrap().to_str().unwrap();\n-        let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n-        let bundled_lib_file_names = bundled_lib_file_names.clone();\n-\n-        sess.prof.generic_activity_with_arg(\"link_altering_rlib\", name).run(|| {\n-            let canonical_name = name.replace('-', \"_\");\n-            let upstream_rust_objects_already_included =\n-                are_upstream_rust_objects_already_included(sess);\n-            let is_builtins = sess.target.no_builtins\n-                || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n-\n-            let mut archive = archive_builder_builder.new_archive_builder(sess);\n-            if let Err(error) = archive.add_archive(\n-                cratepath,\n-                Box::new(move |f| {\n-                    if f == METADATA_FILENAME {\n-                        return true;\n-                    }\n-\n-                    let canonical = f.replace('-', \"_\");\n-\n-                    let is_rust_object =\n-                        canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n-\n-                    // If we've been requested to skip all native object files\n-                    // (those not generated by the rust compiler) then we can skip\n-                    // this file. See above for why we may want to do this.\n-                    let skip_because_cfg_say_so = skip_native && !is_rust_object;\n-\n-                    // If we're performing LTO and this is a rust-generated object\n-                    // file, then we don't need the object file as it's part of the\n-                    // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n-                    // though, so we let that object file slide.\n-                    let skip_because_lto =\n-                        upstream_rust_objects_already_included && is_rust_object && is_builtins;\n-\n-                    // We skip native libraries because:\n-                    // 1. This native libraries won't be used from the generated rlib,\n-                    //    so we can throw them away to avoid the copying work.\n-                    // 2. We can't allow it to be a single remaining entry in archive\n-                    //    as some linkers may complain on that.\n-                    if bundled_lib_file_names.contains(&Symbol::intern(f)) {\n-                        return true;\n-                    }\n-\n-                    if skip_because_cfg_say_so || skip_because_lto {\n-                        return true;\n-                    }\n-\n-                    false\n-                }),\n-            ) {\n-                sess.emit_fatal(errors::RlibArchiveBuildFailure { error });\n-            }\n-            if archive.build(&dst) {\n-                link_upstream(&dst);\n-            }\n-        });\n-    }\n-\n-    // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n-        // Just need to tell the linker about where the library lives and\n-        // what its name is\n-        let parent = cratepath.parent();\n-        if let Some(dir) = parent {\n-            cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n-        }\n-        let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n-        cmd.link_rust_dylib(\n-            &unlib(&sess.target, filestem),\n-            parent.unwrap_or_else(|| Path::new(\"\")),\n-        );\n-    }\n }\n \n fn add_upstream_native_libraries(\n@@ -2684,6 +2552,132 @@ fn add_upstream_native_libraries(\n     }\n }\n \n+// Adds the static \"rlib\" versions of all crates to the command line.\n+// There's a bit of magic which happens here specifically related to LTO,\n+// namely that we remove upstream object files.\n+//\n+// When performing LTO, almost(*) all of the bytecode from the upstream\n+// libraries has already been included in our object file output. As a\n+// result we need to remove the object files in the upstream libraries so\n+// the linker doesn't try to include them twice (or whine about duplicate\n+// symbols). We must continue to include the rest of the rlib, however, as\n+// it may contain static native libraries which must be linked in.\n+//\n+// (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n+// their bytecode wasn't included. The object files in those libraries must\n+// still be passed to the linker.\n+//\n+// Note, however, that if we're not doing LTO we can just pass the rlib\n+// blindly to the linker (fast) because it's fine if it's not actually\n+// included as we're at the end of the dependency chain.\n+fn add_static_crate<'a>(\n+    cmd: &mut dyn Linker,\n+    sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+    cnum: CrateNum,\n+    bundled_lib_file_names: &FxHashSet<Symbol>,\n+) {\n+    let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+    let cratepath = &src.rlib.as_ref().unwrap().0;\n+\n+    let mut link_upstream = |path: &Path| {\n+        cmd.link_rlib(&fix_windows_verbatim_for_gcc(path));\n+    };\n+\n+    // See the comment above in `link_staticlib` and `link_rlib` for why if\n+    // there's a static library that's not relevant we skip all object\n+    // files.\n+    let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n+    let skip_native = native_libs.iter().any(|lib| {\n+        matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n+            && !relevant_lib(sess, lib)\n+    });\n+\n+    if (!are_upstream_rust_objects_already_included(sess)\n+        || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n+        && !skip_native\n+    {\n+        link_upstream(cratepath);\n+        return;\n+    }\n+\n+    let dst = tmpdir.join(cratepath.file_name().unwrap());\n+    let name = cratepath.file_name().unwrap().to_str().unwrap();\n+    let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n+    let bundled_lib_file_names = bundled_lib_file_names.clone();\n+\n+    sess.prof.generic_activity_with_arg(\"link_altering_rlib\", name).run(|| {\n+        let canonical_name = name.replace('-', \"_\");\n+        let upstream_rust_objects_already_included =\n+            are_upstream_rust_objects_already_included(sess);\n+        let is_builtins =\n+            sess.target.no_builtins || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n+\n+        let mut archive = archive_builder_builder.new_archive_builder(sess);\n+        if let Err(e) = archive.add_archive(\n+            cratepath,\n+            Box::new(move |f| {\n+                if f == METADATA_FILENAME {\n+                    return true;\n+                }\n+\n+                let canonical = f.replace('-', \"_\");\n+\n+                let is_rust_object =\n+                    canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n+\n+                // If we've been requested to skip all native object files\n+                // (those not generated by the rust compiler) then we can skip\n+                // this file. See above for why we may want to do this.\n+                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n+\n+                // If we're performing LTO and this is a rust-generated object\n+                // file, then we don't need the object file as it's part of the\n+                // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n+                // though, so we let that object file slide.\n+                let skip_because_lto =\n+                    upstream_rust_objects_already_included && is_rust_object && is_builtins;\n+\n+                // We skip native libraries because:\n+                // 1. This native libraries won't be used from the generated rlib,\n+                //    so we can throw them away to avoid the copying work.\n+                // 2. We can't allow it to be a single remaining entry in archive\n+                //    as some linkers may complain on that.\n+                if bundled_lib_file_names.contains(&Symbol::intern(f)) {\n+                    return true;\n+                }\n+\n+                if skip_because_cfg_say_so || skip_because_lto {\n+                    return true;\n+                }\n+\n+                false\n+            }),\n+        ) {\n+            sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n+        }\n+        if archive.build(&dst) {\n+            link_upstream(&dst);\n+        }\n+    });\n+}\n+\n+// Same thing as above, but for dynamic crates instead of static crates.\n+fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n+    // Just need to tell the linker about where the library lives and\n+    // what its name is\n+    let parent = cratepath.parent();\n+    if let Some(dir) = parent {\n+        cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n+    }\n+    let stem = cratepath.file_stem().unwrap().to_str().unwrap();\n+    // Convert library file-stem into a cc -l argument.\n+    let prefix = if stem.starts_with(\"lib\") && !sess.target.is_like_windows { 3 } else { 0 };\n+    cmd.link_rust_dylib(&stem[prefix..], parent.unwrap_or_else(|| Path::new(\"\")));\n+}\n+\n fn relevant_lib(sess: &Session, lib: &NativeLib) -> bool {\n     match lib.cfg {\n         Some(ref cfg) => rustc_attr::cfg_matches(cfg, &sess.parse_sess, CRATE_NODE_ID, None),"}]}