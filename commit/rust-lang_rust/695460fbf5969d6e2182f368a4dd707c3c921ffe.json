{"sha": "695460fbf5969d6e2182f368a4dd707c3c921ffe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NTQ2MGZiZjU5NjlkNmUyMTgyZjM2OGE0ZGQ3MDdjM2M5MjFmZmU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-27T13:00:51Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-27T13:14:24Z"}, "message": "More cleanup", "tree": {"sha": "5db616f8956e0fcfdfe442efffaf201780677160", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5db616f8956e0fcfdfe442efffaf201780677160"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/695460fbf5969d6e2182f368a4dd707c3c921ffe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/695460fbf5969d6e2182f368a4dd707c3c921ffe", "html_url": "https://github.com/rust-lang/rust/commit/695460fbf5969d6e2182f368a4dd707c3c921ffe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/695460fbf5969d6e2182f368a4dd707c3c921ffe/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e0cc8b62a760b0a333ed500df27625fcbc9cecd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e0cc8b62a760b0a333ed500df27625fcbc9cecd", "html_url": "https://github.com/rust-lang/rust/commit/2e0cc8b62a760b0a333ed500df27625fcbc9cecd"}], "stats": {"total": 222, "additions": 108, "deletions": 114}, "files": [{"sha": "d31c09abbc6c69124bbe28e1c25d1d9f96f1f43c", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 108, "deletions": 114, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/695460fbf5969d6e2182f368a4dd707c3c921ffe/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695460fbf5969d6e2182f368a4dd707c3c921ffe/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=695460fbf5969d6e2182f368a4dd707c3c921ffe", "patch": "@@ -1,4 +1,4 @@\n-//! FIXME: write short doc here\n+//! Implements syntax highlighting.\n \n mod tags;\n mod html;\n@@ -10,16 +10,14 @@ use ra_ide_db::{\n };\n use ra_prof::profile;\n use ra_syntax::{\n-    ast, AstNode, Direction, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxKind::*, SyntaxToken,\n-    TextRange, WalkEvent, T,\n+    ast, AstNode, Direction, NodeOrToken, SyntaxElement, SyntaxKind::*, TextRange, WalkEvent, T,\n };\n use rustc_hash::FxHashMap;\n \n use crate::{references::classify_name_ref, FileId};\n \n-pub use tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n-\n pub(crate) use html::highlight_as_html;\n+pub use tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n \n #[derive(Debug)]\n pub struct HighlightedRange {\n@@ -28,21 +26,6 @@ pub struct HighlightedRange {\n     pub binding_hash: Option<u64>,\n }\n \n-fn is_control_keyword(kind: SyntaxKind) -> bool {\n-    match kind {\n-        T![for]\n-        | T![loop]\n-        | T![while]\n-        | T![continue]\n-        | T![break]\n-        | T![if]\n-        | T![else]\n-        | T![match]\n-        | T![return] => true,\n-        _ => false,\n-    }\n-}\n-\n pub(crate) fn highlight(\n     db: &RootDatabase,\n     file_id: FileId,\n@@ -71,20 +54,24 @@ pub(crate) fn highlight(\n \n     let mut current_macro_call: Option<ast::MacroCall> = None;\n \n+    // Walk all nodes, keeping track of whether we are inside a macro or not.\n+    // If in macro, expand it first and highlight the expanded code.\n     for event in root.preorder_with_tokens() {\n         let event_range = match &event {\n             WalkEvent::Enter(it) => it.text_range(),\n             WalkEvent::Leave(it) => it.text_range(),\n         };\n \n-        if event_range.intersection(&range_to_highlight).is_none() {\n+        // Element outside of the viewport, no need to highlight\n+        if range_to_highlight.intersection(&event_range).is_none() {\n             continue;\n         }\n \n+        // Track \"inside macro\" state\n         match event.clone().map(|it| it.into_node().and_then(ast::MacroCall::cast)) {\n             WalkEvent::Enter(Some(mc)) => {\n                 current_macro_call = Some(mc.clone());\n-                if let Some(range) = highlight_macro(&mc) {\n+                if let Some(range) = macro_call_range(&mc) {\n                     res.push(HighlightedRange {\n                         range,\n                         highlight: HighlightTag::Macro.into(),\n@@ -101,37 +88,40 @@ pub(crate) fn highlight(\n             _ => (),\n         }\n \n-        let node = match event {\n+        let element = match event {\n             WalkEvent::Enter(it) => it,\n             WalkEvent::Leave(_) => continue,\n         };\n+        let range = element.text_range();\n \n-        if current_macro_call.is_some() {\n-            if let Some(token) = node.into_token() {\n-                if let Some((highlight, binding_hash)) =\n-                    highlight_token_tree(&sema, &mut bindings_shadow_count, token.clone())\n-                {\n-                    res.push(HighlightedRange {\n-                        range: token.text_range(),\n-                        highlight,\n-                        binding_hash,\n-                    });\n-                }\n+        let element_to_highlight = if current_macro_call.is_some() {\n+            // Inside a macro -- expand it first\n+            let token = match element.into_token() {\n+                Some(it) if it.parent().kind() == TOKEN_TREE => it,\n+                _ => continue,\n+            };\n+            let token = sema.descend_into_macros(token.clone());\n+            let parent = token.parent();\n+            // We only care Name and Name_ref\n+            match (token.kind(), parent.kind()) {\n+                (IDENT, NAME) | (IDENT, NAME_REF) => parent.into(),\n+                _ => token.into(),\n             }\n-            continue;\n-        }\n+        } else {\n+            element\n+        };\n \n         if let Some((highlight, binding_hash)) =\n-            highlight_node(&sema, &mut bindings_shadow_count, node.clone())\n+            highlight_element(&sema, &mut bindings_shadow_count, element_to_highlight)\n         {\n-            res.push(HighlightedRange { range: node.text_range(), highlight, binding_hash });\n+            res.push(HighlightedRange { range, highlight, binding_hash });\n         }\n     }\n \n     res\n }\n \n-fn highlight_macro(macro_call: &ast::MacroCall) -> Option<TextRange> {\n+fn macro_call_range(macro_call: &ast::MacroCall) -> Option<TextRange> {\n     let path = macro_call.path()?;\n     let name_ref = path.segment()?.name_ref()?;\n \n@@ -147,67 +137,22 @@ fn highlight_macro(macro_call: &ast::MacroCall) -> Option<TextRange> {\n     Some(TextRange::from_to(range_start, range_end))\n }\n \n-fn highlight_token_tree(\n-    sema: &Semantics<RootDatabase>,\n-    bindings_shadow_count: &mut FxHashMap<Name, u32>,\n-    token: SyntaxToken,\n-) -> Option<(Highlight, Option<u64>)> {\n-    if token.parent().kind() != TOKEN_TREE {\n-        return None;\n-    }\n-    let token = sema.descend_into_macros(token.clone());\n-    let expanded = {\n-        let parent = token.parent();\n-        // We only care Name and Name_ref\n-        match (token.kind(), parent.kind()) {\n-            (IDENT, NAME) | (IDENT, NAME_REF) => parent.into(),\n-            _ => token.into(),\n-        }\n-    };\n-\n-    highlight_node(sema, bindings_shadow_count, expanded)\n-}\n-\n-fn highlight_node(\n+fn highlight_element(\n     sema: &Semantics<RootDatabase>,\n     bindings_shadow_count: &mut FxHashMap<Name, u32>,\n-    node: SyntaxElement,\n+    element: SyntaxElement,\n ) -> Option<(Highlight, Option<u64>)> {\n     let db = sema.db;\n     let mut binding_hash = None;\n-    let highlight: Highlight = match node.kind() {\n+    let highlight: Highlight = match element.kind() {\n         FN_DEF => {\n             bindings_shadow_count.clear();\n             return None;\n         }\n-        COMMENT => HighlightTag::Comment.into(),\n-        STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => HighlightTag::LiteralString.into(),\n-        ATTR => HighlightTag::Attribute.into(),\n-        // Special-case field init shorthand\n-        NAME_REF if node.parent().and_then(ast::RecordField::cast).is_some() => {\n-            HighlightTag::Field.into()\n-        }\n-        NAME_REF if node.ancestors().any(|it| it.kind() == ATTR) => return None,\n-        NAME_REF => {\n-            let name_ref = node.as_node().cloned().and_then(ast::NameRef::cast).unwrap();\n-            let name_kind = classify_name_ref(sema, &name_ref);\n-            match name_kind {\n-                Some(name_kind) => {\n-                    if let NameDefinition::Local(local) = &name_kind {\n-                        if let Some(name) = local.name(db) {\n-                            let shadow_count =\n-                                bindings_shadow_count.entry(name.clone()).or_default();\n-                            binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n-                        }\n-                    };\n-\n-                    highlight_name(db, name_kind)\n-                }\n-                _ => return None,\n-            }\n-        }\n+\n+        // Highlight definitions depending on the \"type\" of the definition.\n         NAME => {\n-            let name = node.as_node().cloned().and_then(ast::Name::cast).unwrap();\n+            let name = element.into_node().and_then(ast::Name::cast).unwrap();\n             let name_kind = classify_name(sema, &name);\n \n             if let Some(NameDefinition::Local(local)) = &name_kind {\n@@ -220,25 +165,56 @@ fn highlight_node(\n \n             match name_kind {\n                 Some(name_kind) => highlight_name(db, name_kind),\n-                None => name.syntax().parent().map_or(HighlightTag::Function.into(), |x| {\n-                    match x.kind() {\n-                        STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => {\n-                            HighlightTag::Type.into()\n-                        }\n-                        TYPE_PARAM => HighlightTag::TypeParam.into(),\n-                        RECORD_FIELD_DEF => HighlightTag::Field.into(),\n-                        _ => HighlightTag::Function.into(),\n-                    }\n-                }),\n+                None => highlight_name_by_syntax(name),\n             }\n         }\n+\n+        // Highlight references like the definitions they resolve to\n+\n+        // Special-case field init shorthand\n+        NAME_REF if element.parent().and_then(ast::RecordField::cast).is_some() => {\n+            HighlightTag::Field.into()\n+        }\n+        NAME_REF if element.ancestors().any(|it| it.kind() == ATTR) => return None,\n+        NAME_REF => {\n+            let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n+            let name_kind = classify_name_ref(sema, &name_ref)?;\n+\n+            if let NameDefinition::Local(local) = &name_kind {\n+                if let Some(name) = local.name(db) {\n+                    let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n+                    binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n+                }\n+            };\n+\n+            highlight_name(db, name_kind)\n+        }\n+\n+        // Simple token-based highlighting\n+        COMMENT => HighlightTag::Comment.into(),\n+        STRING | RAW_STRING | RAW_BYTE_STRING | BYTE_STRING => HighlightTag::LiteralString.into(),\n+        ATTR => HighlightTag::Attribute.into(),\n         INT_NUMBER | FLOAT_NUMBER => HighlightTag::LiteralNumeric.into(),\n         BYTE => HighlightTag::LiteralByte.into(),\n         CHAR => HighlightTag::LiteralChar.into(),\n         LIFETIME => HighlightTag::TypeLifetime.into(),\n-        T![unsafe] => HighlightTag::Keyword | HighlightModifier::Unsafe,\n-        k if is_control_keyword(k) => HighlightTag::Keyword | HighlightModifier::Control,\n-        k if k.is_keyword() => HighlightTag::Keyword.into(),\n+\n+        k if k.is_keyword() => {\n+            let h = Highlight::new(HighlightTag::Keyword);\n+            match k {\n+                T![break]\n+                | T![continue]\n+                | T![else]\n+                | T![for]\n+                | T![if]\n+                | T![loop]\n+                | T![match]\n+                | T![return]\n+                | T![while] => h | HighlightModifier::Control,\n+                T![unsafe] => h | HighlightModifier::Unsafe,\n+                _ => h,\n+            }\n+        }\n \n         _ => return None,\n     };\n@@ -262,17 +238,19 @@ fn highlight_name(db: &RootDatabase, def: NameDefinition) -> Highlight {\n     match def {\n         NameDefinition::Macro(_) => HighlightTag::Macro,\n         NameDefinition::StructField(_) => HighlightTag::Field,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Module(_)) => HighlightTag::Module,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Function(_)) => HighlightTag::Function,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Adt(_)) => HighlightTag::Type,\n-        NameDefinition::ModuleDef(hir::ModuleDef::EnumVariant(_)) => HighlightTag::Constant,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Const(_)) => HighlightTag::Constant,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Static(_)) => HighlightTag::Constant,\n-        NameDefinition::ModuleDef(hir::ModuleDef::Trait(_)) => HighlightTag::Type,\n-        NameDefinition::ModuleDef(hir::ModuleDef::TypeAlias(_)) => HighlightTag::Type,\n-        NameDefinition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n-            return HighlightTag::Type | HighlightModifier::Builtin\n-        }\n+        NameDefinition::ModuleDef(def) => match def {\n+            hir::ModuleDef::Module(_) => HighlightTag::Module,\n+            hir::ModuleDef::Function(_) => HighlightTag::Function,\n+            hir::ModuleDef::Adt(_) => HighlightTag::Type,\n+            hir::ModuleDef::EnumVariant(_) => HighlightTag::Constant,\n+            hir::ModuleDef::Const(_) => HighlightTag::Constant,\n+            hir::ModuleDef::Static(_) => HighlightTag::Constant,\n+            hir::ModuleDef::Trait(_) => HighlightTag::Type,\n+            hir::ModuleDef::TypeAlias(_) => HighlightTag::Type,\n+            hir::ModuleDef::BuiltinType(_) => {\n+                return HighlightTag::Type | HighlightModifier::Builtin\n+            }\n+        },\n         NameDefinition::SelfType(_) => HighlightTag::TypeSelf,\n         NameDefinition::TypeParam(_) => HighlightTag::TypeParam,\n         NameDefinition::Local(local) => {\n@@ -286,6 +264,22 @@ fn highlight_name(db: &RootDatabase, def: NameDefinition) -> Highlight {\n     .into()\n }\n \n+fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n+    let default = HighlightTag::Function.into();\n+\n+    let parent = match name.syntax().parent() {\n+        Some(it) => it,\n+        _ => return default,\n+    };\n+\n+    match parent.kind() {\n+        STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => HighlightTag::Type.into(),\n+        TYPE_PARAM => HighlightTag::TypeParam.into(),\n+        RECORD_FIELD_DEF => HighlightTag::Field.into(),\n+        _ => default,\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::fs;"}]}