{"sha": "6330daade9766bbf896495898c2347dc3be6da17", "node_id": "C_kwDOAAsO6NoAKDYzMzBkYWFkZTk3NjZiYmY4OTY0OTU4OThjMjM0N2RjM2JlNmRhMTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-13T22:34:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-13T22:34:59Z"}, "message": "Auto merge of #112062 - lukas-code:unsized-layout, r=wesleywiser\n\nMake struct layout not depend on unsizeable tail\n\nfixes (after backport) https://github.com/rust-lang/rust/issues/112048\n\nSince unsizing `Ptr<Foo<T>>` -> `Ptr<Foo<U>` just copies the pointer and adds the metadata, the layout of `Foo` must not depend on niches in and alignment of the tail `T`.\n\nNominating for beta 1.71, because it will have this issue: `@rustbot` label beta-nominated", "tree": {"sha": "6b2e000ca84491b3929c34b7b69d9b58000b87b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b2e000ca84491b3929c34b7b69d9b58000b87b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6330daade9766bbf896495898c2347dc3be6da17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6330daade9766bbf896495898c2347dc3be6da17", "html_url": "https://github.com/rust-lang/rust/commit/6330daade9766bbf896495898c2347dc3be6da17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6330daade9766bbf896495898c2347dc3be6da17/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "371994e0d8380600ddda78ca1be937c7fb179b49", "url": "https://api.github.com/repos/rust-lang/rust/commits/371994e0d8380600ddda78ca1be937c7fb179b49", "html_url": "https://github.com/rust-lang/rust/commit/371994e0d8380600ddda78ca1be937c7fb179b49"}, {"sha": "b982f3a98820e60eb04ac06910eca66f9a89d517", "url": "https://api.github.com/repos/rust-lang/rust/commits/b982f3a98820e60eb04ac06910eca66f9a89d517", "html_url": "https://github.com/rust-lang/rust/commit/b982f3a98820e60eb04ac06910eca66f9a89d517"}], "stats": {"total": 153, "additions": 109, "deletions": 44}, "files": [{"sha": "73f9deb3143a708006deac00d802740b8f5e17d3", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 54, "deletions": 44, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6330daade9766bbf896495898c2347dc3be6da17/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330daade9766bbf896495898c2347dc3be6da17/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=6330daade9766bbf896495898c2347dc3be6da17", "patch": "@@ -57,48 +57,54 @@ pub trait LayoutCalculator {\n         // run and bias niches to the right and then check which one is closer to one of the struct's\n         // edges.\n         if let Some(layout) = &layout {\n-            if let Some(niche) = layout.largest_niche {\n-                let head_space = niche.offset.bytes();\n-                let niche_length = niche.value.size(dl).bytes();\n-                let tail_space = layout.size.bytes() - head_space - niche_length;\n-\n-                // This may end up doing redundant work if the niche is already in the last field\n-                // (e.g. a trailing bool) and there is tail padding. But it's non-trivial to get\n-                // the unpadded size so we try anyway.\n-                if fields.len() > 1 && head_space != 0 && tail_space > 0 {\n-                    let alt_layout = univariant(self, dl, fields, repr, kind, NicheBias::End)\n-                        .expect(\"alt layout should always work\");\n-                    let niche = alt_layout\n-                        .largest_niche\n-                        .expect(\"alt layout should have a niche like the regular one\");\n-                    let alt_head_space = niche.offset.bytes();\n-                    let alt_niche_len = niche.value.size(dl).bytes();\n-                    let alt_tail_space = alt_layout.size.bytes() - alt_head_space - alt_niche_len;\n-\n-                    debug_assert_eq!(layout.size.bytes(), alt_layout.size.bytes());\n-\n-                    let prefer_alt_layout =\n-                        alt_head_space > head_space && alt_head_space > tail_space;\n-\n-                    debug!(\n-                        \"sz: {}, default_niche_at: {}+{}, default_tail_space: {}, alt_niche_at/head_space: {}+{}, alt_tail: {}, num_fields: {}, better: {}\\n\\\n-                        layout: {}\\n\\\n-                        alt_layout: {}\\n\",\n-                        layout.size.bytes(),\n-                        head_space,\n-                        niche_length,\n-                        tail_space,\n-                        alt_head_space,\n-                        alt_niche_len,\n-                        alt_tail_space,\n-                        layout.fields.count(),\n-                        prefer_alt_layout,\n-                        format_field_niches(&layout, &fields, &dl),\n-                        format_field_niches(&alt_layout, &fields, &dl),\n-                    );\n-\n-                    if prefer_alt_layout {\n-                        return Some(alt_layout);\n+            // Don't try to calculate an end-biased layout for unsizable structs,\n+            // otherwise we could end up with different layouts for\n+            // Foo<Type> and Foo<dyn Trait> which would break unsizing\n+            if !matches!(kind, StructKind::MaybeUnsized) {\n+                if let Some(niche) = layout.largest_niche {\n+                    let head_space = niche.offset.bytes();\n+                    let niche_length = niche.value.size(dl).bytes();\n+                    let tail_space = layout.size.bytes() - head_space - niche_length;\n+\n+                    // This may end up doing redundant work if the niche is already in the last field\n+                    // (e.g. a trailing bool) and there is tail padding. But it's non-trivial to get\n+                    // the unpadded size so we try anyway.\n+                    if fields.len() > 1 && head_space != 0 && tail_space > 0 {\n+                        let alt_layout = univariant(self, dl, fields, repr, kind, NicheBias::End)\n+                            .expect(\"alt layout should always work\");\n+                        let niche = alt_layout\n+                            .largest_niche\n+                            .expect(\"alt layout should have a niche like the regular one\");\n+                        let alt_head_space = niche.offset.bytes();\n+                        let alt_niche_len = niche.value.size(dl).bytes();\n+                        let alt_tail_space =\n+                            alt_layout.size.bytes() - alt_head_space - alt_niche_len;\n+\n+                        debug_assert_eq!(layout.size.bytes(), alt_layout.size.bytes());\n+\n+                        let prefer_alt_layout =\n+                            alt_head_space > head_space && alt_head_space > tail_space;\n+\n+                        debug!(\n+                            \"sz: {}, default_niche_at: {}+{}, default_tail_space: {}, alt_niche_at/head_space: {}+{}, alt_tail: {}, num_fields: {}, better: {}\\n\\\n+                            layout: {}\\n\\\n+                            alt_layout: {}\\n\",\n+                            layout.size.bytes(),\n+                            head_space,\n+                            niche_length,\n+                            tail_space,\n+                            alt_head_space,\n+                            alt_niche_len,\n+                            alt_tail_space,\n+                            layout.fields.count(),\n+                            prefer_alt_layout,\n+                            format_field_niches(&layout, &fields, &dl),\n+                            format_field_niches(&alt_layout, &fields, &dl),\n+                        );\n+\n+                        if prefer_alt_layout {\n+                            return Some(alt_layout);\n+                        }\n                     }\n                 }\n             }\n@@ -828,6 +834,7 @@ fn univariant(\n     if optimize && fields.len() > 1 {\n         let end = if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n         let optimizing = &mut inverse_memory_index.raw[..end];\n+        let fields_excluding_tail = &fields.raw[..end];\n \n         // If `-Z randomize-layout` was enabled for the type definition we can shuffle\n         // the field ordering to try and catch some code making assumptions about layouts\n@@ -844,8 +851,11 @@ fn univariant(\n             }\n             // Otherwise we just leave things alone and actually optimize the type's fields\n         } else {\n-            let max_field_align = fields.iter().map(|f| f.align().abi.bytes()).max().unwrap_or(1);\n-            let largest_niche_size = fields\n+            // To allow unsizing `&Foo<Type>` -> `&Foo<dyn Trait>`, the layout of the struct must\n+            // not depend on the layout of the tail.\n+            let max_field_align =\n+                fields_excluding_tail.iter().map(|f| f.align().abi.bytes()).max().unwrap_or(1);\n+            let largest_niche_size = fields_excluding_tail\n                 .iter()\n                 .filter_map(|f| f.largest_niche())\n                 .map(|n| n.available(dl))"}, {"sha": "ebc4b9e98b7ab4a5067ea22422b8eef2c61d4d14", "filename": "tests/ui/layout/issue-112048-unsizing-field-order.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6330daade9766bbf896495898c2347dc3be6da17/tests%2Fui%2Flayout%2Fissue-112048-unsizing-field-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330daade9766bbf896495898c2347dc3be6da17/tests%2Fui%2Flayout%2Fissue-112048-unsizing-field-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flayout%2Fissue-112048-unsizing-field-order.rs?ref=6330daade9766bbf896495898c2347dc3be6da17", "patch": "@@ -0,0 +1,25 @@\n+// run-pass\n+\n+// Check that unsizing doesn't reorder fields.\n+\n+#![allow(dead_code)]\n+\n+use std::fmt::Debug;\n+\n+#[derive(Debug)]\n+struct GcNode<T: ?Sized> {\n+    gets_swapped_with_next: usize,\n+    next: Option<&'static GcNode<dyn Debug>>,\n+    tail: T,\n+}\n+\n+fn main() {\n+    let node: Box<GcNode<dyn Debug>> = Box::new(GcNode {\n+        gets_swapped_with_next: 42,\n+        next: None,\n+        tail: Box::new(1),\n+    });\n+\n+    assert_eq!(node.gets_swapped_with_next, 42);\n+    assert!(node.next.is_none());\n+}"}, {"sha": "23588ba36ee59cf03113a30377c1ca1881723883", "filename": "tests/ui/layout/issue-112048-unsizing-niche.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6330daade9766bbf896495898c2347dc3be6da17/tests%2Fui%2Flayout%2Fissue-112048-unsizing-niche.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330daade9766bbf896495898c2347dc3be6da17/tests%2Fui%2Flayout%2Fissue-112048-unsizing-niche.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flayout%2Fissue-112048-unsizing-niche.rs?ref=6330daade9766bbf896495898c2347dc3be6da17", "patch": "@@ -0,0 +1,30 @@\n+// run-pass\n+\n+// Check that unsizing does not change which field is considered for niche layout.\n+\n+#![feature(offset_of)]\n+#![allow(dead_code)]\n+\n+#[derive(Clone)]\n+struct WideptrField<T: ?Sized> {\n+    first: usize,\n+    second: usize,\n+    niche: NicheAtEnd,\n+    tail: T,\n+}\n+\n+#[derive(Clone)]\n+#[repr(C)]\n+struct NicheAtEnd {\n+    arr: [u8; 7],\n+    b: bool,\n+}\n+\n+type Tail = [bool; 8];\n+\n+fn main() {\n+    assert_eq!(\n+        core::mem::offset_of!(WideptrField<Tail>, niche),\n+        core::mem::offset_of!(WideptrField<dyn Send>, niche)\n+    );\n+}"}]}