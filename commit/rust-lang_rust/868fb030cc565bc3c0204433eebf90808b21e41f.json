{"sha": "868fb030cc565bc3c0204433eebf90808b21e41f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2OGZiMDMwY2M1NjViYzNjMDIwNDQzM2VlYmY5MDgwOGIyMWU0MWY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2016-12-08T19:06:18Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2016-12-15T01:33:03Z"}, "message": "When cast needs a dereference point at full cast\n\nAfter the fix of #37453 in PR #37369, instead of pointing at only the\ncast type, point at the full cast span when a cast needs a dereference:\n\n```\nerror: casting `&{float}` as `f32` is invalid\n  --> ../../../src/test/ui/mismatched_types/cast-rfc0401.rs:81:30\n   |\n81 |     vec![0.0].iter().map(|s| s as f32).collect::<Vec<f32>>();\n   |                              ^^^^^^^^ cannot cast `&{float}` as `f32`\n   |\nhelp: did you mean `*s`?\n  --> ../../../src/test/ui/mismatched_types/cast-rfc0401.rs:81:30\n   |\n81 |     vec![0.0].iter().map(|s| s as f32).collect::<Vec<f32>>();\n   |                              ^\n```\n\ninstead of\n\n```\nerror: casting `&{float}` as `f32` is invalid\n  --> ../../../src/test/ui/mismatched_types/cast-rfc0401.rs:81:35\n   |\n81 |     vec![0.0].iter().map(|s| s as f32).collect::<Vec<f32>>();\n   |                              -    ^^^\n   |                              |\n   |                              |\n   |                              did you mean `*s`?\n   |                              cannot cast `&{float}` as `f32`\n```", "tree": {"sha": "bf0c089ce7c35e3ca6466f595cb8ba5844d4b120", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf0c089ce7c35e3ca6466f595cb8ba5844d4b120"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/868fb030cc565bc3c0204433eebf90808b21e41f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/868fb030cc565bc3c0204433eebf90808b21e41f", "html_url": "https://github.com/rust-lang/rust/commit/868fb030cc565bc3c0204433eebf90808b21e41f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/868fb030cc565bc3c0204433eebf90808b21e41f/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6483bdd860fd89fc68846d4cc94c7ae3307a84c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6483bdd860fd89fc68846d4cc94c7ae3307a84c1", "html_url": "https://github.com/rust-lang/rust/commit/6483bdd860fd89fc68846d4cc94c7ae3307a84c1"}], "stats": {"total": 452, "additions": 326, "deletions": 126}, "files": [{"sha": "265dcada1f810651a76401793644cfb0d17c1261", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/868fb030cc565bc3c0204433eebf90808b21e41f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868fb030cc565bc3c0204433eebf90808b21e41f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=868fb030cc565bc3c0204433eebf90808b21e41f", "patch": "@@ -142,20 +142,21 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     fn report_cast_error(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, e: CastError) {\n         match e {\n             CastError::NeedDeref => {\n+                let error_span = self.span;\n                 let cast_ty = fcx.ty_to_string(self.cast_ty);\n-                let mut err = fcx.type_error_struct(self.cast_span,\n+                let mut err = fcx.type_error_struct(error_span,\n                                        |actual| {\n                                            format!(\"casting `{}` as `{}` is invalid\",\n                                                    actual,\n                                                    cast_ty)\n                                        },\n                                        self.expr_ty);\n-                err.span_label(self.expr.span,\n+                err.span_label(error_span,\n                                &format!(\"cannot cast `{}` as `{}`\",\n                                         fcx.ty_to_string(self.expr_ty),\n                                         cast_ty));\n                 if let Ok(snippet) = fcx.sess().codemap().span_to_snippet(self.expr.span) {\n-                    err.span_label(self.expr.span,\n+                    err.span_help(self.expr.span,\n                                    &format!(\"did you mean `*{}`?\", snippet));\n                 }\n                 err.emit();"}, {"sha": "b98f464c902278443f7ecec8231ea4efc6c6508b", "filename": "src/test/compile-fail/cast-rfc0401.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/6483bdd860fd89fc68846d4cc94c7ae3307a84c1/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6483bdd860fd89fc68846d4cc94c7ae3307a84c1/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs?ref=6483bdd860fd89fc68846d4cc94c7ae3307a84c1", "patch": "@@ -1,123 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn illegal_cast<U:?Sized,V:?Sized>(u: *const U) -> *const V\n-{\n-    u as *const V\n-    //~^ ERROR casting\n-    //~^^ NOTE vtable kinds\n-}\n-\n-fn illegal_cast_2<U:?Sized>(u: *const U) -> *const str\n-{\n-    u as *const str\n-    //~^ ERROR casting\n-    //~^^ NOTE vtable kinds\n-}\n-\n-trait Foo { fn foo(&self) {} }\n-impl<T> Foo for T {}\n-\n-trait Bar { fn foo(&self) {} }\n-impl<T> Bar for T {}\n-\n-enum E {\n-    A, B\n-}\n-\n-fn main()\n-{\n-    let f: f32 = 1.2;\n-    let v = 0 as *const u8;\n-    let fat_v : *const [u8] = unsafe { &*(0 as *const [u8; 1])};\n-    let fat_sv : *const [i8] = unsafe { &*(0 as *const [i8; 1])};\n-    let foo: &Foo = &f;\n-\n-    let _ = v as &u8; //~ ERROR non-scalar\n-    let _ = v as E; //~ ERROR non-scalar\n-    let _ = v as fn(); //~ ERROR non-scalar\n-    let _ = v as (u32,); //~ ERROR non-scalar\n-    let _ = Some(&v) as *const u8; //~ ERROR non-scalar\n-\n-    let _ = v as f32;\n-    //~^ ERROR casting\n-    let _ = main as f64;\n-    //~^ ERROR casting\n-    let _ = &v as usize;\n-    //~^ ERROR casting\n-    //~^^ HELP through a raw pointer first\n-    let _ = f as *const u8;\n-    //~^ ERROR casting\n-    let _ = 3_i32 as bool;\n-    //~^ ERROR cannot cast as `bool` [E0054]\n-    //~| unsupported cast\n-    //~| HELP compare with zero\n-    let _ = E::A as bool;\n-    //~^ ERROR cannot cast as `bool` [E0054]\n-    //~| unsupported cast\n-    //~| HELP compare with zero\n-    let _ = 0x61u32 as char; //~ ERROR only `u8` can be cast\n-\n-    let _ = false as f32;\n-    //~^ ERROR casting\n-    //~^^ HELP through an integer first\n-    let _ = E::A as f32;\n-    //~^ ERROR casting\n-    //~^^ HELP through an integer first\n-    let _ = 'a' as f32;\n-    //~^ ERROR casting\n-    //~^^ HELP through an integer first\n-\n-    let _ = false as *const u8;\n-    //~^ ERROR casting\n-    let _ = E::A as *const u8;\n-    //~^ ERROR casting\n-    let _ = 'a' as *const u8;\n-    //~^ ERROR casting\n-\n-    let _ = 42usize as *const [u8]; //~ ERROR casting\n-    let _ = v as *const [u8]; //~ ERROR cannot cast\n-    let _ = fat_v as *const Foo;\n-    //~^ ERROR the trait bound `[u8]: std::marker::Sized` is not satisfied\n-    //~| NOTE the trait `std::marker::Sized` is not implemented for `[u8]`\n-    //~| NOTE `[u8]` does not have a constant size known at compile-time\n-    //~| NOTE required for the cast to the object type `Foo`\n-    let _ = foo as *const str; //~ ERROR casting\n-    let _ = foo as *mut str; //~ ERROR casting\n-    let _ = main as *mut str; //~ ERROR casting\n-    let _ = &f as *mut f32; //~ ERROR casting\n-    let _ = &f as *const f64; //~ ERROR casting\n-    let _ = fat_sv as usize;\n-    //~^ ERROR casting\n-    //~^^ HELP through a thin pointer first\n-\n-    let a : *const str = \"hello\";\n-    let _ = a as *const Foo;\n-    //~^ ERROR the trait bound `str: std::marker::Sized` is not satisfied\n-    //~| NOTE the trait `std::marker::Sized` is not implemented for `str`\n-    //~| NOTE `str` does not have a constant size known at compile-time\n-    //~| NOTE required for the cast to the object type `Foo`\n-\n-    // check no error cascade\n-    let _ = main.f as *const u32; //~ no field `f` on type `fn() {main}`\n-\n-    let cf: *const Foo = &0;\n-    let _ = cf as *const [u16];\n-    //~^ ERROR casting\n-    //~^^ NOTE vtable kinds\n-    let _ = cf as *const Bar;\n-    //~^ ERROR casting\n-    //~^^ NOTE vtable kinds\n-\n-    vec![0.0].iter().map(|s| s as f32).collect::<Vec<f32>>();\n-    //~^ ERROR casting `&{float}` as `f32` is invalid\n-    //~| NOTE cannot cast `&{float}` as `f32`\n-    //~| NOTE did you mean `*s`?\n-}"}, {"sha": "f72be0d7054dbc4311a1f0d98b280ef99a202dfe", "filename": "src/test/ui/mismatched_types/cast-rfc0401.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/868fb030cc565bc3c0204433eebf90808b21e41f/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868fb030cc565bc3c0204433eebf90808b21e41f/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.rs?ref=868fb030cc565bc3c0204433eebf90808b21e41f", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn illegal_cast<U:?Sized,V:?Sized>(u: *const U) -> *const V\n+{\n+    u as *const V\n+}\n+\n+fn illegal_cast_2<U:?Sized>(u: *const U) -> *const str\n+{\n+    u as *const str\n+}\n+\n+trait Foo { fn foo(&self) {} }\n+impl<T> Foo for T {}\n+\n+trait Bar { fn foo(&self) {} }\n+impl<T> Bar for T {}\n+\n+enum E {\n+    A, B\n+}\n+\n+fn main()\n+{\n+    let f: f32 = 1.2;\n+    let v = 0 as *const u8;\n+    let fat_v : *const [u8] = unsafe { &*(0 as *const [u8; 1])};\n+    let fat_sv : *const [i8] = unsafe { &*(0 as *const [i8; 1])};\n+    let foo: &Foo = &f;\n+\n+    let _ = v as &u8;\n+    let _ = v as E;\n+    let _ = v as fn();\n+    let _ = v as (u32,);\n+    let _ = Some(&v) as *const u8;\n+\n+    let _ = v as f32;\n+    let _ = main as f64;\n+    let _ = &v as usize;\n+    let _ = f as *const u8;\n+    let _ = 3_i32 as bool;\n+    let _ = E::A as bool;\n+    let _ = 0x61u32 as char;\n+\n+    let _ = false as f32;\n+    let _ = E::A as f32;\n+    let _ = 'a' as f32;\n+\n+    let _ = false as *const u8;\n+    let _ = E::A as *const u8;\n+    let _ = 'a' as *const u8;\n+\n+    let _ = 42usize as *const [u8];\n+    let _ = v as *const [u8];\n+    let _ = fat_v as *const Foo;\n+    let _ = foo as *const str;\n+    let _ = foo as *mut str;\n+    let _ = main as *mut str;\n+    let _ = &f as *mut f32;\n+    let _ = &f as *const f64;\n+    let _ = fat_sv as usize;\n+\n+    let a : *const str = \"hello\";\n+    let _ = a as *const Foo;\n+\n+    // check no error cascade\n+    let _ = main.f as *const u32;\n+\n+    let cf: *const Foo = &0;\n+    let _ = cf as *const [u16];\n+    let _ = cf as *const Bar;\n+\n+    vec![0.0].iter().map(|s| s as f32).collect::<Vec<f32>>();\n+}"}, {"sha": "7fd10f3cb689176f9c23ac53a4c5ee3fee518352", "filename": "src/test/ui/mismatched_types/cast-rfc0401.stderr", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/868fb030cc565bc3c0204433eebf90808b21e41f/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/868fb030cc565bc3c0204433eebf90808b21e41f/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr?ref=868fb030cc565bc3c0204433eebf90808b21e41f", "patch": "@@ -0,0 +1,240 @@\n+error: casting `*const U` as `*const V` is invalid\n+  --> $DIR/cast-rfc0401.rs:13:5\n+   |\n+13 |     u as *const V\n+   |     ^^^^^^^^^^^^^\n+   |\n+   = note: vtable kinds may not match\n+\n+error: casting `*const U` as `*const str` is invalid\n+  --> $DIR/cast-rfc0401.rs:18:5\n+   |\n+18 |     u as *const str\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+   = note: vtable kinds may not match\n+\n+error: no field `f` on type `fn() {main}`\n+  --> $DIR/cast-rfc0401.rs:75:18\n+   |\n+75 |     let _ = main.f as *const u32;\n+   |                  ^\n+\n+error: non-scalar cast: `*const u8` as `&u8`\n+  --> $DIR/cast-rfc0401.rs:39:13\n+   |\n+39 |     let _ = v as &u8;\n+   |             ^^^^^^^^\n+\n+error: non-scalar cast: `*const u8` as `E`\n+  --> $DIR/cast-rfc0401.rs:40:13\n+   |\n+40 |     let _ = v as E;\n+   |             ^^^^^^\n+\n+error: non-scalar cast: `*const u8` as `fn()`\n+  --> $DIR/cast-rfc0401.rs:41:13\n+   |\n+41 |     let _ = v as fn();\n+   |             ^^^^^^^^^\n+\n+error: non-scalar cast: `*const u8` as `(u32,)`\n+  --> $DIR/cast-rfc0401.rs:42:13\n+   |\n+42 |     let _ = v as (u32,);\n+   |             ^^^^^^^^^^^\n+\n+error: non-scalar cast: `std::option::Option<&*const u8>` as `*const u8`\n+  --> $DIR/cast-rfc0401.rs:43:13\n+   |\n+43 |     let _ = Some(&v) as *const u8;\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: casting `*const u8` as `f32` is invalid\n+  --> $DIR/cast-rfc0401.rs:45:13\n+   |\n+45 |     let _ = v as f32;\n+   |             ^^^^^^^^\n+\n+error: casting `fn() {main}` as `f64` is invalid\n+  --> $DIR/cast-rfc0401.rs:46:13\n+   |\n+46 |     let _ = main as f64;\n+   |             ^^^^^^^^^^^\n+\n+error: casting `&*const u8` as `usize` is invalid\n+  --> $DIR/cast-rfc0401.rs:47:13\n+   |\n+47 |     let _ = &v as usize;\n+   |             ^^^^^^^^^^^\n+   |\n+   = help: cast through a raw pointer first\n+\n+error: casting `f32` as `*const u8` is invalid\n+  --> $DIR/cast-rfc0401.rs:48:13\n+   |\n+48 |     let _ = f as *const u8;\n+   |             ^^^^^^^^^^^^^^\n+\n+error[E0054]: cannot cast as `bool`\n+  --> $DIR/cast-rfc0401.rs:49:13\n+   |\n+49 |     let _ = 3_i32 as bool;\n+   |             ^^^^^^^^^^^^^ unsupported cast\n+   |\n+   = help: compare with zero instead\n+\n+error[E0054]: cannot cast as `bool`\n+  --> $DIR/cast-rfc0401.rs:50:13\n+   |\n+50 |     let _ = E::A as bool;\n+   |             ^^^^^^^^^^^^ unsupported cast\n+   |\n+   = help: compare with zero instead\n+\n+error: only `u8` can be cast as `char`, not `u32`\n+  --> $DIR/cast-rfc0401.rs:51:13\n+   |\n+51 |     let _ = 0x61u32 as char;\n+   |             ^^^^^^^^^^^^^^^\n+\n+error: casting `bool` as `f32` is invalid\n+  --> $DIR/cast-rfc0401.rs:53:13\n+   |\n+53 |     let _ = false as f32;\n+   |             ^^^^^^^^^^^^\n+   |\n+   = help: cast through an integer first\n+\n+error: casting `E` as `f32` is invalid\n+  --> $DIR/cast-rfc0401.rs:54:13\n+   |\n+54 |     let _ = E::A as f32;\n+   |             ^^^^^^^^^^^\n+   |\n+   = help: cast through an integer first\n+\n+error: casting `char` as `f32` is invalid\n+  --> $DIR/cast-rfc0401.rs:55:13\n+   |\n+55 |     let _ = 'a' as f32;\n+   |             ^^^^^^^^^^\n+   |\n+   = help: cast through an integer first\n+\n+error: casting `bool` as `*const u8` is invalid\n+  --> $DIR/cast-rfc0401.rs:57:13\n+   |\n+57 |     let _ = false as *const u8;\n+   |             ^^^^^^^^^^^^^^^^^^\n+\n+error: casting `E` as `*const u8` is invalid\n+  --> $DIR/cast-rfc0401.rs:58:13\n+   |\n+58 |     let _ = E::A as *const u8;\n+   |             ^^^^^^^^^^^^^^^^^\n+\n+error: casting `char` as `*const u8` is invalid\n+  --> $DIR/cast-rfc0401.rs:59:13\n+   |\n+59 |     let _ = 'a' as *const u8;\n+   |             ^^^^^^^^^^^^^^^^\n+\n+error: casting `usize` as `*const [u8]` is invalid\n+  --> $DIR/cast-rfc0401.rs:61:13\n+   |\n+61 |     let _ = 42usize as *const [u8];\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: cannot cast thin pointer `*const u8` to fat pointer `*const [u8]`\n+  --> $DIR/cast-rfc0401.rs:62:13\n+   |\n+62 |     let _ = v as *const [u8];\n+   |             ^^^^^^^^^^^^^^^^\n+\n+error: casting `&Foo` as `*const str` is invalid\n+  --> $DIR/cast-rfc0401.rs:64:13\n+   |\n+64 |     let _ = foo as *const str;\n+   |             ^^^^^^^^^^^^^^^^^\n+\n+error: casting `&Foo` as `*mut str` is invalid\n+  --> $DIR/cast-rfc0401.rs:65:13\n+   |\n+65 |     let _ = foo as *mut str;\n+   |             ^^^^^^^^^^^^^^^\n+\n+error: casting `fn() {main}` as `*mut str` is invalid\n+  --> $DIR/cast-rfc0401.rs:66:13\n+   |\n+66 |     let _ = main as *mut str;\n+   |             ^^^^^^^^^^^^^^^^\n+\n+error: casting `&f32` as `*mut f32` is invalid\n+  --> $DIR/cast-rfc0401.rs:67:13\n+   |\n+67 |     let _ = &f as *mut f32;\n+   |             ^^^^^^^^^^^^^^\n+\n+error: casting `&f32` as `*const f64` is invalid\n+  --> $DIR/cast-rfc0401.rs:68:13\n+   |\n+68 |     let _ = &f as *const f64;\n+   |             ^^^^^^^^^^^^^^^^\n+\n+error: casting `*const [i8]` as `usize` is invalid\n+  --> $DIR/cast-rfc0401.rs:69:13\n+   |\n+69 |     let _ = fat_sv as usize;\n+   |             ^^^^^^^^^^^^^^^\n+   |\n+   = help: cast through a thin pointer first\n+\n+error: casting `*const Foo` as `*const [u16]` is invalid\n+  --> $DIR/cast-rfc0401.rs:78:13\n+   |\n+78 |     let _ = cf as *const [u16];\n+   |             ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: vtable kinds may not match\n+\n+error: casting `*const Foo` as `*const Bar` is invalid\n+  --> $DIR/cast-rfc0401.rs:79:13\n+   |\n+79 |     let _ = cf as *const Bar;\n+   |             ^^^^^^^^^^^^^^^^\n+   |\n+   = note: vtable kinds may not match\n+\n+error[E0277]: the trait bound `[u8]: std::marker::Sized` is not satisfied\n+  --> $DIR/cast-rfc0401.rs:63:13\n+   |\n+63 |     let _ = fat_v as *const Foo;\n+   |             ^^^^^ the trait `std::marker::Sized` is not implemented for `[u8]`\n+   |\n+   = note: `[u8]` does not have a constant size known at compile-time\n+   = note: required for the cast to the object type `Foo`\n+\n+error[E0277]: the trait bound `str: std::marker::Sized` is not satisfied\n+  --> $DIR/cast-rfc0401.rs:72:13\n+   |\n+72 |     let _ = a as *const Foo;\n+   |             ^ the trait `std::marker::Sized` is not implemented for `str`\n+   |\n+   = note: `str` does not have a constant size known at compile-time\n+   = note: required for the cast to the object type `Foo`\n+\n+error: casting `&{float}` as `f32` is invalid\n+  --> $DIR/cast-rfc0401.rs:81:30\n+   |\n+81 |     vec![0.0].iter().map(|s| s as f32).collect::<Vec<f32>>();\n+   |                              ^^^^^^^^ cannot cast `&{float}` as `f32`\n+   |\n+help: did you mean `*s`?\n+  --> $DIR/cast-rfc0401.rs:81:30\n+   |\n+81 |     vec![0.0].iter().map(|s| s as f32).collect::<Vec<f32>>();\n+   |                              ^\n+\n+error: aborting due to 34 previous errors\n+"}]}