{"sha": "467a0bfdea3ba03de05b90a3de85d4467a28762e", "node_id": "C_kwDOAAsO6NoAKDQ2N2EwYmZkZWEzYmEwM2RlMDViOTBhM2RlODVkNDQ2N2EyODc2MmU", "commit": {"author": {"name": "Georgy Komarov", "email": "jubnzv@gmail.com", "date": "2022-01-26T15:20:35Z"}, "committer": {"name": "Georgy Komarov", "email": "jubnzv@gmail.com", "date": "2022-01-26T15:20:35Z"}, "message": "matches: Restore `match_type` logic; add tests for these cases", "tree": {"sha": "6571465642c106bbd56b195fb55146f36a7f28d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6571465642c106bbd56b195fb55146f36a7f28d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/467a0bfdea3ba03de05b90a3de85d4467a28762e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/467a0bfdea3ba03de05b90a3de85d4467a28762e", "html_url": "https://github.com/rust-lang/rust/commit/467a0bfdea3ba03de05b90a3de85d4467a28762e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/467a0bfdea3ba03de05b90a3de85d4467a28762e/comments", "author": {"login": "jubnzv", "id": 12023585, "node_id": "MDQ6VXNlcjEyMDIzNTg1", "avatar_url": "https://avatars.githubusercontent.com/u/12023585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jubnzv", "html_url": "https://github.com/jubnzv", "followers_url": "https://api.github.com/users/jubnzv/followers", "following_url": "https://api.github.com/users/jubnzv/following{/other_user}", "gists_url": "https://api.github.com/users/jubnzv/gists{/gist_id}", "starred_url": "https://api.github.com/users/jubnzv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jubnzv/subscriptions", "organizations_url": "https://api.github.com/users/jubnzv/orgs", "repos_url": "https://api.github.com/users/jubnzv/repos", "events_url": "https://api.github.com/users/jubnzv/events{/privacy}", "received_events_url": "https://api.github.com/users/jubnzv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jubnzv", "id": 12023585, "node_id": "MDQ6VXNlcjEyMDIzNTg1", "avatar_url": "https://avatars.githubusercontent.com/u/12023585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jubnzv", "html_url": "https://github.com/jubnzv", "followers_url": "https://api.github.com/users/jubnzv/followers", "following_url": "https://api.github.com/users/jubnzv/following{/other_user}", "gists_url": "https://api.github.com/users/jubnzv/gists{/gist_id}", "starred_url": "https://api.github.com/users/jubnzv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jubnzv/subscriptions", "organizations_url": "https://api.github.com/users/jubnzv/orgs", "repos_url": "https://api.github.com/users/jubnzv/repos", "events_url": "https://api.github.com/users/jubnzv/events{/privacy}", "received_events_url": "https://api.github.com/users/jubnzv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81015870df891084b24497718af086f0575a121b", "url": "https://api.github.com/repos/rust-lang/rust/commits/81015870df891084b24497718af086f0575a121b", "html_url": "https://github.com/rust-lang/rust/commit/81015870df891084b24497718af086f0575a121b"}], "stats": {"total": 71, "additions": 52, "deletions": 19}, "files": [{"sha": "47c02e2282151c13130c732cfe6c5daed5fe5548", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/467a0bfdea3ba03de05b90a3de85d4467a28762e/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467a0bfdea3ba03de05b90a3de85d4467a28762e/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=467a0bfdea3ba03de05b90a3de85d4467a28762e", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::diagnostics::{\n use clippy_utils::macros::{is_panic, root_macro_call};\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, peel_mid_ty_refs};\n+use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n     get_parent_expr, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n@@ -741,7 +741,7 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n         let ty = cx.typeck_results().expr_ty(ex);\n         if *ty.kind() != ty::Bool || is_lint_allowed(cx, MATCH_BOOL, ex.hir_id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n-            check_single_match_opt_like(cx, ex, arms, expr, els);\n+            check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n         }\n     }\n }\n@@ -830,11 +830,12 @@ fn report_single_match_single_pattern(\n     );\n }\n \n-fn check_single_match_opt_like(\n-    cx: &LateContext<'_>,\n+fn check_single_match_opt_like<'a>(\n+    cx: &LateContext<'a>,\n     ex: &Expr<'_>,\n     arms: &[Arm<'_>],\n     expr: &Expr<'_>,\n+    ty: Ty<'a>,\n     els: Option<&Expr<'_>>,\n ) {\n     // list of candidate `Enum`s we know will never get any more members\n@@ -854,44 +855,50 @@ fn check_single_match_opt_like(\n         return;\n     }\n \n-    let mut paths = Vec::new();\n-    if !collect_pat_paths(&mut paths, arms[1].pat) {\n+    let mut paths_and_types = Vec::new();\n+    if !collect_pat_paths(&mut paths_and_types, cx, arms[1].pat, ty) {\n         return;\n     }\n \n-    let in_candidate_enum = |path: &String| -> bool {\n-        for &(_, pat_path) in candidates {\n-            if path == pat_path {\n+    let in_candidate_enum = |path_info: &(String, &TyS<'_>)| -> bool {\n+        let (path, ty) = path_info;\n+        for &(ty_path, pat_path) in candidates {\n+            if path == pat_path && match_type(cx, ty, ty_path) {\n                 return true;\n             }\n         }\n         false\n     };\n-    if paths.iter().all(in_candidate_enum) {\n+    if paths_and_types.iter().all(in_candidate_enum) {\n         report_single_match_single_pattern(cx, ex, arms, expr, els);\n     }\n }\n \n-/// Collects paths from the given paths. Returns true if the given pattern could be simplified,\n-/// false otherwise.\n-fn collect_pat_paths(acc: &mut Vec<String>, pat: &Pat<'_>) -> bool {\n+/// Collects paths and their types from the given patterns. Returns true if the given pattern could\n+/// be simplified, false otherwise.\n+fn collect_pat_paths<'a>(acc: &mut Vec<(String, Ty<'a>)>, cx: &LateContext<'a>, pat: &Pat<'_>, ty: Ty<'a>) -> bool {\n     match pat.kind {\n         PatKind::Wild => true,\n-        PatKind::Tuple(inner, _) => inner.iter().all(|p| collect_pat_paths(acc, p)),\n+        PatKind::Tuple(inner, _) => inner.iter().all(|p| {\n+            let p_ty = cx.typeck_results().pat_ty(p);\n+            collect_pat_paths(acc, cx, p, p_ty)\n+        }),\n         PatKind::TupleStruct(ref path, ..) => {\n-            acc.push(rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n                 s.print_qpath(path, false);\n-            }));\n+            });\n+            acc.push((path, ty));\n             true\n         },\n         PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => {\n-            acc.push(ident.to_string());\n+            acc.push((ident.to_string(), ty));\n             true\n         },\n         PatKind::Path(ref path) => {\n-            acc.push(rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n                 s.print_qpath(path, false);\n-            }));\n+            });\n+            acc.push((path, ty));\n             true\n         },\n         _ => false,"}, {"sha": "bd371888046361ceea6c5ce3b9c866301df7e5a4", "filename": "tests/ui/single_match.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/467a0bfdea3ba03de05b90a3de85d4467a28762e/tests%2Fui%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467a0bfdea3ba03de05b90a3de85d4467a28762e/tests%2Fui%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.rs?ref=467a0bfdea3ba03de05b90a3de85d4467a28762e", "patch": "@@ -197,6 +197,32 @@ fn ranges() {\n     }\n }\n \n+fn skip_type_aliases() {\n+    enum OptionEx {\n+        Some(i32),\n+        None,\n+    }\n+    enum ResultEx {\n+        Err(i32),\n+        Ok(i32),\n+    }\n+\n+    use OptionEx::{None, Some};\n+    use ResultEx::{Err, Ok};\n+\n+    // don't lint\n+    match Err(42) {\n+        Ok(_) => dummy(),\n+        Err(_) => (),\n+    };\n+\n+    // don't lint\n+    match Some(1i32) {\n+        Some(_) => dummy(),\n+        None => (),\n+    };\n+}\n+\n macro_rules! single_match {\n     ($num:literal) => {\n         match $num {"}]}