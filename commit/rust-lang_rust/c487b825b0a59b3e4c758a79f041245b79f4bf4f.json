{"sha": "c487b825b0a59b3e4c758a79f041245b79f4bf4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ODdiODI1YjBhNTliM2U0Yzc1OGE3OWYwNDEyNDViNzlmNGJmNGY=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-09-07T01:31:42Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:59Z"}, "message": "Attempt at including CodegenCx within Builder with Associated types", "tree": {"sha": "61c07bd694c62db8c58dc971900dc321fca63ae5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61c07bd694c62db8c58dc971900dc321fca63ae5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c487b825b0a59b3e4c758a79f041245b79f4bf4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c487b825b0a59b3e4c758a79f041245b79f4bf4f", "html_url": "https://github.com/rust-lang/rust/commit/c487b825b0a59b3e4c758a79f041245b79f4bf4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c487b825b0a59b3e4c758a79f041245b79f4bf4f/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1929ac2007f835a3a46ef1e4b23e9512db007b35", "url": "https://api.github.com/repos/rust-lang/rust/commits/1929ac2007f835a3a46ef1e4b23e9512db007b35", "html_url": "https://github.com/rust-lang/rust/commit/1929ac2007f835a3a46ef1e4b23e9512db007b35"}], "stats": {"total": 93, "additions": 52, "deletions": 41}, "files": [{"sha": "7d3b6025e2a61dc5c8a26fd202ed1b84331ed599", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c487b825b0a59b3e4c758a79f041245b79f4bf4f/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c487b825b0a59b3e4c758a79f041245b79f4bf4f/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=c487b825b0a59b3e4c758a79f041245b79f4bf4f", "patch": "@@ -157,7 +157,7 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOpKind) -> RealPredicate {\n     }\n }\n \n-pub fn compare_simd_types<'a, 'll:'a, 'tcx:'ll, Builder: BuilderMethods<'a, 'll, 'tcx>>(\n+pub fn compare_simd_types<'a, 'tcx: 'a, Builder: BuilderMethods<'a, 'tcx>>(\n     bx: &Builder,\n     lhs: Builder::Value,\n     rhs: Builder::Value,"}, {"sha": "2d5468cfc8e8d1c09ef3c26c3aee7e158a72bcc4", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c487b825b0a59b3e4c758a79f041245b79f4bf4f/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c487b825b0a59b3e4c758a79f041245b79f4bf4f/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=c487b825b0a59b3e4c758a79f041245b79f4bf4f", "patch": "@@ -12,7 +12,7 @@ use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{self, False, OperandBundleDef, BasicBlock};\n use common::{self, *};\n use context::CodegenCx;\n-use type_;\n+use type_::Type;\n use value::Value;\n use libc::{c_uint, c_char};\n use rustc::ty::TyCtxt;\n@@ -57,14 +57,16 @@ bitflags! {\n }\n \n impl Backend for Builder<'a, 'll, 'tcx>  {\n-        type Value = &'ll Value;\n-        type BasicBlock = &'ll BasicBlock;\n-        type Type = &'ll type_::Type;\n-        type TypeKind = llvm::TypeKind;\n-        type Context = &'ll llvm::Context;\n+    type Value = &'ll Value;\n+    type BasicBlock = &'ll BasicBlock;\n+    type Type = &'ll Type;\n+    type TypeKind = llvm::TypeKind;\n+    type Context = &'ll llvm::Context;\n }\n \n-impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n+impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n+    type CodegenCx = CodegenCx<'ll, 'tcx>;\n+\n     fn new_block<'b>(\n         cx: &'a CodegenCx<'ll, 'tcx>,\n         llfn: &'ll Value,\n@@ -199,7 +201,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n                   args: &[&'ll Value],\n                   then: &'ll BasicBlock,\n                   catch: &'ll BasicBlock,\n-                  bundle: Option<&common::OperandBundleDef<'ll, &'ll Value>>) -> &'ll Value {\n+                  bundle: Option<&common::OperandBundleDef<&'ll Value>>) -> &'ll Value {\n         self.count_insn(\"invoke\");\n \n         debug!(\"Invoke {:?} with args ({:?})\",\n@@ -437,15 +439,15 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn alloca(&self, ty: Self::Type, name: &str, align: Align) -> &'ll Value {\n+    fn alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n         let bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n         bx.dynamic_alloca(ty, name, align)\n     }\n \n-    fn dynamic_alloca(&self, ty: Self::Type, name: &str, align: Align) -> &'ll Value {\n+    fn dynamic_alloca(&self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n@@ -461,7 +463,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn array_alloca(&self,\n-                        ty: Self::Type,\n+                        ty: &'ll Type,\n                         len: &'ll Value,\n                         name: &str,\n                         align: Align) -> &'ll Value {\n@@ -620,92 +622,92 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     /* Casts */\n-    fn trunc(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n+    fn trunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"trunc\");\n         unsafe {\n             llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn sext(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n+    fn sext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"sext\");\n         unsafe {\n             llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn fptoui(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n+    fn fptoui(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptoui\");\n         unsafe {\n             llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn fptosi(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n+    fn fptosi(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptosi\");\n         unsafe {\n             llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,noname())\n         }\n     }\n \n-    fn uitofp(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n+    fn uitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"uitofp\");\n         unsafe {\n             llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn sitofp(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n+    fn sitofp(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"sitofp\");\n         unsafe {\n             llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn fptrunc(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n+    fn fptrunc(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fptrunc\");\n         unsafe {\n             llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn fpext(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n+    fn fpext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"fpext\");\n         unsafe {\n             llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn ptrtoint(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n+    fn ptrtoint(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"ptrtoint\");\n         unsafe {\n             llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn inttoptr(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n+    fn inttoptr(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"inttoptr\");\n         unsafe {\n             llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    fn bitcast(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n+    fn bitcast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"bitcast\");\n         unsafe {\n             llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n \n-    fn intcast(&self, val: &'ll Value, dest_ty: Self::Type, is_signed: bool) -> &'ll Value {\n+    fn intcast(&self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value {\n         self.count_insn(\"intcast\");\n         unsafe {\n             llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed)\n         }\n     }\n \n-    fn pointercast(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n+    fn pointercast(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"pointercast\");\n         unsafe {\n             llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n@@ -729,14 +731,14 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     /* Miscellaneous instructions */\n-    fn empty_phi(&self, ty: Self::Type) -> &'ll Value {\n+    fn empty_phi(&self, ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"emptyphi\");\n         unsafe {\n             llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n         }\n     }\n \n-    fn phi(&self, ty: Self::Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n+    fn phi(&self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n         assert_eq!(vals.len(), bbs.len());\n         let phi = self.empty_phi(ty);\n         self.count_insn(\"addincoming\");\n@@ -749,7 +751,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n-                       inputs: &[&'ll Value], output: Self::Type,\n+                       inputs: &[&'ll Value], output: &'ll Type,\n                        volatile: bool, alignstack: bool,\n                        dia: syntax::ast::AsmDialect) -> Option<&'ll Value> {\n         self.count_insn(\"inlineasm\");\n@@ -826,7 +828,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     #[allow(dead_code)]\n-    fn va_arg(&self, list: &'ll Value, ty: Self::Type) -> &'ll Value {\n+    fn va_arg(&self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"vaarg\");\n         unsafe {\n             llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n@@ -961,7 +963,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn landing_pad(&self, ty: Self::Type, pers_fn: &'ll Value,\n+    fn landing_pad(&self, ty: &'ll Type, pers_fn: &'ll Value,\n                        num_clauses: usize) -> &'ll Value {\n         self.count_insn(\"landingpad\");\n         unsafe {\n@@ -1232,7 +1234,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn call(&self, llfn: &'ll Value, args: &[&'ll Value],\n-                bundle: Option<&common::OperandBundleDef<'ll, &'ll Value>>) -> &'ll Value {\n+                bundle: Option<&common::OperandBundleDef<&'ll Value>>) -> &'ll Value {\n         self.count_insn(\"call\");\n \n         debug!(\"Call {:?} with args ({:?})\",\n@@ -1254,7 +1256,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn zext(&self, val: &'ll Value, dest_ty: Self::Type) -> &'ll Value {\n+    fn zext(&self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.count_insn(\"zext\");\n         unsafe {\n             llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())"}, {"sha": "19636596cea26c9b49a29214527a85954060ac34", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c487b825b0a59b3e4c758a79f041245b79f4bf4f/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c487b825b0a59b3e4c758a79f041245b79f4bf4f/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=c487b825b0a59b3e4c758a79f041245b79f4bf4f", "patch": "@@ -50,13 +50,13 @@ pub fn type_is_freeze<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bo\n     ty.is_freeze(tcx, ty::ParamEnv::reveal_all(), DUMMY_SP)\n }\n \n-pub struct OperandBundleDef<'a, Value: 'a> {\n+pub struct OperandBundleDef<'a, Value> {\n     pub name: &'a str,\n     pub val: Value\n }\n \n-impl OperandBundleDef<'ll, &'ll Value> {\n-    pub fn new(name: &'ll str, val: &'ll Value) -> Self {\n+impl<'a, Value> OperandBundleDef<'a, Value> {\n+    pub fn new(name: &'a str, val: Value) -> Self {\n         OperandBundleDef {\n             name,\n             val"}, {"sha": "867e91ff192c184d163d743c0beed250f1f54076", "filename": "src/librustc_codegen_llvm/interfaces/builder.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c487b825b0a59b3e4c758a79f041245b79f4bf4f/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c487b825b0a59b3e4c758a79f041245b79f4bf4f/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs?ref=c487b825b0a59b3e4c758a79f041245b79f4bf4f", "patch": "@@ -15,24 +15,33 @@ use rustc::ty::layout::{Align, Size};\n use rustc::session::Session;\n use builder::MemFlags;\n use super::backend::Backend;\n+use super::type_::TypeMethods;\n+use super::consts::ConstMethods;\n \n use std::borrow::Cow;\n use std::ops::Range;\n use syntax::ast::AsmDialect;\n \n \n \n-pub trait BuilderMethods<'a, 'll :'a, 'tcx: 'll>: Backend {\n+pub trait BuilderMethods<'a, 'tcx: 'a>: Backend {\n+    type CodegenCx: TypeMethods + ConstMethods + Backend<\n+        Value = Self::Value,\n+        BasicBlock = Self::BasicBlock,\n+        Type = Self::Type,\n+        TypeKind = Self::TypeKind,\n+        Context = Self::Context,\n+    >;\n \n     fn new_block<'b>(\n-        cx: &'a CodegenCx<'ll, 'tcx, Self::Value>,\n+        cx: &'a Self::CodegenCx,\n         llfn: Self::Value,\n         name: &'b str\n     ) -> Self;\n-    fn with_cx(cx: &'a CodegenCx<'ll, 'tcx, Self::Value>) -> Self;\n+    fn with_cx(cx: &'a Self::CodegenCx) -> Self;\n     fn build_sibling_block<'b>(&self, name: &'b str) -> Self;\n     fn sess(&self) -> &Session;\n-    fn cx(&self) -> &'a CodegenCx<'ll, 'tcx, Self::Value>;\n+    fn cx(&self) -> &'a Self::CodegenCx;\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n     fn llfn(&self) -> Self::Value;\n     fn llbb(&self) -> Self::BasicBlock;\n@@ -62,7 +71,7 @@ pub trait BuilderMethods<'a, 'll :'a, 'tcx: 'll>: Backend {\n         args: &[Self::Value],\n         then: Self::BasicBlock,\n         catch: Self::BasicBlock,\n-        bundle: Option<&OperandBundleDef<'ll, Self::Value>>\n+        bundle: Option<&OperandBundleDef<Self::Value>>\n     ) -> Self::Value;\n     fn unreachable(&self);\n     fn add(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n@@ -278,6 +287,6 @@ pub trait BuilderMethods<'a, 'll :'a, 'tcx: 'll>: Backend {\n     fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: Self::Value, size: Size);\n \n     fn call(&self, llfn: Self::Value, args: &[Self::Value],\n-                bundle: Option<&OperandBundleDef<'ll, Self::Value>>) -> Self::Value;\n+                bundle: Option<&OperandBundleDef<Self::Value>>) -> Self::Value;\n     fn zext(&self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n }"}]}