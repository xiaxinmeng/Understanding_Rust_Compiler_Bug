{"sha": "4b07c1e77515ae9198aae6275700aacd43181b50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMDdjMWU3NzUxNWFlOTE5OGFhZTYyNzU3MDBhYWNkNDMxODFiNTA=", "commit": {"author": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-06-11T17:17:32Z"}, "committer": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-06-18T07:15:43Z"}, "message": "Add Type::walk method", "tree": {"sha": "30fe7b19cfd23d384ba5de42b96c9eda2d389614", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30fe7b19cfd23d384ba5de42b96c9eda2d389614"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b07c1e77515ae9198aae6275700aacd43181b50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b07c1e77515ae9198aae6275700aacd43181b50", "html_url": "https://github.com/rust-lang/rust/commit/4b07c1e77515ae9198aae6275700aacd43181b50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b07c1e77515ae9198aae6275700aacd43181b50/comments", "author": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ec0064409f90334f6b0dd61e572a65702702985", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ec0064409f90334f6b0dd61e572a65702702985", "html_url": "https://github.com/rust-lang/rust/commit/7ec0064409f90334f6b0dd61e572a65702702985"}], "stats": {"total": 207, "additions": 132, "deletions": 75}, "files": [{"sha": "d0a8199a6436bb30637aca08544b406490268975", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 59, "deletions": 71, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4b07c1e77515ae9198aae6275700aacd43181b50/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b07c1e77515ae9198aae6275700aacd43181b50/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=4b07c1e77515ae9198aae6275700aacd43181b50", "patch": "@@ -26,8 +26,8 @@ use hir_ty::{\n     autoderef,\n     display::{HirDisplayError, HirFormatter},\n     expr::ExprValidator,\n-    method_resolution, ApplicationTy, Canonical, GenericPredicate, InEnvironment, OpaqueTyId,\n-    Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n+    method_resolution, ApplicationTy, Canonical, InEnvironment, Substs, TraitEnvironment, TraitRef,\n+    Ty, TyDefId, TypeCtor,\n };\n use ra_db::{CrateId, CrateName, Edition, FileId};\n use ra_prof::profile;\n@@ -1375,6 +1375,18 @@ impl Type {\n         Some(adt.into())\n     }\n \n+    pub fn as_dyn_trait(&self) -> Option<Trait> {\n+        self.ty.value.dyn_trait().map(Into::into)\n+    }\n+\n+    pub fn as_impl_trait(&self, db: &dyn HirDatabase) -> Option<Trait> {\n+        self.ty.value.impl_trait_ref(db).map(|it| it.trait_.into())\n+    }\n+\n+    pub fn as_associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<Trait> {\n+        self.ty.value.associated_type_parent_trait(db).map(Into::into)\n+    }\n+\n     // FIXME: provide required accessors such that it becomes implementable from outside.\n     pub fn is_equal_for_find_impls(&self, other: &Type) -> bool {\n         match (&self.ty.value, &other.ty.value) {\n@@ -1397,96 +1409,72 @@ impl Type {\n         }\n     }\n \n-    /// Returns a flattened list of all ADTs and Traits mentioned in the type\n-    pub fn flattened_type_items(&self, db: &dyn HirDatabase) -> Vec<ModuleDef> {\n-        fn push_new_item(item: ModuleDef, acc: &mut Vec<ModuleDef>) {\n-            if !acc.contains(&item) {\n-                acc.push(item);\n+    pub fn walk(&self, db: &dyn HirDatabase, mut cb: impl FnMut(Type)) {\n+        // TypeWalk::walk does not preserve items order!\n+        fn walk_substs(db: &dyn HirDatabase, substs: &Substs, cb: &mut impl FnMut(Type)) {\n+            for ty in substs.iter() {\n+                walk_ty(db, ty, cb);\n             }\n         }\n \n-        fn push_bounds(\n+        fn walk_trait(\n             db: &dyn HirDatabase,\n-            predicates: &[GenericPredicate],\n-            acc: &mut Vec<ModuleDef>,\n+            ty: Ty,\n+            trait_ref: &TraitRef,\n+            cb: &mut impl FnMut(Type),\n         ) {\n-            for p in predicates.iter() {\n-                match p {\n-                    GenericPredicate::Implemented(trait_ref) => {\n-                        push_new_item(Trait::from(trait_ref.trait_).into(), acc);\n-                        walk_substs(db, &trait_ref.substs, acc);\n-                    }\n-                    GenericPredicate::Projection(_) => {}\n-                    GenericPredicate::Error => (),\n-                }\n-            }\n+            let def_db: &dyn DefDatabase = db.upcast();\n+            let resolver = trait_ref.trait_.resolver(def_db);\n+            let krate = trait_ref.trait_.lookup(def_db).container.module(def_db).krate;\n+            cb(Type::new_with_resolver_inner(db, krate, &resolver, ty));\n+            walk_substs(db, &trait_ref.substs, cb);\n         }\n \n-        // TypeWalk::walk does not preserve items order!\n-        fn walk_substs(db: &dyn HirDatabase, substs: &Substs, acc: &mut Vec<ModuleDef>) {\n-            for ty in substs.iter() {\n-                walk_type(db, ty, acc);\n-            }\n-        }\n-\n-        fn walk_type(db: &dyn HirDatabase, ty: &Ty, acc: &mut Vec<ModuleDef>) {\n-            match ty.strip_references() {\n-                Ty::Apply(ApplicationTy { ctor, parameters, .. }) => {\n+        fn walk_ty(db: &dyn HirDatabase, ty: &Ty, cb: &mut impl FnMut(Type)) {\n+            let def_db: &dyn DefDatabase = db.upcast();\n+            let ty = ty.strip_references();\n+            match ty {\n+                Ty::Apply(ApplicationTy { ctor, parameters }) => {\n                     match ctor {\n-                        TypeCtor::Adt(adt_id) => push_new_item(Adt::from(*adt_id).into(), acc),\n-                        TypeCtor::AssociatedType(type_alias_id) => {\n-                            let trait_id = match type_alias_id.lookup(db.upcast()).container {\n-                                AssocContainerId::TraitId(it) => it,\n-                                _ => panic!(\"not an associated type\"),\n-                            };\n-\n-                            push_new_item(Trait::from(trait_id).into(), acc);\n+                        TypeCtor::Adt(adt) => {\n+                            cb(Type::from_def(db, adt.module(def_db).krate, *adt));\n+                        }\n+                        TypeCtor::AssociatedType(_) => {\n+                            if let Some(trait_id) = ty.associated_type_parent_trait(db) {\n+                                let resolver = trait_id.resolver(def_db);\n+                                let krate = trait_id.lookup(def_db).container.module(def_db).krate;\n+                                cb(Type::new_with_resolver_inner(db, krate, &resolver, ty.clone()));\n+                            }\n                         }\n                         _ => (),\n                     }\n+\n                     // adt params, tuples, etc...\n-                    walk_substs(db, parameters, acc);\n+                    walk_substs(db, parameters, cb);\n                 }\n-                Ty::Dyn(predicates) => {\n-                    push_bounds(db, predicates, acc);\n+                Ty::Opaque(opaque_ty) => {\n+                    if let Some(trait_ref) = ty.impl_trait_ref(db) {\n+                        walk_trait(db, ty.clone(), &trait_ref, cb);\n+                    }\n+\n+                    walk_substs(db, &opaque_ty.parameters, cb);\n                 }\n-                Ty::Placeholder(id) => {\n-                    let generic_params = db.generic_params(id.parent);\n-                    let param_data = &generic_params.types[id.local_id];\n-                    match param_data.provenance {\n-                        hir_def::generics::TypeParamProvenance::ArgumentImplTrait => {\n-                            let predicates: Vec<_> = db\n-                                .generic_predicates_for_param(*id)\n-                                .into_iter()\n-                                .map(|pred| pred.value.clone())\n-                                .collect();\n-                            push_bounds(db, &predicates, acc);\n-                        }\n-                        _ => (),\n+                Ty::Placeholder(_) => {\n+                    if let Some(trait_ref) = ty.impl_trait_ref(db) {\n+                        walk_trait(db, ty.clone(), &trait_ref, cb);\n                     }\n                 }\n-                Ty::Opaque(opaque_ty) => {\n-                    let bounds = match opaque_ty.opaque_ty_id {\n-                        OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n-                            let datas = db\n-                                .return_type_impl_traits(func)\n-                                .expect(\"impl trait id without data\");\n-                            let data = (*datas)\n-                                .as_ref()\n-                                .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                            data.clone().subst(&opaque_ty.parameters)\n-                        }\n-                    };\n-                    push_bounds(db, &bounds.value, acc);\n-                    walk_substs(db, &opaque_ty.parameters, acc);\n+                Ty::Dyn(_) => {\n+                    if let Some(trait_ref) = ty.dyn_trait_ref() {\n+                        walk_trait(db, ty.clone(), trait_ref, cb);\n+                    }\n                 }\n+\n                 _ => (),\n             }\n         }\n \n-        let mut res: Vec<ModuleDef> = Vec::new(); // not a Set to preserve the order\n-        walk_type(db, &self.ty.value, &mut res);\n-        res\n+        walk_ty(db, &self.ty.value, &mut cb);\n     }\n }\n "}, {"sha": "25ab9d87214ecf5a2087b27bf5d826054b5fa8eb", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4b07c1e77515ae9198aae6275700aacd43181b50/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b07c1e77515ae9198aae6275700aacd43181b50/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=4b07c1e77515ae9198aae6275700aacd43181b50", "patch": "@@ -877,6 +877,58 @@ impl Ty {\n             _ => None,\n         }\n     }\n+\n+    pub fn impl_trait_ref(&self, db: &dyn HirDatabase) -> Option<TraitRef> {\n+        match self {\n+            Ty::Opaque(opaque_ty) => {\n+                let predicates = match opaque_ty.opaque_ty_id {\n+                    OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n+                        db.return_type_impl_traits(func).map(|it| {\n+                            let data = (*it)\n+                                .as_ref()\n+                                .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                            data.clone().subst(&opaque_ty.parameters)\n+                        })\n+                    }\n+                };\n+\n+                predicates.and_then(|it| {\n+                    it.value.iter().find_map(|pred| match pred {\n+                        GenericPredicate::Implemented(tr) => Some(tr.clone()),\n+                        _ => None,\n+                    })\n+                })\n+            }\n+            Ty::Placeholder(id) => {\n+                let generic_params = db.generic_params(id.parent);\n+                let param_data = &generic_params.types[id.local_id];\n+                match param_data.provenance {\n+                    hir_def::generics::TypeParamProvenance::ArgumentImplTrait => db\n+                        .generic_predicates_for_param(*id)\n+                        .into_iter()\n+                        .map(|pred| pred.value.clone())\n+                        .find_map(|pred| match pred {\n+                            GenericPredicate::Implemented(tr) => Some(tr.clone()),\n+                            _ => None,\n+                        }),\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<TraitId> {\n+        match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::AssociatedType(type_alias_id), .. }) => {\n+                match type_alias_id.lookup(db.upcast()).container {\n+                    AssocContainerId::TraitId(trait_id) => Some(trait_id),\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n /// This allows walking structures that contain types to do something with those"}, {"sha": "c2909e200179f8e82265403816a522d58b2b7ca5", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4b07c1e77515ae9198aae6275700aacd43181b50/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b07c1e77515ae9198aae6275700aacd43181b50/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=4b07c1e77515ae9198aae6275700aacd43181b50", "patch": "@@ -236,17 +236,34 @@ fn runnable_action(\n fn goto_type_action(db: &RootDatabase, def: Definition) -> Option<HoverAction> {\n     match def {\n         Definition::Local(it) => {\n-            let targets = it\n-                .ty(db)\n-                .flattened_type_items(db)\n+            let mut targets: Vec<ModuleDef> = Vec::new();\n+            let mut push_new_def = |item: ModuleDef| {\n+                if !targets.contains(&item) {\n+                    targets.push(item);\n+                }\n+            };\n+\n+            it.ty(db).walk(db, |t| {\n+                if let Some(adt) = t.as_adt() {\n+                    push_new_def(adt.into());\n+                } else if let Some(trait_) = t.as_dyn_trait() {\n+                    push_new_def(trait_.into());\n+                } else if let Some(trait_) = t.as_impl_trait(db) {\n+                    push_new_def(trait_.into());\n+                } else if let Some(trait_) = t.as_associated_type_parent_trait(db) {\n+                    push_new_def(trait_.into());\n+                }\n+            });\n+\n+            let targets = targets\n                 .into_iter()\n                 .filter_map(|it| {\n                     Some(HoverGotoTypeData {\n                         mod_path: mod_path(db, &it)?,\n                         nav: it.try_to_nav(db)?,\n                     })\n                 })\n-                .collect_vec();\n+                .collect();\n \n             Some(HoverAction::GoToType(targets))\n         }"}]}