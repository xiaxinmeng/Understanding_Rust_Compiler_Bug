{"sha": "2d5e3f311841617eba62089212c1b43120c13921", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNWUzZjMxMTg0MTYxN2ViYTYyMDg5MjEyYzFiNDMxMjBjMTM5MjE=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-25T22:22:17Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-28T16:05:43Z"}, "message": "Lint transmute from ptr to ref", "tree": {"sha": "f2d261cc55a15a8d6af48874d15a368a24c793fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2d261cc55a15a8d6af48874d15a368a24c793fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d5e3f311841617eba62089212c1b43120c13921", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d5e3f311841617eba62089212c1b43120c13921", "html_url": "https://github.com/rust-lang/rust/commit/2d5e3f311841617eba62089212c1b43120c13921", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d5e3f311841617eba62089212c1b43120c13921/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae24929cd65ab2ab50a6ae7bba2a03e93e573c84", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae24929cd65ab2ab50a6ae7bba2a03e93e573c84", "html_url": "https://github.com/rust-lang/rust/commit/ae24929cd65ab2ab50a6ae7bba2a03e93e573c84"}], "stats": {"total": 154, "additions": 114, "deletions": 40}, "files": [{"sha": "95ba6b08539a1306e444459b01a32a143f8e85a8", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d5e3f311841617eba62089212c1b43120c13921/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/2d5e3f311841617eba62089212c1b43120c13921/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=2d5e3f311841617eba62089212c1b43120c13921", "patch": "@@ -14,7 +14,7 @@ Table of contents:\n * [License](#license)\n \n ##Lints\n-There are 135 lints included in this crate:\n+There are 136 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -133,6 +133,7 @@ name\n [temporary_assignment](https://github.com/Manishearth/rust-clippy/wiki#temporary_assignment)                         | warn    | assignments to temporaries\n [too_many_arguments](https://github.com/Manishearth/rust-clippy/wiki#too_many_arguments)                             | warn    | functions with too many arguments\n [toplevel_ref_arg](https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg)                                 | warn    | An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take references with `&`.\n+[transmute_ptr_to_ref](https://github.com/Manishearth/rust-clippy/wiki#transmute_ptr_to_ref)                         | warn    | transmutes from a pointer to a reference type\n [trivial_regex](https://github.com/Manishearth/rust-clippy/wiki#trivial_regex)                                       | warn    | finds trivial regular expressions in `Regex::new(_)` invocations\n [type_complexity](https://github.com/Manishearth/rust-clippy/wiki#type_complexity)                                   | warn    | usage of very complex types; recommends factoring out parts into `type` definitions\n [unicode_not_nfc](https://github.com/Manishearth/rust-clippy/wiki#unicode_not_nfc)                                   | allow   | using a unicode literal not in NFC normal form (see http://www.unicode.org/reports/tr15/ for further information)"}, {"sha": "7d24b2c89248289d9fb39e860ef3cebe3b60cbdc", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d5e3f311841617eba62089212c1b43120c13921/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5e3f311841617eba62089212c1b43120c13921/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2d5e3f311841617eba62089212c1b43120c13921", "patch": "@@ -195,8 +195,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box no_effect::NoEffectPass);\n     reg.register_late_lint_pass(box map_clone::MapClonePass);\n     reg.register_late_lint_pass(box temporary_assignment::TemporaryAssignmentPass);\n-    reg.register_late_lint_pass(box transmute::CrosspointerTransmute);\n-    reg.register_late_lint_pass(box transmute::UselessTransmute);\n+    reg.register_late_lint_pass(box transmute::Transmute);\n     reg.register_late_lint_pass(box cyclomatic_complexity::CyclomaticComplexity::new(conf.cyclomatic_complexity_threshold));\n     reg.register_late_lint_pass(box escape::EscapePass);\n     reg.register_early_lint_pass(box misc_early::MiscEarly);\n@@ -352,6 +351,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         swap::MANUAL_SWAP,\n         temporary_assignment::TEMPORARY_ASSIGNMENT,\n         transmute::CROSSPOINTER_TRANSMUTE,\n+        transmute::TRANSMUTE_PTR_TO_REF,\n         transmute::USELESS_TRANSMUTE,\n         types::ABSURD_EXTREME_COMPARISONS,\n         types::BOX_VEC,"}, {"sha": "ef049ba4a6dbd176abb5e215ea43a6d2f9c09e47", "filename": "src/transmute.rs", "status": "modified", "additions": 71, "deletions": 37, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/2d5e3f311841617eba62089212c1b43120c13921/src%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5e3f311841617eba62089212c1b43120c13921/src%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftransmute.rs?ref=2d5e3f311841617eba62089212c1b43120c13921", "patch": "@@ -1,9 +1,9 @@\n use rustc::lint::*;\n+use rustc::ty::TypeVariants::{TyRawPtr, TyRef};\n+use rustc::ty;\n use rustc_front::hir::*;\n-use rustc::ty::TyS;\n-use rustc::ty::TypeVariants::TyRawPtr;\n-use utils;\n use utils::TRANSMUTE_PATH;\n+use utils::{match_def_path, snippet_opt, span_lint, span_lint_and_then};\n \n /// **What it does:** This lint checks for transmutes to the original type of the object.\n ///\n@@ -31,72 +31,106 @@ declare_lint! {\n     \"transmutes that have to or from types that are a pointer to the other\"\n }\n \n-pub struct UselessTransmute;\n+/// **What it does:*** This lint checks for transmutes from a pointer to a reference.\n+///\n+/// **Why is this bad?** This can always be rewritten with `&` and `*`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let _: &T = std::mem::transmute(p); // where p: *const T\n+/// // can be written:\n+/// let _: &T = &*p;\n+/// ```\n+declare_lint! {\n+    pub TRANSMUTE_PTR_TO_REF,\n+    Warn,\n+    \"transmutes from a pointer to a reference type\"\n+}\n+\n+pub struct Transmute;\n \n-impl LintPass for UselessTransmute {\n+impl LintPass for Transmute {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(USELESS_TRANSMUTE)\n+        lint_array! [\n+            CROSSPOINTER_TRANSMUTE,\n+            TRANSMUTE_PTR_TO_REF,\n+            USELESS_TRANSMUTE\n+        ]\n     }\n }\n \n-impl LateLintPass for UselessTransmute {\n+impl LateLintPass for Transmute {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n             if let ExprPath(None, _) = path_expr.node {\n                 let def_id = cx.tcx.def_map.borrow()[&path_expr.id].def_id();\n \n-                if utils::match_def_path(cx, def_id, &TRANSMUTE_PATH) {\n+                if match_def_path(cx, def_id, &TRANSMUTE_PATH) {\n                     let from_ty = cx.tcx.expr_ty(&args[0]);\n                     let to_ty = cx.tcx.expr_ty(e);\n \n                     if from_ty == to_ty {\n-                        cx.span_lint(USELESS_TRANSMUTE,\n-                                     e.span,\n-                                     &format!(\"transmute from a type (`{}`) to itself\", from_ty));\n+                        span_lint(cx,\n+                                  USELESS_TRANSMUTE,\n+                                  e.span,\n+                                  &format!(\"transmute from a type (`{}`) to itself\", from_ty));\n+                    } else if is_ptr_to(to_ty, from_ty) {\n+                        span_lint(cx,\n+                                  CROSSPOINTER_TRANSMUTE,\n+                                  e.span,\n+                                  &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\", from_ty, to_ty));\n+                    } else if is_ptr_to(from_ty, to_ty) {\n+                        span_lint(cx,\n+                                  CROSSPOINTER_TRANSMUTE,\n+                                  e.span,\n+                                  &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\", from_ty, to_ty));\n+                    } else {\n+                        check_ptr_to_ref(cx, from_ty, to_ty, e, &args[0]);\n                     }\n                 }\n             }\n         }\n     }\n }\n \n-pub struct CrosspointerTransmute;\n-\n-impl LintPass for CrosspointerTransmute {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(CROSSPOINTER_TRANSMUTE)\n-    }\n-}\n-\n-fn is_ptr_to(from: &TyS, to: &TyS) -> bool {\n+fn is_ptr_to(from: ty::Ty, to: ty::Ty) -> bool {\n     if let TyRawPtr(from_ptr) = from.sty {\n         from_ptr.ty == to\n     } else {\n         false\n     }\n }\n \n-impl LateLintPass for CrosspointerTransmute {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n-        if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(None, _) = path_expr.node {\n-                let def_id = cx.tcx.def_map.borrow()[&path_expr.id].def_id();\n+fn check_ptr_to_ref<'tcx>(cx: &LateContext,\n+                          from_ty: ty::Ty<'tcx>,\n+                          to_ty: ty::Ty<'tcx>,\n+                          e: &Expr, arg: &Expr) {\n+    if let TyRawPtr(ref from_pty) = from_ty.sty {\n+        if let TyRef(_, ref to_rty) = to_ty.sty {\n+            let mess = format!(\"transmute from a pointer type (`{}`) to a reference type (`{}`)\",\n+                               from_ty,\n+                               to_ty);\n+            span_lint_and_then(cx, TRANSMUTE_PTR_TO_REF, e.span, &mess, |db| {\n+                if let Some(arg) = snippet_opt(cx, arg.span) {\n+                    let (deref, cast) = if to_rty.mutbl == Mutability::MutMutable {\n+                        (\"&mut *\", \"*mut\")\n+                    } else {\n+                        (\"&*\", \"*const\")\n+                    };\n \n-                if utils::match_def_path(cx, def_id, &TRANSMUTE_PATH) {\n-                    let from_ty = cx.tcx.expr_ty(&args[0]);\n-                    let to_ty = cx.tcx.expr_ty(e);\n \n-                    if is_ptr_to(to_ty, from_ty) {\n-                        cx.span_lint(CROSSPOINTER_TRANSMUTE,\n-                                     e.span,\n-                                     &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\", from_ty, to_ty));\n-                    } else if is_ptr_to(from_ty, to_ty) {\n-                        cx.span_lint(CROSSPOINTER_TRANSMUTE,\n-                                     e.span,\n-                                     &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\", from_ty, to_ty));\n+                    let sugg = if from_pty.ty == to_rty.ty {\n+                        format!(\"{}{}\", deref, arg)\n                     }\n+                    else {\n+                        format!(\"{}({} as {} {})\", deref, arg, cast, to_rty.ty)\n+                    };\n+\n+                    db.span_suggestion(e.span, \"try\", sugg);\n                 }\n-            }\n+            });\n         }\n     }\n }"}, {"sha": "5bae2c726438cd5a1d3dc9109c3edb4bd9eb2cd3", "filename": "tests/compile-fail/transmute.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2d5e3f311841617eba62089212c1b43120c13921/tests%2Fcompile-fail%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d5e3f311841617eba62089212c1b43120c13921/tests%2Fcompile-fail%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftransmute.rs?ref=2d5e3f311841617eba62089212c1b43120c13921", "patch": "@@ -19,6 +19,45 @@ unsafe fn _generic<'a, T, U: 'a>(t: &'a T) {\n     let _: &'a U = core::intrinsics::transmute(t);\n }\n \n+#[deny(transmute_ptr_to_ref)]\n+unsafe fn _ptr_to_ref<T, U>(p: *const T, m: *mut T, o: *const U, om: *mut U) {\n+    let _: &T = std::mem::transmute(p);\n+    //~^ ERROR transmute from a pointer type (`*const T`) to a reference type (`&T`)\n+    //~| HELP try\n+    //~| SUGGESTION = &*p;\n+    let _: &T = &*p;\n+\n+    let _: &mut T = std::mem::transmute(m);\n+    //~^ ERROR transmute from a pointer type (`*mut T`) to a reference type (`&mut T`)\n+    //~| HELP try\n+    //~| SUGGESTION = &mut *m;\n+    let _: &mut T = &mut *m;\n+\n+    let _: &T = std::mem::transmute(m);\n+    //~^ ERROR transmute from a pointer type (`*mut T`) to a reference type (`&T`)\n+    //~| HELP try\n+    //~| SUGGESTION = &*m;\n+    let _: &T = &*m;\n+\n+    let _: &T = std::mem::transmute(o);\n+    //~^ ERROR transmute from a pointer type (`*const U`) to a reference type (`&T`)\n+    //~| HELP try\n+    //~| SUGGESTION = &*(o as *const T);\n+    let _: &T = &*(o as *const T);\n+\n+    let _: &mut T = std::mem::transmute(om);\n+    //~^ ERROR transmute from a pointer type (`*mut U`) to a reference type (`&mut T`)\n+    //~| HELP try\n+    //~| SUGGESTION = &mut *(om as *mut T);\n+    let _: &mut T = &mut *(om as *mut T);\n+\n+    let _: &T = std::mem::transmute(om);\n+    //~^ ERROR transmute from a pointer type (`*mut U`) to a reference type (`&T`)\n+    //~| HELP try\n+    //~| SUGGESTION = &*(om as *const T);\n+    let _: &T = &*(om as *const T);\n+}\n+\n #[deny(useless_transmute)]\n fn useless() {\n     unsafe {"}]}