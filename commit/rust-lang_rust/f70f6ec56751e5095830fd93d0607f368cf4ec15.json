{"sha": "f70f6ec56751e5095830fd93d0607f368cf4ec15", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3MGY2ZWM1Njc1MWU1MDk1ODMwZmQ5M2QwNjA3ZjM2OGNmNGVjMTU=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-10-02T20:54:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-02T20:54:29Z"}, "message": "Rollup merge of #54603 - davidtwco:issue-54559, r=nikomatsakis\n\nAdd `crate::` to trait suggestions in Rust 2018.\n\nFixes #54559.\n\nIn the 2018 edition, when suggesting traits to import that implement a\ngiven method that is being invoked, suggestions will now include the\n`crate::` prefix if the suggested trait is local to the current crate.\n\nr? @nikomatsakis", "tree": {"sha": "a89afe9780f1e2986989b150f1653df188631f03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a89afe9780f1e2986989b150f1653df188631f03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f70f6ec56751e5095830fd93d0607f368cf4ec15", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbs9sFCRBK7hj4Ov3rIwAAdHIIADNUtn2WgIubbXBONlHLXy1x\nZrcrQ3r8UYhpRqme2hSuykDbdUnhtT0EjIgQ4gu7VIQfmfTHP8pex3LX4+weeg00\naGtcqulsCidOaX/yyyw3aUkcsXz5YnnpgDVmfd0UfHjyoPOiSs++7A/rsZywBUnY\nqZOr2GByZlffbVzSJbD7h+AoYQPkPDG7rqBC9M3IiIw490YpkIshSURTGzCNimPq\nDZkzOkZSglURUXQmio+rX9oSRYuVjk+H6uVJNsx3xHrXimYYBK9BDRzGEjItmZY8\ncBM5Ma/hTQTib944qrseVMO7oLuTn64INwmozRxjv6t3F4cnmzseDIpyHoEAzgs=\n=/dSy\n-----END PGP SIGNATURE-----\n", "payload": "tree a89afe9780f1e2986989b150f1653df188631f03\nparent ab338eadfacb7651540ef5f1babbc8d18f4ab451\nparent 02357e459be7fb2014f57f1a86b38897c2c0816b\nauthor Pietro Albini <pietro@pietroalbini.org> 1538513669 +0200\ncommitter GitHub <noreply@github.com> 1538513669 +0200\n\nRollup merge of #54603 - davidtwco:issue-54559, r=nikomatsakis\n\nAdd `crate::` to trait suggestions in Rust 2018.\n\nFixes #54559.\n\nIn the 2018 edition, when suggesting traits to import that implement a\ngiven method that is being invoked, suggestions will now include the\n`crate::` prefix if the suggested trait is local to the current crate.\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f70f6ec56751e5095830fd93d0607f368cf4ec15", "html_url": "https://github.com/rust-lang/rust/commit/f70f6ec56751e5095830fd93d0607f368cf4ec15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f70f6ec56751e5095830fd93d0607f368cf4ec15/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab338eadfacb7651540ef5f1babbc8d18f4ab451", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab338eadfacb7651540ef5f1babbc8d18f4ab451", "html_url": "https://github.com/rust-lang/rust/commit/ab338eadfacb7651540ef5f1babbc8d18f4ab451"}, {"sha": "02357e459be7fb2014f57f1a86b38897c2c0816b", "url": "https://api.github.com/repos/rust-lang/rust/commits/02357e459be7fb2014f57f1a86b38897c2c0816b", "html_url": "https://github.com/rust-lang/rust/commit/02357e459be7fb2014f57f1a86b38897c2c0816b"}], "stats": {"total": 290, "additions": 241, "deletions": 49}, "files": [{"sha": "3c209a4324675a5b0681375b7f9b75869f0d2ae0", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=f70f6ec56751e5095830fd93d0607f368cf4ec15", "patch": "@@ -28,17 +28,16 @@ use util::common::ProfileQueriesMsg;\n use rustc_data_structures::base_n;\n use rustc_data_structures::sync::{self, Lrc, Lock, LockCell, OneThread, Once, RwLock};\n \n-use syntax::ast::NodeId;\n use errors::{self, DiagnosticBuilder, DiagnosticId, Applicability};\n use errors::emitter::{Emitter, EmitterWriter};\n+use syntax::ast::{self, NodeId};\n use syntax::edition::Edition;\n+use syntax::feature_gate::{self, AttributeType};\n use syntax::json::JsonEmitter;\n-use syntax::feature_gate;\n-use syntax::parse;\n-use syntax::parse::ParseSess;\n-use syntax::{ast, source_map};\n-use syntax::feature_gate::AttributeType;\n-use syntax_pos::{MultiSpan, Span, symbol::Symbol};\n+use syntax::source_map;\n+use syntax::symbol::Symbol;\n+use syntax::parse::{self, ParseSess};\n+use syntax_pos::{MultiSpan, Span};\n use util::profiling::SelfProfiler;\n \n use rustc_target::spec::PanicStrategy;"}, {"sha": "c8d104e6c321f4c6e3d88a2a412e617660ed96c7", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 113, "deletions": 34, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=f70f6ec56751e5095830fd93d0607f368cf4ec15", "patch": "@@ -13,14 +13,16 @@ use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use middle::cstore::{ExternCrate, ExternCrateSource};\n use syntax::ast;\n-use syntax::symbol::Symbol;\n-use syntax::symbol::LocalInternedString;\n+use syntax::symbol::{keywords, LocalInternedString, Symbol};\n+use syntax_pos::edition::Edition;\n \n use std::cell::Cell;\n+use std::fmt::Debug;\n \n thread_local! {\n     static FORCE_ABSOLUTE: Cell<bool> = Cell::new(false);\n     static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n+    static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = Cell::new(false);\n }\n \n /// Enforces that item_path_str always returns an absolute path and\n@@ -51,6 +53,17 @@ pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n     })\n }\n \n+/// Add the `crate::` prefix to paths where appropriate.\n+pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n+    SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n+        let old = flag.get();\n+        flag.set(true);\n+        let result = f();\n+        flag.set(old);\n+        result\n+    })\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It is relative to the current crate\n@@ -64,7 +77,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n         });\n         let mut buffer = LocalPathBuffer::new(mode);\n-        self.push_item_path(&mut buffer, def_id);\n+        debug!(\"item_path_str: buffer={:?} def_id={:?}\", buffer, def_id);\n+        self.push_item_path(&mut buffer, def_id, false);\n         buffer.into_string()\n     }\n \n@@ -77,16 +91,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// suitable for user output. It always begins with a crate identifier.\n     pub fn absolute_item_path_str(self, def_id: DefId) -> String {\n         let mut buffer = LocalPathBuffer::new(RootMode::Absolute);\n-        self.push_item_path(&mut buffer, def_id);\n+        debug!(\"absolute_item_path_str: buffer={:?} def_id={:?}\", buffer, def_id);\n+        self.push_item_path(&mut buffer, def_id, false);\n         buffer.into_string()\n     }\n \n     /// Returns the \"path\" to a particular crate. This can proceed in\n     /// various ways, depending on the `root_mode` of the `buffer`.\n     /// (See `RootMode` enum for more details.)\n-    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: CrateNum)\n-        where T: ItemPathBuffer\n+    ///\n+    /// `pushed_prelude_crate` argument should be `true` when the buffer\n+    /// has had a prelude crate pushed to it. If this is the case, then\n+    /// we do not want to prepend `crate::` (as that would not be a valid\n+    /// path).\n+    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: CrateNum, pushed_prelude_crate: bool)\n+        where T: ItemPathBuffer + Debug\n     {\n+        debug!(\n+            \"push_krate_path: buffer={:?} cnum={:?} LOCAL_CRATE={:?}\",\n+            buffer, cnum, LOCAL_CRATE\n+        );\n         match *buffer.root_mode() {\n             RootMode::Local => {\n                 // In local mode, when we encounter a crate other than\n@@ -109,30 +133,56 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         ..\n                     }) = *opt_extern_crate\n                     {\n-                        self.push_item_path(buffer, def_id);\n+                        debug!(\"push_krate_path: def_id={:?}\", def_id);\n+                        self.push_item_path(buffer, def_id, pushed_prelude_crate);\n                     } else {\n-                        buffer.push(&self.crate_name(cnum).as_str());\n+                        let name = self.crate_name(cnum).as_str();\n+                        debug!(\"push_krate_path: name={:?}\", name);\n+                        buffer.push(&name);\n                     }\n+                } else if self.sess.edition() == Edition::Edition2018 && !pushed_prelude_crate {\n+                    SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n+                        // We only add the `crate::` keyword where appropriate. In particular,\n+                        // when we've not previously pushed a prelude crate to this path.\n+                        if flag.get() {\n+                            buffer.push(&keywords::Crate.name().as_str())\n+                        }\n+                    })\n                 }\n             }\n             RootMode::Absolute => {\n                 // In absolute mode, just write the crate name\n                 // unconditionally.\n-                buffer.push(&self.original_crate_name(cnum).as_str());\n+                let name = self.original_crate_name(cnum).as_str();\n+                debug!(\"push_krate_path: original_name={:?}\", name);\n+                buffer.push(&name);\n             }\n         }\n     }\n \n     /// If possible, this pushes a global path resolving to `external_def_id` that is visible\n     /// from at least one local module and returns true. If the crate defining `external_def_id` is\n     /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n-    pub fn try_push_visible_item_path<T>(self, buffer: &mut T, external_def_id: DefId) -> bool\n-        where T: ItemPathBuffer\n+    pub fn try_push_visible_item_path<T>(\n+        self,\n+        buffer: &mut T,\n+        external_def_id: DefId,\n+        pushed_prelude_crate: bool,\n+    ) -> bool\n+        where T: ItemPathBuffer + Debug\n     {\n+        debug!(\n+            \"try_push_visible_item_path: buffer={:?} external_def_id={:?}\",\n+            buffer, external_def_id\n+        );\n         let visible_parent_map = self.visible_parent_map(LOCAL_CRATE);\n \n         let (mut cur_def, mut cur_path) = (external_def_id, Vec::<LocalInternedString>::new());\n         loop {\n+            debug!(\n+                \"try_push_visible_item_path: cur_def={:?} cur_path={:?} CRATE_DEF_INDEX={:?}\",\n+                cur_def, cur_path, CRATE_DEF_INDEX,\n+            );\n             // If `cur_def` is a direct or injected extern crate, push the path to the crate\n             // followed by the path to the item within the crate and return.\n             if cur_def.index == CRATE_DEF_INDEX {\n@@ -142,7 +192,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         direct: true,\n                         ..\n                     }) => {\n-                        self.push_item_path(buffer, def_id);\n+                        debug!(\"try_push_visible_item_path: def_id={:?}\", def_id);\n+                        self.push_item_path(buffer, def_id, pushed_prelude_crate);\n                         cur_path.iter().rev().for_each(|segment| buffer.push(&segment));\n                         return true;\n                     }\n@@ -156,6 +207,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             let mut cur_def_key = self.def_key(cur_def);\n+            debug!(\"try_push_visible_item_path: cur_def_key={:?}\", cur_def_key);\n \n             // For a UnitStruct or TupleStruct we want the name of its parent rather than <unnamed>.\n             if let DefPathData::StructCtor = cur_def_key.disambiguated_data.data {\n@@ -175,6 +227,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     Symbol::intern(\"<unnamed>\").as_str()\n                 }\n             });\n+            debug!(\"try_push_visible_item_path: symbol={:?}\", symbol);\n             cur_path.push(symbol);\n \n             match visible_parent_map.get(&cur_def) {\n@@ -184,24 +237,29 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn push_item_path<T>(self, buffer: &mut T, def_id: DefId)\n-        where T: ItemPathBuffer\n+    pub fn push_item_path<T>(self, buffer: &mut T, def_id: DefId, pushed_prelude_crate: bool)\n+        where T: ItemPathBuffer + Debug\n     {\n+        debug!(\n+            \"push_item_path: buffer={:?} def_id={:?} pushed_prelude_crate={:?}\",\n+            buffer, def_id, pushed_prelude_crate\n+        );\n         match *buffer.root_mode() {\n             RootMode::Local if !def_id.is_local() =>\n-                if self.try_push_visible_item_path(buffer, def_id) { return },\n+                if self.try_push_visible_item_path(buffer, def_id, pushed_prelude_crate) { return },\n             _ => {}\n         }\n \n         let key = self.def_key(def_id);\n+        debug!(\"push_item_path: key={:?}\", key);\n         match key.disambiguated_data.data {\n             DefPathData::CrateRoot => {\n                 assert!(key.parent.is_none());\n-                self.push_krate_path(buffer, def_id.krate);\n+                self.push_krate_path(buffer, def_id.krate, pushed_prelude_crate);\n             }\n \n             DefPathData::Impl => {\n-                self.push_impl_path(buffer, def_id);\n+                self.push_impl_path(buffer, def_id, pushed_prelude_crate);\n             }\n \n             // Unclear if there is any value in distinguishing these.\n@@ -224,22 +282,40 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::ClosureExpr |\n             data @ DefPathData::ImplTrait |\n             data @ DefPathData::GlobalMetaData(..) => {\n-                let parent_def_id = self.parent_def_id(def_id).unwrap();\n-                self.push_item_path(buffer, parent_def_id);\n+                let parent_did = self.parent_def_id(def_id).unwrap();\n+\n+                // Keep track of whether we are one recursion away from the `CrateRoot` and\n+                // pushing the name of a prelude crate. If we are, we'll want to know this when\n+                // printing the `CrateRoot` so we don't prepend a `crate::` to paths.\n+                let mut is_prelude_crate = false;\n+                if let DefPathData::CrateRoot = self.def_key(parent_did).disambiguated_data.data {\n+                    if self.sess.extern_prelude.contains(&data.as_interned_str().as_symbol()) {\n+                        is_prelude_crate = true;\n+                    }\n+                }\n+\n+                self.push_item_path(\n+                    buffer, parent_did, pushed_prelude_crate || is_prelude_crate\n+                );\n                 buffer.push(&data.as_interned_str().as_symbol().as_str());\n-            }\n+            },\n+\n             DefPathData::StructCtor => { // present `X` instead of `X::{{constructor}}`\n                 let parent_def_id = self.parent_def_id(def_id).unwrap();\n-                self.push_item_path(buffer, parent_def_id);\n+                self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n             }\n         }\n     }\n \n-    fn push_impl_path<T>(self,\n-                         buffer: &mut T,\n-                         impl_def_id: DefId)\n-        where T: ItemPathBuffer\n+    fn push_impl_path<T>(\n+        self,\n+         buffer: &mut T,\n+         impl_def_id: DefId,\n+         pushed_prelude_crate: bool,\n+    )\n+        where T: ItemPathBuffer + Debug\n     {\n+        debug!(\"push_impl_path: buffer={:?} impl_def_id={:?}\", buffer, impl_def_id);\n         let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n \n         // Always use types for non-local impls, where types are always\n@@ -251,7 +327,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if !use_types {\n-            return self.push_impl_path_fallback(buffer, impl_def_id);\n+            return self.push_impl_path_fallback(buffer, impl_def_id, pushed_prelude_crate);\n         }\n \n         // Decide whether to print the parent path for the impl.\n@@ -275,7 +351,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // If the impl is not co-located with either self-type or\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n-            self.push_item_path(buffer, parent_def_id);\n+            self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n             if let Some(trait_ref) = impl_trait_ref {\n                 buffer.push(&format!(\"<impl {} for {}>\", trait_ref, self_ty));\n             } else {\n@@ -301,13 +377,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self_ty.sty {\n             ty::Adt(adt_def, substs) => {\n                 if substs.types().next().is_none() { // ignore regions\n-                    self.push_item_path(buffer, adt_def.did);\n+                    self.push_item_path(buffer, adt_def.did, pushed_prelude_crate);\n                 } else {\n                     buffer.push(&format!(\"<{}>\", self_ty));\n                 }\n             }\n \n-            ty::Foreign(did) => self.push_item_path(buffer, did),\n+            ty::Foreign(did) => self.push_item_path(buffer, did, pushed_prelude_crate),\n \n             ty::Bool |\n             ty::Char |\n@@ -324,16 +400,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn push_impl_path_fallback<T>(self,\n-                                  buffer: &mut T,\n-                                  impl_def_id: DefId)\n-        where T: ItemPathBuffer\n+    fn push_impl_path_fallback<T>(\n+        self,\n+        buffer: &mut T,\n+        impl_def_id: DefId,\n+        pushed_prelude_crate: bool,\n+    )\n+        where T: ItemPathBuffer + Debug\n     {\n         // If no type info is available, fall back to\n         // pretty printing some span information. This should\n         // only occur very early in the compiler pipeline.\n         let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n-        self.push_item_path(buffer, parent_def_id);\n+        self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n         let node_id = self.hir.as_local_node_id(impl_def_id).unwrap();\n         let item = self.hir.expect_item(node_id);\n         let span_str = self.sess.source_map().span_to_string(item.span);"}, {"sha": "c1e80234a775010067889c7dbb855e541a811e25", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=f70f6ec56751e5095830fd93d0607f368cf4ec15", "patch": "@@ -228,7 +228,7 @@ fn get_symbol_hash<'a, 'tcx>(\n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n     let mut buffer = SymbolPathBuffer::new();\n     item_path::with_forced_absolute_paths(|| {\n-        tcx.push_item_path(&mut buffer, def_id);\n+        tcx.push_item_path(&mut buffer, def_id, false);\n     });\n     buffer.into_interned()\n }\n@@ -338,6 +338,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n //\n // To be able to work on all platforms and get *some* reasonable output, we\n // use C++ name-mangling.\n+#[derive(Debug)]\n struct SymbolPathBuffer {\n     result: String,\n     temp_buf: String,"}, {"sha": "28b9dcb9bfdd1abf571baba484a740e87f5484df", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f70f6ec56751e5095830fd93d0607f368cf4ec15", "patch": "@@ -16,6 +16,7 @@ use rustc::hir::map as hir_map;\n use hir::Node;\n use rustc_data_structures::sync::Lrc;\n use rustc::ty::{self, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n+use rustc::ty::item_path::with_crate_prefix;\n use hir::def::Def;\n use hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::lang_items::FnOnceTraitLangItem;\n@@ -515,7 +516,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 } else {\n                     \"\\n\"\n                 };\n-                format!(\"use {};\\n{}\", self.tcx.item_path_str(*did), additional_newline)\n+                format!(\n+                    \"use {};\\n{}\",\n+                    with_crate_prefix(|| self.tcx.item_path_str(*did)),\n+                    additional_newline\n+                )\n             }).collect();\n \n             err.span_suggestions_with_applicability(\n@@ -528,12 +533,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let limit = if candidates.len() == 5 { 5 } else { 4 };\n             for (i, trait_did) in candidates.iter().take(limit).enumerate() {\n                 if candidates.len() > 1 {\n-                    msg.push_str(&format!(\"\\ncandidate #{}: `use {};`\",\n-                                            i + 1,\n-                                            self.tcx.item_path_str(*trait_did)));\n+                    msg.push_str(\n+                        &format!(\n+                            \"\\ncandidate #{}: `use {};`\",\n+                            i + 1,\n+                            with_crate_prefix(|| self.tcx.item_path_str(*trait_did))\n+                        )\n+                    );\n                 } else {\n-                    msg.push_str(&format!(\"\\n`use {};`\",\n-                                            self.tcx.item_path_str(*trait_did)));\n+                    msg.push_str(\n+                        &format!(\n+                            \"\\n`use {};`\",\n+                            with_crate_prefix(|| self.tcx.item_path_str(*trait_did))\n+                        )\n+                    );\n                 }\n             }\n             if candidates.len() > limit {"}, {"sha": "371b631723a39bb35beea29188331c330892e215", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f70f6ec56751e5095830fd93d0607f368cf4ec15", "patch": "@@ -3990,6 +3990,7 @@ pub fn path_to_def(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n \n pub fn get_path_for_type<F>(tcx: TyCtxt, def_id: DefId, def_ctor: F) -> hir::Path\n where F: Fn(DefId) -> Def {\n+    #[derive(Debug)]\n     struct AbsolutePathBuffer {\n         names: Vec<String>,\n     }\n@@ -4007,7 +4008,7 @@ where F: Fn(DefId) -> Def {\n \n     let mut apb = AbsolutePathBuffer { names: vec![] };\n \n-    tcx.push_item_path(&mut apb, def_id);\n+    tcx.push_item_path(&mut apb, def_id, false);\n \n     hir::Path {\n         span: DUMMY_SP,"}, {"sha": "611fa83854b9be2cd06d245a498652f382212b42", "filename": "src/test/ui/rust-2018/auxiliary/trait-import-suggestions.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Ftest%2Fui%2Frust-2018%2Fauxiliary%2Ftrait-import-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Ftest%2Fui%2Frust-2018%2Fauxiliary%2Ftrait-import-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fauxiliary%2Ftrait-import-suggestions.rs?ref=f70f6ec56751e5095830fd93d0607f368cf4ec15", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Baz {\n+    fn baz(&self) { }\n+}\n+\n+impl Baz for u32 { }"}, {"sha": "d603d8212ed377343c64c67a8468473e015678d8", "filename": "src/test/ui/rust-2018/trait-import-suggestions.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Ftest%2Fui%2Frust-2018%2Ftrait-import-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Ftest%2Fui%2Frust-2018%2Ftrait-import-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Ftrait-import-suggestions.rs?ref=f70f6ec56751e5095830fd93d0607f368cf4ec15", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+// aux-build:trait-import-suggestions.rs\n+// compile-flags:--extern trait-import-suggestions\n+\n+mod foo {\n+    mod foobar {\n+        pub(crate) trait Foobar {\n+            fn foobar(&self) { }\n+        }\n+\n+        impl Foobar for u32 { }\n+    }\n+\n+    pub(crate) trait Bar {\n+        fn bar(&self) { }\n+    }\n+\n+    impl Bar for u32 { }\n+\n+    fn in_foo() {\n+        let x: u32 = 22;\n+        x.foobar();\n+    }\n+}\n+\n+fn main() {\n+    let x: u32 = 22;\n+    x.bar();\n+    x.baz();\n+    let y = u32::from_str(\"33\");\n+}"}, {"sha": "59fe7b958e3458e428930faefb8757bb1315295c", "filename": "src/test/ui/rust-2018/trait-import-suggestions.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Ftest%2Fui%2Frust-2018%2Ftrait-import-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f70f6ec56751e5095830fd93d0607f368cf4ec15/src%2Ftest%2Fui%2Frust-2018%2Ftrait-import-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Ftrait-import-suggestions.stderr?ref=f70f6ec56751e5095830fd93d0607f368cf4ec15", "patch": "@@ -0,0 +1,43 @@\n+error[E0599]: no method named `foobar` found for type `u32` in the current scope\n+  --> $DIR/trait-import-suggestions.rs:32:11\n+   |\n+LL |         x.foobar();\n+   |           ^^^^^^\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+           `use crate::foo::foobar::Foobar;`\n+\n+error[E0599]: no method named `bar` found for type `u32` in the current scope\n+  --> $DIR/trait-import-suggestions.rs:38:7\n+   |\n+LL |     x.bar();\n+   |       ^^^\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+   |\n+LL | use crate::foo::Bar;\n+   |\n+\n+error[E0599]: no method named `baz` found for type `u32` in the current scope\n+  --> $DIR/trait-import-suggestions.rs:39:7\n+   |\n+LL |     x.baz();\n+   |       ^^^\n+\n+error[E0599]: no function or associated item named `from_str` found for type `u32` in the current scope\n+  --> $DIR/trait-import-suggestions.rs:40:13\n+   |\n+LL |     let y = u32::from_str(\"33\");\n+   |             ^^^^^^^^^^^^^ function or associated item not found in `u32`\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+help: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+   |\n+LL | use std::str::FromStr;\n+   |\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}]}