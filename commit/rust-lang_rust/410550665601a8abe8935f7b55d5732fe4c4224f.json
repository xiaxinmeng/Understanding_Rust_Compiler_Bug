{"sha": "410550665601a8abe8935f7b55d5732fe4c4224f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMDU1MDY2NTYwMWE4YWJlODkzNWY3YjU1ZDU3MzJmZTRjNDIyNGY=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-11-01T18:59:24Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2021-01-31T13:58:03Z"}, "message": "specialize io::copy to use the memory of the writer if it is a BufWriter", "tree": {"sha": "20f3e1a0e45fdd069ccfda668b2541306aac02a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20f3e1a0e45fdd069ccfda668b2541306aac02a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/410550665601a8abe8935f7b55d5732fe4c4224f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/410550665601a8abe8935f7b55d5732fe4c4224f", "html_url": "https://github.com/rust-lang/rust/commit/410550665601a8abe8935f7b55d5732fe4c4224f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/410550665601a8abe8935f7b55d5732fe4c4224f/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e63af5da3400ace48a0345117980473fd21ad73", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e63af5da3400ace48a0345117980473fd21ad73", "html_url": "https://github.com/rust-lang/rust/commit/0e63af5da3400ace48a0345117980473fd21ad73"}], "stats": {"total": 146, "additions": 138, "deletions": 8}, "files": [{"sha": "65bc2fcf00ae02dc9f8ff23f5cdf7f213e79c401", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/410550665601a8abe8935f7b55d5732fe4c4224f/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/410550665601a8abe8935f7b55d5732fe4c4224f/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=410550665601a8abe8935f7b55d5732fe4c4224f", "patch": "@@ -117,7 +117,7 @@ impl<W: Write> BufWriter<W> {\n     /// \"successfully written\" (by returning nonzero success values from\n     /// `write`), any 0-length writes from `inner` must be reported as i/o\n     /// errors from this method.\n-    pub(super) fn flush_buf(&mut self) -> io::Result<()> {\n+    pub(in crate::io) fn flush_buf(&mut self) -> io::Result<()> {\n         /// Helper struct to ensure the buffer is updated after all the writes\n         /// are complete. It tracks the number of written bytes and drains them\n         /// all from the front of the buffer when dropped.\n@@ -243,6 +243,18 @@ impl<W: Write> BufWriter<W> {\n         &self.buf\n     }\n \n+    /// Returns a mutable reference to the internal buffer.\n+    ///\n+    /// This can be used to write data directly into the buffer without triggering writers\n+    /// to the underlying writer.\n+    ///\n+    /// That the buffer is a `Vec` is an implementation detail.\n+    /// Callers should not modify the capacity as there currently is no public API to do so\n+    /// and thus any capacity changes would be unexpected by the user.\n+    pub(in crate::io) fn buffer_mut(&mut self) -> &mut Vec<u8> {\n+        &mut self.buf\n+    }\n+\n     /// Returns the number of bytes the internal buffer can hold without flushing.\n     ///\n     /// # Examples"}, {"sha": "3780f2044cb9039659c0d0262a78e4b6c9210e12", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 74, "deletions": 6, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/410550665601a8abe8935f7b55d5732fe4c4224f/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/410550665601a8abe8935f7b55d5732fe4c4224f/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=410550665601a8abe8935f7b55d5732fe4c4224f", "patch": "@@ -1,4 +1,4 @@\n-use crate::io::{self, ErrorKind, Read, Write};\n+use super::{BufWriter, ErrorKind, Read, Result, Write, DEFAULT_BUF_SIZE};\n use crate::mem::MaybeUninit;\n \n /// Copies the entire contents of a reader into a writer.\n@@ -40,7 +40,7 @@ use crate::mem::MaybeUninit;\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n+pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> Result<u64>\n where\n     R: Read,\n     W: Write,\n@@ -54,14 +54,82 @@ where\n     }\n }\n \n-/// The general read-write-loop implementation of\n-/// `io::copy` that is used when specializations are not available or not applicable.\n-pub(crate) fn generic_copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n+/// The userspace read-write-loop implementation of `io::copy` that is used when\n+/// OS-specific specializations for copy offloading are not available or not applicable.\n+pub(crate) fn generic_copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> Result<u64>\n where\n     R: Read,\n     W: Write,\n {\n-    let mut buf = MaybeUninit::<[u8; super::DEFAULT_BUF_SIZE]>::uninit();\n+    BufferedCopySpec::copy_to(reader, writer)\n+}\n+\n+/// Specialization of the read-write loop that either uses a stack buffer\n+/// or reuses the internal buffer of a BufWriter\n+trait BufferedCopySpec: Write {\n+    fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64>;\n+}\n+\n+impl<W: Write + ?Sized> BufferedCopySpec for W {\n+    default fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n+        stack_buffer_copy(reader, writer)\n+    }\n+}\n+\n+impl<I: Write> BufferedCopySpec for BufWriter<I> {\n+    fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n+        if writer.capacity() < DEFAULT_BUF_SIZE {\n+            return stack_buffer_copy(reader, writer);\n+        }\n+\n+        // FIXME: #42788\n+        //\n+        //   - This creates a (mut) reference to a slice of\n+        //     _uninitialized_ integers, which is **undefined behavior**\n+        //\n+        //   - Only the standard library gets to soundly \"ignore\" this,\n+        //     based on its privileged knowledge of unstable rustc\n+        //     internals;\n+        unsafe {\n+            let spare_cap = writer.buffer_mut().spare_capacity_mut();\n+            reader.initializer().initialize(MaybeUninit::slice_assume_init_mut(spare_cap));\n+        }\n+\n+        let mut len = 0;\n+\n+        loop {\n+            let buf = writer.buffer_mut();\n+            let spare_cap = buf.spare_capacity_mut();\n+\n+            if spare_cap.len() >= DEFAULT_BUF_SIZE {\n+                match reader.read(unsafe { MaybeUninit::slice_assume_init_mut(spare_cap) }) {\n+                    Ok(0) => return Ok(len), // EOF reached\n+                    Ok(bytes_read) => {\n+                        assert!(bytes_read <= spare_cap.len());\n+                        // Safety: The initializer contract guarantees that either it or `read`\n+                        // will have initialized these bytes. And we just checked that the number\n+                        // of bytes is within the buffer capacity.\n+                        unsafe { buf.set_len(buf.len() + bytes_read) };\n+                        len += bytes_read as u64;\n+                        // Read again if the buffer still has enough capacity, as BufWriter itself would do\n+                        // This will occur if the reader returns short reads\n+                        continue;\n+                    }\n+                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+                    Err(e) => return Err(e),\n+                }\n+            }\n+\n+            writer.flush_buf()?;\n+        }\n+    }\n+}\n+\n+fn stack_buffer_copy<R: Read + ?Sized, W: Write + ?Sized>(\n+    reader: &mut R,\n+    writer: &mut W,\n+) -> Result<u64> {\n+    let mut buf = MaybeUninit::<[u8; DEFAULT_BUF_SIZE]>::uninit();\n     // FIXME: #42788\n     //\n     //   - This creates a (mut) reference to a slice of"}, {"sha": "7632eaf872a5b01e67a7c55e37e01b0eca9d9f9b", "filename": "library/std/src/io/util/tests.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/410550665601a8abe8935f7b55d5732fe4c4224f/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/410550665601a8abe8935f7b55d5732fe4c4224f/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs?ref=410550665601a8abe8935f7b55d5732fe4c4224f", "patch": "@@ -1,5 +1,8 @@\n+use crate::cmp::{max, min};\n use crate::io::prelude::*;\n-use crate::io::{copy, empty, repeat, sink, Empty, Repeat, SeekFrom, Sink};\n+use crate::io::{\n+    copy, empty, repeat, sink, BufWriter, Empty, Repeat, Result, SeekFrom, Sink, DEFAULT_BUF_SIZE,\n+};\n \n #[test]\n fn copy_copies() {\n@@ -11,6 +14,51 @@ fn copy_copies() {\n     assert_eq!(copy(&mut r as &mut dyn Read, &mut w as &mut dyn Write).unwrap(), 1 << 17);\n }\n \n+struct ShortReader {\n+    cap: usize,\n+    read_size: usize,\n+    observed_buffer: usize,\n+}\n+\n+impl Read for ShortReader {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n+        let bytes = min(self.cap, self.read_size);\n+        self.cap -= bytes;\n+        self.observed_buffer = max(self.observed_buffer, buf.len());\n+        Ok(bytes)\n+    }\n+}\n+\n+struct WriteObserver {\n+    observed_buffer: usize,\n+}\n+\n+impl Write for WriteObserver {\n+    fn write(&mut self, buf: &[u8]) -> Result<usize> {\n+        self.observed_buffer = max(self.observed_buffer, buf.len());\n+        Ok(buf.len())\n+    }\n+\n+    fn flush(&mut self) -> Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn copy_specializes_bufwriter() {\n+    let cap = 117 * 1024;\n+    let buf_sz = 16 * 1024;\n+    let mut r = ShortReader { cap, observed_buffer: 0, read_size: 1337 };\n+    let mut w = BufWriter::with_capacity(buf_sz, WriteObserver { observed_buffer: 0 });\n+    assert_eq!(\n+        copy(&mut r, &mut w).unwrap(),\n+        cap as u64,\n+        \"expected the whole capacity to be copied\"\n+    );\n+    assert_eq!(r.observed_buffer, buf_sz, \"expected a large buffer to be provided to the reader\");\n+    assert!(w.get_mut().observed_buffer > DEFAULT_BUF_SIZE, \"expected coalesced writes\");\n+}\n+\n #[test]\n fn sink_sinks() {\n     let mut s = sink();"}, {"sha": "f16fb3d04db4544d49e383789188a3df30a12d48", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/410550665601a8abe8935f7b55d5732fe4c4224f/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/410550665601a8abe8935f7b55d5732fe4c4224f/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=410550665601a8abe8935f7b55d5732fe4c4224f", "patch": "@@ -283,6 +283,7 @@\n #![feature(maybe_uninit_extra)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n+#![feature(maybe_uninit_uninit_array)]\n #![feature(min_specialization)]\n #![feature(needs_panic_runtime)]\n #![feature(negative_impls)]\n@@ -326,6 +327,7 @@\n #![feature(unsafe_cell_raw_get)]\n #![feature(unwind_attributes)]\n #![feature(vec_into_raw_parts)]\n+#![feature(vec_spare_capacity)]\n #![feature(wake_trait)]\n // NB: the above list is sorted to minimize merge conflicts.\n #![default_lib_allocator]"}]}