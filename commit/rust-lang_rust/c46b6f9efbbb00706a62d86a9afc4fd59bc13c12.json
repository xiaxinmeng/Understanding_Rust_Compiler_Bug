{"sha": "c46b6f9efbbb00706a62d86a9afc4fd59bc13c12", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NmI2ZjllZmJiYjAwNzA2YTYyZDg2YTlhZmM0ZmQ1OWJjMTNjMTI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-01T14:22:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-10-02T03:44:30Z"}, "message": "auto_serialize2 should deserialize structs using read_struct", "tree": {"sha": "00b054e7028238a9f6afb3125a95cbdea6d775a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00b054e7028238a9f6afb3125a95cbdea6d775a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c46b6f9efbbb00706a62d86a9afc4fd59bc13c12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c46b6f9efbbb00706a62d86a9afc4fd59bc13c12", "html_url": "https://github.com/rust-lang/rust/commit/c46b6f9efbbb00706a62d86a9afc4fd59bc13c12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c46b6f9efbbb00706a62d86a9afc4fd59bc13c12/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fc3088b2aba397c0f561ce978b2d4a47f8a9eab", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc3088b2aba397c0f561ce978b2d4a47f8a9eab", "html_url": "https://github.com/rust-lang/rust/commit/8fc3088b2aba397c0f561ce978b2d4a47f8a9eab"}], "stats": {"total": 163, "additions": 106, "deletions": 57}, "files": [{"sha": "bec0d6c973dad9ac4593cf9f38c867de8858d1d1", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "modified", "additions": 106, "deletions": 57, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/c46b6f9efbbb00706a62d86a9afc4fd59bc13c12/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46b6f9efbbb00706a62d86a9afc4fd59bc13c12/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=c46b6f9efbbb00706a62d86a9afc4fd59bc13c12", "patch": "@@ -7,34 +7,42 @@ companion module with the same name as the item.\n \n For example, a type like:\n \n-    type node_id = uint;\n+    #[auto_serialize2]\n+    struct Node {id: uint}\n \n would generate two implementations like:\n \n-    impl node_id: Serializable {\n+    impl Node: Serializable {\n         fn serialize<S: Serializer>(s: &S) {\n-            s.emit_uint(self)\n+            do s.emit_struct(\"Node\") {\n+                s.emit_field(\"id\", 0, || s.emit_uint(self))\n+            }\n         }\n     }\n \n     impl node_id: Deserializable {\n-        static fn deserialize<D: Deserializer>(d: &D) -> node_id {\n-            d.read_uint()\n+        static fn deserialize<D: Deserializer>(d: &D) -> Node {\n+            do d.read_struct(\"Node\") {\n+                Node {\n+                    id: d.read_field(~\"x\", 0, || deserialize(d))\n+                }\n+            }\n         }\n     }\n \n Other interesting scenarios are whe the item has type parameters or\n references other non-built-in types.  A type definition like:\n \n+    #[auto_serialize2]\n     type spanned<T> = {node: T, span: span};\n \n would yield functions like:\n \n     impl<T: Serializable> spanned<T>: Serializable {\n         fn serialize<S: Serializer>(s: &S) {\n             do s.emit_rec {\n-                s.emit_field(\"node\", 0, self.node.serialize(s));\n-                s.emit_field(\"span\", 1, self.span.serialize(s));\n+                s.emit_field(\"node\", 0, || self.node.serialize(s));\n+                s.emit_field(\"span\", 1, || self.span.serialize(s));\n             }\n         }\n     }\n@@ -395,33 +403,38 @@ fn mk_rec_impl(\n     fields: ~[ast::ty_field],\n     tps: ~[ast::ty_param]\n ) -> ~[@ast::item] {\n-    // Records and structs don't have the same fields types, but they share\n-    // enough that if we extract the right subfields out we can share the\n-    // serialization generator code.\n-    let fields = do fields.map |field| {\n-        {\n-            span: field.span,\n-            ident: field.node.ident,\n-            mutbl: field.node.mt.mutbl,\n-        }\n-    };\n+    let fields = mk_rec_fields(fields);\n+    let ser_fields = mk_ser_fields(cx, span, fields);\n+    let deser_fields = mk_deser_fields(cx, span, fields);\n \n-    let ser_body = mk_ser_fields(cx, span, fields);\n-\n-    // ast for `__s.emit_rec($(ser_body))`\n+    // ast for `__s.emit_rec(|| $(ser_fields))`\n     let ser_body = cx.expr_call(\n         span,\n         cx.expr_field(\n             span,\n             cx.expr_var(span, ~\"__s\"),\n             cx.ident_of(~\"emit_rec\")\n         ),\n-        ~[ser_body]\n+        ~[cx.lambda_stmts(span, ser_fields)]\n     );\n \n-    let deser_body = do mk_deser_fields(cx, span, fields) |fields| {\n-         cx.expr(span, ast::expr_rec(fields, None))\n-    };\n+    // ast for `read_rec(|| $(deser_fields))`\n+    let deser_body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_rec\")\n+        ),\n+        ~[\n+            cx.lambda_expr(\n+                cx.expr(\n+                    span,\n+                    ast::expr_rec(deser_fields, None)\n+                )\n+            )\n+        ]\n+    );\n \n     ~[\n         mk_ser_impl(cx, span, ident, tps, ser_body),\n@@ -436,55 +449,94 @@ fn mk_struct_impl(\n     fields: ~[@ast::struct_field],\n     tps: ~[ast::ty_param]\n ) -> ~[@ast::item] {\n-    // Records and structs don't have the same fields types, but they share\n-    // enough that if we extract the right subfields out we can share the\n-    // serialization generator code.\n-    let fields = do fields.map |field| {\n-        let (ident, mutbl) = match field.node.kind {\n-            ast::named_field(ident, mutbl, _) => (ident, mutbl),\n-            _ => fail ~\"[auto_serialize2] does not support \\\n-                        unnamed fields\",\n-        };\n-\n-        {\n-            span: field.span,\n-            ident: ident,\n-            mutbl: match mutbl {\n-                ast::class_mutable => ast::m_mutbl,\n-                ast::class_immutable => ast::m_imm,\n-            },\n-        }\n-    };\n+    let fields = mk_struct_fields(fields);\n+    let ser_fields = mk_ser_fields(cx, span, fields);\n+    let deser_fields = mk_deser_fields(cx, span, fields);\n \n-    let ser_body = mk_ser_fields(cx, span, fields);\n-\n-    // ast for `__s.emit_struct($(name), $(ser_body))`\n+    // ast for `__s.emit_struct($(name), || $(ser_fields))`\n     let ser_body = cx.expr_call(\n         span,\n         cx.expr_field(\n             span,\n             cx.expr_var(span, ~\"__s\"),\n             cx.ident_of(~\"emit_struct\")\n         ),\n-        ~[cx.lit_str(span, @cx.str_of(ident)), ser_body]\n+        ~[\n+            cx.lit_str(span, @cx.str_of(ident)),\n+            cx.lambda_stmts(span, ser_fields),\n+        ]\n     );\n \n-    let deser_body = do mk_deser_fields(cx, span, fields) |fields| {\n-        cx.expr(span, ast::expr_struct(cx.path(span, ~[ident]), fields, None))\n-    };\n+    // ast for `read_struct($(name), || $(deser_fields))`\n+    let deser_body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_struct\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(ident)),\n+            cx.lambda_expr(\n+                span,\n+                cx.expr(\n+                    span,\n+                    ast::expr_struct(\n+                        cx.path(span, ~[ident]),\n+                        deser_fields\n+                        None\n+                    )\n+                )\n+            ),\n+        ]\n+    )\n \n     ~[\n         mk_ser_impl(cx, span, ident, tps, ser_body),\n         mk_deser_impl(cx, span, ident, tps, deser_body),\n     ]\n }\n \n+// Records and structs don't have the same fields types, but they share enough\n+// that if we extract the right subfields out we can share the serialization\n+// generator code.\n+type field = { span: span, ident: ast::ident, mutbl: ast::mutability };\n+\n+fn mk_rec_fields(fields: ~[ast::ty_field]) -> ~[field] {\n+    do fields.map |field| {\n+        {\n+            span: field.span,\n+            ident: field.node.ident,\n+            mutbl: field.node.mt.mutbl,\n+        }\n+    }\n+}\n+\n+fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n+    do fields.map |field| {\n+        let (ident, mutbl) = match field.node.kind {\n+            ast::named_field(ident, mutbl, _) => (ident, mutbl),\n+            _ => fail ~\"[auto_serialize2] does not support \\\n+                        unnamed fields\",\n+        };\n+\n+        {\n+            span: field.span,\n+            ident: ident,\n+            mutbl: match mutbl {\n+                ast::class_mutable => ast::m_mutbl,\n+                ast::class_immutable => ast::m_imm,\n+            },\n+        }\n+    }\n+}\n+\n fn mk_ser_fields(\n     cx: ext_ctxt,\n     span: span,\n-    fields: ~[{ span: span, ident: ast::ident, mutbl: ast::mutability }]\n-) -> @ast::expr {\n-    let stmts = do fields.mapi |idx, field| {\n+    fields: ~[field]\n+) -> ~[@ast::stmt] {\n+    do fields.mapi |idx, field| {\n         // ast for `|| self.$(name).serialize(__s)`\n         let expr_lambda = cx.lambda_expr(\n             cx.expr_call(\n@@ -518,10 +570,7 @@ fn mk_ser_fields(\n                 ]\n             )\n         )\n-    };\n-\n-    // ast for `|| $(stmts)`\n-    cx.lambda_stmts(span, stmts)\n+    }\n }\n \n fn mk_deser_fields("}]}