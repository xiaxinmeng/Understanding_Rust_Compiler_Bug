{"sha": "05f2b2ed3da6f504ac31d61e8bffb9a989780847", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1ZjJiMmVkM2RhNmY1MDRhYzMxZDYxZThiZmZiOWE5ODk3ODA4NDc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-10T11:26:20Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-10T11:26:20Z"}, "message": "remove support for not having libstd MIR", "tree": {"sha": "22aa96c5c263302ae426cc0f1a19047cfd69dc78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22aa96c5c263302ae426cc0f1a19047cfd69dc78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05f2b2ed3da6f504ac31d61e8bffb9a989780847", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05f2b2ed3da6f504ac31d61e8bffb9a989780847", "html_url": "https://github.com/rust-lang/rust/commit/05f2b2ed3da6f504ac31d61e8bffb9a989780847", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05f2b2ed3da6f504ac31d61e8bffb9a989780847/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b50662d68c886de44628e7ce55e331515df6c5e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b50662d68c886de44628e7ce55e331515df6c5e0", "html_url": "https://github.com/rust-lang/rust/commit/b50662d68c886de44628e7ce55e331515df6c5e0"}], "stats": {"total": 212, "additions": 56, "deletions": 156}, "files": [{"sha": "e28497aa256fcce817052ae23fd52e6e6964d473", "filename": "src/fn_call.rs", "status": "modified", "additions": 2, "deletions": 82, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/05f2b2ed3da6f504ac31d61e8bffb9a989780847/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f2b2ed3da6f504ac31d61e8bffb9a989780847/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=05f2b2ed3da6f504ac31d61e8bffb9a989780847", "patch": "@@ -17,18 +17,6 @@ pub trait EvalContextExt<'tcx, 'mir> {\n         ret: mir::BasicBlock,\n     ) -> EvalResult<'tcx>;\n \n-    /// Emulate a function that should have MIR but does not.\n-    /// This is solely to support execution without full MIR.\n-    /// Fail if emulating this function is not supported.\n-    /// This function will handle `goto_block` if needed.\n-    fn emulate_missing_fn(\n-        &mut self,\n-        path: String,\n-        args: &[OpTy<'tcx, Borrow>],\n-        dest: Option<PlaceTy<'tcx, Borrow>>,\n-        ret: Option<mir::BasicBlock>,\n-    ) -> EvalResult<'tcx>;\n-\n     fn find_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -81,24 +69,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             return Ok(None);\n         }\n \n-        // Otherwise we really want to see the MIR -- but if we do not have it, maybe we can\n-        // emulate something. This is a HACK to support running without a full-MIR libstd.\n-        let mir = match self.load_mir(instance.def) {\n-            Ok(mir) => mir,\n-            Err(EvalError { kind: EvalErrorKind::NoMirFor(path), .. }) => {\n-                self.emulate_missing_fn(\n-                    path,\n-                    args,\n-                    dest,\n-                    ret,\n-                )?;\n-                // `goto_block` already handled\n-                return Ok(None);\n-            }\n-            Err(other) => return Err(other),\n-        };\n-\n-        Ok(Some(mir))\n+        // Otherwise, load the MIR\n+        Ok(Some(self.load_mir(instance.def)?))\n     }\n \n     fn emulate_foreign_item(\n@@ -657,58 +629,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n         Ok(())\n     }\n \n-    fn emulate_missing_fn(\n-        &mut self,\n-        path: String,\n-        _args: &[OpTy<'tcx, Borrow>],\n-        dest: Option<PlaceTy<'tcx, Borrow>>,\n-        ret: Option<mir::BasicBlock>,\n-    ) -> EvalResult<'tcx> {\n-        // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n-        match &path[..] {\n-            \"std::panicking::rust_panic_with_hook\" |\n-            \"core::panicking::panic_fmt::::panic_impl\" |\n-            \"std::rt::begin_panic_fmt\" =>\n-                return err!(MachineError(\"the evaluated program panicked\".to_string())),\n-            _ => {}\n-        }\n-\n-        let dest = dest.ok_or_else(\n-            // Must be some function we do not support\n-            || EvalErrorKind::NoMirFor(path.clone()),\n-        )?;\n-\n-        match &path[..] {\n-            // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n-            // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n-            \"std::io::_print\" |\n-            \"std::io::_eprint\" => {\n-                warn!(\n-                    \"Ignoring output.  To run programs that prints, make sure you have a libstd with full MIR.\"\n-                );\n-            }\n-            \"std::thread::Builder::new\" => {\n-                return err!(Unimplemented(\"miri does not support threading\".to_owned()))\n-            }\n-            \"std::env::args\" => {\n-                return err!(Unimplemented(\n-                    \"miri does not support program arguments\".to_owned(),\n-                ))\n-            }\n-            \"std::panicking::panicking\" |\n-            \"std::rt::panicking\" => {\n-                // we abort on panic -> `std::rt::panicking` always returns false\n-                self.write_scalar(Scalar::from_bool(false), dest)?;\n-            }\n-\n-            _ => return err!(NoMirFor(path)),\n-        }\n-\n-        self.goto_block(ret)?;\n-        self.dump_place(*dest);\n-        Ok(())\n-    }\n-\n     fn write_null(&mut self, dest: PlaceTy<'tcx, Borrow>) -> EvalResult<'tcx> {\n         self.write_scalar(Scalar::from_int(0, dest.layout.size), dest)\n     }"}, {"sha": "9641670a2edfb384cc86faa273ef4bfb142ad45d", "filename": "src/lib.rs", "status": "modified", "additions": 54, "deletions": 74, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/05f2b2ed3da6f504ac31d61e8bffb9a989780847/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05f2b2ed3da6f504ac31d61e8bffb9a989780847/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=05f2b2ed3da6f504ac31d61e8bffb9a989780847", "patch": "@@ -80,82 +80,62 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         ));\n     }\n \n-    let libstd_has_mir = {\n-        let rustc_panic = ecx.resolve_path(&[\"std\", \"panicking\", \"rust_panic\"])?;\n-        ecx.load_mir(rustc_panic.def).is_ok()\n-    };\n-\n-    if libstd_has_mir {\n-        let start_id = tcx.lang_items().start_fn().unwrap();\n-        let main_ret_ty = tcx.fn_sig(main_id).output();\n-        let main_ret_ty = main_ret_ty.no_bound_vars().unwrap();\n-        let start_instance = ty::Instance::resolve(\n-            ecx.tcx.tcx,\n-            ty::ParamEnv::reveal_all(),\n-            start_id,\n-            ecx.tcx.mk_substs(\n-                ::std::iter::once(ty::subst::Kind::from(main_ret_ty)))\n-            ).unwrap();\n-        let start_mir = ecx.load_mir(start_instance.def)?;\n-\n-        if start_mir.arg_count != 3 {\n-            return err!(AbiViolation(format!(\n-                \"'start' lang item should have three arguments, but has {}\",\n-                start_mir.arg_count\n-            )));\n-        }\n-\n-        // Return value (in static memory so that it does not count as leak)\n-        let ret = ecx.layout_of(start_mir.return_ty())?;\n-        let ret_ptr = ecx.allocate(ret, MiriMemoryKind::MutStatic.into())?;\n-\n-        // Push our stack frame\n-        ecx.push_stack_frame(\n-            start_instance,\n-            DUMMY_SP, // there is no call site, we want no span\n-            start_mir,\n-            Some(ret_ptr.into()),\n-            StackPopCleanup::None { cleanup: true },\n-        )?;\n-\n-        let mut args = ecx.frame().mir.args_iter();\n-\n-        // First argument: pointer to main()\n-        let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance).with_default_tag();\n-        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-        ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n-\n-        // Second argument (argc): 1\n-        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-        ecx.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n-\n-        // FIXME: extract main source file path\n-        // Third argument (argv): &[b\"foo\"]\n-        let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-        let foo = ecx.memory_mut().allocate_static_bytes(b\"foo\\0\").with_default_tag();\n-        let foo_ty = ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8);\n-        let foo_layout = ecx.layout_of(foo_ty)?;\n-        let foo_place = ecx.allocate(foo_layout, MiriMemoryKind::Env.into())?;\n-        ecx.write_scalar(Scalar::Ptr(foo), foo_place.into())?;\n-        ecx.memory_mut().mark_immutable(foo_place.to_ptr()?.alloc_id)?;\n-        ecx.write_scalar(foo_place.ptr, dest)?;\n-\n-        assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n-    } else {\n-        let ret_place = MPlaceTy::dangling(ecx.layout_of(tcx.mk_unit())?, &ecx).into();\n-        ecx.push_stack_frame(\n-            main_instance,\n-            DUMMY_SP, // there is no call site, we want no span\n-            main_mir,\n-            Some(ret_place),\n-            StackPopCleanup::None { cleanup: true },\n-        )?;\n-\n-        // No arguments\n-        let mut args = ecx.frame().mir.args_iter();\n-        assert!(args.next().is_none(), \"main function must not have arguments\");\n+    let start_id = tcx.lang_items().start_fn().unwrap();\n+    let main_ret_ty = tcx.fn_sig(main_id).output();\n+    let main_ret_ty = main_ret_ty.no_bound_vars().unwrap();\n+    let start_instance = ty::Instance::resolve(\n+        ecx.tcx.tcx,\n+        ty::ParamEnv::reveal_all(),\n+        start_id,\n+        ecx.tcx.mk_substs(\n+            ::std::iter::once(ty::subst::Kind::from(main_ret_ty)))\n+        ).unwrap();\n+    let start_mir = ecx.load_mir(start_instance.def)?;\n+\n+    if start_mir.arg_count != 3 {\n+        return err!(AbiViolation(format!(\n+            \"'start' lang item should have three arguments, but has {}\",\n+            start_mir.arg_count\n+        )));\n     }\n \n+    // Return value (in static memory so that it does not count as leak)\n+    let ret = ecx.layout_of(start_mir.return_ty())?;\n+    let ret_ptr = ecx.allocate(ret, MiriMemoryKind::MutStatic.into())?;\n+\n+    // Push our stack frame\n+    ecx.push_stack_frame(\n+        start_instance,\n+        DUMMY_SP, // there is no call site, we want no span\n+        start_mir,\n+        Some(ret_ptr.into()),\n+        StackPopCleanup::None { cleanup: true },\n+    )?;\n+\n+    let mut args = ecx.frame().mir.args_iter();\n+\n+    // First argument: pointer to main()\n+    let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance).with_default_tag();\n+    let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n+    ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n+\n+    // Second argument (argc): 1\n+    let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n+    ecx.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n+\n+    // FIXME: extract main source file path\n+    // Third argument (argv): &[b\"foo\"]\n+    let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n+    let foo = ecx.memory_mut().allocate_static_bytes(b\"foo\\0\").with_default_tag();\n+    let foo_ty = ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8);\n+    let foo_layout = ecx.layout_of(foo_ty)?;\n+    let foo_place = ecx.allocate(foo_layout, MiriMemoryKind::Env.into())?;\n+    ecx.write_scalar(Scalar::Ptr(foo), foo_place.into())?;\n+    ecx.memory_mut().mark_immutable(foo_place.to_ptr()?.alloc_id)?;\n+    ecx.write_scalar(foo_place.ptr, dest)?;\n+\n+    assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n+\n     Ok(ecx)\n }\n "}]}