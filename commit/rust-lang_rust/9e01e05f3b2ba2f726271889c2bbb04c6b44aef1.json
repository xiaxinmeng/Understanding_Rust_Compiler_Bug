{"sha": "9e01e05f3b2ba2f726271889c2bbb04c6b44aef1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMDFlMDVmM2IyYmEyZjcyNjI3MTg4OWMyYmJiMDRjNmI0NGFlZjE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T04:34:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:45Z"}, "message": "Convert rustc::middle::trans to istrs. Issue #855", "tree": {"sha": "22d155fe19d11d1b26e2a0d12c219823192f49b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22d155fe19d11d1b26e2a0d12c219823192f49b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1", "html_url": "https://github.com/rust-lang/rust/commit/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f09ef6ec66b0a204c52cc67a6c91a69da65a5407", "url": "https://api.github.com/repos/rust-lang/rust/commits/f09ef6ec66b0a204c52cc67a6c91a69da65a5407", "html_url": "https://github.com/rust-lang/rust/commit/f09ef6ec66b0a204c52cc67a6c91a69da65a5407"}], "stats": {"total": 462, "additions": 234, "deletions": 228}, "files": [{"sha": "f224bafb4096d4b78e345173178f769961a1c66d", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=9e01e05f3b2ba2f726271889c2bbb04c6b44aef1", "patch": "@@ -59,7 +59,7 @@ fn declare_upcalls(_tn: type_names, tydesc_type: TypeRef,\n         for t: TypeRef in tys { arg_tys += [t]; }\n         let fn_ty = T_fn(arg_tys, rv);\n         ret trans::decl_cdecl_fn(llmod,\n-                                 istr::to_estr(~\"upcall_\" + name), fn_ty);\n+                                 ~\"upcall_\" + name, fn_ty);\n     }\n     fn decl_with_taskptr(taskptr_type: TypeRef, llmod: ModuleRef,\n                          name: &istr,"}, {"sha": "02b01cbc3860b099f0620bec192aff33a31ea0fd", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=9e01e05f3b2ba2f726271889c2bbb04c6b44aef1", "patch": "@@ -166,7 +166,8 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n          bind kind::check_crate(ty_cx, crate));\n     if sess.get_opts().no_trans { ret; }\n     let llmod = time(time_passes, \"translation\",\n-                     bind trans::trans_crate(sess, crate, ty_cx, output,\n+                     bind trans::trans_crate(sess, crate, ty_cx,\n+                                             istr::from_estr(output),\n                                              ast_map, mut_map));\n     time(time_passes, \"LLVM passes\",\n          bind link::write::run_passes(sess, llmod, istr::from_estr(output)));\n@@ -482,7 +483,6 @@ fn main(args: [str]) {\n             sess.fatal(\"No input files allowed with --glue.\");\n         }\n         let out = option::from_maybe::<istr>(~\"glue.bc\", output_file);\n-        let out = istr::to_estr(out);\n         middle::trans::make_common_glue(sess, out);\n         ret;\n     }"}, {"sha": "2ae4fd0cd91239341d234c787ab02777c87aa1ad", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 187, "deletions": 182, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=9e01e05f3b2ba2f726271889c2bbb04c6b44aef1", "patch": "@@ -313,7 +313,7 @@ fn sanitize(s: &istr) -> istr {\n }\n \n \n-fn log_fn_time(ccx: &@crate_ctxt, name: str, start: &time::timeval,\n+fn log_fn_time(ccx: &@crate_ctxt, name: &istr, start: &time::timeval,\n                end: &time::timeval) {\n     let elapsed =\n         1000 * (end.sec - start.sec as int) +\n@@ -322,20 +322,21 @@ fn log_fn_time(ccx: &@crate_ctxt, name: str, start: &time::timeval,\n }\n \n \n-fn decl_fn(llmod: ModuleRef, name: &str, cc: uint, llty: TypeRef) ->\n+fn decl_fn(llmod: ModuleRef, name: &istr, cc: uint, llty: TypeRef) ->\n    ValueRef {\n-    let llfn: ValueRef = istr::as_buf(istr::from_estr(name), { |buf|\n+    let llfn: ValueRef = istr::as_buf(name, { |buf|\n         llvm::LLVMAddFunction(llmod, buf, llty)\n     });\n     llvm::LLVMSetFunctionCallConv(llfn, cc);\n     ret llfn;\n }\n \n-fn decl_cdecl_fn(llmod: ModuleRef, name: &str, llty: TypeRef) -> ValueRef {\n+fn decl_cdecl_fn(llmod: ModuleRef, name: &istr, llty: TypeRef) -> ValueRef {\n     ret decl_fn(llmod, name, lib::llvm::LLVMCCallConv, llty);\n }\n \n-fn decl_fastcall_fn(llmod: ModuleRef, name: &str, llty: TypeRef) -> ValueRef {\n+fn decl_fastcall_fn(llmod: ModuleRef, name: &istr,\n+                    llty: TypeRef) -> ValueRef {\n     let llfn = decl_fn(llmod, name, lib::llvm::LLVMFastCallConv, llty);\n     let _: () = istr::as_buf(~\"rust\", { |buf|\n         llvm::LLVMSetGC(llfn, buf)\n@@ -346,7 +347,7 @@ fn decl_fastcall_fn(llmod: ModuleRef, name: &str, llty: TypeRef) -> ValueRef {\n \n // Only use this if you are going to actually define the function. It's\n // not valid to simply declare a function as internal.\n-fn decl_internal_fastcall_fn(llmod: ModuleRef, name: &str, llty: TypeRef) ->\n+fn decl_internal_fastcall_fn(llmod: ModuleRef, name: &istr, llty: TypeRef) ->\n    ValueRef {\n     let llfn = decl_fn(llmod, name, lib::llvm::LLVMFastCallConv, llty);\n     llvm::LLVMSetLinkage(llfn,\n@@ -357,42 +358,42 @@ fn decl_internal_fastcall_fn(llmod: ModuleRef, name: &str, llty: TypeRef) ->\n     ret llfn;\n }\n \n-fn decl_glue(llmod: ModuleRef, cx: &crate_ctxt, s: &str) -> ValueRef {\n+fn decl_glue(llmod: ModuleRef, cx: &crate_ctxt, s: &istr) -> ValueRef {\n     ret decl_cdecl_fn(llmod, s, T_fn([T_taskptr(cx)], T_void()));\n }\n \n fn get_extern_fn(externs: &hashmap<istr, ValueRef>, llmod: ModuleRef,\n-                 name: &str, cc: uint, ty: TypeRef) -> ValueRef {\n-    if externs.contains_key(istr::from_estr(name)) {\n-        ret externs.get(istr::from_estr(name));\n+                 name: &istr, cc: uint, ty: TypeRef) -> ValueRef {\n+    if externs.contains_key(name) {\n+        ret externs.get(name);\n     }\n     let f = decl_fn(llmod, name, cc, ty);\n-    externs.insert(istr::from_estr(name), f);\n+    externs.insert(name, f);\n     ret f;\n }\n \n fn get_extern_const(externs: &hashmap<istr, ValueRef>, llmod: ModuleRef,\n-                    name: &str, ty: TypeRef) -> ValueRef {\n-    if externs.contains_key(istr::from_estr(name)) {\n-        ret externs.get(istr::from_estr(name));\n+                    name: &istr, ty: TypeRef) -> ValueRef {\n+    if externs.contains_key(name) {\n+        ret externs.get(name);\n     }\n-    let c = istr::as_buf(istr::from_estr(name), { |buf|\n+    let c = istr::as_buf(name, { |buf|\n         llvm::LLVMAddGlobal(llmod, ty, buf)\n     });\n-    externs.insert(istr::from_estr(name), c);\n+    externs.insert(name, c);\n     ret c;\n }\n \n fn get_simple_extern_fn(externs: &hashmap<istr, ValueRef>, llmod: ModuleRef,\n-                        name: &str, n_args: int) -> ValueRef {\n+                        name: &istr, n_args: int) -> ValueRef {\n     let inputs = std::vec::init_elt::<TypeRef>(T_int(), n_args as uint);\n     let output = T_int();\n     let t = T_fn(inputs, output);\n     ret get_extern_fn(externs, llmod, name, lib::llvm::LLVMCCallConv, t);\n }\n \n fn trans_native_call(cx: &@block_ctxt, externs: &hashmap<istr, ValueRef>,\n-                     llmod: ModuleRef, name: &str, args: &[ValueRef]) ->\n+                     llmod: ModuleRef, name: &istr, args: &[ValueRef]) ->\n    ValueRef {\n     let n: int = std::vec::len::<ValueRef>(args) as int;\n     let llnative: ValueRef = get_simple_extern_fn(externs, llmod, name, n);\n@@ -1172,14 +1173,14 @@ tag glue_helper {\n }\n \n fn declare_generic_glue(cx: &@local_ctxt, t: ty::t, llfnty: TypeRef,\n-                        name: &str) -> ValueRef {\n-    let name = istr::from_estr(name);\n+                        name: &istr) -> ValueRef {\n+    let name = name;\n     let fn_nm;\n     if cx.ccx.sess.get_opts().debuginfo {\n         fn_nm = mangle_internal_name_by_type_only(cx.ccx, t, ~\"glue_\" + name);\n         fn_nm = sanitize(fn_nm);\n     } else { fn_nm = mangle_internal_name_by_seq(cx.ccx, ~\"glue_\" + name); }\n-    let llfn = decl_cdecl_fn(cx.ccx.llmod, istr::to_estr(fn_nm), llfnty);\n+    let llfn = decl_cdecl_fn(cx.ccx.llmod, fn_nm, llfnty);\n     set_glue_inlining(cx, llfn, t);\n     ret llfn;\n }\n@@ -1238,16 +1239,16 @@ fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: ty::t,\n \n fn make_generic_glue(cx: &@local_ctxt, sp: &span, t: ty::t, llfn: ValueRef,\n                      helper: &glue_helper, ty_params: &[uint],\n-                     name: &str) -> ValueRef {\n+                     name: &istr) -> ValueRef {\n     if !cx.ccx.sess.get_opts().stats {\n         ret make_generic_glue_inner(cx, sp, t, llfn, helper, ty_params);\n     }\n \n     let start = time::get_time();\n     let llval = make_generic_glue_inner(cx, sp, t, llfn, helper, ty_params);\n     let end = time::get_time();\n-    log_fn_time(cx.ccx, \"glue \" + name + \" \" +\n-                istr::to_estr(ty_to_short_str(cx.ccx.tcx, t)),\n+    log_fn_time(cx.ccx, ~\"glue \" + name + ~\" \" +\n+                ty_to_short_str(cx.ccx.tcx, t),\n                 start, end);\n     ret llval;\n }\n@@ -1342,8 +1343,8 @@ fn incr_refcnt_of_boxed(cx: &@block_ctxt, box_ptr: ValueRef) -> result {\n     let rc_ptr =\n         bld::GEP(cx, box_ptr, [C_int(0), C_int(abi::box_rc_field_refcnt)]);\n     let rc = bld::Load(cx, rc_ptr);\n-    let rc_adj_cx = new_sub_block_ctxt(cx, \"rc++\");\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n+    let rc_adj_cx = new_sub_block_ctxt(cx, ~\"rc++\");\n+    let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n     let const_test =\n         bld::ICmp(cx, lib::llvm::LLVMIntEQ, C_int(abi::const_refcount as int),\n                       rc);\n@@ -1431,8 +1432,8 @@ fn maybe_free_ivec_heap_part(cx: &@block_ctxt, v0: ValueRef, unit_ty: ty::t)\n         bld::Load(cx, bld::InBoundsGEP(cx, v0,\n                                            [C_int(0),\n                                             C_uint(abi::ivec_elt_len)]));\n-    let maybe_on_heap_cx = new_sub_block_ctxt(cx, \"maybe_on_heap\");\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n+    let maybe_on_heap_cx = new_sub_block_ctxt(cx, ~\"maybe_on_heap\");\n+    let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n     let maybe_on_heap =\n         bld::ICmp(cx, lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n     bld::CondBr(cx, maybe_on_heap, maybe_on_heap_cx.llbb, next_cx.llbb);\n@@ -1501,8 +1502,8 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n     let ccx = bcx_ccx(cx);\n     let inner_t_s = ty::substitute_type_params(ccx.tcx, tps, inner_t);\n     let tup_ty = ty::mk_tup(ccx.tcx, [ty::mk_int(ccx.tcx), inner_t_s]);\n-    let drop_cx = new_sub_block_ctxt(cx, \"drop res\");\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n+    let drop_cx = new_sub_block_ctxt(cx, ~\"drop res\");\n+    let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n \n     let drop_flag = GEP_tup_like(cx, tup_ty, rs, [0, 0]);\n     cx = drop_flag.bcx;\n@@ -1546,10 +1547,10 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n fn decr_refcnt_maybe_free(cx: &@block_ctxt, box_ptr_alias: ValueRef,\n                           full_alias: ValueRef, t: ty::t) -> result {\n     let ccx = bcx_ccx(cx);\n-    let load_rc_cx = new_sub_block_ctxt(cx, \"load rc\");\n-    let rc_adj_cx = new_sub_block_ctxt(cx, \"rc--\");\n-    let free_cx = new_sub_block_ctxt(cx, \"free\");\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n+    let load_rc_cx = new_sub_block_ctxt(cx, ~\"load rc\");\n+    let rc_adj_cx = new_sub_block_ctxt(cx, ~\"rc--\");\n+    let free_cx = new_sub_block_ctxt(cx, ~\"free\");\n+    let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n     let box_ptr = bld::Load(cx, box_ptr_alias);\n     let llbox_ty = T_opaque_obj_ptr(*ccx);\n     box_ptr = bld::PointerCast(cx, box_ptr, llbox_ty);\n@@ -1581,9 +1582,9 @@ fn decr_refcnt_maybe_free(cx: &@block_ctxt, box_ptr_alias: ValueRef,\n \n \n // Structural comparison: a rather involved form of glue.\n-fn maybe_name_value(cx: &@crate_ctxt, v: ValueRef, s: &str) {\n+fn maybe_name_value(cx: &@crate_ctxt, v: ValueRef, s: &istr) {\n     if cx.sess.get_opts().save_temps {\n-        let _: () = istr::as_buf(istr::from_estr(s), { |buf|\n+        let _: () = istr::as_buf(s, { |buf|\n             llvm::LLVMSetValueName(v, buf)\n         });\n     }\n@@ -1618,17 +1619,17 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n         }\n       }\n       ty::ty_type. {\n-        trans_fail(cx, none, \"attempt to compare values of type type\");\n+        trans_fail(cx, none, ~\"attempt to compare values of type type\");\n \n         // This is a bit lame, because we return a dummy block to the\n         // caller that's actually unreachable, but I don't think it\n         // matters.\n-        ret rslt(new_sub_block_ctxt(cx, \"after_fail_dummy\"), C_bool(false));\n+        ret rslt(new_sub_block_ctxt(cx, ~\"after_fail_dummy\"), C_bool(false));\n       }\n       ty::ty_native(_) {\n         trans_fail(cx, none::<span>,\n-                   \"attempt to compare values of type native\");\n-        ret rslt(new_sub_block_ctxt(cx, \"after_fail_dummy\"), C_bool(false));\n+                   ~\"attempt to compare values of type native\");\n+        ret rslt(new_sub_block_ctxt(cx, ~\"after_fail_dummy\"), C_bool(false));\n       }\n       _ {\n         // Should never get here, because t is scalar.\n@@ -1685,17 +1686,17 @@ fn compare_scalar_values(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef,\n         } else { r = bld::ICmp(cx, op, lhs, rhs); }\n         ret r;\n     }\n-    let last_cx = new_sub_block_ctxt(cx, \"last\");\n-    let eq_cx = new_sub_block_ctxt(cx, \"eq\");\n+    let last_cx = new_sub_block_ctxt(cx, ~\"last\");\n+    let eq_cx = new_sub_block_ctxt(cx, ~\"eq\");\n     let eq_result = generic_cmp(eq_cx, nt, eq_cmp, lhs, rhs);\n     bld::Br(eq_cx, last_cx.llbb);\n-    let lt_cx = new_sub_block_ctxt(cx, \"lt\");\n+    let lt_cx = new_sub_block_ctxt(cx, ~\"lt\");\n     let lt_result = generic_cmp(lt_cx, nt, lt_cmp, lhs, rhs);\n     bld::Br(lt_cx, last_cx.llbb);\n-    let le_cx = new_sub_block_ctxt(cx, \"le\");\n+    let le_cx = new_sub_block_ctxt(cx, ~\"le\");\n     let le_result = generic_cmp(le_cx, nt, le_cmp, lhs, rhs);\n     bld::Br(le_cx, last_cx.llbb);\n-    let unreach_cx = new_sub_block_ctxt(cx, \"unreach\");\n+    let unreach_cx = new_sub_block_ctxt(cx, ~\"unreach\");\n     bld::Unreachable(unreach_cx);\n     let llswitch = bld::Switch(cx, llop, unreach_cx.llbb, 3u);\n     llvm::LLVMAddCase(llswitch, C_u8(abi::cmp_glue_op_eq), eq_cx.llbb);\n@@ -1745,8 +1746,8 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n         let box_ptr = bld::Load(cx, box_cell);\n         let tnil = ty::mk_nil(bcx_tcx(cx));\n         let tbox = ty::mk_imm_box(bcx_tcx(cx), tnil);\n-        let inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n-        let next_cx = new_sub_block_ctxt(cx, \"next\");\n+        let inner_cx = new_sub_block_ctxt(cx, ~\"iter box\");\n+        let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n         let null_test = bld::IsNull(cx, box_ptr);\n         bld::CondBr(cx, null_test, next_cx.llbb, inner_cx.llbb);\n         let r = f(inner_cx, box_cell, tbox);\n@@ -1782,14 +1783,15 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n         bld::Store(bcx, a_elem, dest_elem_ptr);\n \n         // Now perform the iteration.\n-        let loop_header_cx = new_sub_block_ctxt(bcx, \"iter_ivec_loop_header\");\n+        let loop_header_cx = new_sub_block_ctxt(\n+            bcx, ~\"iter_ivec_loop_header\");\n         bld::Br(bcx, loop_header_cx.llbb);\n         let dest_elem = bld::Load(loop_header_cx, dest_elem_ptr);\n         let not_yet_at_end =\n             bld::ICmp(loop_header_cx, lib::llvm::LLVMIntULT, dest_elem,\n                                       a_end);\n-        let loop_body_cx = new_sub_block_ctxt(bcx, \"iter_ivec_loop_body\");\n-        let next_cx = new_sub_block_ctxt(bcx, \"iter_ivec_next\");\n+        let loop_body_cx = new_sub_block_ctxt(bcx, ~\"iter_ivec_loop_body\");\n+        let next_cx = new_sub_block_ctxt(bcx, ~\"iter_ivec_next\");\n         bld::CondBr(loop_header_cx, not_yet_at_end, loop_body_cx.llbb,\n                                     next_cx.llbb);\n \n@@ -1881,16 +1883,16 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n         // comparison know not to proceed when the discriminants differ.\n         let bcx = cx;\n         bcx = f(bcx, lldiscrim_a_ptr, ty::mk_int(bcx_tcx(cx))).bcx;\n-        let unr_cx = new_sub_block_ctxt(bcx, \"tag-iter-unr\");\n+        let unr_cx = new_sub_block_ctxt(bcx, ~\"tag-iter-unr\");\n         bld::Unreachable(unr_cx);\n         let llswitch = bld::Switch(bcx, lldiscrim_a, unr_cx.llbb, n_variants);\n-        let next_cx = new_sub_block_ctxt(bcx, \"tag-iter-next\");\n+        let next_cx = new_sub_block_ctxt(bcx, ~\"tag-iter-next\");\n         let i = 0u;\n         for variant: ty::variant_info in variants {\n             let variant_cx =\n                 new_sub_block_ctxt(bcx,\n-                                   istr::to_estr(~\"tag-iter-variant-\" +\n-                                                 uint::to_str(i, 10u)));\n+                                   ~\"tag-iter-variant-\" +\n+                                                 uint::to_str(i, 10u));\n             llvm::LLVMAddCase(llswitch, C_int(i as int), variant_cx.llbb);\n             variant_cx =\n                 iter_variant(variant_cx, llunion_a_ptr, variant, tps, tid,\n@@ -1936,9 +1938,9 @@ fn iter_sequence_raw(cx: @block_ctxt, dst: ValueRef,\n     let dst_int: ValueRef = vp2i(bcx, dst);\n     let src_int: ValueRef = vp2i(bcx, src);\n     let src_lim_int: ValueRef = vp2i(bcx, src_lim);\n-    let cond_cx = new_scope_block_ctxt(cx, \"sequence-iter cond\");\n-    let body_cx = new_scope_block_ctxt(cx, \"sequence-iter body\");\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n+    let cond_cx = new_scope_block_ctxt(cx, ~\"sequence-iter cond\");\n+    let body_cx = new_scope_block_ctxt(cx, ~\"sequence-iter body\");\n+    let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n     bld::Br(bcx, cond_cx.llbb);\n     let dst_curr: ValueRef =\n         bld::Phi(cond_cx, T_int(), [dst_int], [bcx.llbb]);\n@@ -2064,11 +2066,11 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n-                                         \"take\");\n+                                         ~\"take\");\n                 ti.take_glue = some::<ValueRef>(glue_fn);\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   default_helper(make_take_glue),\n-                                  ti.ty_params, \"take\");\n+                                  ti.ty_params, ~\"take\");\n                 log #fmt[\"--- lazily_emit_tydesc_glue TAKE %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n               }\n@@ -2082,11 +2084,11 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n-                                         \"drop\");\n+                                         ~\"drop\");\n                 ti.drop_glue = some::<ValueRef>(glue_fn);\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   default_helper(make_drop_glue),\n-                                  ti.ty_params, \"drop\");\n+                                  ti.ty_params, ~\"drop\");\n                 log #fmt[\"--- lazily_emit_tydesc_glue DROP %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n               }\n@@ -2100,11 +2102,11 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(*lcx.ccx),\n-                                         \"free\");\n+                                         ~\"free\");\n                 ti.free_glue = some::<ValueRef>(glue_fn);\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   default_helper(make_free_glue),\n-                                  ti.ty_params, \"free\");\n+                                  ti.ty_params, ~\"free\");\n                 log #fmt[\"--- lazily_emit_tydesc_glue FREE %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n               }\n@@ -2127,11 +2129,11 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n                     declare_generic_glue(lcx, ti.ty, T_copy_glue_fn(*lcx.ccx),\n-                                         \"copy\");\n+                                         ~\"copy\");\n                 ti.copy_glue = some(glue_fn);\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   copy_helper(make_copy_glue),\n-                                  ti.ty_params, \"copy\");\n+                                  ti.ty_params, ~\"copy\");\n               }\n             }\n         }\n@@ -2373,8 +2375,8 @@ fn copy_val(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n             src: ValueRef, t: ty::t) -> @block_ctxt {\n     if type_is_structural_or_param(bcx_ccx(cx).tcx, t) &&\n        action == DROP_EXISTING {\n-        let do_copy_cx = new_sub_block_ctxt(cx, \"do_copy\");\n-        let next_cx = new_sub_block_ctxt(cx, \"next\");\n+        let do_copy_cx = new_sub_block_ctxt(cx, ~\"do_copy\");\n+        let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n         let self_assigning =\n             bld::ICmp(cx, lib::llvm::LLVMIntNE,\n                           bld::PointerCast(cx, dst, val_ty(src)), src);\n@@ -2480,19 +2482,19 @@ fn move_val_if_temp(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n     ret move_val(cx, action, dst, src, t);\n }\n \n-fn trans_lit_istr(cx: &@block_ctxt, s: str) -> result {\n+fn trans_lit_istr(cx: &@block_ctxt, s: &istr) -> result {\n     let vec_ty = ty::mk_vec(bcx_tcx(cx),\n                             {ty: ty::mk_mach(bcx_tcx(cx), ast::ty_u8),\n                              mut: ast::imm});\n-    let strlen = str::byte_len(s);\n+    let strlen = istr::byte_len(s);\n     let veclen = strlen + 1u; // +1 for \\0\n     let alloc_res = trans_ivec::alloc_with_heap(cx, vec_ty, veclen);\n \n     let bcx = alloc_res.bcx;\n     let llvecptr = alloc_res.llptr;\n     let llfirsteltptr = alloc_res.llfirsteltptr;\n \n-    let llcstr = C_cstr(bcx_ccx(cx), istr::from_estr(s));\n+    let llcstr = C_cstr(bcx_ccx(cx), s);\n \n     // FIXME: We need to avoid this memmove\n     bcx = call_memmove(bcx, llfirsteltptr, llcstr, C_uint(veclen)).bcx;\n@@ -2542,7 +2544,7 @@ fn trans_crate_lit(cx: &@crate_ctxt, lit: &ast::lit) -> ValueRef {\n fn trans_lit(cx: &@block_ctxt, lit: &ast::lit) -> result {\n     alt lit.node {\n       ast::lit_str(s, ast::sk_unique.) {\n-        ret trans_lit_istr(cx, istr::to_estr(s));\n+        ret trans_lit_istr(cx, s);\n       }\n       _ { ret rslt(cx, trans_crate_lit(bcx_ccx(cx), lit)); }\n     }\n@@ -2771,10 +2773,10 @@ fn trans_binary(cx: &@block_ctxt, op: ast::binop, a: &@ast::expr,\n       ast::and. {\n         // Lazy-eval and\n         let lhs_res = trans_expr(cx, a);\n-        let rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n+        let rhs_cx = new_scope_block_ctxt(cx, ~\"rhs\");\n         let rhs_res = trans_expr(rhs_cx, b);\n \n-        let lhs_false_cx = new_scope_block_ctxt(cx, \"lhs false\");\n+        let lhs_false_cx = new_scope_block_ctxt(cx, ~\"lhs false\");\n         let lhs_false_res = rslt(lhs_false_cx, C_bool(false));\n \n         // The following line ensures that any cleanups for rhs\n@@ -2789,9 +2791,9 @@ fn trans_binary(cx: &@block_ctxt, op: ast::binop, a: &@ast::expr,\n       ast::or. {\n         // Lazy-eval or\n         let lhs_res = trans_expr(cx, a);\n-        let rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n+        let rhs_cx = new_scope_block_ctxt(cx, ~\"rhs\");\n         let rhs_res = trans_expr(rhs_cx, b);\n-        let lhs_true_cx = new_scope_block_ctxt(cx, \"lhs true\");\n+        let lhs_true_cx = new_scope_block_ctxt(cx, ~\"lhs true\");\n         let lhs_true_res = rslt(lhs_true_cx, C_bool(true));\n \n         // see the and case for an explanation\n@@ -2837,14 +2839,14 @@ fn join_results(parent_cx: &@block_ctxt, t: TypeRef, ins: &[result]) ->\n     }\n     // We have >1 incoming edges. Make a join block and br+phi them into it.\n \n-    let join_cx = new_sub_block_ctxt(parent_cx, \"join\");\n+    let join_cx = new_sub_block_ctxt(parent_cx, ~\"join\");\n     for r: result in live { bld::Br(r.bcx, join_cx.llbb); }\n     let phi = bld::Phi(join_cx, t, vals, bbs);\n     ret rslt(join_cx, phi);\n }\n \n fn join_branches(parent_cx: &@block_ctxt, ins: &[result]) -> @block_ctxt {\n-    let out = new_sub_block_ctxt(parent_cx, \"join\");\n+    let out = new_sub_block_ctxt(parent_cx, ~\"join\");\n     for r: result in ins {\n         if !is_terminated(r.bcx) { bld::Br(r.bcx, out.llbb); }\n     }\n@@ -2866,9 +2868,9 @@ fn trans_if(cx: &@block_ctxt, cond: &@ast::expr, thn: &ast::blk,\n         } else { ret cond_res; }\n     }\n \n-    let then_cx = new_scope_block_ctxt(cx, \"then\");\n+    let then_cx = new_scope_block_ctxt(cx, ~\"then\");\n     let then_res = trans_block(then_cx, thn, output);\n-    let else_cx = new_scope_block_ctxt(cx, \"else\");\n+    let else_cx = new_scope_block_ctxt(cx, ~\"else\");\n     // Synthesize a block here to act as the else block\n     // containing an if expression. Needed in order for the\n     // else scope to behave like a normal block scope. A tad\n@@ -2900,11 +2902,11 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n     // obviously a bug.\n     fn inner(cx: &@block_ctxt, local: @ast::local, curr: ValueRef, t: ty::t,\n              body: &ast::blk, outer_next_cx: @block_ctxt) -> result {\n-        let next_cx = new_sub_block_ctxt(cx, \"next\");\n+        let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n         let scope_cx =\n             new_loop_scope_block_ctxt(cx,\n                                       option::some::<@block_ctxt>(next_cx),\n-                                      outer_next_cx, \"for loop scope\");\n+                                      outer_next_cx, ~\"for loop scope\");\n         bld::Br(cx, scope_cx.llbb);\n         let local_res = alloc_local(scope_cx, local);\n         let bcx = copy_val(local_res.bcx, INIT, local_res.val, curr, t);\n@@ -2920,7 +2922,7 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n         }\n         ret rslt(next_cx, C_nil());\n     }\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n+    let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n     let seq_ty = ty::expr_ty(bcx_tcx(cx), seq);\n     let seq_res = trans_expr(cx, seq);\n     let it =\n@@ -3184,7 +3186,7 @@ fn trans_for_each(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n                            ty::mk_iter_body_fn(lcx.ccx.tcx, decl_ty), 0u);\n     let lliterbody: ValueRef =\n         decl_internal_fastcall_fn(lcx.ccx.llmod,\n-                                  istr::to_estr(s), iter_body_llty);\n+                                  s, iter_body_llty);\n     let fcx = new_fn_ctxt_w_id(lcx, cx.sp, lliterbody, body.node.id);\n     fcx.iterbodyty = cx.fcx.iterbodyty;\n \n@@ -3220,11 +3222,11 @@ fn trans_for_each(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n \n fn trans_while(cx: &@block_ctxt, cond: &@ast::expr, body: &ast::blk) ->\n    result {\n-    let next_cx = new_sub_block_ctxt(cx, \"while next\");\n+    let next_cx = new_sub_block_ctxt(cx, ~\"while next\");\n     let cond_cx = new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>,\n-                                            next_cx, \"while cond\");\n+                                            next_cx, ~\"while cond\");\n     let body_cx =\n-        new_scope_block_ctxt(cond_cx, \"while loop body\");\n+        new_scope_block_ctxt(cond_cx, ~\"while loop body\");\n     let body_res = trans_block(body_cx, body, return);\n     let cond_res = trans_expr(cond_cx, cond);\n     bld::Br(body_res.bcx, cond_cx.llbb);\n@@ -3236,10 +3238,10 @@ fn trans_while(cx: &@block_ctxt, cond: &@ast::expr, body: &ast::blk) ->\n \n fn trans_do_while(cx: &@block_ctxt, body: &ast::blk, cond: &@ast::expr) ->\n    result {\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n+    let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n     let body_cx =\n         new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n-                                  \"do-while loop body\");\n+                                  ~\"do-while loop body\");\n     let body_res = trans_block(body_cx, body, return);\n     if is_terminated(body_res.bcx) {\n         // This is kind of ridiculous, but no permutations\n@@ -3287,7 +3289,8 @@ fn trans_external_path(cx: &@block_ctxt, did: &ast::def_id,\n                        tpt: &ty::ty_param_kinds_and_ty) -> ValueRef {\n     let lcx = cx.fcx.lcx;\n     let name = csearch::get_symbol(lcx.ccx.sess.get_cstore(), did);\n-    ret get_extern_const(lcx.ccx.externs, lcx.ccx.llmod, name,\n+    ret get_extern_const(lcx.ccx.externs, lcx.ccx.llmod,\n+                         istr::from_estr(name),\n                          type_of_ty_param_kinds_and_ty(lcx, cx.sp, tpt));\n }\n \n@@ -3483,9 +3486,9 @@ fn trans_index(cx: &@block_ctxt, sp: &span, base: &@ast::expr,\n     let unit_ty = node_id_type(bcx_ccx(cx), id);\n     let unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n-    maybe_name_value(bcx_ccx(cx), unit_sz.val, \"unit_sz\");\n+    maybe_name_value(bcx_ccx(cx), unit_sz.val, ~\"unit_sz\");\n     let scaled_ix = bld::Mul(bcx, ix_val, unit_sz.val);\n-    maybe_name_value(bcx_ccx(cx), scaled_ix, \"scaled_ix\");\n+    maybe_name_value(bcx_ccx(cx), scaled_ix, ~\"scaled_ix\");\n     let interior_len_and_data;\n     if is_interior {\n         let rslt = ivec::get_len_and_data(bcx, v, unit_ty);\n@@ -3501,12 +3504,12 @@ fn trans_index(cx: &@block_ctxt, sp: &span, base: &@ast::expr,\n       }\n     }\n     let bounds_check = bld::ICmp(bcx, lib::llvm::LLVMIntULT, scaled_ix, lim);\n-    let fail_cx = new_sub_block_ctxt(bcx, \"fail\");\n-    let next_cx = new_sub_block_ctxt(bcx, \"next\");\n+    let fail_cx = new_sub_block_ctxt(bcx, ~\"fail\");\n+    let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n     bld::CondBr(bcx, bounds_check, next_cx.llbb, fail_cx.llbb);\n     // fail: bad bounds check.\n \n-    trans_fail(fail_cx, some::<span>(sp), \"bounds check\");\n+    trans_fail(fail_cx, some::<span>(sp), ~\"bounds check\");\n     let body;\n     alt interior_len_and_data {\n       some(lad) { body = lad.data; }\n@@ -3726,7 +3729,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n         get_pair_fn_ty(type_of(cx.ccx, sp, incoming_fty));\n     let llthunk: ValueRef =\n         decl_internal_fastcall_fn(cx.ccx.llmod,\n-                                  istr::to_estr(s), llthunk_ty);\n+                                  s, llthunk_ty);\n \n     // Create a new function context and block context for the thunk, and hold\n     // onto a pointer to the first block in the function for later use.\n@@ -4125,7 +4128,7 @@ fn trans_call(in_cx: &@block_ctxt, f: &@ast::expr,\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n-    let cx = new_scope_block_ctxt(in_cx, \"call\");\n+    let cx = new_scope_block_ctxt(in_cx, ~\"call\");\n     bld::Br(in_cx, cx.llbb);\n     let f_res = trans_lval_gen(cx, f);\n     let fn_ty: ty::t;\n@@ -4209,7 +4212,7 @@ fn trans_call(in_cx: &@block_ctxt, f: &@ast::expr,\n             revoke_clean(bcx, v)\n         }\n         bcx = trans_block_cleanups(bcx, cx);\n-        let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n+        let next_cx = new_sub_block_ctxt(in_cx, ~\"next\");\n         bld::Br(bcx, next_cx.llbb);\n         bcx = next_cx;\n     }\n@@ -4324,7 +4327,7 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n         let s = mangle_internal_name_by_path(ccx,\n                                              sub_cx.path);\n         let llfn = decl_internal_fastcall_fn(ccx.llmod,\n-                                             istr::to_estr(s), llfnty);\n+                                             s, llfnty);\n \n         let fn_res =\n             trans_closure(some(cx), some(llfnty), sub_cx, e.span, f, llfn,\n@@ -4333,16 +4336,16 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n             alt fn_res {\n               some(fn_pair) { fn_pair }\n               none. {\n-                {fn_pair: create_fn_pair(ccx, istr::to_estr(s),\n+                {fn_pair: create_fn_pair(ccx, s,\n                                          llfnty, llfn, false),\n                  bcx: cx}\n               }\n             };\n         ret rslt(fn_pair.bcx, fn_pair.fn_pair);\n       }\n       ast::expr_block(blk) {\n-        let sub_cx = new_scope_block_ctxt(cx, \"block-expr body\");\n-        let next_cx = new_sub_block_ctxt(cx, \"next\");\n+        let sub_cx = new_scope_block_ctxt(cx, ~\"block-expr body\");\n+        let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n         let sub =\n             with_out_method(bind trans_block(sub_cx, blk, _), cx, e.id,\n                             output);\n@@ -4450,9 +4453,9 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n       ast::expr_mac(_) { ret bcx_ccx(cx).sess.bug(\"unexpanded macro\"); }\n       ast::expr_fail(expr) { ret trans_fail_expr(cx, some(e.span), expr); }\n       ast::expr_log(lvl, a) { ret trans_log(lvl, cx, a); }\n-      ast::expr_assert(a) { ret trans_check_expr(cx, a, \"Assertion\"); }\n+      ast::expr_assert(a) { ret trans_check_expr(cx, a, ~\"Assertion\"); }\n       ast::expr_check(ast::checked., a) {\n-        ret trans_check_expr(cx, a, \"Predicate\");\n+        ret trans_check_expr(cx, a, ~\"Predicate\");\n       }\n       ast::expr_check(ast::unchecked., a) {\n         /* Claims are turned on and off by a global variable\n@@ -4462,12 +4465,12 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n            otherwise. */\n         let c =\n             get_extern_const(bcx_ccx(cx).externs, bcx_ccx(cx).llmod,\n-                             \"check_claims\", T_bool());\n+                             ~\"check_claims\", T_bool());\n         let cond = bld::Load(cx, c);\n \n-        let then_cx = new_scope_block_ctxt(cx, \"claim_then\");\n-        let check_res = trans_check_expr(then_cx, a, \"Claim\");\n-        let else_cx = new_scope_block_ctxt(cx, \"else\");\n+        let then_cx = new_scope_block_ctxt(cx, ~\"claim_then\");\n+        let check_res = trans_check_expr(then_cx, a, ~\"Claim\");\n+        let else_cx = new_scope_block_ctxt(cx, ~\"else\");\n         let els = rslt(else_cx, C_nil());\n \n         bld::CondBr(cx, cond, then_cx.llbb, else_cx.llbb);\n@@ -4571,8 +4574,8 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n                              lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n         lcx.ccx.module_data.insert(modname, global);\n     }\n-    let log_cx = new_scope_block_ctxt(cx, \"log\");\n-    let after_cx = new_sub_block_ctxt(cx, \"after\");\n+    let log_cx = new_scope_block_ctxt(cx, ~\"log\");\n+    let after_cx = new_sub_block_ctxt(cx, ~\"after\");\n     let load = bld::Load(cx, global);\n     let test = bld::ICmp(cx, lib::llvm::LLVMIntSGE, load, C_int(lvl));\n     bld::CondBr(cx, test, log_cx.llbb, after_cx.llbb);\n@@ -4596,12 +4599,12 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n     ret rslt(after_cx, C_nil());\n }\n \n-fn trans_check_expr(cx: &@block_ctxt, e: &@ast::expr, s: &str) -> result {\n+fn trans_check_expr(cx: &@block_ctxt, e: &@ast::expr, s: &istr) -> result {\n     let cond_res = trans_expr(cx, e);\n-    let expr_str = s + \" \" + expr_to_str(e) + \" failed\";\n-    let fail_cx = new_sub_block_ctxt(cx, \"fail\");\n+    let expr_str = s + ~\" \" + istr::from_estr(expr_to_str(e)) + ~\" failed\";\n+    let fail_cx = new_sub_block_ctxt(cx, ~\"fail\");\n     trans_fail(fail_cx, some::<span>(e.span), expr_str);\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n+    let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n     bld::CondBr(cond_res.bcx, cond_res.val, next_cx.llbb, fail_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }\n@@ -4629,13 +4632,13 @@ fn trans_fail_expr(cx: &@block_ctxt, sp_opt: &option::t<span>,\n                                           + ty_to_str(tcx, e_ty));\n         }\n       }\n-      _ { ret trans_fail(bcx, sp_opt, \"explicit failure\"); }\n+      _ { ret trans_fail(bcx, sp_opt, ~\"explicit failure\"); }\n     }\n }\n \n-fn trans_fail(cx: &@block_ctxt, sp_opt: &option::t<span>, fail_str: &str) ->\n+fn trans_fail(cx: &@block_ctxt, sp_opt: &option::t<span>, fail_str: &istr) ->\n    result {\n-    let V_fail_str = C_cstr(bcx_ccx(cx), istr::from_estr(fail_str));\n+    let V_fail_str = C_cstr(bcx_ccx(cx), fail_str);\n     ret trans_fail_value(cx, sp_opt, V_fail_str);\n }\n \n@@ -4660,7 +4663,7 @@ fn trans_fail_value(cx: &@block_ctxt, sp_opt: &option::t<span>,\n }\n \n fn trans_put(in_cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n-    let cx = new_scope_block_ctxt(in_cx, \"put\");\n+    let cx = new_scope_block_ctxt(in_cx, ~\"put\");\n     bld::Br(in_cx, cx.llbb);\n     let llcallee = C_nil();\n     let llenv = C_nil();\n@@ -4692,7 +4695,7 @@ fn trans_put(in_cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n     }\n     bld::FastCall(bcx, llcallee, llargs);\n     bcx = trans_block_cleanups(bcx, cx);\n-    let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n+    let next_cx = new_sub_block_ctxt(in_cx, ~\"next\");\n     bld::Br(bcx, next_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }\n@@ -4733,7 +4736,7 @@ fn trans_break_cont(sp: &span, cx: &@block_ctxt, to_end: bool) -> result {\n                   _ { bld::Br(bcx, cleanup_cx.llbb); }\n                 }\n             }\n-            ret rslt(new_sub_block_ctxt(bcx, \"break_cont.unreachable\"),\n+            ret rslt(new_sub_block_ctxt(bcx, ~\"break_cont.unreachable\"),\n                      C_nil());\n           }\n           _ {\n@@ -4803,7 +4806,7 @@ fn trans_ret(cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n         }\n     }\n     build_return(bcx);\n-    ret rslt(new_sub_block_ctxt(bcx, \"ret.unreachable\"), C_nil());\n+    ret rslt(new_sub_block_ctxt(bcx, ~\"ret.unreachable\"), C_nil());\n }\n \n fn build_return(bcx: &@block_ctxt) { bld::Br(bcx, bcx_fcx(bcx).llreturn); }\n@@ -4926,11 +4929,11 @@ fn trans_stmt(cx: &@block_ctxt, s: &ast::stmt) -> result {\n // You probably don't want to use this one. See the\n // next three functions instead.\n fn new_block_ctxt(cx: &@fn_ctxt, parent: &block_parent, kind: block_kind,\n-                  name: &str) -> @block_ctxt {\n+                  name: &istr) -> @block_ctxt {\n     let s = ~\"\";\n     if cx.lcx.ccx.sess.get_opts().save_temps ||\n            cx.lcx.ccx.sess.get_opts().debuginfo {\n-        s = cx.lcx.ccx.names.next(istr::from_estr(name));\n+        s = cx.lcx.ccx.names.next(name);\n     }\n     let llbb: BasicBlockRef = istr::as_buf(s, { |buf|\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n@@ -4947,25 +4950,25 @@ fn new_block_ctxt(cx: &@fn_ctxt, parent: &block_parent, kind: block_kind,\n \n // Use this when you're at the top block of a function or the like.\n fn new_top_block_ctxt(fcx: &@fn_ctxt) -> @block_ctxt {\n-    ret new_block_ctxt(fcx, parent_none, SCOPE_BLOCK, \"function top level\");\n+    ret new_block_ctxt(fcx, parent_none, SCOPE_BLOCK, ~\"function top level\");\n }\n \n \n // Use this when you're at a curly-brace or similar lexical scope.\n-fn new_scope_block_ctxt(bcx: &@block_ctxt, n: &str) -> @block_ctxt {\n+fn new_scope_block_ctxt(bcx: &@block_ctxt, n: &istr) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx), SCOPE_BLOCK, n);\n }\n \n fn new_loop_scope_block_ctxt(bcx: &@block_ctxt,\n                              _cont: &option::t<@block_ctxt>,\n-                             _break: &@block_ctxt, n: &str) -> @block_ctxt {\n+                             _break: &@block_ctxt, n: &istr) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx),\n                        LOOP_SCOPE_BLOCK(_cont, _break), n);\n }\n \n \n // Use this when you're making a general CFG BB within a scope.\n-fn new_sub_block_ctxt(bcx: &@block_ctxt, n: &str) -> @block_ctxt {\n+fn new_sub_block_ctxt(bcx: &@block_ctxt, n: &istr) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx), NON_SCOPE_BLOCK, n);\n }\n \n@@ -5508,7 +5511,7 @@ fn trans_fn(cx: @local_ctxt, sp: &span, f: &ast::_fn, llfndecl: ValueRef,\n     let start = time::get_time();\n     trans_fn_inner(cx, sp, f, llfndecl, ty_self, ty_params, id);\n     let end = time::get_time();\n-    log_fn_time(cx.ccx, istr::to_estr(istr::connect(cx.path, ~\"::\")),\n+    log_fn_time(cx.ccx, istr::connect(cx.path, ~\"::\"),\n                 start, end);\n }\n \n@@ -5734,16 +5737,16 @@ fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n     ret struct_elt(llpairty, 0u);\n }\n \n-fn decl_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str], flav: str,\n+fn decl_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[istr], flav: &istr,\n                     ty_params: &[ast::ty_param], node_id: ast::node_id) {\n     decl_fn_and_pair_full(ccx, sp, path, flav, ty_params, node_id,\n                           node_id_type(ccx, node_id));\n }\n \n-fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[str],\n-                         _flav: str, ty_params: &[ast::ty_param],\n+fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[istr],\n+                         _flav: &istr, ty_params: &[ast::ty_param],\n                          node_id: ast::node_id, node_type: ty::t) {\n-    let path = istr::from_estrs(path);\n+    let path = path;\n     let llfty =\n         type_of_fn_from_ty(ccx, sp, node_type, std::vec::len(ty_params));\n     alt ty::struct(ccx.tcx, node_type) {\n@@ -5756,11 +5759,11 @@ fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[str],\n     }\n     let s: istr = mangle_internal_name_by_path(ccx, path);\n     let llfn: ValueRef = decl_internal_fastcall_fn(ccx.llmod,\n-                                                   istr::to_estr(s), llfty);\n+                                                   s, llfty);\n     // Declare the global constant pair that points to it.\n \n     let ps: istr = mangle_exported_name(ccx, path, node_type);\n-    register_fn_pair(ccx, istr::to_estr(ps), llfty, llfn, node_id);\n+    register_fn_pair(ccx, ps, llfty, llfn, node_id);\n \n     let is_main: bool = is_main_name(path) && !ccx.sess.get_opts().library;\n     if is_main { create_main_wrapper(ccx, sp, llfn, node_type); }\n@@ -5793,7 +5796,7 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n         let llfty =\n             type_of_fn(ccx, sp, ast::proto_fn, [ivecarg_ty],\n                        ty::mk_nil(ccx.tcx), 0u);\n-        let llfdecl = decl_fastcall_fn(ccx.llmod, \"_rust_main\", llfty);\n+        let llfdecl = decl_fastcall_fn(ccx.llmod, ~\"_rust_main\", llfty);\n \n         let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, llfdecl);\n \n@@ -5822,9 +5825,9 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n // Create a closure: a pair containing (1) a ValueRef, pointing to where the\n // fn's definition is in the executable we're creating, and (2) a pointer to\n // space for the function's environment.\n-fn create_fn_pair(cx: &@crate_ctxt, ps: str, llfnty: TypeRef, llfn: ValueRef,\n-                  external: bool) -> ValueRef {\n-    let gvar = istr::as_buf(istr::from_estr(ps), { |buf|\n+fn create_fn_pair(cx: &@crate_ctxt, ps: &istr, llfnty: TypeRef,\n+                  llfn: ValueRef, external: bool) -> ValueRef {\n+    let gvar = istr::as_buf(ps, { |buf|\n         llvm::LLVMAddGlobal(cx.llmod, T_fn_pair(*cx, llfnty), buf)\n     });\n     let pair = C_struct([llfn, C_null(T_opaque_closure_ptr(*cx))]);\n@@ -5854,14 +5857,14 @@ fn create_real_fn_pair(cx: &@block_ctxt, llfnty: TypeRef, llfn: ValueRef,\n     ret pair;\n }\n \n-fn register_fn_pair(cx: &@crate_ctxt, ps: str, llfnty: TypeRef,\n+fn register_fn_pair(cx: &@crate_ctxt, ps: &istr, llfnty: TypeRef,\n                     llfn: ValueRef, id: ast::node_id) {\n     // FIXME: We should also hide the unexported pairs in crates.\n \n     let gvar =\n         create_fn_pair(cx, ps, llfnty, llfn, cx.sess.get_opts().library);\n     cx.item_ids.insert(id, llfn);\n-    cx.item_symbols.insert(id, istr::from_estr(ps));\n+    cx.item_symbols.insert(id, ps);\n     cx.fn_pairs.insert(id, gvar);\n }\n \n@@ -5892,9 +5895,9 @@ fn native_fn_wrapper_type(cx: &@crate_ctxt, sp: &span, ty_param_count: uint,\n     }\n }\n \n-fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n-                           name: str, id: ast::node_id) {\n-    let path = istr::from_estrs(path);\n+fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[istr],\n+                           name: &istr, id: ast::node_id) {\n+    let path = path;\n     let num_ty_param = native_fn_ty_param_count(ccx, id);\n     // Declare the wrapper.\n \n@@ -5903,11 +5906,11 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n     let s: istr = mangle_internal_name_by_path(ccx, path);\n     let wrapper_fn: ValueRef =\n         decl_internal_fastcall_fn(ccx.llmod,\n-                                  istr::to_estr(s), wrapper_type);\n+                                  s, wrapper_type);\n     // Declare the global constant pair that points to it.\n \n     let ps: istr = mangle_exported_name(ccx, path, node_id_type(ccx, id));\n-    register_fn_pair(ccx, istr::to_estr(ps), wrapper_type, wrapper_fn, id);\n+    register_fn_pair(ccx, ps, wrapper_type, wrapper_fn, id);\n     // Build the wrapper.\n \n     let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, wrapper_fn);\n@@ -5994,7 +5997,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n         ret vp2i(cx, v);\n     }\n \n-    fn trans_simple_native_abi(bcx: &@block_ctxt, name: str,\n+    fn trans_simple_native_abi(bcx: &@block_ctxt, name: &istr,\n                                call_args: &mutable [ValueRef], fn_type: ty::t,\n                                uses_retptr: bool, cc: uint) ->\n        {val: ValueRef, rptr: ValueRef} {\n@@ -6046,7 +6049,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n         rptr = result.rptr;\n       }\n       ast::native_abi_rust_intrinsic. {\n-        let external_name = \"rust_intrinsic_\" + name;\n+        let external_name = ~\"rust_intrinsic_\" + name;\n         let result =\n             trans_simple_native_abi(bcx, external_name, call_args, fn_type,\n                                     uses_retptr, lib::llvm::LLVMCCallConv);\n@@ -6077,29 +6080,29 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n     finish_fn(fcx, lltop);\n }\n \n-fn item_path(item: &@ast::item) -> [str] { ret [istr::to_estr(item.ident)]; }\n+fn item_path(item: &@ast::item) -> [istr] { ret [item.ident]; }\n \n-fn collect_native_item(ccx: @crate_ctxt, i: &@ast::native_item, pt: &[str],\n-                       _v: &vt<[str]>) {\n+fn collect_native_item(ccx: @crate_ctxt, i: &@ast::native_item, pt: &[istr],\n+                       _v: &vt<[istr]>) {\n     alt i.node {\n       ast::native_item_fn(_, _, _) {\n         if !ccx.obj_methods.contains_key(i.id) {\n             decl_native_fn_and_pair(ccx, i.span, pt,\n-                                    istr::to_estr(i.ident), i.id);\n+                                    i.ident, i.id);\n         }\n       }\n       _ { }\n     }\n }\n \n-fn collect_item_1(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n-                  v: &vt<[str]>) {\n+fn collect_item_1(ccx: @crate_ctxt, i: &@ast::item, pt: &[istr],\n+                  v: &vt<[istr]>) {\n     visit::visit_item(i, pt + item_path(i), v);\n     alt i.node {\n       ast::item_const(_, _) {\n         let typ = node_id_type(ccx, i.id);\n         let s =\n-            mangle_exported_name(ccx, istr::from_estrs(pt) + [i.ident],\n+            mangle_exported_name(ccx, pt + [i.ident],\n                                  node_id_type(ccx, i.id));\n         let g = istr::as_buf(s, { |buf|\n             llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, i.span, typ), buf)\n@@ -6111,29 +6114,29 @@ fn collect_item_1(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n     }\n }\n \n-fn collect_item_2(ccx: &@crate_ctxt, i: &@ast::item, pt: &[str],\n-                  v: &vt<[str]>) {\n+fn collect_item_2(ccx: &@crate_ctxt, i: &@ast::item, pt: &[istr],\n+                  v: &vt<[istr]>) {\n     let new_pt = pt + item_path(i);\n     visit::visit_item(i, new_pt, v);\n     alt i.node {\n       ast::item_fn(f, tps) {\n         if !ccx.obj_methods.contains_key(i.id) {\n-            decl_fn_and_pair(ccx, i.span, new_pt, \"fn\", tps, i.id);\n+            decl_fn_and_pair(ccx, i.span, new_pt, ~\"fn\", tps, i.id);\n         }\n       }\n       ast::item_obj(ob, tps, ctor_id) {\n-        decl_fn_and_pair(ccx, i.span, new_pt, \"obj_ctor\", tps, ctor_id);\n+        decl_fn_and_pair(ccx, i.span, new_pt, ~\"obj_ctor\", tps, ctor_id);\n         for m: @ast::method in ob.methods {\n             ccx.obj_methods.insert(m.node.id, ());\n         }\n       }\n       ast::item_res(_, dtor_id, tps, ctor_id) {\n-        decl_fn_and_pair(ccx, i.span, new_pt, \"res_ctor\", tps, ctor_id);\n+        decl_fn_and_pair(ccx, i.span, new_pt, ~\"res_ctor\", tps, ctor_id);\n         // Note that the destructor is associated with the item's id, not\n         // the dtor_id. This is a bit counter-intuitive, but simplifies\n         // ty_res, which would have to carry around two def_ids otherwise\n         // -- one to identify the type, and one to find the dtor symbol.\n-        decl_fn_and_pair_full(ccx, i.span, new_pt, \"res_dtor\", tps, i.id,\n+        decl_fn_and_pair_full(ccx, i.span, new_pt, ~\"res_dtor\", tps, i.id,\n                               node_id_type(ccx, dtor_id));\n       }\n       _ { }\n@@ -6151,17 +6154,17 @@ fn collect_items(ccx: &@crate_ctxt, crate: @ast::crate) {\n     visit::visit_crate(*crate, [], visit::mk_vt(visitor2));\n }\n \n-fn collect_tag_ctor(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n-                    v: &vt<[str]>) {\n+fn collect_tag_ctor(ccx: @crate_ctxt, i: &@ast::item, pt: &[istr],\n+                    v: &vt<[istr]>) {\n     let new_pt = pt + item_path(i);\n     visit::visit_item(i, new_pt, v);\n     alt i.node {\n       ast::item_tag(variants, tps) {\n         for variant: ast::variant in variants {\n             if std::vec::len(variant.node.args) != 0u {\n                 decl_fn_and_pair(ccx, i.span,\n-                                 new_pt + [istr::to_estr(variant.node.name)],\n-                                 \"tag\", tps, variant.node.id);\n+                                 new_pt + [variant.node.name],\n+                                 ~\"tag\", tps, variant.node.id);\n             }\n         }\n       }\n@@ -6178,8 +6181,8 @@ fn collect_tag_ctors(ccx: &@crate_ctxt, crate: @ast::crate) {\n \n \n // The constant translation pass.\n-fn trans_constant(ccx: @crate_ctxt, it: &@ast::item, pt: &[str],\n-                  v: &vt<[str]>) {\n+fn trans_constant(ccx: @crate_ctxt, it: &@ast::item, pt: &[istr],\n+                  v: &vt<[istr]>) {\n     let new_pt = pt + item_path(it);\n     visit::visit_item(it, new_pt, v);\n     alt it.node {\n@@ -6188,9 +6191,9 @@ fn trans_constant(ccx: @crate_ctxt, it: &@ast::item, pt: &[str],\n         let n_variants = std::vec::len::<ast::variant>(variants);\n         while i < n_variants {\n             let variant = variants[i];\n-            let p = istr::from_estrs(new_pt) + [it.ident,\n-                                                variant.node.name,\n-                                                ~\"discrim\"];\n+            let p = new_pt + [it.ident,\n+                              variant.node.name,\n+                              ~\"discrim\"];\n             let s = mangle_exported_name(ccx, p,\n                                          ty::mk_int(ccx.tcx));\n             let discrim_gvar = istr::as_buf(s, { |buf|\n@@ -6237,24 +6240,25 @@ fn declare_intrinsics(llmod: ModuleRef) -> hashmap<istr, ValueRef> {\n         [T_ptr(T_i8()), T_i8(), T_i64(), T_i32(), T_i1()];\n     let T_trap_args: [TypeRef] = [];\n     let gcroot =\n-        decl_cdecl_fn(llmod, \"llvm.gcroot\",\n+        decl_cdecl_fn(llmod, ~\"llvm.gcroot\",\n                       T_fn([T_ptr(T_ptr(T_i8())), T_ptr(T_i8())], T_void()));\n     let gcread =\n-        decl_cdecl_fn(llmod, \"llvm.gcread\",\n+        decl_cdecl_fn(llmod, ~\"llvm.gcread\",\n                       T_fn([T_ptr(T_i8()), T_ptr(T_ptr(T_i8()))], T_void()));\n     let memmove32 =\n-        decl_cdecl_fn(llmod, \"llvm.memmove.p0i8.p0i8.i32\",\n+        decl_cdecl_fn(llmod, ~\"llvm.memmove.p0i8.p0i8.i32\",\n                       T_fn(T_memmove32_args, T_void()));\n     let memmove64 =\n-        decl_cdecl_fn(llmod, \"llvm.memmove.p0i8.p0i8.i64\",\n+        decl_cdecl_fn(llmod, ~\"llvm.memmove.p0i8.p0i8.i64\",\n                       T_fn(T_memmove64_args, T_void()));\n     let memset32 =\n-        decl_cdecl_fn(llmod, \"llvm.memset.p0i8.i32\",\n+        decl_cdecl_fn(llmod, ~\"llvm.memset.p0i8.i32\",\n                       T_fn(T_memset32_args, T_void()));\n     let memset64 =\n-        decl_cdecl_fn(llmod, \"llvm.memset.p0i8.i64\",\n+        decl_cdecl_fn(llmod, ~\"llvm.memset.p0i8.i64\",\n                       T_fn(T_memset64_args, T_void()));\n-    let trap = decl_cdecl_fn(llmod, \"llvm.trap\", T_fn(T_trap_args, T_void()));\n+    let trap = decl_cdecl_fn(llmod, ~\"llvm.trap\",\n+                             T_fn(T_trap_args, T_void()));\n     let intrinsics = new_str_hash::<ValueRef>();\n     intrinsics.insert(~\"llvm.gcroot\", gcroot);\n     intrinsics.insert(~\"llvm.gcread\", gcread);\n@@ -6277,7 +6281,7 @@ fn trap(bcx: &@block_ctxt) {\n fn decl_no_op_type_glue(llmod: ModuleRef, taskptr_type: TypeRef) -> ValueRef {\n     let ty = T_fn([taskptr_type, T_ptr(T_i8())], T_void());\n     ret decl_fastcall_fn(llmod,\n-                         istr::to_estr(abi::no_op_type_glue_name()), ty);\n+                         abi::no_op_type_glue_name(), ty);\n }\n \n fn vec_fill(bcx: &@block_ctxt, v: ValueRef) -> ValueRef {\n@@ -6294,7 +6298,7 @@ fn make_glues(llmod: ModuleRef, taskptr_type: TypeRef) -> @glue_fns {\n     ret @{no_op_type_glue: decl_no_op_type_glue(llmod, taskptr_type)};\n }\n \n-fn make_common_glue(sess: &session::session, output: &str) {\n+fn make_common_glue(sess: &session::session, output: &istr) {\n     // FIXME: part of this is repetitive and is probably a good idea\n     // to autogen it.\n     let task_type = T_task();\n@@ -6316,7 +6320,7 @@ fn make_common_glue(sess: &session::session, output: &str) {\n         llvm::LLVMSetModuleInlineAsm(llmod, buf)\n     });\n     make_glues(llmod, taskptr_type);\n-    link::write::run_passes(sess, llmod, istr::from_estr(output));\n+    link::write::run_passes(sess, llmod, output);\n }\n \n fn create_module_map(ccx: &@crate_ctxt) -> ValueRef {\n@@ -6404,7 +6408,7 @@ fn write_abi_version(ccx: &@crate_ctxt) {\n }\n \n fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n-               output: &str, amap: &ast_map::map, mut_map: alias::mut_map)\n+               output: &istr, amap: &ast_map::map, mut_map: alias::mut_map)\n     -> ModuleRef {\n     let llmod = istr::as_buf(~\"rust_out\", { |buf|\n         llvm::LLVMModuleCreateWithNameInContext(buf,\n@@ -6445,7 +6449,7 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n           item_symbols: new_int_hash::<istr>(),\n           mutable main_fn: none::<ValueRef>,\n           link_meta: link::build_link_meta(sess, *crate,\n-                                           istr::from_estr(output), sha),\n+                                           output, sha),\n           tag_sizes: tag_sizes,\n           discrims: new_int_hash::<ValueRef>(),\n           discrim_symbols: new_int_hash::<istr>(),\n@@ -6498,8 +6502,9 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n         log_err #fmt[\"n_real_glues: %u\", ccx.stats.n_real_glues];\n \n \n-        for timing: {ident: str, time: int} in *ccx.stats.fn_times {\n-            log_err #fmt[\"time: %s took %d ms\", timing.ident, timing.time];\n+        for timing: {ident: istr, time: int} in *ccx.stats.fn_times {\n+            log_err #fmt[\"time: %s took %d ms\",\n+                         istr::to_estr(timing.ident), timing.time];\n         }\n     }\n     ret llmod;"}, {"sha": "4491fca0e200b4f5a4b6d4b4b5169f10fda6f30c", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=9e01e05f3b2ba2f726271889c2bbb04c6b44aef1", "patch": "@@ -296,9 +296,9 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n         let data = m[0].data;\n         alt data.guard {\n           some(e) {\n-            let guard_cx = new_scope_block_ctxt(bcx, \"guard\");\n-            let next_cx = new_sub_block_ctxt(bcx, \"next\");\n-            let else_cx = new_sub_block_ctxt(bcx, \"else\");\n+            let guard_cx = new_scope_block_ctxt(bcx, ~\"guard\");\n+            let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n+            let else_cx = new_sub_block_ctxt(bcx, ~\"else\");\n             bld::Br(bcx, guard_cx.llbb);\n             // Temporarily set bindings. They'll be rewritten to PHI nodes for\n             // the actual arm block.\n@@ -413,7 +413,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n     let else_cx =\n         alt kind {\n           no_branch. | single. { bcx }\n-          _ { new_sub_block_ctxt(bcx, \"match_else\") }\n+          _ { new_sub_block_ctxt(bcx, ~\"match_else\") }\n         };\n     let sw =\n         if kind == switch {\n@@ -422,7 +422,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n \n      // Compile subtrees for each option\n     for opt: opt in opts {\n-        let opt_cx = new_sub_block_ctxt(bcx, \"match_case\");\n+        let opt_cx = new_sub_block_ctxt(bcx, ~\"match_case\");\n         alt kind {\n           single. { bld::Br(bcx, opt_cx.llbb); }\n           switch. {\n@@ -436,7 +436,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n             let t = ty::node_id_to_type(ccx.tcx, pat_id);\n             let eq =\n                 trans::trans_compare(bcx, ast::eq, test_val, t, r.val, t);\n-            bcx = new_sub_block_ctxt(bcx, \"next\");\n+            bcx = new_sub_block_ctxt(bcx, ~\"next\");\n             bld::CondBr(eq.bcx, eq.val, opt_cx.llbb, bcx.llbb);\n           }\n           _ { }\n@@ -503,7 +503,7 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n     }\n \n     for a: ast::arm in arms {\n-        let body = new_scope_block_ctxt(cx, \"case_body\");\n+        let body = new_scope_block_ctxt(cx, ~\"case_body\");\n         let id_map = ast_util::pat_id_map(a.pats[0]);\n         bodies += [body];\n         for p: @ast::pat in a.pats {\n@@ -520,8 +520,8 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n     fn mk_fail(cx: &@block_ctxt, sp: &span,\n                done: @mutable option::t<BasicBlockRef>) -> BasicBlockRef {\n         alt *done { some(bb) { ret bb; } _ { } }\n-        let fail_cx = new_sub_block_ctxt(cx, \"case_fallthrough\");\n-        trans::trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");;\n+        let fail_cx = new_sub_block_ctxt(cx, ~\"case_fallthrough\");\n+        trans::trans_fail(fail_cx, some(sp), ~\"non-exhaustive match failure\");\n         *done = some(fail_cx.llbb);\n         ret fail_cx.llbb;\n     }"}, {"sha": "8914ad2154f9d56f0c7f6a255fc1bf0f260ed056", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=9e01e05f3b2ba2f726271889c2bbb04c6b44aef1", "patch": "@@ -111,7 +111,7 @@ type stats =\n      mutable n_glues_created: uint,\n      mutable n_null_glues: uint,\n      mutable n_real_glues: uint,\n-     fn_times: @mutable [{ident: str, time: int}]};\n+     fn_times: @mutable [{ident: istr, time: int}]};\n \n resource BuilderRef_res(B: llvm::BuilderRef) {\n     llvm::LLVMDisposeBuilder(B);\n@@ -354,8 +354,9 @@ fn get_res_dtor(ccx: &@crate_ctxt, sp: &span, did: &ast::def_id,\n                           [{mode: ty::mo_alias(false), ty: inner_t}],\n                           ty::mk_nil(ccx.tcx), params);\n     ret trans::get_extern_const(ccx.externs, ccx.llmod,\n-                                csearch::get_symbol(ccx.sess.get_cstore(),\n-                                                    did),\n+                                istr::from_estr(csearch::get_symbol(\n+                                    ccx.sess.get_cstore(),\n+                                    did)),\n                                 T_fn_pair(*ccx, f_t));\n }\n "}, {"sha": "a725b616c0c950f7cd796639f644393bfb2aa269", "filename": "src/comp/middle/trans_ivec.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs?ref=9e01e05f3b2ba2f726271889c2bbb04c6b44aef1", "patch": "@@ -148,8 +148,8 @@ fn get_len_and_data(bcx: &@block_ctxt, orig_v: ValueRef, unit_ty: ty::t)\n                                C_int(0)]);\n     let on_heap =\n         bld::ICmp(bcx, lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n-    let on_heap_cx = new_sub_block_ctxt(bcx, \"on_heap\");\n-    let next_cx = new_sub_block_ctxt(bcx, \"next\");\n+    let on_heap_cx = new_sub_block_ctxt(bcx, ~\"on_heap\");\n+    let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n     bld::CondBr(bcx, on_heap, on_heap_cx.llbb, next_cx.llbb);\n     let heap_stub =\n         bld::PointerCast(on_heap_cx, v, T_ptr(T_ivec_heap(llunitty)));\n@@ -165,8 +165,8 @@ fn get_len_and_data(bcx: &@block_ctxt, orig_v: ValueRef, unit_ty: ty::t)\n     let heap_ptr_is_null =\n         bld::ICmp(on_heap_cx, lib::llvm::LLVMIntEQ, heap_ptr,\n                               C_null(T_ptr(llheapptrty)));\n-    let zero_len_cx = new_sub_block_ctxt(bcx, \"zero_len\");\n-    let nonzero_len_cx = new_sub_block_ctxt(bcx, \"nonzero_len\");\n+    let zero_len_cx = new_sub_block_ctxt(bcx, ~\"zero_len\");\n+    let nonzero_len_cx = new_sub_block_ctxt(bcx, ~\"nonzero_len\");\n     bld::CondBr(on_heap_cx, heap_ptr_is_null, zero_len_cx.llbb,\n                             nonzero_len_cx.llbb);\n     // Technically this context is unnecessary, but it makes this function\n@@ -220,11 +220,11 @@ fn reserve_space(cx: &@block_ctxt, llunitty: TypeRef, v: ValueRef,\n \n     let maybe_on_heap =\n         bld::ICmp(cx, lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n-    let maybe_on_heap_cx = new_sub_block_ctxt(cx, \"maybe_on_heap\");\n-    let on_stack_cx = new_sub_block_ctxt(cx, \"on_stack\");\n+    let maybe_on_heap_cx = new_sub_block_ctxt(cx, ~\"maybe_on_heap\");\n+    let on_stack_cx = new_sub_block_ctxt(cx, ~\"on_stack\");\n     bld::CondBr(cx, maybe_on_heap, maybe_on_heap_cx.llbb,\n                     on_stack_cx.llbb);\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n+    let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n     // We're possibly on the heap, unless the vector is zero-length.\n \n     let stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n@@ -235,7 +235,7 @@ fn reserve_space(cx: &@block_ctxt, llunitty: TypeRef, v: ValueRef,\n     let on_heap =\n         bld::ICmp(maybe_on_heap_cx, lib::llvm::LLVMIntNE, heap_ptr,\n                                     C_null(val_ty(heap_ptr)));\n-    let on_heap_cx = new_sub_block_ctxt(cx, \"on_heap\");\n+    let on_heap_cx = new_sub_block_ctxt(cx, ~\"on_heap\");\n     bld::CondBr(maybe_on_heap_cx, on_heap, on_heap_cx.llbb,\n                                   on_stack_cx.llbb);\n     // We're definitely on the heap. Check whether we need to resize.\n@@ -250,8 +250,8 @@ fn reserve_space(cx: &@block_ctxt, llunitty: TypeRef, v: ValueRef,\n         bld::UDiv(on_heap_cx, heap_len, llsize_of(llunitty));\n     let heap_no_resize_needed =\n         bld::ICmp(on_heap_cx, lib::llvm::LLVMIntULE, new_heap_len, alen);\n-    let heap_no_resize_cx = new_sub_block_ctxt(cx, \"heap_no_resize\");\n-    let heap_resize_cx = new_sub_block_ctxt(cx, \"heap_resize\");\n+    let heap_no_resize_cx = new_sub_block_ctxt(cx, ~\"heap_no_resize\");\n+    let heap_resize_cx = new_sub_block_ctxt(cx, ~\"heap_resize\");\n     bld::CondBr(on_heap_cx, heap_no_resize_needed, heap_no_resize_cx.llbb,\n                             heap_resize_cx.llbb);\n     // Case (1): We're on the heap and don't need to resize.\n@@ -293,8 +293,8 @@ fn reserve_space(cx: &@block_ctxt, llunitty: TypeRef, v: ValueRef,\n                                alen);\n     let stack_len_unscaled =\n         bld::UDiv(on_stack_cx, stack_len, llsize_of(llunitty));\n-    let stack_no_spill_cx = new_sub_block_ctxt(cx, \"stack_no_spill\");\n-    let stack_spill_cx = new_sub_block_ctxt(cx, \"stack_spill\");\n+    let stack_no_spill_cx = new_sub_block_ctxt(cx, ~\"stack_no_spill\");\n+    let stack_spill_cx = new_sub_block_ctxt(cx, ~\"stack_spill\");\n     bld::CondBr(on_stack_cx, stack_no_spill_needed,\n                              stack_no_spill_cx.llbb, stack_spill_cx.llbb);\n     // Case (3): We're on the stack and don't need to spill.\n@@ -412,14 +412,14 @@ fn trans_append(cx: &@block_ctxt, t: ty::t, lhs: ValueRef,\n     bld::Store(bcx, lhs_data, dest_ptr);\n     let src_ptr = alloca(bcx, T_ptr(llunitty));\n     bld::Store(bcx, rhs_data, src_ptr);\n-    let copy_loop_header_cx = new_sub_block_ctxt(bcx, \"copy_loop_header\");\n+    let copy_loop_header_cx = new_sub_block_ctxt(bcx, ~\"copy_loop_header\");\n     bld::Br(bcx, copy_loop_header_cx.llbb);\n     let copy_dest_ptr = bld::Load(copy_loop_header_cx, dest_ptr);\n     let not_yet_at_end =\n         bld::ICmp(copy_loop_header_cx, lib::llvm::LLVMIntNE,\n                                        copy_dest_ptr, lhs_end);\n-    let copy_loop_body_cx = new_sub_block_ctxt(bcx, \"copy_loop_body\");\n-    let next_cx = new_sub_block_ctxt(bcx, \"next\");\n+    let copy_loop_body_cx = new_sub_block_ctxt(bcx, ~\"copy_loop_body\");\n+    let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n     bld::CondBr(copy_loop_header_cx, not_yet_at_end,\n                                      copy_loop_body_cx.llbb,\n                                      next_cx.llbb);\n@@ -547,8 +547,8 @@ fn trans_add(cx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n \n     let len_is_zero =\n         bld::ICmp(bcx, lib::llvm::LLVMIntEQ, lllen, C_int(0));\n-    let zero_len_cx = new_sub_block_ctxt(bcx, \"zero_len\");\n-    let nonzero_len_cx = new_sub_block_ctxt(bcx, \"nonzero_len\");\n+    let zero_len_cx = new_sub_block_ctxt(bcx, ~\"zero_len\");\n+    let nonzero_len_cx = new_sub_block_ctxt(bcx, ~\"nonzero_len\");\n     bld::CondBr(bcx, len_is_zero, zero_len_cx.llbb, nonzero_len_cx.llbb);\n     // Case (1): Length is zero.\n \n@@ -571,14 +571,14 @@ fn trans_add(cx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n     bld::Store(zero_len_cx, C_null(T_ptr(llheappartty)),\n                             bld::InBoundsGEP(zero_len_cx, stub_ptr_zero,\n                                                           stub_p));\n-    let next_cx = new_sub_block_ctxt(bcx, \"next\");\n+    let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n     bld::Br(zero_len_cx, next_cx.llbb);\n     // Determine whether we need to spill to the heap.\n \n     let on_stack =\n         bld::ICmp(nonzero_len_cx, lib::llvm::LLVMIntULE, lllen, llalen);\n-    let stack_cx = new_sub_block_ctxt(bcx, \"stack\");\n-    let heap_cx = new_sub_block_ctxt(bcx, \"heap\");\n+    let stack_cx = new_sub_block_ctxt(bcx, ~\"stack\");\n+    let heap_cx = new_sub_block_ctxt(bcx, ~\"heap\");\n     bld::CondBr(nonzero_len_cx, on_stack, stack_cx.llbb, heap_cx.llbb);\n     // Case (2): Copy onto stack.\n \n@@ -590,7 +590,7 @@ fn trans_add(cx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n         bld::InBoundsGEP(stack_cx, llvecptr,\n                                    [C_int(0), C_uint(abi::ivec_elt_elems),\n                                     C_int(0)]);\n-    let copy_cx = new_sub_block_ctxt(bcx, \"copy\");\n+    let copy_cx = new_sub_block_ctxt(bcx, ~\"copy\");\n     bld::Br(stack_cx, copy_cx.llbb);\n     // Case (3): Allocate on heap and copy there.\n \n@@ -644,16 +644,16 @@ fn trans_add(cx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n     bld::Store(copy_cx, lhs_data, lhs_ptr_ptr);\n     let rhs_ptr_ptr = alloca(copy_cx, T_ptr(llunitty));\n     bld::Store(copy_cx, rhs_data, rhs_ptr_ptr);\n-    let lhs_copy_cx = new_sub_block_ctxt(bcx, \"lhs_copy\");\n+    let lhs_copy_cx = new_sub_block_ctxt(bcx, ~\"lhs_copy\");\n     bld::Br(copy_cx, lhs_copy_cx.llbb);\n     // Copy in elements from the LHS.\n \n     let lhs_ptr = bld::Load(lhs_copy_cx, lhs_ptr_ptr);\n     let not_at_end_lhs =\n         bld::ICmp(lhs_copy_cx, lib::llvm::LLVMIntNE, lhs_ptr,\n                                lhs_end_ptr);\n-    let lhs_do_copy_cx = new_sub_block_ctxt(bcx, \"lhs_do_copy\");\n-    let rhs_copy_cx = new_sub_block_ctxt(bcx, \"rhs_copy\");\n+    let lhs_do_copy_cx = new_sub_block_ctxt(bcx, ~\"lhs_do_copy\");\n+    let rhs_copy_cx = new_sub_block_ctxt(bcx, ~\"rhs_copy\");\n     bld::CondBr(lhs_copy_cx, not_at_end_lhs, lhs_do_copy_cx.llbb,\n                              rhs_copy_cx.llbb);\n     let dest_ptr_lhs_copy = bld::Load(lhs_do_copy_cx, dest_ptr_ptr);\n@@ -680,7 +680,7 @@ fn trans_add(cx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n     let not_at_end_rhs =\n         bld::ICmp(rhs_copy_cx, lib::llvm::LLVMIntNE, rhs_ptr,\n                                rhs_end_ptr);\n-    let rhs_do_copy_cx = new_sub_block_ctxt(bcx, \"rhs_do_copy\");\n+    let rhs_do_copy_cx = new_sub_block_ctxt(bcx, ~\"rhs_do_copy\");\n     bld::CondBr(rhs_copy_cx, not_at_end_rhs, rhs_do_copy_cx.llbb,\n                              next_cx.llbb);\n     let dest_ptr_rhs_copy = bld::Load(rhs_do_copy_cx, dest_ptr_ptr);\n@@ -726,8 +726,8 @@ fn duplicate_heap_part(cx: &@block_ctxt, orig_vptr: ValueRef,\n     let stack_len = bld::Load(cx, stack_len_ptr);\n     let stack_len_is_zero =\n         bld::ICmp(cx, lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n-    let maybe_on_heap_cx = new_sub_block_ctxt(cx, \"maybe_on_heap\");\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n+    let maybe_on_heap_cx = new_sub_block_ctxt(cx, ~\"maybe_on_heap\");\n+    let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n     bld::CondBr(cx, stack_len_is_zero, maybe_on_heap_cx.llbb,\n                     next_cx.llbb);\n \n@@ -743,7 +743,7 @@ fn duplicate_heap_part(cx: &@block_ctxt, orig_vptr: ValueRef,\n     let heap_ptr_is_nonnull =\n         bld::ICmp(maybe_on_heap_cx, lib::llvm::LLVMIntNE, heap_ptr,\n                                     C_null(T_ptr(llheappartty)));\n-    let on_heap_cx = new_sub_block_ctxt(cx, \"on_heap\");\n+    let on_heap_cx = new_sub_block_ctxt(cx, ~\"on_heap\");\n     bld::CondBr(maybe_on_heap_cx, heap_ptr_is_nonnull, on_heap_cx.llbb,\n                                   next_cx.llbb);\n "}, {"sha": "7dee2705aece27d86a873cb4041e6a0e9f04e82c", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e01e05f3b2ba2f726271889c2bbb04c6b44aef1/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=9e01e05f3b2ba2f726271889c2bbb04c6b44aef1", "patch": "@@ -616,7 +616,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n                         std::vec::len::<ast::ty_param>(ty_params));\n     let llbackwarding_fn: ValueRef =\n         decl_internal_fastcall_fn(\n-            cx.ccx.llmod, istr::to_estr(s), llbackwarding_fn_ty);\n+            cx.ccx.llmod, s, llbackwarding_fn_ty);\n \n     // Create a new function context and block context for the backwarding\n     // function, holding onto a pointer to the first block.\n@@ -747,7 +747,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n                         std::vec::len::<ast::ty_param>(ty_params));\n     let llforwarding_fn: ValueRef =\n         decl_internal_fastcall_fn(\n-            cx.ccx.llmod, istr::to_estr(s), llforwarding_fn_ty);\n+            cx.ccx.llmod, s, llforwarding_fn_ty);\n \n     // Create a new function context and block context for the forwarding\n     // function, holding onto a pointer to the first block.\n@@ -930,7 +930,7 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n     let s: istr = mangle_internal_name_by_path(mcx.ccx,\n                                                mcx.path);\n     let llfn: ValueRef = decl_internal_fastcall_fn(\n-        cx.ccx.llmod, istr::to_estr(s), llfnty);\n+        cx.ccx.llmod, s, llfnty);\n \n     // Every method on an object gets its node_id inserted into the crate-wide\n     // item_ids map, together with the ValueRef that points to where that"}]}