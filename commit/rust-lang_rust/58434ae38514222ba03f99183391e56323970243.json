{"sha": "58434ae38514222ba03f99183391e56323970243", "node_id": "C_kwDOAAsO6NoAKDU4NDM0YWUzODUxNDIyMmJhMDNmOTkxODMzOTFlNTYzMjM5NzAyNDM", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-08T16:55:48Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-29T17:42:59Z"}, "message": "Extract util functions from `redundant_pattern_match`", "tree": {"sha": "7a1ebe2e70c3e9b1c75a81464d9152ba65e42b3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a1ebe2e70c3e9b1c75a81464d9152ba65e42b3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58434ae38514222ba03f99183391e56323970243", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58434ae38514222ba03f99183391e56323970243", "html_url": "https://github.com/rust-lang/rust/commit/58434ae38514222ba03f99183391e56323970243", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58434ae38514222ba03f99183391e56323970243/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70f1d0d8fd702d8d761ce5c15df5b238ab59c250", "url": "https://api.github.com/repos/rust-lang/rust/commits/70f1d0d8fd702d8d761ce5c15df5b238ab59c250", "html_url": "https://github.com/rust-lang/rust/commit/70f1d0d8fd702d8d761ce5c15df5b238ab59c250"}], "stats": {"total": 215, "additions": 131, "deletions": 84}, "files": [{"sha": "8499e050af2426898ede4a71210d0a4ef8451785", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 4, "deletions": 80, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/58434ae38514222ba03f99183391e56323970243/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58434ae38514222ba03f99183391e56323970243/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=58434ae38514222ba03f99183391e56323970243", "patch": "@@ -3,16 +3,13 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::needs_ordered_drop;\n-use clippy_utils::{higher, match_def_path};\n-use clippy_utils::{is_lang_ctor, is_trait_method, paths};\n+use clippy_utils::visitors::any_temporaries_need_ordered_drop;\n+use clippy_utils::{higher, is_lang_ctor, is_trait_method, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, PollPending};\n-use rustc_hir::{\n-    intravisit::{walk_expr, Visitor},\n-    Arm, Block, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp,\n-};\n+use rustc_hir::{Arm, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n use rustc_span::sym;\n@@ -47,79 +44,6 @@ fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n     }\n }\n \n-// Checks if there are any temporaries created in the given expression for which drop order\n-// matters.\n-fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    struct V<'a, 'tcx> {\n-        cx: &'a LateContext<'tcx>,\n-        res: bool,\n-    }\n-    impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n-        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-            match expr.kind {\n-                // Taking the reference of a value leaves a temporary\n-                // e.g. In `&String::new()` the string is a temporary value.\n-                // Remaining fields are temporary values\n-                // e.g. In `(String::new(), 0).1` the string is a temporary value.\n-                ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n-                    if !matches!(expr.kind, ExprKind::Path(_)) {\n-                        if needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n-                            self.res = true;\n-                        } else {\n-                            self.visit_expr(expr);\n-                        }\n-                    }\n-                },\n-                // the base type is always taken by reference.\n-                // e.g. In `(vec![0])[0]` the vector is a temporary value.\n-                ExprKind::Index(base, index) => {\n-                    if !matches!(base.kind, ExprKind::Path(_)) {\n-                        if needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n-                            self.res = true;\n-                        } else {\n-                            self.visit_expr(base);\n-                        }\n-                    }\n-                    self.visit_expr(index);\n-                },\n-                // Method calls can take self by reference.\n-                // e.g. In `String::new().len()` the string is a temporary value.\n-                ExprKind::MethodCall(_, [self_arg, args @ ..], _) => {\n-                    if !matches!(self_arg.kind, ExprKind::Path(_)) {\n-                        let self_by_ref = self\n-                            .cx\n-                            .typeck_results()\n-                            .type_dependent_def_id(expr.hir_id)\n-                            .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n-                        if self_by_ref && needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg)) {\n-                            self.res = true;\n-                        } else {\n-                            self.visit_expr(self_arg);\n-                        }\n-                    }\n-                    args.iter().for_each(|arg| self.visit_expr(arg));\n-                },\n-                // Either explicitly drops values, or changes control flow.\n-                ExprKind::DropTemps(_)\n-                | ExprKind::Ret(_)\n-                | ExprKind::Break(..)\n-                | ExprKind::Yield(..)\n-                | ExprKind::Block(Block { expr: None, .. }, _)\n-                | ExprKind::Loop(..) => (),\n-\n-                // Only consider the final expression.\n-                ExprKind::Block(Block { expr: Some(expr), .. }, _) => self.visit_expr(expr),\n-\n-                _ => walk_expr(self, expr),\n-            }\n-        }\n-    }\n-\n-    let mut v = V { cx, res: false };\n-    v.visit_expr(expr);\n-    v.res\n-}\n-\n fn find_sugg_for_if_let<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n@@ -191,7 +115,7 @@ fn find_sugg_for_if_let<'tcx>(\n     // scrutinee would be, so they have to be considered as well.\n     // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n     // for the duration if body.\n-    let needs_drop = needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n+    let needs_drop = needs_ordered_drop(cx, check_ty) || any_temporaries_need_ordered_drop(cx, let_expr);\n \n     // check that `while_let_on_iterator` lint does not trigger\n     if_chain! {"}, {"sha": "68cfa8c1aa8ec22e5a96a53e473759943cd018fa", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 127, "deletions": 4, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/58434ae38514222ba03f99183391e56323970243/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58434ae38514222ba03f99183391e56323970243/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=58434ae38514222ba03f99183391e56323970243", "patch": "@@ -1,16 +1,18 @@\n+use crate::ty::needs_ordered_drop;\n use crate::{get_enclosing_block, path_to_local_id};\n use core::ops::ControlFlow;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::intravisit::{self, walk_block, walk_expr, Visitor};\n use rustc_hir::{\n-    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Stmt, UnOp, UnsafeSource,\n-    Unsafety,\n+    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Let, QPath, Stmt, UnOp,\n+    UnsafeSource, Unsafety,\n };\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty;\n+use rustc_middle::ty::adjustment::Adjust;\n+use rustc_middle::ty::{self, Ty, TypeckResults};\n \n /// Convenience method for creating a `Visitor` with just `visit_expr` overridden and nested\n /// bodies (i.e. closures) are visited.\n@@ -494,3 +496,124 @@ pub fn for_each_local_use_after_expr<'tcx, B>(\n         ControlFlow::Continue(())\n     }\n }\n+\n+// Calls the given function for every unconsumed temporary created by the expression. Note the\n+// function is only guaranteed to be called for types which need to be dropped, but it may be called\n+// for other types.\n+pub fn for_each_unconsumed_temporary<'tcx, B>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'tcx>,\n+    mut f: impl FnMut(Ty<'tcx>) -> ControlFlow<B>,\n+) -> ControlFlow<B> {\n+    // Todo: Handle partially consumed values.\n+    fn helper<'tcx, B>(\n+        typeck: &'tcx TypeckResults<'tcx>,\n+        consume: bool,\n+        e: &'tcx Expr<'tcx>,\n+        f: &mut impl FnMut(Ty<'tcx>) -> ControlFlow<B>,\n+    ) -> ControlFlow<B> {\n+        if !consume\n+            || matches!(\n+                typeck.expr_adjustments(e),\n+                [adjust, ..] if matches!(adjust.kind, Adjust::Borrow(_) | Adjust::Deref(_))\n+            )\n+        {\n+            match e.kind {\n+                ExprKind::Path(QPath::Resolved(None, p))\n+                    if matches!(p.res, Res::Def(DefKind::Ctor(_, CtorKind::Const), _)) =>\n+                {\n+                    f(typeck.expr_ty(e))?;\n+                },\n+                ExprKind::Path(_)\n+                | ExprKind::Unary(UnOp::Deref, _)\n+                | ExprKind::Index(..)\n+                | ExprKind::Field(..)\n+                | ExprKind::AddrOf(..) => (),\n+                _ => f(typeck.expr_ty(e))?,\n+            }\n+        }\n+        match e.kind {\n+            ExprKind::AddrOf(_, _, e)\n+            | ExprKind::Field(e, _)\n+            | ExprKind::Unary(UnOp::Deref, e)\n+            | ExprKind::Match(e, ..)\n+            | ExprKind::Let(&Let { init: e, .. }) => {\n+                helper(typeck, false, e, f)?;\n+            },\n+            ExprKind::Block(&Block { expr: Some(e), .. }, _)\n+            | ExprKind::Box(e)\n+            | ExprKind::Cast(e, _)\n+            | ExprKind::Unary(_, e) => {\n+                helper(typeck, true, e, f)?;\n+            },\n+            ExprKind::Call(callee, args) => {\n+                helper(typeck, true, callee, f)?;\n+                for arg in args {\n+                    helper(typeck, true, arg, f)?;\n+                }\n+            },\n+            ExprKind::MethodCall(_, args, _) | ExprKind::Tup(args) | ExprKind::Array(args) => {\n+                for arg in args {\n+                    helper(typeck, true, arg, f)?;\n+                }\n+            },\n+            ExprKind::Index(borrowed, consumed)\n+            | ExprKind::Assign(borrowed, consumed, _)\n+            | ExprKind::AssignOp(_, borrowed, consumed) => {\n+                helper(typeck, false, borrowed, f)?;\n+                helper(typeck, true, consumed, f)?;\n+            },\n+            ExprKind::Binary(_, lhs, rhs) => {\n+                helper(typeck, true, lhs, f)?;\n+                helper(typeck, true, rhs, f)?;\n+            },\n+            ExprKind::Struct(_, fields, default) => {\n+                for field in fields {\n+                    helper(typeck, true, field.expr, f)?;\n+                }\n+                if let Some(default) = default {\n+                    helper(typeck, false, default, f)?;\n+                }\n+            },\n+            ExprKind::If(cond, then, else_expr) => {\n+                helper(typeck, true, cond, f)?;\n+                helper(typeck, true, then, f)?;\n+                if let Some(else_expr) = else_expr {\n+                    helper(typeck, true, else_expr, f)?;\n+                }\n+            },\n+            ExprKind::Type(e, _) => {\n+                helper(typeck, consume, e, f)?;\n+            },\n+\n+            // Either drops temporaries, jumps out of the current expression, or has no sub expression.\n+            ExprKind::DropTemps(_)\n+            | ExprKind::Ret(_)\n+            | ExprKind::Break(..)\n+            | ExprKind::Yield(..)\n+            | ExprKind::Block(..)\n+            | ExprKind::Loop(..)\n+            | ExprKind::Repeat(..)\n+            | ExprKind::Lit(_)\n+            | ExprKind::ConstBlock(_)\n+            | ExprKind::Closure { .. }\n+            | ExprKind::Path(_)\n+            | ExprKind::Continue(_)\n+            | ExprKind::InlineAsm(_)\n+            | ExprKind::Err => (),\n+        }\n+        ControlFlow::Continue(())\n+    }\n+    helper(cx.typeck_results(), true, e, &mut f)\n+}\n+\n+pub fn any_temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'tcx>) -> bool {\n+    for_each_unconsumed_temporary(cx, e, |ty| {\n+        if needs_ordered_drop(cx, ty) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    })\n+    .is_break()\n+}"}]}