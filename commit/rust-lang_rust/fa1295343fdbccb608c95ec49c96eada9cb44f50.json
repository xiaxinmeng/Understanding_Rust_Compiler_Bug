{"sha": "fa1295343fdbccb608c95ec49c96eada9cb44f50", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMTI5NTM0M2ZkYmNjYjYwOGM5NWVjNDljOTZlYWRhOWNiNDRmNTA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-10T07:51:09Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-10T08:25:32Z"}, "message": "Make free glue take a pointer to the heap part (box)\n\nThis way, it can be used to drop values without first spilling them.\n\nIssue #1012", "tree": {"sha": "4578872841844db919061aebde80739b92e41ddf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4578872841844db919061aebde80739b92e41ddf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa1295343fdbccb608c95ec49c96eada9cb44f50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa1295343fdbccb608c95ec49c96eada9cb44f50", "html_url": "https://github.com/rust-lang/rust/commit/fa1295343fdbccb608c95ec49c96eada9cb44f50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa1295343fdbccb608c95ec49c96eada9cb44f50/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96f6a1861c7de555d2ece57d049fc86c50458e57", "url": "https://api.github.com/repos/rust-lang/rust/commits/96f6a1861c7de555d2ece57d049fc86c50458e57", "html_url": "https://github.com/rust-lang/rust/commit/96f6a1861c7de555d2ece57d049fc86c50458e57"}], "stats": {"total": 137, "additions": 67, "deletions": 70}, "files": [{"sha": "16b70e37cbf221163877b7e7cc141aeed4f36f1f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/fa1295343fdbccb608c95ec49c96eada9cb44f50/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1295343fdbccb608c95ec49c96eada9cb44f50/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=fa1295343fdbccb608c95ec49c96eada9cb44f50", "patch": "@@ -46,6 +46,12 @@ import trans_build::*;\n import trans_objects::{trans_anon_obj, trans_obj};\n import tvec = trans_vec;\n \n+fn type_of_1(bcx: @block_ctxt, t: ty::t) -> TypeRef {\n+    let cx = bcx_ccx(bcx);\n+    check type_has_static_size(cx, t);\n+    type_of(cx, bcx.sp, t)\n+}\n+\n fn type_of(cx: @crate_ctxt, sp: span, t: ty::t) : type_has_static_size(cx, t)\n    -> TypeRef {\n     // Should follow from type_has_static_size -- argh.\n@@ -1335,62 +1341,59 @@ fn incr_refcnt_of_boxed(cx: @block_ctxt, box_ptr: ValueRef) -> @block_ctxt {\n     ret cx;\n }\n \n-fn make_free_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n-    // NB: v is an *alias* of type t here, not a direct value.\n-    let bcx =\n-        alt ty::struct(bcx_tcx(bcx), t) {\n-          ty::ty_box(body_mt) {\n-            let v = Load(bcx, v0);\n-            let body = GEP(bcx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n-            let bcx = drop_ty(bcx, body, body_mt.ty);\n-            if !bcx_ccx(bcx).sess.get_opts().do_gc {\n-                trans_non_gc_free(bcx, v)\n-            } else { bcx }\n-          }\n-          ty::ty_uniq(content_mt) {\n-            check trans_uniq::type_is_unique_box(bcx, t);\n-            trans_uniq::make_free_glue(bcx, v0, t)\n-          }\n-          ty::ty_obj(_) {\n-            // Call through the obj's own fields-drop glue first.\n-            // Then free the body.\n-            let box_cell =\n-                GEP(bcx, v0, [C_int(0), C_int(abi::obj_field_box)]);\n-            let b = Load(bcx, box_cell);\n-            let ccx = bcx_ccx(bcx);\n-            let llbox_ty = T_opaque_obj_ptr(*ccx);\n-            b = PointerCast(bcx, b, llbox_ty);\n-            let body = GEP(bcx, b, [C_int(0), C_int(abi::box_rc_field_body)]);\n-            let tydescptr =\n-                GEP(bcx, body, [C_int(0), C_int(abi::obj_body_elt_tydesc)]);\n-            let tydesc = Load(bcx, tydescptr);\n-            let ti = none;\n-            call_tydesc_glue_full(bcx, body, tydesc,\n-                                  abi::tydesc_field_drop_glue, ti);\n-            if !bcx_ccx(bcx).sess.get_opts().do_gc {\n-                trans_non_gc_free(bcx, b)\n-            } else { bcx }\n-          }\n-          ty::ty_fn(_, _, _, _, _) {\n-            // Call through the closure's own fields-drop glue first.\n-            // Then free the body.\n-            let box_cell = GEP(bcx, v0, [C_int(0), C_int(abi::fn_field_box)]);\n-            let v = Load(bcx, box_cell);\n-            let body = GEP(bcx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n-            let bindings =\n-                GEP(bcx, body, [C_int(0), C_int(abi::closure_elt_bindings)]);\n-            let tydescptr =\n-                GEP(bcx, body, [C_int(0), C_int(abi::closure_elt_tydesc)]);\n-            let ti = none;\n-            call_tydesc_glue_full(bcx, bindings, Load(bcx, tydescptr),\n-                                  abi::tydesc_field_drop_glue, ti);\n-            if !bcx_ccx(bcx).sess.get_opts().do_gc {\n-                trans_non_gc_free(bcx, v)\n-            } else { bcx }\n-          }\n-          _ { bcx }\n-        };\n-\n+fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n+    // v is a pointer to the actual box component of the type here. The\n+    // ValueRef will have the wrong type here (make_generic_glue is casting\n+    // everything to a pointer to the type that the glue acts on).\n+    let bcx = alt ty::struct(bcx_tcx(bcx), t) {\n+      ty::ty_box(body_mt) {\n+        v = PointerCast(bcx, v, type_of_1(bcx, t));\n+        let body = GEP(bcx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n+        let bcx = drop_ty(bcx, body, body_mt.ty);\n+        if !bcx_ccx(bcx).sess.get_opts().do_gc {\n+            trans_non_gc_free(bcx, v)\n+        } else { bcx }\n+      }\n+      ty::ty_uniq(content_mt) {\n+        check trans_uniq::type_is_unique_box(bcx, t);\n+        v = PointerCast(bcx, v, type_of_1(bcx, t));\n+        trans_uniq::make_free_glue(bcx, v, t)\n+      }\n+      ty::ty_obj(_) {\n+        // Call through the obj's own fields-drop glue first.\n+        // Then free the body.\n+        let ccx = bcx_ccx(bcx);\n+        let llbox_ty = T_opaque_obj_ptr(*ccx);\n+        let b = PointerCast(bcx, v, llbox_ty);\n+        let body = GEP(bcx, b, [C_int(0), C_int(abi::box_rc_field_body)]);\n+        let tydescptr =\n+            GEP(bcx, body, [C_int(0), C_int(abi::obj_body_elt_tydesc)]);\n+        let tydesc = Load(bcx, tydescptr);\n+        let ti = none;\n+        call_tydesc_glue_full(bcx, body, tydesc,\n+                              abi::tydesc_field_drop_glue, ti);\n+        if !bcx_ccx(bcx).sess.get_opts().do_gc {\n+            trans_non_gc_free(bcx, b)\n+        } else { bcx }\n+      }\n+      ty::ty_fn(_, _, _, _, _) {\n+        // Call through the closure's own fields-drop glue first.\n+        // Then free the body.\n+        v = PointerCast(bcx, v, T_opaque_closure_ptr(*bcx_ccx(bcx)));\n+        let body = GEP(bcx, v, [C_int(0), C_int(abi::box_rc_field_body)]);\n+        let bindings =\n+            GEP(bcx, body, [C_int(0), C_int(abi::closure_elt_bindings)]);\n+        let tydescptr =\n+            GEP(bcx, body, [C_int(0), C_int(abi::closure_elt_tydesc)]);\n+        let ti = none;\n+        call_tydesc_glue_full(bcx, bindings, Load(bcx, tydescptr),\n+                              abi::tydesc_field_drop_glue, ti);\n+        if !bcx_ccx(bcx).sess.get_opts().do_gc {\n+            trans_non_gc_free(bcx, v)\n+        } else { bcx }\n+      }\n+      _ { bcx }\n+    };\n     build_return(bcx);\n }\n \n@@ -1401,21 +1404,19 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n         alt ty::struct(ccx.tcx, t) {\n           ty::ty_vec(_) { tvec::make_drop_glue(bcx, v0, t) }\n           ty::ty_str. { tvec::make_drop_glue(bcx, v0, t) }\n-          ty::ty_box(_) { decr_refcnt_maybe_free(bcx, v0, v0, t) }\n-          ty::ty_uniq(_) {\n-            free_ty(bcx, v0, t)\n-          }\n+          ty::ty_box(_) { decr_refcnt_maybe_free(bcx, Load(bcx, v0), t) }\n+          ty::ty_uniq(_) { free_ty(bcx, Load(bcx, v0), t) }\n           ty::ty_obj(_) {\n             let box_cell =\n                 GEP(bcx, v0, [C_int(0), C_int(abi::obj_field_box)]);\n-            decr_refcnt_maybe_free(bcx, box_cell, v0, t)\n+            decr_refcnt_maybe_free(bcx, Load(bcx, box_cell), t)\n           }\n           ty::ty_res(did, inner, tps) {\n             trans_res_drop(bcx, v0, did, inner, tps)\n           }\n           ty::ty_fn(_, _, _, _, _) {\n             let box_cell = GEP(bcx, v0, [C_int(0), C_int(abi::fn_field_box)]);\n-            decr_refcnt_maybe_free(bcx, box_cell, v0, t)\n+            decr_refcnt_maybe_free(bcx, Load(bcx, box_cell), t)\n           }\n           _ {\n             if ty::type_has_pointers(ccx.tcx, t) &&\n@@ -1470,13 +1471,12 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     ret next_cx;\n }\n \n-fn decr_refcnt_maybe_free(cx: @block_ctxt, box_ptr_alias: ValueRef,\n-                          full_alias: ValueRef, t: ty::t) -> @block_ctxt {\n+fn decr_refcnt_maybe_free(cx: @block_ctxt, box_ptr: ValueRef, t: ty::t)\n+    -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n     let rc_adj_cx = new_sub_block_ctxt(cx, \"rc--\");\n     let free_cx = new_sub_block_ctxt(cx, \"free\");\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n-    let box_ptr = Load(cx, box_ptr_alias);\n     let llbox_ty = T_opaque_obj_ptr(*ccx);\n     box_ptr = PointerCast(cx, box_ptr, llbox_ty);\n     let null_test = IsNull(cx, box_ptr);\n@@ -1488,7 +1488,7 @@ fn decr_refcnt_maybe_free(cx: @block_ctxt, box_ptr_alias: ValueRef,\n     Store(rc_adj_cx, rc, rc_ptr);\n     let zero_test = ICmp(rc_adj_cx, lib::llvm::LLVMIntEQ, C_int(0), rc);\n     CondBr(rc_adj_cx, zero_test, free_cx.llbb, next_cx.llbb);\n-    let free_cx = free_ty(free_cx, full_alias, t);\n+    let free_cx = free_ty(free_cx, box_ptr, t);\n     Br(free_cx, next_cx.llbb);\n     ret next_cx;\n }"}, {"sha": "e3911de4a7a0c9b4e0add0212721d794148bf005", "filename": "src/comp/middle/trans_uniq.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa1295343fdbccb608c95ec49c96eada9cb44f50/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1295343fdbccb608c95ec49c96eada9cb44f50/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs?ref=fa1295343fdbccb608c95ec49c96eada9cb44f50", "patch": "@@ -53,22 +53,19 @@ fn alloc_uniq(cx: @block_ctxt, uniq_ty: ty::t)\n     ret rslt(bcx, llptr);\n }\n \n-fn make_free_glue(cx: @block_ctxt, v: ValueRef, t: ty::t)\n+fn make_free_glue(cx: @block_ctxt, vptr: ValueRef, t: ty::t)\n     : type_is_unique_box(cx, t) -> @block_ctxt {\n \n     let bcx = cx;\n     let free_cx = new_sub_block_ctxt(bcx, \"uniq_free\");\n     let next_cx = new_sub_block_ctxt(bcx, \"uniq_free_next\");\n-    let vptr = Load(bcx, v);\n     let null_test = IsNull(bcx, vptr);\n     CondBr(bcx, null_test, next_cx.llbb, free_cx.llbb);\n \n     let bcx = free_cx;\n     let bcx = drop_ty(bcx, vptr, content_ty(cx, t));\n     let bcx = trans_shared_free(bcx, vptr);\n-    Store(bcx, C_null(val_ty(vptr)), v);\n     Br(bcx, next_cx.llbb);\n-\n     next_cx\n }\n "}]}