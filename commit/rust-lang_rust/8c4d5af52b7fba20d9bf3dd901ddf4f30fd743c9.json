{"sha": "8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNGQ1YWY1MmI3ZmJhMjBkOWJmM2RkOTAxZGRmNGYzMGZkNzQzYzk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-12T23:19:11Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:29Z"}, "message": "rustc: remove Ty::layout and move everything to layout_of.", "tree": {"sha": "2724e9a2bc25a69ecb5993d7f6953b4f5147873b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2724e9a2bc25a69ecb5993d7f6953b4f5147873b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "html_url": "https://github.com/rust-lang/rust/commit/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8864668d536071dee35a472b459586d733105444", "url": "https://api.github.com/repos/rust-lang/rust/commits/8864668d536071dee35a472b459586d733105444", "html_url": "https://github.com/rust-lang/rust/commit/8864668d536071dee35a472b459586d733105444"}], "stats": {"total": 451, "additions": 201, "deletions": 250}, "files": [{"sha": "a080f968da44e8aa27c0540772ec948794655797", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -34,7 +34,8 @@ use middle::privacy::AccessLevels;\n use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use session::{config, early_error, Session};\n use traits::Reveal;\n-use ty::{self, TyCtxt};\n+use ty::{self, TyCtxt, Ty};\n+use ty::layout::{FullLayout, LayoutError, LayoutOf};\n use util::nodemap::FxHashMap;\n \n use std::default::Default as StdDefault;\n@@ -626,6 +627,14 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a LateContext<'a, 'tcx> {\n+    type FullLayout = Result<FullLayout<'tcx>, LayoutError<'tcx>>;\n+\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::FullLayout {\n+        (self.tcx, self.param_env.reveal_all()).layout_of(ty)\n+    }\n+}\n+\n impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     /// Because lints are scoped lexically, we want to walk nested\n     /// items in the context of the outer item, so enable"}, {"sha": "cb7021760274b4fa575e7baffcd477426bfc7b30", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 158, "deletions": 163, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -653,7 +653,7 @@ enum StructKind {\n \n impl<'a, 'tcx> Struct {\n     fn new(dl: &TargetDataLayout,\n-           fields: &Vec<&'a Layout>,\n+           fields: &[FullLayout],\n            repr: &ReprOptions,\n            kind: StructKind,\n            scapegoat: Ty<'tcx>)\n@@ -793,19 +793,6 @@ impl<'a, 'tcx> Struct {\n         self.min_size.abi_align(self.align)\n     }\n \n-    /// Determine whether a structure would be zero-sized, given its fields.\n-    fn would_be_zero_sized<I>(dl: &TargetDataLayout, fields: I)\n-                              -> Result<bool, LayoutError<'tcx>>\n-    where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n-        for field in fields {\n-            let field = field?;\n-            if field.is_unsized() || field.size(dl).bytes() > 0 {\n-                return Ok(false);\n-            }\n-        }\n-        Ok(true)\n-    }\n-\n     /// Get indices of the tys that made this struct by increasing offset.\n     #[inline]\n     pub fn field_index_by_increasing_offset<'b>(&'b self) -> impl iter::Iterator<Item=usize>+'b {\n@@ -837,10 +824,10 @@ impl<'a, 'tcx> Struct {\n     // FIXME(eddyb) track value ranges and traverse already optimized enums.\n     fn non_zero_field_in_type(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               param_env: ty::ParamEnv<'tcx>,\n-                              ty: Ty<'tcx>)\n+                              layout: FullLayout<'tcx>)\n                               -> Result<Option<(Size, Primitive)>, LayoutError<'tcx>> {\n-        let layout = ty.layout(tcx, param_env)?;\n-        match (layout, &ty.sty) {\n+        let cx = (tcx, param_env);\n+        match (layout.layout, &layout.ty.sty) {\n             (&Scalar { non_zero: true, value, .. }, _) => {\n                 Ok(Some((Size::from_bytes(0), value)))\n             }\n@@ -849,49 +836,33 @@ impl<'a, 'tcx> Struct {\n             }\n \n             (&FatPointer { non_zero: true, .. }, _) => {\n-                Ok(Some((layout.field_offset(tcx, FAT_PTR_ADDR, None),\n-                         Pointer)))\n+                Ok(Some((layout.field_offset(tcx, FAT_PTR_ADDR), Pointer)))\n             }\n \n             // Is this the NonZero lang item wrapping a pointer or integer type?\n-            (&Univariant { non_zero: true, .. }, &ty::TyAdt(def, substs)) => {\n-                let fields = &def.struct_variant().fields;\n-                assert_eq!(fields.len(), 1);\n-                let field = fields[0].ty(tcx, substs).layout(tcx, param_env)?;\n+            (_, &ty::TyAdt(def, _)) if Some(def.did) == tcx.lang_items().non_zero() => {\n+                let field = layout.field(cx, 0)?;\n                 match *field {\n                     // FIXME(eddyb) also allow floating-point types here.\n                     Scalar { value: value @ Int(_), non_zero: false } |\n                     Scalar { value: value @ Pointer, non_zero: false } => {\n-                        Ok(Some((layout.field_offset(tcx, 0, None), value)))\n+                        Ok(Some((layout.field_offset(tcx, 0), value)))\n                     }\n                     FatPointer { non_zero: false, .. } => {\n-                        Ok(Some((layout.field_offset(tcx, 0, None) +\n-                                 field.field_offset(tcx, FAT_PTR_ADDR, None),\n+                        Ok(Some((layout.field_offset(tcx, 0) +\n+                                 field.field_offset(tcx, FAT_PTR_ADDR),\n                                  Pointer)))\n                     }\n                     _ => Ok(None)\n                 }\n             }\n \n-            // Perhaps one of the fields of this struct is non-zero\n-            // let's recurse and find out\n-            (&Univariant { ref variant, .. }, &ty::TyAdt(def, substs)) if def.is_struct() => {\n+            // Perhaps one of the fields is non-zero, let's recurse and find out.\n+            (&Univariant(ref variant), _) => {\n                 variant.non_zero_field(\n                     tcx,\n                     param_env,\n-                    def.struct_variant().fields.iter().map(|field| {\n-                        field.ty(tcx, substs)\n-                    }))\n-            }\n-\n-            // Perhaps one of the upvars of this closure is non-zero\n-            (&Univariant { ref variant, .. }, &ty::TyClosure(def, substs)) => {\n-                let upvar_tys = substs.upvar_tys(def, tcx);\n-                variant.non_zero_field(tcx, param_env, upvar_tys)\n-            }\n-            // Can we use one of the fields in this tuple?\n-            (&Univariant { ref variant, .. }, &ty::TyTuple(tys, _)) => {\n-                variant.non_zero_field(tcx, param_env, tys.iter().cloned())\n+                    (0..layout.field_count()).map(|i| layout.field(cx, i)))\n             }\n \n             // Is this a fixed-size array of something non-zero\n@@ -900,22 +871,18 @@ impl<'a, 'tcx> Struct {\n                 if count.has_projections() {\n                     count = tcx.normalize_associated_type_in_env(&count, param_env);\n                     if count.has_projections() {\n-                        return Err(LayoutError::Unknown(ty));\n+                        return Err(LayoutError::Unknown(layout.ty));\n                     }\n                 }\n                 if count.val.to_const_int().unwrap().to_u64().unwrap() != 0 {\n-                    Struct::non_zero_field_in_type(tcx, param_env, ety)\n+                    Struct::non_zero_field_in_type(tcx, param_env, cx.layout_of(ety)?)\n                 } else {\n                     Ok(None)\n                 }\n             }\n \n             (_, &ty::TyProjection(_)) | (_, &ty::TyAnon(..)) => {\n-                let normalized = tcx.normalize_associated_type_in_env(&ty, param_env);\n-                if ty == normalized {\n-                    return Ok(None);\n-                }\n-                return Struct::non_zero_field_in_type(tcx, param_env, normalized);\n+                bug!(\"Struct::non_zero_field_in_type: {:?} not normalized\", layout);\n             }\n \n             // Anything else is not a non-zero type.\n@@ -930,9 +897,9 @@ impl<'a, 'tcx> Struct {\n                          param_env: ty::ParamEnv<'tcx>,\n                          fields: I)\n                          -> Result<Option<(Size, Primitive)>, LayoutError<'tcx>>\n-    where I: Iterator<Item=Ty<'tcx>> {\n-        for (ty, &field_offset) in fields.zip(&self.offsets) {\n-            let r = Struct::non_zero_field_in_type(tcx, param_env, ty)?;\n+    where I: Iterator<Item = Result<FullLayout<'tcx>, LayoutError<'tcx>>> {\n+        for (field, &field_offset) in fields.zip(&self.offsets) {\n+            let r = Struct::non_zero_field_in_type(tcx, param_env, field?)?;\n             if let Some((offset, primitive)) = r {\n                 return Ok(Some((field_offset + offset, primitive)));\n             }\n@@ -981,7 +948,7 @@ impl<'a, 'tcx> Union {\n         }\n     }\n \n-    /// Extend the Struct with more fields.\n+    /// Extend the Union with more fields.\n     fn extend<I>(&mut self, dl: &TargetDataLayout,\n                  fields: I,\n                  scapegoat: Ty<'tcx>)\n@@ -1077,17 +1044,10 @@ pub enum Layout {\n     },\n \n     /// Single-case enums, and structs/tuples.\n-    Univariant {\n-        variant: Struct,\n-        /// If true, the structure is NonZero.\n-        // FIXME(eddyb) use a newtype Layout kind for this.\n-        non_zero: bool\n-    },\n+    Univariant(Struct),\n \n     /// Untagged unions.\n-    UntaggedUnion {\n-        variants: Union,\n-    },\n+    UntaggedUnion(Union),\n \n     /// General-case enums: for each case there is a struct, and they all have\n     /// all space reserved for the discriminant, and their first field starts\n@@ -1145,31 +1105,59 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n+fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                        -> Result<&'tcx Layout, LayoutError<'tcx>>\n+{\n+    let (param_env, ty) = query.into_parts();\n+\n+    let rec_limit = tcx.sess.recursion_limit.get();\n+    let depth = tcx.layout_depth.get();\n+    if depth > rec_limit {\n+        tcx.sess.fatal(\n+            &format!(\"overflow representing the type `{}`\", ty));\n+    }\n+\n+    tcx.layout_depth.set(depth+1);\n+    let layout = Layout::compute_uncached(tcx, param_env, ty);\n+    tcx.layout_depth.set(depth);\n+\n+    layout\n+}\n+\n+pub fn provide(providers: &mut ty::maps::Providers) {\n+    *providers = ty::maps::Providers {\n+        layout_raw,\n+        ..*providers\n+    };\n+}\n+\n impl<'a, 'tcx> Layout {\n-    pub fn compute_uncached(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            param_env: ty::ParamEnv<'tcx>,\n-                            ty: Ty<'tcx>)\n-                            -> Result<&'tcx Layout, LayoutError<'tcx>> {\n+    fn compute_uncached(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        param_env: ty::ParamEnv<'tcx>,\n+                        ty: Ty<'tcx>)\n+                        -> Result<&'tcx Layout, LayoutError<'tcx>> {\n         let success = |layout| Ok(tcx.intern_layout(layout));\n-        let dl = &tcx.data_layout;\n+        let cx = (tcx, param_env);\n+        let dl = cx.data_layout();\n         assert!(!ty.has_infer_types());\n \n         let ptr_layout = |pointee: Ty<'tcx>| {\n             let non_zero = !ty.is_unsafe_ptr();\n             let pointee = tcx.normalize_associated_type_in_env(&pointee, param_env);\n             if pointee.is_sized(tcx, param_env, DUMMY_SP) {\n-                Ok(Scalar { value: Pointer, non_zero: non_zero })\n+                Ok(Scalar { value: Pointer, non_zero })\n             } else {\n                 let unsized_part = tcx.struct_tail(pointee);\n-                match unsized_part.sty {\n-                    ty::TySlice(_) | ty::TyStr => Ok(FatPointer {\n-                        metadata: Int(dl.ptr_sized_integer()),\n-                        non_zero: non_zero\n-                    }),\n-                    ty::TyDynamic(..) => Ok(FatPointer { metadata: Pointer, non_zero: non_zero }),\n-                    ty::TyForeign(..) => Ok(Scalar { value: Pointer, non_zero: non_zero }),\n-                    _ => Err(LayoutError::Unknown(unsized_part)),\n-                }\n+                let metadata = match unsized_part.sty {\n+                    ty::TyForeign(..) => return Ok(Scalar { value: Pointer, non_zero }),\n+                    ty::TySlice(_) | ty::TyStr => {\n+                        Int(dl.ptr_sized_integer())\n+                    }\n+                    ty::TyDynamic(..) => Pointer,\n+                    _ => return Err(LayoutError::Unknown(unsized_part))\n+                };\n+                Ok(FatPointer { metadata, non_zero })\n             }\n         };\n \n@@ -1194,11 +1182,10 @@ impl<'a, 'tcx> Layout {\n             ty::TyFnPtr(_) => Scalar { value: Pointer, non_zero: true },\n \n             // The never type.\n-            ty::TyNever => Univariant {\n-                variant: Struct::new(dl, &vec![], &ReprOptions::default(),\n-                  StructKind::AlwaysSizedUnivariant, ty)?,\n-                non_zero: false\n-            },\n+            ty::TyNever => {\n+                Univariant(Struct::new(dl, &[], &ReprOptions::default(),\n+                                       StructKind::AlwaysSizedUnivariant, ty)?)\n+            }\n \n             // Potentially-fat pointers.\n             ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n@@ -1218,7 +1205,7 @@ impl<'a, 'tcx> Layout {\n                     }\n                 }\n \n-                let element = element.layout(tcx, param_env)?;\n+                let element = cx.layout_of(element)?;\n                 let element_size = element.size(dl);\n                 let count = count.val.to_const_int().unwrap().to_u64().unwrap();\n                 if element_size.checked_mul(count, dl).is_none() {\n@@ -1233,7 +1220,7 @@ impl<'a, 'tcx> Layout {\n                 }\n             }\n             ty::TySlice(element) => {\n-                let element = element.layout(tcx, param_env)?;\n+                let element = cx.layout_of(element)?;\n                 Array {\n                     sized: false,\n                     align: element.align(dl),\n@@ -1254,38 +1241,33 @@ impl<'a, 'tcx> Layout {\n \n             // Odd unit types.\n             ty::TyFnDef(..) => {\n-                Univariant {\n-                    variant: Struct::new(dl, &vec![],\n-                      &ReprOptions::default(), StructKind::AlwaysSizedUnivariant, ty)?,\n-                    non_zero: false\n-                }\n+                Univariant(Struct::new(dl, &[], &ReprOptions::default(),\n+                                       StructKind::AlwaysSizedUnivariant, ty)?)\n             }\n             ty::TyDynamic(..) | ty::TyForeign(..) => {\n-                let mut unit = Struct::new(dl, &vec![], &ReprOptions::default(),\n+                let mut unit = Struct::new(dl, &[], &ReprOptions::default(),\n                   StructKind::AlwaysSizedUnivariant, ty)?;\n                 unit.sized = false;\n-                Univariant { variant: unit, non_zero: false }\n+                Univariant(unit)\n             }\n \n             // Tuples, generators and closures.\n             ty::TyGenerator(def_id, ref substs, _) => {\n                 let tys = substs.field_tys(def_id, tcx);\n-                let st = Struct::new(dl,\n-                    &tys.map(|ty| ty.layout(tcx, param_env))\n+                Univariant(Struct::new(dl,\n+                    &tys.map(|ty| cx.layout_of(ty))\n                       .collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n-                    StructKind::AlwaysSizedUnivariant, ty)?;\n-                Univariant { variant: st, non_zero: false }\n+                    StructKind::AlwaysSizedUnivariant, ty)?)\n             }\n \n             ty::TyClosure(def_id, ref substs) => {\n                 let tys = substs.upvar_tys(def_id, tcx);\n-                let st = Struct::new(dl,\n-                    &tys.map(|ty| ty.layout(tcx, param_env))\n+                Univariant(Struct::new(dl,\n+                    &tys.map(|ty| cx.layout_of(ty))\n                       .collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n-                    StructKind::AlwaysSizedUnivariant, ty)?;\n-                Univariant { variant: st, non_zero: false }\n+                    StructKind::AlwaysSizedUnivariant, ty)?)\n             }\n \n             ty::TyTuple(tys, _) => {\n@@ -1295,17 +1277,16 @@ impl<'a, 'tcx> Layout {\n                     StructKind::MaybeUnsizedUnivariant\n                 };\n \n-                let st = Struct::new(dl,\n-                    &tys.iter().map(|ty| ty.layout(tcx, param_env))\n+                Univariant(Struct::new(dl,\n+                    &tys.iter().map(|ty| cx.layout_of(ty))\n                       .collect::<Result<Vec<_>, _>>()?,\n-                    &ReprOptions::default(), kind, ty)?;\n-                Univariant { variant: st, non_zero: false }\n+                    &ReprOptions::default(), kind, ty)?)\n             }\n \n             // SIMD vector types.\n             ty::TyAdt(def, ..) if def.repr.simd() => {\n                 let element = ty.simd_type(tcx);\n-                match *element.layout(tcx, param_env)? {\n+                match *cx.layout_of(element)? {\n                     Scalar { value, .. } => {\n                         return success(Vector {\n                             element: value,\n@@ -1326,11 +1307,8 @@ impl<'a, 'tcx> Layout {\n                     // Uninhabitable; represent as unit\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n-                    return success(Univariant {\n-                        variant: Struct::new(dl, &vec![],\n-                          &def.repr, StructKind::AlwaysSizedUnivariant, ty)?,\n-                        non_zero: false\n-                    });\n+                    return success(Univariant(Struct::new(dl, &[],\n+                          &def.repr, StructKind::AlwaysSizedUnivariant, ty)?));\n                 }\n \n                 if def.is_enum() && def.variants.iter().all(|v| v.fields.is_empty()) {\n@@ -1376,17 +1354,14 @@ impl<'a, 'tcx> Layout {\n                     };\n \n                     let fields = def.variants[0].fields.iter().map(|field| {\n-                        field.ty(tcx, substs).layout(tcx, param_env)\n+                        cx.layout_of(field.ty(tcx, substs))\n                     }).collect::<Result<Vec<_>, _>>()?;\n                     let layout = if def.is_union() {\n                         let mut un = Union::new(dl, &def.repr);\n-                        un.extend(dl, fields.iter().map(|&f| Ok(f)), ty)?;\n-                        UntaggedUnion { variants: un }\n+                        un.extend(dl, fields.iter().map(|&f| Ok(f.layout)), ty)?;\n+                        UntaggedUnion(un)\n                     } else {\n-                        let st = Struct::new(dl, &fields, &def.repr,\n-                          kind, ty)?;\n-                        let non_zero = Some(def.did) == tcx.lang_items().non_zero();\n-                        Univariant { variant: st, non_zero: non_zero }\n+                        Univariant(Struct::new(dl, &fields, &def.repr, kind, ty)?)\n                     };\n                     return success(layout);\n                 }\n@@ -1403,28 +1378,41 @@ impl<'a, 'tcx> Layout {\n \n                 // Cache the substituted and normalized variant field types.\n                 let variants = def.variants.iter().map(|v| {\n-                    v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n-                }).collect::<Vec<_>>();\n+                    v.fields.iter().map(|field| {\n+                        cx.layout_of(field.ty(tcx, substs))\n+                    }).collect::<Result<Vec<_>, _>>()\n+                }).collect::<Result<Vec<_>, _>>()?;\n \n                 if variants.len() == 2 && !def.repr.inhibit_enum_layout_opt() {\n                     // Nullable pointer optimization\n+                    let st0 = Struct::new(dl, &variants[0],\n+                        &def.repr, StructKind::AlwaysSizedUnivariant, ty)?;\n+                    let st1 = Struct::new(dl, &variants[1],\n+                        &def.repr, StructKind::AlwaysSizedUnivariant, ty)?;\n+\n+                    let mut choice = None;\n                     for discr in 0..2 {\n-                        let other_fields = variants[1 - discr].iter().map(|ty| {\n-                            ty.layout(tcx, param_env)\n-                        });\n-                        if !Struct::would_be_zero_sized(dl, other_fields)? {\n+                        let (st, other) = if discr == 0 {\n+                            (&st0, &st1)\n+                        } else {\n+                            (&st1, &st0)\n+                        };\n+                        if other.stride().bytes() > 0 {\n                             continue;\n                         }\n \n-                        let st = Struct::new(dl,\n-                            &variants[discr].iter().map(|ty| ty.layout(tcx, param_env))\n-                              .collect::<Result<Vec<_>, _>>()?,\n-                            &def.repr, StructKind::AlwaysSizedUnivariant, ty)?;\n-\n                         let field = st.non_zero_field(tcx, param_env,\n-                                                      variants[discr].iter().cloned())?;\n-                        let (offset, primitive) = if let Some(f) = field { f }\n-                          else { continue };\n+                            variants[discr].iter().map(|&f| Ok(f)))?;\n+                        if let Some((offset, primitive)) = field {\n+                            choice = Some((discr, offset, primitive));\n+                            break;\n+                        }\n+                    }\n+\n+                    if let Some((discr, offset, primitive)) = choice {\n+                        // HACK(eddyb) work around not being able to move\n+                        // out of arrays with just the indexing operator.\n+                        let st = if discr == 0 { st0 } else { st1 };\n \n                         // FIXME(eddyb) should take advantage of a newtype.\n                         if offset.bytes() == 0 && primitive.size(dl) == st.stride() &&\n@@ -1457,11 +1445,7 @@ impl<'a, 'tcx> Layout {\n \n                 // Create the set of structs that represent each variant.\n                 let mut variants = variants.into_iter().map(|fields| {\n-                    let fields = fields.into_iter().map(|field| {\n-                        field.layout(tcx, param_env)\n-                    }).collect::<Result<Vec<_>, _>>()?;\n-                    let st = Struct::new(dl,\n-                        &fields,\n+                    let st = Struct::new(dl, &fields,\n                         &def.repr, StructKind::EnumVariant(min_ity), ty)?;\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant.\n@@ -1552,7 +1536,7 @@ impl<'a, 'tcx> Layout {\n                 if ty == normalized {\n                     return Err(LayoutError::Unknown(ty));\n                 }\n-                return normalized.layout(tcx, param_env);\n+                return Ok(cx.layout_of(normalized)?.layout);\n             }\n             ty::TyParam(_) => {\n                 return Err(LayoutError::Unknown(ty));\n@@ -1574,7 +1558,7 @@ impl<'a, 'tcx> Layout {\n             StructWrappedNullablePointer {..} => false,\n \n             Array { sized, .. } |\n-            Univariant { variant: Struct { sized, .. }, .. } => !sized\n+            Univariant(Struct { sized, .. }) => !sized\n         }\n     }\n \n@@ -1612,9 +1596,9 @@ impl<'a, 'tcx> Layout {\n \n             CEnum { discr, .. } => Int(discr).size(dl),\n             General { size, .. } => size,\n-            UntaggedUnion { ref variants } => variants.stride(),\n+            UntaggedUnion(ref un) => un.stride(),\n \n-            Univariant { ref variant, .. } |\n+            Univariant(ref variant) |\n             StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n                 variant.stride()\n             }\n@@ -1646,9 +1630,9 @@ impl<'a, 'tcx> Layout {\n \n             CEnum { discr, .. } => Int(discr).align(dl),\n             Array { align, .. } | General { align, .. } => align,\n-            UntaggedUnion { ref variants } => variants.align,\n+            UntaggedUnion(ref un) => un.align,\n \n-            Univariant { ref variant, .. } |\n+            Univariant(ref variant) |\n             StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n                 variant.align\n             }\n@@ -1663,7 +1647,7 @@ impl<'a, 'tcx> Layout {\n     pub fn primitive_align<C: HasDataLayout>(&self, cx: C) -> Align {\n         match *self {\n             Array { primitive_align, .. } | General { primitive_align, .. } => primitive_align,\n-            Univariant { ref variant, .. } |\n+            Univariant(ref variant) |\n             StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n                 variant.primitive_align\n             },\n@@ -1682,7 +1666,7 @@ impl<'a, 'tcx> Layout {\n         match *self {\n             Scalar { .. } |\n             CEnum { .. } |\n-            UntaggedUnion { .. } |\n+            UntaggedUnion(_) |\n             RawNullablePointer { .. } => {\n                 Size::from_bytes(0)\n             }\n@@ -1710,7 +1694,7 @@ impl<'a, 'tcx> Layout {\n                 }\n             }\n \n-            Univariant { ref variant, .. } => variant.offsets[i],\n+            Univariant(ref variant) => variant.offsets[i],\n \n             General { ref variants, .. } => {\n                 let v = variant_index.expect(\"variant index required\");\n@@ -1730,10 +1714,10 @@ impl<'a, 'tcx> Layout {\n     /// This is invoked by the `layout_raw` query to record the final\n     /// layout of each type.\n     #[inline]\n-    pub fn record_layout_for_printing(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      ty: Ty<'tcx>,\n-                                      param_env: ty::ParamEnv<'tcx>,\n-                                      layout: &Layout) {\n+    fn record_layout_for_printing(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  ty: Ty<'tcx>,\n+                                  param_env: ty::ParamEnv<'tcx>,\n+                                  layout: &Layout) {\n         // If we are running with `-Zprint-type-sizes`, record layouts for\n         // dumping later. Ignore layouts that are done with non-empty\n         // environments or non-monomorphic layouts, as the user only wants\n@@ -1788,8 +1772,7 @@ impl<'a, 'tcx> Layout {\n         let adt_kind = adt_def.adt_kind();\n \n         let build_field_info = |(field_name, field_ty): (ast::Name, Ty<'tcx>), offset: &Size| {\n-            let layout = field_ty.layout(tcx, param_env);\n-            match layout {\n+            match (tcx, param_env).layout_of(field_ty) {\n                 Err(_) => bug!(\"no layout found for field {} type: `{:?}`\", field_name, field_ty),\n                 Ok(field_layout) => {\n                     session::FieldInfo {\n@@ -1859,7 +1842,7 @@ impl<'a, 'tcx> Layout {\n                 record(adt_kind.into(), None,\n                        vec![build_primitive_info(variant_def.name, &discr)]);\n             }\n-            Layout::Univariant { variant: ref variant_layout, non_zero: _ } => {\n+            Layout::Univariant(ref variant_layout) => {\n                 let variant_names = || {\n                     adt_def.variants.iter().map(|v|format!(\"{}\", v.name)).collect::<Vec<_>>()\n                 };\n@@ -1905,9 +1888,8 @@ impl<'a, 'tcx> Layout {\n                 record(adt_kind.into(), Some(discr.size()), variant_infos);\n             }\n \n-            Layout::UntaggedUnion { ref variants } => {\n-                debug!(\"print-type-size t: `{:?}` adt union variants {:?}\",\n-                       ty, variants);\n+            Layout::UntaggedUnion(ref un) => {\n+                debug!(\"print-type-size t: `{:?}` adt union {:?}\", ty, un);\n                 // layout does not currently store info about each\n                 // variant...\n                 record(adt_kind.into(), None, Vec::new());\n@@ -1966,7 +1948,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n         assert!(!ty.has_infer_types());\n \n         // First try computing a static layout.\n-        let err = match ty.layout(tcx, param_env) {\n+        let err = match (tcx, param_env).layout_of(ty) {\n             Ok(layout) => {\n                 return Ok(SizeSkeleton::Known(layout.size(tcx)));\n             }\n@@ -2141,15 +2123,29 @@ pub trait LayoutOf<T> {\n impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (TyCtxt<'a, 'tcx, 'tcx>, ty::ParamEnv<'tcx>) {\n     type FullLayout = Result<FullLayout<'tcx>, LayoutError<'tcx>>;\n \n+    /// Computes the layout of a type. Note that this implicitly\n+    /// executes in \"reveal all\" mode.\n+    #[inline]\n     fn layout_of(self, ty: Ty<'tcx>) -> Self::FullLayout {\n         let (tcx, param_env) = self;\n \n-        let ty = tcx.normalize_associated_type_in_env(&ty, param_env);\n+        let ty = tcx.normalize_associated_type_in_env(&ty, param_env.reveal_all());\n+        let layout = tcx.layout_raw(param_env.reveal_all().and(ty));\n+\n+        // NB: This recording is normally disabled; when enabled, it\n+        // can however trigger recursive invocations of `layout()`.\n+        // Therefore, we execute it *after* the main query has\n+        // completed, to avoid problems around recursive structures\n+        // and the like. (Admitedly, I wasn't able to reproduce a problem\n+        // here, but it seems like the right thing to do. -nmatsakis)\n+        if let Ok(l) = layout {\n+            Layout::record_layout_for_printing(tcx, ty, param_env, l);\n+        }\n \n         Ok(FullLayout {\n             ty,\n             variant_index: None,\n-            layout: ty.layout(tcx, param_env)?,\n+            layout: layout?,\n         })\n     }\n }\n@@ -2204,7 +2200,7 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n             // Handled above (the TyAdt case).\n             CEnum { .. } |\n             General { .. } |\n-            UntaggedUnion { .. } |\n+            UntaggedUnion(_) |\n             RawNullablePointer { .. } |\n             StructWrappedNullablePointer { .. } => bug!(),\n \n@@ -2217,7 +2213,7 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n                 usize_count\n             }\n \n-            Univariant { ref variant, .. } => variant.offsets.len(),\n+            Univariant(ref variant) => variant.offsets.len(),\n         }\n     }\n \n@@ -2356,12 +2352,11 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout\n                 min.hash_stable(hcx, hasher);\n                 max.hash_stable(hcx, hasher);\n             }\n-            Univariant { ref variant, non_zero } => {\n+            Univariant(ref variant) => {\n                 variant.hash_stable(hcx, hasher);\n-                non_zero.hash_stable(hcx, hasher);\n             }\n-            UntaggedUnion { ref variants } => {\n-                variants.hash_stable(hcx, hasher);\n+            UntaggedUnion(ref un) => {\n+                un.hash_stable(hcx, hasher);\n             }\n             General { discr, ref variants, size, align, primitive_align } => {\n                 discr.hash_stable(hcx, hasher);"}, {"sha": "48ec92a255b4c66275750c47d4992b562b994c84", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -2617,9 +2617,10 @@ fn original_crate_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub fn provide(providers: &mut ty::maps::Providers) {\n-    util::provide(providers);\n     context::provide(providers);\n     erase_regions::provide(providers);\n+    layout::provide(providers);\n+    util::provide(providers);\n     *providers = ty::maps::Providers {\n         associated_item,\n         associated_item_def_ids,"}, {"sha": "23dd3f1bc2bba36e55bb9e22f10344afa538312f", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -19,7 +19,6 @@ use middle::const_val::ConstVal;\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeVisitor;\n-use ty::layout::{Layout, LayoutError};\n use ty::subst::{Subst, Kind};\n use ty::TypeVariants::*;\n use util::common::ErrorReported;\n@@ -852,30 +851,6 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         tcx.needs_drop_raw(param_env.and(self))\n     }\n \n-    /// Computes the layout of a type. Note that this implicitly\n-    /// executes in \"reveal all\" mode.\n-    #[inline]\n-    pub fn layout<'lcx>(&'tcx self,\n-                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        param_env: ty::ParamEnv<'tcx>)\n-                        -> Result<&'tcx Layout, LayoutError<'tcx>> {\n-        let ty = tcx.erase_regions(&self);\n-        let layout = tcx.layout_raw(param_env.reveal_all().and(ty));\n-\n-        // NB: This recording is normally disabled; when enabled, it\n-        // can however trigger recursive invocations of `layout()`.\n-        // Therefore, we execute it *after* the main query has\n-        // completed, to avoid problems around recursive structures\n-        // and the like. (Admitedly, I wasn't able to reproduce a problem\n-        // here, but it seems like the right thing to do. -nmatsakis)\n-        if let Ok(l) = layout {\n-            Layout::record_layout_for_printing(tcx, ty, param_env, l);\n-        }\n-\n-        layout\n-    }\n-\n-\n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n     pub fn is_representable(&'tcx self,\n@@ -1184,26 +1159,6 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                        -> Result<&'tcx Layout, LayoutError<'tcx>>\n-{\n-    let (param_env, ty) = query.into_parts();\n-\n-    let rec_limit = tcx.sess.recursion_limit.get();\n-    let depth = tcx.layout_depth.get();\n-    if depth > rec_limit {\n-        tcx.sess.fatal(\n-            &format!(\"overflow representing the type `{}`\", ty));\n-    }\n-\n-    tcx.layout_depth.set(depth+1);\n-    let layout = Layout::compute_uncached(tcx, param_env, ty);\n-    tcx.layout_depth.set(depth);\n-\n-    layout\n-}\n-\n pub enum ExplicitSelf<'tcx> {\n     ByValue,\n     ByReference(ty::Region<'tcx>, hir::Mutability),\n@@ -1262,7 +1217,6 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         is_sized_raw,\n         is_freeze_raw,\n         needs_drop_raw,\n-        layout_raw,\n         ..*providers\n     };\n }"}, {"sha": "86bd227b1af070af9a86b59cb045e22698e6e4fb", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -13,7 +13,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n-use rustc::ty::layout::{Layout, Primitive};\n+use rustc::ty::layout::{Layout, LayoutOf, Primitive};\n use middle::const_val::ConstVal;\n use rustc_const_eval::ConstContext;\n use util::nodemap::FxHashSet;\n@@ -748,9 +748,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 // sizes only make sense for non-generic types\n                 let item_def_id = cx.tcx.hir.local_def_id(it.id);\n                 let t = cx.tcx.type_of(item_def_id);\n-                let param_env = cx.param_env.reveal_all();\n                 let ty = cx.tcx.erase_regions(&t);\n-                let layout = ty.layout(cx.tcx, param_env).unwrap_or_else(|e| {\n+                let layout = cx.layout_of(ty).unwrap_or_else(|e| {\n                     bug!(\"failed to get layout for `{}`: {}\", t, e)\n                 });\n "}, {"sha": "0e5528f916a7adc34b8a4598b4fcff5ff6b2dcc9", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -19,6 +19,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::*;\n use rustc::mir::visit::*;\n use rustc::ty::{self, Instance, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::layout::LayoutOf;\n use rustc::ty::subst::{Subst,Substs};\n \n use std::collections::VecDeque;\n@@ -625,9 +626,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           param_env: ty::ParamEnv<'tcx>,\n                           ty: Ty<'tcx>) -> Option<u64> {\n-    ty.layout(tcx, param_env).ok().map(|layout| {\n-        layout.size(&tcx.data_layout).bytes()\n-    })\n+    (tcx, param_env).layout_of(ty).ok().map(|layout| layout.size(tcx).bytes())\n }\n \n fn subst_and_normalize<'a, 'tcx: 'a>("}, {"sha": "695fc9160c5b39daed19e8822504cdb67d610fd8", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -330,7 +330,7 @@ impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n                 }\n             }\n \n-            Layout::Univariant { ref variant, .. } => {\n+            Layout::Univariant(ref variant) => {\n                 let mut unaligned_offset = Size::from_bytes(0);\n                 let mut result = None;\n "}, {"sha": "3d67d3df04284852ca24aebc5fa2f50e6f815578", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -74,7 +74,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         layout::Univariant { ..}\n         | layout::StructWrappedNullablePointer { .. } => {\n             let (variant_layout, variant) = match *l {\n-                layout::Univariant { ref variant, .. } => {\n+                layout::Univariant(ref variant) => {\n                     let is_enum = if let ty::TyAdt(def, _) = t.sty {\n                         def.is_enum()\n                     } else {\n@@ -123,7 +123,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        layout::Univariant { ref variant, .. } => {\n+        layout::Univariant(ref variant) => {\n             match name {\n                 None => {\n                     Type::struct_(cx, &struct_llfields(cx, l, &variant),\n@@ -134,16 +134,16 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        layout::UntaggedUnion { ref variants, .. }=> {\n+        layout::UntaggedUnion(ref un) => {\n             // Use alignment-sized ints to fill all the union storage.\n-            let fill = union_fill(cx, variants.stride(), variants.align);\n+            let fill = union_fill(cx, un.stride(), un.align);\n             match name {\n                 None => {\n-                    Type::struct_(cx, &[fill], variants.packed)\n+                    Type::struct_(cx, &[fill], un.packed)\n                 }\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(&[fill], variants.packed);\n+                    llty.set_struct_body(&[fill], un.packed);\n                     llty\n                 }\n             }"}, {"sha": "493a9f713fd2392d3152ee7b3f1d530adc96a117", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -101,7 +101,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n                 }\n             }\n \n-            Layout::Univariant { ref variant, .. } => {\n+            Layout::Univariant(ref variant) => {\n                 for i in 0..layout.field_count() {\n                     let field_off = off + variant.offsets[i];\n                     classify(ccx, layout.field(ccx, i), cls, field_off)?;"}, {"sha": "40ddc329dddd5d6142c1c6c3a7b2eebf0e1ca63d", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -74,7 +74,7 @@ pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n     let layout = ccx.layout_of(ty);\n     match *layout {\n         Layout::FatPointer { .. } => true,\n-        Layout::Univariant { ref variant, .. } => {\n+        Layout::Univariant(ref variant) => {\n             // There must be only 2 fields.\n             if variant.offsets.len() != 2 {\n                 return false;"}, {"sha": "44dc831e44236bab2bef6c7299115cc8cdf1b588", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -942,7 +942,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n \n         let tmp;\n         let offsets = match *layout {\n-            layout::Univariant { ref variant, .. } => &variant.offsets,\n+            layout::Univariant(ref variant) => &variant.offsets,\n             layout::Vector { element, count } => {\n                 let element_size = element.size(cx).bytes();\n                 tmp = (0..count).\n@@ -1022,7 +1022,7 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let layout = cx.layout_of(self.ty);\n-        let offsets = if let layout::Univariant { ref variant, .. } = *layout {\n+        let offsets = if let layout::Univariant(ref variant) = *layout {\n             &variant.offsets\n         } else {\n             bug!(\"{} is not a tuple\", self.ty);\n@@ -1184,7 +1184,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         }\n                     }).collect()\n             },\n-            layout::Univariant{ ref variant, .. } => {\n+            layout::Univariant(ref variant) => {\n                 assert!(adt.variants.len() <= 1);\n \n                 if adt.variants.is_empty() {"}, {"sha": "657f7da66b34b84033bb3137d1d03234339e7a98", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -59,7 +59,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             debug!(\"DST {} layout: {:?}\", t, layout);\n \n             let (sized_size, sized_align) = match *layout {\n-                ty::layout::Layout::Univariant { ref variant, .. } => {\n+                ty::layout::Layout::Univariant(ref variant) => {\n                     (variant.offsets.last().map_or(0, |o| o.bytes()), variant.align.abi())\n                 }\n                 _ => {"}, {"sha": "badc9100c40a65a639913eb9f70eed96f3fc90c9", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -1111,16 +1111,16 @@ fn trans_const_adt<'a, 'tcx>(\n             build_const_struct(ccx, l, &variant, vals,\n                 Some(Const::new(lldiscr, d.to_ty(ccx.tcx(), false))))\n         }\n-        layout::UntaggedUnion { ref variants, .. }=> {\n+        layout::UntaggedUnion(ref un) => {\n             assert_eq!(variant_index, 0);\n             let contents = [\n                 vals[0].llval,\n-                padding(ccx, variants.stride() - ccx.size_of(vals[0].ty))\n+                padding(ccx, un.stride() - ccx.size_of(vals[0].ty))\n             ];\n \n-            Const::new(C_struct(ccx, &contents, variants.packed), t)\n+            Const::new(C_struct(ccx, &contents, un.packed), t)\n         }\n-        layout::Univariant { ref variant, .. } => {\n+        layout::Univariant(ref variant) => {\n             assert_eq!(variant_index, 0);\n             build_const_struct(ccx, l, &variant, vals, None)\n         }"}, {"sha": "8f094cd5102231262dd6273104cf3059bb12c239", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -58,8 +58,8 @@ impl ops::BitOr for Alignment {\n impl<'a> From<&'a Layout> for Alignment {\n     fn from(layout: &Layout) -> Self {\n         let (packed, align) = match *layout {\n-            Layout::UntaggedUnion { ref variants } => (variants.packed, variants.align),\n-            Layout::Univariant { ref variant, .. } => (variant.packed, variant.align),\n+            Layout::UntaggedUnion(ref un) => (un.packed, un.align),\n+            Layout::Univariant(ref variant) => (variant.packed, variant.align),\n             _ => return Alignment::AbiAligned\n         };\n         if packed {\n@@ -250,7 +250,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n         // Check whether the variant being used is packed, if applicable.\n         let is_packed = match (&*l, l.variant_index) {\n-            (&layout::Univariant { ref variant, .. }, _) => variant.packed,\n+            (&layout::Univariant(ref variant), _) => variant.packed,\n             (&layout::StructWrappedNullablePointer { ref nonnull, .. }, _) => nonnull.packed,\n             (&layout::General { ref variants, .. }, Some(v)) => variants[v].packed,\n             _ => return simple()"}, {"sha": "b1a9be881f789dbf39eb26311867afe61a8a24d8", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -577,7 +577,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n             let layout = bcx.ccx.layout_of(closure_ty);\n             let offsets = match *layout {\n-                layout::Univariant { ref variant, .. } => &variant.offsets[..],\n+                layout::Univariant(ref variant) => &variant.offsets[..],\n                 _ => bug!(\"Closures are only supposed to be Univariant\")\n             };\n "}, {"sha": "d504ea1c30768795d6e0a7451ff0e522c2e4fa72", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -254,7 +254,7 @@ impl<'tcx> LayoutLlvmExt for FullLayout<'tcx> {\n                 adt::memory_index_to_gep(index as u64)\n             }\n \n-            Layout::Univariant { ref variant, .. } => {\n+            Layout::Univariant(ref variant) => {\n                 adt::memory_index_to_gep(variant.memory_index[index] as u64)\n             }\n "}, {"sha": "39c6e97268f980e3d9aebdcd8a33ba64256be49e", "filename": "src/test/compile-fail/issue-26548.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -8,7 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: overflow representing the type\n+// error-pattern: unsupported cyclic reference between types/traits detected\n+// note-pattern: the cycle begins when computing layout of\n+// note-pattern: ...which then requires computing layout of\n+// note-pattern: ...which then again requires computing layout of\n \n \n trait Mirror { type It: ?Sized; }", "previous_filename": "src/test/ui/issue-26548.rs"}, {"sha": "8bfe4ac733b6d91c97d783b55e6a20fa95af4f4f", "filename": "src/test/ui/issue-26548.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8864668d536071dee35a472b459586d733105444/src%2Ftest%2Fui%2Fissue-26548.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8864668d536071dee35a472b459586d733105444/src%2Ftest%2Fui%2Fissue-26548.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-26548.stderr?ref=8864668d536071dee35a472b459586d733105444", "patch": "@@ -1,9 +0,0 @@\n-error[E0391]: unsupported cyclic reference between types/traits detected\n-  |\n-note: the cycle begins when computing layout of `S`...\n-note: ...which then requires computing layout of `std::option::Option<<S as Mirror>::It>`...\n-note: ...which then requires computing layout of `<S as Mirror>::It`...\n-  = note: ...which then again requires computing layout of `S`, completing the cycle.\n-\n-error: aborting due to previous error\n-"}, {"sha": "f1684f4c5acbe42f5f8eb94ba87a3408b9bd5bc9", "filename": "src/tools/toolstate.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Ftools%2Ftoolstate.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9/src%2Ftools%2Ftoolstate.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftoolstate.toml?ref=8c4d5af52b7fba20d9bf3dd901ddf4f30fd743c9", "patch": "@@ -26,7 +26,7 @@\n miri = \"Broken\"\n \n # ping @Manishearth @llogiq @mcarton @oli-obk\n-clippy = \"Testing\"\n+clippy = \"Broken\"\n \n # ping @nrc\n rls = \"Testing\""}]}