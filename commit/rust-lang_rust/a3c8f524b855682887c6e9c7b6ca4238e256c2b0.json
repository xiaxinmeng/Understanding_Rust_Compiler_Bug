{"sha": "a3c8f524b855682887c6e9c7b6ca4238e256c2b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzYzhmNTI0Yjg1NTY4Mjg4N2M2ZTljN2I2Y2E0MjM4ZTI1NmMyYjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-11T15:25:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-11T15:25:00Z"}, "message": "auto merge of #5823 : Kimundi/rust/str_from_bytes_slice, r=erickt\n\nAdded str::from_bytes_with_null\r\nAdded str::subslice_offset\r\nMisc cleanup\r\n\r\nCloses #5422", "tree": {"sha": "352d7bf9698b191866207c80c614bd299a399faf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/352d7bf9698b191866207c80c614bd299a399faf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3c8f524b855682887c6e9c7b6ca4238e256c2b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3c8f524b855682887c6e9c7b6ca4238e256c2b0", "html_url": "https://github.com/rust-lang/rust/commit/a3c8f524b855682887c6e9c7b6ca4238e256c2b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3c8f524b855682887c6e9c7b6ca4238e256c2b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f8b36fc16178b298b23dfa199067ec2dd91df93", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8b36fc16178b298b23dfa199067ec2dd91df93", "html_url": "https://github.com/rust-lang/rust/commit/2f8b36fc16178b298b23dfa199067ec2dd91df93"}, {"sha": "4ad76e66aad1813bc927ae1b5cf8205c8c5a8944", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ad76e66aad1813bc927ae1b5cf8205c8c5a8944", "html_url": "https://github.com/rust-lang/rust/commit/4ad76e66aad1813bc927ae1b5cf8205c8c5a8944"}], "stats": {"total": 155, "additions": 147, "deletions": 8}, "files": [{"sha": "2201836c72410968c9a0c3a408eb93f8e9983b80", "filename": "src/libcore/str.rs", "status": "modified", "additions": 147, "deletions": 8, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/a3c8f524b855682887c6e9c7b6ca4238e256c2b0/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c8f524b855682887c6e9c7b6ca4238e256c2b0/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=a3c8f524b855682887c6e9c7b6ca4238e256c2b0", "patch": "@@ -38,7 +38,7 @@ Section: Creating a string\n */\n \n /**\n- * Convert a vector of bytes to a UTF-8 string\n+ * Convert a vector of bytes to a new UTF-8 string\n  *\n  * # Failure\n  *\n@@ -49,9 +49,26 @@ pub fn from_bytes(vv: &const [u8]) -> ~str {\n     return unsafe { raw::from_bytes(vv) };\n }\n \n+/**\n+ * Convert a vector of bytes to a UTF-8 string.\n+ * The vector needs to be one byte longer than the string, and end with a 0 byte.\n+ *\n+ * Compared to `from_bytes()`, this fn doesn't need to allocate a new owned str.\n+ *\n+ * # Failure\n+ *\n+ * Fails if invalid UTF-8\n+ * Fails if not null terminated\n+ */\n+pub fn from_bytes_with_null<'a>(vv: &'a [u8]) -> &'a str {\n+    assert!(vv[vv.len() - 1] == 0);\n+    assert!(is_utf8(vv));\n+    return unsafe { raw::from_bytes_with_null(vv) };\n+}\n+\n /// Copy a slice into a new unique str\n pub fn from_slice(s: &str) -> ~str {\n-    unsafe { raw::slice_bytes_unique(s, 0, len(s)) }\n+    unsafe { raw::slice_bytes_owned(s, 0, len(s)) }\n }\n \n impl ToStr for ~str {\n@@ -279,7 +296,7 @@ pub fn pop_char(s: &mut ~str) -> char {\n  */\n pub fn shift_char(s: &mut ~str) -> char {\n     let CharRange {ch, next} = char_range_at(*s, 0u);\n-    *s = unsafe { raw::slice_bytes_unique(*s, next, len(*s)) };\n+    *s = unsafe { raw::slice_bytes_owned(*s, next, len(*s)) };\n     return ch;\n }\n \n@@ -784,9 +801,9 @@ pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n         if first {\n             first = false;\n         } else {\n-            unsafe { push_str(&mut result, to); }\n+            push_str(&mut result, to);\n         }\n-        unsafe { push_str(&mut result, raw::slice_bytes_unique(s, start, end)); }\n+        push_str(&mut result, unsafe{raw::slice_bytes(s, start, end)});\n     }\n     result\n }\n@@ -2037,6 +2054,37 @@ pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n     }\n }\n \n+/**\n+ * Returns the byte offset of an inner slice relative to an enclosing outer slice\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * let string = \"a\\nb\\nc\";\n+ * let mut lines = ~[];\n+ * for each_line(string) |line| { lines.push(line) }\n+ *\n+ * assert!(subslice_offset(string, lines[0]) == 0); // &\"a\"\n+ * assert!(subslice_offset(string, lines[1]) == 2); // &\"b\"\n+ * assert!(subslice_offset(string, lines[2]) == 4); // &\"c\"\n+ * ~~~\n+ */\n+#[inline(always)]\n+pub fn subslice_offset(outer: &str, inner: &str) -> uint {\n+    do as_buf(outer) |a, a_len| {\n+        do as_buf(inner) |b, b_len| {\n+            let a_start: uint, a_end: uint, b_start: uint, b_end: uint;\n+            unsafe {\n+                a_start = cast::transmute(a); a_end = a_len + cast::transmute(a);\n+                b_start = cast::transmute(b); b_end = b_len + cast::transmute(b);\n+            }\n+            assert!(a_start <= b_start);\n+            assert!(b_end <= a_end);\n+            b_start - a_start\n+        }\n+    }\n+}\n+\n /**\n  * Reserves capacity for exactly `n` bytes in the given string, not including\n  * the null terminator.\n@@ -2158,13 +2206,20 @@ pub mod raw {\n         from_buf_len(::cast::reinterpret_cast(&c_str), len)\n     }\n \n-    /// Converts a vector of bytes to a string.\n+    /// Converts a vector of bytes to a new owned string.\n     pub unsafe fn from_bytes(v: &const [u8]) -> ~str {\n         do vec::as_const_buf(v) |buf, len| {\n             from_buf_len(buf, len)\n         }\n     }\n \n+    /// Converts a vector of bytes to a string.\n+    /// The byte slice needs to contain valid utf8 and needs to be one byte longer than\n+    /// the string, if possible ending in a 0 byte.\n+    pub unsafe fn from_bytes_with_null<'a>(v: &'a [u8]) -> &'a str {\n+        cast::transmute(v)\n+    }\n+\n     /// Converts a byte to a string.\n     pub unsafe fn from_byte(u: u8) -> ~str { raw::from_bytes([u]) }\n \n@@ -2186,7 +2241,7 @@ pub mod raw {\n      * If begin is greater than end.\n      * If end is greater than the length of the string.\n      */\n-    pub unsafe fn slice_bytes_unique(s: &str, begin: uint, end: uint) -> ~str {\n+    pub unsafe fn slice_bytes_owned(s: &str, begin: uint, end: uint) -> ~str {\n         do as_buf(s) |sbuf, n| {\n             assert!((begin <= end));\n             assert!((end <= n));\n@@ -2258,7 +2313,7 @@ pub mod raw {\n         let len = len(*s);\n         assert!((len > 0u));\n         let b = s[0];\n-        *s = unsafe { raw::slice_bytes_unique(*s, 1u, len) };\n+        *s = unsafe { raw::slice_bytes_owned(*s, 1u, len) };\n         return b;\n     }\n \n@@ -3289,6 +3344,66 @@ mod tests {\n          let _x = from_bytes(bb);\n     }\n \n+    #[test]\n+    fn test_unsafe_from_bytes_with_null() {\n+        let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+        let b = unsafe { raw::from_bytes_with_null(a) };\n+        assert_eq!(b, \"AAAAAAA\");\n+    }\n+\n+    #[test]\n+    fn test_from_bytes_with_null() {\n+        let ss = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let bb = [0xe0_u8, 0xb8_u8, 0xa8_u8,\n+                  0xe0_u8, 0xb9_u8, 0x84_u8,\n+                  0xe0_u8, 0xb8_u8, 0x97_u8,\n+                  0xe0_u8, 0xb8_u8, 0xa2_u8,\n+                  0xe4_u8, 0xb8_u8, 0xad_u8,\n+                  0xe5_u8, 0x8d_u8, 0x8e_u8,\n+                  0x56_u8, 0x69_u8, 0xe1_u8,\n+                  0xbb_u8, 0x87_u8, 0x74_u8,\n+                  0x20_u8, 0x4e_u8, 0x61_u8,\n+                  0x6d_u8, 0x0_u8];\n+\n+        assert_eq!(ss, from_bytes_with_null(bb));\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_from_bytes_with_null_fail() {\n+        let bb = [0xff_u8, 0xb8_u8, 0xa8_u8,\n+                  0xe0_u8, 0xb9_u8, 0x84_u8,\n+                  0xe0_u8, 0xb8_u8, 0x97_u8,\n+                  0xe0_u8, 0xb8_u8, 0xa2_u8,\n+                  0xe4_u8, 0xb8_u8, 0xad_u8,\n+                  0xe5_u8, 0x8d_u8, 0x8e_u8,\n+                  0x56_u8, 0x69_u8, 0xe1_u8,\n+                  0xbb_u8, 0x87_u8, 0x74_u8,\n+                  0x20_u8, 0x4e_u8, 0x61_u8,\n+                  0x6d_u8, 0x0_u8];\n+\n+         let _x = from_bytes_with_null(bb);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_from_bytes_with_null_fail_2() {\n+        let bb = [0xff_u8, 0xb8_u8, 0xa8_u8,\n+                  0xe0_u8, 0xb9_u8, 0x84_u8,\n+                  0xe0_u8, 0xb8_u8, 0x97_u8,\n+                  0xe0_u8, 0xb8_u8, 0xa2_u8,\n+                  0xe4_u8, 0xb8_u8, 0xad_u8,\n+                  0xe5_u8, 0x8d_u8, 0x8e_u8,\n+                  0x56_u8, 0x69_u8, 0xe1_u8,\n+                  0xbb_u8, 0x87_u8, 0x74_u8,\n+                  0x20_u8, 0x4e_u8, 0x61_u8,\n+                  0x6d_u8, 0x60_u8];\n+\n+         let _x = from_bytes_with_null(bb);\n+    }\n+\n     #[test]\n     fn test_from_buf() {\n         unsafe {\n@@ -3351,6 +3466,30 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_subslice_offset() {\n+        let a = \"kernelsprite\";\n+        let b = slice(a, 7, len(a));\n+        let c = slice(a, 0, len(a) - 6);\n+        assert!(subslice_offset(a, b) == 7);\n+        assert!(subslice_offset(a, c) == 0);\n+\n+        let string = \"a\\nb\\nc\";\n+        let mut lines = ~[];\n+        for each_line(string) |line| { lines.push(line) }\n+        assert!(subslice_offset(string, lines[0]) == 0);\n+        assert!(subslice_offset(string, lines[1]) == 2);\n+        assert!(subslice_offset(string, lines[2]) == 4);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_subslice_offset_2() {\n+        let a = \"alchemiter\";\n+        let b = \"cruxtruder\";\n+        subslice_offset(a, b);\n+    }\n+\n     #[test]\n     fn vec_str_conversions() {\n         let s1: ~str = ~\"All mimsy were the borogoves\";"}]}