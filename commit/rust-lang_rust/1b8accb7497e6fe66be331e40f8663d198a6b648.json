{"sha": "1b8accb7497e6fe66be331e40f8663d198a6b648", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiOGFjY2I3NDk3ZTZmZTY2YmUzMzFlNDBmODY2M2QxOThhNmI2NDg=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-06-20T21:01:03Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-07-15T14:54:05Z"}, "message": "Add an option not to report resolution errors for rustdoc\n\n- Remove unnecessary `should_loop` variable\n- Report errors for trait implementations\n\nThese should give resolution errors because they are visible outside the\ncurrent scope. Without these errors, rustdoc will give ICEs:\n\n```\nthread 'rustc' panicked at 'attempted .def_id() on invalid res: Err', /home/joshua/src/rust/src/libstd/macros.rs:16:9\n  15: rustc_hir::def::Res<Id>::def_id\n             at /home/joshua/src/rust/src/librustc_hir/def.rs:382\n  16: rustdoc::clean::utils::register_res\n             at src/librustdoc/clean/utils.rs:627\n  17: rustdoc::clean::utils::resolve_type\n             at src/librustdoc/clean/utils.rs:587\n```\n\n- Add much more extensive tests\n  + fn -> impl -> fn\n  + fn -> impl -> fn -> macro\n  + errors in function parameters\n  + errors in trait bounds\n  + errors in the type implementing the trait\n  + unknown bounds for the type\n  + unknown types in function bodies\n  + errors generated by macros\n\n- Use explicit state instead of trying to reconstruct it from random info\n- Use an enum instead of a boolean\n- Add example of ignored error", "tree": {"sha": "90f57dafaad4deccde2a8e14b7eecd9437c97ed3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90f57dafaad4deccde2a8e14b7eecd9437c97ed3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b8accb7497e6fe66be331e40f8663d198a6b648", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b8accb7497e6fe66be331e40f8663d198a6b648", "html_url": "https://github.com/rust-lang/rust/commit/1b8accb7497e6fe66be331e40f8663d198a6b648", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b8accb7497e6fe66be331e40f8663d198a6b648/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3187aabd20637e0bb9a930b4b930a079b785ca9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3187aabd20637e0bb9a930b4b930a079b785ca9", "html_url": "https://github.com/rust-lang/rust/commit/b3187aabd20637e0bb9a930b4b930a079b785ca9"}], "stats": {"total": 240, "additions": 201, "deletions": 39}, "files": [{"sha": "690ed9decb9ef3f5fe0ca55445317d97aba033c9", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1b8accb7497e6fe66be331e40f8663d198a6b648/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b8accb7497e6fe66be331e40f8663d198a6b648/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=1b8accb7497e6fe66be331e40f8663d198a6b648", "patch": "@@ -233,6 +233,8 @@ fn configure_and_expand_inner<'a>(\n     resolver_arenas: &'a ResolverArenas<'a>,\n     metadata_loader: &'a MetadataLoaderDyn,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n+    use rustc_resolve::IgnoreState;\n+\n     log::trace!(\"configure_and_expand_inner\");\n     pre_expansion_lint(sess, lint_store, &krate);\n \n@@ -354,13 +356,18 @@ fn configure_and_expand_inner<'a>(\n         )\n     });\n \n-    let crate_types = sess.crate_types();\n-    let is_proc_macro_crate = crate_types.contains(&CrateType::ProcMacro);\n+    if let Some(PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops)) = sess.opts.pretty {\n+        log::debug!(\"replacing bodies with loop {{}}\");\n+        util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n+    }\n \n     let has_proc_macro_decls = sess.time(\"AST_validation\", || {\n         rustc_ast_passes::ast_validation::check_crate(sess, &krate, &mut resolver.lint_buffer())\n     });\n \n+    let crate_types = sess.crate_types();\n+    let is_proc_macro_crate = crate_types.contains(&CrateType::ProcMacro);\n+\n     // For backwards compatibility, we don't try to run proc macro injection\n     // if rustdoc is run on a proc macro crate without '--crate-type proc-macro' being\n     // specified. This should only affect users who manually invoke 'rustdoc', as\n@@ -407,17 +414,9 @@ fn configure_and_expand_inner<'a>(\n     }\n \n     // If we're actually rustdoc then avoid giving a name resolution error for `cfg()` items.\n-    // anything, so switch everything to just looping\n-    resolver.resolve_crate(&krate, sess.opts.actually_rustdoc);\n-\n-    let mut should_loop = false;\n-    if let Some(PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops)) = sess.opts.pretty {\n-        should_loop |= true;\n-    }\n-    if should_loop {\n-        log::debug!(\"replacing bodies with loop {{}}\");\n-        util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n-    }\n+    let ignore_bodies =\n+        if sess.opts.actually_rustdoc { IgnoreState::Ignore } else { IgnoreState::Report };\n+    resolver.resolve_crate(&krate, ignore_bodies);\n \n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n     sess.time(\"complete_gated_feature_checking\", || {"}, {"sha": "637326bb88d865decfce3259f66121e3b26c550e", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 77, "deletions": 22, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/1b8accb7497e6fe66be331e40f8663d198a6b648/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b8accb7497e6fe66be331e40f8663d198a6b648/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=1b8accb7497e6fe66be331e40f8663d198a6b648", "patch": "@@ -376,6 +376,19 @@ struct DiagnosticMetadata<'ast> {\n     current_let_binding: Option<(Span, Option<Span>, Option<Span>)>,\n }\n \n+/// Keeps track of whether errors should be reported.\n+///\n+/// Used by rustdoc to ignore errors in function bodies.\n+/// This is just a fancy boolean so it can have doc-comments.\n+#[derive(Copy, Clone, Debug)]\n+pub enum IgnoreState {\n+    /// We are at global scope or in a trait implementation, so all errors should be reported.\n+    Report,\n+    /// We are in a function body, so errors shouldn't be reported.\n+    Ignore,\n+    // Note that we don't need to worry about macros, which must always be resolved (or we wouldn't have gotten to the late pass).\n+}\n+\n struct LateResolutionVisitor<'a, 'b, 'ast> {\n     r: &'b mut Resolver<'a>,\n \n@@ -395,10 +408,12 @@ struct LateResolutionVisitor<'a, 'b, 'ast> {\n     /// Fields used to add information to diagnostic errors.\n     diagnostic_metadata: DiagnosticMetadata<'ast>,\n \n-    /// Whether to report resolution errors for item bodies.\n+    /// State used to know whether to ignore resolution errors for item bodies.\n     ///\n     /// In particular, rustdoc uses this to avoid giving errors for `cfg()` items.\n-    ignore_bodies: bool,\n+    /// In most cases this will be `None`, in which case errors will always be reported.\n+    /// If it is `Some(_)`, then it will be updated when entering a nested function or trait body.\n+    ignore_bodies: Option<IgnoreState>,\n }\n \n /// Walks the whole crate in DFS order, visiting each item, resolving names as it goes.\n@@ -502,13 +517,18 @@ impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n \n                 visit::walk_fn_ret_ty(this, &declaration.output);\n \n+                let previous_ignore = this.ignore_bodies.take();\n+                // Ignore errors in function bodies if originally passed `ignore_state: true`\n+                // Be sure not to set this until the function signature has been resolved.\n+                this.ignore_bodies = previous_ignore.and(Some(IgnoreState::Ignore));\n                 // Resolve the function body, potentially inside the body of an async closure\n                 match fn_kind {\n                     FnKind::Fn(.., body) => walk_list!(this, visit_block, body),\n                     FnKind::Closure(_, body) => this.visit_expr(body),\n                 };\n \n                 debug!(\"(resolving function) leaving function\");\n+                this.ignore_bodies = previous_ignore;\n             })\n         });\n         self.diagnostic_metadata.current_function = previous_value;\n@@ -634,7 +654,7 @@ impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     fn new(\n         resolver: &'b mut Resolver<'a>,\n-        ignore_bodies: bool,\n+        ignore_bodies: IgnoreState,\n     ) -> LateResolutionVisitor<'a, 'b, 'ast> {\n         // During late resolution we only track the module component of the parent scope,\n         // although it may be useful to track other components as well for diagnostics.\n@@ -652,7 +672,11 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             label_ribs: Vec::new(),\n             current_trait_ref: None,\n             diagnostic_metadata: DiagnosticMetadata::default(),\n-            ignore_bodies,\n+            ignore_bodies: match ignore_bodies {\n+                // errors at module scope should always be reported\n+                IgnoreState::Ignore => Some(IgnoreState::Report),\n+                IgnoreState::Report => None,\n+            },\n         }\n     }\n \n@@ -842,7 +866,11 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n             let report_error = |this: &Self, ns| {\n                 let what = if ns == TypeNS { \"type parameters\" } else { \"local variables\" };\n-                this.r.session.span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n+                if this.should_report_errs() {\n+                    this.r\n+                        .session\n+                        .span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n+                }\n             };\n \n             for &ns in nss {\n@@ -1166,6 +1194,9 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         impl_items: &'ast [P<AssocItem>],\n     ) {\n         debug!(\"resolve_implementation\");\n+        let old_ignore = self.ignore_bodies.take();\n+        // Never ignore errors in trait implementations.\n+        self.ignore_bodies = old_ignore.and(Some(IgnoreState::Report));\n         // If applicable, create a rib for the type parameters.\n         self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n             // Dummy self type for better errors if `Self` is used in the trait path.\n@@ -1261,6 +1292,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 });\n             });\n         });\n+        self.ignore_bodies = old_ignore;\n     }\n \n     fn check_trait_item<F>(&mut self, ident: Ident, ns: Namespace, span: Span, err: F)\n@@ -1298,6 +1330,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn resolve_local(&mut self, local: &'ast Local) {\n+        debug!(\"resolving local ({:?})\", local);\n         // Resolve the type.\n         walk_list!(self, visit_ty, &local.ty);\n \n@@ -1686,18 +1719,27 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         source: PathSource<'ast>,\n         crate_lint: CrateLint,\n     ) -> PartialRes {\n+        log::debug!(\"smart_resolve_path_fragment(id={:?},qself={:?},path={:?}\", id, qself, path);\n         let ns = source.namespace();\n         let is_expected = &|res| source.is_expected(res);\n \n         let report_errors = |this: &mut Self, res: Option<Res>| {\n-            let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n-\n-            let def_id = this.parent_scope.module.normal_ancestor_id;\n-            let instead = res.is_some();\n-            let suggestion =\n-                if res.is_none() { this.report_missing_type_error(path) } else { None };\n-\n-            this.r.use_injections.push(UseError { err, candidates, def_id, instead, suggestion });\n+            if this.should_report_errs() {\n+                let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n+\n+                let def_id = this.parent_scope.module.normal_ancestor_id;\n+                let instead = res.is_some();\n+                let suggestion =\n+                    if res.is_none() { this.report_missing_type_error(path) } else { None };\n+\n+                this.r.use_injections.push(UseError {\n+                    err,\n+                    candidates,\n+                    def_id,\n+                    instead,\n+                    suggestion,\n+                });\n+            }\n \n             PartialRes::new(Res::Err)\n         };\n@@ -1755,13 +1797,17 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             let def_id = this.parent_scope.module.normal_ancestor_id;\n \n-            this.r.use_injections.push(UseError {\n-                err,\n-                candidates,\n-                def_id,\n-                instead: false,\n-                suggestion: None,\n-            });\n+            if this.should_report_errs() {\n+                this.r.use_injections.push(UseError {\n+                    err,\n+                    candidates,\n+                    def_id,\n+                    instead: false,\n+                    suggestion: None,\n+                });\n+            } else {\n+                err.cancel();\n+            }\n \n             // We don't return `Some(parent_err)` here, because the error will\n             // be already printed as part of the `use` injections\n@@ -1856,11 +1902,20 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     ///\n     /// This doesn't emit errors for function bodies if `ignore_bodies` is set.\n     fn report_error(&self, span: Span, resolution_error: ResolutionError<'_>) {\n-        if !self.ignore_bodies || self.diagnostic_metadata.current_function.is_none() {\n+        if self.should_report_errs() {\n             self.r.report_error(span, resolution_error);\n         }\n     }\n \n+    #[inline]\n+    fn should_report_errs(&self) -> bool {\n+        debug!(\"should_report_errs(state={:?})\", self.ignore_bodies);\n+        match self.ignore_bodies {\n+            None | Some(IgnoreState::Report) => true,\n+            Some(IgnoreState::Ignore) => false,\n+        }\n+    }\n+\n     // Resolve in alternative namespaces if resolution in the primary namespace fails.\n     fn resolve_qpath_anywhere(\n         &mut self,\n@@ -2357,7 +2412,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n }\n \n impl<'a> Resolver<'a> {\n-    pub(crate) fn late_resolve_crate(&mut self, krate: &Crate, ignore_bodies: bool) {\n+    pub(crate) fn late_resolve_crate(&mut self, krate: &Crate, ignore_bodies: IgnoreState) {\n         let mut late_resolution_visitor = LateResolutionVisitor::new(self, ignore_bodies);\n         visit::walk_crate(&mut late_resolution_visitor, krate);\n         for (id, span) in late_resolution_visitor.diagnostic_metadata.unused_labels.iter() {"}, {"sha": "23bd0028bd1dd083d53ff71ecd8d323483fa43c4", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b8accb7497e6fe66be331e40f8663d198a6b648/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b8accb7497e6fe66be331e40f8663d198a6b648/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1b8accb7497e6fe66be331e40f8663d198a6b648", "patch": "@@ -15,6 +15,7 @@\n #![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n \n+pub use late::IgnoreState;\n pub use rustc_hir::def::{Namespace, PerNS};\n \n use Determinacy::*;\n@@ -1441,7 +1442,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Entry point to crate resolution.\n-    pub fn resolve_crate(&mut self, krate: &Crate, ignore_bodies: bool) {\n+    pub fn resolve_crate(&mut self, krate: &Crate, ignore_bodies: IgnoreState) {\n         let _prof_timer = self.session.prof.generic_activity(\"resolve_crate\");\n \n         ImportResolver { r: self }.finalize_imports();"}, {"sha": "d2dd8d835fd7955772e484a10a51c781c04f6dc9", "filename": "src/test/rustdoc-ui/impl-fn-nesting.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1b8accb7497e6fe66be331e40f8663d198a6b648/src%2Ftest%2Frustdoc-ui%2Fimpl-fn-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b8accb7497e6fe66be331e40f8663d198a6b648/src%2Ftest%2Frustdoc-ui%2Fimpl-fn-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fimpl-fn-nesting.rs?ref=1b8accb7497e6fe66be331e40f8663d198a6b648", "patch": "@@ -0,0 +1,49 @@\n+// Ensure that rustdoc gives errors for trait impls inside function bodies that don't resolve.\n+// See https://github.com/rust-lang/rust/pull/73566\n+pub struct ValidType;\n+pub trait ValidTrait {}\n+pub trait NeedsBody {\n+    type Item;\n+    fn f();\n+}\n+\n+/// This function has docs\n+pub fn f<B: UnknownBound>(a: UnknownType, b: B) {\n+//~^ ERROR cannot find trait `UnknownBound` in this scope\n+//~| ERROR cannot find type `UnknownType` in this scope\n+    impl UnknownTrait for ValidType {} //~ ERROR cannot find trait `UnknownTrait`\n+    impl<T: UnknownBound> UnknownTrait for T {}\n+    //~^ ERROR cannot find trait `UnknownBound` in this scope\n+    //~| ERROR cannot find trait `UnknownTrait` in this scope\n+    impl ValidTrait for UnknownType {}\n+    //~^ ERROR cannot find type `UnknownType` in this scope\n+    impl ValidTrait for ValidType where ValidTrait: UnknownBound {}\n+    //~^ ERROR cannot find trait `UnknownBound` in this scope\n+\n+    /// This impl has documentation\n+    impl NeedsBody for ValidType {\n+        type Item = UnknownType;\n+        //~^ ERROR cannot find type `UnknownType` in this scope\n+\n+        /// This function has documentation\n+        fn f() {\n+            <UnknownTypeShouldBeIgnored>::a();\n+            content::shouldnt::matter();\n+            unknown_macro!();\n+            //~^ ERROR cannot find macro `unknown_macro` in this scope\n+\n+            /// This is documentation for a macro\n+            macro_rules! can_define_macros_here_too {\n+                () => {\n+                    this::content::should::also::be::ignored()\n+                }\n+            }\n+            can_define_macros_here_too!();\n+\n+            /// This also is documented.\n+            pub fn doubly_nested(c: UnknownTypeShouldBeIgnored) {\n+\n+            }\n+        }\n+    }\n+}"}, {"sha": "f8629964c0701ec3edeca8a4e224c21404229df4", "filename": "src/test/rustdoc-ui/impl-fn-nesting.stderr", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1b8accb7497e6fe66be331e40f8663d198a6b648/src%2Ftest%2Frustdoc-ui%2Fimpl-fn-nesting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b8accb7497e6fe66be331e40f8663d198a6b648/src%2Ftest%2Frustdoc-ui%2Fimpl-fn-nesting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fimpl-fn-nesting.stderr?ref=1b8accb7497e6fe66be331e40f8663d198a6b648", "patch": "@@ -0,0 +1,60 @@\n+error: cannot find macro `unknown_macro` in this scope\n+  --> $DIR/impl-fn-nesting.rs:32:13\n+   |\n+LL |             unknown_macro!();\n+   |             ^^^^^^^^^^^^^\n+\n+error[E0405]: cannot find trait `UnknownBound` in this scope\n+  --> $DIR/impl-fn-nesting.rs:11:13\n+   |\n+LL | pub fn f<B: UnknownBound>(a: UnknownType, b: B) {\n+   |             ^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `UnknownType` in this scope\n+  --> $DIR/impl-fn-nesting.rs:11:30\n+   |\n+LL | pub fn f<B: UnknownBound>(a: UnknownType, b: B) {\n+   |                              ^^^^^^^^^^^ not found in this scope\n+\n+error[E0405]: cannot find trait `UnknownTrait` in this scope\n+  --> $DIR/impl-fn-nesting.rs:14:10\n+   |\n+LL |     impl UnknownTrait for ValidType {}\n+   |          ^^^^^^^^^^^^ not found in this scope\n+\n+error[E0405]: cannot find trait `UnknownTrait` in this scope\n+  --> $DIR/impl-fn-nesting.rs:15:27\n+   |\n+LL |     impl<T: UnknownBound> UnknownTrait for T {}\n+   |                           ^^^^^^^^^^^^ not found in this scope\n+\n+error[E0405]: cannot find trait `UnknownBound` in this scope\n+  --> $DIR/impl-fn-nesting.rs:15:13\n+   |\n+LL |     impl<T: UnknownBound> UnknownTrait for T {}\n+   |             ^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `UnknownType` in this scope\n+  --> $DIR/impl-fn-nesting.rs:18:25\n+   |\n+LL |     impl ValidTrait for UnknownType {}\n+   |                         ^^^^^^^^^^^ not found in this scope\n+\n+error[E0405]: cannot find trait `UnknownBound` in this scope\n+  --> $DIR/impl-fn-nesting.rs:20:53\n+   |\n+LL |     impl ValidTrait for ValidType where ValidTrait: UnknownBound {}\n+   |                                                     ^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `UnknownType` in this scope\n+  --> $DIR/impl-fn-nesting.rs:25:21\n+   |\n+LL |         type Item = UnknownType;\n+   |                     ^^^^^^^^^^^ not found in this scope\n+\n+error: Compilation failed, aborting rustdoc\n+\n+error: aborting due to 10 previous errors\n+\n+Some errors have detailed explanations: E0405, E0412.\n+For more information about an error, try `rustc --explain E0405`."}, {"sha": "aa407b7e9261838b348783c4bd1ebdebb1cb2a0f", "filename": "src/test/rustdoc/doc-cfg.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b8accb7497e6fe66be331e40f8663d198a6b648/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b8accb7497e6fe66be331e40f8663d198a6b648/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs?ref=1b8accb7497e6fe66be331e40f8663d198a6b648", "patch": "@@ -57,7 +57,5 @@ pub unsafe fn uses_target_feature() {\n //        'This is supported with target feature avx only.'\n #[doc(cfg(target_feature = \"avx\"))]\n pub fn uses_cfg_target_feature() {\n-    unsafe {\n-        uses_target_feature();\n-    }\n+    uses_target_feature();\n }"}]}