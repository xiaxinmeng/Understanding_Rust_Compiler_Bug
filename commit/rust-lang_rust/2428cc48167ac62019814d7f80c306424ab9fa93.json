{"sha": "2428cc48167ac62019814d7f80c306424ab9fa93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0MjhjYzQ4MTY3YWM2MjAxOTgxNGQ3ZjgwYzMwNjQyNGFiOWZhOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-03T05:41:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-03T05:41:23Z"}, "message": "Auto merge of #84842 - blkerby:null_lowercase, r=joshtriplett\n\nReplace 'NULL' with 'null'\n\nThis replaces occurrences of \"NULL\" with \"null\" in docs, comments, and compiler error/lint messages. This is for the sake of consistency, as the lowercase \"null\" is already the dominant form in Rust. The all-caps NULL looks like the C macro (or SQL keyword), which seems out of place in a Rust context, given that NULL does not exist in the Rust language or standard library (instead having [`ptr::null()`](https://doc.rust-lang.org/stable/std/ptr/fn.null.html)).", "tree": {"sha": "590c990f489ced3823b61af15862281165d84a3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/590c990f489ced3823b61af15862281165d84a3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2428cc48167ac62019814d7f80c306424ab9fa93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2428cc48167ac62019814d7f80c306424ab9fa93", "html_url": "https://github.com/rust-lang/rust/commit/2428cc48167ac62019814d7f80c306424ab9fa93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2428cc48167ac62019814d7f80c306424ab9fa93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59f551a2dcf57c0d3d96ac5ef60e000524210469", "url": "https://api.github.com/repos/rust-lang/rust/commits/59f551a2dcf57c0d3d96ac5ef60e000524210469", "html_url": "https://github.com/rust-lang/rust/commit/59f551a2dcf57c0d3d96ac5ef60e000524210469"}, {"sha": "6679f5ceb1bd367050bb69b239d94d6213696336", "url": "https://api.github.com/repos/rust-lang/rust/commits/6679f5ceb1bd367050bb69b239d94d6213696336", "html_url": "https://github.com/rust-lang/rust/commit/6679f5ceb1bd367050bb69b239d94d6213696336"}], "stats": {"total": 150, "additions": 75, "deletions": 75}, "files": [{"sha": "decc1e1f70007e2223f54d0d4d853b21d5c43120", "filename": "compiler/rustc_codegen_llvm/src/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -66,7 +66,7 @@ fn search_meta_section<'a>(\n             let mut name_buf = None;\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n             let name = name_buf.map_or_else(\n-                String::new, // We got a NULL ptr, ignore `name_len`.\n+                String::new, // We got a null ptr, ignore `name_len`.\n                 |buf| {\n                     String::from_utf8(\n                         slice::from_raw_parts(buf.as_ptr() as *const u8, name_len as usize)"}, {"sha": "c9b038f0e8796b0c45a5e2c6b9217317edc3a94b", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -2328,7 +2328,7 @@ const HAS_MIN_FEATURES: &[Symbol] = &[sym::specialization];\n \n declare_lint! {\n     /// The `invalid_value` lint detects creating a value that is not valid,\n-    /// such as a NULL reference.\n+    /// such as a null reference.\n     ///\n     /// ### Example\n     ///\n@@ -2359,7 +2359,7 @@ declare_lint! {\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     pub INVALID_VALUE,\n     Warn,\n-    \"an invalid value is being created (such as a NULL reference)\"\n+    \"an invalid value is being created (such as a null reference)\"\n }\n \n declare_lint_pass!(InvalidValue => [INVALID_VALUE]);"}, {"sha": "1a900ccbf65faeed61a07c03f4e26755eee44eeb", "filename": "compiler/rustc_metadata/src/dynamic_lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_metadata%2Fsrc%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_metadata%2Fsrc%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdynamic_lib.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -105,7 +105,7 @@ mod dl {\n             return Ok(ret.cast());\n         }\n \n-        // A NULL return from `dlopen` indicates that an error has definitely occurred, so if\n+        // A null return from `dlopen` indicates that an error has definitely occurred, so if\n         // nothing is in `dlerror`, we are racing with another thread that has stolen our error\n         // message. See the explanation on the `dl::error` module for more information.\n         dlerror.get().and_then(|()| Err(\"Unknown error\".to_string()))\n@@ -117,7 +117,7 @@ mod dl {\n     ) -> Result<*mut u8, String> {\n         let mut dlerror = error::lock();\n \n-        // Unlike `dlopen`, it's possible for `dlsym` to return NULL without overwriting `dlerror`.\n+        // Unlike `dlopen`, it's possible for `dlsym` to return null without overwriting `dlerror`.\n         // Because of this, we clear `dlerror` before calling `dlsym` to avoid picking up a stale\n         // error message by accident.\n         dlerror.clear();\n@@ -128,7 +128,7 @@ mod dl {\n             return Ok(ret.cast());\n         }\n \n-        // If `dlsym` returns NULL but there is nothing in `dlerror` it means one of two things:\n+        // If `dlsym` returns null but there is nothing in `dlerror` it means one of two things:\n         // - We tried to load a symbol mapped to address 0. This is not technically an error but is\n         //   unlikely to occur in practice and equally unlikely to be handled correctly by calling\n         //   code. Therefore we treat it as an error anyway."}, {"sha": "d4970a4f5321f30e062ac1696d580a455d5d9c42", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -185,7 +185,7 @@ impl fmt::Display for CheckInAllocMsg {\n             \"{}\",\n             match *self {\n                 CheckInAllocMsg::MemoryAccessTest => \"memory access\",\n-                CheckInAllocMsg::NullPointerTest => \"NULL pointer test\",\n+                CheckInAllocMsg::NullPointerTest => \"null pointer test\",\n                 CheckInAllocMsg::PointerArithmeticTest => \"pointer arithmetic\",\n                 CheckInAllocMsg::InboundsTest => \"inbounds test\",\n             }\n@@ -309,7 +309,7 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n                 allocation_size.bytes()\n             ),\n             DanglingIntPointer(_, CheckInAllocMsg::NullPointerTest) => {\n-                write!(f, \"NULL pointer is not allowed for this operation\")\n+                write!(f, \"null pointer is not allowed for this operation\")\n             }\n             DanglingIntPointer(i, msg) => {\n                 write!(f, \"{} failed: 0x{:x} is not a valid pointer\", msg, i)"}, {"sha": "a80aa6ad3d81eef743183b597b8b0d65ab079658", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -81,7 +81,7 @@ impl UnsafetyViolationDetails {\n             ),\n             DerefOfRawPointer => (\n                 \"dereference of raw pointer\",\n-                \"raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules \\\n+                \"raw pointers may be null, dangling or unaligned; they can violate aliasing rules \\\n                  and cause data races: all of these are undefined behavior\",\n             ),\n             AssignToDroppingUnionField => ("}, {"sha": "dea1b11331549ef862e382c3cda18b071a5e5a3c", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -348,8 +348,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let b = self.read_immediate(&args[1])?.to_scalar()?;\n \n                 // Special case: if both scalars are *equal integers*\n-                // and not NULL, we pretend there is an allocation of size 0 right there,\n-                // and their offset is 0. (There's never a valid object at NULL, making it an\n+                // and not null, we pretend there is an allocation of size 0 right there,\n+                // and their offset is 0. (There's never a valid object at null, making it an\n                 // exception from the exception.)\n                 // This is the dual to the special exception for offset-by-0\n                 // in the inbounds pointer offset operation (see the Miri code, `src/operator.rs`).\n@@ -501,7 +501,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Offsets a pointer by some multiple of its type, returning an error if the pointer leaves its\n     /// allocation. For integer pointers, we consider each of them their own tiny allocation of size\n-    /// 0, so offset-by-0 (and only 0) is okay -- except that NULL cannot be offset by _any_ value.\n+    /// 0, so offset-by-0 (and only 0) is okay -- except that null cannot be offset by _any_ value.\n     pub fn ptr_offset_inbounds(\n         &self,\n         ptr: Scalar<M::PointerTag>,\n@@ -521,7 +521,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // pointers to be properly aligned (unlike a read/write operation).\n         let min_ptr = if offset_bytes >= 0 { ptr } else { offset_ptr };\n         let size = offset_bytes.unsigned_abs();\n-        // This call handles checking for integer/NULL pointers.\n+        // This call handles checking for integer/null pointers.\n         self.memory.check_ptr_access_align(\n             min_ptr,\n             Size::from_bytes(size),"}, {"sha": "1aaa56403f4645976a330808429152a53f1138b2", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -2,7 +2,7 @@\n //!\n //! Generally, we use `Pointer` to denote memory addresses. However, some operations\n //! have a \"size\"-like parameter, and they take `Scalar` for the address because\n-//! if the size is 0, then the pointer can also be a (properly aligned, non-NULL)\n+//! if the size is 0, then the pointer can also be a (properly aligned, non-null)\n //! integer. It is crucial that these operations call `check_align` *before*\n //! short-circuiting the empty case!\n \n@@ -105,7 +105,7 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Map for \"extra\" function pointers.\n     extra_fn_ptr_map: FxHashMap<AllocId, M::ExtraFnVal>,\n \n-    /// To be able to compare pointers with NULL, and to check alignment for accesses\n+    /// To be able to compare pointers with null, and to check alignment for accesses\n     /// to ZSTs (where pointers may dangle), we keep track of the size even for allocations\n     /// that do not exist any more.\n     // FIXME: this should not be public, but interning currently needs access to it\n@@ -391,7 +391,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Ok(bits) => {\n                 let bits = u64::try_from(bits).unwrap(); // it's ptr-sized\n                 assert!(size.bytes() == 0);\n-                // Must be non-NULL.\n+                // Must be non-null.\n                 if bits == 0 {\n                     throw_ub!(DanglingIntPointer(0, msg))\n                 }\n@@ -404,7 +404,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Err(ptr) => {\n                 let (allocation_size, alloc_align) =\n                     self.get_size_and_align(ptr.alloc_id, AllocCheck::Dereferenceable)?;\n-                // Test bounds. This also ensures non-NULL.\n+                // Test bounds. This also ensures non-null.\n                 // It is sufficient to check this for the end pointer. The addition\n                 // checks for overflow.\n                 let end_ptr = ptr.offset(size, self)?;\n@@ -436,7 +436,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         })\n     }\n \n-    /// Test if the pointer might be NULL.\n+    /// Test if the pointer might be null.\n     pub fn ptr_may_be_null(&self, ptr: Pointer<M::PointerTag>) -> bool {\n         let (size, _align) = self\n             .get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)"}, {"sha": "d7c11aee21fba5c53a6f5e400acfc40fc0e3ae99", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -375,7 +375,7 @@ where\n         assert!(place.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n         // Check (stricter) dynamic alignment, unless forced otherwise.\n         place.mplace.align = force_align.unwrap_or(align);\n-        // When dereferencing a pointer, it must be non-NULL, aligned, and live.\n+        // When dereferencing a pointer, it must be non-null, aligned, and live.\n         if let Some(ptr) = self.check_mplace_access(&place, Some(size))? {\n             place.mplace.ptr = ptr.into();\n         }"}, {"sha": "19ceec70e04265397090fd9cc0357c291b6b833f", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -427,7 +427,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     has.bytes()\n                 },\n             err_ub!(DanglingIntPointer(0, _)) =>\n-                { \"a NULL {}\", kind },\n+                { \"a null {}\", kind },\n             err_ub!(DanglingIntPointer(i, _)) =>\n                 { \"a dangling {} (address 0x{:x} is unallocated)\", kind, i },\n             err_ub!(PointerOutOfBounds { .. }) =>\n@@ -662,10 +662,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n             Err(ptr) => {\n                 if lo == 1 && hi == max_hi {\n-                    // Only NULL is the niche.  So make sure the ptr is NOT NULL.\n+                    // Only null is the niche.  So make sure the ptr is NOT null.\n                     if self.ecx.memory.ptr_may_be_null(ptr) {\n                         throw_validation_failure!(self.path,\n-                            { \"a potentially NULL pointer\" }\n+                            { \"a potentially null pointer\" }\n                             expected {\n                                 \"something that cannot possibly fail to be {}\",\n                                 wrapping_range_format(valid_range, max_hi)"}, {"sha": "30a69bfe982f0b08dbc14d982c9a0126ebb0a3b8", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -84,7 +84,7 @@\n //! /* Returns ownership to the caller */\n //! struct Foo* foo_new(void);\n //!\n-//! /* Takes ownership from the caller; no-op when invoked with NULL */\n+//! /* Takes ownership from the caller; no-op when invoked with null */\n //! void foo_delete(struct Foo*);\n //! ```\n //!"}, {"sha": "d7dd7ee02c1f43fbd633a037f49216cc4ff62bf1", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -1773,7 +1773,7 @@ extern \"rust-intrinsic\" {\n     /// [violate memory safety][read-ownership].\n     ///\n     /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n-    /// `0`, the pointers must be non-NULL and properly aligned.\n+    /// `0`, the pointers must be non-null and properly aligned.\n     ///\n     /// [`read`]: crate::ptr::read\n     /// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n@@ -1857,7 +1857,7 @@ extern \"rust-intrinsic\" {\n     /// [violate memory safety][read-ownership].\n     ///\n     /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n-    /// `0`, the pointers must be non-NULL and properly aligned.\n+    /// `0`, the pointers must be non-null and properly aligned.\n     ///\n     /// [`read`]: crate::ptr::read\n     /// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n@@ -1928,7 +1928,7 @@ pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n /// invalid value of `T` is undefined behavior.\n ///\n /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n-/// `0`, the pointer must be non-NULL and properly aligned.\n+/// `0`, the pointer must be non-null and properly aligned.\n ///\n /// [valid]: crate::ptr#safety\n ///"}, {"sha": "f77acdd618072484dc0816e25c4c09350ebcb1e4", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -10,7 +10,7 @@ use crate::ptr;\n ///\n /// The compiler, in general, assumes that a variable is properly initialized\n /// according to the requirements of the variable's type. For example, a variable of\n-/// reference type must be aligned and non-NULL. This is an invariant that must\n+/// reference type must be aligned and non-null. This is an invariant that must\n /// *always* be upheld, even in unsafe code. As a consequence, zero-initializing a\n /// variable of reference type causes instantaneous [undefined behavior][ub],\n /// no matter whether that reference ever gets used to access memory:"}, {"sha": "8348afb2a56a84ff7e2a8f65521ac90ccf5bd236", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -66,7 +66,7 @@ impl<T: ?Sized> *const T {\n     ///\n     /// # Safety\n     ///\n-    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// When calling this method, you have to ensure that *either* the pointer is null *or*\n     /// all of the following is true:\n     ///\n     /// * The pointer must be properly aligned.\n@@ -130,7 +130,7 @@ impl<T: ?Sized> *const T {\n     ///\n     /// # Safety\n     ///\n-    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// When calling this method, you have to ensure that *either* the pointer is null *or*\n     /// all of the following is true:\n     ///\n     /// * The pointer must be properly aligned.\n@@ -974,7 +974,7 @@ impl<T> *const [T] {\n     ///\n     /// # Safety\n     ///\n-    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// When calling this method, you have to ensure that *either* the pointer is null *or*\n     /// all of the following is true:\n     ///\n     /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,"}, {"sha": "415bdde11eb88db7c6e2e2d4e38d6976f165eb1b", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -149,7 +149,7 @@ mod mut_ptr;\n /// again. [`write()`] can be used to overwrite data without causing it to be\n /// dropped.\n ///\n-/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n+/// Note that even if `T` has size `0`, the pointer must be non-null and properly aligned.\n ///\n /// [valid]: self#safety\n ///\n@@ -315,7 +315,7 @@ pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n ///\n /// * Both `x` and `y` must be properly aligned.\n ///\n-/// Note that even if `T` has size `0`, the pointers must be non-NULL and properly aligned.\n+/// Note that even if `T` has size `0`, the pointers must be non-null and properly aligned.\n ///\n /// [valid]: self#safety\n ///\n@@ -394,7 +394,7 @@ pub const unsafe fn swap<T>(x: *mut T, y: *mut T) {\n ///   beginning at `y` with the same size.\n ///\n /// Note that even if the effectively copied size (`count * size_of::<T>()`) is `0`,\n-/// the pointers must be non-NULL and properly aligned.\n+/// the pointers must be non-null and properly aligned.\n ///\n /// [valid]: self#safety\n ///\n@@ -540,7 +540,7 @@ const unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n ///\n /// * `dst` must point to a properly initialized value of type `T`.\n ///\n-/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n+/// Note that even if `T` has size `0`, the pointer must be non-null and properly aligned.\n ///\n /// [valid]: self#safety\n ///\n@@ -588,7 +588,7 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n ///\n /// * `src` must point to a properly initialized value of type `T`.\n ///\n-/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n+/// Note that even if `T` has size `0`, the pointer must be non-null and properly aligned.\n ///\n /// # Examples\n ///\n@@ -713,7 +713,7 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership].\n ///\n-/// Note that even if `T` has size `0`, the pointer must be non-NULL.\n+/// Note that even if `T` has size `0`, the pointer must be non-null.\n ///\n /// [read-ownership]: read#ownership-of-the-returned-value\n /// [valid]: self#safety\n@@ -818,7 +818,7 @@ pub const unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// * `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\n ///   case.\n ///\n-/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n+/// Note that even if `T` has size `0`, the pointer must be non-null and properly aligned.\n ///\n /// [valid]: self#safety\n ///\n@@ -910,7 +910,7 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n ///\n /// * `dst` must be [valid] for writes.\n ///\n-/// Note that even if `T` has size `0`, the pointer must be non-NULL.\n+/// Note that even if `T` has size `0`, the pointer must be non-null.\n ///\n /// [valid]: self#safety\n ///\n@@ -1024,7 +1024,7 @@ pub const unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// However, storing non-[`Copy`] types in volatile memory is almost certainly\n /// incorrect.\n ///\n-/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n+/// Note that even if `T` has size `0`, the pointer must be non-null and properly aligned.\n ///\n /// [valid]: self#safety\n /// [read-ownership]: read#ownership-of-the-returned-value\n@@ -1094,7 +1094,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// * `dst` must be properly aligned.\n ///\n-/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n+/// Note that even if `T` has size `0`, the pointer must be non-null and properly aligned.\n ///\n /// [valid]: self#safety\n ///\n@@ -1496,7 +1496,7 @@ fnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K, L }\n ///\n /// Note, however, that the `expr` in `addr_of!(expr)` is still subject to all\n /// the usual rules. In particular, `addr_of!(*ptr::null())` is Undefined\n-/// Behavior because it dereferences a NULL pointer.\n+/// Behavior because it dereferences a null pointer.\n ///\n /// # Example\n ///\n@@ -1536,7 +1536,7 @@ pub macro addr_of($place:expr) {\n ///\n /// Note, however, that the `expr` in `addr_of_mut!(expr)` is still subject to all\n /// the usual rules. In particular, `addr_of_mut!(*ptr::null_mut())` is Undefined\n-/// Behavior because it dereferences a NULL pointer.\n+/// Behavior because it dereferences a null pointer.\n ///\n /// # Examples\n ///"}, {"sha": "292ac3e3f7fec3a664588d4b00b8ed05facc96e0", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -68,7 +68,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// # Safety\n     ///\n-    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// When calling this method, you have to ensure that *either* the pointer is null *or*\n     /// all of the following is true:\n     ///\n     /// * The pointer must be properly aligned.\n@@ -135,7 +135,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// # Safety\n     ///\n-    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// When calling this method, you have to ensure that *either* the pointer is null *or*\n     /// all of the following is true:\n     ///\n     /// * The pointer must be properly aligned.\n@@ -314,7 +314,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// # Safety\n     ///\n-    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// When calling this method, you have to ensure that *either* the pointer is null *or*\n     /// all of the following is true:\n     ///\n     /// * The pointer must be properly aligned.\n@@ -380,7 +380,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// # Safety\n     ///\n-    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// When calling this method, you have to ensure that *either* the pointer is null *or*\n     /// all of the following is true:\n     ///\n     /// * The pointer must be properly aligned.\n@@ -1237,7 +1237,7 @@ impl<T> *mut [T] {\n     ///\n     /// # Safety\n     ///\n-    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// When calling this method, you have to ensure that *either* the pointer is null *or*\n     /// all of the following is true:\n     ///\n     /// * The pointer must be [valid] for reads for `ptr.len() * mem::size_of::<T>()` many bytes,\n@@ -1288,7 +1288,7 @@ impl<T> *mut [T] {\n     ///\n     /// # Safety\n     ///\n-    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// When calling this method, you have to ensure that *either* the pointer is null *or*\n     /// all of the following is true:\n     ///\n     /// * The pointer must be [valid] for reads and writes for `ptr.len() * mem::size_of::<T>()`"}, {"sha": "1c65518af04f56090efd7b6859268b5389584695", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -519,7 +519,7 @@ impl<T> NonNull<[T]> {\n         I: SliceIndex<[T]>,\n     {\n         // SAFETY: the caller ensures that `self` is dereferencable and `index` in-bounds.\n-        // As a consequence, the resulting pointer cannot be NULL.\n+        // As a consequence, the resulting pointer cannot be null.\n         unsafe { NonNull::new_unchecked(self.as_ptr().get_unchecked_mut(index)) }\n     }\n }"}, {"sha": "58028d40576470685145943ee1982d6bbdc7eb7b", "filename": "library/panic_unwind/src/seh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fseh.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -316,7 +316,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n }\n \n pub unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send> {\n-    // A NULL payload here means that we got here from the catch (...) of\n+    // A null payload here means that we got here from the catch (...) of\n     // __rust_try. This happens when a non-Rust foreign exception is caught.\n     if payload.is_null() {\n         super::__rust_foreign_exception();"}, {"sha": "2f9845d7536cd4bf7882cf4c2ddccf99c9c55109", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -498,7 +498,7 @@ impl CString {\n     /// Failure to call [`CString::from_raw`] will lead to a memory leak.\n     ///\n     /// The C side must **not** modify the length of the string (by writing a\n-    /// `NULL` somewhere inside the string or removing the final one) before\n+    /// `null` somewhere inside the string or removing the final one) before\n     /// it makes it back into Rust using [`CString::from_raw`]. See the safety section\n     /// in [`CString::from_raw`].\n     ///"}, {"sha": "15ce7056fea3489a5a6ee789d8127a3e7222e659", "filename": "library/std/src/sys/unix/ext/net/ancillary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -49,7 +49,7 @@ pub(super) fn recv_vectored_with_ancillary_from(\n                 msg.msg_controllen = ancillary.buffer.len() as libc::socklen_t;\n             }\n         }\n-        // macos requires that the control pointer is NULL when the len is 0.\n+        // macos requires that the control pointer is null when the len is 0.\n         if msg.msg_controllen > 0 {\n             msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n         }\n@@ -97,7 +97,7 @@ pub(super) fn send_vectored_with_ancillary_to(\n                 msg.msg_controllen = ancillary.length as libc::socklen_t;\n             }\n         }\n-        // macos requires that the control pointer is NULL when the len is 0.\n+        // macos requires that the control pointer is null when the len is 0.\n         if msg.msg_controllen > 0 {\n             msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n         }"}, {"sha": "79617aa77b7b211d91b1a91f4e55af42bbc746a1", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -116,7 +116,7 @@ cfg_has_statx! {{\n \n         match STATX_STATE.load(Ordering::Relaxed) {\n             0 => {\n-                // It is a trick to call `statx` with NULL pointers to check if the syscall\n+                // It is a trick to call `statx` with null pointers to check if the syscall\n                 // is available. According to the manual, it is expected to fail with EFAULT.\n                 // We do this mainly for performance, since it is nearly hundreds times\n                 // faster than a normal successful call.\n@@ -450,7 +450,7 @@ impl Iterator for ReadDir {\n                 super::os::set_errno(0);\n                 let entry_ptr = libc::readdir(self.inner.dirp.0);\n                 if entry_ptr.is_null() {\n-                    // NULL can mean either the end is reached or an error occurred.\n+                    // null can mean either the end is reached or an error occurred.\n                     // So we had to clear errno beforehand to check for an error now.\n                     return match super::os::errno() {\n                         0 => None,"}, {"sha": "c5bdd1bda4a7a7c4b4bfcb25e6691ac0f79f8ef4", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -153,7 +153,7 @@ impl Command {\n     }\n \n     pub fn arg(&mut self, arg: &OsStr) {\n-        // Overwrite the trailing NULL pointer in `argv` and then add a new null\n+        // Overwrite the trailing null pointer in `argv` and then add a new null\n         // pointer.\n         let arg = os2c(arg, &mut self.saw_nul);\n         self.argv.0[self.args.len()] = arg.as_ptr();"}, {"sha": "1f5f26e3e1449244742a16777e3a9457b0c3cc1e", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -722,7 +722,7 @@ pub mod os {\n     unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n         // SAFETY:\n         //\n-        // The OS TLS ensures that this key contains a NULL value when this\n+        // The OS TLS ensures that this key contains a null value when this\n         // destructor starts to run. We set it back to a sentinel value of 1 to\n         // ensure that any future calls to `get` for this thread will return\n         // `None`."}, {"sha": "ce8ab632fcf3e08feac3d7b292da51d3ab17dc81", "filename": "src/test/ui/consts/const-eval/ub-nonnull.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.32bit.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -14,7 +14,7 @@ error: any use of this value will cause an error\n    |\n LL | / const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n LL | |     let ptr: &[u8; 256] = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n-LL | |     // Use address-of-element for pointer arithmetic. This could wrap around to NULL!\n+LL | |     // Use address-of-element for pointer arithmetic. This could wrap around to null!\n LL | |     let out_of_bounds_ptr = &ptr[255];\n    | |                              ^^^^^^^^ memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of alloc10 which has size 1\n LL | |"}, {"sha": "3f49a262ae46768041ccac414df3cd2ce0cb10a8", "filename": "src/test/ui/consts/const-eval/ub-nonnull.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -14,7 +14,7 @@ error: any use of this value will cause an error\n    |\n LL | / const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n LL | |     let ptr: &[u8; 256] = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n-LL | |     // Use address-of-element for pointer arithmetic. This could wrap around to NULL!\n+LL | |     // Use address-of-element for pointer arithmetic. This could wrap around to null!\n LL | |     let out_of_bounds_ptr = &ptr[255];\n    | |                              ^^^^^^^^ memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of alloc10 which has size 1\n LL | |"}, {"sha": "75c02a8da194fdc2904dbcdca00a620a633a31a4", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -15,7 +15,7 @@ const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n #[deny(const_err)] // this triggers a `const_err` so validation does not even happen\n const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n     let ptr: &[u8; 256] = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n-    // Use address-of-element for pointer arithmetic. This could wrap around to NULL!\n+    // Use address-of-element for pointer arithmetic. This could wrap around to null!\n     let out_of_bounds_ptr = &ptr[255]; //~ ERROR any use of this value will cause an error\n     //~| WARN this was previously accepted by the compiler but is being phased out\n     mem::transmute(out_of_bounds_ptr)"}, {"sha": "d4a61a4631932d73c9eadeb200ca5dbe910c99c4", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -24,7 +24,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:21:1\n    |\n LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a NULL reference\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a null reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n@@ -35,7 +35,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:24:1\n    |\n LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a NULL box\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a null box\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {"}, {"sha": "17da7c25bac95dfac834ea128b099af3c10b00ab", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -24,7 +24,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:21:1\n    |\n LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a NULL reference\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a null reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n@@ -35,7 +35,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:24:1\n    |\n LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a NULL box\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a null box\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {"}, {"sha": "33251535be9033f07213ab760e211100acf02f12", "filename": "src/test/ui/consts/const-eval/ub-upvars.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.32bit.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -6,7 +6,7 @@ LL | |     let bad_ref: &'static u16 = unsafe { mem::transmute(0usize) };\n LL | |     let another_var = 13;\n LL | |     move || { let _ = bad_ref; let _ = another_var; }\n LL | | };\n-   | |__^ type validation failed: encountered a NULL reference at .<deref>.<dyn-downcast>.<captured-var(bad_ref)>\n+   | |__^ type validation failed: encountered a null reference at .<deref>.<dyn-downcast>.<captured-var(bad_ref)>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {"}, {"sha": "de6033702ae3002053be959d454d337ae575bd32", "filename": "src/test/ui/consts/const-eval/ub-upvars.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.64bit.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -6,7 +6,7 @@ LL | |     let bad_ref: &'static u16 = unsafe { mem::transmute(0usize) };\n LL | |     let another_var = 13;\n LL | |     move || { let _ = bad_ref; let _ = another_var; }\n LL | | };\n-   | |__^ type validation failed: encountered a NULL reference at .<deref>.<dyn-downcast>.<captured-var(bad_ref)>\n+   | |__^ type validation failed: encountered a null reference at .<deref>.<dyn-downcast>.<captured-var(bad_ref)>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {"}, {"sha": "0bd3dbf6863c5b0e59636255402786c450365cb2", "filename": "src/test/ui/generator/issue-45729-unsafe-in-generator.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fgenerator%2Fissue-45729-unsafe-in-generator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fgenerator%2Fissue-45729-unsafe-in-generator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-45729-unsafe-in-generator.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -4,7 +4,7 @@ error[E0133]: dereference of raw pointer is unsafe and requires unsafe function\n LL |         *(1 as *mut u32) = 42;\n    |         ^^^^^^^^^^^^^^^^^^^^^ dereference of raw pointer\n    |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: aborting due to previous error\n "}, {"sha": "aebcbf07463052ea10c9c24b038e346b7d088764", "filename": "src/test/ui/issues/issue-47412.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fissues%2Fissue-47412.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Fissues%2Fissue-47412.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47412.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -12,7 +12,7 @@ error[E0133]: dereference of raw pointer is unsafe and requires unsafe function\n LL |     match *ptr {}\n    |           ^^^^ dereference of raw pointer\n    |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0aeb186828eeaa1930ce1d2fb51966912b08f700", "filename": "src/test/ui/traits/safety-fn-body.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Ftraits%2Fsafety-fn-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Ftraits%2Fsafety-fn-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsafety-fn-body.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -4,7 +4,7 @@ error[E0133]: dereference of raw pointer is unsafe and requires unsafe function\n LL |         *self += 1;\n    |         ^^^^^^^^^^ dereference of raw pointer\n    |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: aborting due to previous error\n "}, {"sha": "88322c3a0a68405f24ff3a8eadc965ce5f92af17", "filename": "src/test/ui/unsafe/issue-45087-unreachable-unsafe.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Funsafe%2Fissue-45087-unreachable-unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Funsafe%2Fissue-45087-unreachable-unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Fissue-45087-unreachable-unsafe.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -4,7 +4,7 @@ error[E0133]: dereference of raw pointer is unsafe and requires unsafe function\n LL |     *(1 as *mut u32) = 42;\n    |     ^^^^^^^^^^^^^^^^^^^^^ dereference of raw pointer\n    |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: aborting due to previous error\n "}, {"sha": "ad93267ca014e4e4983a657ed4e863e726d5774c", "filename": "src/test/ui/unsafe/rfc-2585-unsafe_op_in_unsafe_fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -17,7 +17,7 @@ error: dereference of raw pointer is unsafe and requires unsafe block (error E01\n LL |     *PTR;\n    |     ^^^^ dereference of raw pointer\n    |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: use of mutable static is unsafe and requires unsafe block (error E0133)\n   --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:13:5\n@@ -59,7 +59,7 @@ error: dereference of raw pointer is unsafe and requires unsafe block (error E01\n LL |     *PTR;\n    |     ^^^^ dereference of raw pointer\n    |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: use of mutable static is unsafe and requires unsafe block (error E0133)\n   --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:28:5"}, {"sha": "b2a30f81e058a9bb84ce6d786b19ffd86278ff8d", "filename": "src/test/ui/unsafe/unsafe-fn-assign-deref-ptr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Funsafe%2Funsafe-fn-assign-deref-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Funsafe%2Funsafe-fn-assign-deref-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-fn-assign-deref-ptr.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -4,7 +4,7 @@ error[E0133]: dereference of raw pointer is unsafe and requires unsafe function\n LL |     *p = 0;\n    |     ^^^^^^ dereference of raw pointer\n    |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: aborting due to previous error\n "}, {"sha": "98cb7b876f802ef3329c5d2309f92ab159e2247d", "filename": "src/test/ui/unsafe/unsafe-fn-deref-ptr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Funsafe%2Funsafe-fn-deref-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Funsafe%2Funsafe-fn-deref-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-fn-deref-ptr.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -4,7 +4,7 @@ error[E0133]: dereference of raw pointer is unsafe and requires unsafe function\n LL |     return *p;\n    |            ^^ dereference of raw pointer\n    |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: aborting due to previous error\n "}, {"sha": "98d7ae9f854341209df4fad6111abec211eb5fd6", "filename": "src/test/ui/unsafe/unsafe-unstable-const-fn.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Funsafe%2Funsafe-unstable-const-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2428cc48167ac62019814d7f80c306424ab9fa93/src%2Ftest%2Fui%2Funsafe%2Funsafe-unstable-const-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-unstable-const-fn.stderr?ref=2428cc48167ac62019814d7f80c306424ab9fa93", "patch": "@@ -4,7 +4,7 @@ error[E0133]: dereference of raw pointer is unsafe and requires unsafe function\n LL |     *a == b\n    |     ^^ dereference of raw pointer\n    |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: aborting due to previous error\n "}]}