{"sha": "8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYjMwMmQzNGRkZTM2Y2M3OGEyODhjYjViZWI0YWY3ZmUzMGJhNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-19T10:13:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-19T10:13:52Z"}, "message": "Auto merge of #80106 - jackh726:binder-refactor-part-2, r=lcnr\n\nA lot of refactoring to remove more `Binder::bind`s\n\nSplit out from #76814", "tree": {"sha": "61b64b211aa67a08b0bbc1cbaf7a8059bdbdc9cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61b64b211aa67a08b0bbc1cbaf7a8059bdbdc9cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "html_url": "https://github.com/rust-lang/rust/commit/8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e461b8137f8f7277147e3ec8ec0b7f0f31d32d0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e461b8137f8f7277147e3ec8ec0b7f0f31d32d0b", "html_url": "https://github.com/rust-lang/rust/commit/e461b8137f8f7277147e3ec8ec0b7f0f31d32d0b"}, {"sha": "5e7095850c3577666a6b8e628760dea7cccb46b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e7095850c3577666a6b8e628760dea7cccb46b7", "html_url": "https://github.com/rust-lang/rust/commit/5e7095850c3577666a6b8e628760dea7cccb46b7"}], "stats": {"total": 332, "additions": 175, "deletions": 157}, "files": [{"sha": "71ce50f7453725be234897a53cd5daa4a2a9b100", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -525,10 +525,10 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         result_subst: &'a CanonicalVarValues<'tcx>,\n     ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a + Captures<'tcx> {\n         unsubstituted_region_constraints.iter().map(move |&constraint| {\n-            let ty::OutlivesPredicate(k1, r2) =\n-                substitute_value(self.tcx, result_subst, constraint).skip_binder();\n+            let predicate = substitute_value(self.tcx, result_subst, constraint);\n+            let ty::OutlivesPredicate(k1, r2) = predicate.skip_binder();\n \n-            let predicate = match k1.unpack() {\n+            let atom = match k1.unpack() {\n                 GenericArgKind::Lifetime(r1) => {\n                     ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n                 }\n@@ -540,8 +540,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                     // encounter this branch.\n                     span_bug!(cause.span, \"unexpected const outlives {:?}\", constraint);\n                 }\n-            }\n-            .potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n+            };\n+            let predicate =\n+                predicate.rebind(atom).potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n \n             Obligation::new(cause.clone(), param_env, predicate)\n         })"}, {"sha": "7770f2bd9115523eae496574dc6c5515ae8b2a17", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -551,7 +551,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n+        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n     fn relate_item_substs(\n@@ -833,7 +833,7 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n+        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n     fn tys(&mut self, t: Ty<'tcx>, _t: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {"}, {"sha": "b9bd66e4b929fdbd3db46906741b62a5eda4d35c", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -1008,6 +1008,6 @@ where\n         self.first_free_index.shift_in(1);\n         let result = self.relate(a.skip_binder(), a.skip_binder())?;\n         self.first_free_index.shift_out(1);\n-        Ok(ty::Binder::bind(result))\n+        Ok(a.rebind(result))\n     }\n }"}, {"sha": "a5962e3b3ba5726bc98e9f7bab27adca2a0755d2", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -118,6 +118,6 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n+        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n }"}, {"sha": "615972ae45c92056f17b6bc287e1f7366cda21f3", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -299,6 +299,7 @@ pub struct ResolvedOpaqueTy<'tcx> {\n /// Here, we would store the type `T`, the span of the value `x`, the \"scope-span\" for\n /// the scope that contains `x`, the expr `T` evaluated from, and the span of `foo.await`.\n #[derive(TyEncodable, TyDecodable, Clone, Debug, Eq, Hash, PartialEq, HashStable)]\n+#[derive(TypeFoldable)]\n pub struct GeneratorInteriorTypeCause<'tcx> {\n     /// Type of the captured binding.\n     pub ty: Ty<'tcx>,\n@@ -423,7 +424,7 @@ pub struct TypeckResults<'tcx> {\n \n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n-    pub generator_interior_types: Vec<GeneratorInteriorTypeCause<'tcx>>,\n+    pub generator_interior_types: ty::Binder<Vec<GeneratorInteriorTypeCause<'tcx>>>,\n \n     /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n     /// as `&[u8]`, depending on the pattern  in which they are used.\n@@ -455,7 +456,7 @@ impl<'tcx> TypeckResults<'tcx> {\n             concrete_opaque_types: Default::default(),\n             closure_captures: Default::default(),\n             closure_min_captures: Default::default(),\n-            generator_interior_types: Default::default(),\n+            generator_interior_types: ty::Binder::dummy(Default::default()),\n             treat_byte_string_as_slice: Default::default(),\n         }\n     }"}, {"sha": "98602d6a459b285991758a98c5a8b961a130940c", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -1149,17 +1149,16 @@ pub enum PredicateAtom<'tcx> {\n     TypeWellFormedFromEnv(Ty<'tcx>),\n }\n \n-impl<'tcx> PredicateAtom<'tcx> {\n+impl<'tcx> Binder<PredicateAtom<'tcx>> {\n     /// Wraps `self` with the given qualifier if this predicate has any unbound variables.\n     pub fn potentially_quantified(\n         self,\n         tcx: TyCtxt<'tcx>,\n         qualifier: impl FnOnce(Binder<PredicateAtom<'tcx>>) -> PredicateKind<'tcx>,\n     ) -> Predicate<'tcx> {\n-        if self.has_escaping_bound_vars() {\n-            qualifier(Binder::bind(self))\n-        } else {\n-            PredicateKind::Atom(self)\n+        match self.no_bound_vars() {\n+            Some(atom) => PredicateKind::Atom(atom),\n+            None => qualifier(self),\n         }\n         .to_predicate(tcx)\n     }\n@@ -1252,7 +1251,11 @@ impl<'tcx> Predicate<'tcx> {\n         let substs = trait_ref.skip_binder().substs;\n         let pred = self.skip_binders();\n         let new = pred.subst(tcx, substs);\n-        if new != pred { new.potentially_quantified(tcx, PredicateKind::ForAll) } else { self }\n+        if new != pred {\n+            ty::Binder::bind(new).potentially_quantified(tcx, PredicateKind::ForAll)\n+        } else {\n+            self\n+        }\n     }\n }\n \n@@ -1279,6 +1282,10 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n         // Ok to skip binder since trait `DefId` does not care about regions.\n         self.skip_binder().def_id()\n     }\n+\n+    pub fn self_ty(self) -> ty::Binder<Ty<'tcx>> {\n+        self.map_bound(|trait_ref| trait_ref.self_ty())\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n@@ -1403,37 +1410,39 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitPredicate<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateAtom::Trait(self.value.skip_binder(), self.constness)\n+        self.value\n+            .map_bound(|value| PredicateAtom::Trait(value, self.constness))\n             .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateAtom::RegionOutlives(self.skip_binder())\n+        self.map_bound(|value| PredicateAtom::RegionOutlives(value))\n             .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateAtom::TypeOutlives(self.skip_binder())\n+        self.map_bound(|value| PredicateAtom::TypeOutlives(value))\n             .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateAtom::Projection(self.skip_binder())\n+        self.map_bound(|value| PredicateAtom::Projection(value))\n             .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> Predicate<'tcx> {\n     pub fn to_opt_poly_trait_ref(self) -> Option<ConstnessAnd<PolyTraitRef<'tcx>>> {\n-        match self.skip_binders() {\n+        let predicate = self.bound_atom();\n+        match predicate.skip_binder() {\n             PredicateAtom::Trait(t, constness) => {\n-                Some(ConstnessAnd { constness, value: ty::Binder::bind(t.trait_ref) })\n+                Some(ConstnessAnd { constness, value: predicate.rebind(t.trait_ref) })\n             }\n             PredicateAtom::Projection(..)\n             | PredicateAtom::Subtype(..)\n@@ -1449,8 +1458,9 @@ impl<'tcx> Predicate<'tcx> {\n     }\n \n     pub fn to_opt_type_outlives(self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n-        match self.skip_binders() {\n-            PredicateAtom::TypeOutlives(data) => Some(ty::Binder::bind(data)),\n+        let predicate = self.bound_atom();\n+        match predicate.skip_binder() {\n+            PredicateAtom::TypeOutlives(data) => Some(predicate.rebind(data)),\n             PredicateAtom::Trait(..)\n             | PredicateAtom::Projection(..)\n             | PredicateAtom::Subtype(..)"}, {"sha": "b4b71a48ce9d2595db67bf36cf0a8543f31068e0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -1151,9 +1151,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     ) -> DiagnosticBuilder<'tcx> {\n         crate fn build_fn_sig_string<'tcx>(\n             tcx: TyCtxt<'tcx>,\n-            trait_ref: ty::TraitRef<'tcx>,\n+            trait_ref: ty::PolyTraitRef<'tcx>,\n         ) -> String {\n-            let inputs = trait_ref.substs.type_at(1);\n+            let inputs = trait_ref.skip_binder().substs.type_at(1);\n             let sig = if let ty::Tuple(inputs) = inputs.kind() {\n                 tcx.mk_fn_sig(\n                     inputs.iter().map(|k| k.expect_ty()),\n@@ -1171,7 +1171,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     abi::Abi::Rust,\n                 )\n             };\n-            ty::Binder::bind(sig).to_string()\n+            trait_ref.rebind(sig).to_string()\n         }\n \n         let argument_is_closure = expected_ref.skip_binder().substs.type_at(0).is_closure();\n@@ -1183,17 +1183,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if argument_is_closure { \"closure\" } else { \"function\" }\n         );\n \n-        let found_str = format!(\n-            \"expected signature of `{}`\",\n-            build_fn_sig_string(self.tcx, found.skip_binder())\n-        );\n+        let found_str = format!(\"expected signature of `{}`\", build_fn_sig_string(self.tcx, found));\n         err.span_label(span, found_str);\n \n         let found_span = found_span.unwrap_or(span);\n-        let expected_str = format!(\n-            \"found signature of `{}`\",\n-            build_fn_sig_string(self.tcx, expected_ref.skip_binder())\n-        );\n+        let expected_str =\n+            format!(\"found signature of `{}`\", build_fn_sig_string(self.tcx, expected_ref));\n         err.span_label(found_span, expected_str);\n \n         err\n@@ -1422,7 +1417,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             // generator frame. Bound regions are preserved by\n             // `erase_regions` and so we must also call\n             // `erase_late_bound_regions`.\n-            let ty_erased = self.tcx.erase_late_bound_regions(ty::Binder::bind(ty));\n+            let ty_erased = self.tcx.erase_late_bound_regions(ty);\n             let ty_erased = self.tcx.erase_regions(ty_erased);\n             let eq = ty::TyS::same_type(ty_erased, target_ty_erased);\n             debug!(\n@@ -1440,18 +1435,21 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             interior_or_upvar_span = upvars.iter().find_map(|(upvar_id, upvar)| {\n                 let upvar_ty = typeck_results.node_type(*upvar_id);\n                 let upvar_ty = self.resolve_vars_if_possible(upvar_ty);\n-                if ty_matches(&upvar_ty) {\n+                if ty_matches(ty::Binder::dummy(upvar_ty)) {\n                     Some(GeneratorInteriorOrUpvar::Upvar(upvar.span))\n                 } else {\n                     None\n                 }\n             });\n         };\n \n-        if let Some(cause) = typeck_results\n-            .generator_interior_types\n-            .iter()\n-            .find(|ty::GeneratorInteriorTypeCause { ty, .. }| ty_matches(ty))\n+        // The generator interior types share the same binders\n+        if let Some(cause) =\n+            typeck_results.generator_interior_types.as_ref().skip_binder().iter().find(\n+                |ty::GeneratorInteriorTypeCause { ty, .. }| {\n+                    ty_matches(typeck_results.generator_interior_types.rebind(ty))\n+                },\n+            )\n         {\n             // Check to see if any awaited expressions have the target type.\n             let from_awaited_ty = visitor\n@@ -1464,7 +1462,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         \"maybe_note_obligation_cause_for_async_await: await_expr={:?}\",\n                         await_expr\n                     );\n-                    ty_matches(ty)\n+                    ty_matches(ty::Binder::dummy(ty))\n                 })\n                 .map(|expr| expr.span);\n             let ty::GeneratorInteriorTypeCause { span, scope_span, yield_span, expr, .. } = cause;"}, {"sha": "8b6e30f34fd4a64f7bfb6e9c334dc693faaa0697", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -418,11 +418,11 @@ fn virtual_call_violation_for_method<'tcx>(\n     }\n \n     for (i, &input_ty) in sig.skip_binder().inputs()[1..].iter().enumerate() {\n-        if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n+        if contains_illegal_self_type_reference(tcx, trait_def_id, sig.rebind(input_ty)) {\n             return Some(MethodViolationCode::ReferencesSelfInput(i));\n         }\n     }\n-    if contains_illegal_self_type_reference(tcx, trait_def_id, sig.output().skip_binder()) {\n+    if contains_illegal_self_type_reference(tcx, trait_def_id, sig.output()) {\n         return Some(MethodViolationCode::ReferencesSelfOutput);\n     }\n "}, {"sha": "a11499e43209f662817d43141924363663485002", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -951,7 +951,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n \n     // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n     // start out by selecting the predicate `T as TraitRef<...>`:\n-    let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+    let poly_trait_ref = ty::Binder::dummy(*obligation_trait_ref);\n     let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n     let _ = selcx.infcx().commit_if_ok(|_| {\n         let impl_source = match selcx.select(&trait_obligation) {\n@@ -1247,7 +1247,9 @@ fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n         ty: self_ty.discriminant_ty(tcx),\n     };\n \n-    confirm_param_env_candidate(selcx, obligation, ty::Binder::bind(predicate), false)\n+    // We get here from `poly_project_and_unify_type` which replaces bound vars\n+    // with placeholders, so dummy is okay here.\n+    confirm_param_env_candidate(selcx, obligation, ty::Binder::dummy(predicate), false)\n }\n \n fn confirm_fn_pointer_candidate<'cx, 'tcx>("}, {"sha": "81de6dc71f46692dc2e39a4faaae645d12c78e7e", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -259,10 +259,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> ImplSourceAutoImplData<PredicateObligation<'tcx>> {\n         debug!(?obligation, ?trait_def_id, \"confirm_auto_impl_candidate\");\n \n-        let types = obligation.predicate.map_bound(|inner| {\n-            let self_ty = self.infcx.shallow_resolve(inner.self_ty());\n-            self.constituent_types_for_ty(self_ty)\n-        });\n+        let self_ty = self.infcx.shallow_resolve(obligation.predicate.self_ty());\n+        let types = self.constituent_types_for_ty(self_ty);\n         self.vtable_auto_impl(obligation, trait_def_id, types)\n     }\n "}, {"sha": "f1c86eab0956e3c76fe9d7a46e7b8db2d28676fe", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -1276,7 +1276,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // FIXME(generic_associated_types): Compare the whole projections\n         let data_poly_trait_ref = projection_ty.map_bound(|proj| proj.trait_ref(self.tcx()));\n-        let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+        let obligation_poly_trait_ref = ty::Binder::dummy(*obligation_trait_ref);\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n@@ -1648,8 +1648,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Bar<i32> where struct Bar<T> { x: T, y: u32 } -> [i32, u32]\n     /// Zed<i32> where enum Zed { A(T), B(u32) } -> [i32, u32]\n     /// ```\n-    fn constituent_types_for_ty(&self, t: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n-        match *t.kind() {\n+    fn constituent_types_for_ty(&self, t: ty::Binder<Ty<'tcx>>) -> ty::Binder<Vec<Ty<'tcx>>> {\n+        match *t.skip_binder().kind() {\n             ty::Uint(_)\n             | ty::Int(_)\n             | ty::Bool\n@@ -1660,7 +1660,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Error(_)\n             | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n             | ty::Never\n-            | ty::Char => Vec::new(),\n+            | ty::Char => ty::Binder::dummy(Vec::new()),\n \n             ty::Placeholder(..)\n             | ty::Dynamic(..)\n@@ -1673,44 +1673,44 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::RawPtr(ty::TypeAndMut { ty: element_ty, .. }) | ty::Ref(_, element_ty, _) => {\n-                vec![element_ty]\n+                t.rebind(vec![element_ty])\n             }\n \n-            ty::Array(element_ty, _) | ty::Slice(element_ty) => vec![element_ty],\n+            ty::Array(element_ty, _) | ty::Slice(element_ty) => t.rebind(vec![element_ty]),\n \n             ty::Tuple(ref tys) => {\n                 // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-                tys.iter().map(|k| k.expect_ty()).collect()\n+                t.rebind(tys.iter().map(|k| k.expect_ty()).collect())\n             }\n \n             ty::Closure(_, ref substs) => {\n                 let ty = self.infcx.shallow_resolve(substs.as_closure().tupled_upvars_ty());\n-                vec![ty]\n+                t.rebind(vec![ty])\n             }\n \n             ty::Generator(_, ref substs, _) => {\n                 let ty = self.infcx.shallow_resolve(substs.as_generator().tupled_upvars_ty());\n                 let witness = substs.as_generator().witness();\n-                vec![ty].into_iter().chain(iter::once(witness)).collect()\n+                t.rebind(vec![ty].into_iter().chain(iter::once(witness)).collect())\n             }\n \n             ty::GeneratorWitness(types) => {\n-                // This is sound because no regions in the witness can refer to\n-                // the binder outside the witness. So we'll effectivly reuse\n-                // the implicit binder around the witness.\n-                types.skip_binder().to_vec()\n+                debug_assert!(!types.has_escaping_bound_vars());\n+                types.map_bound(|types| types.to_vec())\n             }\n \n             // For `PhantomData<T>`, we pass `T`.\n-            ty::Adt(def, substs) if def.is_phantom_data() => substs.types().collect(),\n+            ty::Adt(def, substs) if def.is_phantom_data() => t.rebind(substs.types().collect()),\n \n-            ty::Adt(def, substs) => def.all_fields().map(|f| f.ty(self.tcx(), substs)).collect(),\n+            ty::Adt(def, substs) => {\n+                t.rebind(def.all_fields().map(|f| f.ty(self.tcx(), substs)).collect())\n+            }\n \n             ty::Opaque(def_id, substs) => {\n                 // We can resolve the `impl Trait` to its concrete type,\n                 // which enforces a DAG between the functions requiring\n                 // the auto trait bounds in question.\n-                vec![self.tcx().type_of(def_id).subst(self.tcx(), substs)]\n+                t.rebind(vec![self.tcx().type_of(def_id).subst(self.tcx(), substs)])\n             }\n         }\n     }\n@@ -1738,10 +1738,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // 3. Re-bind the regions back to `for<'a> &'a i32 : Copy`\n \n         types\n+            .as_ref()\n             .skip_binder() // binder moved -\\\n             .iter()\n             .flat_map(|ty| {\n-                let ty: ty::Binder<Ty<'tcx>> = ty::Binder::bind(ty); // <----/\n+                let ty: ty::Binder<Ty<'tcx>> = types.rebind(ty); // <----/\n \n                 self.infcx.commit_unconditionally(|_| {\n                     let placeholder_ty = self.infcx.replace_bound_vars_with_placeholders(ty);"}, {"sha": "8888ea2c8490cd411b332cd510a988f09a4b0b5d", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -6,7 +6,7 @@ use smallvec::SmallVec;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, Subst, SubstsRef};\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n \n use super::{Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext};\n pub use rustc_infer::traits::util::*;\n@@ -333,11 +333,12 @@ pub fn closure_trait_ref_and_return_type(\n         TupleArgumentsFlag::No => sig.skip_binder().inputs()[0],\n         TupleArgumentsFlag::Yes => tcx.intern_tup(sig.skip_binder().inputs()),\n     };\n+    debug_assert!(!self_ty.has_escaping_bound_vars());\n     let trait_ref = ty::TraitRef {\n         def_id: fn_trait_def_id,\n         substs: tcx.mk_substs_trait(self_ty, &[arguments_tuple.into()]),\n     };\n-    ty::Binder::bind((trait_ref, sig.skip_binder().output()))\n+    sig.map_bound(|sig| (trait_ref, sig.output()))\n }\n \n pub fn generator_trait_ref_and_outputs(\n@@ -346,11 +347,12 @@ pub fn generator_trait_ref_and_outputs(\n     self_ty: Ty<'tcx>,\n     sig: ty::PolyGenSig<'tcx>,\n ) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>, Ty<'tcx>)> {\n+    debug_assert!(!self_ty.has_escaping_bound_vars());\n     let trait_ref = ty::TraitRef {\n         def_id: fn_trait_def_id,\n         substs: tcx.mk_substs_trait(self_ty, &[sig.skip_binder().resume_ty.into()]),\n     };\n-    ty::Binder::bind((trait_ref, sig.skip_binder().yield_ty, sig.skip_binder().return_ty))\n+    sig.map_bound(|sig| (trait_ref, sig.yield_ty, sig.return_ty))\n }\n \n pub fn impl_item_is_final(tcx: TyCtxt<'_>, assoc_item: &ty::AssocItem) -> bool {"}, {"sha": "c470659e18a45769738173f7bd5430a2d3091be6", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -837,9 +837,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .instantiate_lang_item_trait_ref(\n                         lang_item, span, hir_id, args, param_ty, bounds,\n                     ),\n-                hir::GenericBound::Outlives(ref l) => {\n-                    bounds.region_bounds.push((self.ast_region_to_region(l, None), l.span))\n-                }\n+                hir::GenericBound::Outlives(ref l) => bounds\n+                    .region_bounds\n+                    .push((ty::Binder::bind(self.ast_region_to_region(l, None)), l.span)),\n             }\n         }\n     }"}, {"sha": "7ba90ad88193f8302ff26cde6120afb803fb6d62", "filename": "compiler/rustc_typeck/src/bounds.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -26,7 +26,7 @@ pub struct Bounds<'tcx> {\n     /// A list of region bounds on the (implicit) self type. So if you\n     /// had `T: 'a + 'b` this might would be a list `['a, 'b]` (but\n     /// the `T` is not explicitly included).\n-    pub region_bounds: Vec<(ty::Region<'tcx>, Span)>,\n+    pub region_bounds: Vec<(ty::Binder<ty::Region<'tcx>>, Span)>,\n \n     /// A list of trait bounds. So if you had `T: Debug` this would be\n     /// `T: Debug`. Note that the self-type is explicit here.\n@@ -68,8 +68,12 @@ impl<'tcx> Bounds<'tcx> {\n         sized_predicate\n             .into_iter()\n             .chain(self.region_bounds.iter().map(|&(region_bound, span)| {\n-                let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n-                (ty::Binder::bind(outlives).to_predicate(tcx), span)\n+                (\n+                    region_bound\n+                        .map_bound(|region_bound| ty::OutlivesPredicate(param_ty, region_bound))\n+                        .to_predicate(tcx),\n+                    span,\n+                )\n             }))\n             .chain(self.trait_bounds.iter().map(|&(bound_trait_ref, span, constness)| {\n                 let predicate = bound_trait_ref.with_constness(constness).to_predicate(tcx);"}, {"sha": "22e287320d842d61bfb64e957bc4ec10597b44ae", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -389,7 +389,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // In that case, we check each argument against \"error\" in order to\n                 // set up all the node type bindings.\n                 (\n-                    ty::Binder::bind(self.tcx.mk_fn_sig(\n+                    ty::Binder::dummy(self.tcx.mk_fn_sig(\n                         self.err_args(arg_exprs.len()).into_iter(),\n                         self.tcx.ty_error(),\n                         false,"}, {"sha": "7470c1a76a94316a910164c188e28618ae5be30f", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -24,7 +24,7 @@ use std::iter;\n struct ExpectedSig<'tcx> {\n     /// Span that gave us this expectation, if we know that.\n     cause_span: Option<Span>,\n-    sig: ty::FnSig<'tcx>,\n+    sig: ty::PolyFnSig<'tcx>,\n }\n \n struct ClosureSignatures<'tcx> {\n@@ -174,7 +174,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n             ty::FnPtr(sig) => {\n-                let expected_sig = ExpectedSig { cause_span: None, sig: sig.skip_binder() };\n+                let expected_sig = ExpectedSig { cause_span: None, sig };\n                 (Some(expected_sig), Some(ty::ClosureKind::Fn))\n             }\n             _ => (None, None),\n@@ -274,13 +274,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ret_param_ty = self.resolve_vars_if_possible(ret_param_ty);\n         debug!(\"deduce_sig_from_projection: ret_param_ty={:?}\", ret_param_ty);\n \n-        let sig = self.tcx.mk_fn_sig(\n+        let sig = projection.rebind(self.tcx.mk_fn_sig(\n             input_tys.iter(),\n             &ret_param_ty,\n             false,\n             hir::Unsafety::Normal,\n             Abi::Rust,\n-        );\n+        ));\n         debug!(\"deduce_sig_from_projection: sig={:?}\", sig);\n \n         Some(ExpectedSig { cause_span, sig })\n@@ -374,9 +374,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Watch out for some surprises and just ignore the\n         // expectation if things don't see to match up with what we\n         // expect.\n-        if expected_sig.sig.c_variadic != decl.c_variadic {\n+        if expected_sig.sig.c_variadic() != decl.c_variadic {\n             return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n-        } else if expected_sig.sig.inputs_and_output.len() != decl.inputs.len() + 1 {\n+        } else if expected_sig.sig.skip_binder().inputs_and_output.len() != decl.inputs.len() + 1 {\n             return self.sig_of_closure_with_mismatched_number_of_arguments(\n                 expr_def_id,\n                 decl,\n@@ -388,14 +388,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Create a `PolyFnSig`. Note the oddity that late bound\n         // regions appearing free in `expected_sig` are now bound up\n         // in this binder we are creating.\n-        assert!(!expected_sig.sig.has_vars_bound_above(ty::INNERMOST));\n-        let bound_sig = ty::Binder::bind(self.tcx.mk_fn_sig(\n-            expected_sig.sig.inputs().iter().cloned(),\n-            expected_sig.sig.output(),\n-            decl.c_variadic,\n-            hir::Unsafety::Normal,\n-            Abi::RustCall,\n-        ));\n+        assert!(!expected_sig.sig.skip_binder().has_vars_bound_above(ty::INNERMOST));\n+        let bound_sig = expected_sig.sig.map_bound(|sig| {\n+            self.tcx.mk_fn_sig(\n+                sig.inputs().iter().cloned(),\n+                sig.output(),\n+                sig.c_variadic,\n+                hir::Unsafety::Normal,\n+                Abi::RustCall,\n+            )\n+        });\n \n         // `deduce_expectations_from_expected_type` introduces\n         // late-bound lifetimes defined elsewhere, which we now\n@@ -428,6 +430,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let expr_map_node = hir.get_if_local(expr_def_id).unwrap();\n         let expected_args: Vec<_> = expected_sig\n             .sig\n+            .skip_binder()\n             .inputs()\n             .iter()\n             .map(|ty| ArgKind::from_expected_ty(ty, None))\n@@ -500,7 +503,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let (supplied_ty, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n                     hir_ty.span,\n                     LateBoundRegionConversionTime::FnCall,\n-                    ty::Binder::bind(supplied_ty),\n+                    supplied_sig.inputs().rebind(supplied_ty),\n                 ); // recreated from (*) above\n \n                 // Check that E' = S'.\n@@ -619,12 +622,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n         let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n-            if let ty::PredicateAtom::Projection(proj_predicate) =\n-                obligation.predicate.skip_binders()\n-            {\n+            let bound_predicate = obligation.predicate.bound_atom();\n+            if let ty::PredicateAtom::Projection(proj_predicate) = bound_predicate.skip_binder() {\n                 self.deduce_future_output_from_projection(\n                     obligation.cause.span,\n-                    ty::Binder::bind(proj_predicate),\n+                    bound_predicate.rebind(proj_predicate),\n                 )\n             } else {\n                 None\n@@ -704,7 +706,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             astconv.ast_ty_to_ty(&output);\n         }\n \n-        let result = ty::Binder::bind(self.tcx.mk_fn_sig(\n+        let result = ty::Binder::dummy(self.tcx.mk_fn_sig(\n             supplied_arguments,\n             self.tcx.ty_error(),\n             decl.c_variadic,"}, {"sha": "bb324d0d8bc1ee27aaf0a8df2da6c4d575ecd21d", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -494,12 +494,11 @@ fn compare_self_type<'tcx>(\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n             ty::TraitContainer(_) => tcx.types.self_param,\n         };\n-        let self_arg_ty = tcx.fn_sig(method.def_id).input(0).skip_binder();\n+        let self_arg_ty = tcx.fn_sig(method.def_id).input(0);\n         let param_env = ty::ParamEnv::reveal_all();\n \n         tcx.infer_ctxt().enter(|infcx| {\n-            let self_arg_ty =\n-                tcx.liberate_late_bound_regions(method.def_id, ty::Binder::bind(self_arg_ty));\n+            let self_arg_ty = tcx.liberate_late_bound_regions(method.def_id, self_arg_ty);\n             let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n             match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n                 ExplicitSelf::ByValue => \"self\".to_owned(),"}, {"sha": "41a403a010ee698b1fa840dd2e88e0e445a40682", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -764,12 +764,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .pending_obligations()\n             .into_iter()\n             .filter_map(move |obligation| {\n-                match obligation.predicate.skip_binders() {\n+                let bound_predicate = obligation.predicate.bound_atom();\n+                match bound_predicate.skip_binder() {\n                     ty::PredicateAtom::Projection(data) => {\n-                        Some((ty::Binder::bind(data).to_poly_trait_ref(self.tcx), obligation))\n+                        Some((bound_predicate.rebind(data).to_poly_trait_ref(self.tcx), obligation))\n                     }\n                     ty::PredicateAtom::Trait(data, _) => {\n-                        Some((ty::Binder::bind(data).to_poly_trait_ref(), obligation))\n+                        Some((bound_predicate.rebind(data).to_poly_trait_ref(), obligation))\n                     }\n                     ty::PredicateAtom::Subtype(..) => None,\n                     ty::PredicateAtom::RegionOutlives(..) => None,"}, {"sha": "54710e12a746d4ee8f9160c4ee96537df4a9ffb3", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -204,7 +204,8 @@ pub fn resolve_interior<'a, 'tcx>(\n     let witness = fcx.tcx.mk_generator_witness(ty::Binder::bind(type_list));\n \n     // Store the generator types and spans into the typeck results for this generator.\n-    visitor.fcx.inh.typeck_results.borrow_mut().generator_interior_types = type_causes;\n+    visitor.fcx.inh.typeck_results.borrow_mut().generator_interior_types =\n+        ty::Binder::bind(type_causes);\n \n     debug!(\n         \"types in generator after region replacement {:?}, span = {:?}\","}, {"sha": "dd629980ab4db4653579b2f0e838bebec10266c2", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -12,7 +12,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::traits::{ObligationCause, ObligationCauseCode};\n use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n@@ -23,10 +23,7 @@ fn equate_intrinsic_type<'tcx>(\n     it: &hir::ForeignItem<'_>,\n     def_id: DefId,\n     n_tps: usize,\n-    abi: Abi,\n-    safety: hir::Unsafety,\n-    inputs: Vec<Ty<'tcx>>,\n-    output: Ty<'tcx>,\n+    sig: ty::PolyFnSig<'tcx>,\n ) {\n     match it.kind {\n         hir::ForeignItemKind::Fn(..) => {}\n@@ -53,13 +50,7 @@ fn equate_intrinsic_type<'tcx>(\n         return;\n     }\n \n-    let fty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n-        inputs.into_iter(),\n-        output,\n-        false,\n-        safety,\n-        abi,\n-    )));\n+    let fty = tcx.mk_fn_ptr(sig);\n     let cause = ObligationCause::new(it.span, it.hir_id, ObligationCauseCode::IntrinsicType);\n     require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(def_id)), fty);\n }\n@@ -380,7 +371,9 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n         };\n         (n_tps, inputs, output, unsafety)\n     };\n-    equate_intrinsic_type(tcx, it, def_id, n_tps, Abi::RustIntrinsic, unsafety, inputs, output)\n+    let sig = tcx.mk_fn_sig(inputs.into_iter(), output, false, unsafety, Abi::RustIntrinsic);\n+    let sig = ty::Binder::bind(sig);\n+    equate_intrinsic_type(tcx, it, def_id, n_tps, sig)\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n@@ -466,14 +459,13 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n         }\n     };\n \n-    equate_intrinsic_type(\n-        tcx,\n-        it,\n-        def_id,\n-        n_tps,\n-        Abi::PlatformIntrinsic,\n-        hir::Unsafety::Unsafe,\n-        inputs,\n+    let sig = tcx.mk_fn_sig(\n+        inputs.into_iter(),\n         output,\n-    )\n+        false,\n+        hir::Unsafety::Unsafe,\n+        Abi::PlatformIntrinsic,\n+    );\n+    let sig = ty::Binder::dummy(sig);\n+    equate_intrinsic_type(tcx, it, def_id, n_tps, sig)\n }"}, {"sha": "543e39af6694431cd2a08dd0899b716551ef7185", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -1919,10 +1919,11 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                     } else {\n                         let span = bound_pred.bounded_ty.span;\n                         let re_root_empty = tcx.lifetimes.re_root_empty;\n-                        let predicate = ty::OutlivesPredicate(ty, re_root_empty);\n+                        let predicate = ty::Binder::bind(ty::PredicateAtom::TypeOutlives(\n+                            ty::OutlivesPredicate(ty, re_root_empty),\n+                        ));\n                         predicates.insert((\n-                            ty::PredicateAtom::TypeOutlives(predicate)\n-                                .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n+                            predicate.potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                             span,\n                         ));\n                     }\n@@ -1965,8 +1966,10 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                         &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n                             predicates.insert((\n-                                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, region))\n-                                    .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n+                                ty::Binder::bind(ty::PredicateAtom::TypeOutlives(\n+                                    ty::OutlivesPredicate(ty, region),\n+                                ))\n+                                .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                                 lifetime.span,\n                             ));\n                         }\n@@ -1983,9 +1986,10 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                         }\n                         _ => bug!(),\n                     };\n-                    let pred = ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r1, r2));\n+                    let pred = ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n+                        .to_predicate(icx.tcx);\n \n-                    (pred.potentially_quantified(icx.tcx, ty::PredicateKind::ForAll), span)\n+                    (pred, span)\n                 }))\n             }\n \n@@ -2234,7 +2238,7 @@ fn predicates_from_bound<'tcx>(\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(param_ty, region))\n-                .potentially_quantified(astconv.tcx(), ty::PredicateKind::ForAll);\n+                .to_predicate(astconv.tcx());\n             vec![(pred, lifetime.span)]\n         }\n     }"}, {"sha": "dde4a62ffbf3def8ec2e9f7857d5966764e7db86", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -226,19 +226,21 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: LocalDefId) {\n             let expected_return_type = if tcx.lang_items().termination().is_some() {\n                 // we take the return type of the given main function, the real check is done\n                 // in `check_fn`\n-                actual.output().skip_binder()\n+                actual.output()\n             } else {\n                 // standard () main return type\n-                tcx.mk_unit()\n+                ty::Binder::dummy(tcx.mk_unit())\n             };\n \n-            let se_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n-                iter::empty(),\n-                expected_return_type,\n-                false,\n-                hir::Unsafety::Normal,\n-                Abi::Rust,\n-            )));\n+            let se_ty = tcx.mk_fn_ptr(expected_return_type.map_bound(|expected_return_type| {\n+                tcx.mk_fn_sig(\n+                    iter::empty(),\n+                    expected_return_type,\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    Abi::Rust,\n+                )\n+            }));\n \n             require_same_types(\n                 tcx,"}, {"sha": "b1f79331d5f62bbfebd1ca287552317f76ca1f7a", "filename": "compiler/rustc_typeck/src/outlives/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -3,7 +3,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, CratePredicatesMap, TyCtxt};\n+use rustc_middle::ty::{self, CratePredicatesMap, ToPredicate, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -90,14 +90,14 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CratePredica\n                     match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => Some((\n                             ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty1, region2))\n-                                .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n+                                .to_predicate(tcx),\n                             span,\n                         )),\n                         GenericArgKind::Lifetime(region1) => Some((\n                             ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(\n                                 region1, region2,\n                             ))\n-                            .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n+                            .to_predicate(tcx),\n                             span,\n                         )),\n                         GenericArgKind::Const(_) => {"}, {"sha": "1c9b19e6b871c4efb93e512e9a84b1f8881eef8d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -469,8 +469,9 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n \n impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n-        match self.skip_binders() {\n-            ty::PredicateAtom::Trait(pred, _) => Some(ty::Binder::bind(pred).clean(cx)),\n+        let bound_predicate = self.bound_atom();\n+        match bound_predicate.skip_binder() {\n+            ty::PredicateAtom::Trait(pred, _) => Some(bound_predicate.rebind(pred).clean(cx)),\n             ty::PredicateAtom::RegionOutlives(pred) => pred.clean(cx),\n             ty::PredicateAtom::TypeOutlives(pred) => pred.clean(cx),\n             ty::PredicateAtom::Projection(pred) => Some(pred.clean(cx)),\n@@ -733,7 +734,8 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n             .flat_map(|(p, _)| {\n                 let mut projection = None;\n                 let param_idx = (|| {\n-                    match p.skip_binders() {\n+                    let bound_p = p.bound_atom();\n+                    match bound_p.skip_binder() {\n                         ty::PredicateAtom::Trait(pred, _constness) => {\n                             if let ty::Param(param) = pred.self_ty().kind() {\n                                 return Some(param.index);\n@@ -746,7 +748,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                         }\n                         ty::PredicateAtom::Projection(p) => {\n                             if let ty::Param(param) = p.projection_ty.self_ty().kind() {\n-                                projection = Some(ty::Binder::bind(p));\n+                                projection = Some(bound_p.rebind(p));\n                                 return Some(param.index);\n                             }\n                         }\n@@ -1659,12 +1661,10 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     .filter_map(|bound| {\n                         // Note: The substs of opaque types can contain unbound variables,\n                         // meaning that we have to use `ignore_quantifiers_with_unbound_vars` here.\n-                        let trait_ref = match bound\n-                            .bound_atom_with_opt_escaping(cx.tcx)\n-                            .skip_binder()\n-                        {\n+                        let bound_predicate = bound.bound_atom_with_opt_escaping(cx.tcx);\n+                        let trait_ref = match bound_predicate.skip_binder() {\n                             ty::PredicateAtom::Trait(tr, _constness) => {\n-                                ty::Binder::bind(tr.trait_ref)\n+                                bound_predicate.rebind(tr.trait_ref)\n                             }\n                             ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n                                 if let Some(r) = reg.clean(cx) {"}, {"sha": "cfade9cbc469a5dd54efeb0d074c584d35ef59d2", "filename": "src/tools/clippy/clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb302d34dde36cc78a288cb5beb4af7fe30ba41/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=8bb302d34dde36cc78a288cb5beb4af7fe30ba41", "patch": "@@ -99,7 +99,7 @@ impl LateLintPass<'_> for AwaitHolding {\n             };\n             let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n             let typeck_results = cx.tcx.typeck(def_id);\n-            check_interior_types(cx, &typeck_results.generator_interior_types, body.value.span);\n+            check_interior_types(cx, &typeck_results.generator_interior_types.as_ref().skip_binder(), body.value.span);\n         }\n     }\n }"}]}