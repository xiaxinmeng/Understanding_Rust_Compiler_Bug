{"sha": "c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNzNlNGY2YmE1ZTRmMjc1NDI2MmVhMDJhZDNiYjIzZTc4ZTFmM2U=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-18T19:27:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-18T19:27:18Z"}, "message": "Merge #6934\n\n6934: Implement `cfg_attr` handling r=jonas-schievink a=jonas-schievink\n\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/5548\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "524b2882b071232a2603f657279e7ac9c459950f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/524b2882b071232a2603f657279e7ac9c459950f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf3QKWCRBK7hj4Ov3rIwAAdHIIAJeJNUXrCAS6cLrbAkpc/ohZ\nzGZcHntmm+rI8O1y0fmZXpH2oJBS8KkDJmhHoAaKpJ2j+RP6vk2B+O//ncEQ89Wh\nnMja3A3gO6GWKN8Cr4/kc30MES3ho7j73miqFdtXbXus3pLRmKO1i8vbxkhXlZeL\nVMVbwzqeYU0iywT31aIOUZKq9M3pTfxLVFQKpiQeDh33w+HcFSB2uTPGNE8WScOM\ndnJD7CfZgdbbyxDXFEHAS3nIDFx0LCAOcDzZRYdwP/i3TK3iOOCNTVk/WbGNPe80\n6Eld55Z6U6XdceSvGYYfrWU30k3db8gXhJ8Z0UxpUirzIgkUOIqBmE4lFh7gu98=\n=VAWo\n-----END PGP SIGNATURE-----\n", "payload": "tree 524b2882b071232a2603f657279e7ac9c459950f\nparent 25185c1418022868e2f7ec1599e32a34d63e8314\nparent aab9cc9cfb64aea659f2f9b588e8a4f392e2c4e1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1608319638 +0000\ncommitter GitHub <noreply@github.com> 1608319638 +0000\n\nMerge #6934\n\n6934: Implement `cfg_attr` handling r=jonas-schievink a=jonas-schievink\n\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/5548\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e", "html_url": "https://github.com/rust-lang/rust/commit/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25185c1418022868e2f7ec1599e32a34d63e8314", "url": "https://api.github.com/repos/rust-lang/rust/commits/25185c1418022868e2f7ec1599e32a34d63e8314", "html_url": "https://github.com/rust-lang/rust/commit/25185c1418022868e2f7ec1599e32a34d63e8314"}, {"sha": "aab9cc9cfb64aea659f2f9b588e8a4f392e2c4e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/aab9cc9cfb64aea659f2f9b588e8a4f392e2c4e1", "html_url": "https://github.com/rust-lang/rust/commit/aab9cc9cfb64aea659f2f9b588e8a4f392e2c4e1"}], "stats": {"total": 100, "additions": 97, "deletions": 3}, "files": [{"sha": "1b9c64ee55ad381c7fe8b4e42fbbee50b23ce784", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e", "patch": "@@ -12,6 +12,7 @@ use syntax::{\n     ast::{self, AstNode, AttrsOwner},\n     match_ast, AstToken, SmolStr, SyntaxNode,\n };\n+use test_utils::mark;\n use tt::Subtree;\n \n use crate::{\n@@ -122,9 +123,69 @@ impl RawAttrs {\n     }\n \n     /// Processes `cfg_attr`s, returning the resulting semantic `Attrs`.\n-    pub(crate) fn filter(self, _db: &dyn DefDatabase, _krate: CrateId) -> Attrs {\n-        // FIXME actually implement this\n-        Attrs(self)\n+    pub(crate) fn filter(self, db: &dyn DefDatabase, krate: CrateId) -> Attrs {\n+        let has_cfg_attrs = self.iter().any(|attr| {\n+            attr.path.as_ident().map_or(false, |name| *name == hir_expand::name![cfg_attr])\n+        });\n+        if !has_cfg_attrs {\n+            return Attrs(self);\n+        }\n+\n+        let crate_graph = db.crate_graph();\n+        let new_attrs = self\n+            .iter()\n+            .filter_map(|attr| {\n+                let attr = attr.clone();\n+                let is_cfg_attr =\n+                    attr.path.as_ident().map_or(false, |name| *name == hir_expand::name![cfg_attr]);\n+                if !is_cfg_attr {\n+                    return Some(attr);\n+                }\n+\n+                let subtree = match &attr.input {\n+                    Some(AttrInput::TokenTree(it)) => it,\n+                    _ => return Some(attr),\n+                };\n+\n+                // Input subtree is: `(cfg, attr)`\n+                // Split it up into a `cfg` and an `attr` subtree.\n+                // FIXME: There should be a common API for this.\n+                let mut saw_comma = false;\n+                let (mut cfg, attr): (Vec<_>, Vec<_>) =\n+                    subtree.clone().token_trees.into_iter().partition(|tree| {\n+                        if saw_comma {\n+                            return false;\n+                        }\n+\n+                        match tree {\n+                            tt::TokenTree::Leaf(tt::Leaf::Punct(p)) if p.char == ',' => {\n+                                saw_comma = true;\n+                            }\n+                            _ => {}\n+                        }\n+\n+                        true\n+                    });\n+                cfg.pop(); // `,` ends up in here\n+\n+                let attr = Subtree { delimiter: None, token_trees: attr };\n+                let cfg = Subtree { delimiter: subtree.delimiter, token_trees: cfg };\n+                let cfg = CfgExpr::parse(&cfg);\n+\n+                let cfg_options = &crate_graph[krate].cfg_options;\n+                if cfg_options.check(&cfg) == Some(false) {\n+                    None\n+                } else {\n+                    mark::hit!(cfg_attr_active);\n+\n+                    let attr = ast::Attr::parse(&format!(\"#[{}]\", attr)).ok()?;\n+                    let hygiene = Hygiene::new_unhygienic(); // FIXME\n+                    Attr::from_src(attr, &hygiene)\n+                }\n+            })\n+            .collect();\n+\n+        Attrs(RawAttrs { entries: Some(new_attrs) })\n     }\n }\n "}, {"sha": "58d69d3c6b2b33412ce675455aed5b0370f449f4", "filename": "crates/hir_def/src/nameres/tests/diagnostics.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs?ref=c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e", "patch": "@@ -1,4 +1,5 @@\n use base_db::fixture::WithFixture;\n+use test_utils::mark;\n \n use crate::test_db::TestDB;\n \n@@ -119,3 +120,20 @@ fn inactive_item() {\n         \"#,\n     );\n }\n+\n+/// Tests that `cfg` attributes behind `cfg_attr` is handled properly.\n+#[test]\n+fn inactive_via_cfg_attr() {\n+    mark::check!(cfg_attr_active);\n+    check_diagnostics(\n+        r#\"\n+        //- /lib.rs\n+          #[cfg_attr(not(never), cfg(no))] fn f() {}\n+        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: no is disabled\n+\n+          #[cfg_attr(not(never), cfg(not(no)))] fn f() {}\n+\n+          #[cfg_attr(never, cfg(no))] fn g() {}\n+        \"#,\n+    );\n+}"}, {"sha": "77eeee3fe9fff44bdc2349d044bca0b36074def1", "filename": "crates/hir_expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e/crates%2Fhir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e/crates%2Fhir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fname.rs?ref=c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e", "patch": "@@ -153,6 +153,7 @@ pub mod known {\n         // Special names\n         macro_rules,\n         doc,\n+        cfg_attr,\n         // Components of known path (value or mod name)\n         std,\n         core,"}, {"sha": "1a078f6b4cf4bc42525f47065830cfa6ede4f2fc", "filename": "crates/parser/src/grammar.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e", "patch": "@@ -133,6 +133,10 @@ pub(crate) mod fragments {\n \n         m.complete(p, MACRO_STMTS);\n     }\n+\n+    pub(crate) fn attr(p: &mut Parser) {\n+        attributes::outer_attrs(p)\n+    }\n }\n \n pub(crate) fn reparser("}, {"sha": "ab8e4c70e80955fbac22a026ff8d1564c126ef99", "filename": "crates/parser/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e/crates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e/crates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flib.rs?ref=c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e", "patch": "@@ -99,6 +99,8 @@ pub enum FragmentKind {\n     // FIXME: use separate fragment kinds for macro inputs and outputs?\n     Items,\n     Statements,\n+\n+    Attr,\n }\n \n pub fn parse_fragment(\n@@ -118,6 +120,7 @@ pub fn parse_fragment(\n         FragmentKind::Statement => grammar::fragments::stmt,\n         FragmentKind::Items => grammar::fragments::macro_items,\n         FragmentKind::Statements => grammar::fragments::macro_stmts,\n+        FragmentKind::Attr => grammar::fragments::attr,\n     };\n     parse_from_tokens(token_source, tree_sink, parser)\n }"}, {"sha": "4d272f367ad39ba4ac36f93b3fd5a98fc7322fa3", "filename": "crates/syntax/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e/crates%2Fsyntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e/crates%2Fsyntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Flib.rs?ref=c073e4f6ba5e4f2754262ea02ad3bb23e78e1f3e", "patch": "@@ -205,6 +205,13 @@ impl ast::Type {\n     }\n }\n \n+impl ast::Attr {\n+    /// Returns `text`, parsed as an attribute, but only if it has no errors.\n+    pub fn parse(text: &str) -> Result<Self, ()> {\n+        parsing::parse_text_fragment(text, parser::FragmentKind::Attr)\n+    }\n+}\n+\n /// Matches a `SyntaxNode` against an `ast` type.\n ///\n /// # Example:"}]}