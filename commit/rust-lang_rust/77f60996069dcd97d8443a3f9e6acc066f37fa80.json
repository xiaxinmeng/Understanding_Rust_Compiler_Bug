{"sha": "77f60996069dcd97d8443a3f9e6acc066f37fa80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ZjYwOTk2MDY5ZGNkOTdkODQ0M2EzZjllNmFjYzA2NmYzN2ZhODA=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-18T21:39:58Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-22T22:31:39Z"}, "message": "Using unsafe pointers to views to try to reduce some vector copy and allocation time. Doesn't seem to have made much difference.", "tree": {"sha": "c7fcbcbbf68b78e9e9215fa275e09e1eecf5039f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7fcbcbbf68b78e9e9215fa275e09e1eecf5039f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77f60996069dcd97d8443a3f9e6acc066f37fa80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77f60996069dcd97d8443a3f9e6acc066f37fa80", "html_url": "https://github.com/rust-lang/rust/commit/77f60996069dcd97d8443a3f9e6acc066f37fa80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77f60996069dcd97d8443a3f9e6acc066f37fa80/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea889742d75e68bb7ecbdf81ecbcddc12fd10616", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea889742d75e68bb7ecbdf81ecbcddc12fd10616", "html_url": "https://github.com/rust-lang/rust/commit/ea889742d75e68bb7ecbdf81ecbcddc12fd10616"}], "stats": {"total": 68, "additions": 48, "deletions": 20}, "files": [{"sha": "46716b874cfbaa0d522c8ea5120e4f3ca60ac141", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/77f60996069dcd97d8443a3f9e6acc066f37fa80/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f60996069dcd97d8443a3f9e6acc066f37fa80/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=77f60996069dcd97d8443a3f9e6acc066f37fa80", "patch": "@@ -273,6 +273,7 @@ fn pbfs(graph: graph, key: node_id) -> bfs_result {\n         // Do the BFS.\n         log(info, #fmt(\"PBFS iteration %?\", i));\n         i += 1u;\n+        let old_len = colors.len();\n         colors = par::mapi(colors) {|i, c, copy colors|\n             let c : color = c;\n             alt c {\n@@ -296,7 +297,8 @@ fn pbfs(graph: graph, key: node_id) -> bfs_result {\n               gray(parent) { black(parent) }\n               black(parent) { black(parent) }\n             }\n-        }\n+        };\n+        assert(colors.len() == old_len);\n     }\n \n     // Convert the results.\n@@ -403,10 +405,10 @@ fn validate(edges: [(node_id, node_id)],\n }\n \n fn main() {\n-    let scale = 14u;\n-    let num_keys = 16u;\n+    let scale = 18u;\n+    let num_keys = 64u;\n     let do_validate = false;\n-    let do_sequential = true;\n+    let do_sequential = false;\n \n     let start = time::precise_time_s();\n     let edges = make_edges(scale, 16u);\n@@ -522,7 +524,9 @@ const min_granularity : uint = 1024u;\n \n This is used to build most of the other parallel vector functions,\n like map or alli.\"]\n-fn map_slices<A: send, B: send>(xs: [A], f: fn~(uint, [A]) -> B) -> [B] {\n+fn map_slices<A: send, B: send>(xs: [A], f: fn~(uint, [const A]/&) -> B) \n+    -> [B] {\n+\n     let len = xs.len();\n     if len < min_granularity {\n         log(info, \"small slice\");\n@@ -538,21 +542,37 @@ fn map_slices<A: send, B: send>(xs: [A], f: fn~(uint, [A]) -> B) -> [B] {\n         let mut base = 0u;\n         log(info, \"spawning tasks\");\n         while base < len {\n-            let slice = vec::slice(xs, base,\n-                                   uint::min(len, base + items_per_task));\n-            let f = ptr::addr_of(f);\n-            futures += [future::spawn() {|copy base|\n-                unsafe {\n-                    (*f)(base, slice)\n-                }\n-            }];\n+            let end = uint::min(len, base + items_per_task);\n+            // FIXME: why is the ::<A, ()> annotation required here?\n+            vec::unpack_slice::<A, ()>(xs) {|p, _len|\n+                let f = ptr::addr_of(f);\n+                futures += [future::spawn() {|copy base|\n+                    unsafe {\n+                        let len = end - base;\n+                        let slice = (ptr::offset(p, base),\n+                                     len * sys::size_of::<A>());\n+                        log(info, #fmt(\"pre-slice: %?\", (base, slice)));\n+                        let slice : [const A]/& = \n+                            unsafe::reinterpret_cast(slice);\n+                        log(info, #fmt(\"slice: %?\",\n+                                       (base, vec::len(slice), end - base)));\n+                        assert(vec::len(slice) == end - base);\n+                        (*f)(base, slice)\n+                    }\n+                }];\n+            };\n             base += items_per_task;\n         }\n         log(info, \"tasks spawned\");\n \n-        futures.map() {|ys|\n+        log(info, #fmt(\"num_tasks: %?\", (num_tasks, futures.len())));\n+        assert(num_tasks == futures.len());\n+\n+        let r = futures.map() {|ys|\n             ys.get()\n-        }\n+        };\n+        assert(r.len() == futures.len());\n+        r\n     }\n }\n \n@@ -565,17 +585,25 @@ fn map<A: send, B: send>(xs: [A], f: fn~(A) -> B) -> [B] {\n \n #[doc=\"A parallel version of mapi.\"]\n fn mapi<A: send, B: send>(xs: [A], f: fn~(uint, A) -> B) -> [B] {\n-    vec::concat(map_slices(xs) {|base, slice|\n-        slice.mapi() {|i, x|\n+    let slices = map_slices(xs) {|base, slice|\n+        vec::mapi(slice) {|i, x|\n             f(i + base, x)\n         }\n-    })\n+    };\n+    log(info, slices.len());\n+    for vec::eachi(slices) {|i, inner|\n+        log(info, #fmt(\"slice %?: %?\", i, inner.len()));\n+    }\n+    let r = vec::concat(slices);\n+    log(info, (r.len(), xs.len()));\n+    assert(r.len() == xs.len());\n+    r\n }\n \n #[doc=\"Returns true if the function holds for all elements in the vector.\"]\n fn alli<A: send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n     vec::all(map_slices(xs) {|base, slice|\n-        slice.alli() {|i, x|\n+        vec::alli(slice) {|i, x|\n             f(i + base, x)\n         }\n     }) {|x| x }\n@@ -584,7 +612,7 @@ fn alli<A: send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n     #[doc=\"Returns true if the function holds for any elements in the vector.\"]\n     fn any<A: send>(xs: [A], f: fn~(A) -> bool) -> bool {\n         vec::any(map_slices(xs) {|_base, slice|\n-            slice.any(f)\n+            vec::any(slice, f)\n         }) {|x| x }\n     }\n "}]}