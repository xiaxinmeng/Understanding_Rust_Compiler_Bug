{"sha": "e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMTJjOGE4YzNlY2Q3ZmVhZDFlOGE2Y2M1OTEzNjBkYzczYzllNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-13T09:13:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-13T09:13:00Z"}, "message": "Auto merge of #45956 - kennytm:rollup, r=kennytm\n\nRollup of 9 pull requests\n\n- Successful merges: #45828, #45892, #45893, #45914, #45917, #45927, #45933, #45952, #45954\n- Failed merges:", "tree": {"sha": "f89bad69d8c6b8ca6bbddb12c16ab8d9adf9e2b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f89bad69d8c6b8ca6bbddb12c16ab8d9adf9e2b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "html_url": "https://github.com/rust-lang/rust/commit/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8c1424bf44d2dfa5b18dd2a85ee5106919c709d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8c1424bf44d2dfa5b18dd2a85ee5106919c709d", "html_url": "https://github.com/rust-lang/rust/commit/c8c1424bf44d2dfa5b18dd2a85ee5106919c709d"}, {"sha": "48d2627c38e014f5372d1a642bc21e5506fe83f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/48d2627c38e014f5372d1a642bc21e5506fe83f3", "html_url": "https://github.com/rust-lang/rust/commit/48d2627c38e014f5372d1a642bc21e5506fe83f3"}], "stats": {"total": 504, "additions": 420, "deletions": 84}, "files": [{"sha": "12e6e8430562a8baeb3f1472b00a5c7121ed8094", "filename": "src/libcore/option.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -634,16 +634,12 @@ impl<T> Option<T> {\n     #[inline]\n     #[unstable(feature = \"option_filter\", issue = \"45860\")]\n     pub fn filter<P: FnOnce(&T) -> bool>(self, predicate: P) -> Self {\n-        match self {\n-            Some(x) => {\n-                if predicate(&x) {\n-                    Some(x)\n-                } else {\n-                    None\n-                }\n+        if let Some(x) = self {\n+            if predicate(&x) {\n+                return Some(x)\n             }\n-            None => None,\n         }\n+        None\n     }\n \n     /// Returns the option if it contains a value, otherwise returns `optb`."}, {"sha": "39e222230e57764ab1630d429f0c1035f5fa5549", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -1949,7 +1949,7 @@ impl ForeignItem_ {\n }\n \n /// A free variable referred to in a function.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct Freevar {\n     /// The variable being accessed free.\n     pub def: Def,"}, {"sha": "cd0176506332aa1a8ee77c2155f3737070e6264a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -267,10 +267,10 @@ impl<'tcx> Mir<'tcx> {\n         let block = &self[location.block];\n         let stmts = &block.statements;\n         let idx = location.statement_index;\n-        if location.statement_index < stmts.len() {\n+        if idx < stmts.len() {\n             &stmts[idx].source_info\n         } else {\n-            assert!(location.statement_index == stmts.len());\n+            assert!(idx == stmts.len());\n             &block.terminator().source_info\n         }\n     }"}, {"sha": "00a91eeb9c18e17b77dff1de17330814506c49e1", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -164,11 +164,13 @@ enum DiagnosticBuilderMethod {\n     // add more variants as needed to support one-time diagnostics\n }\n \n-/// Diagnostic message id - used in order to avoid emitting the same message more than once\n+/// Diagnostic message ID\u2014used by `Session.one_time_diagnostics` to avoid\n+/// emitting the same message more than once\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum DiagnosticMessageId {\n+    ErrorId(u16), // EXXXX error code as integer\n     LintId(lint::LintId),\n-    StabilityId(u32)\n+    StabilityId(u32) // issue number\n }\n \n impl Session {"}, {"sha": "106b1b08656f2f40e85aa49b37fee9cb84f17bdf", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -36,6 +36,7 @@ use middle::const_val;\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use std::fmt;\n use syntax::ast;\n+use session::DiagnosticMessageId;\n use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n use ty::fast_reject;\n@@ -219,13 +220,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            let mut diag = struct_span_err!(\n-                self.tcx.sess, obligation.cause.span, E0271,\n-                \"type mismatch resolving `{}`\", predicate\n-            );\n-            self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n-            self.note_obligation_cause(&mut diag, obligation);\n-            diag.emit();\n+            let msg = format!(\"type mismatch resolving `{}`\", predicate);\n+            let error_id = (DiagnosticMessageId::ErrorId(271),\n+                            Some(obligation.cause.span), msg.clone());\n+            let fresh = self.tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n+            if fresh {\n+                let mut diag = struct_span_err!(\n+                    self.tcx.sess, obligation.cause.span, E0271,\n+                    \"type mismatch resolving `{}`\", predicate\n+                );\n+                self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n+                self.note_obligation_cause(&mut diag, obligation);\n+                diag.emit();\n+            }\n         });\n     }\n "}, {"sha": "b723b86776b11cab5c2830cfd3a801630068f02d", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 92, "deletions": 6, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -1169,8 +1169,72 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         err.emit();\n     }\n \n+    /// Finds the span of arguments of a closure (within `maybe_closure_span`) and its usage of\n+    /// the local assigned at `location`.\n+    /// This is done by searching in statements succeeding `location`\n+    /// and originating from `maybe_closure_span`.\n+    fn find_closure_span(\n+        &self,\n+        maybe_closure_span: Span,\n+        location: Location,\n+    ) -> Option<(Span, Span)> {\n+        use rustc::hir::ExprClosure;\n+        use rustc::mir::AggregateKind;\n+\n+        let local = if let StatementKind::Assign(Lvalue::Local(local), _) =\n+            self.mir[location.block].statements[location.statement_index].kind\n+        {\n+            local\n+        } else {\n+            return None;\n+        };\n+\n+        for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+            if maybe_closure_span != stmt.source_info.span {\n+                break;\n+            }\n+\n+            if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref lvs)) = stmt.kind {\n+                if let AggregateKind::Closure(def_id, _) = **kind {\n+                    debug!(\"find_closure_span: found closure {:?}\", lvs);\n+\n+                    return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                        let args_span = if let ExprClosure(_, _, _, span, _) =\n+                            self.tcx.hir.expect_expr(node_id).node\n+                        {\n+                            span\n+                        } else {\n+                            return None;\n+                        };\n+\n+                        self.tcx\n+                            .with_freevars(node_id, |freevars| {\n+                                for (v, lv) in freevars.iter().zip(lvs) {\n+                                    if let Operand::Consume(Lvalue::Local(l)) = *lv {\n+                                        if local == l {\n+                                            debug!(\n+                                                \"find_closure_span: found captured local {:?}\",\n+                                                l\n+                                            );\n+                                            return Some(v.span);\n+                                        }\n+                                    }\n+                                }\n+                                None\n+                            })\n+                            .map(|var_span| (args_span, var_span))\n+                    } else {\n+                        None\n+                    };\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn report_conflicting_borrow(&mut self,\n-                                 _context: Context,\n+                                 context: Context,\n                                  common_prefix: &Lvalue,\n                                  (lvalue, span): (&Lvalue, Span),\n                                  gen_borrow_kind: BorrowKind,\n@@ -1183,38 +1247,60 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n         let issued_span = self.retrieve_borrow_span(issued_borrow);\n \n+        let new_closure_span = self.find_closure_span(span, context.loc);\n+        let span = new_closure_span.map(|(args, _)| args).unwrap_or(span);\n+        let old_closure_span = self.find_closure_span(issued_span, issued_borrow.location);\n+        let issued_span = old_closure_span.map(|(args, _)| args).unwrap_or(issued_span);\n+\n+        let desc_lvalue = self.describe_lvalue(lvalue);\n+\n         // FIXME: supply non-\"\" `opt_via` when appropriate\n         let mut err = match (gen_borrow_kind, \"immutable\", \"mutable\",\n                              issued_borrow.kind, \"immutable\", \"mutable\") {\n             (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n             (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) =>\n                 self.tcx.cannot_reborrow_already_borrowed(\n-                    span, &self.describe_lvalue(lvalue), \"\", lft, issued_span,\n+                    span, &desc_lvalue, \"\", lft, issued_span,\n                     \"it\", rgt, \"\", end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Mut, _, _, BorrowKind::Mut, _, _) =>\n                 self.tcx.cannot_mutably_borrow_multiply(\n-                    span, &self.describe_lvalue(lvalue), \"\", issued_span,\n+                    span, &desc_lvalue, \"\", issued_span,\n                     \"\", end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) =>\n                 self.tcx.cannot_uniquely_borrow_by_two_closures(\n-                    span, &self.describe_lvalue(lvalue), issued_span,\n+                    span, &desc_lvalue, issued_span,\n                     end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Unique, _, _, _, _, _) =>\n                 self.tcx.cannot_uniquely_borrow_by_one_closure(\n-                    span, &self.describe_lvalue(lvalue), \"\",\n+                    span, &desc_lvalue, \"\",\n                     issued_span, \"it\", \"\", end_issued_loan_span, Origin::Mir),\n \n             (_, _, _, BorrowKind::Unique, _, _) =>\n                 self.tcx.cannot_reborrow_already_uniquely_borrowed(\n-                    span, &self.describe_lvalue(lvalue), \"it\", \"\",\n+                    span, &desc_lvalue, \"it\", \"\",\n                     issued_span, \"\", end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) =>\n                 unreachable!(),\n         };\n+\n+        if let Some((_, var_span)) = old_closure_span {\n+            err.span_label(\n+                var_span,\n+                format!(\"previous borrow occurs due to use of `{}` in closure\", desc_lvalue),\n+            );\n+        }\n+\n+        if let Some((_, var_span)) = new_closure_span {\n+            err.span_label(\n+                var_span,\n+                format!(\"borrow occurs due to use of `{}` in closure\", desc_lvalue),\n+            );\n+        }\n+\n         err.emit();\n     }\n "}, {"sha": "1d2bfd001f1fe20da070edd0822685f912a8907a", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -503,31 +503,10 @@ fn link_staticlib(sess: &Session,\n     if !all_native_libs.is_empty() {\n         if sess.opts.prints.contains(&PrintRequest::NativeStaticLibs) {\n             print_native_static_libs(sess, &all_native_libs);\n-        } else {\n-            // Fallback for backwards compatibility only\n-            print_native_static_libs_legacy(sess, &all_native_libs);\n         }\n     }\n }\n \n-fn print_native_static_libs_legacy(sess: &Session, all_native_libs: &[NativeLibrary]) {\n-    sess.note_without_error(\"link against the following native artifacts when linking against \\\n-                             this static library\");\n-    sess.note_without_error(\"This list will not be printed by default. \\\n-        Please add --print=native-static-libs if you need this information\");\n-\n-    for lib in all_native_libs.iter().filter(|l| relevant_lib(sess, l)) {\n-        let name = match lib.kind {\n-            NativeLibraryKind::NativeStaticNobundle |\n-            NativeLibraryKind::NativeUnknown => \"library\",\n-            NativeLibraryKind::NativeFramework => \"framework\",\n-            // These are included, no need to print them\n-            NativeLibraryKind::NativeStatic => continue,\n-        };\n-        sess.note_without_error(&format!(\"{}: {}\", name, lib.name));\n-    }\n-}\n-\n fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n     let lib_args: Vec<_> = all_native_libs.iter()\n         .filter(|l| relevant_lib(sess, l))"}, {"sha": "69922470cff4a7072a69d8b5a3cf8bcf04fa9d01", "filename": "src/libstd/path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -1690,11 +1690,11 @@ impl Path {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n     pub fn is_absolute(&self) -> bool {\n-        if !cfg!(target_os = \"redox\") {\n-            self.has_root() && (cfg!(unix) || self.prefix().is_some())\n-        } else {\n+        if cfg!(target_os = \"redox\") {\n             // FIXME: Allow Redox prefixes\n-            has_redox_scheme(self.as_u8_slice())\n+            self.has_root() || has_redox_scheme(self.as_u8_slice())\n+        } else {\n+            self.has_root() && (cfg!(unix) || self.prefix().is_some())\n         }\n     }\n "}, {"sha": "2a611ed7dabbef50953c2a36975caf1a61410e81", "filename": "src/libstd/sys/redox/condvar.rs", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fcondvar.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n use cell::UnsafeCell;\n-use intrinsics::{atomic_cxchg, atomic_xadd, atomic_xchg};\n+use intrinsics::{atomic_cxchg, atomic_load, atomic_xadd, atomic_xchg};\n use ptr;\n use time::Duration;\n \n use sys::mutex::{mutex_unlock, Mutex};\n-use sys::syscall::{futex, FUTEX_WAIT, FUTEX_WAKE, FUTEX_REQUEUE};\n+use sys::syscall::{futex, TimeSpec, FUTEX_WAIT, FUTEX_WAKE, FUTEX_REQUEUE};\n \n pub struct Condvar {\n     lock: UnsafeCell<*mut i32>,\n@@ -63,33 +63,50 @@ impl Condvar {\n     }\n \n     #[inline]\n-    pub fn wait(&self, mutex: &Mutex) {\n-        unsafe {\n-            let lock = self.lock.get();\n-            let seq = self.seq.get();\n-\n-            if *lock != mutex.lock.get() {\n-                if *lock != ptr::null_mut() {\n-                    panic!(\"Condvar used with more than one Mutex\");\n-                }\n+    unsafe fn wait_inner(&self, mutex: &Mutex, timeout_ptr: *const TimeSpec) -> bool {\n+        let lock = self.lock.get();\n+        let seq = self.seq.get();\n \n-                atomic_cxchg(lock as *mut usize, 0, mutex.lock.get() as usize);\n+        if *lock != mutex.lock.get() {\n+            if *lock != ptr::null_mut() {\n+                panic!(\"Condvar used with more than one Mutex\");\n             }\n \n-            mutex_unlock(*lock);\n+            atomic_cxchg(lock as *mut usize, 0, mutex.lock.get() as usize);\n+        }\n \n-            let _ = futex(seq, FUTEX_WAIT, *seq, 0, ptr::null_mut());\n+        mutex_unlock(*lock);\n \n-            while atomic_xchg(*lock, 2) != 0 {\n-                let _ = futex(*lock, FUTEX_WAIT, 2, 0, ptr::null_mut());\n-            }\n+        let seq_before = atomic_load(seq);\n+\n+        let _ = futex(seq, FUTEX_WAIT, seq_before, timeout_ptr as usize, ptr::null_mut());\n+\n+        let seq_after = atomic_load(seq);\n+\n+        while atomic_xchg(*lock, 2) != 0 {\n+            let _ = futex(*lock, FUTEX_WAIT, 2, 0, ptr::null_mut());\n+        }\n+\n+        seq_before != seq_after\n+    }\n+\n+    #[inline]\n+    pub fn wait(&self, mutex: &Mutex) {\n+        unsafe {\n+            assert!(self.wait_inner(mutex, ptr::null()));\n         }\n     }\n \n     #[inline]\n-    pub fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n-        ::sys_common::util::dumb_print(format_args!(\"condvar wait_timeout\\n\"));\n-        unimplemented!();\n+    pub fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        unsafe {\n+            let timeout = TimeSpec {\n+                tv_sec: dur.as_secs() as i64,\n+                tv_nsec: dur.subsec_nanos() as i32\n+            };\n+\n+            self.wait_inner(mutex, &timeout as *const TimeSpec)\n+        }\n     }\n \n     #[inline]"}, {"sha": "3483477d40cf62981ecc9d404048048415bea288", "filename": "src/libstd/sys/redox/fs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -437,8 +437,7 @@ pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n }\n \n pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n-    ::sys_common::util::dumb_print(format_args!(\"Link\\n\"));\n-    unimplemented!();\n+    Err(Error::from_raw_os_error(syscall::ENOSYS))\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {"}, {"sha": "69ddd560213778ac53e0ff871bd87de799f780b1", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -416,7 +416,7 @@ mod tests {\n         // first one is zero:\n         assert_eq!(i.intern(\"dog\"), Symbol(0));\n         // re-use gets the same entry:\n-        assert_eq!(i.intern (\"dog\"), Symbol(0));\n+        assert_eq!(i.intern(\"dog\"), Symbol(0));\n         // different string gets a different #:\n         assert_eq!(i.intern(\"cat\"), Symbol(1));\n         assert_eq!(i.intern(\"cat\"), Symbol(1));"}, {"sha": "182b3d75442421f2aa8caf32a463d0181079aec7", "filename": "src/test/ui/borrowck/borrowck-closures-two-mut.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that two closures cannot simultaneously have mutable\n+// access to the variable, whether that mutable access be used\n+// for direct assignment or for taking mutable ref. Issue #6801.\n+\n+// compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n+#![feature(box_syntax)]\n+\n+fn to_fn_mut<F: FnMut()>(f: F) -> F { f }\n+\n+fn a() {\n+    let mut x = 3;\n+    let c1 = to_fn_mut(|| x = 4);\n+    let c2 = to_fn_mut(|| x = 5); //~ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn set(x: &mut isize) {\n+    *x = 4;\n+}\n+\n+fn b() {\n+    let mut x = 3;\n+    let c1 = to_fn_mut(|| set(&mut x));\n+    let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn c() {\n+    let mut x = 3;\n+    let c1 = to_fn_mut(|| x = 5);\n+    let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn d() {\n+    let mut x = 3;\n+    let c1 = to_fn_mut(|| x = 5);\n+    let c2 = to_fn_mut(|| { let _y = to_fn_mut(|| set(&mut x)); }); // (nested closure)\n+    //~^ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn g() {\n+    struct Foo {\n+        f: Box<isize>\n+    }\n+\n+    let mut x: Box<_> = box Foo { f: box 3 };\n+    let c1 = to_fn_mut(|| set(&mut *x.f));\n+    let c2 = to_fn_mut(|| set(&mut *x.f));\n+    //~^ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn main() {\n+}"}, {"sha": "fc8a7f2ab606002b477b67da0f4c4413c6f7a7b2", "filename": "src/test/ui/borrowck/borrowck-closures-two-mut.stderr", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -0,0 +1,146 @@\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n+  --> $DIR/borrowck-closures-two-mut.rs:24:24\n+   |\n+23 |     let c1 = to_fn_mut(|| x = 4);\n+   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+24 |     let c2 = to_fn_mut(|| x = 5); //~ ERROR cannot borrow `x` as mutable more than once\n+   |                        ^^ - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+25 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n+  --> $DIR/borrowck-closures-two-mut.rs:34:24\n+   |\n+33 |     let c1 = to_fn_mut(|| set(&mut x));\n+   |                        --          - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+34 |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n+   |                        ^^          - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+35 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n+  --> $DIR/borrowck-closures-two-mut.rs:40:24\n+   |\n+39 |     let c1 = to_fn_mut(|| x = 5);\n+   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+40 |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n+   |                        ^^          - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+41 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n+  --> $DIR/borrowck-closures-two-mut.rs:46:24\n+   |\n+45 |     let c1 = to_fn_mut(|| x = 5);\n+   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+46 |     let c2 = to_fn_mut(|| { let _y = to_fn_mut(|| set(&mut x)); }); // (nested closure)\n+   |                        ^^                                  - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+47 |     //~^ ERROR cannot borrow `x` as mutable more than once\n+48 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n+  --> $DIR/borrowck-closures-two-mut.rs:57:24\n+   |\n+56 |     let c1 = to_fn_mut(|| set(&mut *x.f));\n+   |                        --           - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+57 |     let c2 = to_fn_mut(|| set(&mut *x.f));\n+   |                        ^^           - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+58 |     //~^ ERROR cannot borrow `x` as mutable more than once\n+59 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n+  --> $DIR/borrowck-closures-two-mut.rs:24:24\n+   |\n+23 |     let c1 = to_fn_mut(|| x = 4);\n+   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+24 |     let c2 = to_fn_mut(|| x = 5); //~ ERROR cannot borrow `x` as mutable more than once\n+   |                        ^^ - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+25 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n+  --> $DIR/borrowck-closures-two-mut.rs:34:24\n+   |\n+33 |     let c1 = to_fn_mut(|| set(&mut x));\n+   |                        --          - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+34 |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n+   |                        ^^          - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+35 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n+  --> $DIR/borrowck-closures-two-mut.rs:40:24\n+   |\n+39 |     let c1 = to_fn_mut(|| x = 5);\n+   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+40 |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n+   |                        ^^          - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+41 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n+  --> $DIR/borrowck-closures-two-mut.rs:46:24\n+   |\n+45 |     let c1 = to_fn_mut(|| x = 5);\n+   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+46 |     let c2 = to_fn_mut(|| { let _y = to_fn_mut(|| set(&mut x)); }); // (nested closure)\n+   |                        ^^                                  - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+47 |     //~^ ERROR cannot borrow `x` as mutable more than once\n+48 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n+  --> $DIR/borrowck-closures-two-mut.rs:57:24\n+   |\n+56 |     let c1 = to_fn_mut(|| set(&mut *x.f));\n+   |                        --           - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+57 |     let c2 = to_fn_mut(|| set(&mut *x.f));\n+   |                        ^^           - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+58 |     //~^ ERROR cannot borrow `x` as mutable more than once\n+59 | }\n+   | - first borrow ends here\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "eb111d33b99c2a204fe168a81cabbac475422b68", "filename": "src/test/ui/issue-33941.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftest%2Fui%2Fissue-33941.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftest%2Fui%2Fissue-33941.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-33941.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+\n+fn main() {\n+    for _ in HashMap::new().iter().cloned() {}\n+}"}, {"sha": "5a8d1fab3f6590867794bc9cdbd0a31dfc7ffd2d", "filename": "src/test/ui/issue-33941.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftest%2Fui%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftest%2Fui%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-33941.stderr?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -0,0 +1,21 @@\n+error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as std::iter::Iterator>::Item == &_`\n+  --> $DIR/issue-33941.rs:14:36\n+   |\n+14 |     for _ in HashMap::new().iter().cloned() {}\n+   |                                    ^^^^^^ expected tuple, found reference\n+   |\n+   = note: expected type `(&_, &_)`\n+              found type `&_`\n+\n+error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as std::iter::Iterator>::Item == &_`\n+  --> $DIR/issue-33941.rs:14:5\n+   |\n+14 |     for _ in HashMap::new().iter().cloned() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found reference\n+   |\n+   = note: expected type `(&_, &_)`\n+              found type `&_`\n+   = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::iter::Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "e03d9f89e5d8c61ca8713bd44b71126b2b65a249", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -259,20 +259,20 @@ impl TestProps {\n         props\n     }\n \n-    pub fn from_file(testfile: &Path, config: &Config) -> Self {\n+    pub fn from_file(testfile: &Path, cfg: Option<&str>, config: &Config) -> Self {\n         let mut props = TestProps::new();\n-        props.load_from(testfile, None, config);\n+        props.load_from(testfile, cfg, config);\n         props\n     }\n \n     /// Load properties from `testfile` into `props`. If a property is\n     /// tied to a particular revision `foo` (indicated by writing\n     /// `//[foo]`), then the property is ignored unless `cfg` is\n     /// `Some(\"foo\")`.\n-    pub fn load_from(&mut self,\n-                     testfile: &Path,\n-                     cfg: Option<&str>,\n-                     config: &Config) {\n+    fn load_from(&mut self,\n+                 testfile: &Path,\n+                 cfg: Option<&str>,\n+                 config: &Config) {\n         iter_header(testfile,\n                     cfg,\n                     &mut |ln| {"}, {"sha": "6da37df19279a6c5969dc9ff94c46407ba88024f", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -493,6 +493,7 @@ fn stamp(config: &Config, testpaths: &TestPaths) -> PathBuf {\n                              config.stage_id);\n     config.build_base.canonicalize()\n           .unwrap_or_else(|_| config.build_base.clone())\n+          .join(&testpaths.relative_dir)\n           .join(stamp_name)\n }\n \n@@ -524,6 +525,10 @@ fn up_to_date(config: &Config, testpaths: &TestPaths, props: &EarlyProps) -> boo\n         let lib = lib.unwrap();\n         inputs.push(mtime(&lib.path()));\n     }\n+    if let Some(ref rustdoc_path) = config.rustdoc_path {\n+        inputs.push(mtime(&rustdoc_path));\n+        inputs.push(mtime(&rust_src_dir.join(\"src/etc/htmldocck.py\")));\n+    }\n     inputs.iter().any(|input| *input > stamp)\n }\n "}, {"sha": "2ff3eb7678f1a2970400de4b78a618b272f46e2d", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=e312c8a8c3ecd7fead1e8a6cc591360dc73c9e79", "patch": "@@ -69,7 +69,7 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n         print!(\"\\n\\n\");\n     }\n     debug!(\"running {:?}\", testpaths.file.display());\n-    let base_props = TestProps::from_file(&testpaths.file, &config);\n+    let base_props = TestProps::from_file(&testpaths.file, None, &config);\n \n     let base_cx = TestCx { config: &config,\n                            props: &base_props,\n@@ -81,8 +81,9 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n         base_cx.run_revision()\n     } else {\n         for revision in &base_props.revisions {\n-            let mut revision_props = base_props.clone();\n-            revision_props.load_from(&testpaths.file, Some(revision), &config);\n+            let revision_props = TestProps::from_file(&testpaths.file,\n+                                                      Some(revision),\n+                                                      &config);\n             let rev_cx = TestCx {\n                 config: &config,\n                 props: &revision_props,\n@@ -2614,4 +2615,4 @@ fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n         stdout: stdout.into_bytes(),\n         stderr: stderr.into_bytes(),\n     })\n-}\n\\ No newline at end of file\n+}"}]}