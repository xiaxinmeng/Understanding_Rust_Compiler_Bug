{"sha": "9ba3fe5e40ed404f8865c0be4f9b5827d5861439", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYTNmZTVlNDBlZDQwNGY4ODY1YzBiZTRmOWI1ODI3ZDU4NjE0Mzk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-31T16:27:53Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-01T07:45:55Z"}, "message": "Clean up handling of restriction contexts in alias analysis", "tree": {"sha": "45fffa56ddfb4931225b097cfef828c7c5321eb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45fffa56ddfb4931225b097cfef828c7c5321eb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ba3fe5e40ed404f8865c0be4f9b5827d5861439", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ba3fe5e40ed404f8865c0be4f9b5827d5861439", "html_url": "https://github.com/rust-lang/rust/commit/9ba3fe5e40ed404f8865c0be4f9b5827d5861439", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ba3fe5e40ed404f8865c0be4f9b5827d5861439/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91f05fba11902caa66f0cc47b9c0d6d59e87ab3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/91f05fba11902caa66f0cc47b9c0d6d59e87ab3d", "html_url": "https://github.com/rust-lang/rust/commit/91f05fba11902caa66f0cc47b9c0d6d59e87ab3d"}], "stats": {"total": 187, "additions": 94, "deletions": 93}, "files": [{"sha": "75019b2029e8a46162d6faf2081045c59b5c303a", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 94, "deletions": 93, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/9ba3fe5e40ed404f8865c0be4f9b5827d5861439/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba3fe5e40ed404f8865c0be4f9b5827d5861439/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=9ba3fe5e40ed404f8865c0be4f9b5827d5861439", "patch": "@@ -27,10 +27,10 @@ import std::option::is_none;\n tag valid { valid; overwritten(span, ast::path); val_taken(span, ast::path); }\n \n type restrict =\n-    @{root_vars: [node_id],\n+    @{root_var: option::t<node_id>,\n       local_id: uint,\n       bindings: [node_id],\n-      tys: [ty::t],\n+      unsafe_ty: option::t<ty::t>,\n       depends_on: [uint],\n       mutable ok: valid};\n \n@@ -86,12 +86,11 @@ fn visit_fn(cx: &@ctx, f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span,\n             for each nid in freevars::get_freevar_defs(cx.tcx, id).keys() {\n                 dnums += [nid];\n             };\n-            @[\n-              // I'm not sure if there is anything sensical to put here\n-              @{root_vars: [],\n+            // I'm not sure if there is anything sensical to put here\n+            @[@{root_var: none,\n                 local_id: cx.next_local,\n                 bindings: dnums,\n-                tys: [],\n+                unsafe_ty: none,\n                 depends_on: [],\n                 mutable ok: valid}]\n           }\n@@ -195,14 +194,12 @@ fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt<scope>) {\n     }\n }\n \n-fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n-   {root_vars: [node_id], unsafe_ts: [ty::t]} {\n+fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n+    -> [restrict] {\n     let fty = ty::expr_ty(cx.tcx, f);\n     let arg_ts = fty_args(cx, fty);\n-    let roots: [node_id] = [];\n     let mut_roots: [{arg: uint, node: node_id}] = [];\n-    let unsafe_ts: [ty::t] = [];\n-    let unsafe_t_offsets: [uint] = [];\n+    let restricts = [];\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n         if arg_t.mode != ty::mo_val {\n@@ -242,70 +239,83 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n                   }\n                 }\n             }\n-            alt path_def_id(cx, root.ex) {\n-              some(did) { roots += [did.node]; }\n-              _ { }\n-            }\n-            alt inner_mut(root.ds) {\n-              some(t) { unsafe_ts += [t]; unsafe_t_offsets += [i]; }\n-              _ { }\n-            }\n+            let root_var = path_def_id(cx, root.ex);\n+            let unsafe_t = alt inner_mut(root.ds) {\n+              some(t) { some(t) }\n+              _ { none }\n+            };\n+            restricts += [@{root_var: root_var,\n+                            local_id: cx.next_local,\n+                            bindings: [arg.id],\n+                            unsafe_ty: unsafe_t,\n+                            depends_on: deps(sc, root_var),\n+                            mutable ok: valid}];\n         }\n         i += 1u;\n     }\n-    if vec::len(unsafe_ts) > 0u {\n-        alt f.node {\n-          ast::expr_path(_) {\n-            if def_is_local(cx.tcx.def_map.get(f.id), true) {\n+    let f_may_close = alt f.node {\n+      ast::expr_path(_) { def_is_local(cx.tcx.def_map.get(f.id), true) }\n+      _ { false } // FIXME should be true!\n+    };\n+    if f_may_close {\n+        let i = 0u;\n+        for r in restricts {\n+            if !option::is_none(r.unsafe_ty) {\n                 cx.tcx.sess.span_err(f.span,\n-                                     #ifmt[\"function may alias with \\\n-                         argument %u, which is not immutably rooted\",\n-                                          unsafe_t_offsets[0]]);\n+                                     #ifmt[\"function may alias with argument \\\n+                                           %u, which is not immutably rooted\",\n+                                           i]);\n             }\n-          }\n-          _ { }\n+            i += 1u;\n         }\n     }\n     let j = 0u;\n-    for unsafe: ty::t in unsafe_ts {\n-        let offset = unsafe_t_offsets[j];\n-        j += 1u;\n-        let i = 0u;\n-        for arg_t: ty::arg in arg_ts {\n-            let mut_alias = arg_t.mode == ty::mo_alias(true);\n-            if i != offset &&\n-                   ty_can_unsafely_include(cx, unsafe, arg_t.ty, mut_alias) {\n-                cx.tcx.sess.span_err(args[i].span,\n-                                     #ifmt[\"argument %u may alias with \\\n-                     argument %u, which is not immutably rooted\",\n-                                          i, offset]);\n+    for @{unsafe_ty, _} in restricts {\n+        alt unsafe_ty {\n+          some(ty) {\n+            let i = 0u;\n+            for arg_t: ty::arg in arg_ts {\n+                let mut_alias = arg_t.mode == ty::mo_alias(true);\n+                if i != j &&\n+                   ty_can_unsafely_include(cx, ty, arg_t.ty, mut_alias) {\n+                    cx.tcx.sess.span_err(args[i].span,\n+                        #ifmt[\"argument %u may alias with argument %u, \\\n+                               which is not immutably rooted\", i, j]);\n+                }\n+                i += 1u;\n             }\n-            i += 1u;\n+          }\n+          _ {}\n         }\n+        j += 1u;\n     }\n     // Ensure we're not passing a root by mutable alias.\n \n-    for root: {arg: uint, node: node_id} in mut_roots {\n+    for {node, arg} in mut_roots {\n         let mut_alias_to_root = false;\n         let mut_alias_to_root_count = 0u;\n-        for r: node_id in roots {\n-            if root.node == r {\n-                mut_alias_to_root_count += 1u;\n-                if mut_alias_to_root_count > 1u {\n-                    mut_alias_to_root = true;\n-                    break;\n+        for @{root_var, _} in restricts {\n+            alt root_var {\n+              some(root) {\n+                if node == root {\n+                    mut_alias_to_root_count += 1u;\n+                    if mut_alias_to_root_count > 1u {\n+                        mut_alias_to_root = true;\n+                        break;\n+                    }\n                 }\n+              }\n+              none. {}\n             }\n         }\n \n-\n         if mut_alias_to_root {\n-            cx.tcx.sess.span_err(args[root.arg].span,\n-                                 ~\"passing a mutable alias to a \\\n-                 variable that roots another alias\");\n+            cx.tcx.sess.span_err(args[arg].span,\n+                                 ~\"passing a mutable alias to a variable \\\n+                                   that roots another alias\");\n         }\n     }\n-    ret {root_vars: roots, unsafe_ts: unsafe_ts};\n+    ret restricts;\n }\n \n fn check_tail_call(cx: &ctx, call: &@ast::expr) {\n@@ -347,19 +357,16 @@ fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n              v: &vt<scope>) {\n     v.visit_expr(input, sc, v);\n     let root = expr_root(cx, input, true);\n-    let roots =\n-        alt path_def_id(cx, root.ex) { some(did) { [did.node] } _ { [] } };\n-    let forbidden_tp: [ty::t] =\n-        alt inner_mut(root.ds) { some(t) { [t] } _ { [] } };\n     for a: ast::arm in arms {\n         let dnums = ast_util::pat_binding_ids(a.pats[0]);\n         let new_sc = sc;\n         if vec::len(dnums) > 0u {\n-            new_sc = @(*sc + [@{root_vars: roots,\n+            let root_var = path_def_id(cx, root.ex);\n+            new_sc = @(*sc + [@{root_var: root_var,\n                                 local_id: cx.next_local,\n                                 bindings: dnums,\n-                                tys: forbidden_tp,\n-                                depends_on: deps(sc, roots),\n+                                unsafe_ty: inner_mut(root.ds),\n+                                depends_on: deps(sc, root_var),\n                                 mutable ok: valid}]);\n         }\n         register_locals(cx, a.pats[0]);\n@@ -372,17 +379,9 @@ fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n     v.visit_expr(call, sc, v);\n     alt call.node {\n       ast::expr_call(f, args) {\n-        let data = check_call(cx, f, args, sc);\n-        let bindings = ast_util::pat_binding_ids(local.node.pat);\n-        let new_sc =\n-            @{root_vars: data.root_vars,\n-              local_id: cx.next_local,\n-              bindings: bindings,\n-              tys: data.unsafe_ts,\n-              depends_on: deps(sc, data.root_vars),\n-              mutable ok: valid};\n+        let restricts = check_call(cx, f, args, sc);\n         register_locals(cx, local.node.pat);\n-        visit::visit_block(blk, @(*sc + [new_sc]), v);\n+        visit::visit_block(blk, @(*sc + restricts), v);\n       }\n     }\n }\n@@ -391,29 +390,25 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n              sc: &scope, v: &vt<scope>) {\n     v.visit_expr(seq, sc, v);\n     let root = expr_root(cx, seq, false);\n-    let root_def =\n-        alt path_def_id(cx, root.ex) { some(did) { [did.node] } _ { [] } };\n-    let unsafe = alt inner_mut(root.ds) { some(t) { [t] } _ { [] } };\n+    let unsafe = inner_mut(root.ds);\n \n     // If this is a mutable vector, don't allow it to be touched.\n     let seq_t = ty::expr_ty(cx.tcx, seq);\n     alt ty::struct(cx.tcx, seq_t) {\n-      ty::ty_vec(mt) { if mt.mut != ast::imm { unsafe = [seq_t]; } }\n+      ty::ty_vec(mt) { if mt.mut != ast::imm { unsafe = some(seq_t); } }\n       ty::ty_str. | ty::ty_istr. {/* no-op */ }\n       _ {\n-        cx.tcx.sess.span_unimpl(\n-            seq.span,\n-            ~\"unknown seq type \" +\n-            util::ppaux::ty_to_str(cx.tcx, seq_t));\n+        cx.tcx.sess.span_unimpl(seq.span, ~\"unknown seq type \" +\n+                                util::ppaux::ty_to_str(cx.tcx, seq_t));\n       }\n     }\n-    let bindings = ast_util::pat_binding_ids(local.node.pat);\n+    let root_var = path_def_id(cx, root.ex);\n     let new_sc =\n-        @{root_vars: root_def,\n+        @{root_var: root_var,\n           local_id: cx.next_local,\n-          bindings: bindings,\n-          tys: unsafe,\n-          depends_on: deps(sc, root_def),\n+          bindings: ast_util::pat_binding_ids(local.node.pat),\n+          unsafe_ty: unsafe,\n+          depends_on: deps(sc, root_var),\n           mutable ok: valid};\n     register_locals(cx, local.node.pat);\n     visit::visit_block(blk, @(*sc + [new_sc]), v);\n@@ -432,10 +427,13 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n     for r: restrict in *sc {\n         // excludes variables introduced since the alias was made\n         if my_local_id < r.local_id {\n-            for t: ty::t in r.tys {\n-                if ty_can_unsafely_include(cx, t, var_t, assign) {\n+            alt r.unsafe_ty {\n+              some(ty) {\n+                if ty_can_unsafely_include(cx, ty, var_t, assign) {\n                     r.ok = val_taken(ex.span, p);\n                 }\n+              }\n+              _ {}\n             }\n         } else if vec::member(my_defnum, r.bindings) {\n             test_scope(cx, sc, r, p);\n@@ -455,7 +453,7 @@ fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt<scope>) {\n                                  ~\"assigning to immutable obj field\");\n         }\n         for r: restrict in *sc {\n-            if vec::member(dnum, r.root_vars) {\n+            if r.root_var == some(dnum) {\n                 r.ok = overwritten(dest.span, p);\n             }\n         }\n@@ -548,14 +546,17 @@ fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n     }\n }\n \n-fn deps(sc: &scope, roots: &[node_id]) -> [uint] {\n-    let i = 0u;\n+fn deps(sc: &scope, root: &option::t<node_id>) -> [uint] {\n     let result = [];\n-    for r: restrict in *sc {\n-        for dn: node_id in roots {\n+    alt root {\n+      some(dn) {\n+        let i = 0u;\n+        for r: restrict in *sc {\n             if vec::member(dn, r.bindings) { result += [i]; }\n+            i += 1u;\n         }\n-        i += 1u;\n+      }\n+      _ {}\n     }\n     ret result;\n }\n@@ -678,10 +679,10 @@ fn path_def(cx: &ctx, ex: &@ast::expr) -> option::t<ast::def> {\n         }\n }\n \n-fn path_def_id(cx: &ctx, ex: &@ast::expr) -> option::t<ast::def_id> {\n+fn path_def_id(cx: &ctx, ex: &@ast::expr) -> option::t<ast::node_id> {\n     alt ex.node {\n       ast::expr_path(_) {\n-        ret some(ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id)));\n+        ret some(ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id)).node);\n       }\n       _ { ret none; }\n     }"}]}