{"sha": "84f250973079508e52d81be88f45a401958442dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ZjI1MDk3MzA3OTUwOGU1MmQ4MWJlODhmNDVhNDAxOTU4NDQyZGQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-04T20:54:54Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-04T20:54:54Z"}, "message": "Merge #254\n\n254: Defids r=matklad a=matklad\n\nFleshing out DefIds some more\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "be2864c8f1906f096e37e0778fa18524e2ddbe67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be2864c8f1906f096e37e0778fa18524e2ddbe67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84f250973079508e52d81be88f45a401958442dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84f250973079508e52d81be88f45a401958442dd", "html_url": "https://github.com/rust-lang/rust/commit/84f250973079508e52d81be88f45a401958442dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84f250973079508e52d81be88f45a401958442dd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "244f9a142f0593ab5847163d1832e464e2524c4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/244f9a142f0593ab5847163d1832e464e2524c4b", "html_url": "https://github.com/rust-lang/rust/commit/244f9a142f0593ab5847163d1832e464e2524c4b"}, {"sha": "54d053c881514b024ba399ce2edc678e3f710ab7", "url": "https://api.github.com/repos/rust-lang/rust/commits/54d053c881514b024ba399ce2edc678e3f710ab7", "html_url": "https://github.com/rust-lang/rust/commit/54d053c881514b024ba399ce2edc678e3f710ab7"}], "stats": {"total": 346, "additions": 186, "deletions": 160}, "files": [{"sha": "f483ed0455ae1a0f0656ea3fb7082acba218c221", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=84f250973079508e52d81be88f45a401958442dd", "patch": "@@ -163,7 +163,7 @@ fn complete_path(\n     };\n     let target_module = match def_id.resolve(db)? {\n         Def::Module(it) => it,\n-        Def::Item => return Ok(()),\n+        _ => return Ok(()),\n     };\n     let module_scope = target_module.scope(db)?;\n     let completions = module_scope.entries().map(|(name, _res)| CompletionItem {"}, {"sha": "b8d774eb5820d98f8e4487d2c24d40fc3f596f0c", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=84f250973079508e52d81be88f45a401958442dd", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n use salsa::{self, Database};\n use ra_db::{LocationIntener, BaseDatabase};\n-use hir::{self, DefId, DefLoc, FnId, SourceItemId};\n+use hir::{self, DefId, DefLoc};\n \n use crate::{\n     symbol_index,\n@@ -15,7 +15,6 @@ pub(crate) struct RootDatabase {\n \n #[derive(Debug, Default)]\n struct IdMaps {\n-    fns: LocationIntener<SourceItemId, FnId>,\n     defs: LocationIntener<DefLoc, DefId>,\n }\n \n@@ -58,12 +57,6 @@ impl AsRef<LocationIntener<DefLoc, DefId>> for RootDatabase {\n     }\n }\n \n-impl AsRef<LocationIntener<hir::SourceItemId, FnId>> for RootDatabase {\n-    fn as_ref(&self) -> &LocationIntener<hir::SourceItemId, FnId> {\n-        &self.id_maps.fns\n-    }\n-}\n-\n salsa::database_storage! {\n     pub(crate) struct RootDatabaseStorage for RootDatabase {\n         impl ra_db::FilesDatabase {"}, {"sha": "fe1dfefea15626c20ffbb49e619854090857afe5", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=84f250973079508e52d81be88f45a401958442dd", "patch": "@@ -190,10 +190,7 @@ impl AnalysisImpl {\n             Some(it) => it,\n         };\n         let root = descr.crate_root();\n-        let file_id = root\n-            .source()\n-            .as_file()\n-            .expect(\"root module always has a file as a source\");\n+        let file_id = root.source().file_id();\n \n         let crate_graph = self.db.crate_graph();\n         let crate_id = crate_graph.crate_id_for_crate_root(file_id);\n@@ -213,7 +210,7 @@ impl AnalysisImpl {\n         let syntax = file.syntax();\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n             if let Some(fn_descr) =\n-                hir::Function::guess_for_name_ref(&*self.db, position.file_id, name_ref)\n+                hir::Function::guess_for_name_ref(&*self.db, position.file_id, name_ref)?\n             {\n                 let scope = fn_descr.scope(&*self.db);\n                 // First try to resolve the symbol locally\n@@ -260,11 +257,11 @@ impl AnalysisImpl {\n         Ok(vec![])\n     }\n \n-    pub fn find_all_refs(&self, position: FilePosition) -> Vec<(FileId, TextRange)> {\n+    pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {\n         let file = self.db.source_file(position.file_id);\n         // Find the binding associated with the offset\n-        let (binding, descr) = match find_binding(&self.db, &file, position) {\n-            None => return Vec::new(),\n+        let (binding, descr) = match find_binding(&self.db, &file, position)? {\n+            None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n \n@@ -277,25 +274,36 @@ impl AnalysisImpl {\n                 .map(|ref_desc| (position.file_id, ref_desc.range)),\n         );\n \n-        return ret;\n+        return Ok(ret);\n \n         fn find_binding<'a>(\n             db: &db::RootDatabase,\n             source_file: &'a SourceFileNode,\n             position: FilePosition,\n-        ) -> Option<(ast::BindPat<'a>, hir::Function)> {\n+        ) -> Cancelable<Option<(ast::BindPat<'a>, hir::Function)>> {\n             let syntax = source_file.syntax();\n             if let Some(binding) = find_node_at_offset::<ast::BindPat>(syntax, position.offset) {\n-                let descr = hir::Function::guess_for_bind_pat(db, position.file_id, binding)?;\n-                return Some((binding, descr));\n+                let descr = ctry!(hir::Function::guess_for_bind_pat(\n+                    db,\n+                    position.file_id,\n+                    binding\n+                )?);\n+                return Ok(Some((binding, descr)));\n             };\n-            let name_ref = find_node_at_offset::<ast::NameRef>(syntax, position.offset)?;\n-            let descr = hir::Function::guess_for_name_ref(db, position.file_id, name_ref)?;\n+            let name_ref = ctry!(find_node_at_offset::<ast::NameRef>(syntax, position.offset));\n+            let descr = ctry!(hir::Function::guess_for_name_ref(\n+                db,\n+                position.file_id,\n+                name_ref\n+            )?);\n             let scope = descr.scope(db);\n-            let resolved = scope.resolve_local_name(name_ref)?;\n+            let resolved = ctry!(scope.resolve_local_name(name_ref));\n             let resolved = resolved.ptr().resolve(source_file);\n-            let binding = find_node_at_offset::<ast::BindPat>(syntax, resolved.range().end())?;\n-            Some((binding, descr))\n+            let binding = ctry!(find_node_at_offset::<ast::BindPat>(\n+                syntax,\n+                resolved.range().end()\n+            ));\n+            Ok(Some((binding, descr)))\n         }\n     }\n \n@@ -411,7 +419,9 @@ impl AnalysisImpl {\n             if fs.kind == FN_DEF {\n                 let fn_file = self.db.source_file(fn_file_id);\n                 if let Some(fn_def) = find_node_at_offset(fn_file.syntax(), fs.node_range.start()) {\n-                    let descr = hir::Function::guess_from_source(&*self.db, fn_file_id, fn_def);\n+                    let descr = ctry!(hir::Function::guess_from_source(\n+                        &*self.db, fn_file_id, fn_def\n+                    )?);\n                     if let Some(descriptor) = descr.signature_info(&*self.db) {\n                         // If we have a calling expression let's find which argument we are on\n                         let mut current_parameter = None;"}, {"sha": "90528edfdec7a010a30d4be5a0b6ca61ba022d04", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=84f250973079508e52d81be88f45a401958442dd", "patch": "@@ -248,7 +248,7 @@ impl Analysis {\n         self.imp.approximately_resolve_symbol(position)\n     }\n     pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {\n-        Ok(self.imp.find_all_refs(position))\n+        self.imp.find_all_refs(position)\n     }\n     pub fn doc_comment_for(\n         &self,"}, {"sha": "ff41fd326a06426c41b2e309110590c32ad27c1c", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=84f250973079508e52d81be88f45a401958442dd", "patch": "@@ -7,10 +7,11 @@ use ra_syntax::{\n use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, FileId, Cancelable};\n \n use crate::{\n-    DefLoc, DefId, FnId,\n+    DefLoc, DefId,\n     SourceFileItems, SourceItemId,\n     query_definitions,\n     FnScopes,\n+    function::FnId,\n     module::{ModuleId, ModuleTree, ModuleSource,\n     nameres::{ItemMap, InputModuleItems}},\n };\n@@ -19,7 +20,6 @@ salsa::query_group! {\n \n pub trait HirDatabase: SyntaxDatabase\n     + AsRef<LocationIntener<DefLoc, DefId>>\n-    + AsRef<LocationIntener<SourceItemId, FnId>>\n {\n     fn fn_scopes(fn_id: FnId) -> Arc<FnScopes> {\n         type FnScopesQuery;"}, {"sha": "e00bca6e38c3ee36b07c184bf1ce22fcb677bc27", "filename": "crates/ra_hir/src/function/mod.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs?ref=84f250973079508e52d81be88f45a401958442dd", "patch": "@@ -12,58 +12,67 @@ use ra_syntax::{\n use ra_db::FileId;\n \n use crate::{\n-    FnId, HirDatabase, SourceItemId,\n+    Cancelable,\n+    DefLoc, DefKind, DefId, HirDatabase, SourceItemId,\n+    Module,\n };\n \n pub use self::scope::FnScopes;\n \n-impl FnId {\n-    pub fn get(db: &impl HirDatabase, file_id: FileId, fn_def: ast::FnDef) -> FnId {\n-        let file_items = db.file_items(file_id);\n-        let item_id = file_items.id_of(fn_def.syntax());\n-        let item_id = SourceItemId { file_id, item_id };\n-        FnId::from_loc(db, &item_id)\n-    }\n-}\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct FnId(pub(crate) DefId);\n \n pub struct Function {\n     fn_id: FnId,\n }\n \n impl Function {\n+    pub(crate) fn new(def_id: DefId) -> Function {\n+        let fn_id = FnId(def_id);\n+        Function { fn_id }\n+    }\n+\n     pub fn guess_from_source(\n         db: &impl HirDatabase,\n         file_id: FileId,\n         fn_def: ast::FnDef,\n-    ) -> Function {\n-        let fn_id = FnId::get(db, file_id, fn_def);\n-        Function { fn_id }\n+    ) -> Cancelable<Option<Function>> {\n+        let module = ctry!(Module::guess_from_child_node(db, file_id, fn_def.syntax())?);\n+        let file_items = db.file_items(file_id);\n+        let item_id = file_items.id_of(fn_def.syntax());\n+        let source_item_id = SourceItemId { file_id, item_id };\n+        let def_loc = DefLoc {\n+            kind: DefKind::Function,\n+            source_root_id: module.source_root_id,\n+            module_id: module.module_id,\n+            source_item_id,\n+        };\n+        Ok(Some(Function::new(def_loc.id(db))))\n     }\n \n     pub fn guess_for_name_ref(\n         db: &impl HirDatabase,\n         file_id: FileId,\n         name_ref: ast::NameRef,\n-    ) -> Option<Function> {\n+    ) -> Cancelable<Option<Function>> {\n         Function::guess_for_node(db, file_id, name_ref.syntax())\n     }\n \n     pub fn guess_for_bind_pat(\n         db: &impl HirDatabase,\n         file_id: FileId,\n         bind_pat: ast::BindPat,\n-    ) -> Option<Function> {\n+    ) -> Cancelable<Option<Function>> {\n         Function::guess_for_node(db, file_id, bind_pat.syntax())\n     }\n \n     fn guess_for_node(\n         db: &impl HirDatabase,\n         file_id: FileId,\n         node: SyntaxNodeRef,\n-    ) -> Option<Function> {\n-        let fn_def = node.ancestors().find_map(ast::FnDef::cast)?;\n-        let res = Function::guess_from_source(db, file_id, fn_def);\n-        Some(res)\n+    ) -> Cancelable<Option<Function>> {\n+        let fn_def = ctry!(node.ancestors().find_map(ast::FnDef::cast));\n+        Function::guess_from_source(db, file_id, fn_def)\n     }\n \n     pub fn scope(&self, db: &impl HirDatabase) -> Arc<FnScopes> {"}, {"sha": "9168dad3b04f4441b67228654f3f48f1de4f87ca", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=84f250973079508e52d81be88f45a401958442dd", "patch": "@@ -41,63 +41,58 @@ pub use self::{\n \n pub use self::function::FnSignatureInfo;\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct FnId(u32);\n-ra_db::impl_numeric_id!(FnId);\n-\n-impl FnId {\n-    pub fn from_loc(\n-        db: &impl AsRef<LocationIntener<SourceItemId, FnId>>,\n-        loc: &SourceItemId,\n-    ) -> FnId {\n-        db.as_ref().loc2id(loc)\n-    }\n-    pub fn loc(self, db: &impl AsRef<LocationIntener<SourceItemId, FnId>>) -> SourceItemId {\n-        db.as_ref().id2loc(self)\n-    }\n-}\n-\n+/// Def's are a core concept of hir. A `Def` is an Item (function, module, etc)\n+/// in a specific module.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct DefId(u32);\n ra_db::impl_numeric_id!(DefId);\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub(crate) enum DefKind {\n+    Module,\n+    Function,\n+    Item,\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum DefLoc {\n-    Module {\n-        id: ModuleId,\n-        source_root: SourceRootId,\n-    },\n-    Item {\n-        source_item_id: SourceItemId,\n-    },\n+pub struct DefLoc {\n+    pub(crate) kind: DefKind,\n+    source_root_id: SourceRootId,\n+    module_id: ModuleId,\n+    source_item_id: SourceItemId,\n }\n \n impl DefId {\n-    pub fn loc(self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefLoc {\n+    pub(crate) fn loc(self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefLoc {\n         db.as_ref().id2loc(self)\n     }\n }\n \n impl DefLoc {\n-    pub fn id(&self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefId {\n+    pub(crate) fn id(&self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefId {\n         db.as_ref().loc2id(&self)\n     }\n }\n \n pub enum Def {\n     Module(Module),\n+    Function(Function),\n     Item,\n }\n \n impl DefId {\n     pub fn resolve(self, db: &impl HirDatabase) -> Cancelable<Def> {\n         let loc = self.loc(db);\n-        let res = match loc {\n-            DefLoc::Module { id, source_root } => {\n-                let descr = Module::new(db, source_root, id)?;\n-                Def::Module(descr)\n+        let res = match loc.kind {\n+            DefKind::Module => {\n+                let module = Module::new(db, loc.source_root_id, loc.module_id)?;\n+                Def::Module(module)\n             }\n-            DefLoc::Item { .. } => Def::Item,\n+            DefKind::Function => {\n+                let function = Function::new(self);\n+                Def::Function(function)\n+            }\n+            DefKind::Item => Def::Item,\n         };\n         Ok(res)\n     }\n@@ -131,6 +126,10 @@ impl SourceFileItems {\n             .unwrap();\n         id\n     }\n+    pub fn id_of_source_file(&self) -> SourceFileItemId {\n+        let (id, _syntax) = self.arena.iter().next().unwrap();\n+        id\n+    }\n }\n \n impl Index<SourceFileItemId> for SourceFileItems {"}, {"sha": "e855df11d1f77e2dad3ddbcaa05b27f34265c608", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=84f250973079508e52d81be88f45a401958442dd", "patch": "@@ -6,7 +6,7 @@ use ra_db::{LocationIntener, BaseDatabase, FilePosition, mock::FileMap, FileId,\n use relative_path::RelativePathBuf;\n use test_utils::{parse_fixture, CURSOR_MARKER, extract_offset};\n \n-use crate::{db, DefId, DefLoc, FnId, SourceItemId};\n+use crate::{db, DefId, DefLoc};\n \n #[derive(Debug)]\n pub(crate) struct MockDatabase {\n@@ -65,7 +65,6 @@ impl MockDatabase {\n \n #[derive(Debug, Default)]\n struct IdMaps {\n-    fns: LocationIntener<SourceItemId, FnId>,\n     defs: LocationIntener<DefLoc, DefId>,\n }\n \n@@ -117,12 +116,6 @@ impl AsRef<LocationIntener<DefLoc, DefId>> for MockDatabase {\n     }\n }\n \n-impl AsRef<LocationIntener<SourceItemId, FnId>> for MockDatabase {\n-    fn as_ref(&self) -> &LocationIntener<SourceItemId, FnId> {\n-        &self.id_maps.fns\n-    }\n-}\n-\n impl MockDatabase {\n     pub(crate) fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event<MockDatabase>> {\n         *self.events.lock() = Some(Vec::new());"}, {"sha": "0eec38797c5922319a266cbec2e801e5c8fe56bc", "filename": "crates/ra_hir/src/module/imp.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs?ref=84f250973079508e52d81be88f45a401958442dd", "patch": "@@ -66,7 +66,7 @@ fn create_module_tree<'a>(\n \n     let source_root = db.source_root(source_root);\n     for &file_id in source_root.files.iter() {\n-        let source = ModuleSource::SourceFile(file_id);\n+        let source = ModuleSource::new_file(db, file_id);\n         if visited.contains(&source) {\n             continue; // TODO: use explicit crate_roots here\n         }\n@@ -126,7 +126,7 @@ fn build_subtree(\n                             visited,\n                             roots,\n                             Some(link),\n-                            ModuleSource::SourceFile(file_id),\n+                            ModuleSource::new_file(db, file_id),\n                         ),\n                     })\n                     .collect::<Cancelable<Vec<_>>>()?;\n@@ -157,13 +157,8 @@ fn resolve_submodule(\n     name: &SmolStr,\n     file_resolver: &FileResolverImp,\n ) -> (Vec<FileId>, Option<Problem>) {\n-    let file_id = match source {\n-        ModuleSource::SourceFile(it) => it,\n-        ModuleSource::Module(..) => {\n-            // TODO\n-            return (Vec::new(), None);\n-        }\n-    };\n+    // TODO: handle submodules of inline modules properly\n+    let file_id = source.file_id();\n     let mod_name = file_resolver.file_stem(file_id);\n     let is_dir_owner = mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n "}, {"sha": "11e6e8e75a01622db35c8ba5b041239ad04a95bb", "filename": "crates/ra_hir/src/module/mod.rs", "status": "modified", "additions": 62, "deletions": 45, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs?ref=84f250973079508e52d81be88f45a401958442dd", "patch": "@@ -8,13 +8,13 @@ use ra_editor::find_node_at_offset;\n use ra_syntax::{\n     algo::generate,\n     ast::{self, AstNode, NameOwner},\n-    SmolStr, SyntaxNode,\n+    SmolStr, SyntaxNode, SyntaxNodeRef,\n };\n use ra_db::{SourceRootId, FileId, FilePosition, Cancelable};\n use relative_path::RelativePathBuf;\n \n use crate::{\n-    DefLoc, DefId, Path, PathKind, HirDatabase, SourceItemId,\n+    DefKind, DefLoc, DefId, Path, PathKind, HirDatabase, SourceItemId, SourceFileItemId,\n     arena::{Arena, Id},\n };\n \n@@ -25,8 +25,8 @@ pub use self::nameres::ModuleScope;\n #[derive(Debug, Clone)]\n pub struct Module {\n     tree: Arc<ModuleTree>,\n-    source_root_id: SourceRootId,\n-    module_id: ModuleId,\n+    pub(crate) source_root_id: SourceRootId,\n+    pub(crate) module_id: ModuleId,\n }\n \n impl Module {\n@@ -37,7 +37,8 @@ impl Module {\n         db: &impl HirDatabase,\n         file_id: FileId,\n     ) -> Cancelable<Option<Module>> {\n-        Module::guess_from_source(db, file_id, ModuleSource::SourceFile(file_id))\n+        let module_source = ModuleSource::new_file(db, file_id);\n+        Module::guess_from_source(db, module_source)\n     }\n \n     /// Lookup `Module` by position in the source code. Note that this\n@@ -51,17 +52,33 @@ impl Module {\n         let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset)\n         {\n             Some(m) if !m.has_semi() => ModuleSource::new_inline(db, position.file_id, m),\n-            _ => ModuleSource::SourceFile(position.file_id),\n+            _ => ModuleSource::new_file(db, position.file_id),\n         };\n-        Module::guess_from_source(db, position.file_id, module_source)\n+        Module::guess_from_source(db, module_source)\n     }\n \n-    fn guess_from_source(\n+    pub fn guess_from_child_node(\n         db: &impl HirDatabase,\n         file_id: FileId,\n+        node: SyntaxNodeRef,\n+    ) -> Cancelable<Option<Module>> {\n+        let module_source = if let Some(m) = node\n+            .ancestors()\n+            .filter_map(ast::Module::cast)\n+            .find(|it| !it.has_semi())\n+        {\n+            ModuleSource::new_inline(db, file_id, m)\n+        } else {\n+            ModuleSource::new_file(db, file_id)\n+        };\n+        Module::guess_from_source(db, module_source)\n+    }\n+\n+    fn guess_from_source(\n+        db: &impl HirDatabase,\n         module_source: ModuleSource,\n     ) -> Cancelable<Option<Module>> {\n-        let source_root_id = db.file_source_root(file_id);\n+        let source_root_id = db.file_source_root(module_source.file_id());\n         let module_tree = db.module_tree(source_root_id)?;\n \n         let res = match module_tree.any_module_for_source(module_source) {\n@@ -127,9 +144,11 @@ impl Module {\n     }\n \n     pub fn def_id(&self, db: &impl HirDatabase) -> DefId {\n-        let def_loc = DefLoc::Module {\n-            id: self.module_id,\n-            source_root: self.source_root_id,\n+        let def_loc = DefLoc {\n+            kind: DefKind::Module,\n+            source_root_id: self.source_root_id,\n+            module_id: self.module_id,\n+            source_item_id: self.module_id.source(&self.tree).0,\n         };\n         def_loc.id(db)\n     }\n@@ -161,7 +180,12 @@ impl Module {\n         let segments = path.segments;\n         for name in segments.iter() {\n             let module = match curr.loc(db) {\n-                DefLoc::Module { id, source_root } => Module::new(db, source_root, id)?,\n+                DefLoc {\n+                    kind: DefKind::Module,\n+                    source_root_id,\n+                    module_id,\n+                    ..\n+                } => Module::new(db, source_root_id, module_id)?,\n                 _ => return Ok(None),\n             };\n             let scope = module.scope(db)?;\n@@ -209,10 +233,7 @@ impl ModuleTree {\n /// `ModuleSource` is the syntax tree element that produced this module:\n /// either a file, or an inlinde module.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum ModuleSource {\n-    SourceFile(FileId),\n-    Module(SourceItemId),\n-}\n+pub struct ModuleSource(SourceItemId);\n \n /// An owned syntax node for a module. Unlike `ModuleSource`,\n /// this holds onto the AST for the whole file.\n@@ -310,45 +331,41 @@ pub struct ModuleData {\n }\n \n impl ModuleSource {\n+    // precondition: item_id **must** point to module\n+    fn new(file_id: FileId, item_id: SourceFileItemId) -> ModuleSource {\n+        let source_item_id = SourceItemId { file_id, item_id };\n+        ModuleSource(source_item_id)\n+    }\n+\n+    pub(crate) fn new_file(db: &impl HirDatabase, file_id: FileId) -> ModuleSource {\n+        let file_items = db.file_items(file_id);\n+        let item_id = file_items.id_of_source_file();\n+        ModuleSource::new(file_id, item_id)\n+    }\n+\n     pub(crate) fn new_inline(\n         db: &impl HirDatabase,\n         file_id: FileId,\n-        module: ast::Module,\n+        m: ast::Module,\n     ) -> ModuleSource {\n-        assert!(!module.has_semi());\n-        let items = db.file_items(file_id);\n-        let item_id = items.id_of(module.syntax());\n-        let id = SourceItemId { file_id, item_id };\n-        ModuleSource::Module(id)\n-    }\n-\n-    pub fn as_file(self) -> Option<FileId> {\n-        match self {\n-            ModuleSource::SourceFile(f) => Some(f),\n-            ModuleSource::Module(..) => None,\n-        }\n+        assert!(!m.has_semi());\n+        let file_items = db.file_items(file_id);\n+        let item_id = file_items.id_of(m.syntax());\n+        ModuleSource::new(file_id, item_id)\n     }\n \n     pub fn file_id(self) -> FileId {\n-        match self {\n-            ModuleSource::SourceFile(f) => f,\n-            ModuleSource::Module(source_item_id) => source_item_id.file_id,\n-        }\n+        self.0.file_id\n     }\n \n     pub(crate) fn resolve(self, db: &impl HirDatabase) -> ModuleSourceNode {\n-        match self {\n-            ModuleSource::SourceFile(file_id) => {\n-                let syntax = db.source_file(file_id);\n-                ModuleSourceNode::SourceFile(syntax.ast().owned())\n-            }\n-            ModuleSource::Module(item_id) => {\n-                let syntax = db.file_item(item_id);\n-                let syntax = syntax.borrowed();\n-                let module = ast::Module::cast(syntax).unwrap();\n-                ModuleSourceNode::Module(module.owned())\n-            }\n+        let syntax_node = db.file_item(self.0);\n+        let syntax_node = syntax_node.borrowed();\n+        if let Some(file) = ast::SourceFile::cast(syntax_node) {\n+            return ModuleSourceNode::SourceFile(file.owned());\n         }\n+        let module = ast::Module::cast(syntax_node).unwrap();\n+        ModuleSourceNode::Module(module.owned())\n     }\n }\n "}, {"sha": "c2b380a8067ec493340349c1f9fd349b6e543a4e", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=84f250973079508e52d81be88f45a401958442dd", "patch": "@@ -28,7 +28,7 @@ use ra_db::SourceRootId;\n \n use crate::{\n     Cancelable, FileId,\n-    DefId, DefLoc,\n+    DefId, DefLoc, DefKind,\n     SourceItemId, SourceFileItemId, SourceFileItems,\n     Path, PathKind,\n     HirDatabase,\n@@ -247,7 +247,10 @@ where\n                 // handle submodules separatelly\n                 continue;\n             }\n-            let def_loc = DefLoc::Item {\n+            let def_loc = DefLoc {\n+                kind: DefKind::Item,\n+                source_root_id: self.source_root,\n+                module_id,\n                 source_item_id: SourceItemId {\n                     file_id,\n                     item_id: item.id,\n@@ -261,10 +264,12 @@ where\n             module_items.items.insert(item.name.clone(), resolution);\n         }\n \n-        for (name, mod_id) in module_id.children(&self.module_tree) {\n-            let def_loc = DefLoc::Module {\n-                id: mod_id,\n-                source_root: self.source_root,\n+        for (name, module_id) in module_id.children(&self.module_tree) {\n+            let def_loc = DefLoc {\n+                kind: DefKind::Module,\n+                source_root_id: self.source_root,\n+                module_id,\n+                source_item_id: module_id.source(&self.module_tree).0,\n             };\n             let def_id = def_loc.id(self.db);\n             let resolution = Resolution {\n@@ -316,7 +321,11 @@ where\n \n             if !is_last {\n                 curr = match def_id.loc(self.db) {\n-                    DefLoc::Module { id, .. } => id,\n+                    DefLoc {\n+                        kind: DefKind::Module,\n+                        module_id,\n+                        ..\n+                    } => module_id,\n                     _ => return,\n                 }\n             } else {"}, {"sha": "e4d721601df94f67cf6a49a75fb48ea1fc7aed98", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f250973079508e52d81be88f45a401958442dd/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=84f250973079508e52d81be88f45a401958442dd", "patch": "@@ -11,21 +11,21 @@ use ra_syntax::{\n use ra_db::{SourceRootId, FileId, Cancelable,};\n \n use crate::{\n-        FnId,\n-        SourceFileItems, SourceItemId,\n-        db::HirDatabase,\n-        function::FnScopes,\n-        module::{\n-            ModuleSource, ModuleSourceNode, ModuleId,\n-            imp::Submodule,\n-            nameres::{InputModuleItems, ItemMap, Resolver},\n-        },\n+    SourceFileItems, SourceItemId, DefKind,\n+    db::HirDatabase,\n+    function::{FnScopes, FnId},\n+    module::{\n+        ModuleSource, ModuleSourceNode, ModuleId,\n+        imp::Submodule,\n+        nameres::{InputModuleItems, ItemMap, Resolver},\n+    },\n };\n \n /// Resolve `FnId` to the corresponding `SyntaxNode`\n pub(super) fn fn_syntax(db: &impl HirDatabase, fn_id: FnId) -> FnDefNode {\n-    let item_id = fn_id.loc(db);\n-    let syntax = db.file_item(item_id);\n+    let def_loc = fn_id.0.loc(db);\n+    assert!(def_loc.kind == DefKind::Function);\n+    let syntax = db.file_item(def_loc.source_item_id);\n     FnDef::cast(syntax.borrowed()).unwrap().owned()\n }\n \n@@ -36,9 +36,10 @@ pub(super) fn fn_scopes(db: &impl HirDatabase, fn_id: FnId) -> Arc<FnScopes> {\n }\n \n pub(super) fn file_items(db: &impl HirDatabase, file_id: FileId) -> Arc<SourceFileItems> {\n+    let mut res = SourceFileItems::default();\n     let source_file = db.source_file(file_id);\n+    res.alloc(source_file.syntax().owned());\n     let source_file = source_file.borrowed();\n-    let mut res = SourceFileItems::default();\n     source_file\n         .syntax()\n         .descendants()"}]}