{"sha": "395709ca6d39ba1e095e404e1d2a169d918b7f0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NTcwOWNhNmQzOWJhMWUwOTVlNDA0ZTFkMmExNjlkOTE4YjdmMGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-06T00:50:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-11T23:23:34Z"}, "message": "std: Add a `net` module for TCP/UDP\n\nThis commit is an implementation of [RFC 807][rfc] which adds a `std::net`\nmodule for basic neworking based on top of `std::io`. This module serves as a\nreplacement for the `std::old_io::net` module and networking primitives in\n`old_io`.\n\n[rfc]: fillmein\n\nThe major focus of this redesign is to cut back on the level of abstraction to\nthe point that each of the networking types is just a bare socket. To this end\nfunctionality such as timeouts and cloning has been removed (although cloning\ncan be done through `duplicate`, it may just yield an error).\n\nWith this `net` module comes a new implementation of `SocketAddr` and `IpAddr`.\nThis work is entirely based on #20785 and the only changes were to alter the\nin-memory representation to match the `libc`-expected variants and to move from\npublic fields to accessors.", "tree": {"sha": "e6a3d38abb028967c3139ee234d1c69935806800", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6a3d38abb028967c3139ee234d1c69935806800"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/395709ca6d39ba1e095e404e1d2a169d918b7f0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/395709ca6d39ba1e095e404e1d2a169d918b7f0c", "html_url": "https://github.com/rust-lang/rust/commit/395709ca6d39ba1e095e404e1d2a169d918b7f0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/395709ca6d39ba1e095e404e1d2a169d918b7f0c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a954663db66fc8efb1889beaf7bd1771ecbb9b21", "url": "https://api.github.com/repos/rust-lang/rust/commits/a954663db66fc8efb1889beaf7bd1771ecbb9b21", "html_url": "https://github.com/rust-lang/rust/commit/a954663db66fc8efb1889beaf7bd1771ecbb9b21"}], "stats": {"total": 3220, "additions": 3214, "deletions": 6}, "files": [{"sha": "9b7c65bb7199975d7ec5cca69ce2d7fdb2bf0adf", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -250,6 +250,7 @@ pub mod ffi;\n pub mod old_io;\n pub mod io;\n pub mod fs;\n+pub mod net;\n pub mod os;\n pub mod env;\n pub mod path;"}, {"sha": "66d4d34f8eb54a56de61c0f7d14e6ec3ccd75f39", "filename": "src/libstd/net/addr.rs", "status": "added", "additions": 592, "deletions": 0, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -0,0 +1,592 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use fmt;\n+use hash;\n+use io;\n+use libc::{self, socklen_t, sa_family_t};\n+use mem;\n+use net::{IpAddr, lookup_host, ntoh, hton};\n+use option;\n+use sys_common::{FromInner, AsInner, IntoInner};\n+use vec;\n+\n+/// Representation of a socket address for networking applications\n+///\n+/// A socket address consists of at least an (ip, port) pair and may also\n+/// contain other information depending on the protocol.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct SocketAddr {\n+    repr: Repr,\n+}\n+\n+#[derive(Copy)]\n+enum Repr {\n+    V4(libc::sockaddr_in),\n+    V6(libc::sockaddr_in6),\n+}\n+\n+impl SocketAddr {\n+    /// Creates a new socket address from the (ip, port) pair.\n+    pub fn new(ip: IpAddr, port: u16) -> SocketAddr {\n+        let repr = match ip {\n+            IpAddr::V4(ref ip) => {\n+                Repr::V4(libc::sockaddr_in {\n+                    sin_family: libc::AF_INET as sa_family_t,\n+                    sin_port: hton(port),\n+                    sin_addr: *ip.as_inner(),\n+                    .. unsafe { mem::zeroed() }\n+                })\n+            }\n+            IpAddr::V6(ref ip) => {\n+                Repr::V6(libc::sockaddr_in6 {\n+                    sin6_family: libc::AF_INET6 as sa_family_t,\n+                    sin6_port: hton(port),\n+                    sin6_addr: *ip.as_inner(),\n+                    .. unsafe { mem::zeroed() }\n+                })\n+            }\n+        };\n+        SocketAddr { repr: repr }\n+    }\n+\n+    /// Gets the IP address associated with this socket address.\n+    pub fn ip(&self) -> IpAddr {\n+        match self.repr {\n+            Repr::V4(ref sa) => IpAddr::V4(FromInner::from_inner(sa.sin_addr)),\n+            Repr::V6(ref sa) => IpAddr::V6(FromInner::from_inner(sa.sin6_addr)),\n+        }\n+    }\n+\n+    /// Gets the port number associated with this socket address\n+    pub fn port(&self) -> u16 {\n+        match self.repr {\n+            Repr::V4(ref sa) => ntoh(sa.sin_port),\n+            Repr::V6(ref sa) => ntoh(sa.sin6_port),\n+        }\n+    }\n+\n+    fn set_port(&mut self, port: u16) {\n+        match self.repr {\n+            Repr::V4(ref mut sa) => sa.sin_port = hton(port),\n+            Repr::V6(ref mut sa) => sa.sin6_port = hton(port),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for SocketAddr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.repr {\n+            Repr::V4(_) => write!(f, \"{}:{}\", self.ip(), self.port()),\n+            Repr::V6(_) => write!(f, \"[{}]:{}\", self.ip(), self.port()),\n+        }\n+    }\n+}\n+\n+impl FromInner<libc::sockaddr_in> for SocketAddr {\n+    fn from_inner(addr: libc::sockaddr_in) -> SocketAddr {\n+        SocketAddr { repr: Repr::V4(addr) }\n+    }\n+}\n+\n+impl FromInner<libc::sockaddr_in6> for SocketAddr {\n+    fn from_inner(addr: libc::sockaddr_in6) -> SocketAddr {\n+        SocketAddr { repr: Repr::V6(addr) }\n+    }\n+}\n+\n+impl<'a> IntoInner<(*const libc::sockaddr, socklen_t)> for &'a SocketAddr {\n+    fn into_inner(self) -> (*const libc::sockaddr, socklen_t) {\n+        match self.repr {\n+            Repr::V4(ref a) => {\n+                (a as *const _ as *const _, mem::size_of_val(a) as socklen_t)\n+            }\n+            Repr::V6(ref a) => {\n+                (a as *const _ as *const _, mem::size_of_val(a) as socklen_t)\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+impl Clone for Repr {\n+    fn clone(&self) -> Repr { *self }\n+}\n+\n+impl PartialEq for Repr {\n+    fn eq(&self, other: &Repr) -> bool {\n+        match (*self, *other) {\n+            (Repr::V4(ref a), Repr::V4(ref b)) => {\n+                a.sin_port == b.sin_port &&\n+                    a.sin_addr.s_addr == b.sin_addr.s_addr\n+            }\n+            (Repr::V6(ref a), Repr::V6(ref b)) => {\n+                a.sin6_port == b.sin6_port &&\n+                    a.sin6_addr.s6_addr == b.sin6_addr.s6_addr &&\n+                    a.sin6_flowinfo == b.sin6_flowinfo &&\n+                    a.sin6_scope_id == b.sin6_scope_id\n+            }\n+            _ => false,\n+        }\n+    }\n+}\n+impl Eq for Repr {}\n+\n+impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Repr {\n+    fn hash(&self, s: &mut S) {\n+        match *self {\n+            Repr::V4(ref a) => {\n+                (a.sin_family, a.sin_port, a.sin_addr.s_addr).hash(s)\n+            }\n+            Repr::V6(ref a) => {\n+                (a.sin6_family, a.sin6_port, &a.sin6_addr.s6_addr,\n+                 a.sin6_flowinfo, a.sin6_scope_id).hash(s)\n+            }\n+        }\n+    }\n+}\n+\n+/// A trait for objects which can be converted or resolved to one or more\n+/// `SocketAddr` values.\n+///\n+/// This trait is used for generic address resolution when constructing network\n+/// objects.  By default it is implemented for the following types:\n+///\n+///  * `SocketAddr` - `to_socket_addrs` is identity function.\n+///\n+///  * `(IpAddr, u16)` - `to_socket_addrs` constructs `SocketAddr` trivially.\n+///\n+///  * `(&str, u16)` - the string should be either a string representation of an\n+///    IP address expected by `FromStr` implementation for `IpAddr` or a host\n+///    name.\n+///\n+///  * `&str` - the string should be either a string representation of a\n+///    `SocketAddr` as expected by its `FromStr` implementation or a string like\n+///    `<host_name>:<port>` pair where `<port>` is a `u16` value.\n+///\n+/// This trait allows constructing network objects like `TcpStream` or\n+/// `UdpSocket` easily with values of various types for the bind/connection\n+/// address. It is needed because sometimes one type is more appropriate than\n+/// the other: for simple uses a string like `\"localhost:12345\"` is much nicer\n+/// than manual construction of the corresponding `SocketAddr`, but sometimes\n+/// `SocketAddr` value is *the* main source of the address, and converting it to\n+/// some other type (e.g. a string) just for it to be converted back to\n+/// `SocketAddr` in constructor methods is pointless.\n+///\n+/// Some examples:\n+///\n+/// ```no_run\n+/// use std::net::{IpAddr, SocketAddr, TcpStream, UdpSocket, TcpListener};\n+///\n+/// fn main() {\n+///     let ip = IpAddr::new_v4(127, 0, 0, 1);\n+///     let port = 12345;\n+///\n+///     // The following lines are equivalent modulo possible \"localhost\" name\n+///     // resolution differences\n+///     let tcp_s = TcpStream::connect(&SocketAddr::new(ip, port));\n+///     let tcp_s = TcpStream::connect(&(ip, port));\n+///     let tcp_s = TcpStream::connect(&(\"127.0.0.1\", port));\n+///     let tcp_s = TcpStream::connect(&(\"localhost\", port));\n+///     let tcp_s = TcpStream::connect(\"127.0.0.1:12345\");\n+///     let tcp_s = TcpStream::connect(\"localhost:12345\");\n+///\n+///     // TcpListener::bind(), UdpSocket::bind() and UdpSocket::send_to()\n+///     // behave similarly\n+///     let tcp_l = TcpListener::bind(\"localhost:12345\");\n+///\n+///     let mut udp_s = UdpSocket::bind(&(\"127.0.0.1\", port)).unwrap();\n+///     udp_s.send_to(&[7], &(ip, 23451));\n+/// }\n+/// ```\n+pub trait ToSocketAddrs {\n+    /// Returned iterator over socket addresses which this type may correspond\n+    /// to.\n+    type Iter: Iterator<Item=SocketAddr>;\n+\n+    /// Converts this object to an iterator of resolved `SocketAddr`s.\n+    ///\n+    /// The returned iterator may not actually yield any values depending on the\n+    /// outcome of any resolution performed.\n+    ///\n+    /// Note that this function may block the current thread while resolution is\n+    /// performed.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Any errors encountered during resolution will be returned as an `Err`.\n+    fn to_socket_addrs(&self) -> io::Result<Self::Iter>;\n+}\n+\n+impl ToSocketAddrs for SocketAddr {\n+    type Iter = option::IntoIter<SocketAddr>;\n+    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n+        Ok(Some(*self).into_iter())\n+    }\n+}\n+\n+impl ToSocketAddrs for (IpAddr, u16) {\n+    type Iter = option::IntoIter<SocketAddr>;\n+    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n+        let (ip, port) = *self;\n+        Ok(Some(SocketAddr::new(ip, port)).into_iter())\n+    }\n+}\n+\n+fn resolve_socket_addr(s: &str, p: u16) -> io::Result<vec::IntoIter<SocketAddr>> {\n+    let ips = try!(lookup_host(s));\n+    let v: Vec<_> = try!(ips.map(|a| {\n+        a.map(|mut a| { a.set_port(p); a })\n+    }).collect());\n+    Ok(v.into_iter())\n+}\n+\n+impl<'a> ToSocketAddrs for (&'a str, u16) {\n+    type Iter = vec::IntoIter<SocketAddr>;\n+    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n+        let (host, port) = *self;\n+\n+        // try to parse the host as a regular IpAddr first\n+        match host.parse().ok() {\n+            Some(addr) => return Ok(vec![SocketAddr::new(addr, port)].into_iter()),\n+            None => {}\n+        }\n+\n+        resolve_socket_addr(host, port)\n+    }\n+}\n+\n+// accepts strings like 'localhost:12345'\n+impl ToSocketAddrs for str {\n+    type Iter = vec::IntoIter<SocketAddr>;\n+    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n+        // try to parse as a regular SocketAddr first\n+        match self.parse().ok() {\n+            Some(addr) => return Ok(vec![addr].into_iter()),\n+            None => {}\n+        }\n+\n+        macro_rules! try_opt {\n+            ($e:expr, $msg:expr) => (\n+                match $e {\n+                    Some(r) => r,\n+                    None => return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                                      $msg, None)),\n+                }\n+            )\n+        }\n+\n+        // split the string by ':' and convert the second part to u16\n+        let mut parts_iter = self.rsplitn(2, ':');\n+        let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n+        let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n+        let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n+        resolve_socket_addr(host, port)\n+    }\n+}\n+\n+impl<'a, T: ToSocketAddrs + ?Sized> ToSocketAddrs for &'a T {\n+    type Iter = T::Iter;\n+    fn to_socket_addrs(&self) -> io::Result<T::Iter> {\n+        (**self).to_socket_addrs()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use io;\n+    use net::*;\n+    use net::Ipv6MulticastScope::*;\n+\n+    #[test]\n+    fn test_from_str_ipv4() {\n+        assert_eq!(Ok(Ipv4Addr::new(127, 0, 0, 1)), \"127.0.0.1\".parse());\n+        assert_eq!(Ok(Ipv4Addr::new(255, 255, 255, 255)), \"255.255.255.255\".parse());\n+        assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n+\n+        // out of range\n+        let none: Option<IpAddr> = \"256.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+        // too short\n+        let none: Option<IpAddr> = \"255.0.0\".parse().ok();\n+        assert_eq!(None, none);\n+        // too long\n+        let none: Option<IpAddr> = \"255.0.0.1.2\".parse().ok();\n+        assert_eq!(None, none);\n+        // no number between dots\n+        let none: Option<IpAddr> = \"255.0..1\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_ipv6() {\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n+\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n+\n+        assert_eq!(Ok(Ipv6Addr::new(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n+                \"2a02:6b8::11:11\".parse());\n+\n+        // too long group\n+        let none: Option<IpAddr> = \"::00000\".parse().ok();\n+        assert_eq!(None, none);\n+        // too short\n+        let none: Option<IpAddr> = \"1:2:3:4:5:6:7\".parse().ok();\n+        assert_eq!(None, none);\n+        // too long\n+        let none: Option<IpAddr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n+        assert_eq!(None, none);\n+        // triple colon\n+        let none: Option<IpAddr> = \"1:2:::6:7:8\".parse().ok();\n+        assert_eq!(None, none);\n+        // two double colons\n+        let none: Option<IpAddr> = \"1:2::6::8\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_ipv4_in_ipv6() {\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 545)),\n+                \"::192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n+                \"::FFFF:192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n+                \"64:ff9b::192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr::new(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n+                \"2001:db8:122:c000:2:2100:192.0.2.33\".parse());\n+\n+        // colon after v4\n+        let none: Option<IpAddr> = \"::127.0.0.1:\".parse().ok();\n+        assert_eq!(None, none);\n+        // not enough groups\n+        let none: Option<IpAddr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+        // too many groups\n+        let none: Option<IpAddr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_socket_addr() {\n+        assert_eq!(Ok(SocketAddr::new(IpAddr::new_v4(77, 88, 21, 11), 80)),\n+                \"77.88.21.11:80\".parse());\n+        assert_eq!(Ok(SocketAddr::new(IpAddr::new_v6(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n+                \"[2a02:6b8:0:1::1]:53\".parse());\n+        assert_eq!(Ok(SocketAddr::new(IpAddr::new_v6(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)),\n+                \"[::127.0.0.1]:22\".parse());\n+\n+        // without port\n+        let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n+        assert_eq!(None, none);\n+        // without port\n+        let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n+        assert_eq!(None, none);\n+        // wrong brackets around v4\n+        let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n+        assert_eq!(None, none);\n+        // port out of range\n+        let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n+        assert_eq!(None, none);\n+    }\n+\n+    #[test]\n+    fn ipv6_addr_to_string() {\n+        // ipv4-mapped address\n+        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n+        assert_eq!(a1.to_string(), \"::ffff:192.0.2.128\");\n+\n+        // ipv4-compatible address\n+        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280);\n+        assert_eq!(a1.to_string(), \"::192.0.2.128\");\n+\n+        // v6 address with no zero segments\n+        assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(),\n+                   \"8:9:a:b:c:d:e:f\");\n+\n+        // reduce a single run of zeros\n+        assert_eq!(\"ae::ffff:102:304\",\n+                   Ipv6Addr::new(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304).to_string());\n+\n+        // don't reduce just a single zero segment\n+        assert_eq!(\"1:2:3:4:5:6:0:8\",\n+                   Ipv6Addr::new(1, 2, 3, 4, 5, 6, 0, 8).to_string());\n+\n+        // 'any' address\n+        assert_eq!(\"::\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+        // loopback address\n+        assert_eq!(\"::1\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_string());\n+\n+        // ends in zeros\n+        assert_eq!(\"1::\", Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+        // two runs of zeros, second one is longer\n+        assert_eq!(\"1:0:0:4::8\", Ipv6Addr::new(1, 0, 0, 4, 0, 0, 0, 8).to_string());\n+\n+        // two runs of zeros, equal length\n+        assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n+    }\n+\n+    #[test]\n+    fn ipv4_to_ipv6() {\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678),\n+                   Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_mapped());\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678),\n+                   Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_compatible());\n+    }\n+\n+    #[test]\n+    fn ipv6_to_ipv4() {\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4(),\n+                   Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78)));\n+        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n+                   Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78)));\n+        assert_eq!(Ipv6Addr::new(0, 0, 1, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n+                   None);\n+    }\n+\n+    #[test]\n+    fn ipv4_properties() {\n+        fn check(octets: &[u8; 4], unspec: bool, loopback: bool,\n+                 private: bool, link_local: bool, global: bool,\n+                 multicast: bool) {\n+            let ip = Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3]);\n+            assert_eq!(octets, &ip.octets());\n+\n+            assert_eq!(ip.is_unspecified(), unspec);\n+            assert_eq!(ip.is_loopback(), loopback);\n+            assert_eq!(ip.is_private(), private);\n+            assert_eq!(ip.is_link_local(), link_local);\n+            assert_eq!(ip.is_global(), global);\n+            assert_eq!(ip.is_multicast(), multicast);\n+        }\n+\n+        //    address                unspec loopbk privt  linloc global multicast\n+        check(&[0, 0, 0, 0],         true,  false, false, false, true,  false);\n+        check(&[0, 0, 0, 1],         false, false, false, false, true,  false);\n+        check(&[1, 0, 0, 0],         false, false, false, false, true,  false);\n+        check(&[10, 9, 8, 7],        false, false, true,  false, false, false);\n+        check(&[127, 1, 2, 3],       false, true,  false, false, false, false);\n+        check(&[172, 31, 254, 253],  false, false, true,  false, false,  false);\n+        check(&[169, 254, 253, 242], false, false, false, true,  false, false);\n+        check(&[192, 168, 254, 253], false, false, true,  false, false, false);\n+        check(&[224, 0, 0, 0],       false, false, false, false, true,  true);\n+        check(&[239, 255, 255, 255], false, false, false, false, true,  true);\n+        check(&[255, 255, 255, 255], false, false, false, false, true,  false);\n+    }\n+\n+    #[test]\n+    fn ipv6_properties() {\n+        fn check(str_addr: &str, unspec: bool, loopback: bool,\n+                 unique_local: bool, global: bool,\n+                 u_link_local: bool, u_site_local: bool, u_global: bool,\n+                 m_scope: Option<Ipv6MulticastScope>) {\n+            let ip: Ipv6Addr = str_addr.parse().ok().unwrap();\n+            assert_eq!(str_addr, ip.to_string());\n+\n+            assert_eq!(ip.is_unspecified(), unspec);\n+            assert_eq!(ip.is_loopback(), loopback);\n+            assert_eq!(ip.is_unique_local(), unique_local);\n+            assert_eq!(ip.is_global(), global);\n+            assert_eq!(ip.is_unicast_link_local(), u_link_local);\n+            assert_eq!(ip.is_unicast_site_local(), u_site_local);\n+            assert_eq!(ip.is_unicast_global(), u_global);\n+            assert_eq!(ip.multicast_scope(), m_scope);\n+            assert_eq!(ip.is_multicast(), m_scope.is_some());\n+        }\n+\n+        //    unspec loopbk uniqlo global unill  unisl  uniglo mscope\n+        check(\"::\",\n+              true,  false, false, true,  false, false, true,  None);\n+        check(\"::1\",\n+              false, true,  false, false, false, false, false, None);\n+        check(\"::0.0.0.2\",\n+              false, false, false, true,  false, false, true,  None);\n+        check(\"1::\",\n+              false, false, false, true,  false, false, true,  None);\n+        check(\"fc00::\",\n+              false, false, true,  false, false, false, false, None);\n+        check(\"fdff:ffff::\",\n+              false, false, true,  false, false, false, false, None);\n+        check(\"fe80:ffff::\",\n+              false, false, false, false, true,  false, false, None);\n+        check(\"febf:ffff::\",\n+              false, false, false, false, true,  false, false, None);\n+        check(\"fec0::\",\n+              false, false, false, false, false, true,  false, None);\n+        check(\"ff01::\",\n+              false, false, false, false, false, false, false, Some(InterfaceLocal));\n+        check(\"ff02::\",\n+              false, false, false, false, false, false, false, Some(LinkLocal));\n+        check(\"ff03::\",\n+              false, false, false, false, false, false, false, Some(RealmLocal));\n+        check(\"ff04::\",\n+              false, false, false, false, false, false, false, Some(AdminLocal));\n+        check(\"ff05::\",\n+              false, false, false, false, false, false, false, Some(SiteLocal));\n+        check(\"ff08::\",\n+              false, false, false, false, false, false, false, Some(OrganizationLocal));\n+        check(\"ff0e::\",\n+              false, false, false, true,  false, false, false, Some(Global));\n+    }\n+\n+    fn tsa<A: ToSocketAddrs>(a: A) -> io::Result<Vec<SocketAddr>> {\n+        Ok(try!(a.to_socket_addrs()).collect())\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_socketaddr() {\n+        let a = SocketAddr::new(IpAddr::new_v4(77, 88, 21, 11), 12345);\n+        assert_eq!(Ok(vec![a]), tsa(a));\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_ipaddr_u16() {\n+        let a = IpAddr::new_v4(77, 88, 21, 11);\n+        let p = 12345u16;\n+        let e = SocketAddr::new(a, p);\n+        assert_eq!(Ok(vec![e]), tsa((a, p)));\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_str_u16() {\n+        let a = SocketAddr::new(IpAddr::new_v4(77, 88, 21, 11), 24352);\n+        assert_eq!(Ok(vec![a]), tsa((\"77.88.21.11\", 24352u16)));\n+\n+        let a = SocketAddr::new(IpAddr::new_v6(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n+        assert_eq!(Ok(vec![a]), tsa((\"2a02:6b8:0:1::1\", 53)));\n+\n+        let a = SocketAddr::new(IpAddr::new_v4(127, 0, 0, 1), 23924);\n+        assert!(tsa((\"localhost\", 23924u16)).unwrap().contains(&a));\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_str() {\n+        let a = SocketAddr::new(IpAddr::new_v4(77, 88, 21, 11), 24352);\n+        assert_eq!(Ok(vec![a]), tsa(\"77.88.21.11:24352\"));\n+\n+        let a = SocketAddr::new(IpAddr::new_v6(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n+        assert_eq!(Ok(vec![a]), tsa(\"[2a02:6b8:0:1::1]:53\"));\n+\n+        let a = SocketAddr::new(IpAddr::new_v4(127, 0, 0, 1), 23924);\n+        assert!(tsa(\"localhost:23924\").unwrap().contains(&a));\n+    }\n+}"}, {"sha": "08f7a6e2e963663421229951fce8a63d80724db4", "filename": "src/libstd/net/ip.rs", "status": "added", "additions": 449, "deletions": 0, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -0,0 +1,449 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use cmp::Ordering;\n+use hash;\n+use fmt;\n+use libc;\n+use sys_common::{AsInner, FromInner};\n+use net::{hton, ntoh};\n+\n+/// Representation of an IPv4 address.\n+#[derive(Copy)]\n+pub struct Ipv4Addr {\n+    inner: libc::in_addr,\n+}\n+\n+/// Representation of an IPv6 address.\n+#[derive(Copy)]\n+pub struct Ipv6Addr {\n+    inner: libc::in6_addr,\n+}\n+\n+#[allow(missing_docs)]\n+#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n+pub enum Ipv6MulticastScope {\n+    InterfaceLocal,\n+    LinkLocal,\n+    RealmLocal,\n+    AdminLocal,\n+    SiteLocal,\n+    OrganizationLocal,\n+    Global\n+}\n+\n+/// Enumeration of possible IP addresses\n+#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n+pub enum IpAddr {\n+    /// An IPv4 address.\n+    V4(Ipv4Addr),\n+    /// An IPv6 address.\n+    V6(Ipv6Addr)\n+}\n+\n+impl IpAddr {\n+    /// Create a new IpAddr that contains an IPv4 address.\n+    ///\n+    /// The result will represent the IP address a.b.c.d\n+    pub fn new_v4(a: u8, b: u8, c: u8, d: u8) -> IpAddr {\n+        IpAddr::V4(Ipv4Addr::new(a, b, c, d))\n+    }\n+\n+    /// Create a new IpAddr that contains an IPv6 address.\n+    ///\n+    /// The result will represent the IP address a:b:c:d:e:f\n+    pub fn new_v6(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,\n+                  h: u16) -> IpAddr {\n+        IpAddr::V6(Ipv6Addr::new(a, b, c, d, e, f, g, h))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for IpAddr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            IpAddr::V4(v4) => v4.fmt(f),\n+            IpAddr::V6(v6) => v6.fmt(f)\n+        }\n+    }\n+}\n+\n+impl Ipv4Addr {\n+    /// Create a new IPv4 address from four eight-bit octets.\n+    ///\n+    /// The result will represent the IP address a.b.c.d\n+    pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n+        Ipv4Addr {\n+            inner: libc::in_addr {\n+                s_addr: hton(((a as u32) << 24) |\n+                             ((b as u32) << 16) |\n+                             ((c as u32) <<  8) |\n+                              (d as u32)),\n+            }\n+        }\n+    }\n+\n+    /// Returns the four eight-bit integers that make up this address\n+    pub fn octets(&self) -> [u8; 4] {\n+        let bits = ntoh(self.inner.s_addr);\n+        [(bits >> 24) as u8, (bits >> 16) as u8, (bits >> 8) as u8, bits as u8]\n+    }\n+\n+    /// Returns true for the special 'unspecified' address 0.0.0.0\n+    pub fn is_unspecified(&self) -> bool {\n+        self.inner.s_addr == 0\n+    }\n+\n+    /// Returns true if this is a loopback address (127.0.0.0/8)\n+    pub fn is_loopback(&self) -> bool {\n+        self.octets()[0] == 127\n+    }\n+\n+    /// Returns true if this is a private address.\n+    ///\n+    /// The private address ranges are defined in RFC1918 and include:\n+    ///\n+    ///  - 10.0.0.0/8\n+    ///  - 172.16.0.0/12\n+    ///  - 192.168.0.0/16\n+    pub fn is_private(&self) -> bool {\n+        match (self.octets()[0], self.octets()[1]) {\n+            (10, _) => true,\n+            (172, b) if b >= 16 && b <= 31 => true,\n+            (192, 168) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Returns true if the address is link-local (169.254.0.0/16)\n+    pub fn is_link_local(&self) -> bool {\n+        self.octets()[0] == 169 && self.octets()[1] == 254\n+    }\n+\n+    /// Returns true if the address appears to be globally routable.\n+    ///\n+    /// Non-globally-routable networks include the private networks (10.0.0.0/8,\n+    /// 172.16.0.0/12 and 192.168.0.0/16), the loopback network (127.0.0.0/8),\n+    /// and the link-local network (169.254.0.0/16).\n+    pub fn is_global(&self) -> bool {\n+        !self.is_private() && !self.is_loopback() && !self.is_link_local()\n+    }\n+\n+    /// Returns true if this is a multicast address.\n+    ///\n+    /// Multicast addresses have a most significant octet between 224 and 239.\n+    pub fn is_multicast(&self) -> bool {\n+        self.octets()[0] >= 224 && self.octets()[0] <= 239\n+    }\n+\n+    /// Convert this address to an IPv4-compatible IPv6 address\n+    ///\n+    /// a.b.c.d becomes ::a.b.c.d\n+    pub fn to_ipv6_compatible(&self) -> Ipv6Addr {\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0,\n+                      ((self.octets()[0] as u16) << 8) | self.octets()[1] as u16,\n+                      ((self.octets()[2] as u16) << 8) | self.octets()[3] as u16)\n+    }\n+\n+    /// Convert this address to an IPv4-mapped IPv6 address\n+    ///\n+    /// a.b.c.d becomes ::ffff:a.b.c.d\n+    pub fn to_ipv6_mapped(&self) -> Ipv6Addr {\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff,\n+                      ((self.octets()[0] as u16) << 8) | self.octets()[1] as u16,\n+                      ((self.octets()[2] as u16) << 8) | self.octets()[3] as u16)\n+    }\n+\n+}\n+\n+impl fmt::Display for Ipv4Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let octets = self.octets();\n+        write!(fmt, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3])\n+    }\n+}\n+\n+impl fmt::Debug for Ipv4Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+impl Clone for Ipv4Addr {\n+    fn clone(&self) -> Ipv4Addr { *self }\n+}\n+\n+impl PartialEq for Ipv4Addr {\n+    fn eq(&self, other: &Ipv4Addr) -> bool {\n+        self.inner.s_addr == other.inner.s_addr\n+    }\n+}\n+impl Eq for Ipv4Addr {}\n+\n+impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Ipv4Addr {\n+    fn hash(&self, s: &mut S) {\n+        self.inner.s_addr.hash(s)\n+    }\n+}\n+\n+impl PartialOrd for Ipv4Addr {\n+    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Ipv4Addr {\n+    fn cmp(&self, other: &Ipv4Addr) -> Ordering {\n+        self.inner.s_addr.cmp(&other.inner.s_addr)\n+    }\n+}\n+\n+impl AsInner<libc::in_addr> for Ipv4Addr {\n+    fn as_inner(&self) -> &libc::in_addr { &self.inner }\n+}\n+impl FromInner<libc::in_addr> for Ipv4Addr {\n+    fn from_inner(addr: libc::in_addr) -> Ipv4Addr {\n+        Ipv4Addr { inner: addr }\n+    }\n+}\n+\n+impl Ipv6Addr {\n+    /// Create a new IPv6 address from eight 16-bit segments.\n+    ///\n+    /// The result will represent the IP address a:b:c:d:e:f\n+    pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,\n+               h: u16) -> Ipv6Addr {\n+        Ipv6Addr {\n+            inner: libc::in6_addr {\n+                s6_addr: [hton(a), hton(b), hton(c), hton(d),\n+                          hton(e), hton(f), hton(g), hton(h)]\n+            }\n+        }\n+    }\n+\n+    /// Return the eight 16-bit segments that make up this address\n+    pub fn segments(&self) -> [u16; 8] {\n+        [ntoh(self.inner.s6_addr[0]),\n+         ntoh(self.inner.s6_addr[1]),\n+         ntoh(self.inner.s6_addr[2]),\n+         ntoh(self.inner.s6_addr[3]),\n+         ntoh(self.inner.s6_addr[4]),\n+         ntoh(self.inner.s6_addr[5]),\n+         ntoh(self.inner.s6_addr[6]),\n+         ntoh(self.inner.s6_addr[7])]\n+    }\n+\n+    /// Returns true for the special 'unspecified' address ::\n+    pub fn is_unspecified(&self) -> bool {\n+        self.segments() == [0, 0, 0, 0, 0, 0, 0, 0]\n+    }\n+\n+    /// Returns true if this is a loopback address (::1)\n+    pub fn is_loopback(&self) -> bool {\n+        self.segments() == [0, 0, 0, 0, 0, 0, 0, 1]\n+    }\n+\n+    /// Returns true if the address appears to be globally routable.\n+    ///\n+    /// Non-globally-routable networks include the loopback address; the\n+    /// link-local, site-local, and unique local unicast addresses; and the\n+    /// interface-, link-, realm-, admin- and site-local multicast addresses.\n+    pub fn is_global(&self) -> bool {\n+        match self.multicast_scope() {\n+            Some(Ipv6MulticastScope::Global) => true,\n+            None => self.is_unicast_global(),\n+            _ => false\n+        }\n+    }\n+\n+    /// Returns true if this is a unique local address (IPv6)\n+    ///\n+    /// Unique local addresses are defined in RFC4193 and have the form fc00::/7\n+    pub fn is_unique_local(&self) -> bool {\n+        (self.segments()[0] & 0xfe00) == 0xfc00\n+    }\n+\n+    /// Returns true if the address is unicast and link-local (fe80::/10)\n+    pub fn is_unicast_link_local(&self) -> bool {\n+        (self.segments()[0] & 0xffc0) == 0xfe80\n+    }\n+\n+    /// Returns true if this is a deprecated unicast site-local address (IPv6\n+    /// fec0::/10)\n+    pub fn is_unicast_site_local(&self) -> bool {\n+        (self.segments()[0] & 0xffc0) == 0xfec0\n+    }\n+\n+    /// Returns true if the address is a globally routable unicast address\n+    ///\n+    /// Non-globally-routable unicast addresses include the loopback address,\n+    /// the link-local addresses, the deprecated site-local addresses and the\n+    /// unique local addresses.\n+    pub fn is_unicast_global(&self) -> bool {\n+        !self.is_multicast()\n+            && !self.is_loopback() && !self.is_unicast_link_local()\n+            && !self.is_unicast_site_local() && !self.is_unique_local()\n+    }\n+\n+    /// Returns the address's multicast scope if the address is multicast.\n+    pub fn multicast_scope(&self) -> Option<Ipv6MulticastScope> {\n+        if self.is_multicast() {\n+            match self.segments()[0] & 0x000f {\n+                1 => Some(Ipv6MulticastScope::InterfaceLocal),\n+                2 => Some(Ipv6MulticastScope::LinkLocal),\n+                3 => Some(Ipv6MulticastScope::RealmLocal),\n+                4 => Some(Ipv6MulticastScope::AdminLocal),\n+                5 => Some(Ipv6MulticastScope::SiteLocal),\n+                8 => Some(Ipv6MulticastScope::OrganizationLocal),\n+                14 => Some(Ipv6MulticastScope::Global),\n+                _ => None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns true if this is a multicast address.\n+    ///\n+    /// Multicast addresses have the form ff00::/8.\n+    pub fn is_multicast(&self) -> bool {\n+        (self.segments()[0] & 0xff00) == 0xff00\n+    }\n+\n+    /// Convert this address to an IPv4 address. Returns None if this address is\n+    /// neither IPv4-compatible or IPv4-mapped.\n+    ///\n+    /// ::a.b.c.d and ::ffff:a.b.c.d become a.b.c.d\n+    pub fn to_ipv4(&self) -> Option<Ipv4Addr> {\n+        match self.segments() {\n+            [0, 0, 0, 0, 0, f, g, h] if f == 0 || f == 0xffff => {\n+                Some(Ipv4Addr::new((g >> 8) as u8, g as u8,\n+                                   (h >> 8) as u8, h as u8))\n+            },\n+            _ => None\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Ipv6Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match self.segments() {\n+            // We need special cases for :: and ::1, otherwise they're formatted\n+            // as ::0.0.0.[01]\n+            [0, 0, 0, 0, 0, 0, 0, 0] => write!(fmt, \"::\"),\n+            [0, 0, 0, 0, 0, 0, 0, 1] => write!(fmt, \"::1\"),\n+            // Ipv4 Compatible address\n+            [0, 0, 0, 0, 0, 0, g, h] => {\n+                write!(fmt, \"::{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n+                       (h >> 8) as u8, h as u8)\n+            }\n+            // Ipv4-Mapped address\n+            [0, 0, 0, 0, 0, 0xffff, g, h] => {\n+                write!(fmt, \"::ffff:{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n+                       (h >> 8) as u8, h as u8)\n+            },\n+            _ => {\n+                fn find_zero_slice(segments: &[u16; 8]) -> (usize, usize) {\n+                    let mut longest_span_len = 0;\n+                    let mut longest_span_at = 0;\n+                    let mut cur_span_len = 0;\n+                    let mut cur_span_at = 0;\n+\n+                    for i in range(0, 8) {\n+                        if segments[i] == 0 {\n+                            if cur_span_len == 0 {\n+                                cur_span_at = i;\n+                            }\n+\n+                            cur_span_len += 1;\n+\n+                            if cur_span_len > longest_span_len {\n+                                longest_span_len = cur_span_len;\n+                                longest_span_at = cur_span_at;\n+                            }\n+                        } else {\n+                            cur_span_len = 0;\n+                            cur_span_at = 0;\n+                        }\n+                    }\n+\n+                    (longest_span_at, longest_span_len)\n+                }\n+\n+                let (zeros_at, zeros_len) = find_zero_slice(&self.segments());\n+\n+                if zeros_len > 1 {\n+                    fn fmt_subslice(segments: &[u16]) -> String {\n+                        segments\n+                            .iter()\n+                            .map(|&seg| format!(\"{:x}\", seg))\n+                            .collect::<Vec<String>>()\n+                            .as_slice()\n+                            .connect(\":\")\n+                    }\n+\n+                    write!(fmt, \"{}::{}\",\n+                           fmt_subslice(&self.segments()[..zeros_at]),\n+                           fmt_subslice(&self.segments()[zeros_at + zeros_len..]))\n+                } else {\n+                    let &[a, b, c, d, e, f, g, h] = &self.segments();\n+                    write!(fmt, \"{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}\",\n+                           a, b, c, d, e, f, g, h)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Ipv6Addr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+impl Clone for Ipv6Addr {\n+    fn clone(&self) -> Ipv6Addr { *self }\n+}\n+\n+impl PartialEq for Ipv6Addr {\n+    fn eq(&self, other: &Ipv6Addr) -> bool {\n+        self.inner.s6_addr == other.inner.s6_addr\n+    }\n+}\n+impl Eq for Ipv6Addr {}\n+\n+impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Ipv6Addr {\n+    fn hash(&self, s: &mut S) {\n+        self.inner.s6_addr.hash(s)\n+    }\n+}\n+\n+impl PartialOrd for Ipv6Addr {\n+    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Ipv6Addr {\n+    fn cmp(&self, other: &Ipv6Addr) -> Ordering {\n+        self.inner.s6_addr.cmp(&other.inner.s6_addr)\n+    }\n+}\n+\n+impl AsInner<libc::in6_addr> for Ipv6Addr {\n+    fn as_inner(&self) -> &libc::in6_addr { &self.inner }\n+}\n+impl FromInner<libc::in6_addr> for Ipv6Addr {\n+    fn from_inner(addr: libc::in6_addr) -> Ipv6Addr {\n+        Ipv6Addr { inner: addr }\n+    }\n+}"}, {"sha": "d73c06a2549e10970294d356aa07754ac8f73658", "filename": "src/libstd/net/mod.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Networking primitives for TCP/UDP communication\n+//!\n+//! > **NOTE**: This module is very much a work in progress and is under active\n+//! > development. At this time it is still recommended to use the `old_io`\n+//! > module while the details of this module shake out.\n+\n+#![unstable(feature = \"net\")]\n+\n+use prelude::v1::*;\n+\n+use io::{self, Error, ErrorKind};\n+use num::Int;\n+use sys_common::net2 as net_imp;\n+\n+pub use self::ip::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n+pub use self::addr::{SocketAddr, ToSocketAddrs};\n+pub use self::tcp::{TcpStream, TcpListener};\n+pub use self::udp::UdpSocket;\n+\n+mod ip;\n+mod addr;\n+mod tcp;\n+mod udp;\n+mod parser;\n+#[cfg(test)] mod test;\n+\n+/// Possible values which can be passed to the `shutdown` method of `TcpStream`\n+/// and `UdpSocket`.\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum Shutdown {\n+    /// Indicates that the reading portion of this stream/socket should be shut\n+    /// down. All currently blocked and future reads will return `Ok(0)`.\n+    Read,\n+    /// Indicates that the writing portion of this stream/socket should be shut\n+    /// down. All currently blocked and future writes will return an error.\n+    Write,\n+    /// Shut down both the reading and writing portions of this stream.\n+    ///\n+    /// See `Shutdown::Read` and `Shutdown::Write` for more information.\n+    Both\n+}\n+\n+fn hton<I: Int>(i: I) -> I { i.to_be() }\n+fn ntoh<I: Int>(i: I) -> I { Int::from_be(i) }\n+\n+fn each_addr<A: ToSocketAddrs + ?Sized, F, T>(addr: &A, mut f: F) -> io::Result<T>\n+    where F: FnMut(&SocketAddr) -> io::Result<T>\n+{\n+    let mut last_err = None;\n+    for addr in try!(addr.to_socket_addrs()) {\n+        match f(&addr) {\n+            Ok(l) => return Ok(l),\n+            Err(e) => last_err = Some(e),\n+        }\n+    }\n+    Err(last_err.unwrap_or_else(|| {\n+        Error::new(ErrorKind::InvalidInput,\n+                   \"could not resolve to any addresses\", None)\n+    }))\n+}\n+\n+/// An iterator over `SocketAddr` values returned from a host lookup operation.\n+pub struct LookupHost(net_imp::LookupHost);\n+\n+impl Iterator for LookupHost {\n+    type Item = io::Result<SocketAddr>;\n+    fn next(&mut self) -> Option<io::Result<SocketAddr>> { self.0.next() }\n+}\n+\n+/// Resolve the host specified by `host` as a number of `SocketAddr` instances.\n+///\n+/// This method may perform a DNS query to resolve `host` and may also inspect\n+/// system configuration to resolve the specified hostname.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// use std::net;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// for host in try!(net::lookup_host(\"rust-lang.org\")) {\n+///     println!(\"found address: {}\", try!(host));\n+/// }\n+/// # Ok(())\n+/// # }\n+/// ```\n+pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n+    net_imp::lookup_host(host).map(LookupHost)\n+}"}, {"sha": "e82dc88cddd7b7036989232092f2e781f43a4617", "filename": "src/libstd/net/parser.rs", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -0,0 +1,330 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A private parser implementation of IPv4, IPv6, and socket addresses.\n+//!\n+//! This module is \"publicly exported\" through the `FromStr` implementations\n+//! below.\n+\n+use prelude::v1::*;\n+\n+use str::FromStr;\n+use net::{Ipv4Addr, Ipv6Addr, IpAddr, SocketAddr};\n+\n+struct Parser<'a> {\n+    // parsing as ASCII, so can use byte array\n+    s: &'a [u8],\n+    pos: usize,\n+}\n+\n+impl<'a> Parser<'a> {\n+    fn new(s: &'a str) -> Parser<'a> {\n+        Parser {\n+            s: s.as_bytes(),\n+            pos: 0,\n+        }\n+    }\n+\n+    fn is_eof(&self) -> bool {\n+        self.pos == self.s.len()\n+    }\n+\n+    // Commit only if parser returns Some\n+    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T> where\n+        F: FnOnce(&mut Parser) -> Option<T>,\n+    {\n+        let pos = self.pos;\n+        let r = cb(self);\n+        if r.is_none() {\n+            self.pos = pos;\n+        }\n+        r\n+    }\n+\n+    // Commit only if parser read till EOF\n+    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T> where\n+        F: FnOnce(&mut Parser) -> Option<T>,\n+    {\n+        self.read_atomically(move |p| {\n+            match cb(p) {\n+                Some(x) => if p.is_eof() {Some(x)} else {None},\n+                None => None,\n+            }\n+        })\n+    }\n+\n+    // Return result of first successful parser\n+    fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T>>])\n+               -> Option<T> {\n+        for pf in parsers.iter_mut() {\n+            match self.read_atomically(|p: &mut Parser| pf(p)) {\n+                Some(r) => return Some(r),\n+                None => {}\n+            }\n+        }\n+        None\n+    }\n+\n+    // Apply 3 parsers sequentially\n+    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self,\n+                                       pa: PA,\n+                                       pb: PB,\n+                                       pc: PC)\n+                                       -> Option<(A, B, C)> where\n+        PA: FnOnce(&mut Parser) -> Option<A>,\n+        PB: FnOnce(&mut Parser) -> Option<B>,\n+        PC: FnOnce(&mut Parser) -> Option<C>,\n+    {\n+        self.read_atomically(move |p| {\n+            let a = pa(p);\n+            let b = if a.is_some() { pb(p) } else { None };\n+            let c = if b.is_some() { pc(p) } else { None };\n+            match (a, b, c) {\n+                (Some(a), Some(b), Some(c)) => Some((a, b, c)),\n+                _ => None\n+            }\n+        })\n+    }\n+\n+    // Read next char\n+    fn read_char(&mut self) -> Option<char> {\n+        if self.is_eof() {\n+            None\n+        } else {\n+            let r = self.s[self.pos] as char;\n+            self.pos += 1;\n+            Some(r)\n+        }\n+    }\n+\n+    // Return char and advance iff next char is equal to requested\n+    fn read_given_char(&mut self, c: char) -> Option<char> {\n+        self.read_atomically(|p| {\n+            match p.read_char() {\n+                Some(next) if next == c => Some(next),\n+                _ => None,\n+            }\n+        })\n+    }\n+\n+    // Read digit\n+    fn read_digit(&mut self, radix: u8) -> Option<u8> {\n+        fn parse_digit(c: char, radix: u8) -> Option<u8> {\n+            let c = c as u8;\n+            // assuming radix is either 10 or 16\n+            if c >= b'0' && c <= b'9' {\n+                Some(c - b'0')\n+            } else if radix > 10 && c >= b'a' && c < b'a' + (radix - 10) {\n+                Some(c - b'a' + 10)\n+            } else if radix > 10 && c >= b'A' && c < b'A' + (radix - 10) {\n+                Some(c - b'A' + 10)\n+            } else {\n+                None\n+            }\n+        }\n+\n+        self.read_atomically(|p| {\n+            p.read_char().and_then(|c| parse_digit(c, radix))\n+        })\n+    }\n+\n+    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n+        let mut r = 0u32;\n+        let mut digit_count = 0;\n+        loop {\n+            match self.read_digit(radix) {\n+                Some(d) => {\n+                    r = r * (radix as u32) + (d as u32);\n+                    digit_count += 1;\n+                    if digit_count > max_digits || r >= upto {\n+                        return None\n+                    }\n+                }\n+                None => {\n+                    if digit_count == 0 {\n+                        return None\n+                    } else {\n+                        return Some(r)\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n+    // Read number, failing if max_digits of number value exceeded\n+    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n+        self.read_atomically(|p| p.read_number_impl(radix, max_digits, upto))\n+    }\n+\n+    fn read_ipv4_addr_impl(&mut self) -> Option<Ipv4Addr> {\n+        let mut bs = [0u8; 4];\n+        let mut i = 0;\n+        while i < 4 {\n+            if i != 0 && self.read_given_char('.').is_none() {\n+                return None;\n+            }\n+\n+            let octet = self.read_number(10, 3, 0x100).map(|n| n as u8);\n+            match octet {\n+                Some(d) => bs[i] = d,\n+                None => return None,\n+            };\n+            i += 1;\n+        }\n+        Some(Ipv4Addr::new(bs[0], bs[1], bs[2], bs[3]))\n+    }\n+\n+    // Read IPv4 address\n+    fn read_ipv4_addr(&mut self) -> Option<Ipv4Addr> {\n+        self.read_atomically(|p| p.read_ipv4_addr_impl())\n+    }\n+\n+    fn read_ipv6_addr_impl(&mut self) -> Option<Ipv6Addr> {\n+        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> Ipv6Addr {\n+            assert!(head.len() + tail.len() <= 8);\n+            let mut gs = [0u16; 8];\n+            gs.clone_from_slice(head);\n+            gs[(8 - tail.len()) .. 8].clone_from_slice(tail);\n+            Ipv6Addr::new(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n+        }\n+\n+        fn read_groups(p: &mut Parser, groups: &mut [u16; 8], limit: usize)\n+                       -> (usize, bool) {\n+            let mut i = 0;\n+            while i < limit {\n+                if i < limit - 1 {\n+                    let ipv4 = p.read_atomically(|p| {\n+                        if i == 0 || p.read_given_char(':').is_some() {\n+                            p.read_ipv4_addr()\n+                        } else {\n+                            None\n+                        }\n+                    });\n+                    if let Some(v4_addr) = ipv4 {\n+                        let octets = v4_addr.octets();\n+                        groups[i + 0] = ((octets[0] as u16) << 8) | (octets[1] as u16);\n+                        groups[i + 1] = ((octets[2] as u16) << 8) | (octets[3] as u16);\n+                        return (i + 2, true);\n+                    }\n+                }\n+\n+                let group = p.read_atomically(|p| {\n+                    if i == 0 || p.read_given_char(':').is_some() {\n+                        p.read_number(16, 4, 0x10000).map(|n| n as u16)\n+                    } else {\n+                        None\n+                    }\n+                });\n+                match group {\n+                    Some(g) => groups[i] = g,\n+                    None => return (i, false)\n+                }\n+                i += 1;\n+            }\n+            (i, false)\n+        }\n+\n+        let mut head = [0u16; 8];\n+        let (head_size, head_ipv4) = read_groups(self, &mut head, 8);\n+\n+        if head_size == 8 {\n+            return Some(Ipv6Addr::new(\n+                head[0], head[1], head[2], head[3],\n+                head[4], head[5], head[6], head[7]))\n+        }\n+\n+        // IPv4 part is not allowed before `::`\n+        if head_ipv4 {\n+            return None\n+        }\n+\n+        // read `::` if previous code parsed less than 8 groups\n+        if !self.read_given_char(':').is_some() || !self.read_given_char(':').is_some() {\n+            return None;\n+        }\n+\n+        let mut tail = [0u16; 8];\n+        let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n+        Some(ipv6_addr_from_head_tail(&head[..head_size], &tail[..tail_size]))\n+    }\n+\n+    fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> {\n+        self.read_atomically(|p| p.read_ipv6_addr_impl())\n+    }\n+\n+    fn read_ip_addr(&mut self) -> Option<IpAddr> {\n+        let ipv4_addr = |p: &mut Parser| p.read_ipv4_addr().map(|v4| IpAddr::V4(v4));\n+        let ipv6_addr = |p: &mut Parser| p.read_ipv6_addr().map(|v6| IpAddr::V6(v6));\n+        self.read_or(&mut [Box::new(ipv4_addr), Box::new(ipv6_addr)])\n+    }\n+\n+    fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n+        let ip_addr = |p: &mut Parser| {\n+            let ipv4_p = |p: &mut Parser| p.read_ip_addr();\n+            let ipv6_p = |p: &mut Parser| {\n+                let open_br = |p: &mut Parser| p.read_given_char('[');\n+                let ip_addr = |p: &mut Parser| p.read_ipv6_addr();\n+                let clos_br = |p: &mut Parser| p.read_given_char(']');\n+                p.read_seq_3::<char, Ipv6Addr, char, _, _, _>(open_br, ip_addr, clos_br)\n+                        .map(|t| match t { (_, ip, _) => IpAddr::V6(ip) })\n+            };\n+            p.read_or(&mut [Box::new(ipv4_p), Box::new(ipv6_p)])\n+        };\n+        let colon = |p: &mut Parser| p.read_given_char(':');\n+        let port  = |p: &mut Parser| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n+\n+        // host, colon, port\n+        self.read_seq_3::<IpAddr, char, u16, _, _, _>(ip_addr, colon, port)\n+                .map(|t| match t { (ip, _, port) => SocketAddr::new(ip, port) })\n+    }\n+}\n+\n+impl FromStr for IpAddr {\n+    type Err = ParseError;\n+    fn from_str(s: &str) -> Result<IpAddr, ParseError> {\n+        match Parser::new(s).read_till_eof(|p| p.read_ip_addr()) {\n+            Some(s) => Ok(s),\n+            None => Err(ParseError),\n+        }\n+    }\n+}\n+\n+impl FromStr for Ipv4Addr {\n+    type Err = ParseError;\n+    fn from_str(s: &str) -> Result<Ipv4Addr, ParseError> {\n+        match Parser::new(s).read_till_eof(|p| p.read_ipv4_addr()) {\n+            Some(s) => Ok(s),\n+            None => Err(ParseError)\n+        }\n+    }\n+}\n+\n+impl FromStr for Ipv6Addr {\n+    type Err = ParseError;\n+    fn from_str(s: &str) -> Result<Ipv6Addr, ParseError> {\n+        match Parser::new(s).read_till_eof(|p| p.read_ipv6_addr()) {\n+            Some(s) => Ok(s),\n+            None => Err(ParseError)\n+        }\n+    }\n+}\n+\n+impl FromStr for SocketAddr {\n+    type Err = ParseError;\n+    fn from_str(s: &str) -> Result<SocketAddr, ParseError> {\n+        match Parser::new(s).read_till_eof(|p| p.read_socket_addr()) {\n+            Some(s) => Ok(s),\n+            None => Err(ParseError),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Copy)]\n+pub struct ParseError;"}, {"sha": "50eafdfc5c2389677aa0cd6cb6c5dcf39fc4b98d", "filename": "src/libstd/net/tcp.rs", "status": "added", "additions": 792, "deletions": 0, "changes": 792, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -0,0 +1,792 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+use io::prelude::*;\n+\n+use io;\n+use net::{ToSocketAddrs, SocketAddr, Shutdown};\n+use sys_common::net2 as net_imp;\n+use sys_common::AsInner;\n+\n+/// A structure which represents a TCP stream between a local socket and a\n+/// remote socket.\n+///\n+/// The socket will be closed when the value is dropped.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::net::TcpStream;\n+///\n+/// {\n+///     let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n+///\n+///     // ignore the Result\n+///     let _ = stream.write(&[1]);\n+///     let _ = stream.read(&mut [0; 128]); // ignore here too\n+/// } // the stream is closed here\n+/// ```\n+pub struct TcpStream(net_imp::TcpStream);\n+\n+/// A structure representing a socket server.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::net::{TcpListener, TcpStream};\n+/// use std::thread::Thread;\n+///\n+/// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+///\n+/// fn handle_client(stream: TcpStream) {\n+///     // ...\n+/// }\n+///\n+/// // accept connections and process them, spawning a new thread for each one\n+/// for stream in listener.incoming() {\n+///     match stream {\n+///         Ok(stream) => {\n+///             Thread::spawn(move|| {\n+///                 // connection succeeded\n+///                 handle_client(stream)\n+///             });\n+///         }\n+///         Err(e) => { /* connection failed */ }\n+///     }\n+/// }\n+///\n+/// // close the socket server\n+/// drop(listener);\n+/// ```\n+pub struct TcpListener(net_imp::TcpListener);\n+\n+/// An infinite iterator over the connections from a `TcpListener`.\n+///\n+/// This iterator will infinitely yield `Some` of the accepted connections. It\n+/// is equivalent to calling `accept` in a loop.\n+pub struct Incoming<'a> { listener: &'a TcpListener }\n+\n+impl TcpStream {\n+    /// Open a TCP connection to a remote host.\n+    ///\n+    /// `addr` is an address of the remote host. Anything which implements\n+    /// `ToSocketAddrs` trait can be supplied for the address; see this trait\n+    /// documentation for concrete examples.\n+    pub fn connect<A: ToSocketAddrs + ?Sized>(addr: &A) -> io::Result<TcpStream> {\n+        super::each_addr(addr, net_imp::TcpStream::connect).map(TcpStream)\n+    }\n+\n+    /// Returns the socket address of the remote peer of this TCP connection.\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.peer_addr()\n+    }\n+\n+    /// Returns the socket address of the local half of this TCP connection.\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.socket_addr()\n+    }\n+\n+    /// Shut down the read, write, or both halves of this connection.\n+    ///\n+    /// This function will cause all pending and future I/O on the specified\n+    /// portions to return immediately with an appropriate value (see the\n+    /// documentation of `Shutdown`).\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        self.0.shutdown(how)\n+    }\n+\n+    /// Create a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `TcpStream` is a reference to the same stream that this\n+    /// object references. Both handles will read and write the same stream of\n+    /// data, and options set on one stream will be propagated to the other\n+    /// stream.\n+    pub fn try_clone(&self) -> io::Result<TcpStream> {\n+        self.0.duplicate().map(TcpStream)\n+    }\n+\n+    /// Sets the nodelay flag on this connection to the boolean specified\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        self.0.set_nodelay(nodelay)\n+    }\n+\n+    /// Sets the keepalive timeout to the timeout specified.\n+    ///\n+    /// If the value specified is `None`, then the keepalive flag is cleared on\n+    /// this connection. Otherwise, the keepalive timeout will be set to the\n+    /// specified time, in seconds.\n+    pub fn set_keepalive(&self, seconds: Option<u32>) -> io::Result<()> {\n+        self.0.set_keepalive(seconds)\n+    }\n+}\n+\n+impl Read for TcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+}\n+impl Write for TcpStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+impl<'a> Read for &'a TcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+}\n+impl<'a> Write for &'a TcpStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n+impl AsInner<net_imp::TcpStream> for TcpStream {\n+    fn as_inner(&self) -> &net_imp::TcpStream { &self.0 }\n+}\n+\n+impl TcpListener {\n+    /// Creates a new `TcpListener` which will be bound to the specified\n+    /// address.\n+    ///\n+    /// The returned listener is ready for accepting connections.\n+    ///\n+    /// Binding with a port number of 0 will request that the OS assigns a port\n+    /// to this listener. The port allocated can be queried via the\n+    /// `socket_addr` function.\n+    ///\n+    /// The address type can be any implementer of `ToSocketAddrs` trait. See\n+    /// its documentation for concrete examples.\n+    pub fn bind<A: ToSocketAddrs + ?Sized>(addr: &A) -> io::Result<TcpListener> {\n+        super::each_addr(addr, net_imp::TcpListener::bind).map(TcpListener)\n+    }\n+\n+    /// Returns the local socket address of this listener.\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.socket_addr()\n+    }\n+\n+    /// Create a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `TcpListener` is a reference to the same socket that this\n+    /// object references. Both handles can be used to accept incoming\n+    /// connections and options set on one listener will affect the other.\n+    pub fn try_clone(&self) -> io::Result<TcpListener> {\n+        self.0.duplicate().map(TcpListener)\n+    }\n+\n+    /// Accept a new incoming connection from this listener.\n+    ///\n+    /// This function will block the calling thread until a new TCP connection\n+    /// is established. When established, the corresponding `TcpStream` and the\n+    /// remote peer's address will be returned.\n+    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+        self.0.accept().map(|(a, b)| (TcpStream(a), b))\n+    }\n+\n+    /// Returns an iterator over the connections being received on this\n+    /// listener.\n+    ///\n+    /// The returned iterator will never returned `None` and will also not yield\n+    /// the peer's `SocketAddr` structure.\n+    pub fn incoming(&self) -> Incoming {\n+        Incoming { listener: self }\n+    }\n+}\n+\n+impl<'a> Iterator for Incoming<'a> {\n+    type Item = io::Result<TcpStream>;\n+    fn next(&mut self) -> Option<io::Result<TcpStream>> {\n+        Some(self.listener.accept().map(|p| p.0))\n+    }\n+}\n+\n+impl AsInner<net_imp::TcpListener> for TcpListener {\n+    fn as_inner(&self) -> &net_imp::TcpListener { &self.0 }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+\n+    use io::ErrorKind;\n+    use io::prelude::*;\n+    use net::*;\n+    use net::test::{next_test_ip4, next_test_ip6};\n+    use sync::mpsc::channel;\n+    use thread::Thread;\n+\n+    fn each_ip(f: &mut FnMut(SocketAddr)) {\n+        f(next_test_ip4());\n+        f(next_test_ip6());\n+    }\n+\n+    macro_rules! t {\n+        ($e:expr) => {\n+            match $e {\n+                Ok(t) => t,\n+                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n+            }\n+        }\n+    }\n+\n+    // FIXME #11530 this fails on android because tests are run as root\n+    #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n+    #[test]\n+    fn bind_error() {\n+        match TcpListener::bind(\"0.0.0.0:1\") {\n+            Ok(..) => panic!(),\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::PermissionDenied),\n+        }\n+    }\n+\n+    #[test]\n+    fn connect_error() {\n+        match TcpStream::connect(\"0.0.0.0:1\") {\n+            Ok(..) => panic!(),\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::ConnectionRefused),\n+        }\n+    }\n+\n+    #[test]\n+    fn listen_localhost() {\n+        let socket_addr = next_test_ip4();\n+        let listener = t!(TcpListener::bind(&socket_addr));\n+\n+        let _t = Thread::scoped(move || {\n+            let mut stream = t!(TcpStream::connect(&(\"localhost\",\n+                                                     socket_addr.port())));\n+            t!(stream.write(&[144]));\n+        });\n+\n+        let mut stream = t!(listener.accept()).0;\n+        let mut buf = [0];\n+        t!(stream.read(&mut buf));\n+        assert!(buf[0] == 144);\n+    }\n+\n+    #[test]\n+    fn connect_ip4_loopback() {\n+        let addr = next_test_ip4();\n+        let acceptor = t!(TcpListener::bind(&addr));\n+\n+        let _t = Thread::scoped(move|| {\n+            let mut stream = t!(TcpStream::connect(&(\"127.0.0.1\", addr.port())));\n+            t!(stream.write(&[44]));\n+        });\n+\n+        let mut stream = t!(acceptor.accept()).0;\n+        let mut buf = [0];\n+        t!(stream.read(&mut buf));\n+        assert!(buf[0] == 44);\n+    }\n+\n+    #[test]\n+    fn connect_ip6_loopback() {\n+        let addr = next_test_ip6();\n+        let acceptor = t!(TcpListener::bind(&addr));\n+\n+        let _t = Thread::scoped(move|| {\n+            let mut stream = t!(TcpStream::connect(&(\"::1\", addr.port())));\n+            t!(stream.write(&[66]));\n+        });\n+\n+        let mut stream = t!(acceptor.accept()).0;\n+        let mut buf = [0];\n+        t!(stream.read(&mut buf));\n+        assert!(buf[0] == 66);\n+    }\n+\n+    #[test]\n+    fn smoke_test_ip6() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let (tx, rx) = channel();\n+            let _t = Thread::scoped(move|| {\n+                let mut stream = t!(TcpStream::connect(&addr));\n+                t!(stream.write(&[99]));\n+                tx.send(t!(stream.socket_addr())).unwrap();\n+            });\n+\n+            let (mut stream, addr) = t!(acceptor.accept());\n+            let mut buf = [0];\n+            t!(stream.read(&mut buf));\n+            assert!(buf[0] == 99);\n+            assert_eq!(addr, t!(rx.recv()));\n+        })\n+    }\n+\n+    #[test]\n+    fn read_eof_ip4() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                let _stream = t!(TcpStream::connect(&addr));\n+                // Close\n+            });\n+\n+            let mut stream = t!(acceptor.accept()).0;\n+            let mut buf = [0];\n+            let nread = t!(stream.read(&mut buf));\n+            assert_eq!(nread, 0);\n+            let nread = t!(stream.read(&mut buf));\n+            assert_eq!(nread, 0);\n+        })\n+    }\n+\n+    #[test]\n+    fn write_close() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let (tx, rx) = channel();\n+            let _t = Thread::scoped(move|| {\n+                drop(t!(TcpStream::connect(&addr)));\n+                tx.send(()).unwrap();\n+            });\n+\n+            let mut stream = t!(acceptor.accept()).0;\n+            rx.recv().unwrap();\n+            let buf = [0];\n+            match stream.write(&buf) {\n+                Ok(..) => {}\n+                Err(e) => {\n+                    assert!(e.kind() == ErrorKind::ConnectionReset ||\n+                            e.kind() == ErrorKind::BrokenPipe ||\n+                            e.kind() == ErrorKind::ConnectionAborted,\n+                            \"unknown error: {}\", e);\n+                }\n+            }\n+        })\n+    }\n+\n+    #[test]\n+    fn multiple_connect_serial_ip4() {\n+        each_ip(&mut |addr| {\n+            let max = 10;\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                for _ in 0..max {\n+                    let mut stream = t!(TcpStream::connect(&addr));\n+                    t!(stream.write(&[99]));\n+                }\n+            });\n+\n+            for stream in acceptor.incoming().take(max) {\n+                let mut stream = t!(stream);\n+                let mut buf = [0];\n+                t!(stream.read(&mut buf));\n+                assert_eq!(buf[0], 99);\n+            }\n+        })\n+    }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_greedy_schedule() {\n+        static MAX: usize = 10;\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                let acceptor = acceptor;\n+                for (i, stream) in acceptor.incoming().enumerate().take(MAX) {\n+                    // Start another task to handle the connection\n+                    let _t = Thread::scoped(move|| {\n+                        let mut stream = t!(stream);\n+                        let mut buf = [0];\n+                        t!(stream.read(&mut buf));\n+                        assert!(buf[0] == i as u8);\n+                    });\n+                }\n+            });\n+\n+            connect(0, addr);\n+        });\n+\n+        fn connect(i: usize, addr: SocketAddr) {\n+            if i == MAX { return }\n+\n+            let t = Thread::scoped(move|| {\n+                let mut stream = t!(TcpStream::connect(&addr));\n+                // Connect again before writing\n+                connect(i + 1, addr);\n+                t!(stream.write(&[i as u8]));\n+            });\n+            t.join().ok().unwrap();\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_lazy_schedule_ip4() {\n+        static MAX: usize = 10;\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                for stream in acceptor.incoming().take(MAX) {\n+                    // Start another task to handle the connection\n+                    let _t = Thread::scoped(move|| {\n+                        let mut stream = t!(stream);\n+                        let mut buf = [0];\n+                        t!(stream.read(&mut buf));\n+                        assert!(buf[0] == 99);\n+                    });\n+                }\n+            });\n+\n+            connect(0, addr);\n+        });\n+\n+        fn connect(i: usize, addr: SocketAddr) {\n+            if i == MAX { return }\n+\n+            let t = Thread::scoped(move|| {\n+                let mut stream = t!(TcpStream::connect(&addr));\n+                connect(i + 1, addr);\n+                t!(stream.write(&[99]));\n+            });\n+            t.join().ok().unwrap();\n+        }\n+    }\n+\n+    pub fn socket_name(addr: SocketAddr) {\n+    }\n+\n+    pub fn peer_name(addr: SocketAddr) {\n+    }\n+\n+    #[test]\n+    fn socket_and_peer_name_ip4() {\n+        each_ip(&mut |addr| {\n+            let listener = t!(TcpListener::bind(&addr));\n+            let so_name = t!(listener.socket_addr());\n+            assert_eq!(addr, so_name);\n+            let _t = Thread::scoped(move|| {\n+                t!(listener.accept());\n+            });\n+\n+            let stream = t!(TcpStream::connect(&addr));\n+            assert_eq!(addr, t!(stream.peer_addr()));\n+        })\n+    }\n+\n+    #[test]\n+    fn partial_read() {\n+        each_ip(&mut |addr| {\n+            let (tx, rx) = channel();\n+            let srv = t!(TcpListener::bind(&addr));\n+            let _t = Thread::scoped(move|| {\n+                let mut cl = t!(srv.accept()).0;\n+                cl.write(&[10]).unwrap();\n+                let mut b = [0];\n+                t!(cl.read(&mut b));\n+                tx.send(()).unwrap();\n+            });\n+\n+            let mut c = t!(TcpStream::connect(&addr));\n+            let mut b = [0; 10];\n+            assert_eq!(c.read(&mut b), Ok(1));\n+            t!(c.write(&[1]));\n+            rx.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn double_bind() {\n+        each_ip(&mut |addr| {\n+            let _listener = t!(TcpListener::bind(&addr));\n+            match TcpListener::bind(&addr) {\n+                Ok(..) => panic!(),\n+                Err(e) => {\n+                    assert!(e.kind() == ErrorKind::ConnectionRefused ||\n+                            e.kind() == ErrorKind::Other,\n+                            \"unknown error: {} {:?}\", e, e.kind());\n+                }\n+            }\n+        })\n+    }\n+\n+    #[test]\n+    fn fast_rebind() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                t!(TcpStream::connect(&addr));\n+            });\n+\n+            t!(acceptor.accept());\n+            drop(acceptor);\n+            t!(TcpListener::bind(&addr));\n+        });\n+    }\n+\n+    #[test]\n+    fn tcp_clone_smoke() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                let mut s = t!(TcpStream::connect(&addr));\n+                let mut buf = [0, 0];\n+                assert_eq!(s.read(&mut buf), Ok(1));\n+                assert_eq!(buf[0], 1);\n+                t!(s.write(&[2]));\n+            });\n+\n+            let mut s1 = t!(acceptor.accept()).0;\n+            let s2 = t!(s1.try_clone());\n+\n+            let (tx1, rx1) = channel();\n+            let (tx2, rx2) = channel();\n+            let _t = Thread::scoped(move|| {\n+                let mut s2 = s2;\n+                rx1.recv().unwrap();\n+                t!(s2.write(&[1]));\n+                tx2.send(()).unwrap();\n+            });\n+            tx1.send(()).unwrap();\n+            let mut buf = [0, 0];\n+            assert_eq!(s1.read(&mut buf), Ok(1));\n+            rx2.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn tcp_clone_two_read() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+            let (tx1, rx) = channel();\n+            let tx2 = tx1.clone();\n+\n+            let _t = Thread::scoped(move|| {\n+                let mut s = t!(TcpStream::connect(&addr));\n+                t!(s.write(&[1]));\n+                rx.recv().unwrap();\n+                t!(s.write(&[2]));\n+                rx.recv().unwrap();\n+            });\n+\n+            let mut s1 = t!(acceptor.accept()).0;\n+            let s2 = t!(s1.try_clone());\n+\n+            let (done, rx) = channel();\n+            let _t = Thread::scoped(move|| {\n+                let mut s2 = s2;\n+                let mut buf = [0, 0];\n+                t!(s2.read(&mut buf));\n+                tx2.send(()).unwrap();\n+                done.send(()).unwrap();\n+            });\n+            let mut buf = [0, 0];\n+            t!(s1.read(&mut buf));\n+            tx1.send(()).unwrap();\n+\n+            rx.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn tcp_clone_two_write() {\n+        each_ip(&mut |addr| {\n+            let acceptor = t!(TcpListener::bind(&addr));\n+\n+            let _t = Thread::scoped(move|| {\n+                let mut s = t!(TcpStream::connect(&addr));\n+                let mut buf = [0, 1];\n+                t!(s.read(&mut buf));\n+                t!(s.read(&mut buf));\n+            });\n+\n+            let mut s1 = t!(acceptor.accept()).0;\n+            let s2 = t!(s1.try_clone());\n+\n+            let (done, rx) = channel();\n+            let _t = Thread::scoped(move|| {\n+                let mut s2 = s2;\n+                t!(s2.write(&[1]));\n+                done.send(()).unwrap();\n+            });\n+            t!(s1.write(&[2]));\n+\n+            rx.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn shutdown_smoke() {\n+        each_ip(&mut |addr| {\n+            let a = t!(TcpListener::bind(&addr));\n+            let _t = Thread::scoped(move|| {\n+                let mut c = t!(a.accept()).0;\n+                let mut b = [0];\n+                assert_eq!(c.read(&mut b), Ok(0));\n+                t!(c.write(&[1]));\n+            });\n+\n+            let mut s = t!(TcpStream::connect(&addr));\n+            t!(s.shutdown(Shutdown::Write));\n+            assert!(s.write(&[1]).is_err());\n+            let mut b = [0, 0];\n+            assert_eq!(t!(s.read(&mut b)), 1);\n+            assert_eq!(b[0], 1);\n+        })\n+    }\n+\n+    #[test]\n+    fn close_readwrite_smoke() {\n+        each_ip(&mut |addr| {\n+            let a = t!(TcpListener::bind(&addr));\n+            let (tx, rx) = channel::<()>();\n+            let _t = Thread::scoped(move|| {\n+                let _s = t!(a.accept());\n+                let _ = rx.recv();\n+            });\n+\n+            let mut b = [0];\n+            let mut s = t!(TcpStream::connect(&addr));\n+            let mut s2 = t!(s.try_clone());\n+\n+            // closing should prevent reads/writes\n+            t!(s.shutdown(Shutdown::Write));\n+            assert!(s.write(&[0]).is_err());\n+            t!(s.shutdown(Shutdown::Read));\n+            assert_eq!(s.read(&mut b), Ok(0));\n+\n+            // closing should affect previous handles\n+            assert!(s2.write(&[0]).is_err());\n+            assert_eq!(s2.read(&mut b), Ok(0));\n+\n+            // closing should affect new handles\n+            let mut s3 = t!(s.try_clone());\n+            assert!(s3.write(&[0]).is_err());\n+            assert_eq!(s3.read(&mut b), Ok(0));\n+\n+            // make sure these don't die\n+            let _ = s2.shutdown(Shutdown::Read);\n+            let _ = s2.shutdown(Shutdown::Write);\n+            let _ = s3.shutdown(Shutdown::Read);\n+            let _ = s3.shutdown(Shutdown::Write);\n+            drop(tx);\n+        })\n+    }\n+\n+    #[test]\n+    fn close_read_wakes_up() {\n+        each_ip(&mut |addr| {\n+            let a = t!(TcpListener::bind(&addr));\n+            let (tx1, rx) = channel::<()>();\n+            let _t = Thread::scoped(move|| {\n+                let _s = t!(a.accept());\n+                let _ = rx.recv();\n+            });\n+\n+            let s = t!(TcpStream::connect(&addr));\n+            let s2 = t!(s.try_clone());\n+            let (tx, rx) = channel();\n+            let _t = Thread::scoped(move|| {\n+                let mut s2 = s2;\n+                assert_eq!(t!(s2.read(&mut [0])), 0);\n+                tx.send(()).unwrap();\n+            });\n+            // this should wake up the child task\n+            t!(s.shutdown(Shutdown::Read));\n+\n+            // this test will never finish if the child doesn't wake up\n+            rx.recv().unwrap();\n+            drop(tx1);\n+        })\n+    }\n+\n+    #[test]\n+    fn clone_while_reading() {\n+        each_ip(&mut |addr| {\n+            let accept = t!(TcpListener::bind(&addr));\n+\n+            // Enqueue a task to write to a socket\n+            let (tx, rx) = channel();\n+            let (txdone, rxdone) = channel();\n+            let txdone2 = txdone.clone();\n+            let _t = Thread::scoped(move|| {\n+                let mut tcp = t!(TcpStream::connect(&addr));\n+                rx.recv().unwrap();\n+                t!(tcp.write(&[0]));\n+                txdone2.send(()).unwrap();\n+            });\n+\n+            // Spawn off a reading clone\n+            let tcp = t!(accept.accept()).0;\n+            let tcp2 = t!(tcp.try_clone());\n+            let txdone3 = txdone.clone();\n+            let _t = Thread::scoped(move|| {\n+                let mut tcp2 = tcp2;\n+                t!(tcp2.read(&mut [0]));\n+                txdone3.send(()).unwrap();\n+            });\n+\n+            // Try to ensure that the reading clone is indeed reading\n+            for _ in 0..50 {\n+                Thread::yield_now();\n+            }\n+\n+            // clone the handle again while it's reading, then let it finish the\n+            // read.\n+            let _ = t!(tcp.try_clone());\n+            tx.send(()).unwrap();\n+            rxdone.recv().unwrap();\n+            rxdone.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn clone_accept_smoke() {\n+        each_ip(&mut |addr| {\n+            let a = t!(TcpListener::bind(&addr));\n+            let a2 = t!(a.try_clone());\n+\n+            let _t = Thread::scoped(move|| {\n+                let _ = TcpStream::connect(&addr);\n+            });\n+            let _t = Thread::scoped(move|| {\n+                let _ = TcpStream::connect(&addr);\n+            });\n+\n+            t!(a.accept());\n+            t!(a2.accept());\n+        })\n+    }\n+\n+    #[test]\n+    fn clone_accept_concurrent() {\n+        each_ip(&mut |addr| {\n+            let a = t!(TcpListener::bind(&addr));\n+            let a2 = t!(a.try_clone());\n+\n+            let (tx, rx) = channel();\n+            let tx2 = tx.clone();\n+\n+            let _t = Thread::scoped(move|| {\n+                tx.send(t!(a.accept())).unwrap();\n+            });\n+            let _t = Thread::scoped(move|| {\n+                tx2.send(t!(a2.accept())).unwrap();\n+            });\n+\n+            let _t = Thread::scoped(move|| {\n+                let _ = TcpStream::connect(&addr);\n+            });\n+            let _t = Thread::scoped(move|| {\n+                let _ = TcpStream::connect(&addr);\n+            });\n+\n+            rx.recv().unwrap();\n+            rx.recv().unwrap();\n+        })\n+    }\n+}"}, {"sha": "971fb4b69c8ef5ee6df1cd5ef3700d2c248f2ebf", "filename": "src/libstd/net/test.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use env;\n+use net::{SocketAddr, IpAddr};\n+use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+pub fn next_test_ip4() -> SocketAddr {\n+    static PORT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    SocketAddr::new(IpAddr::new_v4(127, 0, 0, 1),\n+                    PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port())\n+}\n+\n+pub fn next_test_ip6() -> SocketAddr {\n+    static PORT: AtomicUsize = ATOMIC_USIZE_INIT;\n+    SocketAddr::new(IpAddr::new_v6(0, 0, 0, 0, 0, 0, 0, 1),\n+                    PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port())\n+}\n+\n+// The bots run multiple builds at the same time, and these builds\n+// all want to use ports. This function figures out which workspace\n+// it is running in and assigns a port range based on it.\n+fn base_port() -> u16 {\n+    let cwd = env::current_dir().unwrap();\n+    let dirs = [\"32-opt\", \"32-nopt\", \"64-opt\", \"64-nopt\", \"64-opt-vg\",\n+                \"all-opt\", \"snap3\", \"dist\"];\n+    dirs.iter().enumerate().find(|&(i, dir)| {\n+        cwd.as_str().unwrap().contains(dir)\n+    }).map(|p| p.0).unwrap_or(0) as u16 * 1000 + 19600\n+}"}, {"sha": "d162a29790ea16c77ea4e6463209b00f8f829554", "filename": "src/libstd/net/udp.rs", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -0,0 +1,291 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use io::{self, Error, ErrorKind};\n+use net::{ToSocketAddrs, SocketAddr, IpAddr};\n+use sys_common::net2 as net_imp;\n+use sys_common::AsInner;\n+\n+/// A User Datagram Protocol socket.\n+///\n+/// This is an implementation of a bound UDP socket. This supports both IPv4 and\n+/// IPv6 addresses, and there is no corresponding notion of a server because UDP\n+/// is a datagram protocol.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// use std::net::UdpSocket;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// let mut socket = try!(UdpSocket::bind(\"127.0.0.1:34254\"));\n+///\n+/// let mut buf = [0; 10];\n+/// let (amt, src) = try!(socket.recv_from(&mut buf));\n+///\n+/// // Send a reply to the socket we received data from\n+/// let buf = &mut buf[..amt];\n+/// buf.reverse();\n+/// try!(socket.send_to(buf, &src));\n+///\n+/// drop(socket); // close the socket\n+/// # Ok(())\n+/// # }\n+/// ```\n+pub struct UdpSocket(net_imp::UdpSocket);\n+\n+impl UdpSocket {\n+    /// Creates a UDP socket from the given address.\n+    ///\n+    /// Address type can be any implementor of `ToSocketAddr` trait. See its\n+    /// documentation for concrete examples.\n+    pub fn bind<A: ToSocketAddrs + ?Sized>(addr: &A) -> io::Result<UdpSocket> {\n+        super::each_addr(addr, net_imp::UdpSocket::bind).map(UdpSocket)\n+    }\n+\n+    /// Receives data from the socket. On success, returns the number of bytes\n+    /// read and the address from whence the data came.\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.0.recv_from(buf)\n+    }\n+\n+    /// Sends data on the socket to the given address. Returns nothing on\n+    /// success.\n+    ///\n+    /// Address type can be any implementor of `ToSocketAddrs` trait. See its\n+    /// documentation for concrete examples.\n+    pub fn send_to<A: ToSocketAddrs + ?Sized>(&self, buf: &[u8], addr: &A)\n+                                              -> io::Result<usize> {\n+        match try!(addr.to_socket_addrs()).next() {\n+            Some(addr) => self.0.send_to(buf, &addr),\n+            None => Err(Error::new(ErrorKind::InvalidInput,\n+                                   \"no addresses to send data to\", None)),\n+        }\n+    }\n+\n+    /// Returns the socket address that this socket was created from.\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.socket_addr()\n+    }\n+\n+    /// Create a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UdpSocket` is a reference to the same socket that this\n+    /// object references. Both handles will read and write the same port, and\n+    /// options set on one socket will be propagated to the other.\n+    pub fn try_clone(&self) -> io::Result<UdpSocket> {\n+        self.0.duplicate().map(UdpSocket)\n+    }\n+\n+    /// Sets the broadcast flag on or off\n+    pub fn set_broadcast(&self, on: bool) -> io::Result<()> {\n+        self.0.set_broadcast(on)\n+    }\n+\n+    /// Set the multicast loop flag to the specified value\n+    ///\n+    /// This lets multicast packets loop back to local sockets (if enabled)\n+    pub fn set_multicast_loop(&self, on: bool) -> io::Result<()> {\n+        self.0.set_multicast_loop(on)\n+    }\n+\n+    /// Joins a multicast IP address (becomes a member of it)\n+    pub fn join_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n+        self.0.join_multicast(multi)\n+    }\n+\n+    /// Leaves a multicast IP address (drops membership from it)\n+    pub fn leave_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n+        self.0.leave_multicast(multi)\n+    }\n+\n+    /// Sets the multicast TTL\n+    pub fn set_multicast_time_to_live(&self, ttl: i32) -> io::Result<()> {\n+        self.0.multicast_time_to_live(ttl)\n+    }\n+\n+    /// Sets this socket's TTL\n+    pub fn set_time_to_live(&self, ttl: i32) -> io::Result<()> {\n+        self.0.time_to_live(ttl)\n+    }\n+}\n+\n+impl AsInner<net_imp::UdpSocket> for UdpSocket {\n+    fn as_inner(&self) -> &net_imp::UdpSocket { &self.0 }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+\n+    use io::ErrorKind;\n+    use net::*;\n+    use net::test::{next_test_ip4, next_test_ip6};\n+    use sync::mpsc::channel;\n+    use thread::Thread;\n+\n+    fn each_ip(f: &mut FnMut(SocketAddr, SocketAddr)) {\n+        f(next_test_ip4(), next_test_ip4());\n+        f(next_test_ip6(), next_test_ip6());\n+    }\n+\n+    macro_rules! t {\n+        ($e:expr) => {\n+            match $e {\n+                Ok(t) => t,\n+                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n+            }\n+        }\n+    }\n+\n+    // FIXME #11530 this fails on android because tests are run as root\n+    #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n+    #[test]\n+    fn bind_error() {\n+        let addr = SocketAddr::new(IpAddr::new_v4(0, 0, 0, 0), 1);\n+        match UdpSocket::bind(&addr) {\n+            Ok(..) => panic!(),\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::PermissionDenied),\n+        }\n+    }\n+\n+    #[test]\n+    fn socket_smoke_test_ip4() {\n+        each_ip(&mut |server_ip, client_ip| {\n+            let (tx1, rx1) = channel();\n+            let (tx2, rx2) = channel();\n+\n+            let _t = Thread::spawn(move|| {\n+                let client = t!(UdpSocket::bind(&client_ip));\n+                rx1.recv().unwrap();\n+                t!(client.send_to(&[99], &server_ip));\n+                tx2.send(()).unwrap();\n+            });\n+\n+            let server = t!(UdpSocket::bind(&server_ip));\n+            tx1.send(()).unwrap();\n+            let mut buf = [0];\n+            let (nread, src) = t!(server.recv_from(&mut buf));\n+            assert_eq!(nread, 1);\n+            assert_eq!(buf[0], 99);\n+            assert_eq!(src, client_ip);\n+            rx2.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn socket_name_ip4() {\n+        each_ip(&mut |addr, _| {\n+            let server = t!(UdpSocket::bind(&addr));\n+            assert_eq!(addr, t!(server.socket_addr()));\n+        })\n+    }\n+\n+    #[test]\n+    fn udp_clone_smoke() {\n+        each_ip(&mut |addr1, addr2| {\n+            let sock1 = t!(UdpSocket::bind(&addr1));\n+            let sock2 = t!(UdpSocket::bind(&addr2));\n+\n+            let _t = Thread::spawn(move|| {\n+                let mut buf = [0, 0];\n+                assert_eq!(sock2.recv_from(&mut buf), Ok((1, addr1)));\n+                assert_eq!(buf[0], 1);\n+                t!(sock2.send_to(&[2], &addr1));\n+            });\n+\n+            let sock3 = t!(sock1.try_clone());\n+\n+            let (tx1, rx1) = channel();\n+            let (tx2, rx2) = channel();\n+            let _t = Thread::spawn(move|| {\n+                rx1.recv().unwrap();\n+                t!(sock3.send_to(&[1], &addr2));\n+                tx2.send(()).unwrap();\n+            });\n+            tx1.send(()).unwrap();\n+            let mut buf = [0, 0];\n+            assert_eq!(sock1.recv_from(&mut buf), Ok((1, addr2)));\n+            rx2.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn udp_clone_two_read() {\n+        each_ip(&mut |addr1, addr2| {\n+            let sock1 = t!(UdpSocket::bind(&addr1));\n+            let sock2 = t!(UdpSocket::bind(&addr2));\n+            let (tx1, rx) = channel();\n+            let tx2 = tx1.clone();\n+\n+            let _t = Thread::spawn(move|| {\n+                t!(sock2.send_to(&[1], &addr1));\n+                rx.recv().unwrap();\n+                t!(sock2.send_to(&[2], &addr1));\n+                rx.recv().unwrap();\n+            });\n+\n+            let sock3 = t!(sock1.try_clone());\n+\n+            let (done, rx) = channel();\n+            let _t = Thread::spawn(move|| {\n+                let mut buf = [0, 0];\n+                t!(sock3.recv_from(&mut buf));\n+                tx2.send(()).unwrap();\n+                done.send(()).unwrap();\n+            });\n+            let mut buf = [0, 0];\n+            t!(sock1.recv_from(&mut buf));\n+            tx1.send(()).unwrap();\n+\n+            rx.recv().unwrap();\n+        })\n+    }\n+\n+    #[test]\n+    fn udp_clone_two_write() {\n+        each_ip(&mut |addr1, addr2| {\n+            let sock1 = t!(UdpSocket::bind(&addr1));\n+            let sock2 = t!(UdpSocket::bind(&addr2));\n+\n+            let (tx, rx) = channel();\n+            let (serv_tx, serv_rx) = channel();\n+\n+            let _t = Thread::spawn(move|| {\n+                let mut buf = [0, 1];\n+                rx.recv().unwrap();\n+                t!(sock2.recv_from(&mut buf));\n+                serv_tx.send(()).unwrap();\n+            });\n+\n+            let sock3 = t!(sock1.try_clone());\n+\n+            let (done, rx) = channel();\n+            let tx2 = tx.clone();\n+            let _t = Thread::spawn(move|| {\n+                match sock3.send_to(&[1], &addr2) {\n+                    Ok(..) => { let _ = tx2.send(()); }\n+                    Err(..) => {}\n+                }\n+                done.send(()).unwrap();\n+            });\n+            match sock1.send_to(&[2], &addr2) {\n+                Ok(..) => { let _ = tx.send(()); }\n+                Err(..) => {}\n+            }\n+            drop(tx);\n+\n+            rx.recv().unwrap();\n+            serv_rx.recv().unwrap();\n+        })\n+    }\n+}"}, {"sha": "5054f72ea98791d5931d66f917ccd2e87fd71604", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -24,6 +24,7 @@ pub mod condvar;\n pub mod helper_thread;\n pub mod mutex;\n pub mod net;\n+pub mod net2;\n pub mod rwlock;\n pub mod stack;\n pub mod thread;"}, {"sha": "5af59ec6d2b1473ae3b513bf420c0eff0400eb96", "filename": "src/libstd/sys/common/net2.rs", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -0,0 +1,393 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use ffi::CString;\n+use io::{self, Error, ErrorKind};\n+use libc::{self, c_int, c_char, c_void, socklen_t};\n+use mem;\n+use net::{IpAddr, SocketAddr, Shutdown};\n+use num::Int;\n+use sys::c;\n+use sys::net::{cvt, cvt_r, cvt_gai, Socket, init, wrlen_t};\n+use sys_common::{AsInner, FromInner, IntoInner};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// sockaddr and misc bindings\n+////////////////////////////////////////////////////////////////////////////////\n+\n+fn hton<I: Int>(i: I) -> I { i.to_be() }\n+fn ntoh<I: Int>(i: I) -> I { Int::from_be(i) }\n+\n+fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int,\n+                     payload: T) -> io::Result<()> {\n+    unsafe {\n+        let payload = &payload as *const T as *const c_void;\n+        try!(cvt(libc::setsockopt(*sock.as_inner(), opt, val, payload,\n+                                  mem::size_of::<T>() as socklen_t)));\n+        Ok(())\n+    }\n+}\n+\n+#[allow(dead_code)]\n+fn getsockopt<T: Copy>(sock: &Socket, opt: c_int,\n+                           val: c_int) -> io::Result<T> {\n+    unsafe {\n+        let mut slot: T = mem::zeroed();\n+        let mut len = mem::size_of::<T>() as socklen_t;\n+        let ret = try!(cvt(c::getsockopt(*sock.as_inner(), opt, val,\n+                                         &mut slot as *mut _ as *mut _,\n+                                         &mut len)));\n+        assert_eq!(ret as usize, mem::size_of::<T>());\n+        Ok(slot)\n+    }\n+}\n+\n+fn sockname<F>(f: F) -> io::Result<SocketAddr>\n+    where F: FnOnce(*mut libc::sockaddr, *mut socklen_t) -> c_int\n+{\n+    unsafe {\n+        let mut storage: libc::sockaddr_storage = mem::zeroed();\n+        let mut len = mem::size_of_val(&storage) as socklen_t;\n+        try!(cvt(f(&mut storage as *mut _ as *mut _, &mut len)));\n+        sockaddr_to_addr(&storage, len as usize)\n+    }\n+}\n+\n+fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n+                    len: usize) -> io::Result<SocketAddr> {\n+    match storage.ss_family as libc::c_int {\n+        libc::AF_INET => {\n+            assert!(len as usize >= mem::size_of::<libc::sockaddr_in>());\n+            Ok(FromInner::from_inner(unsafe {\n+                *(storage as *const _ as *const libc::sockaddr_in)\n+            }))\n+        }\n+        libc::AF_INET6 => {\n+            assert!(len as usize >= mem::size_of::<libc::sockaddr_in6>());\n+            Ok(FromInner::from_inner(unsafe {\n+                *(storage as *const _ as *const libc::sockaddr_in6)\n+            }))\n+        }\n+        _ => {\n+            Err(Error::new(ErrorKind::InvalidInput, \"invalid argument\", None))\n+        }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// get_host_addresses\n+////////////////////////////////////////////////////////////////////////////////\n+\n+extern \"system\" {\n+    fn getaddrinfo(node: *const c_char, service: *const c_char,\n+                   hints: *const libc::addrinfo,\n+                   res: *mut *mut libc::addrinfo) -> c_int;\n+    fn freeaddrinfo(res: *mut libc::addrinfo);\n+}\n+\n+pub struct LookupHost {\n+    original: *mut libc::addrinfo,\n+    cur: *mut libc::addrinfo,\n+}\n+\n+impl Iterator for LookupHost {\n+    type Item = io::Result<SocketAddr>;\n+    fn next(&mut self) -> Option<io::Result<SocketAddr>> {\n+        unsafe {\n+            if self.cur.is_null() { return None }\n+            let ret = sockaddr_to_addr(mem::transmute((*self.cur).ai_addr),\n+                                       (*self.cur).ai_addrlen as usize);\n+            self.cur = (*self.cur).ai_next as *mut libc::addrinfo;\n+            Some(ret)\n+        }\n+    }\n+}\n+\n+impl Drop for LookupHost {\n+    fn drop(&mut self) {\n+        unsafe { freeaddrinfo(self.original) }\n+    }\n+}\n+\n+pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n+    init();\n+\n+    let c_host = CString::from_slice(host.as_bytes());\n+    let mut res = 0 as *mut _;\n+    unsafe {\n+        try!(cvt_gai(getaddrinfo(c_host.as_ptr(), 0 as *const _, 0 as *const _,\n+                                 &mut res)));\n+        Ok(LookupHost { original: res, cur: res })\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// TCP streams\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct TcpStream {\n+    inner: Socket,\n+}\n+\n+impl TcpStream {\n+    pub fn connect(addr: &SocketAddr) -> io::Result<TcpStream> {\n+        init();\n+\n+        let sock = try!(Socket::new(addr, libc::SOCK_STREAM));\n+\n+        let (addrp, len) = addr.into_inner();\n+        try!(cvt_r(|| unsafe { libc::connect(*sock.as_inner(), addrp, len) }));\n+        Ok(TcpStream { inner: sock })\n+    }\n+\n+    pub fn socket(&self) -> &Socket { &self.inner }\n+\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::IPPROTO_TCP, libc::TCP_NODELAY,\n+                   nodelay as c_int)\n+    }\n+\n+    pub fn set_keepalive(&self, seconds: Option<u32>) -> io::Result<()> {\n+        let ret = setsockopt(&self.inner, libc::SOL_SOCKET, libc::SO_KEEPALIVE,\n+                             seconds.is_some() as c_int);\n+        match seconds {\n+            Some(n) => ret.and_then(|()| self.set_tcp_keepalive(n)),\n+            None => ret,\n+        }\n+    }\n+\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+    fn set_tcp_keepalive(&self, seconds: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,\n+                   seconds as c_int)\n+    }\n+    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+    fn set_tcp_keepalive(&self, seconds: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n+                   seconds as c_int)\n+    }\n+    #[cfg(not(any(target_os = \"macos\",\n+                  target_os = \"ios\",\n+                  target_os = \"freebsd\",\n+                  target_os = \"dragonfly\")))]\n+    fn set_tcp_keepalive(&self, _seconds: u32) -> io::Result<()> {\n+        Ok(())\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.read(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        let ret = try!(cvt(unsafe {\n+            libc::send(*self.inner.as_inner(),\n+                       buf.as_ptr() as *const c_void,\n+                       buf.len() as wrlen_t,\n+                       0)\n+        }));\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        sockname(|buf, len| unsafe {\n+            libc::getpeername(*self.inner.as_inner(), buf, len)\n+        })\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        sockname(|buf, len| unsafe {\n+            libc::getsockname(*self.inner.as_inner(), buf, len)\n+        })\n+    }\n+\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        use libc::consts::os::bsd44::SHUT_RDWR;\n+\n+        let how = match how {\n+            Shutdown::Write => libc::SHUT_WR,\n+            Shutdown::Read => libc::SHUT_RD,\n+            Shutdown::Both => SHUT_RDWR,\n+        };\n+        try!(cvt(unsafe { libc::shutdown(*self.inner.as_inner(), how) }));\n+        Ok(())\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpStream> {\n+        self.inner.duplicate().map(|s| TcpStream { inner: s })\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// TCP listeners\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct TcpListener {\n+    inner: Socket,\n+}\n+\n+impl TcpListener {\n+    pub fn bind(addr: &SocketAddr) -> io::Result<TcpListener> {\n+        init();\n+\n+        let sock = try!(Socket::new(addr, libc::SOCK_STREAM));\n+\n+        // On platforms with Berkeley-derived sockets, this allows\n+        // to quickly rebind a socket, without needing to wait for\n+        // the OS to clean up the previous one.\n+        if !cfg!(windows) {\n+            try!(setsockopt(&sock, libc::SOL_SOCKET, libc::SO_REUSEADDR,\n+                            1 as c_int));\n+        }\n+\n+        // Bind our new socket\n+        let (addrp, len) = addr.into_inner();\n+        try!(cvt(unsafe { libc::bind(*sock.as_inner(), addrp, len) }));\n+\n+        // Start listening\n+        try!(cvt(unsafe { libc::listen(*sock.as_inner(), 128) }));\n+        Ok(TcpListener { inner: sock })\n+    }\n+\n+    pub fn socket(&self) -> &Socket { &self.inner }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        sockname(|buf, len| unsafe {\n+            libc::getsockname(*self.inner.as_inner(), buf, len)\n+        })\n+    }\n+\n+    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n+        let mut len = mem::size_of_val(&storage) as socklen_t;\n+        let sock = try!(self.inner.accept(&mut storage as *mut _ as *mut _,\n+                                          &mut len));\n+        let addr = try!(sockaddr_to_addr(&storage, len as usize));\n+        Ok((TcpStream { inner: sock, }, addr))\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpListener> {\n+        self.inner.duplicate().map(|s| TcpListener { inner: s })\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// UDP\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct UdpSocket {\n+    inner: Socket,\n+}\n+\n+impl UdpSocket {\n+    pub fn bind(addr: &SocketAddr) -> io::Result<UdpSocket> {\n+        init();\n+\n+        let sock = try!(Socket::new(addr, libc::SOCK_DGRAM));\n+        let (addrp, len) = addr.into_inner();\n+        try!(cvt(unsafe { libc::bind(*sock.as_inner(), addrp, len) }));\n+        Ok(UdpSocket { inner: sock })\n+    }\n+\n+    pub fn socket(&self) -> &Socket { &self.inner }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        sockname(|buf, len| unsafe {\n+            libc::getsockname(*self.inner.as_inner(), buf, len)\n+        })\n+    }\n+\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n+        let mut addrlen = mem::size_of_val(&storage) as socklen_t;\n+\n+        let n = try!(cvt(unsafe {\n+            libc::recvfrom(*self.inner.as_inner(),\n+                           buf.as_mut_ptr() as *mut c_void,\n+                           buf.len() as wrlen_t, 0,\n+                           &mut storage as *mut _ as *mut _, &mut addrlen)\n+        }));\n+        Ok((n as usize, try!(sockaddr_to_addr(&storage, addrlen as usize))))\n+    }\n+\n+    pub fn send_to(&self, buf: &[u8], dst: &SocketAddr) -> io::Result<usize> {\n+        let (dstp, dstlen) = dst.into_inner();\n+        let ret = try!(cvt(unsafe {\n+            libc::sendto(*self.inner.as_inner(),\n+                         buf.as_ptr() as *const c_void, buf.len() as wrlen_t,\n+                         0, dstp, dstlen)\n+        }));\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn set_broadcast(&self, on: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::SOL_SOCKET, libc::SO_BROADCAST,\n+                   on as c_int)\n+    }\n+\n+    pub fn set_multicast_loop(&self, on: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::IPPROTO_IP,\n+                   libc::IP_MULTICAST_LOOP, on as c_int)\n+    }\n+\n+    pub fn join_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n+        match *multi {\n+            IpAddr::V4(..) => {\n+                self.set_membership(multi, libc::IP_ADD_MEMBERSHIP)\n+            }\n+            IpAddr::V6(..) => {\n+                self.set_membership(multi, libc::IPV6_ADD_MEMBERSHIP)\n+            }\n+        }\n+    }\n+    pub fn leave_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n+        match *multi {\n+            IpAddr::V4(..) => {\n+                self.set_membership(multi, libc::IP_DROP_MEMBERSHIP)\n+            }\n+            IpAddr::V6(..) => {\n+                self.set_membership(multi, libc::IPV6_DROP_MEMBERSHIP)\n+            }\n+        }\n+    }\n+    fn set_membership(&self, addr: &IpAddr, opt: c_int) -> io::Result<()> {\n+        match *addr {\n+            IpAddr::V4(ref addr) => {\n+                let mreq = libc::ip_mreq {\n+                    imr_multiaddr: *addr.as_inner(),\n+                    // interface == INADDR_ANY\n+                    imr_interface: libc::in_addr { s_addr: 0x0 },\n+                };\n+                setsockopt(&self.inner, libc::IPPROTO_IP, opt, mreq)\n+            }\n+            IpAddr::V6(ref addr) => {\n+                let mreq = libc::ip6_mreq {\n+                    ipv6mr_multiaddr: *addr.as_inner(),\n+                    ipv6mr_interface: 0,\n+                };\n+                setsockopt(&self.inner, libc::IPPROTO_IPV6, opt, mreq)\n+            }\n+        }\n+    }\n+\n+    pub fn multicast_time_to_live(&self, ttl: i32) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::IPPROTO_IP, libc::IP_MULTICAST_TTL,\n+                   ttl as c_int)\n+    }\n+\n+    pub fn time_to_live(&self, ttl: i32) -> io::Result<()> {\n+        setsockopt(&self.inner, libc::IPPROTO_IP, libc::IP_TTL, ttl as c_int)\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n+        self.inner.duplicate().map(|s| UdpSocket { inner: s })\n+    }\n+}"}, {"sha": "03803cc30cebd554ae6cc978d7d1591aa312cdbf", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -157,6 +157,7 @@ extern {\n \n     pub fn utimes(filename: *const libc::c_char,\n                   times: *const libc::timeval) -> libc::c_int;\n+    pub fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]"}, {"sha": "1d95f1cce7e1bd80fa8060f400ce127f72d3b8b7", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -32,8 +32,8 @@\n #![unstable(feature = \"std_misc\")]\n \n use ffi::{OsStr, OsString};\n-use fs::{Permissions, OpenOptions};\n-use fs;\n+use fs::{self, Permissions, OpenOptions};\n+use net;\n use libc;\n use mem;\n use sys::os_str::Buf;\n@@ -111,6 +111,16 @@ impl AsRawFd for old_io::net::udp::UdpSocket {\n     }\n }\n \n+impl AsRawFd for net::TcpStream {\n+    fn as_raw_fd(&self) -> Fd { *self.as_inner().socket().as_inner() }\n+}\n+impl AsRawFd for net::TcpListener {\n+    fn as_raw_fd(&self) -> Fd { *self.as_inner().socket().as_inner() }\n+}\n+impl AsRawFd for net::UdpSocket {\n+    fn as_raw_fd(&self) -> Fd { *self.as_inner().socket().as_inner() }\n+}\n+\n // Unix-specific extensions to `OsString`.\n pub trait OsStringExt {\n     /// Create an `OsString` from a byte vector."}, {"sha": "327d117823ee37e1360164a678ad4a71fabb5b6b", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -15,8 +15,7 @@ use io;\n use libc::{self, c_int, size_t, c_void};\n use mem;\n use sys::cvt;\n-\n-pub type fd_t = c_int;\n+use sys_common::AsInner;\n \n pub struct FileDesc {\n     fd: c_int,\n@@ -55,6 +54,10 @@ impl FileDesc {\n     }\n }\n \n+impl AsInner<c_int> for FileDesc {\n+    fn as_inner(&self) -> &c_int { &self.fd }\n+}\n+\n impl Drop for FileDesc {\n     fn drop(&mut self) {\n         // closing stdio file handles makes no sense, so never do it. Also, note"}, {"sha": "96a18a956c6a67d0a6f652f5758ada956dd2078c", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -18,12 +18,11 @@\n use prelude::v1::*;\n \n use ffi;\n-use io::ErrorKind;\n+use io::{self, ErrorKind};\n use libc;\n use num::{Int, SignedInt};\n use num;\n use old_io::{self, IoResult, IoError};\n-use io;\n use str;\n use sys_common::mkerr_libc;\n \n@@ -47,6 +46,7 @@ pub mod fs;  // support for std::old_io\n pub mod fs2; // support for std::fs\n pub mod helper_signal;\n pub mod mutex;\n+pub mod net;\n pub mod os;\n pub mod os_str;\n pub mod pipe;"}, {"sha": "54aec7cf4b193a9b25cea06d4062969752ac5ebc", "filename": "src/libstd/sys/unix/net.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use ffi;\n+use io;\n+use libc::{self, c_int, size_t};\n+use str;\n+use sys::c;\n+use net::{SocketAddr, IpAddr};\n+use sys::fd::FileDesc;\n+use sys_common::AsInner;\n+\n+pub use sys::{cvt, cvt_r};\n+\n+pub type wrlen_t = size_t;\n+\n+pub struct Socket(FileDesc);\n+\n+pub fn init() {}\n+\n+pub fn cvt_gai(err: c_int) -> io::Result<()> {\n+    if err == 0 { return Ok(()) }\n+\n+    let detail = unsafe {\n+        str::from_utf8(ffi::c_str_to_bytes(&c::gai_strerror(err))).unwrap()\n+            .to_string()\n+    };\n+    Err(io::Error::new(io::ErrorKind::Other,\n+                       \"failed to lookup address information\", Some(detail)))\n+}\n+\n+impl Socket {\n+    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n+        let fam = match addr.ip() {\n+            IpAddr::V4(..) => libc::AF_INET,\n+            IpAddr::V6(..) => libc::AF_INET6,\n+        };\n+        unsafe {\n+            let fd = try!(cvt(libc::socket(fam, ty, 0)));\n+            Ok(Socket(FileDesc::new(fd)))\n+        }\n+    }\n+\n+    pub fn accept(&self, storage: *mut libc::sockaddr,\n+                  len: *mut libc::socklen_t) -> io::Result<Socket> {\n+        let fd = try!(cvt_r(|| unsafe {\n+            libc::accept(self.0.raw(), storage, len)\n+        }));\n+        Ok(Socket(FileDesc::new(fd)))\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<Socket> {\n+        cvt(unsafe { libc::dup(self.0.raw()) }).map(|fd| {\n+            Socket(FileDesc::new(fd))\n+        })\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+}\n+\n+impl AsInner<c_int> for Socket {\n+    fn as_inner(&self) -> &c_int { self.0.as_inner() }\n+}"}, {"sha": "ac1006e653f09dc7c76c1e423e8c536f54d93a81", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -21,6 +21,7 @@ pub use sys_common::wtf8::{Wtf8Buf, EncodeWide};\n use ffi::{OsStr, OsString};\n use fs::{self, OpenOptions};\n use libc;\n+use net;\n use sys::os_str::Buf;\n use sys_common::{AsInner, FromInner, AsInnerMut};\n \n@@ -103,6 +104,16 @@ impl AsRawSocket for old_io::net::udp::UdpSocket {\n     }\n }\n \n+impl AsRawSocket for net::TcpStream {\n+    fn as_raw_socket(&self) -> Socket { *self.as_inner().socket().as_inner() }\n+}\n+impl AsRawSocket for net::TcpListener {\n+    fn as_raw_socket(&self) -> Socket { *self.as_inner().socket().as_inner() }\n+}\n+impl AsRawSocket for net::UdpSocket {\n+    fn as_raw_socket(&self) -> Socket { *self.as_inner().socket().as_inner() }\n+}\n+\n // Windows-specific extensions to `OsString`.\n pub trait OsStringExt {\n     /// Create an `OsString` from a potentially ill-formed UTF-16 slice of 16-bit code units."}, {"sha": "0fa9aaf43235543818a8005108182723bd370297", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -43,6 +43,7 @@ pub mod fs2;\n pub mod handle;\n pub mod helper_signal;\n pub mod mutex;\n+pub mod net;\n pub mod os;\n pub mod os_str;\n pub mod pipe;"}, {"sha": "4df72f6d4ab7e57dd3b6740b808861ded0d5059c", "filename": "src/libstd/sys/windows/net.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/395709ca6d39ba1e095e404e1d2a169d918b7f0c/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=395709ca6d39ba1e095e404e1d2a169d918b7f0c", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use io;\n+use libc::consts::os::extra::INVALID_SOCKET;\n+use libc::{self, c_int, c_void};\n+use mem;\n+use net::{SocketAddr, IpAddr};\n+use num::{SignedInt, Int};\n+use rt;\n+use sync::{Once, ONCE_INIT};\n+use sys::c;\n+use sys_common::AsInner;\n+\n+pub type wrlen_t = i32;\n+\n+pub struct Socket(libc::SOCKET);\n+\n+pub fn init() {\n+    static START: Once = ONCE_INIT;\n+\n+    START.call_once(|| unsafe {\n+        let mut data: c::WSADATA = mem::zeroed();\n+        let ret = c::WSAStartup(0x202, // version 2.2\n+                                &mut data);\n+        assert_eq!(ret, 0);\n+\n+        rt::at_exit(|| { c::WSACleanup(); })\n+    });\n+}\n+\n+fn last_error() -> io::Error {\n+    io::Error::from_os_error(unsafe { c::WSAGetLastError() })\n+}\n+\n+pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n+    let one: T = Int::one();\n+    if t == -one {\n+        Err(last_error())\n+    } else {\n+        Ok(t)\n+    }\n+}\n+\n+pub fn cvt_gai(err: c_int) -> io::Result<()> {\n+    if err == 0 { return Ok(()) }\n+    cvt(err).map(|_| ())\n+}\n+\n+pub fn cvt_r<T: SignedInt, F>(mut f: F) -> io::Result<T> where F: FnMut() -> T {\n+    cvt(f())\n+}\n+\n+impl Socket {\n+    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n+        let fam = match addr.ip {\n+            IpAddr::V4(..) => libc::AF_INET,\n+            IpAddr::V6(..) => libc::AF_INET6,\n+        };\n+        match unsafe { libc::socket(fam, ty, 0) } {\n+            INVALID_SOCKET => Err(last_error()),\n+            n => Ok(Socket(n)),\n+        }\n+    }\n+\n+    pub fn accept(&self, storage: *mut libc::sockaddr,\n+                  len: *mut libc::socklen_t) -> io::Result<Socket> {\n+        match unsafe { libc::accept(self.0, storage, len) } {\n+            INVALID_SOCKET => Err(last_error()),\n+            n => Ok(Socket(n)),\n+        }\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<Socket> {\n+        unsafe {\n+            let mut info: c::WSAPROTOCOL_INFO = mem::zeroed();\n+            try!(cvt(c::WSADuplicateSocketW(self.0,\n+                                            c::GetCurrentProcessId(),\n+                                            &mut info)));\n+            match c::WSASocketW(info.iAddressFamily,\n+                                info.iSocketType,\n+                                info.iProtocol,\n+                                &mut info, 0, 0) {\n+                INVALID_SOCKET => Err(last_error()),\n+                n => Ok(Socket(n)),\n+            }\n+        }\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        // On unix when a socket is shut down all further reads return 0, so we\n+        // do the same on windows to map a shut down socket to returning EOF.\n+        unsafe {\n+            match libc::recv(self.0, buf.as_mut_ptr() as *mut c_void,\n+                             buf.len() as i32, 0) {\n+                -1 if c::WSAGetLastError() == c::WSAESHUTDOWN => Ok(0),\n+                -1 => Err(last_error()),\n+                n => Ok(n as usize)\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for Socket {\n+    fn drop(&mut self) {\n+        unsafe { let _ = libc::closesocket(self.0); }\n+    }\n+}\n+\n+impl AsInner<libc::SOCKET> for Socket {\n+    fn as_inner(&self) -> &libc::SOCKET { &self.0 }\n+}"}]}