{"sha": "addc404d32b8b153f65b180c4bcdc5ccaaba2a77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZGM0MDRkMzJiOGIxNTNmNjViMTgwYzRiY2RjNWNjYWFiYTJhNzc=", "commit": {"author": {"name": "leonardo.yvens", "email": "leoyvens@gmail.com", "date": "2018-01-21T14:09:06Z"}, "committer": {"name": "leonardo.yvens", "email": "leoyvens@gmail.com", "date": "2018-02-28T15:33:15Z"}, "message": "Check WF of predicate with defaults only if all in LHS have default\n\n Given a trait predicate, if all params appearing in the LHS have\ndefaults then it should be a backwards compatible predicate. We verify\nthat by checking the WF of predicate with all defaults substituted\nsimultaneously.", "tree": {"sha": "5889b6c08df4756782c626aa73795dfd23fe2cf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5889b6c08df4756782c626aa73795dfd23fe2cf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/addc404d32b8b153f65b180c4bcdc5ccaaba2a77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/addc404d32b8b153f65b180c4bcdc5ccaaba2a77", "html_url": "https://github.com/rust-lang/rust/commit/addc404d32b8b153f65b180c4bcdc5ccaaba2a77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/addc404d32b8b153f65b180c4bcdc5ccaaba2a77/comments", "author": {"login": "leoyvens", "id": 9885558, "node_id": "MDQ6VXNlcjk4ODU1NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/9885558?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leoyvens", "html_url": "https://github.com/leoyvens", "followers_url": "https://api.github.com/users/leoyvens/followers", "following_url": "https://api.github.com/users/leoyvens/following{/other_user}", "gists_url": "https://api.github.com/users/leoyvens/gists{/gist_id}", "starred_url": "https://api.github.com/users/leoyvens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leoyvens/subscriptions", "organizations_url": "https://api.github.com/users/leoyvens/orgs", "repos_url": "https://api.github.com/users/leoyvens/repos", "events_url": "https://api.github.com/users/leoyvens/events{/privacy}", "received_events_url": "https://api.github.com/users/leoyvens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "leoyvens", "id": 9885558, "node_id": "MDQ6VXNlcjk4ODU1NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/9885558?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leoyvens", "html_url": "https://github.com/leoyvens", "followers_url": "https://api.github.com/users/leoyvens/followers", "following_url": "https://api.github.com/users/leoyvens/following{/other_user}", "gists_url": "https://api.github.com/users/leoyvens/gists{/gist_id}", "starred_url": "https://api.github.com/users/leoyvens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leoyvens/subscriptions", "organizations_url": "https://api.github.com/users/leoyvens/orgs", "repos_url": "https://api.github.com/users/leoyvens/repos", "events_url": "https://api.github.com/users/leoyvens/events{/privacy}", "received_events_url": "https://api.github.com/users/leoyvens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35499aa9fcef2cab965f0c1e04da1b97ec715d64", "url": "https://api.github.com/repos/rust-lang/rust/commits/35499aa9fcef2cab965f0c1e04da1b97ec715d64", "html_url": "https://github.com/rust-lang/rust/commit/35499aa9fcef2cab965f0c1e04da1b97ec715d64"}], "stats": {"total": 209, "additions": 99, "deletions": 110}, "files": [{"sha": "2c538d2bba56dea44492e97eea8d70f2a870a98b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/addc404d32b8b153f65b180c4bcdc5ccaaba2a77/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addc404d32b8b153f65b180c4bcdc5ccaaba2a77/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=addc404d32b8b153f65b180c4bcdc5ccaaba2a77", "patch": "@@ -1040,6 +1040,13 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n                 Predicate::ConstEvaluatable(def_id, const_substs.subst(tcx, substs)),\n         }\n     }\n+\n+    pub fn as_poly_trait_predicate(&self) -> Option<&PolyTraitPredicate<'tcx>> {\n+        match self {\n+            Predicate::Trait(trait_pred) => Some(trait_pred),\n+            _ => None\n+        }\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]"}, {"sha": "463cc2aa6b3eb8fe39a89cdf697c5ba0b0971e24", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 61, "deletions": 59, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/addc404d32b8b153f65b180c4bcdc5ccaaba2a77/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addc404d32b8b153f65b180c4bcdc5ccaaba2a77/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=addc404d32b8b153f65b180c4bcdc5ccaaba2a77", "patch": "@@ -378,67 +378,69 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         let mut substituted_predicates = Vec::new();\n \n         let generics = self.tcx.generics_of(def_id);\n-        let defaulted_params = generics.types.iter()\n-                                             .filter(|def| def.has_default &&\n-                                                     def.index >= generics.parent_count() as u32);\n-        // WF checks for type parameter defaults. See test `type-check-defaults.rs` for examples.\n-        for param_def in defaulted_params {\n-            // This parameter has a default value. Check that this default value is well-formed.\n-            // For example this forbids the declaration:\n-            // struct Foo<T = Vec<[u32]>> { .. }\n-            // Here `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n-            let d = param_def.def_id;\n+        let is_our_default = |def: &ty::TypeParameterDef|\n+                                def.has_default && def.index >= generics.parent_count() as u32;\n+        let defaulted_params = generics.types.iter().cloned().filter(&is_our_default);\n+        // Check that defaults are well-formed. See test `type-check-defaults.rs`.\n+        // For example this forbids the declaration:\n+        // struct Foo<T = Vec<[u32]>> { .. }\n+        // Here the default `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n+        for d in defaulted_params.map(|p| p.def_id) {\n             fcx.register_wf_obligation(fcx.tcx.type_of(d), fcx.tcx.def_span(d), self.code.clone());\n+        }\n \n-            // Check the clauses are well-formed when the param is substituted by it's default.\n-            // For example this forbids the following declaration because `String` is not `Copy`:\n-            // struct Foo<T: Copy = String> { .. }\n-            //\n-            // In `trait Trait: Super`, checking `Self: Trait` or `Self: Super` is problematic.\n-            // Therefore we skip such predicates. This means we check less than we could.\n-            for pred in predicates.predicates.iter().filter(|p| !(is_trait && p.has_self_ty())) {\n-                let mut skip = true;\n-                let substs = ty::subst::Substs::for_item(fcx.tcx, def_id, |def, _| {\n-                    // All regions are identity.\n-                    fcx.tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n-                }, |def, _| {\n-                    let identity_ty = fcx.tcx.mk_param_from_def(def);\n-                    if def.index != param_def.index {\n-                        identity_ty\n-                    } else {\n-                        let sized = fcx.tcx.lang_items().sized_trait();\n-                        let pred_is_sized = match pred {\n-                            ty::Predicate::Trait(p) => Some(p.def_id()) == sized,\n-                            _ => false,\n-                        };\n-                        let default_ty = fcx.tcx.type_of(def.def_id);\n-                        let default_is_self = match default_ty.sty {\n-                            ty::TyParam(ref p) => p.is_self(),\n-                            _ => false\n-                        };\n-                        // In trait defs, skip `Self: Sized` when `Self` is the default.\n-                        if is_trait && pred_is_sized && default_is_self {\n-                            identity_ty\n-                        } else {\n-                            skip = false;\n-                            default_ty\n-                        }\n-                    }\n-                });\n-                if skip { continue; }\n-                substituted_predicates.push(match pred {\n-                    // In trait predicates, substitute defaults only for the LHS.\n-                    // See test `defaults-well-formedness.rs` for why substituting the RHS is bad.\n-                    ty::Predicate::Trait(t_pred) => {\n-                        let trait_ref = t_pred.map_bound(|t_pred| {\n-                            let mut trait_subs = t_pred.trait_ref.substs.to_vec();\n-                            trait_subs[0] = t_pred.self_ty().subst(fcx.tcx, substs).into();\n-                            ty::TraitRef::new(t_pred.def_id(), fcx.tcx.intern_substs(&trait_subs))\n-                        });\n-                        ty::Predicate::Trait(trait_ref.to_poly_trait_predicate())\n-                    }\n-                    _ => pred.subst(fcx.tcx, substs)\n-                });\n+        // Check that trait predicates are WF when params are substituted by their defaults.\n+        // We don't want to overly constrain the predicates that may be written but we\n+        // want to catch obviously wrong cases such as `struct Foo<T: Copy = String>`\n+        // or cases that may cause backwards incompatibility such as a library going from\n+        // `pub struct Foo<T>` to `pub struct Foo<T, U = i32>` where U: Trait<T>`\n+        // which may break existing uses of Foo<T>.\n+        // Therefore the check we do is: If if all params appearing in the LHS of the predicate\n+        // have defaults then we verify that it is WF with all defaults substituted simultaneously.\n+        // For more examples see tests `defaults-well-formedness.rs` and `type-check-defaults.rs`.\n+        //\n+        // First, we build the defaulted substitution.\n+        let mut defaulted_params = Vec::new();\n+        let substs = ty::subst::Substs::for_item(fcx.tcx, def_id, |def, _| {\n+                // All regions are identity.\n+                fcx.tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n+            }, |def, _| {\n+                if !is_our_default(def) {\n+                    // Identity substitution.\n+                    fcx.tcx.mk_param_from_def(def)\n+                } else  {\n+                    // Substitute with default.\n+                    defaulted_params.push(def.index);\n+                    fcx.tcx.type_of(def.def_id)\n+                }\n+            });\n+        // In `trait Trait: Super`, checking `Self: Trait` or `Self: Super` is problematic.\n+        // We avoid those by skipping any predicates in trait declarations that contain `Self`,\n+        // which is excessive so we end up checking less than we could.\n+        for pred in predicates.predicates.iter()\n+                                         .filter_map(ty::Predicate::as_poly_trait_predicate)\n+                                         .filter(|p| !(is_trait && p.has_self_ty())) {\n+            let is_defaulted_param = |ty: ty::Ty| match ty.sty {\n+                                            ty::TyParam(p) => defaulted_params.contains(&p.idx),\n+                                            _ => false\n+                                          };\n+            // If there is a non-defaulted param in the LHS, don't check the substituted predicate.\n+            // `skip_binder()` is ok, we're only inspecting the type params.\n+            if !pred.skip_binder().self_ty().walk().all(is_defaulted_param) {\n+                continue;\n+            }\n+            let substituted_pred = pred.subst(fcx.tcx, substs);\n+            // `skip_binder()` is ok, we're only inspecting for `has_self_ty()`.\n+            let substituted_lhs = substituted_pred.skip_binder().self_ty();\n+            // In trait defs, don't check `Self: Sized` when `Self` is the default.\n+            let pred_is_sized = Some(pred.def_id()) == fcx.tcx.lang_items().sized_trait();\n+            if is_trait && substituted_lhs.has_self_ty() && pred_is_sized {\n+                continue;\n+            }\n+            let pred = ty::Predicate::Trait(pred.subst(fcx.tcx, substs));\n+            // Avoid duplicates.\n+            if !predicates.predicates.contains(&pred) {\n+                substituted_predicates.push(pred);\n             }\n         }\n "}, {"sha": "abbd35b3909a6848ec74d020dd2c4ca4330510c9", "filename": "src/test/run-pass/defaults-well-formedness.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/addc404d32b8b153f65b180c4bcdc5ccaaba2a77/src%2Ftest%2Frun-pass%2Fdefaults-well-formedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addc404d32b8b153f65b180c4bcdc5ccaaba2a77/src%2Ftest%2Frun-pass%2Fdefaults-well-formedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefaults-well-formedness.rs?ref=addc404d32b8b153f65b180c4bcdc5ccaaba2a77", "patch": "@@ -11,4 +11,11 @@\n trait Trait<T> {}\n struct Foo<U, V=i32>(U, V) where U: Trait<V>;\n \n+trait Trait2 {}\n+struct TwoParams<T, U>(T, U);\n+impl Trait2 for TwoParams<i32, i32> {}\n+// Check that defaults are substituted simultaneously.\n+struct IndividuallyBogus<T = i32, U = i32>(TwoParams<T, U>) where TwoParams<T, U>: Trait2;\n+// Clauses with non-defaulted params are not checked.\n+struct NonDefaultedInClause<T, U = i32>(TwoParams<T, U>) where TwoParams<T, U>: Trait2;\n fn main() {}"}, {"sha": "cc20f81ae1647f73582034ed2b56088132a4c6d0", "filename": "src/test/ui/type-check-defaults.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/addc404d32b8b153f65b180c4bcdc5ccaaba2a77/src%2Ftest%2Fui%2Ftype-check-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addc404d32b8b153f65b180c4bcdc5ccaaba2a77/src%2Ftest%2Fui%2Ftype-check-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check-defaults.rs?ref=addc404d32b8b153f65b180c4bcdc5ccaaba2a77", "patch": "@@ -33,19 +33,15 @@ trait TraitBound<T:Copy=String> {}\n trait SelfBound<T:Copy=Self> {}\n //~^ error: the trait bound `Self: std::marker::Copy` is not satisfied [E0277]\n \n-trait FooTrait<T:Iterator = IntoIter<i32>> where T::Item : Add<u8> {}\n-//~^ error: the trait bound `i32: std::ops::Add<u8>` is not satisfied [E0277]\n-\n-trait Trait {}\n-struct TwoParams<T, U>(T, U);\n-impl Trait for TwoParams<i32, i32> {}\n-// Check that each default is substituted individually in the clauses.\n-struct Bogus<T = i32, U = i32>(TwoParams<T, U>) where TwoParams<T, U>: Trait;\n-//~^ error: the trait bound `TwoParams<i32, U>: Trait` is not satisfied [E0277]\n-//~^^ error: the trait bound `TwoParams<T, i32>: Trait` is not satisfied [E0277]\n-\n trait Super<T: Copy> { }\n trait Base<T = String>: Super<T> { }\n //~^ error: the trait bound `T: std::marker::Copy` is not satisfied [E0277]\n \n+trait Trait<T> {}\n+struct DefaultedLhs<U, V=i32>(U, V) where V: Trait<U>;\n+//~^ error: the trait bound `i32: Trait<U>` is not satisfied [E0277]\n+\n+// FIXME: Deal with projection predicates\n+// trait ProjectionPred<T:Iterator = IntoIter<i32>> where T::Item : Add<u8> {}\n+// ~^ error: the trait bound `i32: std::ops::Add<u8>` is not satisfied [E0277]\n fn main() { }"}, {"sha": "ede1b417c7c9294cf8e0472cea9f6b795300ca65", "filename": "src/test/ui/type-check-defaults.stderr", "status": "modified", "additions": 17, "deletions": 40, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/addc404d32b8b153f65b180c4bcdc5ccaaba2a77/src%2Ftest%2Fui%2Ftype-check-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/addc404d32b8b153f65b180c4bcdc5ccaaba2a77/src%2Ftest%2Fui%2Ftype-check-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check-defaults.stderr?ref=addc404d32b8b153f65b180c4bcdc5ccaaba2a77", "patch": "@@ -66,53 +66,30 @@ error[E0277]: the trait bound `Self: std::marker::Copy` is not satisfied\n    = help: consider adding a `where Self: std::marker::Copy` bound\n    = note: required by `std::marker::Copy`\n \n-error[E0277]: the trait bound `i32: std::ops::Add<u8>` is not satisfied\n-  --> $DIR/type-check-defaults.rs:36:1\n-   |\n-36 | trait FooTrait<T:Iterator = IntoIter<i32>> where T::Item : Add<u8> {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `i32 + u8`\n-   |\n-   = help: the trait `std::ops::Add<u8>` is not implemented for `i32`\n-   = note: required by `std::ops::Add`\n-\n-error[E0277]: the trait bound `TwoParams<i32, U>: Trait` is not satisfied\n-  --> $DIR/type-check-defaults.rs:43:1\n-   |\n-43 | struct Bogus<T = i32, U = i32>(TwoParams<T, U>) where TwoParams<T, U>: Trait;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait` is not implemented for `TwoParams<i32, U>`\n-   |\n-   = help: consider adding a `where TwoParams<i32, U>: Trait` bound\n-note: required by `Trait`\n-  --> $DIR/type-check-defaults.rs:39:1\n-   |\n-39 | trait Trait {}\n-   | ^^^^^^^^^^^\n-\n-error[E0277]: the trait bound `TwoParams<T, i32>: Trait` is not satisfied\n-  --> $DIR/type-check-defaults.rs:43:1\n-   |\n-43 | struct Bogus<T = i32, U = i32>(TwoParams<T, U>) where TwoParams<T, U>: Trait;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait` is not implemented for `TwoParams<T, i32>`\n-   |\n-   = help: consider adding a `where TwoParams<T, i32>: Trait` bound\n-note: required by `Trait`\n-  --> $DIR/type-check-defaults.rs:39:1\n-   |\n-39 | trait Trait {}\n-   | ^^^^^^^^^^^\n-\n error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n-  --> $DIR/type-check-defaults.rs:48:1\n+  --> $DIR/type-check-defaults.rs:37:1\n    |\n-48 | trait Base<T = String>: Super<T> { }\n+37 | trait Base<T = String>: Super<T> { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n    |\n    = help: consider adding a `where T: std::marker::Copy` bound\n note: required by `Super`\n-  --> $DIR/type-check-defaults.rs:47:1\n+  --> $DIR/type-check-defaults.rs:36:1\n    |\n-47 | trait Super<T: Copy> { }\n+36 | trait Super<T: Copy> { }\n    | ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 11 previous errors\n+error[E0277]: the trait bound `i32: Trait<U>` is not satisfied\n+  --> $DIR/type-check-defaults.rs:41:1\n+   |\n+41 | struct DefaultedLhs<U, V=i32>(U, V) where V: Trait<U>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<U>` is not implemented for `i32`\n+   |\n+note: required by `Trait`\n+  --> $DIR/type-check-defaults.rs:40:1\n+   |\n+40 | trait Trait<T> {}\n+   | ^^^^^^^^^^^^^^\n+\n+error: aborting due to 9 previous errors\n "}]}