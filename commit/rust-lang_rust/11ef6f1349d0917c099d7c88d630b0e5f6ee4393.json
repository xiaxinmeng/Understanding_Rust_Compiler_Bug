{"sha": "11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZWY2ZjEzNDlkMDkxN2MwOTlkN2M4OGQ2MzBiMGU1ZjZlZTQzOTM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-24T20:00:03Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-26T02:15:09Z"}, "message": "Remove \"unboxed\" attribute in code referring to new closures.", "tree": {"sha": "279a0216e7ca16bff046801f4889b77846296786", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/279a0216e7ca16bff046801f4889b77846296786"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "html_url": "https://github.com/rust-lang/rust/commit/11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "458a6a2f6e9dfb6ed3d76f14418ff1f2f5e97f86", "url": "https://api.github.com/repos/rust-lang/rust/commits/458a6a2f6e9dfb6ed3d76f14418ff1f2f5e97f86", "html_url": "https://github.com/rust-lang/rust/commit/458a6a2f6e9dfb6ed3d76f14418ff1f2f5e97f86"}], "stats": {"total": 1078, "additions": 513, "deletions": 565}, "files": [{"sha": "c602a7f2d8e2faf3e9659e234fd8ed067fe1343e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -1732,7 +1732,7 @@ impl LintPass for Stability {\n                             ty::MethodStatic(def_id) => {\n                                 def_id\n                             }\n-                            ty::MethodStaticUnboxedClosure(def_id) => {\n+                            ty::MethodStaticClosure(def_id) => {\n                                 def_id\n                             }\n                             ty::MethodTypeParam(ty::MethodParam {\n@@ -1940,7 +1940,7 @@ impl LintPass for UnconditionalRecursion {\n                     ty::MethodTraitObject(_) => return false,\n \n                     // This `did` refers directly to the method definition.\n-                    ty::MethodStatic(did) | ty::MethodStaticUnboxedClosure(did) => did,\n+                    ty::MethodStatic(did) | ty::MethodStaticClosure(did) => did,\n \n                     // MethodTypeParam are methods from traits:\n "}, {"sha": "0ca3e2595ab87f202b3da5699fdf6ab0999c57d2", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -139,7 +139,7 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_adjustments = 0x51,\n     tag_table_moves_map = 0x52,\n     tag_table_capture_map = 0x53,\n-    tag_table_unboxed_closures = 0x54,\n+    tag_table_closures = 0x54,\n     tag_table_upvar_borrow_map = 0x55,\n     tag_table_capture_modes = 0x56,\n     tag_table_object_cast_map = 0x57,\n@@ -225,10 +225,10 @@ pub struct LinkMeta {\n     pub crate_hash: Svh,\n }\n \n-pub const tag_unboxed_closures: uint = 0x95;\n-pub const tag_unboxed_closure: uint = 0x96;\n-pub const tag_unboxed_closure_type: uint = 0x97;\n-pub const tag_unboxed_closure_kind: uint = 0x98;\n+pub const tag_closures: uint = 0x95;\n+pub const tag_closure: uint = 0x96;\n+pub const tag_closure_type: uint = 0x97;\n+pub const tag_closure_kind: uint = 0x98;\n \n pub const tag_struct_fields: uint = 0x99;\n pub const tag_struct_field: uint = 0x9a;"}, {"sha": "59465067f4ab5684503ecf33ca01b878f2501803", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -618,13 +618,12 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n     rbml_w.end_tag();\n }\n \n-fn encode_unboxed_closure_kind(rbml_w: &mut Encoder,\n-                               kind: ty::UnboxedClosureKind) {\n-    rbml_w.start_tag(tag_unboxed_closure_kind);\n+fn encode_closure_kind(rbml_w: &mut Encoder, kind: ty::ClosureKind) {\n+    rbml_w.start_tag(tag_closure_kind);\n     let ch = match kind {\n-        ty::FnUnboxedClosureKind => 'f',\n-        ty::FnMutUnboxedClosureKind => 'm',\n-        ty::FnOnceUnboxedClosureKind => 'o',\n+        ty::FnClosureKind => 'f',\n+        ty::FnMutClosureKind => 'm',\n+        ty::FnOnceClosureKind => 'o',\n     };\n     rbml_w.wr_str(&ch.to_string()[]);\n     rbml_w.end_tag();\n@@ -1838,24 +1837,19 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_unboxed_closures<'a>(\n-                           ecx: &'a EncodeContext,\n-                           rbml_w: &'a mut Encoder) {\n-    rbml_w.start_tag(tag_unboxed_closures);\n-    for (unboxed_closure_id, unboxed_closure) in ecx.tcx\n-                                                    .unboxed_closures\n-                                                    .borrow()\n-                                                    .iter() {\n-        if unboxed_closure_id.krate != ast::LOCAL_CRATE {\n+fn encode_closures<'a>(ecx: &'a EncodeContext, rbml_w: &'a mut Encoder) {\n+    rbml_w.start_tag(tag_closures);\n+    for (closure_id, closure) in ecx.tcx.closures.borrow().iter() {\n+        if closure_id.krate != ast::LOCAL_CRATE {\n             continue\n         }\n \n-        rbml_w.start_tag(tag_unboxed_closure);\n-        encode_def_id(rbml_w, *unboxed_closure_id);\n-        rbml_w.start_tag(tag_unboxed_closure_type);\n-        write_closure_type(ecx, rbml_w, &unboxed_closure.closure_type);\n+        rbml_w.start_tag(tag_closure);\n+        encode_def_id(rbml_w, *closure_id);\n+        rbml_w.start_tag(tag_closure_type);\n+        write_closure_type(ecx, rbml_w, &closure.closure_type);\n         rbml_w.end_tag();\n-        encode_unboxed_closure_kind(rbml_w, unboxed_closure.kind);\n+        encode_closure_kind(rbml_w, closure.kind);\n         rbml_w.end_tag();\n     }\n     rbml_w.end_tag();\n@@ -2069,7 +2063,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         native_lib_bytes: u64,\n         plugin_registrar_fn_bytes: u64,\n         macro_defs_bytes: u64,\n-        unboxed_closure_bytes: u64,\n+        closure_bytes: u64,\n         impl_bytes: u64,\n         misc_bytes: u64,\n         item_bytes: u64,\n@@ -2084,7 +2078,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         native_lib_bytes: 0,\n         plugin_registrar_fn_bytes: 0,\n         macro_defs_bytes: 0,\n-        unboxed_closure_bytes: 0,\n+        closure_bytes: 0,\n         impl_bytes: 0,\n         misc_bytes: 0,\n         item_bytes: 0,\n@@ -2156,8 +2150,8 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n \n     // Encode the types of all unboxed closures in this crate.\n     i = rbml_w.writer.tell().unwrap();\n-    encode_unboxed_closures(&ecx, &mut rbml_w);\n-    stats.unboxed_closure_bytes = rbml_w.writer.tell().unwrap() - i;\n+    encode_closures(&ecx, &mut rbml_w);\n+    stats.closure_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n     i = rbml_w.writer.tell().unwrap();"}, {"sha": "ecf40b0f1fc67c2be790e0e8ee1986a355bc0182", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -58,7 +58,7 @@ pub enum DefIdSource {\n     RegionParameter,\n \n     // Identifies an unboxed closure\n-    UnboxedClosureSource\n+    ClosureSource\n }\n \n // type conv_did = impl FnMut(DefIdSource, ast::DefId) -> ast::DefId;\n@@ -537,11 +537,11 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n       }\n       'k' => {\n           assert_eq!(next(st), '[');\n-          let did = parse_def_(st, UnboxedClosureSource, conv);\n+          let did = parse_def_(st, ClosureSource, conv);\n           let region = parse_region_(st, conv);\n           let substs = parse_substs_(st, conv);\n           assert_eq!(next(st), ']');\n-          return ty::mk_unboxed_closure(st.tcx, did,\n+          return ty::mk_closure(st.tcx, did,\n                   st.tcx.mk_region(region), st.tcx.mk_substs(substs));\n       }\n       'P' => {"}, {"sha": "54b930fbda9ca6ee4b029e8426a265b111d1aa8d", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -139,7 +139,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_unboxed_closure(def, region, substs) => {\n+        ty::ty_closure(def, region, substs) => {\n             mywrite!(w, \"k[{}|\", (cx.ds)(def));\n             enc_region(w, cx, *region);\n             enc_substs(w, cx, substs);"}, {"sha": "3409c8d92be31406fd58f6a6bacf9ee54851d6a3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 40, "deletions": 47, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -21,7 +21,7 @@ use metadata::encoder as e;\n use middle::region;\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n-use metadata::tydecode::{RegionParameter, UnboxedClosureSource};\n+use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n use middle::mem_categorization::Typer;\n use middle::subst;\n@@ -618,8 +618,8 @@ impl<'tcx> tr for MethodOrigin<'tcx> {\n     fn tr(&self, dcx: &DecodeContext) -> MethodOrigin<'tcx> {\n         match *self {\n             ty::MethodStatic(did) => ty::MethodStatic(did.tr(dcx)),\n-            ty::MethodStaticUnboxedClosure(did) => {\n-                ty::MethodStaticUnboxedClosure(did.tr(dcx))\n+            ty::MethodStaticClosure(did) => {\n+                ty::MethodStaticClosure(did.tr(dcx))\n             }\n             ty::MethodTypeParam(ref mp) => {\n                 ty::MethodTypeParam(\n@@ -643,24 +643,23 @@ impl<'tcx> tr for MethodOrigin<'tcx> {\n     }\n }\n \n-pub fn encode_unboxed_closure_kind(ebml_w: &mut Encoder,\n-                                   kind: ty::UnboxedClosureKind) {\n+pub fn encode_closure_kind(ebml_w: &mut Encoder, kind: ty::ClosureKind) {\n     use serialize::Encoder;\n \n-    ebml_w.emit_enum(\"UnboxedClosureKind\", |ebml_w| {\n+    ebml_w.emit_enum(\"ClosureKind\", |ebml_w| {\n         match kind {\n-            ty::FnUnboxedClosureKind => {\n-                ebml_w.emit_enum_variant(\"FnUnboxedClosureKind\", 0, 3, |_| {\n+            ty::FnClosureKind => {\n+                ebml_w.emit_enum_variant(\"FnClosureKind\", 0, 3, |_| {\n                     Ok(())\n                 })\n             }\n-            ty::FnMutUnboxedClosureKind => {\n-                ebml_w.emit_enum_variant(\"FnMutUnboxedClosureKind\", 1, 3, |_| {\n+            ty::FnMutClosureKind => {\n+                ebml_w.emit_enum_variant(\"FnMutClosureKind\", 1, 3, |_| {\n                     Ok(())\n                 })\n             }\n-            ty::FnOnceUnboxedClosureKind => {\n-                ebml_w.emit_enum_variant(\"FnOnceUnboxedClosureKind\",\n+            ty::FnOnceClosureKind => {\n+                ebml_w.emit_enum_variant(\"FnOnceClosureKind\",\n                                          2,\n                                          3,\n                                          |_| {\n@@ -736,7 +735,7 @@ impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             this.read_enum_variant(&[\"vtable_static\",\n                                      \"vtable_param\",\n                                      \"vtable_error\",\n-                                     \"vtable_unboxed_closure\"],\n+                                     \"vtable_closure\"],\n                                    |this, i| {\n                 Ok(match i {\n                   0 => {\n@@ -763,7 +762,7 @@ impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                     )\n                   }\n                   2 => {\n-                    ty::vtable_unboxed_closure(\n+                    ty::vtable_closure(\n                         this.read_enum_variant_arg(0u, |this| {\n                             Ok(this.read_def_id_nodcx(cdata))\n                         }).unwrap()\n@@ -865,8 +864,8 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     })\n                 }\n \n-                ty::MethodStaticUnboxedClosure(def_id) => {\n-                    this.emit_enum_variant(\"MethodStaticUnboxedClosure\", 1, 1, |this| {\n+                ty::MethodStaticClosure(def_id) => {\n+                    this.emit_enum_variant(\"MethodStaticClosure\", 1, 1, |this| {\n                         Ok(this.emit_def_id(def_id))\n                     })\n                 }\n@@ -1322,15 +1321,12 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for unboxed_closure in tcx.unboxed_closures\n-                              .borrow()\n-                              .get(&ast_util::local_def(id))\n-                              .iter() {\n-        rbml_w.tag(c::tag_table_unboxed_closures, |rbml_w| {\n+    for closure in tcx.closures.borrow().get(&ast_util::local_def(id)).iter() {\n+        rbml_w.tag(c::tag_table_closures, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_closure_type(ecx, &unboxed_closure.closure_type);\n-                encode_unboxed_closure_kind(rbml_w, unboxed_closure.kind)\n+                rbml_w.emit_closure_type(ecx, &closure.closure_type);\n+                encode_closure_kind(rbml_w, closure.kind)\n             })\n         })\n     }\n@@ -1369,8 +1365,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                            -> subst::Substs<'tcx>;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                     -> ty::AutoAdjustment<'tcx>;\n-    fn read_unboxed_closure<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                    -> ty::UnboxedClosure<'tcx>;\n+    fn read_closure<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                            -> ty::Closure<'tcx>;\n     fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::AutoDerefRef<'tcx>;\n     fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1436,7 +1432,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                   -> ty::MethodOrigin<'tcx>\n     {\n         self.read_enum(\"MethodOrigin\", |this| {\n-            let variants = &[\"MethodStatic\", \"MethodStaticUnboxedClosure\",\n+            let variants = &[\"MethodStatic\", \"MethodStaticClosure\",\n                              \"MethodTypeParam\", \"MethodTraitObject\"];\n             this.read_enum_variant(variants, |this, i| {\n                 Ok(match i {\n@@ -1447,7 +1443,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n                     1 => {\n                         let def_id = this.read_def_id(dcx);\n-                        ty::MethodStaticUnboxedClosure(def_id)\n+                        ty::MethodStaticClosure(def_id)\n                     }\n \n                     2 => {\n@@ -1797,8 +1793,8 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_unboxed_closure<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                    -> ty::UnboxedClosure<'tcx> {\n+    fn read_closure<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n+                            -> ty::Closure<'tcx> {\n         let closure_type = self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_ty_closure_data(\n                 doc.data,\n@@ -1808,21 +1804,21 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                 |s, a| this.convert_def_id(dcx, s, a)))\n         }).unwrap();\n         let variants = &[\n-            \"FnUnboxedClosureKind\",\n-            \"FnMutUnboxedClosureKind\",\n-            \"FnOnceUnboxedClosureKind\"\n+            \"FnClosureKind\",\n+            \"FnMutClosureKind\",\n+            \"FnOnceClosureKind\"\n         ];\n-        let kind = self.read_enum(\"UnboxedClosureKind\", |this| {\n+        let kind = self.read_enum(\"ClosureKind\", |this| {\n             this.read_enum_variant(variants, |_, i| {\n                 Ok(match i {\n-                    0 => ty::FnUnboxedClosureKind,\n-                    1 => ty::FnMutUnboxedClosureKind,\n-                    2 => ty::FnOnceUnboxedClosureKind,\n-                    _ => panic!(\"bad enum variant for ty::UnboxedClosureKind\"),\n+                    0 => ty::FnClosureKind,\n+                    1 => ty::FnMutClosureKind,\n+                    2 => ty::FnOnceClosureKind,\n+                    _ => panic!(\"bad enum variant for ty::ClosureKind\"),\n                 })\n             })\n         }).unwrap();\n-        ty::UnboxedClosure {\n+        ty::Closure {\n             closure_type: closure_type,\n             kind: kind,\n         }\n@@ -1864,7 +1860,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                       -> ast::DefId {\n         let r = match source {\n             NominalType | TypeWithId | RegionParameter => dcx.tr_def_id(did),\n-            TypeParameter | UnboxedClosureSource => dcx.tr_intern_def_id(did)\n+            TypeParameter | ClosureSource => dcx.tr_intern_def_id(did)\n         };\n         debug!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n         return r;\n@@ -1959,14 +1955,11 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(dcx);\n                         dcx.tcx.adjustments.borrow_mut().insert(id, adj);\n                     }\n-                    c::tag_table_unboxed_closures => {\n-                        let unboxed_closure =\n-                            val_dsr.read_unboxed_closure(dcx);\n-                        dcx.tcx\n-                           .unboxed_closures\n-                           .borrow_mut()\n-                           .insert(ast_util::local_def(id),\n-                                   unboxed_closure);\n+                    c::tag_table_closures => {\n+                        let closure =\n+                            val_dsr.read_closure(dcx);\n+                        dcx.tcx.closures.borrow_mut().insert(ast_util::local_def(id),\n+                                                             closure);\n                     }\n                     _ => {\n                         dcx.tcx.sess.bug("}, {"sha": "3db931002d23c05055c3f3332b15e7e9f6dbc404", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                             None => self.check_def_id(def_id)\n                         }\n                     }\n-                    ty::MethodStaticUnboxedClosure(_) => {}\n+                    ty::MethodStaticClosure(_) => {}\n                     ty::MethodTypeParam(ty::MethodParam {\n                         ref trait_ref,\n                         method_num: index,"}, {"sha": "70a7b4f13cc83e59be767ccee69a76c9b312475e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -26,7 +26,7 @@ use middle::mem_categorization::Typer;\n use middle::ty::{self};\n use middle::ty::{MethodCall, MethodObject, MethodTraitObject};\n use middle::ty::{MethodOrigin, MethodParam, MethodTypeParam};\n-use middle::ty::{MethodStatic, MethodStaticUnboxedClosure};\n+use middle::ty::{MethodStatic, MethodStaticClosure};\n use util::ppaux::Repr;\n \n use std::marker;\n@@ -257,13 +257,13 @@ impl OverloadedCallType {\n         OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n     }\n \n-    fn from_unboxed_closure(tcx: &ty::ctxt, closure_did: ast::DefId)\n-                            -> OverloadedCallType {\n+    fn from_closure(tcx: &ty::ctxt, closure_did: ast::DefId)\n+                    -> OverloadedCallType {\n         let trait_did =\n-            tcx.unboxed_closures\n+            tcx.closures\n                .borrow()\n                .get(&closure_did)\n-               .expect(\"OverloadedCallType::from_unboxed_closure: didn't \\\n+               .expect(\"OverloadedCallType::from_closure: didn't \\\n                         find closure id\")\n                .kind\n                .trait_did(tcx);\n@@ -276,8 +276,8 @@ impl OverloadedCallType {\n             MethodStatic(def_id) => {\n                 OverloadedCallType::from_method_id(tcx, def_id)\n             }\n-            MethodStaticUnboxedClosure(def_id) => {\n-                OverloadedCallType::from_unboxed_closure(tcx, def_id)\n+            MethodStaticClosure(def_id) => {\n+                OverloadedCallType::from_closure(tcx, def_id)\n             }\n             MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n             MethodTraitObject(MethodObject { ref trait_ref, .. }) => {"}, {"sha": "b33e5a802f1582f6a639431938abaf3c026d8709", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -28,7 +28,7 @@ pub enum SimplifiedType {\n     TupleSimplifiedType(uint),\n     TraitSimplifiedType(ast::DefId),\n     StructSimplifiedType(ast::DefId),\n-    UnboxedClosureSimplifiedType(ast::DefId),\n+    ClosureSimplifiedType(ast::DefId),\n     FunctionSimplifiedType(uint),\n     ParameterSimplifiedType,\n }\n@@ -74,8 +74,8 @@ pub fn simplify_type(tcx: &ty::ctxt,\n             let def_id = tcx.lang_items.owned_box().unwrap();\n             Some(StructSimplifiedType(def_id))\n         }\n-        ty::ty_unboxed_closure(def_id, _, _) => {\n-            Some(UnboxedClosureSimplifiedType(def_id))\n+        ty::ty_closure(def_id, _, _) => {\n+            Some(ClosureSimplifiedType(def_id))\n         }\n         ty::ty_tup(ref tys) => {\n             Some(TupleSimplifiedType(tys.len()))"}, {"sha": "b445215182c8b10db7ef7156b4d103b43843c872", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -514,15 +514,15 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n             Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n       }\n \n-      (&ty::ty_unboxed_closure(a_id, a_region, a_substs),\n-       &ty::ty_unboxed_closure(b_id, b_region, b_substs))\n+      (&ty::ty_closure(a_id, a_region, a_substs),\n+       &ty::ty_closure(b_id, b_region, b_substs))\n       if a_id == b_id => {\n-          // All ty_unboxed_closure types with the same id represent\n+          // All ty_closure types with the same id represent\n           // the (anonymous) type of the same closure expression. So\n           // all of their regions should be equated.\n           let region = try!(this.equate().regions(*a_region, *b_region));\n           let substs = try!(this.substs_variances(None, a_substs, b_substs));\n-          Ok(ty::mk_unboxed_closure(tcx, a_id, tcx.mk_region(region), tcx.mk_substs(substs)))\n+          Ok(ty::mk_closure(tcx, a_id, tcx.mk_region(region), tcx.mk_substs(substs)))\n       }\n \n       (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {"}, {"sha": "8e9911aaefa0a5d3fc673893912c2973a08317e1", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ty_bare_fn(..) |\n             ty::ty_trait(..) |\n             ty::ty_struct(..) |\n-            ty::ty_unboxed_closure(..) |\n+            ty::ty_closure(..) |\n             ty::ty_tup(..) |\n             ty::ty_projection(..) |\n             ty::ty_param(..) => {"}, {"sha": "43653a25eaeaa91f8d209a15ba29972d6e3861a7", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -113,11 +113,11 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn fn_trait_kind(&self, id: ast::DefId) -> Option<ty::UnboxedClosureKind> {\n+    pub fn fn_trait_kind(&self, id: ast::DefId) -> Option<ty::ClosureKind> {\n         let def_id_kinds = [\n-            (self.fn_trait(), ty::FnUnboxedClosureKind),\n-            (self.fn_mut_trait(), ty::FnMutUnboxedClosureKind),\n-            (self.fn_once_trait(), ty::FnOnceUnboxedClosureKind),\n+            (self.fn_trait(), ty::FnClosureKind),\n+            (self.fn_mut_trait(), ty::FnMutClosureKind),\n+            (self.fn_once_trait(), ty::FnOnceClosureKind),\n             ];\n \n         for &(opt_def_id, kind) in def_id_kinds.iter() {"}, {"sha": "0131b9f1491e7afbb5b467aa30ad05819b0a6ee1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -114,7 +114,7 @@ use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::region::CodeExtent;\n use middle::ty;\n-use middle::ty::UnboxedClosureTyper;\n+use middle::ty::ClosureTyper;\n use lint;\n use util::nodemap::NodeMap;\n \n@@ -1519,8 +1519,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n         let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n         match fn_ty.sty {\n-            ty::ty_unboxed_closure(closure_def_id, _, substs) =>\n-                self.ir.tcx.unboxed_closure_type(closure_def_id, substs).sig.output(),\n+            ty::ty_closure(closure_def_id, _, substs) =>\n+                self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n             _ =>\n                 ty::ty_fn_ret(fn_ty),\n         }"}, {"sha": "49e34d987990e398f42695f26e4a342086102c52", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -105,7 +105,7 @@ pub enum categorization<'tcx> {\n pub struct Upvar {\n     pub id: ty::UpvarId,\n     // Unboxed closure kinds are used even for old-style closures for simplicity\n-    pub kind: ty::UnboxedClosureKind,\n+    pub kind: ty::ClosureKind,\n     // Is this from an unboxed closure?  Used only for diagnostics.\n     pub is_unboxed: bool\n }\n@@ -269,7 +269,7 @@ pub type McResult<T> = Result<T, ()>;\n /// In the borrow checker, in contrast, type checking is complete and we\n /// know that no errors have occurred, so we simply consult the tcx and we\n /// can be sure that only `Ok` results will occur.\n-pub trait Typer<'tcx> : ty::UnboxedClosureTyper<'tcx> {\n+pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>>;\n@@ -596,8 +596,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           def::DefUpvar(var_id, fn_node_id, _) => {\n               let ty = try!(self.node_ty(fn_node_id));\n               match ty.sty {\n-                  ty::ty_unboxed_closure(closure_id, _, _) => {\n-                      let kind = self.typer.unboxed_closure_kind(closure_id);\n+                  ty::ty_closure(closure_id, _, _) => {\n+                      let kind = self.typer.closure_kind(closure_id);\n                       let mode = self.typer.capture_mode(fn_node_id);\n                       self.cat_upvar(id, span, var_id, fn_node_id, kind, mode, true)\n                   }\n@@ -631,7 +631,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                  span: Span,\n                  var_id: ast::NodeId,\n                  fn_node_id: ast::NodeId,\n-                 kind: ty::UnboxedClosureKind,\n+                 kind: ty::ClosureKind,\n                  mode: ast::CaptureClause,\n                  is_unboxed: bool)\n                  -> McResult<cmt<'tcx>> {\n@@ -666,12 +666,12 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         // Construct information about env pointer dereference, if any\n         let mutbl = match kind {\n-            ty::FnOnceUnboxedClosureKind => None, // None, env is by-value\n-            ty::FnMutUnboxedClosureKind => match mode { // Depends on capture type\n+            ty::FnOnceClosureKind => None, // None, env is by-value\n+            ty::FnMutClosureKind => match mode { // Depends on capture type\n                 ast::CaptureByValue => Some(var_mutbl), // Mutable if the original var is\n                 ast::CaptureByRef => Some(McDeclared) // Mutable regardless\n             },\n-            ty::FnUnboxedClosureKind => Some(McImmutable) // Never mutable\n+            ty::FnClosureKind => Some(McImmutable) // Never mutable\n         };\n         let env_info = mutbl.map(|env_mutbl| {\n             // Look up the node ID of the closure body so we can construct\n@@ -1566,7 +1566,7 @@ fn element_kind(t: Ty) -> ElementKind {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::UnboxedClosureKind {\n+impl<'tcx> Repr<'tcx> for ty::ClosureKind {\n     fn repr(&self, _: &ty::ctxt) -> String {\n         format!(\"Upvar({:?})\", self)\n     }\n@@ -1581,9 +1581,9 @@ impl<'tcx> Repr<'tcx> for Upvar {\n impl<'tcx> UserString<'tcx> for Upvar {\n     fn user_string(&self, _: &ty::ctxt) -> String {\n         let kind = match self.kind {\n-            ty::FnUnboxedClosureKind => \"Fn\",\n-            ty::FnMutUnboxedClosureKind => \"FnMut\",\n-            ty::FnOnceUnboxedClosureKind => \"FnOnce\",\n+            ty::FnClosureKind => \"Fn\",\n+            ty::FnMutClosureKind => \"FnMut\",\n+            ty::FnOnceClosureKind => \"FnOnce\",\n         };\n         format!(\"captured outer variable in an `{}` closure\", kind)\n     }"}, {"sha": "e3363aa8fb70a6f8c47c5a4593546db2975ce653", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -138,7 +138,7 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n             tt.principal_def_id().krate == ast::LOCAL_CRATE\n         }\n \n-        ty::ty_unboxed_closure(..) |\n+        ty::ty_closure(..) |\n         ty::ty_infer(..) |\n         ty::ty_open(..) |\n         ty::ty_err => {"}, {"sha": "d08857c96133eaac013260662fa1a4a74dbb9350", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -110,7 +110,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// `projection_ty` again.\n     pub fn normalize_projection_type<'a>(&mut self,\n                                          infcx: &InferCtxt<'a,'tcx>,\n-                                         typer: &ty::UnboxedClosureTyper<'tcx>,\n+                                         typer: &ty::ClosureTyper<'tcx>,\n                                          projection_ty: ty::ProjectionTy<'tcx>,\n                                          cause: ObligationCause<'tcx>)\n                                          -> Ty<'tcx>\n@@ -186,7 +186,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n     pub fn select_all_or_error<'a>(&mut self,\n                                    infcx: &InferCtxt<'a,'tcx>,\n-                                   typer: &ty::UnboxedClosureTyper<'tcx>)\n+                                   typer: &ty::ClosureTyper<'tcx>)\n                                    -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         try!(self.select_where_possible(infcx, typer));\n@@ -211,7 +211,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// results in `O(n^2)` performance (#18208).\n     pub fn select_new_obligations<'a>(&mut self,\n                                       infcx: &InferCtxt<'a,'tcx>,\n-                                      typer: &ty::UnboxedClosureTyper<'tcx>)\n+                                      typer: &ty::ClosureTyper<'tcx>)\n                                       -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx, typer);\n@@ -220,7 +220,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n     pub fn select_where_possible<'a>(&mut self,\n                                      infcx: &InferCtxt<'a,'tcx>,\n-                                     typer: &ty::UnboxedClosureTyper<'tcx>)\n+                                     typer: &ty::ClosureTyper<'tcx>)\n                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx, typer);"}, {"sha": "6e65301c51729015a877187cb1486e9e9c7cb8a3", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -236,7 +236,7 @@ pub enum Vtable<'tcx, N> {\n     /// ID is the ID of the closure expression. This is a `VtableImpl`\n     /// in spirit, but the impl is generated by the compiler and does\n     /// not appear in the source.\n-    VtableUnboxedClosure(ast::DefId, subst::Substs<'tcx>),\n+    VtableClosure(ast::DefId, subst::Substs<'tcx>),\n \n     /// Same as above, but for a fn pointer type with the given signature.\n     VtableFnPointer(ty::Ty<'tcx>),\n@@ -296,7 +296,7 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                       typer: &ty::UnboxedClosureTyper<'tcx>,\n+                                       typer: &ty::ClosureTyper<'tcx>,\n                                        ty: Ty<'tcx>,\n                                        bound: ty::BuiltinBound,\n                                        span: Span)\n@@ -361,7 +361,7 @@ pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n }\n \n pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                                 typer: &ty::UnboxedClosureTyper<'tcx>,\n+                                                 typer: &ty::ClosureTyper<'tcx>,\n                                                  ty: Ty<'tcx>,\n                                                  bound: ty::BuiltinBound,\n                                                  span: Span)\n@@ -446,7 +446,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         match *self {\n             VtableImpl(ref i) => i.iter_nested(),\n             VtableFnPointer(..) => (&[]).iter(),\n-            VtableUnboxedClosure(..) => (&[]).iter(),\n+            VtableClosure(..) => (&[]).iter(),\n             VtableParam(ref n) => n.iter(),\n             VtableObject(_) => (&[]).iter(),\n             VtableBuiltin(ref i) => i.iter_nested(),\n@@ -457,7 +457,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         match *self {\n             VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n             VtableFnPointer(ref sig) => VtableFnPointer((*sig).clone()),\n-            VtableUnboxedClosure(d, ref s) => VtableUnboxedClosure(d, s.clone()),\n+            VtableClosure(d, ref s) => VtableClosure(d, s.clone()),\n             VtableParam(ref n) => VtableParam(n.iter().map(op).collect()),\n             VtableObject(ref p) => VtableObject(p.clone()),\n             VtableBuiltin(ref b) => VtableBuiltin(b.map_nested(op)),\n@@ -470,7 +470,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         match self {\n             VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n             VtableFnPointer(sig) => VtableFnPointer(sig),\n-            VtableUnboxedClosure(d, s) => VtableUnboxedClosure(d, s),\n+            VtableClosure(d, s) => VtableClosure(d, s),\n             VtableParam(n) => VtableParam(n.into_iter().map(op).collect()),\n             VtableObject(p) => VtableObject(p),\n             VtableBuiltin(no) => VtableBuiltin(no.map_move_nested(op)),"}, {"sha": "ffb38091a873549524cd7b751ad4fdd90cb0003d", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -579,7 +579,7 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             // in `assemble_candidates_from_param_env`.\n         }\n         super::VtableBuiltin(..) |\n-        super::VtableUnboxedClosure(..) |\n+        super::VtableClosure(..) |\n         super::VtableFnPointer(..) => {\n             // These traits have no associated types.\n             selcx.tcx().sess.span_bug("}, {"sha": "abd669bc36c75a53e94b45e166a942445c446086", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -25,7 +25,7 @@ use super::{ObligationCauseCode, BuiltinDerivedObligation};\n use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n-use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure,\n+use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n             VtableFnPointer, VtableObject};\n use super::{VtableImplData, VtableObjectData, VtableBuiltinData};\n use super::object_safety;\n@@ -47,7 +47,7 @@ use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    closure_typer: &'cx (ty::UnboxedClosureTyper<'tcx>+'cx),\n+    closure_typer: &'cx (ty::ClosureTyper<'tcx>+'cx),\n \n     /// Freshener used specifically for skolemizing entries on the\n     /// obligation stack. This ensures that all entries on the stack\n@@ -143,7 +143,7 @@ enum SelectionCandidate<'tcx> {\n \n     /// Implementation of a `Fn`-family trait by one of the\n     /// anonymous types generated for a `||` expression.\n-    UnboxedClosureCandidate(/* closure */ ast::DefId, Substs<'tcx>),\n+    ClosureCandidate(/* closure */ ast::DefId, Substs<'tcx>),\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n@@ -181,7 +181,7 @@ enum EvaluationResult<'tcx> {\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-               closure_typer: &'cx ty::UnboxedClosureTyper<'tcx>)\n+               closure_typer: &'cx ty::ClosureTyper<'tcx>)\n                -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n@@ -192,7 +192,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-                      closure_typer: &'cx ty::UnboxedClosureTyper<'tcx>)\n+                      closure_typer: &'cx ty::ClosureTyper<'tcx>)\n                       -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n@@ -751,7 +751,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // For the time being, we ignore user-defined impls for builtin-bounds, other than\n                 // `Copy`.\n                 // (And unboxed candidates only apply to the Fn/FnMut/etc traits.)\n-                try!(self.assemble_unboxed_closure_candidates(obligation, &mut candidates));\n+                try!(self.assemble_closure_candidates(obligation, &mut candidates));\n                 try!(self.assemble_fn_pointer_candidates(obligation, &mut candidates));\n                 try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n                 self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n@@ -948,10 +948,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Note: the type parameters on an unboxed closure candidate are modeled as *output* type\n     /// parameters and hence do not affect whether this trait is a match or not. They will be\n     /// unified during the confirmation step.\n-    fn assemble_unboxed_closure_candidates(&mut self,\n-                                           obligation: &TraitObligation<'tcx>,\n-                                           candidates: &mut SelectionCandidateSet<'tcx>)\n-                                           -> Result<(),SelectionError<'tcx>>\n+    fn assemble_closure_candidates(&mut self,\n+                                   obligation: &TraitObligation<'tcx>,\n+                                   candidates: &mut SelectionCandidateSet<'tcx>)\n+                                   -> Result<(),SelectionError<'tcx>>\n     {\n         let kind = match self.fn_family_trait_kind(obligation.predicate.0.def_id()) {\n             Some(k) => k,\n@@ -960,7 +960,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::ty_unboxed_closure(id, _, ref substs) => (id, substs.clone()),\n+            ty::ty_closure(id, _, ref substs) => (id, substs.clone()),\n             ty::ty_infer(ty::TyVar(_)) => {\n                 candidates.ambiguous = true;\n                 return Ok(());\n@@ -973,12 +973,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                kind,\n                obligation.repr(self.tcx()));\n \n-        let closure_kind = self.closure_typer.unboxed_closure_kind(closure_def_id);\n+        let closure_kind = self.closure_typer.closure_kind(closure_def_id);\n \n         debug!(\"closure_kind = {:?}\", closure_kind);\n \n         if closure_kind == kind {\n-            candidates.vec.push(UnboxedClosureCandidate(closure_def_id, substs.clone()));\n+            candidates.vec.push(ClosureCandidate(closure_def_id, substs.clone()));\n         }\n \n         Ok(())\n@@ -1453,7 +1453,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(If(tys.clone()))\n             }\n \n-            ty::ty_unboxed_closure(def_id, _, substs) => {\n+            ty::ty_closure(def_id, _, substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n                 // closures particularly, we need the results of\n                 // inference to decide how to reflect the type of each\n@@ -1471,7 +1471,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     return Ok(ParameterBuiltin);\n                 }\n \n-                match self.closure_typer.unboxed_closure_upvars(def_id, substs) {\n+                match self.closure_typer.closure_upvars(def_id, substs) {\n                     Some(upvars) => {\n                         Ok(If(upvars.iter().map(|c| c.ty).collect()))\n                     }\n@@ -1616,9 +1616,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(VtableImpl(vtable_impl))\n             }\n \n-            UnboxedClosureCandidate(closure_def_id, substs) => {\n-                try!(self.confirm_unboxed_closure_candidate(obligation, closure_def_id, &substs));\n-                Ok(VtableUnboxedClosure(closure_def_id, substs))\n+            ClosureCandidate(closure_def_id, substs) => {\n+                try!(self.confirm_closure_candidate(obligation, closure_def_id, &substs));\n+                Ok(VtableClosure(closure_def_id, substs))\n             }\n \n             ObjectCandidate => {\n@@ -1894,20 +1894,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(self_ty)\n     }\n \n-    fn confirm_unboxed_closure_candidate(&mut self,\n-                                         obligation: &TraitObligation<'tcx>,\n-                                         closure_def_id: ast::DefId,\n-                                         substs: &Substs<'tcx>)\n-                                         -> Result<(),SelectionError<'tcx>>\n+    fn confirm_closure_candidate(&mut self,\n+                                 obligation: &TraitObligation<'tcx>,\n+                                 closure_def_id: ast::DefId,\n+                                 substs: &Substs<'tcx>)\n+                                 -> Result<(),SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_unboxed_closure_candidate({},{},{})\",\n+        debug!(\"confirm_closure_candidate({},{},{})\",\n                obligation.repr(self.tcx()),\n                closure_def_id.repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n-        let closure_type = self.closure_typer.unboxed_closure_type(closure_def_id, substs);\n+        let closure_type = self.closure_typer.closure_type(closure_def_id, substs);\n \n-        debug!(\"confirm_unboxed_closure_candidate: closure_def_id={} closure_type={}\",\n+        debug!(\"confirm_closure_candidate: closure_def_id={} closure_type={}\",\n                closure_def_id.repr(self.tcx()),\n                closure_type.repr(self.tcx()));\n \n@@ -1923,7 +1923,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             substs: self.tcx().mk_substs(trait_substs),\n         }));\n \n-        debug!(\"confirm_unboxed_closure_candidate(closure_def_id={}, trait_ref={})\",\n+        debug!(\"confirm_closure_candidate(closure_def_id={}, trait_ref={})\",\n                closure_def_id.repr(self.tcx()),\n                trait_ref.repr(self.tcx()));\n \n@@ -2259,15 +2259,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn fn_family_trait_kind(&self,\n                             trait_def_id: ast::DefId)\n-                            -> Option<ty::UnboxedClosureKind>\n+                            -> Option<ty::ClosureKind>\n     {\n         let tcx = self.tcx();\n         if Some(trait_def_id) == tcx.lang_items.fn_trait() {\n-            Some(ty::FnUnboxedClosureKind)\n+            Some(ty::FnClosureKind)\n         } else if Some(trait_def_id) == tcx.lang_items.fn_mut_trait() {\n-            Some(ty::FnMutUnboxedClosureKind)\n+            Some(ty::FnMutClosureKind)\n         } else if Some(trait_def_id) == tcx.lang_items.fn_once_trait() {\n-            Some(ty::FnOnceUnboxedClosureKind)\n+            Some(ty::FnOnceClosureKind)\n         } else {\n             None\n         }\n@@ -2318,8 +2318,8 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n             ObjectCandidate => {\n                 format!(\"ObjectCandidate\")\n             }\n-            UnboxedClosureCandidate(c, ref s) => {\n-                format!(\"UnboxedClosureCandidate({:?},{})\", c, s.repr(tcx))\n+            ClosureCandidate(c, ref s) => {\n+                format!(\"ClosureCandidate({:?},{})\", c, s.repr(tcx))\n             }\n         }\n     }"}, {"sha": "beb28260834acf4e8e46bae3828a1645ba5665b3", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -367,8 +367,8 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n             super::VtableImpl(ref v) =>\n                 v.repr(tcx),\n \n-            super::VtableUnboxedClosure(ref d, ref s) =>\n-                format!(\"VtableUnboxedClosure({},{})\",\n+            super::VtableClosure(ref d, ref s) =>\n+                format!(\"VtableClosure({},{})\",\n                         d.repr(tcx),\n                         s.repr(tcx)),\n "}, {"sha": "2407377a30063a12ae08b8851741cd30e74e7367", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 76, "deletions": 84, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -16,7 +16,7 @@ pub use self::BuiltinBound::*;\n pub use self::InferTy::*;\n pub use self::InferRegion::*;\n pub use self::ImplOrTraitItemId::*;\n-pub use self::UnboxedClosureKind::*;\n+pub use self::ClosureKind::*;\n pub use self::ast_ty_to_ty_cache_entry::*;\n pub use self::Variance::*;\n pub use self::AutoAdjustment::*;\n@@ -434,7 +434,7 @@ pub enum MethodOrigin<'tcx> {\n     MethodStatic(ast::DefId),\n \n     // fully statically resolved unboxed closure invocation\n-    MethodStaticUnboxedClosure(ast::DefId),\n+    MethodStaticClosure(ast::DefId),\n \n     // method invoked on a type parameter with a bounded trait\n     MethodTypeParam(MethodParam<'tcx>),\n@@ -569,7 +569,7 @@ pub enum vtable_origin<'tcx> {\n       Vtable automatically generated for an unboxed closure. The def ID is the\n       ID of the closure expression.\n      */\n-    vtable_unboxed_closure(ast::DefId),\n+    vtable_closure(ast::DefId),\n \n     /*\n       Asked to determine the vtable for ty_err. This is the value used\n@@ -788,7 +788,7 @@ pub struct ctxt<'tcx> {\n \n     /// Records the type of each unboxed closure. The def ID is the ID of the\n     /// expression defining the unboxed closure.\n-    pub unboxed_closures: RefCell<DefIdMap<UnboxedClosure<'tcx>>>,\n+    pub closures: RefCell<DefIdMap<Closure<'tcx>>>,\n \n     pub node_lint_levels: RefCell<FnvHashMap<(ast::NodeId, lint::LintId),\n                                               lint::LevelSource>>,\n@@ -913,7 +913,7 @@ impl<'tcx> ctxt<'tcx> {\n         sty_debug_print!(\n             self,\n             ty_enum, ty_uniq, ty_vec, ty_ptr, ty_rptr, ty_bare_fn, ty_trait,\n-            ty_struct, ty_unboxed_closure, ty_tup, ty_param, ty_open, ty_infer, ty_projection);\n+            ty_struct, ty_closure, ty_tup, ty_param, ty_open, ty_infer, ty_projection);\n \n         println!(\"Substs interner: #{}\", self.substs_interner.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n@@ -1376,7 +1376,7 @@ pub enum sty<'tcx> {\n     ty_trait(Box<TyTrait<'tcx>>),\n     ty_struct(DefId, &'tcx Substs<'tcx>),\n \n-    ty_unboxed_closure(DefId, &'tcx Region, &'tcx Substs<'tcx>),\n+    ty_closure(DefId, &'tcx Region, &'tcx Substs<'tcx>),\n \n     ty_tup(Vec<Ty<'tcx>>),\n \n@@ -2266,28 +2266,28 @@ pub struct ItemSubsts<'tcx> {\n \n /// Records information about each unboxed closure.\n #[derive(Clone)]\n-pub struct UnboxedClosure<'tcx> {\n+pub struct Closure<'tcx> {\n     /// The type of the unboxed closure.\n     pub closure_type: ClosureTy<'tcx>,\n     /// The kind of unboxed closure this is.\n-    pub kind: UnboxedClosureKind,\n+    pub kind: ClosureKind,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Show)]\n-pub enum UnboxedClosureKind {\n-    FnUnboxedClosureKind,\n-    FnMutUnboxedClosureKind,\n-    FnOnceUnboxedClosureKind,\n+pub enum ClosureKind {\n+    FnClosureKind,\n+    FnMutClosureKind,\n+    FnOnceClosureKind,\n }\n \n-impl UnboxedClosureKind {\n+impl ClosureKind {\n     pub fn trait_did(&self, cx: &ctxt) -> ast::DefId {\n         let result = match *self {\n-            FnUnboxedClosureKind => cx.lang_items.require(FnTraitLangItem),\n-            FnMutUnboxedClosureKind => {\n+            FnClosureKind => cx.lang_items.require(FnTraitLangItem),\n+            FnMutClosureKind => {\n                 cx.lang_items.require(FnMutTraitLangItem)\n             }\n-            FnOnceUnboxedClosureKind => {\n+            FnOnceClosureKind => {\n                 cx.lang_items.require(FnOnceTraitLangItem)\n             }\n         };\n@@ -2298,23 +2298,21 @@ impl UnboxedClosureKind {\n     }\n }\n \n-pub trait UnboxedClosureTyper<'tcx> {\n+pub trait ClosureTyper<'tcx> {\n     fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx>;\n \n-    fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind;\n+    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind;\n \n-    fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>;\n+    fn closure_type(&self,\n+                    def_id: ast::DefId,\n+                    substs: &subst::Substs<'tcx>)\n+                    -> ty::ClosureTy<'tcx>;\n \n     // Returns `None` if the upvar types cannot yet be definitively determined.\n-    fn unboxed_closure_upvars(&self,\n-                              def_id: ast::DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> Option<Vec<UnboxedClosureUpvar<'tcx>>>;\n+    fn closure_upvars(&self,\n+                      def_id: ast::DefId,\n+                      substs: &Substs<'tcx>)\n+                      -> Option<Vec<ClosureUpvar<'tcx>>>;\n }\n \n impl<'tcx> CommonTypes<'tcx> {\n@@ -2407,7 +2405,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         extern_const_variants: RefCell::new(DefIdMap()),\n         method_map: RefCell::new(FnvHashMap()),\n         dependency_formats: RefCell::new(FnvHashMap()),\n-        unboxed_closures: RefCell::new(DefIdMap()),\n+        closures: RefCell::new(DefIdMap()),\n         node_lint_levels: RefCell::new(FnvHashMap()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability),\n@@ -2454,19 +2452,16 @@ impl<'tcx> ctxt<'tcx> {\n         region\n     }\n \n-    pub fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind\n-    {\n-        self.unboxed_closures.borrow()[def_id].kind\n+    pub fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n+        self.closures.borrow()[def_id].kind\n     }\n \n-    pub fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>\n+    pub fn closure_type(&self,\n+                        def_id: ast::DefId,\n+                        substs: &subst::Substs<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n     {\n-        self.unboxed_closures.borrow()[def_id].closure_type.subst(self, substs)\n+        self.closures.borrow()[def_id].closure_type.subst(self, substs)\n     }\n }\n \n@@ -2574,7 +2569,7 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty_unboxed_closure(_, region, substs) => {\n+            &ty_closure(_, region, substs) => {\n                 self.add_region(*region);\n                 self.add_substs(substs);\n             }\n@@ -2843,10 +2838,10 @@ pub fn mk_struct<'tcx>(cx: &ctxt<'tcx>, struct_id: ast::DefId,\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n \n-pub fn mk_unboxed_closure<'tcx>(cx: &ctxt<'tcx>, closure_id: ast::DefId,\n-                                region: &'tcx Region, substs: &'tcx Substs<'tcx>)\n-                                -> Ty<'tcx> {\n-    mk_t(cx, ty_unboxed_closure(closure_id, region, substs))\n+pub fn mk_closure<'tcx>(cx: &ctxt<'tcx>, closure_id: ast::DefId,\n+                        region: &'tcx Region, substs: &'tcx Substs<'tcx>)\n+                        -> Ty<'tcx> {\n+    mk_t(cx, ty_closure(closure_id, region, substs))\n }\n \n pub fn mk_var<'tcx>(cx: &ctxt<'tcx>, v: TyVid) -> Ty<'tcx> {\n@@ -3057,7 +3052,7 @@ pub fn type_is_vec(ty: Ty) -> bool {\n pub fn type_is_structural(ty: Ty) -> bool {\n     match ty.sty {\n       ty_struct(..) | ty_tup(_) | ty_enum(..) |\n-      ty_vec(_, Some(_)) | ty_unboxed_closure(..) => true,\n+      ty_vec(_, Some(_)) | ty_closure(..) => true,\n       _ => type_is_slice(ty) | type_is_trait(ty)\n     }\n }\n@@ -3422,11 +3417,11 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 apply_lang_items(cx, did, res)\n             }\n \n-            ty_unboxed_closure(did, r, substs) => {\n+            ty_closure(did, r, substs) => {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut`\n                 // unboxed closure.\n                 let param_env = ty::empty_parameter_environment(cx);\n-                let upvars = unboxed_closure_upvars(&param_env, did, substs).unwrap();\n+                let upvars = closure_upvars(&param_env, did, substs).unwrap();\n                 TypeContents::union(upvars.as_slice(),\n                                     |f| tc_ty(cx, f.ty, cache))\n                     | borrowed_contents(*r, MutMutable)\n@@ -3690,7 +3685,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n \n             ty_err |\n             ty_infer(_) |\n-            ty_unboxed_closure(..) => {\n+            ty_closure(..) => {\n                 // this check is run on type definitions, so we don't expect to see\n                 // inference by-products or unboxed closure types\n                 cx.sess.bug(format!(\"requires check invoked on inapplicable type: {:?}\",\n@@ -3784,7 +3779,7 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n \n                 find_nonrepresentable(cx, sp, seen, iter)\n             }\n-            ty_unboxed_closure(..) => {\n+            ty_closure(..) => {\n                 // this check is run on type definitions, so we don't expect to see\n                 // unboxed closure types\n                 cx.sess.bug(format!(\"requires check invoked on inapplicable type: {:?}\",\n@@ -4698,7 +4693,7 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n         ty_struct(id, _) => {\n             format!(\"struct `{}`\", item_path_str(cx, id))\n         }\n-        ty_unboxed_closure(..) => \"closure\".to_string(),\n+        ty_closure(..) => \"closure\".to_string(),\n         ty_tup(_) => \"tuple\".to_string(),\n         ty_infer(TyVar(_)) => \"inferred type\".to_string(),\n         ty_infer(IntVar(_)) => \"integral variable\".to_string(),\n@@ -5118,7 +5113,7 @@ pub fn ty_to_def_id(ty: Ty) -> Option<ast::DefId> {\n             Some(tt.principal_def_id()),\n         ty_struct(id, _) |\n         ty_enum(id, _) |\n-        ty_unboxed_closure(id, _, _) =>\n+        ty_closure(id, _, _) =>\n             Some(id),\n         _ =>\n             None\n@@ -5626,17 +5621,17 @@ pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n }\n \n #[derive(Copy, Clone)]\n-pub struct UnboxedClosureUpvar<'tcx> {\n+pub struct ClosureUpvar<'tcx> {\n     pub def: def::Def,\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n }\n \n-// Returns a list of `UnboxedClosureUpvar`s for each upvar.\n-pub fn unboxed_closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n-                                    closure_id: ast::DefId,\n-                                    substs: &Substs<'tcx>)\n-                                    -> Option<Vec<UnboxedClosureUpvar<'tcx>>>\n+// Returns a list of `ClosureUpvar`s for each upvar.\n+pub fn closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n+                            closure_id: ast::DefId,\n+                            substs: &Substs<'tcx>)\n+                            -> Option<Vec<ClosureUpvar<'tcx>>>\n {\n     // Presently an unboxed closure type cannot \"escape\" out of a\n     // function, so we will only encounter ones that originated in the\n@@ -5660,9 +5655,9 @@ pub fn unboxed_closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n \n                         match capture_mode {\n                             ast::CaptureByValue => {\n-                                Some(UnboxedClosureUpvar { def: freevar.def,\n-                                                           span: freevar.span,\n-                                                           ty: freevar_ty })\n+                                Some(ClosureUpvar { def: freevar.def,\n+                                                    span: freevar.span,\n+                                                    ty: freevar_ty })\n                             }\n \n                             ast::CaptureByRef => {\n@@ -5688,7 +5683,7 @@ pub fn unboxed_closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n                                         freevar_ty\n                                     }\n                                 };\n-                                Some(UnboxedClosureUpvar {\n+                                Some(ClosureUpvar {\n                                     def: freevar.def,\n                                     span: freevar.span,\n                                     ty: freevar_ref_ty,\n@@ -6240,7 +6235,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                 ty_open(_) => byte!(22),\n                 ty_infer(_) => unreachable!(),\n                 ty_err => byte!(23),\n-                ty_unboxed_closure(d, r, _) => {\n+                ty_closure(d, r, _) => {\n                     byte!(24);\n                     did(state, d);\n                     region(state, *r);\n@@ -6476,32 +6471,29 @@ impl<'a,'tcx> mc::Typer<'tcx> for ParameterEnvironment<'a,'tcx> {\n     }\n }\n \n-impl<'a,'tcx> UnboxedClosureTyper<'tcx> for ty::ParameterEnvironment<'a,'tcx> {\n+impl<'a,'tcx> ClosureTyper<'tcx> for ty::ParameterEnvironment<'a,'tcx> {\n     fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n         self\n     }\n \n-    fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind\n-    {\n-        self.tcx.unboxed_closure_kind(def_id)\n+    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n+        self.tcx.closure_kind(def_id)\n     }\n \n-    fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>\n+    fn closure_type(&self,\n+                    def_id: ast::DefId,\n+                    substs: &subst::Substs<'tcx>)\n+                    -> ty::ClosureTy<'tcx>\n     {\n-        self.tcx.unboxed_closure_type(def_id, substs)\n+        self.tcx.closure_type(def_id, substs)\n     }\n \n-    fn unboxed_closure_upvars(&self,\n-                              def_id: ast::DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> Option<Vec<UnboxedClosureUpvar<'tcx>>>\n+    fn closure_upvars(&self,\n+                      def_id: ast::DefId,\n+                      substs: &Substs<'tcx>)\n+                      -> Option<Vec<ClosureUpvar<'tcx>>>\n     {\n-        unboxed_closure_upvars(self, def_id, substs)\n+        closure_upvars(self, def_id, substs)\n     }\n }\n \n@@ -6533,7 +6525,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_struct(_, substs) => {\n                 accum_substs(accumulator, substs);\n             }\n-            ty_unboxed_closure(_, region, substs) => {\n+            ty_closure(_, region, substs) => {\n                 accumulator.push(*region);\n                 accum_substs(accumulator, substs);\n             }\n@@ -6826,8 +6818,8 @@ impl<'tcx> Repr<'tcx> for vtable_origin<'tcx> {\n                 format!(\"vtable_param({:?}, {})\", x, y)\n             }\n \n-            vtable_unboxed_closure(def_id) => {\n-                format!(\"vtable_unboxed_closure({:?})\", def_id)\n+            vtable_closure(def_id) => {\n+                format!(\"vtable_closure({:?})\", def_id)\n             }\n \n             vtable_error => {\n@@ -7064,7 +7056,7 @@ impl<'tcx> HasProjectionTypes for ClosureTy<'tcx> {\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for UnboxedClosureUpvar<'tcx> {\n+impl<'tcx> HasProjectionTypes for ClosureUpvar<'tcx> {\n     fn has_projection_types(&self) -> bool {\n         self.ty.has_projection_types()\n     }\n@@ -7285,9 +7277,9 @@ impl<'tcx> Repr<'tcx> for ClosureTy<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for UnboxedClosureUpvar<'tcx> {\n+impl<'tcx> Repr<'tcx> for ClosureUpvar<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"UnboxedClosureUpvar({},{})\",\n+        format!(\"ClosureUpvar({},{})\",\n                 self.def.repr(tcx),\n                 self.ty.repr(tcx))\n     }"}, {"sha": "86552705963c9865d03890e79d4a7eff6cebd0c5", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -304,8 +304,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::MethodOrigin<'tcx> {\n             ty::MethodStatic(def_id) => {\n                 ty::MethodStatic(def_id)\n             }\n-            ty::MethodStaticUnboxedClosure(def_id) => {\n-                ty::MethodStaticUnboxedClosure(def_id)\n+            ty::MethodStaticClosure(def_id) => {\n+                ty::MethodStaticClosure(def_id)\n             }\n             ty::MethodTypeParam(ref param) => {\n                 ty::MethodTypeParam(ty::MethodParam {\n@@ -337,8 +337,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::vtable_origin<'tcx> {\n             ty::vtable_param(n, b) => {\n                 ty::vtable_param(n, b)\n             }\n-            ty::vtable_unboxed_closure(def_id) => {\n-                ty::vtable_unboxed_closure(def_id)\n+            ty::vtable_closure(def_id) => {\n+                ty::vtable_closure(def_id)\n             }\n             ty::vtable_error => {\n                 ty::vtable_error\n@@ -499,8 +499,8 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<'tcx, N> {\n         match *self {\n             traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n-            traits::VtableUnboxedClosure(d, ref s) => {\n-                traits::VtableUnboxedClosure(d, s.fold_with(folder))\n+            traits::VtableClosure(d, ref s) => {\n+                traits::VtableClosure(d, s.fold_with(folder))\n             }\n             traits::VtableFnPointer(ref d) => {\n                 traits::VtableFnPointer(d.fold_with(folder))\n@@ -545,9 +545,9 @@ impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::UnboxedClosureUpvar<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::UnboxedClosureUpvar<'tcx> {\n-        ty::UnboxedClosureUpvar {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureUpvar<'tcx> {\n+        ty::ClosureUpvar {\n             def: self.def,\n             span: self.span,\n             ty: self.ty.fold_with(folder),\n@@ -624,10 +624,10 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             let substs = substs.fold_with(this);\n             ty::ty_struct(did, this.tcx().mk_substs(substs))\n         }\n-        ty::ty_unboxed_closure(did, ref region, ref substs) => {\n+        ty::ty_closure(did, ref region, ref substs) => {\n             let r = region.fold_with(this);\n             let s = substs.fold_with(this);\n-            ty::ty_unboxed_closure(did, this.tcx().mk_region(r), this.tcx().mk_substs(s))\n+            ty::ty_closure(did, this.tcx().mk_region(r), this.tcx().mk_substs(s))\n         }\n         ty::ty_projection(ref data) => {\n             ty::ty_projection(data.fold_with(this))"}, {"sha": "bf8216144eff6f452be63ddfdb102cc6fbeae1ce", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> TypeWalker<'tcx> {\n             }\n             ty::ty_enum(_, ref substs) |\n             ty::ty_struct(_, ref substs) |\n-            ty::ty_unboxed_closure(_, _, ref substs) => {\n+            ty::ty_closure(_, _, ref substs) => {\n                 self.push_reversed(substs.types.as_slice());\n             }\n             ty::ty_tup(ref ts) => {"}, {"sha": "f93f5903e014da7cd71b3e6b917839f043caebc3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -20,7 +20,7 @@ use middle::ty::{mt, Ty, ParamTy};\n use middle::ty::{ty_bool, ty_char, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn};\n use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n-use middle::ty::{ty_unboxed_closure};\n+use middle::ty::{ty_closure};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n use middle::ty_fold::TypeFoldable;\n@@ -414,9 +414,8 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                     data.item_name.user_string(cx))\n         }\n         ty_str => \"str\".to_string(),\n-        ty_unboxed_closure(ref did, _, substs) => {\n-            let unboxed_closures = cx.unboxed_closures.borrow();\n-            unboxed_closures.get(did).map(|cl| {\n+        ty_closure(ref did, _, substs) => {\n+            cx.closures.borrow().get(did).map(|cl| {\n                 closure_to_string(cx, &cl.closure_type.subst(cx, substs))\n             }).unwrap_or_else(|| {\n                 if did.krate == ast::LOCAL_CRATE {\n@@ -1021,8 +1020,8 @@ impl<'tcx> Repr<'tcx> for ty::MethodOrigin<'tcx> {\n             &ty::MethodStatic(def_id) => {\n                 format!(\"MethodStatic({})\", def_id.repr(tcx))\n             }\n-            &ty::MethodStaticUnboxedClosure(def_id) => {\n-                format!(\"MethodStaticUnboxedClosure({})\", def_id.repr(tcx))\n+            &ty::MethodStaticClosure(def_id) => {\n+                format!(\"MethodStaticClosure({})\", def_id.repr(tcx))\n             }\n             &ty::MethodTypeParam(ref p) => {\n                 p.repr(tcx)"}, {"sha": "b66419420e9a127b8f782e99145a9a2fcc426d9f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -806,7 +806,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     mc::cat_upvar(mc::Upvar { kind, .. }) => kind,\n                     _ => unreachable!()\n                 };\n-                if kind == ty::FnUnboxedClosureKind {\n+                if kind == ty::FnClosureKind {\n                     self.bccx.span_err(\n                         assignment_span,\n                         &format!(\"cannot assign to {}\","}, {"sha": "449f2a4d00643d48837678524bab262f16a958a2", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -845,7 +845,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             mc::cat_upvar(mc::Upvar { kind, .. }) => kind,\n                             _ => unreachable!()\n                         };\n-                        if kind == ty::FnUnboxedClosureKind {\n+                        if kind == ty::FnClosureKind {\n                             self.tcx.sess.span_help(\n                                 self.tcx.map.span(upvar_id.closure_expr_id),\n                                 \"consider changing this closure to take \\"}, {"sha": "b89853fb5cc65db366c0d6187c612b03db16422c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -40,7 +40,7 @@ use rustc::middle::privacy::{ExportedItems, PublicItems, LastPrivateMap};\n use rustc::middle::privacy::{ExternalExports};\n use rustc::middle::ty::{MethodTypeParam, MethodStatic};\n use rustc::middle::ty::{MethodCall, MethodMap, MethodOrigin, MethodParam};\n-use rustc::middle::ty::{MethodStaticUnboxedClosure, MethodObject};\n+use rustc::middle::ty::{MethodStaticClosure, MethodObject};\n use rustc::middle::ty::{MethodTraitObject};\n use rustc::middle::ty::{self, Ty};\n use rustc::util::nodemap::{NodeMap, NodeSet};\n@@ -816,7 +816,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             MethodStatic(method_id) => {\n                 self.check_static_method(span, method_id, ident)\n             }\n-            MethodStaticUnboxedClosure(_) => {}\n+            MethodStaticClosure(_) => {}\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n             MethodTypeParam(MethodParam { ref trait_ref, .. }) |"}, {"sha": "71ca6a4db03d34694bb32b373a8165b431464652", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -920,7 +920,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let method_callee = &(*method_map)[ty::MethodCall::expr(ex.id)];\n         let (def_id, decl_id) = match method_callee.origin {\n             ty::MethodStatic(def_id) |\n-            ty::MethodStaticUnboxedClosure(def_id) => {\n+            ty::MethodStaticClosure(def_id) => {\n                 // method invoked on an object with a concrete type (not a static method)\n                 let decl_id =\n                     match ty::trait_item_of_item(&self.analysis.ty_cx,"}, {"sha": "519a7e19125101653a93f282e9d5bc81e9ba630b", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -51,7 +51,7 @@ use std::rc::Rc;\n use llvm::{ValueRef, True, IntEQ, IntNE};\n use back::abi::FAT_PTR_ADDR;\n use middle::subst;\n-use middle::ty::{self, Ty, UnboxedClosureTyper};\n+use middle::ty::{self, Ty, ClosureTyper};\n use middle::ty::Disr;\n use syntax::ast;\n use syntax::attr;\n@@ -169,9 +169,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             Univariant(mk_struct(cx, &ftys[], packed, t), dtor)\n         }\n-        ty::ty_unboxed_closure(def_id, _, substs) => {\n-            let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n-            let upvars = typer.unboxed_closure_upvars(def_id, substs).unwrap();\n+        ty::ty_closure(def_id, _, substs) => {\n+            let typer = NormalizingClosureTyper::new(cx.tcx());\n+            let upvars = typer.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n             Univariant(mk_struct(cx, &upvar_types[], false, t), false)\n         }"}, {"sha": "a73af16d7ecb4937c0ffea44840c1bbac4fe936a", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -43,7 +43,7 @@ use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::subst;\n use middle::weak_lang_items;\n use middle::subst::{Subst, Substs};\n-use middle::ty::{self, Ty, UnboxedClosureTyper};\n+use middle::ty::{self, Ty, ClosureTyper};\n use session::config::{self, NoDebugInfo};\n use session::Session;\n use trans::_match;\n@@ -255,27 +255,25 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n     f\n }\n \n-pub fn self_type_for_unboxed_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                               closure_id: ast::DefId,\n-                                               fn_ty: Ty<'tcx>)\n-                                               -> Ty<'tcx>\n+pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                       closure_id: ast::DefId,\n+                                       fn_ty: Ty<'tcx>)\n+                                       -> Ty<'tcx>\n {\n-    let unboxed_closure_kind = ccx.tcx().unboxed_closure_kind(closure_id);\n-    match unboxed_closure_kind {\n-        ty::FnUnboxedClosureKind => {\n+    let closure_kind = ccx.tcx().closure_kind(closure_id);\n+    match closure_kind {\n+        ty::FnClosureKind => {\n             ty::mk_imm_rptr(ccx.tcx(), ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n-        ty::FnMutUnboxedClosureKind => {\n+        ty::FnMutClosureKind => {\n             ty::mk_mut_rptr(ccx.tcx(), ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n-        ty::FnOnceUnboxedClosureKind => fn_ty\n+        ty::FnOnceClosureKind => fn_ty\n     }\n }\n \n-pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n-                                -> ty::UnboxedClosureKind {\n-    let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n-    (*unboxed_closures)[closure_id].kind\n+pub fn kind_for_closure(ccx: &CrateContext, closure_id: ast::DefId) -> ty::ClosureKind {\n+    ccx.tcx().closures.borrow()[closure_id].kind\n }\n \n pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -295,10 +293,10 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref f) => {\n             (&f.sig, f.abi, None)\n         }\n-        ty::ty_unboxed_closure(closure_did, _, substs) => {\n-            let typer = common::NormalizingUnboxedClosureTyper::new(ccx.tcx());\n-            function_type = typer.unboxed_closure_type(closure_did, substs);\n-            let self_type = self_type_for_unboxed_closure(ccx, closure_did, fn_ty);\n+        ty::ty_closure(closure_did, _, substs) => {\n+            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n+            function_type = typer.closure_type(closure_did, substs);\n+            let self_type = self_type_for_closure(ccx, closure_did, fn_ty);\n             let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n             debug!(\"decl_rust_fn: function_type={} self_type={}\",\n                    function_type.repr(ccx.tcx()),\n@@ -715,10 +713,10 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               }\n           })\n       }\n-      ty::ty_unboxed_closure(def_id, _, substs) => {\n+      ty::ty_closure(def_id, _, substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          let typer = common::NormalizingUnboxedClosureTyper::new(cx.tcx());\n-          let upvars = typer.unboxed_closure_upvars(def_id, substs).unwrap();\n+          let typer = common::NormalizingClosureTyper::new(cx.tcx());\n+          let upvars = typer.closure_upvars(def_id, substs).unwrap();\n           for (i, upvar) in upvars.iter().enumerate() {\n               let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llupvar, upvar.ty);\n@@ -1626,14 +1624,13 @@ fn copy_args_to_allocas<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bcx\n }\n \n-fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n-                                        mut bcx: Block<'blk, 'tcx>,\n-                                        arg_scope: cleanup::CustomScopeIndex,\n-                                        args: &[ast::Arg],\n-                                        arg_datums: Vec<RvalueDatum<'tcx>>,\n-                                        monomorphized_arg_types: &[Ty<'tcx>])\n-                                        -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"copy_unboxed_closure_args_to_allocas\");\n+fn copy_closure_args_to_allocas<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                            arg_scope: cleanup::CustomScopeIndex,\n+                                            args: &[ast::Arg],\n+                                            arg_datums: Vec<RvalueDatum<'tcx>>,\n+                                            monomorphized_arg_types: &[Ty<'tcx>])\n+                                            -> Block<'blk, 'tcx> {\n+    let _icx = push_ctxt(\"copy_closure_args_to_allocas\");\n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n \n     assert_eq!(arg_datums.len(), 1);\n@@ -1822,7 +1819,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n \n         // Tuple up closure argument types for the \"rust-call\" ABI.\n-        closure::UnboxedClosure(..) => {\n+        closure::Closure(..) => {\n             vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n         }\n     };\n@@ -1850,8 +1847,8 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                  &decl.inputs[],\n                                  arg_datums)\n         }\n-        closure::UnboxedClosure(..) => {\n-            copy_unboxed_closure_args_to_allocas(\n+        closure::Closure(..) => {\n+            copy_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n                 &decl.inputs[],\n@@ -2430,9 +2427,9 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n     let function_type;\n     let (fn_sig, abi, has_env) = match fn_ty.sty {\n         ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, false),\n-        ty::ty_unboxed_closure(closure_did, _, substs) => {\n-            let typer = common::NormalizingUnboxedClosureTyper::new(ccx.tcx());\n-            function_type = typer.unboxed_closure_type(closure_did, substs);\n+        ty::ty_closure(closure_did, _, substs) => {\n+            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n+            function_type = typer.closure_type(closure_did, substs);\n             (&function_type.sig, RustCall, true)\n         }\n         _ => ccx.sess().bug(\"expected closure or function.\")\n@@ -2449,7 +2446,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n     let input_tys = match fn_ty.sty {\n-        ty::ty_unboxed_closure(_, _, _) => {\n+        ty::ty_closure(_, _, _) => {\n             assert!(abi == RustCall);\n \n             match fn_sig.inputs[0].sty {"}, {"sha": "06fb743c495a8cde606825662a1209c71573a3c6", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -458,9 +458,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     };\n \n     // If this is an unboxed closure, redirect to it.\n-    match closure::get_or_create_declaration_if_unboxed_closure(ccx,\n-                                                                def_id,\n-                                                                &substs) {\n+    match closure::get_or_create_declaration_if_closure(ccx, def_id, &substs) {\n         None => {}\n         Some(llfn) => return llfn,\n     }"}, {"sha": "9001b842cc87e06467444a65835989c618655862", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -23,32 +23,31 @@ use trans::debuginfo;\n use trans::expr;\n use trans::monomorphize::{self, MonoId};\n use trans::type_of::*;\n-use middle::ty::{self, UnboxedClosureTyper};\n+use middle::ty::{self, ClosureTyper};\n use middle::subst::{Substs};\n use session::config::FullDebugInfo;\n \n use syntax::ast;\n use syntax::ast_util;\n \n \n-fn load_unboxed_closure_environment<'blk, 'tcx>(\n-                                    bcx: Block<'blk, 'tcx>,\n-                                    arg_scope_id: ScopeId,\n-                                    freevar_mode: ast::CaptureClause,\n-                                    freevars: &[ty::Freevar])\n-                                    -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::load_unboxed_closure_environment\");\n+fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                        arg_scope_id: ScopeId,\n+                                        freevar_mode: ast::CaptureClause,\n+                                        freevars: &[ty::Freevar])\n+                                        -> Block<'blk, 'tcx> {\n+    let _icx = push_ctxt(\"closure::load_closure_environment\");\n \n     // Special case for small by-value selfs.\n     let closure_id = ast_util::local_def(bcx.fcx.id);\n-    let self_type = self_type_for_unboxed_closure(bcx.ccx(), closure_id,\n+    let self_type = self_type_for_closure(bcx.ccx(), closure_id,\n                                                   node_id_type(bcx, closure_id.node));\n-    let kind = kind_for_unboxed_closure(bcx.ccx(), closure_id);\n-    let llenv = if kind == ty::FnOnceUnboxedClosureKind &&\n+    let kind = kind_for_closure(bcx.ccx(), closure_id);\n+    let llenv = if kind == ty::FnOnceClosureKind &&\n             !arg_is_indirect(bcx.ccx(), self_type) {\n         let datum = rvalue_scratch_datum(bcx,\n                                          self_type,\n-                                         \"unboxed_closure_env\");\n+                                         \"closure_env\");\n         store_ty(bcx, bcx.fcx.llenv.unwrap(), datum.val, self_type);\n         datum.val\n     } else {\n@@ -77,7 +76,7 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n         let def_id = freevar.def.def_id();\n         bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvar_ptr);\n \n-        if kind == ty::FnOnceUnboxedClosureKind && freevar_mode == ast::CaptureByValue {\n+        if kind == ty::FnOnceClosureKind && freevar_mode == ast::CaptureByValue {\n             bcx.fcx.schedule_drop_mem(arg_scope_id,\n                                       upvar_ptr,\n                                       node_id_type(bcx, def_id.node))\n@@ -100,8 +99,8 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n #[derive(PartialEq)]\n pub enum ClosureKind<'tcx> {\n     NotClosure,\n-    // See load_unboxed_closure_environment.\n-    UnboxedClosure(ast::CaptureClause)\n+    // See load_closure_environment.\n+    Closure(ast::CaptureClause)\n }\n \n pub struct ClosureEnv<'a, 'tcx> {\n@@ -127,21 +126,21 @@ impl<'a, 'tcx> ClosureEnv<'a, 'tcx> {\n \n         match self.kind {\n             NotClosure => bcx,\n-            UnboxedClosure(freevar_mode) => {\n-                load_unboxed_closure_environment(bcx, arg_scope, freevar_mode, self.freevars)\n+            Closure(freevar_mode) => {\n+                load_closure_environment(bcx, arg_scope, freevar_mode, self.freevars)\n             }\n         }\n     }\n }\n \n /// Returns the LLVM function declaration for an unboxed closure, creating it\n /// if necessary. If the ID does not correspond to a closure ID, returns None.\n-pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                              closure_id: ast::DefId,\n-                                                              substs: &Substs<'tcx>)\n-                                                              -> Option<Datum<'tcx, Rvalue>> {\n-    if !ccx.tcx().unboxed_closures.borrow().contains_key(&closure_id) {\n         // Not an unboxed closure.\n+pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                      closure_id: ast::DefId,\n+                                                      substs: &Substs<'tcx>)\n+                                                      -> Option<Datum<'tcx, Rvalue>> {\n+    if !ccx.tcx().closures.borrow().contains_key(&closure_id) {\n         return None\n     }\n \n@@ -152,66 +151,65 @@ pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext\n     // duplicate declarations\n     let function_type = erase_regions(ccx.tcx(), &function_type);\n     let params = match function_type.sty {\n-        ty::ty_unboxed_closure(_, _, ref substs) => substs.types.clone(),\n+        ty::ty_closure(_, _, ref substs) => substs.types.clone(),\n         _ => unreachable!()\n     };\n     let mono_id = MonoId {\n         def: closure_id,\n         params: params\n     };\n \n-    match ccx.unboxed_closure_vals().borrow().get(&mono_id) {\n+    match ccx.closure_vals().borrow().get(&mono_id) {\n         Some(&llfn) => {\n-            debug!(\"get_or_create_declaration_if_unboxed_closure(): found \\\n+            debug!(\"get_or_create_declaration_if_closure(): found \\\n                     closure\");\n             return Some(Datum::new(llfn, function_type, Rvalue::new(ByValue)))\n         }\n         None => {}\n     }\n \n     let symbol = ccx.tcx().map.with_path(closure_id.node, |path| {\n-        mangle_internal_name_by_path_and_seq(path, \"unboxed_closure\")\n+        mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n \n     let llfn = decl_internal_rust_fn(ccx, function_type, &symbol[]);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n \n-    debug!(\"get_or_create_declaration_if_unboxed_closure(): inserting new \\\n+    debug!(\"get_or_create_declaration_if_closure(): inserting new \\\n             closure {:?} (type {})\",\n            mono_id,\n            ccx.tn().type_to_string(val_ty(llfn)));\n-    ccx.unboxed_closure_vals().borrow_mut().insert(mono_id, llfn);\n+    ccx.closure_vals().borrow_mut().insert(mono_id, llfn);\n \n     Some(Datum::new(llfn, function_type, Rvalue::new(ByValue)))\n }\n \n-pub fn trans_unboxed_closure<'blk, 'tcx>(\n-                             mut bcx: Block<'blk, 'tcx>,\n-                             decl: &ast::FnDecl,\n-                             body: &ast::Block,\n-                             id: ast::NodeId,\n-                             dest: expr::Dest)\n-                             -> Block<'blk, 'tcx>\n+pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                      decl: &ast::FnDecl,\n+                                      body: &ast::Block,\n+                                      id: ast::NodeId,\n+                                      dest: expr::Dest)\n+                                      -> Block<'blk, 'tcx>\n {\n-    let _icx = push_ctxt(\"closure::trans_unboxed_closure\");\n+    let _icx = push_ctxt(\"closure::trans_closure\");\n \n-    debug!(\"trans_unboxed_closure()\");\n+    debug!(\"trans_closure()\");\n \n     let closure_id = ast_util::local_def(id);\n-    let llfn = get_or_create_declaration_if_unboxed_closure(\n+    let llfn = get_or_create_declaration_if_closure(\n         bcx.ccx(),\n         closure_id,\n         bcx.fcx.param_substs).unwrap();\n \n     // Get the type of this closure. Use the current `param_substs` as\n     // the closure substitutions. This makes sense because the closure\n     // takes the same set of type arguments as the enclosing fn, and\n-    // this function (`trans_unboxed_closure`) is invoked at the point\n+    // this function (`trans_closure`) is invoked at the point\n     // of the closure expression.\n-    let typer = NormalizingUnboxedClosureTyper::new(bcx.tcx());\n-    let function_type = typer.unboxed_closure_type(closure_id, bcx.fcx.param_substs);\n+    let typer = NormalizingClosureTyper::new(bcx.tcx());\n+    let function_type = typer.closure_type(closure_id, bcx.fcx.param_substs);\n \n     let freevars: Vec<ty::Freevar> =\n         ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n@@ -229,15 +227,15 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                   sig.output,\n                   function_type.abi,\n                   ClosureEnv::new(&freevars[],\n-                                  UnboxedClosure(freevar_mode)));\n+                                  Closure(freevar_mode)));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size unboxed closure (in which case dest will be\n     // `Ignore`) and we must still generate the closure body.\n     let dest_addr = match dest {\n         expr::SaveIn(p) => p,\n         expr::Ignore => {\n-            debug!(\"trans_unboxed_closure() ignoring result\");\n+            debug!(\"trans_closure() ignoring result\");\n             return bcx\n         }\n     };"}, {"sha": "a5c4df7dbb94290eadd1f462a0476816265f41d6", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -248,7 +248,7 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     }\n     match ty.sty {\n         ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) | ty::ty_vec(_, Some(_)) |\n-        ty::ty_unboxed_closure(..) => {\n+        ty::ty_closure(..) => {\n             let llty = sizing_type_of(ccx, ty);\n             llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n         }\n@@ -693,35 +693,32 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n }\n \n-impl<'blk, 'tcx> ty::UnboxedClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n+impl<'blk, 'tcx> ty::ClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n     fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx> {\n         &self.fcx.param_env\n     }\n \n-    fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind\n-    {\n-        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-        typer.unboxed_closure_kind(def_id)\n+    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n+        let typer = NormalizingClosureTyper::new(self.tcx());\n+        typer.closure_kind(def_id)\n     }\n \n-    fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>\n+    fn closure_type(&self,\n+                    def_id: ast::DefId,\n+                    substs: &subst::Substs<'tcx>)\n+                    -> ty::ClosureTy<'tcx>\n     {\n-        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-        typer.unboxed_closure_type(def_id, substs)\n+        let typer = NormalizingClosureTyper::new(self.tcx());\n+        typer.closure_type(def_id, substs)\n     }\n \n-    fn unboxed_closure_upvars(&self,\n-                              def_id: ast::DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    fn closure_upvars(&self,\n+                      def_id: ast::DefId,\n+                      substs: &Substs<'tcx>)\n+                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n     {\n-        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-        typer.unboxed_closure_upvars(def_id, substs)\n+        let typer = NormalizingClosureTyper::new(self.tcx());\n+        typer.closure_upvars(def_id, substs)\n     }\n }\n \n@@ -1011,7 +1008,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    let typer = NormalizingUnboxedClosureTyper::new(tcx);\n+    let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                              trait_ref.to_poly_trait_predicate());\n@@ -1056,49 +1053,46 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     vtable\n }\n \n-pub struct NormalizingUnboxedClosureTyper<'a,'tcx:'a> {\n+pub struct NormalizingClosureTyper<'a,'tcx:'a> {\n     param_env: ty::ParameterEnvironment<'a, 'tcx>\n }\n \n-impl<'a,'tcx> NormalizingUnboxedClosureTyper<'a,'tcx> {\n-    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingUnboxedClosureTyper<'a,'tcx> {\n+impl<'a,'tcx> NormalizingClosureTyper<'a,'tcx> {\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingClosureTyper<'a,'tcx> {\n         // Parameter environment is used to give details about type parameters,\n         // but since we are in trans, everything is fully monomorphized.\n-        NormalizingUnboxedClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n+        NormalizingClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n     }\n }\n \n-impl<'a,'tcx> ty::UnboxedClosureTyper<'tcx> for NormalizingUnboxedClosureTyper<'a,'tcx> {\n+impl<'a,'tcx> ty::ClosureTyper<'tcx> for NormalizingClosureTyper<'a,'tcx> {\n     fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n         &self.param_env\n     }\n \n-    fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind\n-    {\n-        self.param_env.tcx.unboxed_closure_kind(def_id)\n+    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n+        self.param_env.tcx.closure_kind(def_id)\n     }\n \n-    fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>\n+    fn closure_type(&self,\n+                    def_id: ast::DefId,\n+                    substs: &subst::Substs<'tcx>)\n+                    -> ty::ClosureTy<'tcx>\n     {\n         // the substitutions in `substs` are already monomorphized,\n         // but we still must normalize associated types\n-        let closure_ty = self.param_env.tcx.unboxed_closure_type(def_id, substs);\n+        let closure_ty = self.param_env.tcx.closure_type(def_id, substs);\n         monomorphize::normalize_associated_type(self.param_env.tcx, &closure_ty)\n     }\n \n-    fn unboxed_closure_upvars(&self,\n-                              def_id: ast::DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    fn closure_upvars(&self,\n+                      def_id: ast::DefId,\n+                      substs: &Substs<'tcx>)\n+                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n     {\n         // the substitutions in `substs` are already monomorphized,\n         // but we still must normalize associated types\n-        let result = ty::unboxed_closure_upvars(&self.param_env, def_id, substs);\n+        let result = ty::closure_upvars(&self.param_env, def_id, substs);\n         monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n     }\n }\n@@ -1116,7 +1110,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n     // In principle, we only need to do this so long as `result`\n     // contains unbound type parameters. It could be a slight\n     // optimization to stop iterating early.\n-    let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n+    let typer = NormalizingClosureTyper::new(infcx.tcx);\n     match fulfill_cx.select_all_or_error(infcx, &typer) {\n         Ok(()) => { }\n         Err(errors) => {"}, {"sha": "09e0c016133cd0da577eb520ace687b15742fe13", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -138,7 +138,7 @@ pub struct LocalCrateContext<'tcx> {\n     builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n-    unboxed_closure_vals: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n+    closure_vals: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n \n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n@@ -414,7 +414,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                unboxed_closure_vals: RefCell::new(FnvHashMap()),\n+                closure_vals: RefCell::new(FnvHashMap()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: RefCell::new(None),\n                 intrinsics: RefCell::new(FnvHashMap()),\n@@ -684,8 +684,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.opaque_vec_type\n     }\n \n-    pub fn unboxed_closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId<'tcx>,ValueRef>> {\n-        &self.local.unboxed_closure_vals\n+    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>> {\n+        &self.local.closure_vals\n     }\n \n     pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {"}, {"sha": "4c1cf62ce8a996c08f51ce6c681a2dd5fa16a5a3", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -197,11 +197,11 @@ use metadata::csearch;\n use middle::subst::{self, Substs};\n use trans::{self, adt, machine, type_of};\n use trans::common::{self, NodeIdAndSpan, CrateContext, FunctionContext, Block,\n-                    C_bytes, C_i32, C_i64, NormalizingUnboxedClosureTyper};\n+                    C_bytes, C_i32, C_i64, NormalizingClosureTyper};\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use trans::monomorphize;\n use trans::type_::Type;\n-use middle::ty::{self, Ty, UnboxedClosureTyper};\n+use middle::ty::{self, Ty, ClosureTyper};\n use middle::pat_util;\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n@@ -472,9 +472,9 @@ impl<'tcx> TypeMap<'tcx> {\n                     }\n                 }\n             },\n-            ty::ty_unboxed_closure(def_id, _, substs) => {\n-                let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n-                let closure_ty = typer.unboxed_closure_type(def_id, substs);\n+            ty::ty_closure(def_id, _, substs) => {\n+                let typer = NormalizingClosureTyper::new(cx.tcx());\n+                let closure_ty = typer.closure_type(def_id, substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n                                                         closure_ty,\n                                                         &mut unique_type_id);\n@@ -3035,9 +3035,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref barefnty) => {\n             subroutine_type_metadata(cx, unique_type_id, &barefnty.sig, usage_site_span)\n         }\n-        ty::ty_unboxed_closure(def_id, _, substs) => {\n-            let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n-            let sig = typer.unboxed_closure_type(def_id, substs).sig;\n+        ty::ty_closure(def_id, _, substs) => {\n+            let typer = NormalizingClosureTyper::new(cx.tcx());\n+            let sig = typer.closure_type(def_id, substs).sig;\n             subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)\n         }\n         ty::ty_struct(def_id, substs) => {\n@@ -3888,7 +3888,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         },\n-        ty::ty_unboxed_closure(..) => {\n+        ty::ty_closure(..) => {\n             output.push_str(\"closure\");\n         }\n         ty::ty_err |"}, {"sha": "52087da9e9f8634daabba5582166dda17be85b46", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -1102,7 +1102,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // closure or an older, legacy style closure. Store this\n             // into a variable to ensure the the RefCell-lock is\n             // released before we recurse.\n-            closure::trans_unboxed_closure(bcx, &**decl, &**body, expr.id, dest)\n+            closure::trans_closure_expr(bcx, &**decl, &**body, expr.id, dest)\n         }\n         ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {"}, {"sha": "c1d98987991e374800344d5c8b1641fb2d8ee12d", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -438,7 +438,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                 }\n             }\n         }\n-        ty::ty_unboxed_closure(..) => {\n+        ty::ty_closure(..) => {\n             iter_structural_ty(bcx,\n                                v0,\n                                t,"}, {"sha": "580a2d5ae3dc7c37631a2ab2912386b28dc90d7d", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -120,7 +120,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match origin {\n         ty::MethodStatic(did) |\n-        ty::MethodStaticUnboxedClosure(did) => {\n+        ty::MethodStaticClosure(did) => {\n             Callee {\n                 bcx: bcx,\n                 data: Fn(callee::trans_fn_ref(bcx.ccx(),\n@@ -365,7 +365,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n-        traits::VtableUnboxedClosure(closure_def_id, substs) => {\n+        traits::VtableClosure(closure_def_id, substs) => {\n             // The substitutions should have no type parameters remaining\n             // after passing through fulfill_obligation\n             let llfn = trans_fn_ref_with_substs(bcx.ccx(),\n@@ -727,7 +727,7 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     nested: _ }) => {\n                 emit_vtable_methods(bcx, id, substs).into_iter()\n             }\n-            traits::VtableUnboxedClosure(closure_def_id, substs) => {\n+            traits::VtableClosure(closure_def_id, substs) => {\n                 let llfn = trans_fn_ref_with_substs(\n                     bcx.ccx(),\n                     closure_def_id,"}, {"sha": "72e41408d8a46fbfb62cea781b14f514d80026ef", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -322,7 +322,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     // FIXME(#20304) -- cache\n \n     let infcx = infer::new_infer_ctxt(tcx);\n-    let typer = NormalizingUnboxedClosureTyper::new(tcx);\n+    let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: result, obligations } ="}, {"sha": "61dbb5514353af8f4e8310e64395a6f363536115", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -211,7 +211,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             Type::nil(cx)\n         }\n \n-        ty::ty_tup(..) | ty::ty_enum(..) | ty::ty_unboxed_closure(..) => {\n+        ty::ty_tup(..) | ty::ty_enum(..) | ty::ty_closure(..) => {\n             let repr = adt::represent_type(cx, t);\n             adt::sizing_type_of(cx, &*repr, false)\n         }\n@@ -330,15 +330,15 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           let name = llvm_type_name(cx, an_enum, did, tps);\n           adt::incomplete_type_of(cx, &*repr, &name[])\n       }\n-      ty::ty_unboxed_closure(did, _, ref substs) => {\n+      ty::ty_closure(did, _, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache.\n           let repr = adt::represent_type(cx, t);\n           // Unboxed closures can have substitutions in all spaces\n           // inherited from their environment, so we use entire\n           // contents of the VecPerParamSpace to to construct the llvm\n           // name\n-          let name = llvm_type_name(cx, an_unboxed_closure, did, substs.types.as_slice());\n+          let name = llvm_type_name(cx, a_closure, did, substs.types.as_slice());\n           adt::incomplete_type_of(cx, &*repr, &name[])\n       }\n \n@@ -432,7 +432,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n \n     // If this was an enum or struct, fill in the type now.\n     match t.sty {\n-        ty::ty_enum(..) | ty::ty_struct(..) | ty::ty_unboxed_closure(..)\n+        ty::ty_enum(..) | ty::ty_struct(..) | ty::ty_closure(..)\n                 if !ty::type_is_simd(cx.tcx(), t) => {\n             let repr = adt::represent_type(cx, t);\n             adt::finish_type_of(cx, &*repr, &mut llty);\n@@ -454,7 +454,7 @@ pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n pub enum named_ty {\n     a_struct,\n     an_enum,\n-    an_unboxed_closure,\n+    a_closure,\n }\n \n pub fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -465,7 +465,7 @@ pub fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let name = match what {\n         a_struct => \"struct\",\n         an_enum => \"enum\",\n-        an_unboxed_closure => return \"closure\".to_string(),\n+        a_closure => return \"closure\".to_string(),\n     };\n \n     let base = ty::item_path_str(cx.tcx(), did);"}, {"sha": "0e0a929464018a2a9bfc09eade851876feb8c805", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -18,7 +18,7 @@ use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n-                                                typer: &(ty::UnboxedClosureTyper<'tcx>+'a),\n+                                                typer: &(ty::ClosureTyper<'tcx>+'a),\n                                                 fulfillment_cx: &mut FulfillmentContext<'tcx>,\n                                                 span: Span,\n                                                 body_id: ast::NodeId,"}, {"sha": "76ed88eb82da042dd78fd56d5e6116d610e21bb8", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -25,7 +25,7 @@ use util::ppaux::Repr;\n pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                    expr: &ast::Expr,\n                                    _capture: ast::CaptureClause,\n-                                   opt_kind: Option<ast::UnboxedClosureKind>,\n+                                   opt_kind: Option<ast::ClosureKind>,\n                                    decl: &ast::FnDecl,\n                                    body: &ast::Block,\n                                    expected: Expectation<'tcx>) {\n@@ -34,7 +34,7 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n            expected.repr(fcx.tcx()));\n \n     let expected_sig_and_kind = expected.to_option(fcx).and_then(|ty| {\n-        deduce_unboxed_closure_expectations_from_expected_type(fcx, ty)\n+        deduce_closure_expectations_from_expected_type(fcx, ty)\n     });\n \n     match opt_kind {\n@@ -46,42 +46,42 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             match expected_sig_and_kind {\n                 None => { // don't have information about the kind, request explicit annotation\n                     // NB We still need to typeck the body, so assume `FnMut` kind just for that\n-                    let kind = ty::FnMutUnboxedClosureKind;\n+                    let kind = ty::FnMutClosureKind;\n \n-                    check_unboxed_closure(fcx, expr, kind, decl, body, None);\n+                    check_closure(fcx, expr, kind, decl, body, None);\n \n                     span_err!(fcx.ccx.tcx.sess, expr.span, E0187,\n                         \"can't infer the \\\"kind\\\" of the closure; explicitly annotate it; e.g. \\\n                         `|&:| {{}}`\");\n                 },\n                 Some((sig, kind)) => {\n-                    check_unboxed_closure(fcx, expr, kind, decl, body, Some(sig));\n+                    check_closure(fcx, expr, kind, decl, body, Some(sig));\n                 }\n             }\n         }\n \n         Some(kind) => {\n             let kind = match kind {\n-                ast::FnUnboxedClosureKind => ty::FnUnboxedClosureKind,\n-                ast::FnMutUnboxedClosureKind => ty::FnMutUnboxedClosureKind,\n-                ast::FnOnceUnboxedClosureKind => ty::FnOnceUnboxedClosureKind,\n+                ast::FnClosureKind => ty::FnClosureKind,\n+                ast::FnMutClosureKind => ty::FnMutClosureKind,\n+                ast::FnOnceClosureKind => ty::FnOnceClosureKind,\n             };\n \n             let expected_sig = expected_sig_and_kind.map(|t| t.0);\n-            check_unboxed_closure(fcx, expr, kind, decl, body, expected_sig);\n+            check_closure(fcx, expr, kind, decl, body, expected_sig);\n         }\n     }\n }\n \n-fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                  expr: &ast::Expr,\n-                                  kind: ty::UnboxedClosureKind,\n-                                  decl: &ast::FnDecl,\n-                                  body: &ast::Block,\n-                                  expected_sig: Option<ty::FnSig<'tcx>>) {\n+fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                          expr: &ast::Expr,\n+                          kind: ty::ClosureKind,\n+                          decl: &ast::FnDecl,\n+                          body: &ast::Block,\n+                          expected_sig: Option<ty::FnSig<'tcx>>) {\n     let expr_def_id = ast_util::local_def(expr.id);\n \n-    debug!(\"check_unboxed_closure kind={:?} expected_sig={}\",\n+    debug!(\"check_closure kind={:?} expected_sig={}\",\n            kind,\n            expected_sig.repr(fcx.tcx()));\n \n@@ -100,11 +100,11 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         Ok(regions) => regions[0],\n     };\n \n-    let closure_type = ty::mk_unboxed_closure(fcx.ccx.tcx,\n-                                              expr_def_id,\n-                                              fcx.ccx.tcx.mk_region(region),\n-                                              fcx.ccx.tcx.mk_substs(\n-                                                  fcx.inh.param_env.free_substs.clone()));\n+    let closure_type = ty::mk_closure(fcx.ccx.tcx,\n+                                      expr_def_id,\n+                                      fcx.ccx.tcx.mk_region(region),\n+                                      fcx.ccx.tcx.mk_substs(\n+                                        fcx.inh.param_env.free_substs.clone()));\n \n     fcx.write_ty(expr.id, closure_type);\n \n@@ -121,54 +121,51 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n              fcx.inh);\n \n     // Tuple up the arguments and insert the resulting function type into\n-    // the `unboxed_closures` table.\n+    // the `closures` table.\n     fn_ty.sig.0.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.0.inputs)];\n \n-    debug!(\"unboxed_closure for {} --> sig={} kind={:?}\",\n+    debug!(\"closure for {} --> sig={} kind={:?}\",\n            expr_def_id.repr(fcx.tcx()),\n            fn_ty.sig.repr(fcx.tcx()),\n            kind);\n \n-    let unboxed_closure = ty::UnboxedClosure {\n+    let closure = ty::Closure {\n         closure_type: fn_ty,\n         kind: kind,\n     };\n \n-    fcx.inh\n-        .unboxed_closures\n-        .borrow_mut()\n-        .insert(expr_def_id, unboxed_closure);\n+    fcx.inh.closures.borrow_mut().insert(expr_def_id, closure);\n }\n \n-fn deduce_unboxed_closure_expectations_from_expected_type<'a,'tcx>(\n+fn deduce_closure_expectations_from_expected_type<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     expected_ty: Ty<'tcx>)\n-    -> Option<(ty::FnSig<'tcx>,ty::UnboxedClosureKind)>\n+    -> Option<(ty::FnSig<'tcx>,ty::ClosureKind)>\n {\n     match expected_ty.sty {\n         ty::ty_trait(ref object_type) => {\n             let trait_ref =\n                 object_type.principal_trait_ref_with_self_ty(fcx.tcx(),\n                                                              fcx.tcx().types.err);\n-            deduce_unboxed_closure_expectations_from_trait_ref(fcx, &trait_ref)\n+            deduce_closure_expectations_from_trait_ref(fcx, &trait_ref)\n         }\n         ty::ty_infer(ty::TyVar(vid)) => {\n-            deduce_unboxed_closure_expectations_from_obligations(fcx, vid)\n+            deduce_closure_expectations_from_obligations(fcx, vid)\n         }\n         _ => {\n             None\n         }\n     }\n }\n \n-fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n+fn deduce_closure_expectations_from_trait_ref<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     trait_ref: &ty::PolyTraitRef<'tcx>)\n-    -> Option<(ty::FnSig<'tcx>, ty::UnboxedClosureKind)>\n+    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n {\n     let tcx = fcx.tcx();\n \n-    debug!(\"deduce_unboxed_closure_expectations_from_object_type({})\",\n+    debug!(\"deduce_closure_expectations_from_object_type({})\",\n            trait_ref.repr(tcx));\n \n     let kind = match tcx.lang_items.fn_trait_kind(trait_ref.def_id()) {\n@@ -202,10 +199,10 @@ fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n     return Some((fn_sig, kind));\n }\n \n-fn deduce_unboxed_closure_expectations_from_obligations<'a,'tcx>(\n+fn deduce_closure_expectations_from_obligations<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     expected_vid: ty::TyVid)\n-    -> Option<(ty::FnSig<'tcx>, ty::UnboxedClosureKind)>\n+    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n {\n     // Here `expected_ty` is known to be a type inference variable.\n     for obligation in fcx.inh.fulfillment_cx.borrow().pending_obligations().iter() {\n@@ -218,7 +215,7 @@ fn deduce_unboxed_closure_expectations_from_obligations<'a,'tcx>(\n                     _ => { continue; }\n                 }\n \n-                match deduce_unboxed_closure_expectations_from_trait_ref(fcx, &trait_ref) {\n+                match deduce_closure_expectations_from_trait_ref(fcx, &trait_ref) {\n                     Some(e) => { return Some(e); }\n                     None => { }\n                 }"}, {"sha": "959120aae6659d44959ac5c40af6a36cd4da520c", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -62,7 +62,7 @@ enum CandidateKind<'tcx> {\n     ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n     ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n                            subst::Substs<'tcx>, MethodIndex),\n-    UnboxedClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n+    ClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n     WhereClauseCandidate(ty::PolyTraitRef<'tcx>, MethodIndex),\n     ProjectionCandidate(ast::DefId, MethodIndex),\n }\n@@ -249,7 +249,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             }\n             ty::ty_enum(did, _) |\n             ty::ty_struct(did, _) |\n-            ty::ty_unboxed_closure(did, _, _) => {\n+            ty::ty_closure(did, _, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(did);\n             }\n             ty::ty_param(p) => {\n@@ -494,9 +494,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                            method.clone(),\n                                                            matching_index);\n \n-        self.assemble_unboxed_closure_candidates(trait_def_id,\n-                                                 method.clone(),\n-                                                 matching_index);\n+        self.assemble_closure_candidates(trait_def_id,\n+                                         method.clone(),\n+                                         matching_index);\n \n         self.assemble_projection_candidates(trait_def_id,\n                                             method.clone(),\n@@ -571,19 +571,19 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         simplified_steps.contains(&impl_simplified_type)\n     }\n \n-    fn assemble_unboxed_closure_candidates(&mut self,\n-                                           trait_def_id: ast::DefId,\n-                                           method_ty: Rc<ty::Method<'tcx>>,\n-                                           method_index: uint)\n+    fn assemble_closure_candidates(&mut self,\n+                                   trait_def_id: ast::DefId,\n+                                   method_ty: Rc<ty::Method<'tcx>>,\n+                                   method_index: uint)\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n         let tcx = self.tcx();\n         let kind = if Some(trait_def_id) == tcx.lang_items.fn_trait() {\n-            ty::FnUnboxedClosureKind\n+            ty::FnClosureKind\n         } else if Some(trait_def_id) == tcx.lang_items.fn_mut_trait() {\n-            ty::FnMutUnboxedClosureKind\n+            ty::FnMutClosureKind\n         } else if Some(trait_def_id) == tcx.lang_items.fn_once_trait() {\n-            ty::FnOnceUnboxedClosureKind\n+            ty::FnOnceClosureKind\n         } else {\n             return;\n         };\n@@ -593,12 +593,12 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let steps = self.steps.clone();\n         for step in steps.iter() {\n             let (closure_def_id, _, _) = match step.self_ty.sty {\n-                ty::ty_unboxed_closure(a, b, ref c) => (a, b, c),\n+                ty::ty_closure(a, b, ref c) => (a, b, c),\n                 _ => continue,\n             };\n \n-            let unboxed_closures = self.fcx.inh.unboxed_closures.borrow();\n-            let closure_data = match unboxed_closures.get(&closure_def_id) {\n+            let closures = self.fcx.inh.closures.borrow();\n+            let closure_data = match closures.get(&closure_def_id) {\n                 Some(data) => data,\n                 None => {\n                     self.tcx().sess.span_bug(\n@@ -626,7 +626,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             self.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 method_ty: method_ty.clone(),\n-                kind: UnboxedClosureCandidate(trait_def_id, method_index)\n+                kind: ClosureCandidate(trait_def_id, method_index)\n             });\n         }\n     }\n@@ -950,7 +950,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n                 ProjectionCandidate(..) |\n                 ObjectCandidate(..) |\n-                UnboxedClosureCandidate(..) |\n+                ClosureCandidate(..) |\n                 WhereClauseCandidate(..) => {\n                     // These have no additional conditions to check.\n                     true\n@@ -1173,7 +1173,7 @@ impl<'tcx> Candidate<'tcx> {\n                 ExtensionImplCandidate(def_id, _, _, index) => {\n                     ExtensionImplPick(def_id, index)\n                 }\n-                UnboxedClosureCandidate(trait_def_id, index) => {\n+                ClosureCandidate(trait_def_id, index) => {\n                     TraitPick(trait_def_id, index)\n                 }\n                 WhereClauseCandidate(ref trait_ref, index) => {\n@@ -1198,7 +1198,7 @@ impl<'tcx> Candidate<'tcx> {\n             InherentImplCandidate(def_id, _) => ImplSource(def_id),\n             ObjectCandidate(def_id, _, _) => TraitSource(def_id),\n             ExtensionImplCandidate(def_id, _, _, _) => ImplSource(def_id),\n-            UnboxedClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n+            ClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n             WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id()),\n             ProjectionCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n         }\n@@ -1210,7 +1210,7 @@ impl<'tcx> Candidate<'tcx> {\n             ObjectCandidate(..) => {\n                 None\n             }\n-            UnboxedClosureCandidate(trait_def_id, method_num) => {\n+            ClosureCandidate(trait_def_id, method_num) => {\n                 Some((trait_def_id, method_num))\n             }\n             ExtensionImplCandidate(_, ref trait_ref, _, method_num) => {\n@@ -1244,8 +1244,8 @@ impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n             ExtensionImplCandidate(ref a, ref b, ref c, ref d) =>\n                 format!(\"ExtensionImplCandidate({},{},{},{})\", a.repr(tcx), b.repr(tcx),\n                         c.repr(tcx), d),\n-            UnboxedClosureCandidate(ref a, ref b) =>\n-                format!(\"UnboxedClosureCandidate({},{})\", a.repr(tcx), b),\n+            ClosureCandidate(ref a, ref b) =>\n+                format!(\"ClosureCandidate({},{})\", a.repr(tcx), b),\n             WhereClauseCandidate(ref a, ref b) =>\n                 format!(\"WhereClauseCandidate({},{})\", a.repr(tcx), b),\n             ProjectionCandidate(ref a, ref b) =>"}, {"sha": "be1ad18ba9f53c5f5a33336a468c0e87513a3f0e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -160,7 +160,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     adjustments: RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>,\n     method_map: MethodMap<'tcx>,\n     upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n-    unboxed_closures: RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>>,\n+    closures: RefCell<DefIdMap<ty::Closure<'tcx>>>,\n     object_cast_map: ObjectCastMap<'tcx>,\n \n     // A mapping from each fn's id to its signature, with all bound\n@@ -338,32 +338,29 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ty::UnboxedClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> ty::ClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n     fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n         &self.inh.param_env\n     }\n \n-    fn unboxed_closure_kind(&self,\n-                            def_id: ast::DefId)\n-                            -> ty::UnboxedClosureKind\n-    {\n-        self.inh.unboxed_closures.borrow()[def_id].kind\n+    fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n+        self.inh.closures.borrow()[def_id].kind\n     }\n \n-    fn unboxed_closure_type(&self,\n-                            def_id: ast::DefId,\n-                            substs: &subst::Substs<'tcx>)\n-                            -> ty::ClosureTy<'tcx>\n+    fn closure_type(&self,\n+                    def_id: ast::DefId,\n+                    substs: &subst::Substs<'tcx>)\n+                    -> ty::ClosureTy<'tcx>\n     {\n-        self.inh.unboxed_closures.borrow()[def_id].closure_type.subst(self.tcx(), substs)\n+        self.inh.closures.borrow()[def_id].closure_type.subst(self.tcx(), substs)\n     }\n \n-    fn unboxed_closure_upvars(&self,\n-                              def_id: ast::DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    fn closure_upvars(&self,\n+                      def_id: ast::DefId,\n+                      substs: &Substs<'tcx>)\n+                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n     {\n-        ty::unboxed_closure_upvars(self, def_id, substs)\n+        ty::closure_upvars(self, def_id, substs)\n     }\n }\n \n@@ -381,14 +378,14 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             method_map: RefCell::new(FnvHashMap()),\n             object_cast_map: RefCell::new(NodeMap()),\n             upvar_borrow_map: RefCell::new(FnvHashMap()),\n-            unboxed_closures: RefCell::new(DefIdMap()),\n+            closures: RefCell::new(DefIdMap()),\n             fn_sig_map: RefCell::new(NodeMap()),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n         }\n     }\n \n     fn normalize_associated_types_in<T>(&self,\n-                                        typer: &ty::UnboxedClosureTyper<'tcx>,\n+                                        typer: &ty::ClosureTyper<'tcx>,\n                                         span: Span,\n                                         body_id: ast::NodeId,\n                                         value: &T)"}, {"sha": "c625caba2fe51dd3be08c82bcda2604e35e93980", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -748,7 +748,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     let function_type = rcx.resolve_node_type(expr.id);\n \n     match function_type.sty {\n-        ty::ty_unboxed_closure(_, region, _) => {\n+        ty::ty_closure(_, region, _) => {\n             if tcx.capture_modes.borrow()[expr.id].clone() == ast::CaptureByRef {\n                 ty::with_freevars(tcx, expr.id, |freevars| {\n                     if !freevars.is_empty() {\n@@ -768,7 +768,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     rcx.set_repeating_scope(repeating_scope);\n \n     match function_type.sty {\n-        ty::ty_unboxed_closure(_, region, _) => {\n+        ty::ty_closure(_, region, _) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n                 let bounds = ty::region_existential_bound(*region);\n                 ensure_free_variable_types_outlive_closure_bound(rcx, &bounds, expr, freevars);"}, {"sha": "4056800c0d15b077921847bad8bfeac5dadda6bb", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                 // No borrowed content reachable here.\n             }\n \n-            ty::ty_unboxed_closure(_, region, _) => {\n+            ty::ty_closure(_, region, _) => {\n                 // An \"unboxed closure type\" is basically\n                 // modeled here as equivalent to a struct like\n                 //"}, {"sha": "1c16ab828675aea41963c89497c8f4b1afdfb1c6", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -39,7 +39,7 @@ pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     let mut wbcx = WritebackCx::new(fcx);\n     wbcx.visit_expr(e);\n     wbcx.visit_upvar_borrow_map();\n-    wbcx.visit_unboxed_closures();\n+    wbcx.visit_closures();\n     wbcx.visit_object_cast_map();\n }\n \n@@ -60,7 +60,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n         }\n     }\n     wbcx.visit_upvar_borrow_map();\n-    wbcx.visit_unboxed_closures();\n+    wbcx.visit_closures();\n     wbcx.visit_object_cast_map();\n }\n \n@@ -195,27 +195,19 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn visit_unboxed_closures(&self) {\n+    fn visit_closures(&self) {\n         if self.fcx.writeback_errors.get() {\n             return\n         }\n \n-        for (def_id, unboxed_closure) in self.fcx\n-                                             .inh\n-                                             .unboxed_closures\n-                                             .borrow()\n-                                             .iter() {\n-            let closure_ty = self.resolve(&unboxed_closure.closure_type,\n-                                          ResolvingUnboxedClosure(*def_id));\n-            let unboxed_closure = ty::UnboxedClosure {\n+        for (def_id, closure) in self.fcx.inh.closures.borrow().iter() {\n+            let closure_ty = self.resolve(&closure.closure_type,\n+                                          ResolvingClosure(*def_id));\n+            let closure = ty::Closure {\n                 closure_type: closure_ty,\n-                kind: unboxed_closure.kind,\n+                kind: closure.kind,\n             };\n-            self.fcx\n-                .tcx()\n-                .unboxed_closures\n-                .borrow_mut()\n-                .insert(*def_id, unboxed_closure);\n+            self.fcx.tcx().closures.borrow_mut().insert(*def_id, closure);\n         }\n     }\n \n@@ -331,7 +323,7 @@ enum ResolveReason {\n     ResolvingLocal(Span),\n     ResolvingPattern(Span),\n     ResolvingUpvar(ty::UpvarId),\n-    ResolvingUnboxedClosure(ast::DefId),\n+    ResolvingClosure(ast::DefId),\n }\n \n impl ResolveReason {\n@@ -343,7 +335,7 @@ impl ResolveReason {\n             ResolvingUpvar(upvar_id) => {\n                 ty::expr_span(tcx, upvar_id.closure_expr_id)\n             }\n-            ResolvingUnboxedClosure(did) => {\n+            ResolvingClosure(did) => {\n                 if did.krate == ast::LOCAL_CRATE {\n                     ty::expr_span(tcx, did.node)\n                 } else {\n@@ -414,7 +406,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                         infer::fixup_err_to_string(e));\n                 }\n \n-                ResolvingUnboxedClosure(_) => {\n+                ResolvingClosure(_) => {\n                     let span = self.reason.span(self.tcx);\n                     span_err!(self.tcx.sess, span, E0196,\n                                            \"cannot determine a type for this \\"}, {"sha": "9760d5f05df71d6878b182d382dc6fd7dc611dda", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -26,7 +26,7 @@ use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n use middle::ty::{ty_param, TypeScheme, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_open};\n-use middle::ty::{ty_uint, ty_unboxed_closure, ty_uniq, ty_bare_fn};\n+use middle::ty::{ty_uint, ty_closure, ty_uniq, ty_bare_fn};\n use middle::ty::{ty_projection};\n use middle::ty;\n use CrateCtxt;\n@@ -80,7 +80,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n             None\n         }\n \n-        ty_infer(..) | ty_unboxed_closure(..) => {\n+        ty_infer(..) | ty_closure(..) => {\n             // `ty` comes from a user declaration so we should only expect types\n             // that the user can type\n             inference_context.tcx.sess.span_bug(\n@@ -410,7 +410,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             match self_type.ty.sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) |\n-                ty::ty_unboxed_closure(type_def_id, _, _) => {\n+                ty::ty_closure(type_def_id, _, _) => {\n                     tcx.destructor_for_type\n                        .borrow_mut()\n                        .insert(type_def_id, method_def_id.def_id());"}, {"sha": "1bf5c3fbd07f75599ec76b059ac9fb206023b37e", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -740,7 +740,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 /* leaf type -- noop */\n             }\n \n-            ty::ty_unboxed_closure(..) => {\n+            ty::ty_closure(..) => {\n                 self.tcx().sess.bug(\"Unexpected unboxed closure type in variance computation\");\n             }\n "}, {"sha": "4276e079e296aeb285c57fa5e9dae2aa44b7320e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -1601,7 +1601,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n \n             ty::ty_param(ref p) => Generic(token::get_name(p.name).to_string()),\n \n-            ty::ty_unboxed_closure(..) => Tuple(vec![]), // FIXME(pcwalton)\n+            ty::ty_closure(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n             ty::ty_infer(..) => panic!(\"ty_infer\"),\n             ty::ty_open(..) => panic!(\"ty_open\"),"}, {"sha": "909a719c691d0f4db45db5b9e21c227bd72b4b19", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -49,7 +49,7 @@ pub use self::TraitItem::*;\n pub use self::Ty_::*;\n pub use self::TyParamBound::*;\n pub use self::UintTy::*;\n-pub use self::UnboxedClosureKind::*;\n+pub use self::ClosureKind::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::VariantKind::*;\n@@ -734,7 +734,7 @@ pub enum Expr_ {\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n     ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n-    ExprClosure(CaptureClause, Option<UnboxedClosureKind>, P<FnDecl>, P<Block>),\n+    ExprClosure(CaptureClause, Option<ClosureKind>, P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n     ExprAssign(P<Expr>, P<Expr>),\n@@ -1710,10 +1710,10 @@ impl ForeignItem_ {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n-pub enum UnboxedClosureKind {\n-    FnUnboxedClosureKind,\n-    FnMutUnboxedClosureKind,\n-    FnOnceUnboxedClosureKind,\n+pub enum ClosureKind {\n+    FnClosureKind,\n+    FnMutClosureKind,\n+    FnOnceClosureKind,\n }\n \n /// The data we save and restore about an inlined item or method.  This is not"}, {"sha": "37f95bffe27835d4a84d930dc860b0680c4ba188", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -28,8 +28,8 @@ use ast::{ExprLit, ExprLoop, ExprMac, ExprRange};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprQPath};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n-use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n-use ast::{FnOnceUnboxedClosureKind};\n+use ast::{FnClosureKind, FnMutClosureKind};\n+use ast::{FnOnceClosureKind};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod, FunctionRetTy};\n use ast::{Ident, Inherited, ImplItem, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n@@ -57,7 +57,7 @@ use ast::{TyFixedLengthVec, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n-use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n+use ast::{TypeImplItem, TypeTraitItem, Typedef, ClosureKind};\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n@@ -1134,26 +1134,25 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an optional unboxed closure kind (`&:`, `&mut:`, or `:`).\n-    pub fn parse_optional_unboxed_closure_kind(&mut self)\n-                                               -> Option<UnboxedClosureKind> {\n+    pub fn parse_optional_closure_kind(&mut self) -> Option<ClosureKind> {\n         if self.check(&token::BinOp(token::And)) &&\n                 self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n                 self.look_ahead(2, |t| *t == token::Colon) {\n             self.bump();\n             self.bump();\n             self.bump();\n-            return Some(FnMutUnboxedClosureKind)\n+            return Some(FnMutClosureKind)\n         }\n \n         if self.token == token::BinOp(token::And) &&\n                     self.look_ahead(1, |t| *t == token::Colon) {\n             self.bump();\n             self.bump();\n-            return Some(FnUnboxedClosureKind)\n+            return Some(FnClosureKind)\n         }\n \n         if self.eat(&token::Colon) {\n-            return Some(FnOnceUnboxedClosureKind)\n+            return Some(FnOnceClosureKind)\n         }\n \n         return None\n@@ -3023,8 +3022,7 @@ impl<'a> Parser<'a> {\n                              -> P<Expr>\n     {\n         let lo = self.span.lo;\n-        let (decl, optional_unboxed_closure_kind) =\n-            self.parse_fn_block_decl();\n+        let (decl, optional_closure_kind) = self.parse_fn_block_decl();\n         let body = self.parse_expr();\n         let fakeblock = P(ast::Block {\n             id: ast::DUMMY_NODE_ID,\n@@ -3037,7 +3035,7 @@ impl<'a> Parser<'a> {\n         self.mk_expr(\n             lo,\n             fakeblock.span.hi,\n-            ExprClosure(capture_clause, optional_unboxed_closure_kind, decl, fakeblock))\n+            ExprClosure(capture_clause, optional_closure_kind, decl, fakeblock))\n     }\n \n     pub fn parse_else_expr(&mut self) -> P<Expr> {\n@@ -4506,22 +4504,21 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse the |arg, arg| header on a lambda\n-    fn parse_fn_block_decl(&mut self)\n-                           -> (P<FnDecl>, Option<UnboxedClosureKind>) {\n-        let (optional_unboxed_closure_kind, inputs_captures) = {\n+    fn parse_fn_block_decl(&mut self) -> (P<FnDecl>, Option<ClosureKind>) {\n+        let (optional_closure_kind, inputs_captures) = {\n             if self.eat(&token::OrOr) {\n                 (None, Vec::new())\n             } else {\n                 self.expect(&token::BinOp(token::Or));\n-                let optional_unboxed_closure_kind =\n-                    self.parse_optional_unboxed_closure_kind();\n+                let optional_closure_kind =\n+                    self.parse_optional_closure_kind();\n                 let args = self.parse_seq_to_before_end(\n                     &token::BinOp(token::Or),\n                     seq_sep_trailing_allowed(token::Comma),\n                     |p| p.parse_fn_block_arg()\n                 );\n                 self.bump();\n-                (optional_unboxed_closure_kind, args)\n+                (optional_closure_kind, args)\n             }\n         };\n         let output = self.parse_ret_ty();\n@@ -4530,7 +4527,7 @@ impl<'a> Parser<'a> {\n             inputs: inputs_captures,\n             output: output,\n             variadic: false\n-        }), optional_unboxed_closure_kind)\n+        }), optional_closure_kind)\n     }\n \n     /// Parses the `(arg, arg) -> return_type` header on a procedure."}, {"sha": "7cbc701995e520cc433e6036270948bd1cbd5750", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -11,11 +11,11 @@\n pub use self::AnnNode::*;\n \n use abi;\n-use ast::{self, FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n-use ast::{FnOnceUnboxedClosureKind};\n+use ast::{self, FnClosureKind, FnMutClosureKind};\n+use ast::{FnOnceClosureKind};\n use ast::{MethodImplItem, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::{RequiredMethod, ProvidedMethod, TypeImplItem, TypeTraitItem};\n-use ast::{UnboxedClosureKind};\n+use ast::{ClosureKind};\n use ast_util;\n use owned_slice::OwnedSlice;\n use attr::{AttrMetaMethods, AttributeMethods};\n@@ -2357,14 +2357,14 @@ impl<'a> State<'a> {\n     pub fn print_fn_block_args(\n             &mut self,\n             decl: &ast::FnDecl,\n-            unboxed_closure_kind: Option<UnboxedClosureKind>)\n+            closure_kind: Option<ClosureKind>)\n             -> IoResult<()> {\n         try!(word(&mut self.s, \"|\"));\n-        match unboxed_closure_kind {\n+        match closure_kind {\n             None => {}\n-            Some(FnUnboxedClosureKind) => try!(self.word_space(\"&:\")),\n-            Some(FnMutUnboxedClosureKind) => try!(self.word_space(\"&mut:\")),\n-            Some(FnOnceUnboxedClosureKind) => try!(self.word_space(\":\")),\n+            Some(FnClosureKind) => try!(self.word_space(\"&:\")),\n+            Some(FnMutClosureKind) => try!(self.word_space(\"&mut:\")),\n+            Some(FnOnceClosureKind) => try!(self.word_space(\":\")),\n         }\n         try!(self.print_fn_args(decl, None));\n         try!(word(&mut self.s, \"|\"));"}, {"sha": "a04301931da6a941e03048046e977c3a0500565d", "filename": "src/test/run-pass/unboxed-closures-unique-type-id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ef6f1349d0917c099d7c88d630b0e5f6ee4393/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs?ref=11ef6f1349d0917c099d7c88d630b0e5f6ee4393", "patch": "@@ -12,7 +12,7 @@\n //\n //    error: internal compiler error: get_unique_type_id_of_type() -\n //    unexpected type: closure,\n-//    ty_unboxed_closure(syntax::ast::DefId{krate: 0u32, node: 66u32},\n+//    ty_closure(syntax::ast::DefId{krate: 0u32, node: 66u32},\n //    ReScope(63u32))\n //\n // This is a regression test for issue #17021."}]}