{"sha": "2cb684bbce1c487b2efb5a8154afe66e4907ceac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjYjY4NGJiY2UxYzQ4N2IyZWZiNWE4MTU0YWZlNjZlNDkwN2NlYWM=", "commit": {"author": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2019-11-29T06:49:12Z"}, "committer": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2019-11-29T06:49:12Z"}, "message": "Reduce variants of Expr", "tree": {"sha": "f93ef014cc82793949e8567634cec341ffc58d62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f93ef014cc82793949e8567634cec341ffc58d62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cb684bbce1c487b2efb5a8154afe66e4907ceac", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl3gv6UACgkQztOS3gxI\nPQBbVA/+IQfnGauJ30o0ZJqFVEPS+wYGAS9Sqr0+ttY1hUZrw0r5zPhY2wPnpqlY\nsbfyLcRzAKoNEHDemljGqD+wNJKW1QVJHrB3XgYp1CxPCClYRKKobox7MBdg5Civ\nQXtpr1UVEUCDTep+29N7sSQWvmrJTdoZThJ3q+e4fqyCusT69x+or+IhuboQOD5t\nlmX1GlDvLB9A2AdHvKqL9UoUOmaFnQmokchvrMKa0lUCPC4F2LyycRYTx78oVovl\n3GsNF7pzxVDlGnK13EGf6Zd6c90DRnK5V9FHsjrGC6NuxSMVzh3Lk83fhs0RR0LE\nPmI8X7gLFohtmPEdOexjwTbQN9CYiuoPojLujpCuE/U2l8kr+pHHTJegUxBJC8KV\n4vls+/MPbbZrFP3T5adbXnQc0xWr9dYahJ16oxQxTI9VnWWFhXFKQ9iEvf/ufZUf\n+3Sp1AGXPiTtBh486XhI6dcQa53CQjoINyaatOwRxn1U3N6h/Pep4n4fMADHk3uJ\n/zFbr1Y54lM9vL76mvMj+r+QZQnhAZyIfgF4hE1jqSMphi4oJltM5p3x4UsCnNKo\nkTJoCAme0SVCuBv5Z5iF4H5TdaQFPcXQ6viIUz6H0uEWemrks2aQBb6rN1yQiLjH\nJf9nslPzwG0PwlVmT3xXm5l/o1W7PMnL/A3ihzyTTBBvdCaYtrY=\n=qEpQ\n-----END PGP SIGNATURE-----", "payload": "tree f93ef014cc82793949e8567634cec341ffc58d62\nparent 4992d2bf79e9da6db759eb8e1715f90f31ec7eb9\nauthor oxalica <oxalicc@pm.me> 1575010152 +0800\ncommitter oxalica <oxalicc@pm.me> 1575010152 +0800\n\nReduce variants of Expr\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cb684bbce1c487b2efb5a8154afe66e4907ceac", "html_url": "https://github.com/rust-lang/rust/commit/2cb684bbce1c487b2efb5a8154afe66e4907ceac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cb684bbce1c487b2efb5a8154afe66e4907ceac/comments", "author": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4992d2bf79e9da6db759eb8e1715f90f31ec7eb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4992d2bf79e9da6db759eb8e1715f90f31ec7eb9", "html_url": "https://github.com/rust-lang/rust/commit/4992d2bf79e9da6db759eb8e1715f90f31ec7eb9"}], "stats": {"total": 133, "additions": 56, "deletions": 77}, "files": [{"sha": "be1eaa52344dac699a527a81cea5e433caa2745d", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2cb684bbce1c487b2efb5a8154afe66e4907ceac/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb684bbce1c487b2efb5a8154afe66e4907ceac/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=2cb684bbce1c487b2efb5a8154afe66e4907ceac", "patch": "@@ -8,7 +8,7 @@ use hir_expand::{\n use ra_arena::Arena;\n use ra_syntax::{\n     ast::{\n-        self, ArgListOwner, ArrayExprKind, LiteralKind, LoopBodyOwner, NameOwner, RangeOp,\n+        self, ArgListOwner, ArrayExprKind, LiteralKind, LoopBodyOwner, NameOwner,\n         TypeAscriptionOwner,\n     },\n     AstNode, AstPtr,\n@@ -432,20 +432,11 @@ where\n             ast::Expr::RangeExpr(e) => {\n                 let lhs = e.start().map(|lhs| self.collect_expr(lhs));\n                 let rhs = e.end().map(|rhs| self.collect_expr(rhs));\n-                match (lhs, e.op_kind(), rhs) {\n-                    (None, _, None) => self.alloc_expr(Expr::RangeFull, syntax_ptr),\n-                    (Some(lhs), _, None) => self.alloc_expr(Expr::RangeFrom { lhs }, syntax_ptr),\n-                    (None, Some(RangeOp::Inclusive), Some(rhs)) => {\n-                        self.alloc_expr(Expr::RangeToInclusive { rhs }, syntax_ptr)\n-                    }\n-                    (Some(lhs), Some(RangeOp::Inclusive), Some(rhs)) => {\n-                        self.alloc_expr(Expr::RangeInclusive { lhs, rhs }, syntax_ptr)\n-                    }\n-                    // If RangeOp is missing, fallback to exclusive range.\n-                    (None, _, Some(rhs)) => self.alloc_expr(Expr::RangeTo { rhs }, syntax_ptr),\n-                    (Some(lhs), _, Some(rhs)) => {\n-                        self.alloc_expr(Expr::Range { lhs, rhs }, syntax_ptr)\n+                match e.op_kind() {\n+                    Some(range_type) => {\n+                        self.alloc_expr(Expr::Range { lhs, rhs, range_type }, syntax_ptr)\n                     }\n+                    None => self.alloc_expr(Expr::Missing, syntax_ptr),\n                 }\n             }\n "}, {"sha": "6fad80a8d488cb9410ba94d84bc4795fef3dbf6d", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2cb684bbce1c487b2efb5a8154afe66e4907ceac/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb684bbce1c487b2efb5a8154afe66e4907ceac/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=2cb684bbce1c487b2efb5a8154afe66e4907ceac", "patch": "@@ -14,6 +14,7 @@\n \n use hir_expand::name::Name;\n use ra_arena::{impl_arena_id, RawId};\n+use ra_syntax::ast::RangeOp;\n \n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt},\n@@ -130,23 +131,10 @@ pub enum Expr {\n         rhs: ExprId,\n         op: Option<BinaryOp>,\n     },\n-    RangeFull,\n-    RangeFrom {\n-        lhs: ExprId,\n-    },\n-    RangeTo {\n-        rhs: ExprId,\n-    },\n     Range {\n-        lhs: ExprId,\n-        rhs: ExprId,\n-    },\n-    RangeToInclusive {\n-        rhs: ExprId,\n-    },\n-    RangeInclusive {\n-        lhs: ExprId,\n-        rhs: ExprId,\n+        lhs: Option<ExprId>,\n+        rhs: Option<ExprId>,\n+        range_type: RangeOp,\n     },\n     Index {\n         base: ExprId,\n@@ -302,21 +290,23 @@ impl Expr {\n             Expr::Lambda { body, .. } => {\n                 f(*body);\n             }\n-            Expr::BinaryOp { lhs, rhs, .. }\n-            | Expr::Range { lhs, rhs }\n-            | Expr::RangeInclusive { lhs, rhs } => {\n+            Expr::BinaryOp { lhs, rhs, .. } => {\n                 f(*lhs);\n                 f(*rhs);\n             }\n+            Expr::Range { lhs, rhs, .. } => {\n+                if let Some(lhs) = rhs {\n+                    f(*lhs);\n+                }\n+                if let Some(rhs) = lhs {\n+                    f(*rhs);\n+                }\n+            }\n             Expr::Index { base, index } => {\n                 f(*base);\n                 f(*index);\n             }\n-            Expr::RangeFull => {}\n-            Expr::RangeFrom { lhs: expr }\n-            | Expr::RangeTo { rhs: expr }\n-            | Expr::RangeToInclusive { rhs: expr }\n-            | Expr::Field { expr, .. }\n+            Expr::Field { expr, .. }\n             | Expr::Await { expr }\n             | Expr::Try { expr }\n             | Expr::Cast { expr, .. }"}, {"sha": "4014f4732d483bb07a88a541f9cd34ed0c2034d4", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2cb684bbce1c487b2efb5a8154afe66e4907ceac/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb684bbce1c487b2efb5a8154afe66e4907ceac/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=2cb684bbce1c487b2efb5a8154afe66e4907ceac", "patch": "@@ -12,6 +12,7 @@ use hir_def::{\n     AdtId, ContainerId, Lookup, StructFieldId,\n };\n use hir_expand::name::{self, Name};\n+use ra_syntax::ast::RangeOp;\n \n use crate::{\n     autoderef, db::HirDatabase, method_resolution, op, traits::InEnvironment, utils::variant_data,\n@@ -415,45 +416,42 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n                 _ => Ty::Unknown,\n             },\n-            Expr::RangeFull => match self.resolve_range_full() {\n-                Some(adt) => Ty::simple(TypeCtor::Adt(adt)),\n-                None => Ty::Unknown,\n-            },\n-            Expr::Range { lhs, rhs } => {\n-                let lhs_ty = self.infer_expr(*lhs, &Expectation::none());\n-                let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(lhs_ty));\n-                match self.resolve_range() {\n-                    Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), rhs_ty),\n-                    None => Ty::Unknown,\n-                }\n-            }\n-            Expr::RangeInclusive { lhs, rhs } => {\n-                let lhs_ty = self.infer_expr(*lhs, &Expectation::none());\n-                let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(lhs_ty));\n-                match self.resolve_range_inclusive() {\n-                    Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), rhs_ty),\n-                    None => Ty::Unknown,\n-                }\n-            }\n-            Expr::RangeFrom { lhs } => {\n-                let ty = self.infer_expr(*lhs, &Expectation::none());\n-                match self.resolve_range_from() {\n-                    Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n-                    None => Ty::Unknown,\n-                }\n-            }\n-            Expr::RangeTo { rhs } => {\n-                let ty = self.infer_expr(*rhs, &Expectation::none());\n-                match self.resolve_range_to() {\n-                    Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n-                    None => Ty::Unknown,\n-                }\n-            }\n-            Expr::RangeToInclusive { rhs } => {\n-                let ty = self.infer_expr(*rhs, &Expectation::none());\n-                match self.resolve_range_to_inclusive() {\n-                    Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n-                    None => Ty::Unknown,\n+            Expr::Range { lhs, rhs, range_type } => {\n+                let lhs_ty = lhs.map(|e| self.infer_expr(e, &Expectation::none()));\n+                let rhs_expect = lhs_ty\n+                    .as_ref()\n+                    .map_or_else(Expectation::none, |ty| Expectation::has_type(ty.clone()));\n+                let rhs_ty = rhs.map(|e| self.infer_expr(e, &rhs_expect));\n+                match (range_type, lhs_ty, rhs_ty) {\n+                    (RangeOp::Exclusive, None, None) => match self.resolve_range_full() {\n+                        Some(adt) => Ty::simple(TypeCtor::Adt(adt)),\n+                        None => Ty::Unknown,\n+                    },\n+                    (RangeOp::Exclusive, None, Some(ty)) => match self.resolve_range_to() {\n+                        Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                        None => Ty::Unknown,\n+                    },\n+                    (RangeOp::Inclusive, None, Some(ty)) => {\n+                        match self.resolve_range_to_inclusive() {\n+                            Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                            None => Ty::Unknown,\n+                        }\n+                    }\n+                    (RangeOp::Exclusive, Some(_), Some(ty)) => match self.resolve_range() {\n+                        Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                        None => Ty::Unknown,\n+                    },\n+                    (RangeOp::Inclusive, Some(_), Some(ty)) => {\n+                        match self.resolve_range_inclusive() {\n+                            Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                            None => Ty::Unknown,\n+                        }\n+                    }\n+                    (RangeOp::Exclusive, Some(ty), None) => match self.resolve_range_from() {\n+                        Some(adt) => Ty::apply_one(TypeCtor::Adt(adt), ty),\n+                        None => Ty::Unknown,\n+                    },\n+                    (RangeOp::Inclusive, _, None) => Ty::Unknown,\n                 }\n             }\n             Expr::Index { base, index } => {"}]}