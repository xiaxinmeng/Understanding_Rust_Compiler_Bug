{"sha": "33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZWYwYmFkMjFkNmJiNjQ2YzdjM2FiMGRiZjM4MWNhOTZjMzI0YmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-27T13:20:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-27T13:20:16Z"}, "message": "Auto merge of #59415 - varkor:values_since_snapshot, r=eddyb\n\nRefactor InferenceFudger (n\u00e9e RegionFudger)\n\n- Rename `RegionFudger` (and related methods) to `InferenceFudger`.\n- Take integer and float inference variables into account.\n- Refactor `types_created_since_snapshot` and `vars_created_since_snapshot` with the [new version of ena](https://github.com/rust-lang-nursery/ena/pull/21).\n- Some other refactoring in the area.\n\nr? @eddyb", "tree": {"sha": "4ecc12251d92fb72ffb00b111a19f6dfc191582e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ecc12251d92fb72ffb00b111a19f6dfc191582e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "html_url": "https://github.com/rust-lang/rust/commit/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5fb4d0d2f464bc9ab61f7693ed4dde4d9326820", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5fb4d0d2f464bc9ab61f7693ed4dde4d9326820", "html_url": "https://github.com/rust-lang/rust/commit/c5fb4d0d2f464bc9ab61f7693ed4dde4d9326820"}, {"sha": "86d5a69d9d884b3c40be464c7dc32261f35accc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/86d5a69d9d884b3c40be464c7dc32261f35accc5", "html_url": "https://github.com/rust-lang/rust/commit/86d5a69d9d884b3c40be464c7dc32261f35accc5"}], "stats": {"total": 232, "additions": 132, "deletions": 100}, "files": [{"sha": "73adb762e485b44056f392667b8bd0d8d16780df", "filename": "Cargo.lock", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "patch": "@@ -780,6 +780,14 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"ena\"\n+version = \"0.13.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"env_logger\"\n version = \"0.5.13\"\n@@ -2662,7 +2670,7 @@ name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ena 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"jobserver 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -4043,6 +4051,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3be565ca5c557d7f59e7cfcf1844f9e3033650c929c6566f511e8005f205c1d0\"\n \"checksum elasticlunr-rs 2.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a99a310cd1f9770e7bf8e48810c7bcbb0e078c8fb23a8c7bcf0da4c2bf61a455\"\n \"checksum ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f56c93cc076508c549d9bb747f79aa9b4eb098be7b8cad8830c3137ef52d1e00\"\n+\"checksum ena 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3dc01d68e08ca384955a3aeba9217102ca1aa85b6e168639bf27739f1d749d87\"\n \"checksum env_logger 0.5.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15b0a4d2e39f8420210be8b27eeda28029729e2fd4291019455016c348240c38\"\n \"checksum env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afb070faf94c85d17d50ca44f6ad076bce18ae92f0037d350947240a36e9d42e\"\n \"checksum error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff511d5dc435d703f4971bc399647c9bc38e20cb41452e3b9feb4765419ed3f3\""}, {"sha": "39b84fabff6fbe38ba58577dd018bd9a146990e7", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "patch": "@@ -360,9 +360,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                         )\n                     }\n \n-                    CanonicalTyVarKind::Int => self.tcx.mk_int_var(self.next_int_var_id()),\n+                    CanonicalTyVarKind::Int => self.next_int_var(),\n \n-                    CanonicalTyVarKind::Float => self.tcx.mk_float_var(self.next_float_var_id()),\n+                    CanonicalTyVarKind::Float => self.next_float_var(),\n                 };\n                 ty.into()\n             }"}, {"sha": "7788ae2b88f21d3cc8310301f8b2690ae7ca3a44", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 84, "deletions": 59, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "patch": "@@ -1,9 +1,11 @@\n-use crate::infer::type_variable::TypeVariableMap;\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, Ty, TyCtxt, TyVid, IntVid, FloatVid, RegionVid};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n \n use super::InferCtxt;\n use super::RegionVariableOrigin;\n+use super::type_variable::TypeVariableOrigin;\n+\n+use std::ops::Range;\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// This rather funky routine is used while processing expected\n@@ -17,7 +19,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// from `&[u32; 3]` to `&[u32]` and make the users life more\n     /// pleasant.\n     ///\n-    /// The way we do this is using `fudge_regions_if_ok`. What the\n+    /// The way we do this is using `fudge_inference_if_ok`. What the\n     /// routine actually does is to start a snapshot and execute the\n     /// closure `f`. In our example above, what this closure will do\n     /// is to unify the expectation (`Option<&[u32]>`) with the actual\n@@ -26,7 +28,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// with `&?a [u32]`, where `?a` is a fresh lifetime variable. The\n     /// input type (`?T`) is then returned by `f()`.\n     ///\n-    /// At this point, `fudge_regions_if_ok` will normalize all type\n+    /// At this point, `fudge_inference_if_ok` will normalize all type\n     /// variables, converting `?T` to `&?a [u32]` and end the\n     /// snapshot. The problem is that we can't just return this type\n     /// out, because it references the region variable `?a`, and that\n@@ -42,36 +44,51 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// regions in question are not particularly important. We will\n     /// use the expected types to guide coercions, but we will still\n     /// type-check the resulting types from those coercions against\n-    /// the actual types (`?T`, `Option<?T`) -- and remember that\n+    /// the actual types (`?T`, `Option<?T>`) -- and remember that\n     /// after the snapshot is popped, the variable `?T` is no longer\n     /// unified.\n-    pub fn fudge_regions_if_ok<T, E, F>(&self,\n-                                        origin: &RegionVariableOrigin,\n-                                        f: F) -> Result<T, E> where\n+    pub fn fudge_inference_if_ok<T, E, F>(\n+        &self,\n+        f: F,\n+    ) -> Result<T, E> where\n         F: FnOnce() -> Result<T, E>,\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\"fudge_regions_if_ok(origin={:?})\", origin);\n+        debug!(\"fudge_inference_if_ok()\");\n \n-        let (type_variables, region_vars, value) = self.probe(|snapshot| {\n+        let (mut fudger, value) = self.probe(|snapshot| {\n             match f() {\n                 Ok(value) => {\n                     let value = self.resolve_type_vars_if_possible(&value);\n \n                     // At this point, `value` could in principle refer\n-                    // to types/regions that have been created during\n+                    // to inference variables that have been created during\n                     // the snapshot. Once we exit `probe()`, those are\n                     // going to be popped, so we will have to\n                     // eliminate any references to them.\n \n-                    let type_variables =\n-                        self.type_variables.borrow_mut().types_created_since_snapshot(\n-                            &snapshot.type_snapshot);\n-                    let region_vars =\n-                        self.borrow_region_constraints().vars_created_since_snapshot(\n-                            &snapshot.region_constraints_snapshot);\n+                    let type_vars = self.type_variables.borrow_mut().vars_since_snapshot(\n+                        &snapshot.type_snapshot,\n+                    );\n+                    let int_vars = self.int_unification_table.borrow_mut().vars_since_snapshot(\n+                        &snapshot.int_snapshot,\n+                    );\n+                    let float_vars = self.float_unification_table.borrow_mut().vars_since_snapshot(\n+                        &snapshot.float_snapshot,\n+                    );\n+                    let region_vars = self.borrow_region_constraints().vars_since_snapshot(\n+                        &snapshot.region_constraints_snapshot,\n+                    );\n+\n+                    let fudger = InferenceFudger {\n+                        infcx: self,\n+                        type_vars,\n+                        int_vars,\n+                        float_vars,\n+                        region_vars,\n+                    };\n \n-                    Ok((type_variables, region_vars, value))\n+                    Ok((fudger, value))\n                 }\n                 Err(e) => Err(e),\n             }\n@@ -84,69 +101,77 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         // Micro-optimization: if no variables have been created, then\n         // `value` can't refer to any of them. =) So we can just return it.\n-        if type_variables.is_empty() && region_vars.is_empty() {\n-            return Ok(value);\n+        if fudger.type_vars.0.is_empty() &&\n+            fudger.int_vars.is_empty() &&\n+            fudger.float_vars.is_empty() &&\n+            fudger.region_vars.0.is_empty() {\n+            Ok(value)\n+        } else {\n+            Ok(value.fold_with(&mut fudger))\n         }\n-\n-        let mut fudger = RegionFudger {\n-            infcx: self,\n-            type_variables: &type_variables,\n-            region_vars: &region_vars,\n-            origin,\n-        };\n-\n-        Ok(value.fold_with(&mut fudger))\n     }\n }\n \n-pub struct RegionFudger<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct InferenceFudger<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    type_variables: &'a TypeVariableMap,\n-    region_vars: &'a Vec<ty::RegionVid>,\n-    origin: &'a RegionVariableOrigin,\n+    type_vars: (Range<TyVid>, Vec<TypeVariableOrigin>),\n+    int_vars: Range<IntVid>,\n+    float_vars: Range<FloatVid>,\n+    region_vars: (Range<RegionVid>, Vec<RegionVariableOrigin>),\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for InferenceFudger<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         match ty.sty {\n             ty::Infer(ty::InferTy::TyVar(vid)) => {\n-                match self.type_variables.get(&vid) {\n-                    None => {\n-                        // This variable was created before the\n-                        // \"fudging\".  Since we refresh all type\n-                        // variables to their binding anyhow, we know\n-                        // that it is unbound, so we can just return\n-                        // it.\n-                        debug_assert!(self.infcx.type_variables.borrow_mut()\n-                                      .probe(vid)\n-                                      .is_unknown());\n-                        ty\n-                    }\n-\n-                    Some(&origin) => {\n-                        // This variable was created during the\n-                        // fudging. Recreate it with a fresh variable\n-                        // here.\n-                        self.infcx.next_ty_var(origin)\n-                    }\n+                if self.type_vars.0.contains(&vid) {\n+                    // This variable was created during the fudging.\n+                    // Recreate it with a fresh variable here.\n+                    let idx = (vid.index - self.type_vars.0.start.index) as usize;\n+                    let origin = self.type_vars.1[idx];\n+                    self.infcx.next_ty_var(origin)\n+                } else {\n+                    // This variable was created before the\n+                    // \"fudging\". Since we refresh all type\n+                    // variables to their binding anyhow, we know\n+                    // that it is unbound, so we can just return\n+                    // it.\n+                    debug_assert!(self.infcx.type_variables.borrow_mut()\n+                                  .probe(vid)\n+                                  .is_unknown());\n+                    ty\n+                }\n+            }\n+            ty::Infer(ty::InferTy::IntVar(vid)) => {\n+                if self.int_vars.contains(&vid) {\n+                    self.infcx.next_int_var()\n+                } else {\n+                    ty\n+                }\n+            }\n+            ty::Infer(ty::InferTy::FloatVar(vid)) => {\n+                if self.float_vars.contains(&vid) {\n+                    self.infcx.next_float_var()\n+                } else {\n+                    ty\n                 }\n             }\n             _ => ty.super_fold_with(self),\n         }\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n-            ty::ReVar(v) if self.region_vars.contains(&v) => {\n-                self.infcx.next_region_var(self.origin.clone())\n-            }\n-            _ => {\n-                r\n+        if let ty::ReVar(vid) = r {\n+            if self.region_vars.0.contains(&vid) {\n+                let idx = (vid.index() - self.region_vars.0.start.index()) as usize;\n+                let origin = self.region_vars.1[idx];\n+                return self.infcx.next_region_var(origin);\n             }\n         }\n+        r\n     }\n }"}, {"sha": "16140d006bf0981eb5803f67afb29f11aef2bec2", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "patch": "@@ -999,14 +999,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_ty_var(self.next_ty_var_id(true, origin))\n     }\n \n-    pub fn next_int_var_id(&self) -> IntVid {\n+    fn next_int_var_id(&self) -> IntVid {\n         self.int_unification_table.borrow_mut().new_key(None)\n     }\n \n-    pub fn next_float_var_id(&self) -> FloatVid {\n+    pub fn next_int_var(&self) -> Ty<'tcx> {\n+        self.tcx.mk_int_var(self.next_int_var_id())\n+    }\n+\n+    fn next_float_var_id(&self) -> FloatVid {\n         self.float_unification_table.borrow_mut().new_key(None)\n     }\n \n+    pub fn next_float_var(&self) -> Ty<'tcx> {\n+        self.tcx.mk_float_var(self.next_float_var_id())\n+    }\n+\n     /// Creates a fresh region variable with the next available index.\n     /// The variable will be created in the maximum universe created\n     /// thus far, allowing it to name any region created thus far."}, {"sha": "6a20d95cc3ad349bb687d73f4a57ebf316fc6507", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "patch": "@@ -16,6 +16,7 @@ use crate::ty::{Region, RegionVid};\n \n use std::collections::BTreeMap;\n use std::{cmp, fmt, mem, u32};\n+use std::ops::Range;\n \n mod leak_check;\n \n@@ -840,13 +841,14 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n-    pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot) -> Vec<RegionVid> {\n-        self.undo_log[mark.length..]\n-            .iter()\n-            .filter_map(|&elt| match elt {\n-                AddVar(vid) => Some(vid),\n-                _ => None,\n-            }).collect()\n+    pub fn vars_since_snapshot(\n+        &self,\n+        mark: &RegionSnapshot,\n+    ) -> (Range<RegionVid>, Vec<RegionVariableOrigin>) {\n+        let range = self.unification_table.vars_since_snapshot(&mark.region_snapshot);\n+        (range.clone(), (range.start.index()..range.end.index()).map(|index| {\n+            self.var_infos[ty::RegionVid::from(index)].origin.clone()\n+        }).collect())\n     }\n \n     /// See [`RegionInference::region_constraints_added_in_snapshot`]."}, {"sha": "8a719ff2bf31c2f4b306b565888f278b53c5f6f7", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "patch": "@@ -1,11 +1,11 @@\n use syntax::symbol::InternedString;\n use syntax_pos::Span;\n-use crate::ty::{self, Ty};\n+use crate::ty::{self, Ty, TyVid};\n \n use std::cmp;\n use std::marker::PhantomData;\n use std::u32;\n-use rustc_data_structures::fx::FxHashMap;\n+use std::ops::Range;\n use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::unify as ut;\n \n@@ -58,8 +58,6 @@ pub enum TypeVariableOrigin {\n     Generalized(ty::TyVid),\n }\n \n-pub type TypeVariableMap = FxHashMap<ty::TyVid, TypeVariableOrigin>;\n-\n struct TypeVariableData {\n     origin: TypeVariableOrigin,\n     diverging: bool,\n@@ -292,24 +290,15 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.sub_relations.commit(sub_snapshot);\n     }\n \n-    /// Returns a map `{V1 -> V2}`, where the keys `{V1}` are\n-    /// ty-variables created during the snapshot, and the values\n-    /// `{V2}` are the root variables that they were unified with,\n-    /// along with their origin.\n-    pub fn types_created_since_snapshot(&mut self, s: &Snapshot<'tcx>) -> TypeVariableMap {\n-        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n-\n-        actions_since_snapshot\n-            .iter()\n-            .filter_map(|action| match action {\n-                &sv::UndoLog::NewElem(index) => Some(ty::TyVid { index: index as u32 }),\n-                _ => None,\n-            })\n-            .map(|vid| {\n-                let origin = self.values.get(vid.index as usize).origin.clone();\n-                (vid, origin)\n-            })\n-            .collect()\n+    /// Returns a range of the type variables created during the snapshot.\n+    pub fn vars_since_snapshot(\n+        &mut self,\n+        s: &Snapshot<'tcx>,\n+    ) -> (Range<TyVid>, Vec<TypeVariableOrigin>) {\n+        let range = self.eq_relations.vars_since_snapshot(&s.eq_snapshot);\n+        (range.start.vid..range.end.vid, (range.start.vid.index..range.end.vid.index).map(|index| {\n+            self.values.get(index as usize).origin.clone()\n+        }).collect())\n     }\n \n     /// Finds the set of type variables that existed *before* `s`"}, {"sha": "e905c3688518bd21e0c0b207d3ffff530bd0fa68", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "patch": "@@ -44,6 +44,7 @@\n #![feature(non_exhaustive)]\n #![feature(proc_macro_internals)]\n #![feature(optin_builtin_traits)]\n+#![feature(range_is_empty)]\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_attrs)]"}, {"sha": "63e44d82a28c3df7517a3ae21ab6eb32e06ab5c2", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-ena = \"0.11\"\n+ena = \"0.13\"\n log = \"0.4\"\n jobserver_crate = { version = \"0.1\", package = \"jobserver\" }\n lazy_static = \"1\""}, {"sha": "ec4fc2a3bfb88d6a329141f960d29d1285688648", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "patch": "@@ -92,7 +92,7 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use crate::middle::lang_items;\n use crate::namespace::Namespace;\n-use rustc::infer::{self, InferCtxt, InferOk, InferResult, RegionVariableOrigin};\n+use rustc::infer::{self, InferCtxt, InferOk, InferResult};\n use rustc::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n@@ -3097,8 +3097,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         _ => None\n                     }\n                 });\n-                opt_ty.unwrap_or_else(\n-                    || tcx.mk_int_var(self.next_int_var_id()))\n+                opt_ty.unwrap_or_else(|| self.next_int_var())\n             }\n             ast::LitKind::Float(_, t) => tcx.mk_mach_float(t),\n             ast::LitKind::FloatUnsuffixed(_) => {\n@@ -3108,8 +3107,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         _ => None\n                     }\n                 });\n-                opt_ty.unwrap_or_else(\n-                    || tcx.mk_float_var(self.next_float_var_id()))\n+                opt_ty.unwrap_or_else(|| self.next_float_var())\n             }\n             ast::LitKind::Bool(_) => tcx.types.bool,\n             ast::LitKind::Err(_) => tcx.types.err,\n@@ -3231,7 +3229,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Some(ret) => ret,\n             None => return Vec::new()\n         };\n-        let expect_args = self.fudge_regions_if_ok(&RegionVariableOrigin::Coercion(call_span), || {\n+        let expect_args = self.fudge_inference_if_ok(|| {\n             // Attempt to apply a subtyping relationship between the formal\n             // return type (likely containing type variables if the function\n             // is polymorphic) and the expected return type."}]}