{"sha": "a7bbd7da4eb98127104fdfd415ad6c746f7e2a12", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YmJkN2RhNGViOTgxMjcxMDRmZGZkNDE1YWQ2Yzc0NmY3ZTJhMTI=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-06-10T04:39:36Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-06-15T03:17:06Z"}, "message": "Implement RFC 1014\n\nCloses #25977\n\nThe various `stdfoo_raw` methods in std::io now return `io::Result`s,\nsince they may not exist on Windows. They will always return `Ok` on\nUnix-like platforms.\n\n[breaking-change]", "tree": {"sha": "f7c2c18daba6885ccf1fa1b028575d3fca54c464", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7c2c18daba6885ccf1fa1b028575d3fca54c464"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12", "html_url": "https://github.com/rust-lang/rust/commit/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2228ce10c6d83c17b6346396aa7c7ef9082f1c04", "url": "https://api.github.com/repos/rust-lang/rust/commits/2228ce10c6d83c17b6346396aa7c7ef9082f1c04", "html_url": "https://github.com/rust-lang/rust/commit/2228ce10c6d83c17b6346396aa7c7ef9082f1c04"}], "stats": {"total": 194, "additions": 161, "deletions": 33}, "files": [{"sha": "9fd48f6795039733337f67094b57b80556d8a071", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 77, "deletions": 19, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=a7bbd7da4eb98127104fdfd415ad6c746f7e2a12", "patch": "@@ -19,6 +19,7 @@ use io::{self, BufReader, LineWriter};\n use sync::{Arc, Mutex, MutexGuard};\n use sys::stdio;\n use sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n+use libc;\n \n /// Stdout used by print! and println! macros\n thread_local! {\n@@ -52,7 +53,7 @@ struct StderrRaw(stdio::Stderr);\n /// handles is **not** available to raw handles returned from this function.\n ///\n /// The returned handle has no external synchronization or buffering.\n-fn stdin_raw() -> StdinRaw { StdinRaw(stdio::Stdin::new()) }\n+fn stdin_raw() -> io::Result<StdinRaw> { stdio::Stdin::new().map(StdinRaw) }\n \n /// Constructs a new raw handle to the standard input stream of this process.\n ///\n@@ -63,7 +64,7 @@ fn stdin_raw() -> StdinRaw { StdinRaw(stdio::Stdin::new()) }\n ///\n /// The returned handle has no external synchronization or buffering layered on\n /// top.\n-fn stdout_raw() -> StdoutRaw { StdoutRaw(stdio::Stdout::new()) }\n+fn stdout_raw() -> io::Result<StdoutRaw> { stdio::Stdout::new().map(StdoutRaw) }\n \n /// Constructs a new raw handle to the standard input stream of this process.\n ///\n@@ -72,7 +73,7 @@ fn stdout_raw() -> StdoutRaw { StdoutRaw(stdio::Stdout::new()) }\n ///\n /// The returned handle has no external synchronization or buffering layered on\n /// top.\n-fn stderr_raw() -> StderrRaw { StderrRaw(stdio::Stderr::new()) }\n+fn stderr_raw() -> io::Result<StderrRaw> { stdio::Stderr::new().map(StderrRaw) }\n \n impl Read for StdinRaw {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n@@ -86,6 +87,48 @@ impl Write for StderrRaw {\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n+enum Maybe<T> {\n+    Real(T),\n+    Fake,\n+}\n+\n+impl<W: io::Write> io::Write for Maybe<W> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        match *self {\n+            Maybe::Real(ref mut w) => handle_ebadf(w.write(buf), buf.len()),\n+            Maybe::Fake => Ok(buf.len())\n+        }\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        match *self {\n+            Maybe::Real(ref mut w) => handle_ebadf(w.flush(), ()),\n+            Maybe::Fake => Ok(())\n+        }\n+    }\n+}\n+\n+impl<R: io::Read> io::Read for Maybe<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        match *self {\n+            Maybe::Real(ref mut r) => handle_ebadf(r.read(buf), buf.len()),\n+            Maybe::Fake => Ok(0)\n+        }\n+    }\n+}\n+\n+fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n+    #[cfg(windows)]\n+    const ERR: libc::c_int = libc::ERROR_INVALID_HANDLE;\n+    #[cfg(not(windows))]\n+    const ERR: libc::c_int = libc::EBADF;\n+\n+    match r {\n+        Err(ref e) if e.raw_os_error() == Some(ERR) => Ok(default),\n+        r => r\n+    }\n+}\n+\n /// A handle to the standard input stream of a process.\n ///\n /// Each handle is a shared reference to a global buffer of input data to this\n@@ -99,7 +142,7 @@ impl Write for StderrRaw {\n /// Created by the function `io::stdin()`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stdin {\n-    inner: Arc<Mutex<BufReader<StdinRaw>>>,\n+    inner: Arc<Mutex<BufReader<Maybe<StdinRaw>>>>,\n }\n \n /// A locked reference to the a `Stdin` handle.\n@@ -108,7 +151,7 @@ pub struct Stdin {\n /// constructed via the `lock` method on `Stdin`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdinLock<'a> {\n-    inner: MutexGuard<'a, BufReader<StdinRaw>>,\n+    inner: MutexGuard<'a, BufReader<Maybe<StdinRaw>>>,\n }\n \n /// Creates a new handle to the global standard input stream of this process.\n@@ -122,20 +165,25 @@ pub struct StdinLock<'a> {\n /// locked version, `StdinLock`, implements both `Read` and `BufRead`, however.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdin() -> Stdin {\n-    static INSTANCE: Lazy<Mutex<BufReader<StdinRaw>>> = Lazy::new(stdin_init);\n+    static INSTANCE: Lazy<Mutex<BufReader<Maybe<StdinRaw>>>> = Lazy::new(stdin_init);\n     return Stdin {\n         inner: INSTANCE.get().expect(\"cannot access stdin during shutdown\"),\n     };\n \n-    fn stdin_init() -> Arc<Mutex<BufReader<StdinRaw>>> {\n+    fn stdin_init() -> Arc<Mutex<BufReader<Maybe<StdinRaw>>>> {\n+        let stdin = match stdin_raw() {\n+            Ok(stdin) => Maybe::Real(stdin),\n+            _ => Maybe::Fake\n+        };\n+\n         // The default buffer capacity is 64k, but apparently windows\n         // doesn't like 64k reads on stdin. See #13304 for details, but the\n         // idea is that on windows we use a slightly smaller buffer that's\n         // been seen to be acceptable.\n         Arc::new(Mutex::new(if cfg!(windows) {\n-            BufReader::with_capacity(8 * 1024, stdin_raw())\n+            BufReader::with_capacity(8 * 1024, stdin)\n         } else {\n-            BufReader::new(stdin_raw())\n+            BufReader::new(stdin)\n         }))\n     }\n }\n@@ -181,6 +229,7 @@ impl<'a> Read for StdinLock<'a> {\n         self.inner.read(buf)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> BufRead for StdinLock<'a> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }\n@@ -215,7 +264,7 @@ pub struct Stdout {\n     // FIXME: this should be LineWriter or BufWriter depending on the state of\n     //        stdout (tty or not). Note that if this is not line buffered it\n     //        should also flush-on-panic or some form of flush-on-abort.\n-    inner: Arc<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>>,\n+    inner: Arc<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>>,\n }\n \n /// A locked reference to the a `Stdout` handle.\n@@ -224,7 +273,7 @@ pub struct Stdout {\n /// method on `Stdout`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdoutLock<'a> {\n-    inner: ReentrantMutexGuard<'a, RefCell<LineWriter<StdoutRaw>>>,\n+    inner: ReentrantMutexGuard<'a, RefCell<LineWriter<Maybe<StdoutRaw>>>>,\n }\n \n /// Constructs a new reference to the standard output of the current process.\n@@ -236,13 +285,18 @@ pub struct StdoutLock<'a> {\n /// The returned handle implements the `Write` trait.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = Lazy::new(stdout_init);\n+    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>>\n+        = Lazy::new(stdout_init);\n     return Stdout {\n         inner: INSTANCE.get().expect(\"cannot access stdout during shutdown\"),\n     };\n \n-    fn stdout_init() -> Arc<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> {\n-        Arc::new(ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw()))))\n+    fn stdout_init() -> Arc<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>> {\n+        let stdout = match stdout_raw() {\n+            Ok(stdout) => Maybe::Real(stdout),\n+            _ => Maybe::Fake,\n+        };\n+        Arc::new(ReentrantMutex::new(RefCell::new(LineWriter::new(stdout))))\n     }\n }\n \n@@ -288,7 +342,7 @@ impl<'a> Write for StdoutLock<'a> {\n /// For more information, see `stderr`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stderr {\n-    inner: Arc<ReentrantMutex<RefCell<StderrRaw>>>,\n+    inner: Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>>,\n }\n \n /// A locked reference to the a `Stderr` handle.\n@@ -297,7 +351,7 @@ pub struct Stderr {\n /// method on `Stderr`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StderrLock<'a> {\n-    inner: ReentrantMutexGuard<'a, RefCell<StderrRaw>>,\n+    inner: ReentrantMutexGuard<'a, RefCell<Maybe<StderrRaw>>>,\n }\n \n /// Constructs a new reference to the standard error stream of a process.\n@@ -308,13 +362,17 @@ pub struct StderrLock<'a> {\n /// The returned handle implements the `Write` trait.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stderr() -> Stderr {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<StderrRaw>>> = Lazy::new(stderr_init);\n+    static INSTANCE: Lazy<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> = Lazy::new(stderr_init);\n     return Stderr {\n         inner: INSTANCE.get().expect(\"cannot access stderr during shutdown\"),\n     };\n \n-    fn stderr_init() -> Arc<ReentrantMutex<RefCell<StderrRaw>>> {\n-        Arc::new(ReentrantMutex::new(RefCell::new(stderr_raw())))\n+    fn stderr_init() -> Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> {\n+        let stderr = match stderr_raw() {\n+            Ok(stderr) => Maybe::Real(stderr),\n+            _ => Maybe::Fake,\n+        };\n+        Arc::new(ReentrantMutex::new(RefCell::new(stderr)))\n     }\n }\n "}, {"sha": "01588843591f370c20a3125c755c39a3fecd9191", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=a7bbd7da4eb98127104fdfd415ad6c746f7e2a12", "patch": "@@ -33,7 +33,10 @@ pub fn on_panic(obj: &(Any+Send), file: &'static str, line: u32) {\n             None => \"Box<Any>\",\n         }\n     };\n-    let mut err = Stderr::new();\n+    let mut err = match Stderr::new() {\n+        Ok(err) => err,\n+        _ => return,\n+    };\n     let thread = thread_info::current_thread();\n     let name = thread.as_ref().and_then(|t| t.name()).unwrap_or(\"<unnamed>\");\n     let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());"}, {"sha": "04f36d99c8eb5155ccb8014cc28bc5451eff2267", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=a7bbd7da4eb98127104fdfd415ad6c746f7e2a12", "patch": "@@ -63,7 +63,7 @@ pub const ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n                                   cfg!(rtassert);\n \n pub fn dumb_print(args: fmt::Arguments) {\n-    let _ = Stderr::new().write_fmt(args);\n+    let _ = Stderr::new().map(|mut stderr| stderr.write_fmt(args));\n }\n \n pub fn abort(args: fmt::Arguments) -> ! {"}, {"sha": "fce52f8f92ba8e992e4d793a921fa4a455dbc75d", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=a7bbd7da4eb98127104fdfd415ad6c746f7e2a12", "patch": "@@ -19,7 +19,7 @@ pub struct Stdout(());\n pub struct Stderr(());\n \n impl Stdin {\n-    pub fn new() -> Stdin { Stdin(()) }\n+    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n \n     pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(libc::STDIN_FILENO);\n@@ -30,7 +30,7 @@ impl Stdin {\n }\n \n impl Stdout {\n-    pub fn new() -> Stdout { Stdout(()) }\n+    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(libc::STDOUT_FILENO);\n@@ -41,7 +41,7 @@ impl Stdout {\n }\n \n impl Stderr {\n-    pub fn new() -> Stderr { Stderr(()) }\n+    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n         let fd = FileDesc::new(libc::STDERR_FILENO);"}, {"sha": "9961fef714abbb2228b499dd6c2063350a3d0d81", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=a7bbd7da4eb98127104fdfd415ad6c746f7e2a12", "patch": "@@ -77,11 +77,13 @@ fn write(out: &Output, data: &[u8]) -> io::Result<usize> {\n }\n \n impl Stdin {\n-    pub fn new() -> Stdin {\n-        Stdin {\n-            handle: get(c::STD_INPUT_HANDLE).unwrap(),\n-            utf8: Mutex::new(Cursor::new(Vec::new())),\n-        }\n+    pub fn new() -> io::Result<Stdin> {\n+        get(c::STD_INPUT_HANDLE).map(|handle| {\n+            Stdin {\n+                handle: handle,\n+                utf8: Mutex::new(Cursor::new(Vec::new())),\n+            }\n+        })\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -116,8 +118,8 @@ impl Stdin {\n }\n \n impl Stdout {\n-    pub fn new() -> Stdout {\n-        Stdout(get(c::STD_OUTPUT_HANDLE).unwrap())\n+    pub fn new() -> io::Result<Stdout> {\n+        get(c::STD_OUTPUT_HANDLE).map(Stdout)\n     }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n@@ -126,8 +128,8 @@ impl Stdout {\n }\n \n impl Stderr {\n-    pub fn new() -> Stderr {\n-        Stderr(get(c::STD_ERROR_HANDLE).unwrap())\n+    pub fn new() -> io::Result<Stderr> {\n+        get(c::STD_ERROR_HANDLE).map(Stderr)\n     }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {"}, {"sha": "ad76daaace49b9a4b4cbef072909b8d101360279", "filename": "src/test/run-pass/rfc-1014-2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Ftest%2Frun-pass%2Frfc-1014-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Ftest%2Frun-pass%2Frfc-1014-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1014-2.rs?ref=a7bbd7da4eb98127104fdfd415ad6c746f7e2a12", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(libc)]\n+\n+extern crate libc;\n+\n+#[cfg(windows)]\n+extern \"system\" {\n+    fn SetStdHandle(nStdHandle: libc::DWORD, nHandle: libc::HANDLE) -> libc::BOOL;\n+}\n+\n+#[cfg(windows)]\n+fn close_stdout() {\n+    const STD_OUTPUT_HANDLE: libc::DWORD = -11i32 as libc::DWORD;\n+    unsafe { SetStdHandle(STD_OUTPUT_HANDLE, 0 as libc::HANDLE); }\n+}\n+\n+#[cfg(windows)]\n+fn main() {\n+    close_stdout();\n+    println!(\"hello world\");\n+}\n+\n+#[cfg(not(windows))]\n+fn main() {}"}, {"sha": "98cad4efab71adee437c15a94076f669495c5964", "filename": "src/test/run-pass/rfc-1014.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Ftest%2Frun-pass%2Frfc-1014.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7bbd7da4eb98127104fdfd415ad6c746f7e2a12/src%2Ftest%2Frun-pass%2Frfc-1014.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1014.rs?ref=a7bbd7da4eb98127104fdfd415ad6c746f7e2a12", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(libc)]\n+\n+extern crate libc;\n+\n+#[cfg(windows)]\n+extern \"system\" {\n+    pub fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;\n+}\n+\n+#[cfg(windows)]\n+fn close_stdout() {\n+    const STD_OUTPUT_HANDLE: libc::DWORD = -11i32 as libc::DWORD;\n+    unsafe { libc::CloseHandle(GetStdHandle(STD_OUTPUT_HANDLE)); }\n+}\n+\n+#[cfg(not(windows))]\n+fn close_stdout() {\n+    unsafe { libc::close(libc::STDOUT_FILENO); }\n+}\n+\n+fn main() {\n+    close_stdout();\n+    println!(\"hello world\");\n+}"}]}