{"sha": "bca0dd9a7685c090b3de9751751f2438105cb65d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYTBkZDlhNzY4NWMwOTBiM2RlOTc1MTc1MWYyNDM4MTA1Y2I2NWQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-07-26T23:07:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-26T23:07:17Z"}, "message": "Merge pull request #1821 from topecongiro/avoid-unnecessary-line-breaks\n\nAvoid unnecessary line breaks", "tree": {"sha": "5b824c739f73a4f3b8e9928ba7e21d50334301ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b824c739f73a4f3b8e9928ba7e21d50334301ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bca0dd9a7685c090b3de9751751f2438105cb65d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bca0dd9a7685c090b3de9751751f2438105cb65d", "html_url": "https://github.com/rust-lang/rust/commit/bca0dd9a7685c090b3de9751751f2438105cb65d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bca0dd9a7685c090b3de9751751f2438105cb65d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b5831b5016bf9565f55e1975602c80b5151bd50", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b5831b5016bf9565f55e1975602c80b5151bd50", "html_url": "https://github.com/rust-lang/rust/commit/8b5831b5016bf9565f55e1975602c80b5151bd50"}, {"sha": "38614e7af124c59c0d82d360af55b2eeed67bea3", "url": "https://api.github.com/repos/rust-lang/rust/commits/38614e7af124c59c0d82d360af55b2eeed67bea3", "html_url": "https://github.com/rust-lang/rust/commit/38614e7af124c59c0d82d360af55b2eeed67bea3"}], "stats": {"total": 249, "additions": 109, "deletions": 140}, "files": [{"sha": "d332c354b12eac17887f2b9666890ff42bf7399e", "filename": "src/comment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=bca0dd9a7685c090b3de9751751f2438105cb65d", "patch": "@@ -314,8 +314,8 @@ fn left_trim_comment_line<'a>(line: &'a str, style: &CommentStyle) -> &'a str {\n             &line[opener.trim_right().len()..]\n         }\n     } else if line.starts_with(\"/* \") || line.starts_with(\"// \") || line.starts_with(\"//!\") ||\n-        line.starts_with(\"///\") ||\n-        line.starts_with(\"** \") || line.starts_with(\"/*!\") ||\n+        line.starts_with(\"///\") || line.starts_with(\"** \") ||\n+        line.starts_with(\"/*!\") ||\n         (line.starts_with(\"/**\") && !line.starts_with(\"/**/\"))\n     {\n         &line[3..]"}, {"sha": "ab6bcb53e5ad4b9dd0449bd3bde0211151ba88bb", "filename": "src/expr.rs", "status": "modified", "additions": 59, "deletions": 82, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=bca0dd9a7685c090b3de9751751f2438105cb65d", "patch": "@@ -334,8 +334,7 @@ pub fn format_expr(\n             shape,\n         ),\n         ast::ExprKind::Catch(ref block) => {\n-            if let rewrite @ Some(_) =\n-                rewrite_single_line_block(context, \"do catch \", block, shape)\n+            if let rewrite @ Some(_) = rewrite_single_line_block(context, \"do catch \", block, shape)\n             {\n                 return rewrite;\n             }\n@@ -371,56 +370,37 @@ where\n     LHS: Rewrite,\n     RHS: Rewrite,\n {\n-    // Get \"full width\" rhs and see if it fits on the current line. This\n-    // usually works fairly well since it tends to place operands of\n-    // operations with high precendence close together.\n-    // Note that this is non-conservative, but its just to see if it's even\n-    // worth trying to put everything on one line.\n-    let rhs_shape = try_opt!(shape.sub_width(suffix.len()));\n-    let rhs_orig_result = rhs.rewrite(context, rhs_shape);\n+    let sep = if infix.ends_with(' ') { \" \" } else { \"\" };\n+    let infix = infix.trim_right();\n+    let lhs_overhead = shape.used_width() + prefix.len() + infix.len();\n+    let lhs_shape = Shape {\n+        width: try_opt!(context.config.max_width().checked_sub(lhs_overhead)),\n+        ..shape\n+    };\n+    let lhs_result = try_opt!(\n+        lhs.rewrite(context, lhs_shape)\n+            .map(|lhs_str| format!(\"{}{}{}\", prefix, lhs_str, infix))\n+    );\n \n+    // Try to the both lhs and rhs on the same line.\n+    let rhs_orig_result = shape\n+        .offset_left(last_line_width(&lhs_result) + suffix.len() + sep.len())\n+        .and_then(|rhs_shape| rhs.rewrite(context, rhs_shape));\n     if let Some(ref rhs_result) = rhs_orig_result {\n-        // This is needed in case of line break not caused by a\n-        // shortage of space, but by end-of-line comments, for example.\n-        if !rhs_result.contains('\\n') {\n-            let lhs_shape =\n-                try_opt!(try_opt!(shape.offset_left(prefix.len())).sub_width(infix.len()));\n-            let lhs_result = lhs.rewrite(context, lhs_shape);\n-            if let Some(lhs_result) = lhs_result {\n-                let mut result = format!(\"{}{}{}\", prefix, lhs_result, infix);\n-\n-                let remaining_width = shape\n-                    .width\n-                    .checked_sub(last_line_width(&result) + suffix.len())\n-                    .unwrap_or(0);\n-\n-                if rhs_result.len() <= remaining_width {\n-                    result.push_str(&rhs_result);\n-                    result.push_str(suffix);\n-                    return Some(result);\n-                }\n-\n-                // Try rewriting the rhs into the remaining space.\n-                let rhs_shape = shape.offset_left(last_line_width(&result) + suffix.len());\n-                if let Some(rhs_shape) = rhs_shape {\n-                    if let Some(rhs_result) = rhs.rewrite(context, rhs_shape) {\n-                        // FIXME this should always hold.\n-                        if rhs_result.len() <= remaining_width {\n-                            result.push_str(&rhs_result);\n-                            result.push_str(suffix);\n-                            return Some(result);\n-                        }\n-                    }\n-                }\n-            }\n+        // If the rhs looks like block expression, we allow it to stay on the same line\n+        // with the lhs even if it is multi-lined.\n+        let allow_same_line = rhs_result\n+            .lines()\n+            .next()\n+            .map(|first_line| first_line.ends_with('{'))\n+            .unwrap_or(false);\n+        if !rhs_result.contains('\\n') || allow_same_line {\n+            return Some(format!(\"{}{}{}{}\", lhs_result, sep, rhs_result, suffix));\n         }\n     }\n \n     // We have to use multiple lines.\n-\n     // Re-evaluate the rhs because we have more space now:\n-    let sep = if infix.ends_with(' ') { \" \" } else { \"\" };\n-    let infix = infix.trim_right();\n     let rhs_shape = match context.config.control_style() {\n         Style::Legacy => {\n             try_opt!(shape.sub_width(suffix.len() + prefix.len())).visual_indent(prefix.len())\n@@ -435,26 +415,6 @@ where\n         }\n     };\n     let rhs_result = try_opt!(rhs.rewrite(context, rhs_shape));\n-    let lhs_overhead = shape.used_width() + prefix.len() + infix.len();\n-    let lhs_shape = Shape {\n-        width: try_opt!(context.config.max_width().checked_sub(lhs_overhead)),\n-        ..shape\n-    };\n-    let lhs_result = try_opt!(\n-        lhs.rewrite(context, lhs_shape)\n-            .map(|lhs_str| format!(\"{}{}{}\", prefix, lhs_str, infix))\n-    );\n-    if let Some(ref rhs_str) = rhs_orig_result {\n-        if rhs_str.lines().count() <= rhs_result.lines().count() &&\n-            rhs_str\n-                .lines()\n-                .next()\n-                .map_or(false, |first_line| first_line.ends_with('{')) &&\n-            last_line_width(&lhs_result) + sep.len() + first_line_width(rhs_str) <= shape.width\n-        {\n-            return Some(format!(\"{}{}{}{}\", lhs_result, sep, rhs_str, suffix));\n-        }\n-    }\n     Some(format!(\n         \"{}\\n{}{}{}\",\n         lhs_result,\n@@ -697,8 +657,8 @@ fn rewrite_closure(\n         }\n \n         // Figure out if the block is necessary.\n-        let needs_block = block.rules != ast::BlockCheckMode::Default ||\n-            block.stmts.len() > 1 || context.inside_macro ||\n+        let needs_block = block.rules != ast::BlockCheckMode::Default || block.stmts.len() > 1 ||\n+            context.inside_macro ||\n             block_contains_comment(block, context.codemap) ||\n             prefix.contains('\\n');\n \n@@ -826,8 +786,7 @@ fn rewrite_empty_block(\n     block: &ast::Block,\n     shape: Shape,\n ) -> Option<String> {\n-    if block.stmts.is_empty() && !block_contains_comment(block, context.codemap) &&\n-        shape.width >= 2\n+    if block.stmts.is_empty() && !block_contains_comment(block, context.codemap) && shape.width >= 2\n     {\n         return Some(\"{}\".to_owned());\n     }\n@@ -1197,12 +1156,23 @@ impl<'a> ControlFlow<'a> {\n         shape: Shape,\n         alt_block_sep: &str,\n     ) -> Option<(String, usize)> {\n+        // Do not take the rhs overhead from the upper expressions into account\n+        // when rewriting pattern.\n+        let new_width = context\n+            .config\n+            .max_width()\n+            .checked_sub(shape.used_width())\n+            .unwrap_or(0);\n+        let fresh_shape = Shape {\n+            width: new_width,\n+            ..shape\n+        };\n         let constr_shape = if self.nested_if {\n             // We are part of an if-elseif-else chain. Our constraints are tightened.\n             // 7 = \"} else \" .len()\n-            try_opt!(shape.offset_left(7))\n+            try_opt!(fresh_shape.offset_left(7))\n         } else {\n-            shape\n+            fresh_shape\n         };\n \n         let label_string = rewrite_label(self.label);\n@@ -1211,15 +1181,10 @@ impl<'a> ControlFlow<'a> {\n \n         let pat_expr_string = match self.cond {\n             Some(cond) => {\n-                let mut cond_shape = match context.config.control_style() {\n+                let cond_shape = match context.config.control_style() {\n                     Style::Legacy => try_opt!(constr_shape.shrink_left(offset)),\n                     Style::Rfc => try_opt!(constr_shape.offset_left(offset)),\n                 };\n-                if context.config.control_brace_style() != ControlBraceStyle::AlwaysNextLine {\n-                    // 2 = \" {\".len()\n-                    cond_shape = try_opt!(cond_shape.sub_width(2));\n-                }\n-\n                 try_opt!(rewrite_pat_expr(\n                     context,\n                     self.pat,\n@@ -1233,8 +1198,20 @@ impl<'a> ControlFlow<'a> {\n             None => String::new(),\n         };\n \n+        let brace_overhead =\n+            if context.config.control_brace_style() != ControlBraceStyle::AlwaysNextLine {\n+                // 2 = ` {`\n+                2\n+            } else {\n+                0\n+            };\n+        let one_line_budget = context\n+            .config\n+            .max_width()\n+            .checked_sub(constr_shape.used_width() + offset + brace_overhead)\n+            .unwrap_or(0);\n         let force_newline_brace = context.config.control_style() == Style::Rfc &&\n-            pat_expr_string.contains('\\n') &&\n+            (pat_expr_string.contains('\\n') || pat_expr_string.len() > one_line_budget) &&\n             !last_line_extendable(&pat_expr_string);\n \n         // Try to format if-else on single line.\n@@ -2304,10 +2281,10 @@ fn rewrite_last_closure(\n         let body_shape = try_opt!(shape.offset_left(extra_offset));\n         // When overflowing the closure which consists of a single control flow expression,\n         // force to use block if its condition uses multi line.\n-        if rewrite_cond(context, body, body_shape)\n-            .map(|cond| cond.contains('\\n'))\n-            .unwrap_or(false)\n-        {\n+        let is_multi_lined_cond = rewrite_cond(context, body, body_shape)\n+            .map(|cond| cond.contains('\\n') || cond.len() > body_shape.width)\n+            .unwrap_or(false);\n+        if is_multi_lined_cond {\n             return rewrite_closure_with_block(context, body_shape, &prefix, body);\n         }\n "}, {"sha": "69249a4522d3356300db231324baf15287be48b1", "filename": "src/imports.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=bca0dd9a7685c090b3de9751751f2438105cb65d", "patch": "@@ -482,18 +482,18 @@ fn rewrite_use_list(\n     };\n     let list_str = try_opt!(write_list(&items[first_index..], &fmt));\n \n-    let result =\n-        if list_str.contains('\\n') && context.config.imports_indent() == IndentStyle::Block {\n-            format!(\n-                \"{}{{\\n{}{}\\n{}}}\",\n-                path_str,\n-                nested_shape.indent.to_string(context.config),\n-                list_str,\n-                shape.indent.to_string(context.config)\n-            )\n-        } else {\n-            format!(\"{}{{{}}}\", path_str, list_str)\n-        };\n+    let result = if list_str.contains('\\n') && context.config.imports_indent() == IndentStyle::Block\n+    {\n+        format!(\n+            \"{}{{\\n{}{}\\n{}}}\",\n+            path_str,\n+            nested_shape.indent.to_string(context.config),\n+            list_str,\n+            shape.indent.to_string(context.config)\n+        )\n+    } else {\n+        format!(\"{}{{{}}}\", path_str, list_str)\n+    };\n     Some(result)\n }\n "}, {"sha": "63e6eb7bc66e8a0fef1426236469b0409e9ca498", "filename": "src/items.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=bca0dd9a7685c090b3de9751751f2438105cb65d", "patch": "@@ -2734,9 +2734,7 @@ fn format_generics(\n     let shape = Shape::legacy(context.budget(used_width + offset.width()), offset);\n     let mut result = try_opt!(rewrite_generics(context, generics, shape, span));\n \n-    let same_line_brace = if !generics.where_clause.predicates.is_empty() ||\n-        result.contains('\\n')\n-    {\n+    let same_line_brace = if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n         let budget = context\n             .config\n             .max_width()"}, {"sha": "03afe2d81b12230ead6036a1a5fede59962580c8", "filename": "src/patterns.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=bca0dd9a7685c090b3de9751751f2438105cb65d", "patch": "@@ -291,17 +291,17 @@ fn rewrite_tuple_pat(\n     }\n \n     let wildcard_suffix_len = count_wildcard_suffix_len(context, &pat_vec, span, shape);\n-    let (pat_vec, span) =\n-        if context.config.condense_wildcard_suffixes() && wildcard_suffix_len >= 2 {\n-            let new_item_count = 1 + pat_vec.len() - wildcard_suffix_len;\n-            let sp = pat_vec[new_item_count - 1].span();\n-            let snippet = context.snippet(sp);\n-            let lo = sp.lo + BytePos(snippet.find_uncommented(\"_\").unwrap() as u32);\n-            pat_vec[new_item_count - 1] = TuplePatField::Dotdot(mk_sp(lo, lo + BytePos(1)));\n-            (&pat_vec[..new_item_count], mk_sp(span.lo, lo + BytePos(1)))\n-        } else {\n-            (&pat_vec[..], span)\n-        };\n+    let (pat_vec, span) = if context.config.condense_wildcard_suffixes() && wildcard_suffix_len >= 2\n+    {\n+        let new_item_count = 1 + pat_vec.len() - wildcard_suffix_len;\n+        let sp = pat_vec[new_item_count - 1].span();\n+        let snippet = context.snippet(sp);\n+        let lo = sp.lo + BytePos(snippet.find_uncommented(\"_\").unwrap() as u32);\n+        pat_vec[new_item_count - 1] = TuplePatField::Dotdot(mk_sp(lo, lo + BytePos(1)));\n+        (&pat_vec[..new_item_count], mk_sp(span.lo, lo + BytePos(1)))\n+    } else {\n+        (&pat_vec[..], span)\n+    };\n \n     // add comma if `(x,)`\n     let add_comma = path_str.is_none() && pat_vec.len() == 1 && dotdot_pos.is_none();"}, {"sha": "57a09a91501d89c1dace4364cfd2833511a28592", "filename": "src/types.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=bca0dd9a7685c090b3de9751751f2438105cb65d", "patch": "@@ -44,12 +44,11 @@ pub fn rewrite_path(\n ) -> Option<String> {\n     let skip_count = qself.map_or(0, |x| x.position);\n \n-    let mut result =\n-        if path.is_global() && qself.is_none() && path_context != PathContext::Import {\n-            \"::\".to_owned()\n-        } else {\n-            String::new()\n-        };\n+    let mut result = if path.is_global() && qself.is_none() && path_context != PathContext::Import {\n+        \"::\".to_owned()\n+    } else {\n+        String::new()\n+    };\n \n     let mut span_lo = path.span.lo;\n \n@@ -633,13 +632,13 @@ impl Rewrite for ast::PolyTraitRef {\n                 Shape::legacy(max_path_width, shape.indent + extra_offset),\n             ));\n \n-            Some(if context.config.spaces_within_angle_brackets() &&\n-                lifetime_str.len() > 0\n-            {\n-                format!(\"for< {} > {}\", lifetime_str, path_str)\n-            } else {\n-                format!(\"for<{}> {}\", lifetime_str, path_str)\n-            })\n+            Some(\n+                if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n+                    format!(\"for< {} > {}\", lifetime_str, path_str)\n+                } else {\n+                    format!(\"for<{}> {}\", lifetime_str, path_str)\n+                },\n+            )\n         } else {\n             self.trait_ref.rewrite(context, shape)\n         }"}, {"sha": "c657a4050e2160cdfc249abbc43c0735add06420", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca0dd9a7685c090b3de9751751f2438105cb65d/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=bca0dd9a7685c090b3de9751751f2438105cb65d", "patch": "@@ -328,8 +328,7 @@ impl<'a> FmtVisitor<'a> {\n             }\n             ast::ItemKind::Trait(..) => {\n                 self.format_missing_with_indent(item.span.lo);\n-                if let Some(trait_str) =\n-                    format_trait(&self.get_context(), item, self.block_indent)\n+                if let Some(trait_str) = format_trait(&self.get_context(), item, self.block_indent)\n                 {\n                     self.buffer.push_str(&trait_str);\n                     self.last_pos = source!(self, item.span).hi;"}, {"sha": "cfd7192b8b4a030347c4239a1653a74f8be7f42f", "filename": "tests/target/chains-visual.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bca0dd9a7685c090b3de9751751f2438105cb65d/tests%2Ftarget%2Fchains-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca0dd9a7685c090b3de9751751f2438105cb65d/tests%2Ftarget%2Fchains-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-visual.rs?ref=bca0dd9a7685c090b3de9751751f2438105cb65d", "patch": "@@ -119,10 +119,10 @@ fn floaters() {\n     .quux();\n \n     a + match x {\n-        true => \"yay!\",\n-        false => \"boo!\",\n-    }\n-    .bar()\n+            true => \"yay!\",\n+            false => \"boo!\",\n+        }\n+        .bar()\n }\n \n fn is_replaced_content() -> bool {"}, {"sha": "48aa74317365b515136fe8cd84922a719e1d6ee3", "filename": "tests/target/configs-control_style-rfc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bca0dd9a7685c090b3de9751751f2438105cb65d/tests%2Ftarget%2Fconfigs-control_style-rfc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca0dd9a7685c090b3de9751751f2438105cb65d/tests%2Ftarget%2Fconfigs-control_style-rfc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-control_style-rfc.rs?ref=bca0dd9a7685c090b3de9751751f2438105cb65d", "patch": "@@ -12,8 +12,7 @@ fn main() {\n                 foo\n             }\n             if ai_timer.elapsed_time().as_microseconds() > ai_time.as_microseconds() {\n-                if ball.position().y + ball_radius >\n-                    right_paddle.position().y + paddle_size.y / 2.\n+                if ball.position().y + ball_radius > right_paddle.position().y + paddle_size.y / 2.\n                 {\n                     foo\n                 }"}, {"sha": "661637b743e9c5a796f0c3d0f2520bf1ecd631ce", "filename": "tests/target/expr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bca0dd9a7685c090b3de9751751f2438105cb65d/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca0dd9a7685c090b3de9751751f2438105cb65d/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=bca0dd9a7685c090b3de9751751f2438105cb65d", "patch": "@@ -346,12 +346,10 @@ fn complex_if_else() {\n         ha();\n     } else if xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + xxxxxxxx {\n         yo();\n-    } else if let Some(x) =\n-        xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n+    } else if let Some(x) = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n     {\n         ha();\n-    } else if xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx +\n-        xxxxxxxxx\n+    } else if xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx + xxxxxxxxx\n     {\n         yo();\n     }"}, {"sha": "815f920a3c233cce0d15eb546f446c686fccf2fb", "filename": "tests/target/loop.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bca0dd9a7685c090b3de9751751f2438105cb65d/tests%2Ftarget%2Floop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca0dd9a7685c090b3de9751751f2438105cb65d/tests%2Ftarget%2Floop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Floop.rs?ref=bca0dd9a7685c090b3de9751751f2438105cb65d", "patch": "@@ -12,18 +12,17 @@ fn main() {\n         // Just comments\n     }\n \n-    'a: while loooooooooooooooooooooooooooooooooong_variable_name + another_value >\n-        some_other_value\n-    {}\n+    'a: while loooooooooooooooooooooooooooooooooong_variable_name + another_value > some_other_value\n+    {\n+    }\n \n     while aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa > bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb {\n     }\n \n     while aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa {\n     }\n \n-    'b: for xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx in\n-        some_iter(arg1, arg2)\n+    'b: for xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx in some_iter(arg1, arg2)\n     {\n         // do smth\n     }"}]}