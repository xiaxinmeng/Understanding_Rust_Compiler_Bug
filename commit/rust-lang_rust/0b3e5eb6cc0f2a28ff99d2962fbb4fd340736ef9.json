{"sha": "0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiM2U1ZWI2Y2MwZjJhMjhmZjk5ZDI5NjJmYmI0ZmQzNDA3MzZlZjk=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2018-09-24T15:01:46Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2018-09-30T13:27:13Z"}, "message": "Simplify implementation of align_offset slightly", "tree": {"sha": "461c2eda5f8ff3b053d41de77d95331c35957c3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/461c2eda5f8ff3b053d41de77d95331c35957c3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9", "html_url": "https://github.com/rust-lang/rust/commit/0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5c6575801028f5e089ef2e7720aa1af9d452334", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5c6575801028f5e089ef2e7720aa1af9d452334", "html_url": "https://github.com/rust-lang/rust/commit/e5c6575801028f5e089ef2e7720aa1af9d452334"}], "stats": {"total": 39, "additions": 13, "deletions": 26}, "files": [{"sha": "3e0985a96db970d293f66f44d9dc264c5b4b02d6", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9", "patch": "@@ -2336,13 +2336,13 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         ///\n         /// Note, that this table does not contain values where inverse does not exist (i.e. for\n         /// `0\u207b\u00b9 mod 16`, `2\u207b\u00b9 mod 16`, etc.)\n-        const INV_TABLE_MOD_16: [usize; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n+        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n         /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n         const INV_TABLE_MOD: usize = 16;\n         /// INV_TABLE_MOD\u00b2\n         const INV_TABLE_MOD_SQUARED: usize = INV_TABLE_MOD * INV_TABLE_MOD;\n \n-        let table_inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1];\n+        let table_inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n         if m <= INV_TABLE_MOD {\n             table_inverse & (m - 1)\n         } else {\n@@ -2395,36 +2395,23 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     let gcdpow = intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a));\n     let gcd = 1usize << gcdpow;\n \n-    if gcd == 1 {\n-        // This branch solves for the variable $o$ in following linear congruence equation:\n-        //\n-        // \u23b0 p + o \u2261 0 (mod a)   # $p + o$ must be aligned to specified alignment $a$\n-        // \u23b1     o \u2261 0 (mod s)   # offset $o$ must be a multiple of stride $s$\n-        //\n-        // where\n+    if p as usize & (gcd - 1) == 0 {\n+        // This branch solves for the following linear congruence equation:\n         //\n-        // * a, s are co-prime\n+        // $$ p + so \u2261 0 mod a $$\n         //\n-        // This gives us the formula below:\n+        // $p$ here is the pointer value, $s$ \u2013 stride of `T`, $o$ offset in `T`s, and $a$ \u2013 the\n+        // requested alignment.\n         //\n-        // o = (a - (p mod a)) * (s\u207b\u00b9 mod a) * s\n+        // g = gcd(a, s)\n+        // o = (a - (p mod a))/g * ((s/g)\u207b\u00b9 mod a)\n         //\n         // The first term is \u201cthe relative alignment of p to a\u201d, the second term is \u201chow does\n-        // incrementing p by one s change the relative alignment of p\u201d, the third term is\n-        // translating change in units of s to a byte count.\n+        // incrementing p by s bytes change the relative alignment of p\u201d. Division by `g` is\n+        // necessary to make this equation well formed if $a$ and $s$ are not co-prime.\n         //\n         // Furthermore, the result produced by this solution is not \u201cminimal\u201d, so it is necessary\n-        // to take the result $o mod lcm(s, a)$. Since $s$ and $a$ are co-prime (i.e. $gcd(s, a) =\n-        // 1$) and $lcm(s, a) = s * a / gcd(s, a)$, we can replace $lcm(s, a)$ with just a $s * a$.\n-        //\n-        // (Author note: we decided later on to express the offset in \"elements\" rather than bytes,\n-        // which drops the multiplication by `s` on both sides of the modulo.)\n-        return intrinsics::unchecked_rem(a.wrapping_sub(pmoda).wrapping_mul(mod_inv(smoda, a)), a);\n-    }\n-\n-    if p as usize & (gcd - 1) == 0 {\n-        // This can be aligned, but `a` and `stride` are not co-prime, so a somewhat adapted\n-        // formula is used.\n+        // to take the result $o mod lcm(s, a)$. We can replace $lcm(s, a)$ with just a $a / g$.\n         let j = a.wrapping_sub(pmoda) >> gcdpow;\n         let k = smoda >> gcdpow;\n         return intrinsics::unchecked_rem(j.wrapping_mul(mod_inv(k, a)), a >> gcdpow);"}, {"sha": "96280d70f7ead5ca4e7e42d473324baf31e9cece", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=0b3e5eb6cc0f2a28ff99d2962fbb4fd340736ef9", "patch": "@@ -1756,7 +1756,7 @@ impl<T> [T] {\n         fn gcd(a: usize, b: usize) -> usize {\n             // iterative stein\u2019s algorithm\n             // We should still make this `const fn` (and revert to recursive algorithm if we do)\n-            // because relying on llvm to consteval all this is\u2026 well, it makes me\n+            // because relying on llvm to consteval all this is\u2026 well, it makes me uncomfortable.\n             let (ctz_a, mut ctz_b) = unsafe {\n                 if a == 0 { return b; }\n                 if b == 0 { return a; }"}]}