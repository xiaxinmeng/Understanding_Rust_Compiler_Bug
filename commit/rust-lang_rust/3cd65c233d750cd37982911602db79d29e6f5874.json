{"sha": "3cd65c233d750cd37982911602db79d29e6f5874", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjZDY1YzIzM2Q3NTBjZDM3OTgyOTExNjAyZGI3OWQyOWU2ZjU4NzQ=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-03-13T22:30:37Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-03-20T23:05:59Z"}, "message": "change some uses of fail_unless to assert_eq", "tree": {"sha": "0e558145a765241119fa002bc7e78c8fa25f3084", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e558145a765241119fa002bc7e78c8fa25f3084"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cd65c233d750cd37982911602db79d29e6f5874", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cd65c233d750cd37982911602db79d29e6f5874", "html_url": "https://github.com/rust-lang/rust/commit/3cd65c233d750cd37982911602db79d29e6f5874", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cd65c233d750cd37982911602db79d29e6f5874/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab8e46b0660e076e629e6775ed8da9890c5fbf1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab8e46b0660e076e629e6775ed8da9890c5fbf1f", "html_url": "https://github.com/rust-lang/rust/commit/ab8e46b0660e076e629e6775ed8da9890c5fbf1f"}], "stats": {"total": 547, "additions": 251, "deletions": 296}, "files": [{"sha": "f2db9ca919d17cf61db0a4c7b05051698379a96f", "filename": "src/libcore/char.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -288,16 +288,16 @@ fn test_is_whitespace() {\n \n #[test]\n fn test_to_digit() {\n-    fail_unless!(to_digit('0', 10u) == Some(0u));\n-    fail_unless!(to_digit('1', 2u) == Some(1u));\n-    fail_unless!(to_digit('2', 3u) == Some(2u));\n-    fail_unless!(to_digit('9', 10u) == Some(9u));\n-    fail_unless!(to_digit('a', 16u) == Some(10u));\n-    fail_unless!(to_digit('A', 16u) == Some(10u));\n-    fail_unless!(to_digit('b', 16u) == Some(11u));\n-    fail_unless!(to_digit('B', 16u) == Some(11u));\n-    fail_unless!(to_digit('z', 36u) == Some(35u));\n-    fail_unless!(to_digit('Z', 36u) == Some(35u));\n+    assert_eq!(to_digit('0', 10u), Some(0u));\n+    assert_eq!(to_digit('1', 2u), Some(1u));\n+    assert_eq!(to_digit('2', 3u), Some(2u));\n+    assert_eq!(to_digit('9', 10u), Some(9u));\n+    assert_eq!(to_digit('a', 16u), Some(10u));\n+    assert_eq!(to_digit('A', 16u), Some(10u));\n+    assert_eq!(to_digit('b', 16u), Some(11u));\n+    assert_eq!(to_digit('B', 16u), Some(11u));\n+    assert_eq!(to_digit('z', 36u), Some(35u));\n+    assert_eq!(to_digit('Z', 36u), Some(35u));\n \n     fail_unless!(to_digit(' ', 10u).is_none());\n     fail_unless!(to_digit('$', 36u).is_none());\n@@ -321,28 +321,28 @@ fn test_is_digit() {\n \n #[test]\n fn test_escape_default() {\n-    fail_unless!(escape_default('\\n') == ~\"\\\\n\");\n-    fail_unless!(escape_default('\\r') == ~\"\\\\r\");\n-    fail_unless!(escape_default('\\'') == ~\"\\\\'\");\n-    fail_unless!(escape_default('\"') == ~\"\\\\\\\"\");\n-    fail_unless!(escape_default(' ') == ~\" \");\n-    fail_unless!(escape_default('a') == ~\"a\");\n-    fail_unless!(escape_default('~') == ~\"~\");\n-    fail_unless!(escape_default('\\x00') == ~\"\\\\x00\");\n-    fail_unless!(escape_default('\\x1f') == ~\"\\\\x1f\");\n-    fail_unless!(escape_default('\\x7f') == ~\"\\\\x7f\");\n-    fail_unless!(escape_default('\\xff') == ~\"\\\\xff\");\n-    fail_unless!(escape_default('\\u011b') == ~\"\\\\u011b\");\n-    fail_unless!(escape_default('\\U0001d4b6') == ~\"\\\\U0001d4b6\");\n+    assert_eq!(escape_default('\\n'), ~\"\\\\n\");\n+    assert_eq!(escape_default('\\r'), ~\"\\\\r\");\n+    assert_eq!(escape_default('\\''), ~\"\\\\'\");\n+    assert_eq!(escape_default('\"'), ~\"\\\\\\\"\");\n+    assert_eq!(escape_default(' '), ~\" \");\n+    assert_eq!(escape_default('a'), ~\"a\");\n+    assert_eq!(escape_default('~'), ~\"~\");\n+    assert_eq!(escape_default('\\x00'), ~\"\\\\x00\");\n+    assert_eq!(escape_default('\\x1f'), ~\"\\\\x1f\");\n+    assert_eq!(escape_default('\\x7f'), ~\"\\\\x7f\");\n+    assert_eq!(escape_default('\\xff'), ~\"\\\\xff\");\n+    assert_eq!(escape_default('\\u011b'), ~\"\\\\u011b\");\n+    assert_eq!(escape_default('\\U0001d4b6'), ~\"\\\\U0001d4b6\");\n }\n \n \n #[test]\n fn test_escape_unicode() {\n-    fail_unless!(escape_unicode('\\x00') == ~\"\\\\x00\");\n-    fail_unless!(escape_unicode('\\n') == ~\"\\\\x0a\");\n-    fail_unless!(escape_unicode(' ') == ~\"\\\\x20\");\n-    fail_unless!(escape_unicode('a') == ~\"\\\\x61\");\n-    fail_unless!(escape_unicode('\\u011b') == ~\"\\\\u011b\");\n-    fail_unless!(escape_unicode('\\U0001d4b6') == ~\"\\\\U0001d4b6\");\n+    assert_eq!(escape_unicode('\\x00'), ~\"\\\\x00\");\n+    assert_eq!(escape_unicode('\\n'), ~\"\\\\x0a\");\n+    assert_eq!(escape_unicode(' '), ~\"\\\\x20\");\n+    assert_eq!(escape_unicode('a'), ~\"\\\\x61\");\n+    assert_eq!(escape_unicode('\\u011b'), ~\"\\\\u011b\");\n+    assert_eq!(escape_unicode('\\U0001d4b6'), ~\"\\\\U0001d4b6\");\n }"}, {"sha": "25778f08757c3ee2435801d999885887da07624a", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -172,10 +172,10 @@ pub pure fn max<T:Ord>(v1: T, v2: T) -> T {\n mod test {\n     #[test]\n     fn test_int() {\n-        fail_unless!(5.cmp(&10) == Less);\n-        fail_unless!(10.cmp(&5) == Greater);\n-        fail_unless!(5.cmp(&5) == Equal);\n-        fail_unless!((-5).cmp(&12) == Less);\n-        fail_unless!(12.cmp(-5) == Greater);\n+        assert_eq!(5.cmp(&10), Less);\n+        assert_eq!(10.cmp(&5), Greater);\n+        assert_eq!(5.cmp(&5), Equal);\n+        assert_eq!((-5).cmp(&12), Less);\n+        assert_eq!(12.cmp(-5), Greater);\n     }\n }"}, {"sha": "5a230da877f67d2d93c87cf06779effb3914cda2", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 147, "deletions": 147, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -555,66 +555,66 @@ mod tests {\n         let ab = from_vec(~[a,b]);\n         let cd = from_vec(~[c,d]);\n         let abcd = concat(concat(from_vec(~[ab,cd])));\n-        abcd.assert_consistent(); fail_unless!(abcd.len() == 8);\n-        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 1);\n-        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 2);\n-        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 3);\n-        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 4);\n-        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 5);\n-        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 6);\n-        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 7);\n-        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 8);\n+        abcd.assert_consistent(); assert_eq!(abcd.len(), 8);\n+        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 1);\n+        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 2);\n+        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 3);\n+        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 4);\n+        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 5);\n+        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 6);\n+        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 7);\n+        abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 8);\n         abcd.assert_consistent(); fail_unless!(abcd.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append() {\n         let a = from_vec(~[1,2,3]);\n         let b = from_vec(~[4,5,6]);\n         a.append(b);\n-        fail_unless!(a.len() == 6);\n-        fail_unless!(b.len() == 0);\n+        assert_eq!(a.len(), 6);\n+        assert_eq!(b.len(), 0);\n         b.assert_consistent();\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 1);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 2);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 4);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 5);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 6);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 2);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 6);\n         a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append_empty() {\n         let a = from_vec(~[1,2,3]);\n         let b = DList::<int>();\n         a.append(b);\n-        fail_unless!(a.len() == 3);\n-        fail_unless!(b.len() == 0);\n+        assert_eq!(a.len(), 3);\n+        assert_eq!(b.len(), 0);\n         b.assert_consistent();\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 1);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 2);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 2);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n         a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append_to_empty() {\n         let a = DList::<int>();\n         let b = from_vec(~[4,5,6]);\n         a.append(b);\n-        fail_unless!(a.len() == 3);\n-        fail_unless!(b.len() == 0);\n+        assert_eq!(a.len(), 3);\n+        assert_eq!(b.len(), 0);\n         b.assert_consistent();\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 4);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 5);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 6);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 6);\n         a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append_two_empty() {\n         let a = DList::<int>();\n         let b = DList::<int>();\n         a.append(b);\n-        fail_unless!(a.len() == 0);\n-        fail_unless!(b.len() == 0);\n+        assert_eq!(a.len(), 0);\n+        assert_eq!(b.len(), 0);\n         b.assert_consistent();\n         a.assert_consistent();\n     }\n@@ -637,34 +637,34 @@ mod tests {\n         let a = from_vec(~[1,2,3]);\n         let b = from_vec(~[4,5,6]);\n         b.prepend(a);\n-        fail_unless!(a.len() == 0);\n-        fail_unless!(b.len() == 6);\n+        assert_eq!(a.len(), 0);\n+        assert_eq!(b.len(), 6);\n         a.assert_consistent();\n-        b.assert_consistent(); fail_unless!(b.pop().get() == 1);\n-        b.assert_consistent(); fail_unless!(b.pop().get() == 2);\n-        b.assert_consistent(); fail_unless!(b.pop().get() == 3);\n-        b.assert_consistent(); fail_unless!(b.pop().get() == 4);\n-        b.assert_consistent(); fail_unless!(b.pop().get() == 5);\n-        b.assert_consistent(); fail_unless!(b.pop().get() == 6);\n+        b.assert_consistent(); assert_eq!(b.pop().get(), 1);\n+        b.assert_consistent(); assert_eq!(b.pop().get(), 2);\n+        b.assert_consistent(); assert_eq!(b.pop().get(), 3);\n+        b.assert_consistent(); assert_eq!(b.pop().get(), 4);\n+        b.assert_consistent(); assert_eq!(b.pop().get(), 5);\n+        b.assert_consistent(); assert_eq!(b.pop().get(), 6);\n         b.assert_consistent(); fail_unless!(b.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_reverse() {\n         let a = from_vec(~[5,4,3,2,1]);\n         a.reverse();\n-        fail_unless!(a.len() == 5);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 1);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 2);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 4);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 5);\n+        assert_eq!(a.len(), 5);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 2);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n         a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_reverse_empty() {\n         let a = DList::<int>();\n         a.reverse();\n-        fail_unless!(a.len() == 0);\n+        assert_eq!(a.len(), 0);\n         a.assert_consistent();\n     }\n     #[test]\n@@ -675,20 +675,20 @@ mod tests {\n                 a.insert_before(3, nobe);\n             }\n         }\n-        fail_unless!(a.len() == 6);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 1);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 2);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 4);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n-        a.assert_consistent(); fail_unless!(a.pop().get() == 5);\n+        assert_eq!(a.len(), 6);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 2);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 4);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 3);\n+        a.assert_consistent(); assert_eq!(a.pop().get(), 5);\n         a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_clear() {\n         let a = from_vec(~[5,4,3,2,1]);\n         a.clear();\n-        fail_unless!(a.len() == 0);\n+        assert_eq!(a.len(), 0);\n         a.assert_consistent();\n     }\n     #[test]\n@@ -701,68 +701,68 @@ mod tests {\n     #[test]\n     pub fn test_dlist_head_tail() {\n         let l = from_vec(~[1,2,3]);\n-        fail_unless!(l.head() == 1);\n-        fail_unless!(l.tail() == 3);\n-        fail_unless!(l.len() == 3);\n+        assert_eq!(l.head(), 1);\n+        assert_eq!(l.tail(), 3);\n+        assert_eq!(l.len(), 3);\n     }\n     #[test]\n     pub fn test_dlist_pop() {\n         let l = from_vec(~[1,2,3]);\n-        fail_unless!(l.pop().get() == 1);\n-        fail_unless!(l.tail() == 3);\n-        fail_unless!(l.head() == 2);\n-        fail_unless!(l.pop().get() == 2);\n-        fail_unless!(l.tail() == 3);\n-        fail_unless!(l.head() == 3);\n-        fail_unless!(l.pop().get() == 3);\n+        assert_eq!(l.pop().get(), 1);\n+        assert_eq!(l.tail(), 3);\n+        assert_eq!(l.head(), 2);\n+        assert_eq!(l.pop().get(), 2);\n+        assert_eq!(l.tail(), 3);\n+        assert_eq!(l.head(), 3);\n+        assert_eq!(l.pop().get(), 3);\n         fail_unless!(l.is_empty());\n         fail_unless!(l.pop().is_none());\n     }\n     #[test]\n     pub fn test_dlist_pop_tail() {\n         let l = from_vec(~[1,2,3]);\n-        fail_unless!(l.pop_tail().get() == 3);\n-        fail_unless!(l.tail() == 2);\n-        fail_unless!(l.head() == 1);\n-        fail_unless!(l.pop_tail().get() == 2);\n-        fail_unless!(l.tail() == 1);\n-        fail_unless!(l.head() == 1);\n-        fail_unless!(l.pop_tail().get() == 1);\n+        assert_eq!(l.pop_tail().get(), 3);\n+        assert_eq!(l.tail(), 2);\n+        assert_eq!(l.head(), 1);\n+        assert_eq!(l.pop_tail().get(), 2);\n+        assert_eq!(l.tail(), 1);\n+        assert_eq!(l.head(), 1);\n+        assert_eq!(l.pop_tail().get(), 1);\n         fail_unless!(l.is_empty());\n         fail_unless!(l.pop_tail().is_none());\n     }\n     #[test]\n     pub fn test_dlist_push() {\n         let l = DList::<int>();\n         l.push(1);\n-        fail_unless!(l.head() == 1);\n-        fail_unless!(l.tail() == 1);\n+        assert_eq!(l.head(), 1);\n+        assert_eq!(l.tail(), 1);\n         l.push(2);\n-        fail_unless!(l.head() == 1);\n-        fail_unless!(l.tail() == 2);\n+        assert_eq!(l.head(), 1);\n+        assert_eq!(l.tail(), 2);\n         l.push(3);\n-        fail_unless!(l.head() == 1);\n-        fail_unless!(l.tail() == 3);\n-        fail_unless!(l.len() == 3);\n+        assert_eq!(l.head(), 1);\n+        assert_eq!(l.tail(), 3);\n+        assert_eq!(l.len(), 3);\n     }\n     #[test]\n     pub fn test_dlist_push_head() {\n         let l = DList::<int>();\n         l.push_head(3);\n-        fail_unless!(l.head() == 3);\n-        fail_unless!(l.tail() == 3);\n+        assert_eq!(l.head(), 3);\n+        assert_eq!(l.tail(), 3);\n         l.push_head(2);\n-        fail_unless!(l.head() == 2);\n-        fail_unless!(l.tail() == 3);\n+        assert_eq!(l.head(), 2);\n+        assert_eq!(l.tail(), 3);\n         l.push_head(1);\n-        fail_unless!(l.head() == 1);\n-        fail_unless!(l.tail() == 3);\n-        fail_unless!(l.len() == 3);\n+        assert_eq!(l.head(), 1);\n+        assert_eq!(l.tail(), 3);\n+        assert_eq!(l.len(), 3);\n     }\n     #[test]\n     pub fn test_dlist_foldl() {\n         let l = from_vec(vec::from_fn(101, |x|x));\n-        fail_unless!(iter::foldl(&l, 0, |accum,elem| *accum+*elem) == 5050);\n+        assert_eq!(iter::foldl(&l, 0, |accum,elem| *accum+*elem), 5050);\n     }\n     #[test]\n     pub fn test_dlist_break_early() {\n@@ -772,21 +772,21 @@ mod tests {\n             x += 1;\n             if (*i == 3) { break; }\n         }\n-        fail_unless!(x == 3);\n+        assert_eq!(x, 3);\n     }\n     #[test]\n     pub fn test_dlist_remove_head() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); assert_eq!(l.len(), 3);\n         l.assert_consistent(); l.remove(one);\n-        l.assert_consistent(); fail_unless!(l.len() == 2);\n-        l.assert_consistent(); fail_unless!(l.head() == 2);\n-        l.assert_consistent(); fail_unless!(l.tail() == 3);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); assert_eq!(l.len(), 2);\n+        l.assert_consistent(); assert_eq!(l.head(), 2);\n+        l.assert_consistent(); assert_eq!(l.tail(), 3);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n         l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n@@ -795,13 +795,13 @@ mod tests {\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); assert_eq!(l.len(), 3);\n         l.assert_consistent(); l.remove(two);\n-        l.assert_consistent(); fail_unless!(l.len() == 2);\n-        l.assert_consistent(); fail_unless!(l.head() == 1);\n-        l.assert_consistent(); fail_unless!(l.tail() == 3);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); assert_eq!(l.len(), 2);\n+        l.assert_consistent(); assert_eq!(l.head(), 1);\n+        l.assert_consistent(); assert_eq!(l.tail(), 3);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n         l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n@@ -810,13 +810,13 @@ mod tests {\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); assert_eq!(l.len(), 3);\n         l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); fail_unless!(l.len() == 2);\n-        l.assert_consistent(); fail_unless!(l.head() == 1);\n-        l.assert_consistent(); fail_unless!(l.tail() == 2);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); assert_eq!(l.len(), 2);\n+        l.assert_consistent(); assert_eq!(l.head(), 1);\n+        l.assert_consistent(); assert_eq!(l.tail(), 2);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n         l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n@@ -825,14 +825,14 @@ mod tests {\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); assert_eq!(l.len(), 3);\n         l.assert_consistent(); l.remove(one);\n         l.assert_consistent(); l.remove(two);\n         // and through and through, the vorpal blade went snicker-snack\n-        l.assert_consistent(); fail_unless!(l.len() == 1);\n-        l.assert_consistent(); fail_unless!(l.head() == 3);\n-        l.assert_consistent(); fail_unless!(l.tail() == 3);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); assert_eq!(l.len(), 1);\n+        l.assert_consistent(); assert_eq!(l.head(), 3);\n+        l.assert_consistent(); assert_eq!(l.tail(), 3);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n         l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n@@ -841,13 +841,13 @@ mod tests {\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); assert_eq!(l.len(), 3);\n         l.assert_consistent(); l.remove(one);\n         l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); fail_unless!(l.len() == 1);\n-        l.assert_consistent(); fail_unless!(l.head() == 2);\n-        l.assert_consistent(); fail_unless!(l.tail() == 2);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); assert_eq!(l.len(), 1);\n+        l.assert_consistent(); assert_eq!(l.head(), 2);\n+        l.assert_consistent(); assert_eq!(l.tail(), 2);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n         l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n@@ -856,13 +856,13 @@ mod tests {\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); assert_eq!(l.len(), 3);\n         l.assert_consistent(); l.remove(two);\n         l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); fail_unless!(l.len() == 1);\n-        l.assert_consistent(); fail_unless!(l.head() == 1);\n-        l.assert_consistent(); fail_unless!(l.tail() == 1);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); assert_eq!(l.len(), 1);\n+        l.assert_consistent(); assert_eq!(l.head(), 1);\n+        l.assert_consistent(); assert_eq!(l.tail(), 1);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n         l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n@@ -871,7 +871,7 @@ mod tests {\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); assert_eq!(l.len(), 3);\n         l.assert_consistent(); l.remove(two);\n         l.assert_consistent(); l.remove(three);\n         l.assert_consistent(); l.remove(one); // Twenty-three is number one!\n@@ -884,14 +884,14 @@ mod tests {\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let three = new_dlist_node(3);\n-        l.assert_consistent(); fail_unless!(l.len() == 2);\n+        l.assert_consistent(); assert_eq!(l.len(), 2);\n         l.assert_consistent(); l.insert_n_before(three, two);\n-        l.assert_consistent(); fail_unless!(l.len() == 3);\n-        l.assert_consistent(); fail_unless!(l.head() == 1);\n-        l.assert_consistent(); fail_unless!(l.tail() == 2);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); assert_eq!(l.len(), 3);\n+        l.assert_consistent(); assert_eq!(l.head(), 1);\n+        l.assert_consistent(); assert_eq!(l.tail(), 2);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n         l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n@@ -900,44 +900,44 @@ mod tests {\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let three = new_dlist_node(3);\n-        l.assert_consistent(); fail_unless!(l.len() == 2);\n+        l.assert_consistent(); assert_eq!(l.len(), 2);\n         l.assert_consistent(); l.insert_n_after(three, one);\n-        l.assert_consistent(); fail_unless!(l.len() == 3);\n-        l.assert_consistent(); fail_unless!(l.head() == 1);\n-        l.assert_consistent(); fail_unless!(l.tail() == 2);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); assert_eq!(l.len(), 3);\n+        l.assert_consistent(); assert_eq!(l.head(), 1);\n+        l.assert_consistent(); assert_eq!(l.tail(), 2);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n         l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_before_head() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); fail_unless!(l.len() == 2);\n+        l.assert_consistent(); assert_eq!(l.len(), 2);\n         l.assert_consistent(); l.insert_before(3, one);\n-        l.assert_consistent(); fail_unless!(l.len() == 3);\n-        l.assert_consistent(); fail_unless!(l.head() == 3);\n-        l.assert_consistent(); fail_unless!(l.tail() == 2);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); assert_eq!(l.len(), 3);\n+        l.assert_consistent(); assert_eq!(l.head(), 3);\n+        l.assert_consistent(); assert_eq!(l.tail(), 2);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n         l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_after_tail() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); fail_unless!(l.len() == 2);\n+        l.assert_consistent(); assert_eq!(l.len(), 2);\n         l.assert_consistent(); l.insert_after(3, two);\n-        l.assert_consistent(); fail_unless!(l.len() == 3);\n-        l.assert_consistent(); fail_unless!(l.head() == 1);\n-        l.assert_consistent(); fail_unless!(l.tail() == 3);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n-        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); assert_eq!(l.len(), 3);\n+        l.assert_consistent(); assert_eq!(l.head(), 1);\n+        l.assert_consistent(); assert_eq!(l.tail(), 3);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 1);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 2);\n+        l.assert_consistent(); assert_eq!(l.pop().get(), 3);\n         l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]"}, {"sha": "2410ef39332778646d35c79d756e08f50cb48f3f", "filename": "src/libcore/either.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -191,77 +191,77 @@ fn test_either_right() {\n fn test_lefts() {\n     let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n     let result = lefts(input);\n-    fail_unless!((result == ~[10, 12, 14]));\n+    assert_eq!(result, ~[10, 12, 14]);\n }\n \n #[test]\n fn test_lefts_none() {\n     let input: ~[Either<int, int>] = ~[Right(10), Right(10)];\n     let result = lefts(input);\n-    fail_unless!((vec::len(result) == 0u));\n+    assert_eq!(vec::len(result), 0u);\n }\n \n #[test]\n fn test_lefts_empty() {\n     let input: ~[Either<int, int>] = ~[];\n     let result = lefts(input);\n-    fail_unless!((vec::len(result) == 0u));\n+    assert_eq!(vec::len(result), 0u);\n }\n \n #[test]\n fn test_rights() {\n     let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n     let result = rights(input);\n-    fail_unless!((result == ~[11, 13]));\n+    assert_eq!(result, ~[11, 13]);\n }\n \n #[test]\n fn test_rights_none() {\n     let input: ~[Either<int, int>] = ~[Left(10), Left(10)];\n     let result = rights(input);\n-    fail_unless!((vec::len(result) == 0u));\n+    assert_eq!(vec::len(result), 0u);\n }\n \n #[test]\n fn test_rights_empty() {\n     let input: ~[Either<int, int>] = ~[];\n     let result = rights(input);\n-    fail_unless!((vec::len(result) == 0u));\n+    assert_eq!(vec::len(result), 0u);\n }\n \n #[test]\n fn test_partition() {\n     let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n     let (lefts, rights) = partition(input);\n-    fail_unless!((lefts[0] == 10));\n-    fail_unless!((lefts[1] == 12));\n-    fail_unless!((lefts[2] == 14));\n-    fail_unless!((rights[0] == 11));\n-    fail_unless!((rights[1] == 13));\n+    assert_eq!(lefts[0], 10);\n+    assert_eq!(lefts[1], 12);\n+    assert_eq!(lefts[2], 14);\n+    assert_eq!(rights[0], 11);\n+    assert_eq!(rights[1], 13);\n }\n \n #[test]\n fn test_partition_no_lefts() {\n     let input: ~[Either<int, int>] = ~[Right(10), Right(11)];\n     let (lefts, rights) = partition(input);\n-    fail_unless!((vec::len(lefts) == 0u));\n-    fail_unless!((vec::len(rights) == 2u));\n+    assert_eq!(vec::len(lefts), 0u);\n+    assert_eq!(vec::len(rights), 2u);\n }\n \n #[test]\n fn test_partition_no_rights() {\n     let input: ~[Either<int, int>] = ~[Left(10), Left(11)];\n     let (lefts, rights) = partition(input);\n-    fail_unless!((vec::len(lefts) == 2u));\n-    fail_unless!((vec::len(rights) == 0u));\n+    assert_eq!(vec::len(lefts), 2u);\n+    assert_eq!(vec::len(rights), 0u);\n }\n \n #[test]\n fn test_partition_empty() {\n     let input: ~[Either<int, int>] = ~[];\n     let (lefts, rights) = partition(input);\n-    fail_unless!((vec::len(lefts) == 0u));\n-    fail_unless!((vec::len(rights) == 0u));\n+    assert_eq!(vec::len(lefts), 0u);\n+    assert_eq!(vec::len(rights), 0u);\n }\n \n //"}, {"sha": "921a225f7ca700ad3abceb23b1d17575cf96314b", "filename": "src/libstd/json.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -1284,20 +1284,6 @@ mod tests {\n         fail_unless!(a == b);\n     }\n \n-    // two fns copied from libsyntax/util/testing.rs.\n-    // Should they be in their own crate?\n-    pub pure fn check_equal_ptr<T:cmp::Eq> (given : &T, expected: &T) {\n-        if !((given == expected) && (expected == given )) {\n-            fail!(fmt!(\"given %?, expected %?\",given,expected));\n-        }\n-    }\n-\n-    pub pure fn check_equal<T:cmp::Eq> (given : T, expected: T) {\n-        if !((given == expected) && (expected == given )) {\n-            fail!(fmt!(\"given %?, expected %?\",given,expected));\n-        }\n-    }\n-\n     #[test]\n     fn test_write_enum () {\n         let bw = @io::BytesWriter();\n@@ -1315,7 +1301,7 @@ mod tests {\n                 }\n             }\n         }\n-        check_equal(str::from_bytes(bw.bytes), ~\"[\\\"frog\\\",[\\\"Henry\\\",349]]\");\n+        assert_eq!(str::from_bytes(bw.bytes), ~\"[\\\"frog\\\",[\\\"Henry\\\",349]]\");\n     }\n \n     #[test]\n@@ -1330,7 +1316,7 @@ mod tests {\n                 }\n             }\n         }\n-        check_equal(str::from_bytes(bw.bytes), ~\"\\\"jodhpurs\\\"\");\n+        assert_eq!(str::from_bytes(bw.bytes), ~\"\\\"jodhpurs\\\"\");\n     }\n \n     #[test]\n@@ -1342,7 +1328,7 @@ mod tests {\n             do encoder.emit_enum_variant (~\"None\",37,1242) {\n             }\n         }\n-        check_equal(str::from_bytes(bw.bytes), ~\"null\");\n+        assert_eq!(str::from_bytes(bw.bytes), ~\"null\");\n     }\n \n     #[test]"}, {"sha": "b535082ad333f8265f421cd0a534b2566740e5f6", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -208,7 +208,8 @@ pub enum ExpnInfo {\n \n pub type FileName = ~str;\n \n-pub struct FileLines {\n+pub struct FileLines\n+{\n     file: @FileMap,\n     lines: ~[uint]\n }\n@@ -509,17 +510,16 @@ priv impl CodeMap {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use util::testing::check_equal;\n \n     #[test]\n     fn t1 () {\n         let cm = CodeMap::new();\n         let fm = cm.new_filemap(~\"blork.rs\",@~\"first line.\\nsecond line\");\n         fm.next_line(BytePos(0));\n-        check_equal(&fm.get_line(0),&~\"first line.\");\n+        assert_eq!(&fm.get_line(0),&~\"first line.\");\n         // TESTING BROKEN BEHAVIOR:\n         fm.next_line(BytePos(10));\n-        check_equal(&fm.get_line(1),&~\".\");\n+        assert_eq!(&fm.get_line(1),&~\".\");\n     }\n \n     #[test]"}, {"sha": "3ab95258f038e051ef16940f4d453456138cca8f", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -1202,7 +1202,6 @@ fn mk_enum_deser_body(\n mod test {\n     use std::serialize::Encodable;\n     use std::serialize::Encoder;\n-    use util::testing::*;\n \n     // just adding the ones I want to test, for now:\n     #[deriving_eq]\n@@ -1321,7 +1320,7 @@ mod test {\n     }\n \n     #[test] fn encode_enum_test () {\n-        check_equal (to_call_log(Book(34,44)),\n+        assert_eq!(to_call_log(Book(34,44)),\n                      ~[CallToEmitEnum (~\"Written\"),\n                        CallToEmitEnumVariant (~\"Book\",0,2),\n                        CallToEmitEnumVariantArg (0),"}, {"sha": "34e4d8c73e72c51a9f9d57563a0d60cdb8d0e779", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -509,31 +509,30 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n #[cfg(test)]\n mod test {\n     use super::MapChain;\n-    use util::testing::check_equal;\n     use core::hashmap::linear::LinearMap;\n \n     #[test] fn testenv () {\n         let mut a = LinearMap::new();\n         a.insert (@~\"abc\",@15);\n         let m = MapChain::new(~a);\n         m.insert (@~\"def\",@16);\n-        // FIXME: #4492 (ICE)  check_equal(m.find(&@~\"abc\"),Some(@15));\n-        //  ....               check_equal(m.find(&@~\"def\"),Some(@16));\n-        check_equal(*(m.find(&@~\"abc\").get()),15);\n-        check_equal(*(m.find(&@~\"def\").get()),16);\n+        // FIXME: #4492 (ICE)  assert_eq!(m.find(&@~\"abc\"),Some(@15));\n+        //  ....               assert_eq!(m.find(&@~\"def\"),Some(@16));\n+        assert_eq!(*(m.find(&@~\"abc\").get()),15);\n+        assert_eq!(*(m.find(&@~\"def\").get()),16);\n         let n = m.push_frame();\n         // old bindings are still present:\n-        check_equal(*(n.find(&@~\"abc\").get()),15);\n-        check_equal(*(n.find(&@~\"def\").get()),16);\n+        assert_eq!(*(n.find(&@~\"abc\").get()),15);\n+        assert_eq!(*(n.find(&@~\"def\").get()),16);\n         n.insert (@~\"def\",@17);\n         // n shows the new binding\n-        check_equal(*(n.find(&@~\"abc\").get()),15);\n-        check_equal(*(n.find(&@~\"def\").get()),17);\n+        assert_eq!(*(n.find(&@~\"abc\").get()),15);\n+        assert_eq!(*(n.find(&@~\"def\").get()),17);\n         // ... but m still has the old ones\n-        // FIXME: #4492: check_equal(m.find(&@~\"abc\"),Some(@15));\n-        // FIXME: #4492: check_equal(m.find(&@~\"def\"),Some(@16));\n-        check_equal(*(m.find(&@~\"abc\").get()),15);\n-        check_equal(*(m.find(&@~\"def\").get()),16);\n+        // FIXME: #4492: assert_eq!(m.find(&@~\"abc\"),Some(@15));\n+        // FIXME: #4492: assert_eq!(m.find(&@~\"def\"),Some(@16));\n+        assert_eq!(*(m.find(&@~\"abc\").get()),15);\n+        assert_eq!(*(m.find(&@~\"def\").get()),16);\n     }\n }\n "}, {"sha": "27b35b37849296bd7c62bbf9a65d9c770f08c5d6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -557,7 +557,6 @@ mod test {\n     use codemap;\n     use codemap::spanned;\n     use parse;\n-    use util::testing::check_equal;\n     use core::option::{None, Some};\n \n     // make sure that fail! is present\n@@ -644,9 +643,9 @@ mod test {\n         let attr2 = make_dummy_attr (@~\"bar\");\n         let escape_attr = make_dummy_attr (@~\"macro_escape\");\n         let attrs1 = ~[attr1, escape_attr, attr2];\n-        check_equal (contains_macro_escape (attrs1),true);\n+        assert_eq!(contains_macro_escape (attrs1),true);\n         let attrs2 = ~[attr1,attr2];\n-        check_equal (contains_macro_escape (attrs2),false);\n+        assert_eq!(contains_macro_escape (attrs2),false);\n     }\n \n     // make a \"meta_word\" outer attribute with the given name"}, {"sha": "e94ad0a5c17061c287a1763ad13d168973d8174d", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -779,7 +779,6 @@ pub mod test {\n     use core::option::None;\n     use diagnostic;\n     use parse::token;\n-    use util::testing::{check_equal, check_equal_ptr};\n \n     // represents a testing reader (incl. both reader and interner)\n     struct Env {\n@@ -809,17 +808,17 @@ pub mod test {\n         let tok2 = TokenAndSpan{\n             tok:token::IDENT(id, false),\n             sp:span {lo:BytePos(21),hi:BytePos(23),expn_info: None}};\n-        check_equal (tok1,tok2);\n+        assert_eq!(tok1,tok2);\n         // the 'main' id is already read:\n-        check_equal (copy string_reader.last_pos,BytePos(28));\n+        assert_eq!(copy string_reader.last_pos,BytePos(28));\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan{\n             tok:token::IDENT(ident_interner.intern (@~\"main\"), false),\n             sp:span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n-        check_equal (tok3,tok4);\n+        assert_eq!(tok3,tok4);\n         // the lparen is already read:\n-        check_equal (copy string_reader.last_pos,BytePos(29))\n+        assert_eq!(copy string_reader.last_pos,BytePos(29))\n     }\n \n     // check that the given reader produces the desired stream\n@@ -828,7 +827,7 @@ pub mod test {\n         for expected.each |expected_tok| {\n             let TokenAndSpan {tok:actual_tok, sp: _} =\n                 env.string_reader.next_token();\n-            check_equal(&actual_tok,expected_tok);\n+            assert_eq!(&actual_tok,expected_tok);\n         }\n     }\n \n@@ -872,29 +871,29 @@ pub mod test {\n         let env = setup(~\"'a'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n-        fail_unless!(tok == token::LIT_INT('a' as i64, ast::ty_char));\n+        assert_eq!(tok,token::LIT_INT('a' as i64, ast::ty_char));\n     }\n \n     #[test] fn character_space() {\n         let env = setup(~\"' '\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n-        fail_unless!(tok == token::LIT_INT(' ' as i64, ast::ty_char));\n+        assert_eq!(tok, token::LIT_INT(' ' as i64, ast::ty_char));\n     }\n \n     #[test] fn character_escaped() {\n         let env = setup(~\"'\\n'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n-        fail_unless!(tok == token::LIT_INT('\\n' as i64, ast::ty_char));\n+        assert_eq!(tok, token::LIT_INT('\\n' as i64, ast::ty_char));\n     }\n \n     #[test] fn lifetime_name() {\n         let env = setup(~\"'abc\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         let id = env.interner.intern(@~\"abc\");\n-        fail_unless!(tok == token::LIFETIME(id));\n+        assert_eq!(tok, token::LIFETIME(id));\n     }\n }\n "}, {"sha": "a0c73668a05f9dabda1a78769c51bb899b9fc7f2", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -313,7 +313,6 @@ mod test {\n     use std;\n     use core::io;\n     use core::option::None;\n-    use util::testing::*;\n \n     #[test] fn to_json_str<E : Encodable<std::json::Encoder>>(val: @E) -> ~str {\n         do io::with_str_writer |writer| {\n@@ -327,7 +326,7 @@ mod test {\n             @~\"fn foo (x : int) { x; }\",\n             ~[],\n             new_parse_sess(None));\n-        check_equal(to_json_str(@tts),\n+        assert_eq!(to_json_str(@tts),\n                     ~\"[[\\\"tt_tok\\\",[null,[\\\"IDENT\\\",[\\\"fn\\\",false]]]],\\\n                       [\\\"tt_tok\\\",[null,[\\\"IDENT\\\",[\\\"foo\\\",false]]]],\\\n                       [\\\"tt_delim\\\",[[[\\\"tt_tok\\\",[null,[\\\"LPAREN\\\",[]]]],\\\n@@ -347,7 +346,7 @@ mod test {\n             @~\"fn foo (x : int) { x; }\",\n             ~[],~[],\n             new_parse_sess(None));\n-        check_equal(ast1,ast2);\n+        assert_eq!(ast1,ast2);\n     }\n }\n "}, {"sha": "ed108df7db250bd2f0b3b5bb6d1237813726b6ad", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -117,7 +117,7 @@ pub fn tok_str(++t: token) -> ~str {\n pub fn buf_str(toks: ~[token], szs: ~[int], left: uint, right: uint,\n                lim: uint) -> ~str {\n     let n = vec::len(toks);\n-    fail_unless!((n == vec::len(szs)));\n+    fail_unless!(n == vec::len(szs));\n     let mut i = left;\n     let mut L = lim;\n     let mut s = ~\"[\";"}, {"sha": "c6d7e6fd2624463940a3acc4ffc247c231de1cc6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -2258,7 +2258,6 @@ pub mod test {\n     use core::cmp::Eq;\n     use core::option::None;\n     use parse;\n-    use util::testing::check_equal;\n \n     fn string_check<T:Eq> (given : &T, expected: &T) {\n         if !(given == expected) {\n@@ -2279,7 +2278,7 @@ pub mod test {\n             cf: ast::return_val\n         };\n         let generics = ast_util::empty_generics();\n-        check_equal (&fun_to_str(&decl, abba_ident, None, &generics, mock_interner),\n+        assert_eq!(&fun_to_str(&decl, abba_ident, None, &generics, mock_interner),\n                      &~\"fn abba()\");\n     }\n \n@@ -2299,7 +2298,7 @@ pub mod test {\n         });\n \n         let varstr = variant_to_str(var,mock_interner);\n-        check_equal(&varstr,&~\"pub principal_skinner\");\n+        assert_eq!(&varstr,&~\"pub principal_skinner\");\n     }\n }\n "}, {"sha": "19ed68093267a9bb93f78c2117bbe9e538e155b8", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -46,7 +46,6 @@ pub mod visit;\n pub mod fold;\n pub mod util {\n     pub mod interner;\n-    pub mod testing;\n }\n \n "}, {"sha": "b4a85ce1617a14f097995d249df91111716ccc38", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd65c233d750cd37982911602db79d29e6f5874/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=3cd65c233d750cd37982911602db79d29e6f5874", "patch": "@@ -77,32 +77,32 @@ pub fn i1 () {\n pub fn i2 () {\n     let i : Interner<@~str> = Interner::new();\n     // first one is zero:\n-    fail_unless!(i.intern (@~\"dog\") == 0);\n+    assert_eq!(i.intern (@~\"dog\"), 0);\n     // re-use gets the same entry:\n-    fail_unless!(i.intern (@~\"dog\") == 0);\n+    assert_eq!(i.intern (@~\"dog\"), 0);\n     // different string gets a different #:\n-    fail_unless!(i.intern (@~\"cat\") == 1);\n-    fail_unless!(i.intern (@~\"cat\") == 1);\n+    assert_eq!(i.intern (@~\"cat\"), 1);\n+    assert_eq!(i.intern (@~\"cat\"), 1);\n     // dog is still at zero\n-    fail_unless!(i.intern (@~\"dog\") == 0);\n+    assert_eq!(i.intern (@~\"dog\"), 0);\n     // gensym gets 3\n-    fail_unless!(i.gensym (@~\"zebra\" ) == 2);\n+    assert_eq!(i.gensym (@~\"zebra\" ), 2);\n     // gensym of same string gets new number :\n-    fail_unless!(i.gensym (@~\"zebra\" ) == 3);\n+    assert_eq!(i.gensym (@~\"zebra\" ), 3);\n     // gensym of *existing* string gets new number:\n-    fail_unless!(i.gensym (@~\"dog\") == 4);\n-    fail_unless!(i.get(0) == @~\"dog\");\n-    fail_unless!(i.get(1) == @~\"cat\");\n-    fail_unless!(i.get(2) == @~\"zebra\");\n-    fail_unless!(i.get(3) == @~\"zebra\");\n-    fail_unless!(i.get(4) == @~\"dog\");\n+    assert_eq!(i.gensym (@~\"dog\"), 4);\n+    assert_eq!(i.get(0), @~\"dog\");\n+    assert_eq!(i.get(1), @~\"cat\");\n+    assert_eq!(i.get(2), @~\"zebra\");\n+    assert_eq!(i.get(3), @~\"zebra\");\n+    assert_eq!(i.get(4), @~\"dog\");\n }\n \n #[test]\n pub fn i3 () {\n     let i : Interner<@~str> = Interner::prefill([@~\"Alan\",@~\"Bob\",@~\"Carol\"]);\n-    fail_unless!(i.get(0) == @~\"Alan\");\n-    fail_unless!(i.get(1) == @~\"Bob\");\n-    fail_unless!(i.get(2) == @~\"Carol\");\n-    fail_unless!(i.intern(@~\"Bob\") == 1);\n+    assert_eq!(i.get(0), @~\"Alan\");\n+    assert_eq!(i.get(1), @~\"Bob\");\n+    assert_eq!(i.get(2), @~\"Carol\");\n+    assert_eq!(i.intern(@~\"Bob\"), 1);\n }"}, {"sha": "78a175df29f276a59e015d9cb6d572ac621bbfc5", "filename": "src/libsyntax/util/testing.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ab8e46b0660e076e629e6775ed8da9890c5fbf1f/src%2Flibsyntax%2Futil%2Ftesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8e46b0660e076e629e6775ed8da9890c5fbf1f/src%2Flibsyntax%2Futil%2Ftesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Ftesting.rs?ref=ab8e46b0660e076e629e6775ed8da9890c5fbf1f", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// support for test cases.\n-use core::cmp;\n-\n-pub pure fn check_equal_ptr<T:cmp::Eq> (given : &T, expected: &T) {\n-    if !((given == expected) && (expected == given )) {\n-        fail!(fmt!(\"given %?, expected %?\",given,expected));\n-    }\n-}\n-\n-pub pure fn check_equal<T:cmp::Eq> (given : T, expected: T) {\n-    if !((given == expected) && (expected == given )) {\n-        fail!(fmt!(\"given %?, expected %?\",given,expected));\n-    }\n-}"}]}