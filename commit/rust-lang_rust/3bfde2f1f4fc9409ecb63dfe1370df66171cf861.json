{"sha": "3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "node_id": "C_kwDOAAsO6NoAKDNiZmRlMmYxZjRmYzk0MDllY2I2M2RmZTEzNzBkZjY2MTcxY2Y4NjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-21T10:19:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-21T10:19:33Z"}, "message": "Auto merge of #91104 - matthiaskrgr:rollup-duk33o1, r=matthiaskrgr\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #91008 (Adds IEEE 754-2019 minimun and maximum functions for f32/f64)\n - #91070 (Make `LLVMRustGetOrInsertGlobal` always return a `GlobalVariable`)\n - #91097 (Add spaces in opaque `impl Trait` with more than one trait)\n - #91098 (Don't suggest certain fixups (`.field`, `.await`, etc) when reporting errors while matching on arrays )\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ed9e0b4780c7980749b09d4fd1ea9b57202c709a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed9e0b4780c7980749b09d4fd1ea9b57202c709a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "html_url": "https://github.com/rust-lang/rust/commit/3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8e5ab20ed7a7677a998a163ccf7853764b195e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8e5ab20ed7a7677a998a163ccf7853764b195e6", "html_url": "https://github.com/rust-lang/rust/commit/b8e5ab20ed7a7677a998a163ccf7853764b195e6"}, {"sha": "a54eae94a019a4128265413f3799b8d93a81c2e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a54eae94a019a4128265413f3799b8d93a81c2e3", "html_url": "https://github.com/rust-lang/rust/commit/a54eae94a019a4128265413f3799b8d93a81c2e3"}], "stats": {"total": 371, "additions": 344, "deletions": 27}, "files": [{"sha": "85226e60bdbdbac5705bfb528a0dd87b37f1e91b", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -1695,11 +1695,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             _ => exp_found,\n         };\n-        debug!(\"exp_found {:?} terr {:?}\", exp_found, terr);\n+        debug!(\"exp_found {:?} terr {:?} cause.code {:?}\", exp_found, terr, cause.code);\n         if let Some(exp_found) = exp_found {\n-            self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n-            self.suggest_accessing_field_where_appropriate(cause, &exp_found, diag);\n-            self.suggest_await_on_expect_found(cause, span, &exp_found, diag);\n+            let should_suggest_fixes = if let ObligationCauseCode::Pattern { root_ty, .. } =\n+                &cause.code\n+            {\n+                // Skip if the root_ty of the pattern is not the same as the expected_ty.\n+                // If these types aren't equal then we've probably peeled off a layer of arrays.\n+                same_type_modulo_infer(self.resolve_vars_if_possible(*root_ty), exp_found.expected)\n+            } else {\n+                true\n+            };\n+\n+            if should_suggest_fixes {\n+                self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n+                self.suggest_accessing_field_where_appropriate(cause, &exp_found, diag);\n+                self.suggest_await_on_expect_found(cause, span, &exp_found, diag);\n+            }\n         }\n \n         // In some (most?) cases cause.body_id points to actual body, but in some cases\n@@ -1879,7 +1891,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 .iter()\n                 .filter(|field| field.vis.is_accessible_from(field.did, self.tcx))\n                 .map(|field| (field.ident.name, field.ty(self.tcx, expected_substs)))\n-                .find(|(_, ty)| ty::TyS::same_type(ty, exp_found.found))\n+                .find(|(_, ty)| same_type_modulo_infer(ty, exp_found.found))\n             {\n                 if let ObligationCauseCode::Pattern { span: Some(span), .. } = cause.code {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n@@ -1944,7 +1956,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                         | (_, ty::Infer(_))\n                                         | (ty::Param(_), _)\n                                         | (ty::Infer(_), _) => {}\n-                                        _ if ty::TyS::same_type(exp_ty, found_ty) => {}\n+                                        _ if same_type_modulo_infer(exp_ty, found_ty) => {}\n                                         _ => show_suggestion = false,\n                                     };\n                                 }"}, {"sha": "f3d8eb2602a37ccd31a415cf5e35d142bf9aa863", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -124,8 +124,18 @@ extern \"C\" LLVMValueRef LLVMRustGetOrInsertFunction(LLVMModuleRef M,\n \n extern \"C\" LLVMValueRef\n LLVMRustGetOrInsertGlobal(LLVMModuleRef M, const char *Name, size_t NameLen, LLVMTypeRef Ty) {\n+  Module *Mod = unwrap(M);\n   StringRef NameRef(Name, NameLen);\n-  return wrap(unwrap(M)->getOrInsertGlobal(NameRef, unwrap(Ty)));\n+\n+  // We don't use Module::getOrInsertGlobal because that returns a Constant*,\n+  // which may either be the real GlobalVariable*, or a constant bitcast of it\n+  // if our type doesn't match the original declaration. We always want the\n+  // GlobalVariable* so we can access linkage, visibility, etc.\n+  GlobalVariable *GV = Mod->getGlobalVariable(NameRef, true);\n+  if (!GV)\n+    GV = new GlobalVariable(*Mod, unwrap(Ty), false,\n+                            GlobalValue::ExternalLinkage, nullptr, NameRef);\n+  return wrap(GV);\n }\n \n extern \"C\" LLVMValueRef"}, {"sha": "3846cf19d915b339eaa7fb729950fccbb432f62f", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -688,7 +688,7 @@ pub trait PrettyPrinter<'tcx>:\n                                 }\n \n                                 p!(\n-                                    write(\"{}\", if first { \" \" } else { \"+\" }),\n+                                    write(\"{}\", if first { \" \" } else { \" + \" }),\n                                     print(trait_ref.print_only_trait_path())\n                                 );\n \n@@ -699,7 +699,7 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n \n                     if is_future {\n-                        p!(write(\"{}Future\", if first { \" \" } else { \"+\" }));\n+                        p!(write(\"{}Future\", if first { \" \" } else { \" + \" }));\n                         first = false;\n \n                         if let Some(future_output_ty) = future_output_ty {\n@@ -712,7 +712,7 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n \n                     if !is_sized {\n-                        p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n+                        p!(write(\"{}?Sized\", if first { \" \" } else { \" + \" }));\n                     } else if first {\n                         p!(\" Sized\");\n                     }"}, {"sha": "c4a232ef36c615c5010557afefa93358552a8adf", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -673,6 +673,9 @@ impl f32 {\n \n     /// Returns the maximum of the two numbers.\n     ///\n+    /// Follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs.\n+    /// This matches the behavior of libm\u2019s fmin.\n+    ///\n     /// ```\n     /// let x = 1.0f32;\n     /// let y = 2.0f32;\n@@ -689,6 +692,9 @@ impl f32 {\n \n     /// Returns the minimum of the two numbers.\n     ///\n+    /// Follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs.\n+    /// This matches the behavior of libm\u2019s fmin.\n+    ///\n     /// ```\n     /// let x = 1.0f32;\n     /// let y = 2.0f32;\n@@ -703,6 +709,68 @@ impl f32 {\n         intrinsics::minnumf32(self, other)\n     }\n \n+    /// Returns the maximum of the two numbers, propagating NaNs.\n+    ///\n+    /// This returns NaN when *either* argument is NaN, as opposed to\n+    /// [`f32::max`] which only returns NaN when *both* arguments are NaN.\n+    ///\n+    /// ```\n+    /// #![feature(float_minimum_maximum)]\n+    /// let x = 1.0f32;\n+    /// let y = 2.0f32;\n+    ///\n+    /// assert_eq!(x.maximum(y), y);\n+    /// assert!(x.maximum(f32::NAN).is_nan());\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater\n+    /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n+    /// Note that this follows the semantics specified in IEEE 754-2019.\n+    #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n+    #[inline]\n+    pub fn maximum(self, other: f32) -> f32 {\n+        if self > other {\n+            self\n+        } else if other > self {\n+            other\n+        } else if self == other {\n+            if self.is_sign_positive() && other.is_sign_negative() { self } else { other }\n+        } else {\n+            self + other\n+        }\n+    }\n+\n+    /// Returns the minimum of the two numbers, propagating NaNs.\n+    ///\n+    /// This returns NaN when *either* argument is NaN, as opposed to\n+    /// [`f32::min`] which only returns NaN when *both* arguments are NaN.\n+    ///\n+    /// ```\n+    /// #![feature(float_minimum_maximum)]\n+    /// let x = 1.0f32;\n+    /// let y = 2.0f32;\n+    ///\n+    /// assert_eq!(x.minimum(y), x);\n+    /// assert!(x.minimum(f32::NAN).is_nan());\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser\n+    /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n+    /// Note that this follows the semantics specified in IEEE 754-2019.\n+    #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n+    #[inline]\n+    pub fn minimum(self, other: f32) -> f32 {\n+        if self < other {\n+            self\n+        } else if other < self {\n+            other\n+        } else if self == other {\n+            if self.is_sign_negative() && other.is_sign_positive() { self } else { other }\n+        } else {\n+            self + other\n+        }\n+    }\n+\n     /// Rounds toward zero and converts to any primitive integer type,\n     /// assuming that the value is finite and fits in that type.\n     ///"}, {"sha": "85ee6aa2cb8c3399f6bd2787ad9696d72fbe5b82", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -689,6 +689,9 @@ impl f64 {\n \n     /// Returns the maximum of the two numbers.\n     ///\n+    /// Follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs.\n+    /// This matches the behavior of libm\u2019s fmin.\n+    ///\n     /// ```\n     /// let x = 1.0_f64;\n     /// let y = 2.0_f64;\n@@ -705,6 +708,9 @@ impl f64 {\n \n     /// Returns the minimum of the two numbers.\n     ///\n+    /// Follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs.\n+    /// This matches the behavior of libm\u2019s fmin.\n+    ///\n     /// ```\n     /// let x = 1.0_f64;\n     /// let y = 2.0_f64;\n@@ -719,6 +725,68 @@ impl f64 {\n         intrinsics::minnumf64(self, other)\n     }\n \n+    /// Returns the maximum of the two numbers, propagating NaNs.\n+    ///\n+    /// This returns NaN when *either* argument is NaN, as opposed to\n+    /// [`f64::max`] which only returns NaN when *both* arguments are NaN.\n+    ///\n+    /// ```\n+    /// #![feature(float_minimum_maximum)]\n+    /// let x = 1.0_f64;\n+    /// let y = 2.0_f64;\n+    ///\n+    /// assert_eq!(x.maximum(y), y);\n+    /// assert!(x.maximum(f64::NAN).is_nan());\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater\n+    /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n+    /// Note that this follows the semantics specified in IEEE 754-2019.\n+    #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n+    #[inline]\n+    pub fn maximum(self, other: f64) -> f64 {\n+        if self > other {\n+            self\n+        } else if other > self {\n+            other\n+        } else if self == other {\n+            if self.is_sign_positive() && other.is_sign_negative() { self } else { other }\n+        } else {\n+            self + other\n+        }\n+    }\n+\n+    /// Returns the minimum of the two numbers, propagating NaNs.\n+    ///\n+    /// This returns NaN when *either* argument is NaN, as opposed to\n+    /// [`f64::min`] which only returns NaN when *both* arguments are NaN.\n+    ///\n+    /// ```\n+    /// #![feature(float_minimum_maximum)]\n+    /// let x = 1.0_f64;\n+    /// let y = 2.0_f64;\n+    ///\n+    /// assert_eq!(x.minimum(y), x);\n+    /// assert!(x.minimum(f64::NAN).is_nan());\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser\n+    /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n+    /// Note that this follows the semantics specified in IEEE 754-2019.\n+    #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n+    #[inline]\n+    pub fn minimum(self, other: f64) -> f64 {\n+        if self < other {\n+            self\n+        } else if other < self {\n+            other\n+        } else if self == other {\n+            if self.is_sign_negative() && other.is_sign_positive() { self } else { other }\n+        } else {\n+            self + other\n+        }\n+    }\n+\n     /// Rounds toward zero and converts to any primitive integer type,\n     /// assuming that the value is finite and fits in that type.\n     ///"}, {"sha": "a56a1dbd17ae01df0cb35ed8e597c23f407be92e", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -27,6 +27,7 @@\n #![feature(extern_types)]\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n+#![feature(float_minimum_maximum)]\n #![feature(array_from_fn)]\n #![feature(hashmap_internals)]\n #![feature(try_find)]"}, {"sha": "4f773a824efd29a4aaa36d33a068675ca9324d61", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -715,6 +715,67 @@ macro_rules! test_float {\n                 assert!(($nan as $fty).max($nan).is_nan());\n             }\n             #[test]\n+            fn minimum() {\n+                assert_eq!((0.0 as $fty).minimum(0.0), 0.0);\n+                assert!((0.0 as $fty).minimum(0.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).minimum(0.0), -0.0);\n+                assert!((-0.0 as $fty).minimum(0.0).is_sign_negative());\n+                assert_eq!((-0.0 as $fty).minimum(-0.0), -0.0);\n+                assert!((-0.0 as $fty).minimum(-0.0).is_sign_negative());\n+                assert_eq!((9.0 as $fty).minimum(9.0), 9.0);\n+                assert_eq!((-9.0 as $fty).minimum(0.0), -9.0);\n+                assert_eq!((0.0 as $fty).minimum(9.0), 0.0);\n+                assert!((0.0 as $fty).minimum(9.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).minimum(9.0), -0.0);\n+                assert!((-0.0 as $fty).minimum(9.0).is_sign_negative());\n+                assert_eq!((-0.0 as $fty).minimum(-9.0), -9.0);\n+                assert_eq!(($inf as $fty).minimum(9.0), 9.0);\n+                assert_eq!((9.0 as $fty).minimum($inf), 9.0);\n+                assert_eq!(($inf as $fty).minimum(-9.0), -9.0);\n+                assert_eq!((-9.0 as $fty).minimum($inf), -9.0);\n+                assert_eq!(($neginf as $fty).minimum(9.0), $neginf);\n+                assert_eq!((9.0 as $fty).minimum($neginf), $neginf);\n+                assert_eq!(($neginf as $fty).minimum(-9.0), $neginf);\n+                assert_eq!((-9.0 as $fty).minimum($neginf), $neginf);\n+                assert!(($nan as $fty).minimum(9.0).is_nan());\n+                assert!(($nan as $fty).minimum(-9.0).is_nan());\n+                assert!((9.0 as $fty).minimum($nan).is_nan());\n+                assert!((-9.0 as $fty).minimum($nan).is_nan());\n+                assert!(($nan as $fty).minimum($nan).is_nan());\n+            }\n+            #[test]\n+            fn maximum() {\n+                assert_eq!((0.0 as $fty).maximum(0.0), 0.0);\n+                assert!((0.0 as $fty).maximum(0.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).maximum(0.0), 0.0);\n+                assert!((-0.0 as $fty).maximum(0.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).maximum(-0.0), -0.0);\n+                assert!((-0.0 as $fty).maximum(-0.0).is_sign_negative());\n+                assert_eq!((9.0 as $fty).maximum(9.0), 9.0);\n+                assert_eq!((-9.0 as $fty).maximum(0.0), 0.0);\n+                assert!((-9.0 as $fty).maximum(0.0).is_sign_positive());\n+                assert_eq!((-9.0 as $fty).maximum(-0.0), -0.0);\n+                assert!((-9.0 as $fty).maximum(-0.0).is_sign_negative());\n+                assert_eq!((0.0 as $fty).maximum(9.0), 9.0);\n+                assert_eq!((0.0 as $fty).maximum(-9.0), 0.0);\n+                assert!((0.0 as $fty).maximum(-9.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).maximum(-9.0), -0.0);\n+                assert!((-0.0 as $fty).maximum(-9.0).is_sign_negative());\n+                assert_eq!(($inf as $fty).maximum(9.0), $inf);\n+                assert_eq!((9.0 as $fty).maximum($inf), $inf);\n+                assert_eq!(($inf as $fty).maximum(-9.0), $inf);\n+                assert_eq!((-9.0 as $fty).maximum($inf), $inf);\n+                assert_eq!(($neginf as $fty).maximum(9.0), 9.0);\n+                assert_eq!((9.0 as $fty).maximum($neginf), 9.0);\n+                assert_eq!(($neginf as $fty).maximum(-9.0), -9.0);\n+                assert_eq!((-9.0 as $fty).maximum($neginf), -9.0);\n+                assert!(($nan as $fty).maximum(9.0).is_nan());\n+                assert!(($nan as $fty).maximum(-9.0).is_nan());\n+                assert!((9.0 as $fty).maximum($nan).is_nan());\n+                assert!((-9.0 as $fty).maximum($nan).is_nan());\n+                assert!(($nan as $fty).maximum($nan).is_nan());\n+            }\n+            #[test]\n             fn rem_euclid() {\n                 let a: $fty = 42.0;\n                 assert!($inf.rem_euclid(a).is_nan());"}, {"sha": "69fa203ff4e70bb03c9f0a15615348345670a625", "filename": "library/std/src/f32/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -19,6 +19,18 @@ fn test_max_nan() {\n     assert_eq!(2.0f32.max(f32::NAN), 2.0);\n }\n \n+#[test]\n+fn test_minimum() {\n+    assert!(f32::NAN.minimum(2.0).is_nan());\n+    assert!(2.0f32.minimum(f32::NAN).is_nan());\n+}\n+\n+#[test]\n+fn test_maximum() {\n+    assert!(f32::NAN.maximum(2.0).is_nan());\n+    assert!(2.0f32.maximum(f32::NAN).is_nan());\n+}\n+\n #[test]\n fn test_nan() {\n     let nan: f32 = f32::NAN;"}, {"sha": "afd8d8edaa169f8b41d1bed27fdb56f7a4eb6ad8", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -287,6 +287,7 @@\n #![feature(exhaustive_patterns)]\n #![feature(extend_one)]\n #![feature(fn_traits)]\n+#![feature(float_minimum_maximum)]\n #![feature(format_args_nl)]\n #![feature(gen_future)]\n #![feature(generator_trait)]"}, {"sha": "384561f8ccd7e0496ef3c867ff4e015f8955a958", "filename": "src/test/ui/associated-types/issue-87261.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -83,17 +83,17 @@ fn main() {\n     //~^ ERROR type mismatch resolving `<impl DerivedTrait as Trait>::Associated == ()`\n \n     accepts_trait(returns_opaque_foo());\n-    //~^ ERROR type mismatch resolving `<impl Trait+Foo as Trait>::Associated == ()`\n+    //~^ ERROR type mismatch resolving `<impl Trait + Foo as Trait>::Associated == ()`\n \n     accepts_trait(returns_opaque_derived_foo());\n-    //~^ ERROR type mismatch resolving `<impl DerivedTrait+Foo as Trait>::Associated == ()`\n+    //~^ ERROR type mismatch resolving `<impl DerivedTrait + Foo as Trait>::Associated == ()`\n \n     accepts_generic_trait(returns_opaque_generic());\n     //~^ ERROR type mismatch resolving `<impl GenericTrait<()> as GenericTrait<()>>::Associated == ()`\n \n     accepts_generic_trait(returns_opaque_generic_foo());\n-    //~^ ERROR type mismatch resolving `<impl GenericTrait<()>+Foo as GenericTrait<()>>::Associated == ()`\n+    //~^ ERROR type mismatch resolving `<impl GenericTrait<()> + Foo as GenericTrait<()>>::Associated == ()`\n \n     accepts_generic_trait(returns_opaque_generic_duplicate());\n-    //~^ ERROR type mismatch resolving `<impl GenericTrait<()>+GenericTrait<u8> as GenericTrait<()>>::Associated == ()`\n+    //~^ ERROR type mismatch resolving `<impl GenericTrait<()> + GenericTrait<u8> as GenericTrait<()>>::Associated == ()`\n }"}, {"sha": "8db4a49da3c96e4f7790d038e62ac3ad0062a3d4", "filename": "src/test/ui/associated-types/issue-87261.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -160,7 +160,7 @@ help: consider constraining the associated type `<impl DerivedTrait as Trait>::A\n LL | fn returns_opaque_derived() -> impl DerivedTrait<Associated = ()> + 'static {\n    |                                                 +++++++++++++++++\n \n-error[E0271]: type mismatch resolving `<impl Trait+Foo as Trait>::Associated == ()`\n+error[E0271]: type mismatch resolving `<impl Trait + Foo as Trait>::Associated == ()`\n   --> $DIR/issue-87261.rs:85:5\n    |\n LL | fn returns_opaque_foo() -> impl Trait + Foo {\n@@ -170,18 +170,18 @@ LL |     accepts_trait(returns_opaque_foo());\n    |     ^^^^^^^^^^^^^ expected `()`, found associated type\n    |\n    = note:    expected unit type `()`\n-           found associated type `<impl Trait+Foo as Trait>::Associated`\n+           found associated type `<impl Trait + Foo as Trait>::Associated`\n note: required by a bound in `accepts_trait`\n   --> $DIR/issue-87261.rs:43:27\n    |\n LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n    |                           ^^^^^^^^^^^^^^^ required by this bound in `accepts_trait`\n-help: consider constraining the associated type `<impl Trait+Foo as Trait>::Associated` to `()`\n+help: consider constraining the associated type `<impl Trait + Foo as Trait>::Associated` to `()`\n    |\n LL | fn returns_opaque_foo() -> impl Trait<Associated = ()> + Foo {\n    |                                      +++++++++++++++++\n \n-error[E0271]: type mismatch resolving `<impl DerivedTrait+Foo as Trait>::Associated == ()`\n+error[E0271]: type mismatch resolving `<impl DerivedTrait + Foo as Trait>::Associated == ()`\n   --> $DIR/issue-87261.rs:88:5\n    |\n LL | fn returns_opaque_derived_foo() -> impl DerivedTrait + Foo {\n@@ -191,8 +191,8 @@ LL |     accepts_trait(returns_opaque_derived_foo());\n    |     ^^^^^^^^^^^^^ expected `()`, found associated type\n    |\n    = note:    expected unit type `()`\n-           found associated type `<impl DerivedTrait+Foo as Trait>::Associated`\n-   = help: consider constraining the associated type `<impl DerivedTrait+Foo as Trait>::Associated` to `()`\n+           found associated type `<impl DerivedTrait + Foo as Trait>::Associated`\n+   = help: consider constraining the associated type `<impl DerivedTrait + Foo as Trait>::Associated` to `()`\n    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n note: required by a bound in `accepts_trait`\n   --> $DIR/issue-87261.rs:43:27\n@@ -221,7 +221,7 @@ help: consider constraining the associated type `<impl GenericTrait<()> as Gener\n LL | fn returns_opaque_generic() -> impl GenericTrait<(), Associated = ()> + 'static {\n    |                                                    +++++++++++++++++\n \n-error[E0271]: type mismatch resolving `<impl GenericTrait<()>+Foo as GenericTrait<()>>::Associated == ()`\n+error[E0271]: type mismatch resolving `<impl GenericTrait<()> + Foo as GenericTrait<()>>::Associated == ()`\n   --> $DIR/issue-87261.rs:94:5\n    |\n LL | fn returns_opaque_generic_foo() -> impl GenericTrait<()> + Foo {\n@@ -231,18 +231,18 @@ LL |     accepts_generic_trait(returns_opaque_generic_foo());\n    |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n    |\n    = note:    expected unit type `()`\n-           found associated type `<impl GenericTrait<()>+Foo as GenericTrait<()>>::Associated`\n+           found associated type `<impl GenericTrait<()> + Foo as GenericTrait<()>>::Associated`\n note: required by a bound in `accepts_generic_trait`\n   --> $DIR/issue-87261.rs:44:46\n    |\n LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n    |                                              ^^^^^^^^^^^^^^^ required by this bound in `accepts_generic_trait`\n-help: consider constraining the associated type `<impl GenericTrait<()>+Foo as GenericTrait<()>>::Associated` to `()`\n+help: consider constraining the associated type `<impl GenericTrait<()> + Foo as GenericTrait<()>>::Associated` to `()`\n    |\n LL | fn returns_opaque_generic_foo() -> impl GenericTrait<(), Associated = ()> + Foo {\n    |                                                        +++++++++++++++++\n \n-error[E0271]: type mismatch resolving `<impl GenericTrait<()>+GenericTrait<u8> as GenericTrait<()>>::Associated == ()`\n+error[E0271]: type mismatch resolving `<impl GenericTrait<()> + GenericTrait<u8> as GenericTrait<()>>::Associated == ()`\n   --> $DIR/issue-87261.rs:97:5\n    |\n LL | fn returns_opaque_generic_duplicate() -> impl GenericTrait<()> + GenericTrait<u8> {\n@@ -252,8 +252,8 @@ LL |     accepts_generic_trait(returns_opaque_generic_duplicate());\n    |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n    |\n    = note:    expected unit type `()`\n-           found associated type `<impl GenericTrait<()>+GenericTrait<u8> as GenericTrait<()>>::Associated`\n-   = help: consider constraining the associated type `<impl GenericTrait<()>+GenericTrait<u8> as GenericTrait<()>>::Associated` to `()`\n+           found associated type `<impl GenericTrait<()> + GenericTrait<u8> as GenericTrait<()>>::Associated`\n+   = help: consider constraining the associated type `<impl GenericTrait<()> + GenericTrait<u8> as GenericTrait<()>>::Associated` to `()`\n    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n note: required by a bound in `accepts_generic_trait`\n   --> $DIR/issue-87261.rs:44:46"}, {"sha": "f9abfb5225f91c3f5b1fd693f14c6cb245887fed", "filename": "src/test/ui/cast/casts-differing-anon.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.stderr?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -1,4 +1,4 @@\n-error[E0606]: casting `*mut impl Debug+?Sized` as `*mut impl Debug+?Sized` is invalid\n+error[E0606]: casting `*mut impl Debug + ?Sized` as `*mut impl Debug + ?Sized` is invalid\n   --> $DIR/casts-differing-anon.rs:21:13\n    |\n LL |     b_raw = f_raw as *mut _;"}, {"sha": "d1bc279c7589a6c5eb5bd2b126fb33ef84a0ef8c", "filename": "src/test/ui/issues/issue-5358-1.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -8,6 +8,10 @@ LL |         Either::Right(_) => {}\n    |\n    = note: expected struct `S`\n                 found enum `Either<_, _>`\n+help: you might have meant to use field `0` whose type is `Either<usize, usize>`\n+   |\n+LL |     match S(Either::Left(5)).0 {\n+   |           ~~~~~~~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "4845937d5440177962982d4131d3ef4e89a752c1", "filename": "src/test/ui/match/issue-91058.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fmatch%2Fissue-91058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fmatch%2Fissue-91058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fissue-91058.rs?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -0,0 +1,11 @@\n+struct S(());\n+\n+fn main() {\n+    let array = [S(())];\n+\n+    match array {\n+        [()] => {}\n+        //~^ ERROR mismatched types [E0308]\n+        _ => {}\n+    }\n+}"}, {"sha": "ec1d7e21fa53caa66ac159618bcb8a93ef214d96", "filename": "src/test/ui/match/issue-91058.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fmatch%2Fissue-91058.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fmatch%2Fissue-91058.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fissue-91058.stderr?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-91058.rs:7:10\n+   |\n+LL |     match array {\n+   |           ----- this expression has type `[S; 1]`\n+LL |         [()] => {}\n+   |          ^^ expected struct `S`, found `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "403a41462ef18d48ffeba6c723bc541993fb4102", "filename": "src/test/ui/statics/issue-91050-1.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fstatics%2Fissue-91050-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fstatics%2Fissue-91050-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Fissue-91050-1.rs?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -0,0 +1,34 @@\n+// build-pass\n+// compile-flags: --crate-type=rlib --emit=llvm-ir -Cno-prepopulate-passes\n+\n+// This test declares globals by the same name with different types, which\n+// caused problems because Module::getOrInsertGlobal would return a Constant*\n+// bitcast instead of a GlobalVariable* that could access linkage/visibility.\n+// In alt builds with LLVM assertions this would fail:\n+//\n+// rustc: /checkout/src/llvm-project/llvm/include/llvm/Support/Casting.h:269:\n+// typename cast_retty<X, Y *>::ret_type llvm::cast(Y *) [X = llvm::GlobalValue, Y = llvm::Value]:\n+// Assertion `isa<X>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.\n+//\n+// In regular builds, the bad cast was UB, like \"Invalid LLVMRustVisibility value!\"\n+\n+pub mod before {\n+    #[no_mangle]\n+    pub static GLOBAL1: [u8; 1] = [1];\n+}\n+\n+pub mod inner {\n+    extern \"C\" {\n+        pub static GLOBAL1: u8;\n+        pub static GLOBAL2: u8;\n+    }\n+\n+    pub fn call() {\n+        drop(unsafe { (GLOBAL1, GLOBAL2) });\n+    }\n+}\n+\n+pub mod after {\n+    #[no_mangle]\n+    pub static GLOBAL2: [u8; 1] = [2];\n+}"}, {"sha": "2ff954d15cabe09e0beefc9e471a84a3baff1c7e", "filename": "src/test/ui/statics/issue-91050-2.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fstatics%2Fissue-91050-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bfde2f1f4fc9409ecb63dfe1370df66171cf861/src%2Ftest%2Fui%2Fstatics%2Fissue-91050-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Fissue-91050-2.rs?ref=3bfde2f1f4fc9409ecb63dfe1370df66171cf861", "patch": "@@ -0,0 +1,24 @@\n+// build-pass\n+// compile-flags: --crate-type=rlib --emit=llvm-ir -Cno-prepopulate-passes\n+\n+// This is a variant of issue-91050-1.rs -- see there for an explanation.\n+\n+pub mod before {\n+    extern \"C\" {\n+        pub static GLOBAL1: [u8; 1];\n+    }\n+\n+    pub unsafe fn do_something_with_array() -> u8 {\n+        GLOBAL1[0]\n+    }\n+}\n+\n+pub mod inner {\n+    extern \"C\" {\n+        pub static GLOBAL1: u8;\n+    }\n+\n+    pub unsafe fn call() -> u8 {\n+        GLOBAL1 + 42\n+    }\n+}"}]}