{"sha": "9b9cf9892b74dc376fe740ea56858042e9bd89de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliOWNmOTg5MmI3NGRjMzc2ZmU3NDBlYTU2ODU4MDQyZTliZDg5ZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-04T19:32:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-04T19:32:23Z"}, "message": "auto merge of #10701 : huonw/rust/rm-from_utf8, r=brson\n\nThis function had type &[u8] -> ~str, i.e. it allocates a string\r\ninternally, even though the non-allocating version that take &[u8] ->\r\n&str and ~[u8] -> ~str are all that is necessary in most circumstances.", "tree": {"sha": "0453cef98715b1efed5b3baed3d0481eb474f09c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0453cef98715b1efed5b3baed3d0481eb474f09c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b9cf9892b74dc376fe740ea56858042e9bd89de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9cf9892b74dc376fe740ea56858042e9bd89de", "html_url": "https://github.com/rust-lang/rust/commit/9b9cf9892b74dc376fe740ea56858042e9bd89de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b9cf9892b74dc376fe740ea56858042e9bd89de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fa6bd526ef66ce9ce80e975340aa98bcc3596b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fa6bd526ef66ce9ce80e975340aa98bcc3596b7", "html_url": "https://github.com/rust-lang/rust/commit/5fa6bd526ef66ce9ce80e975340aa98bcc3596b7"}, {"sha": "b0426edc0a83699de79ceffcbe603812b9b53374", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0426edc0a83699de79ceffcbe603812b9b53374", "html_url": "https://github.com/rust-lang/rust/commit/b0426edc0a83699de79ceffcbe603812b9b53374"}], "stats": {"total": 348, "additions": 122, "deletions": 226}, "files": [{"sha": "4f05247ada4b832a8ad9e649cc08bf35e8520ae5", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -60,12 +60,12 @@ pub fn run(lib_path: &str,\n     for input in input.iter() {\n         process.input().write(input.as_bytes());\n     }\n-    let output = process.finish_with_output();\n+    let run::ProcessOutput { status, output, error } = process.finish_with_output();\n \n     Result {\n-        status: output.status,\n-        out: str::from_utf8(output.output),\n-        err: str::from_utf8(output.error)\n+        status: status,\n+        out: str::from_utf8_owned(output),\n+        err: str::from_utf8_owned(error)\n     }\n }\n \n@@ -90,4 +90,3 @@ pub fn run_background(lib_path: &str,\n \n     return process;\n }\n-"}, {"sha": "726fbcb5d7a67eca2504cfa60a2c9ae37417cacd", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -298,7 +298,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n \n                 let adb_arg = format!(\"export LD_LIBRARY_PATH={}; gdbserver :5039 {}/{}\",\n                          config.adb_test_dir.clone(), config.adb_test_dir.clone(),\n-                         str::from_utf8(exe_file.filename().unwrap())).clone();\n+                         str::from_utf8(exe_file.filename().unwrap()));\n \n                 let mut process = procsrv::run_background(\"\", config.adb_path.clone(),\n                         [~\"shell\",adb_arg.clone()],~[(~\"\",~\"\")], Some(~\"\"));\n@@ -1151,4 +1151,3 @@ fn run_codegen_test(config: &config, props: &TestProps,\n                      (base_lines as f64) / (clang_lines as f64),\n                      0.001);\n }\n-"}, {"sha": "c4247799cad1dbb23e8b632cb6823618d1577e76", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -162,7 +162,7 @@ impl<'self> FromBase64 for &'self str {\n      * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes.\n      *\n-     * You can use the `from_utf8` function in `std::str`\n+     * You can use the `from_utf8_owned` function in `std::str`\n      * to turn a `[u8]` into a string with characters corresponding to those\n      * values.\n      *\n@@ -180,7 +180,7 @@ impl<'self> FromBase64 for &'self str {\n      *     println!(\"base64 output: {}\", hello_str);\n      *     let res = hello_str.from_base64();\n      *     if res.is_ok() {\n-     *       let optBytes = str::from_utf8_opt(res.unwrap());\n+     *       let optBytes = str::from_utf8_owned_opt(res.unwrap());\n      *       if optBytes.is_some() {\n      *         println!(\"decoded from base64: {}\", optBytes.unwrap());\n      *       }"}, {"sha": "aadb93f2e24e1db124d071bfe43a02ba464e0ed6", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -41,7 +41,7 @@ impl Doc {\n     }\n \n     pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-        str::from_utf8_slice(self.data.slice(self.start, self.end))\n+        str::from_utf8(self.data.slice(self.start, self.end))\n     }\n \n     pub fn as_str(&self) -> ~str {"}, {"sha": "7daba4c08f23ed06c024fc6c60d55c2878b4d3bb", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -62,7 +62,7 @@ impl<'self> FromHex for &'self str {\n      * Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes.\n      *\n-     * You can use the `from_utf8` function in `std::str`\n+     * You can use the `from_utf8_owned` function in `std::str`\n      * to turn a `[u8]` into a string with characters corresponding to those\n      * values.\n      *\n@@ -80,7 +80,7 @@ impl<'self> FromHex for &'self str {\n      *     println!(\"{}\", hello_str);\n      *     let bytes = hello_str.from_hex().unwrap();\n      *     println!(\"{:?}\", bytes);\n-     *     let result_str = str::from_utf8(bytes);\n+     *     let result_str = str::from_utf8_owned(bytes);\n      *     println!(\"{}\", result_str);\n      * }\n      * ```"}, {"sha": "bc997c5147dbd844df6343468299a147c9ae2a41", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -215,7 +215,9 @@ pub fn parse(file: &mut io::Reader,\n         return Err(~\"incompatible file: more string offsets than expected\");\n     }\n \n-    let names_str = str::from_utf8(file.read_bytes(names_bytes as uint - 1)); // don't read NUL\n+    // don't read NUL\n+    let names_str = str::from_utf8_owned(file.read_bytes(names_bytes as uint - 1));\n+\n     let term_names: ~[~str] = names_str.split('|').map(|s| s.to_owned()).collect();\n \n     file.read_byte(); // consume NUL"}, {"sha": "0fbac7771dc2aed87aa26aed0d4b320eddc9a8e3", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -310,7 +310,7 @@ impl Uuid {\n             s[i*2+0] = digit[0];\n             s[i*2+1] = digit[1];\n         }\n-        str::from_utf8(s)\n+        str::from_utf8_owned(s)\n     }\n \n     /// Returns a string of hexadecimal digits, separated into groups with a hypen"}, {"sha": "d906896ff60b5ca50441f962bbb41db31298bcf7", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -260,7 +260,7 @@ fn json_encode<'self, T:Encodable<json::Encoder<'self>>>(t: &T) -> ~str {\n     let mut writer = MemWriter::new();\n     let mut encoder = json::Encoder::init(&mut writer as &mut io::Writer);\n     t.encode(&mut encoder);\n-    str::from_utf8(writer.inner_ref().as_slice())\n+    str::from_utf8_owned(writer.inner())\n }\n \n // FIXME(#5121)"}, {"sha": "1c4b15f42e986180469ee7e68d8f2a34e5ed4cbe", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -368,7 +368,7 @@ pub mod write {\n         if !prog.status.success() {\n             sess.err(format!(\"linking with `{}` failed: {}\", cc, prog.status));\n             sess.note(format!(\"{} arguments: '{}'\", cc, args.connect(\"' '\")));\n-            sess.note(str::from_utf8(prog.error + prog.output));\n+            sess.note(str::from_utf8_owned(prog.error + prog.output));\n             sess.abort_if_errors();\n         }\n     }\n@@ -1079,7 +1079,7 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n     if !prog.status.success() {\n         sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n         sess.note(format!(\"{} arguments: '{}'\", cc_prog, cc_args.connect(\"' '\")));\n-        sess.note(str::from_utf8(prog.error + prog.output));\n+        sess.note(str::from_utf8_owned(prog.error + prog.output));\n         sess.abort_if_errors();\n     }\n "}, {"sha": "24cac4d9aeef0d2efda8be61bdff323ca0a8fe89", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -166,7 +166,7 @@ Available lint options:\n         max_key = num::max(name.len(), max_key);\n     }\n     fn padded(max: uint, s: &str) -> ~str {\n-        str::from_utf8(vec::from_elem(max - s.len(), ' ' as u8)) + s\n+        \" \".repeat(max - s.len()) + s\n     }\n     println(\"\\nAvailable lint checks:\\n\");\n     println!(\"    {}  {:7.7s}  {}\",\n@@ -246,7 +246,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n       1u => {\n         let ifile = matches.free[0].as_slice();\n         if \"-\" == ifile {\n-            let src = str::from_utf8(io::stdin().read_to_end());\n+            let src = str::from_utf8_owned(io::stdin().read_to_end());\n             str_input(src.to_managed())\n         } else {\n             file_input(Path::init(ifile))"}, {"sha": "7ccfe6b8d216c99a6a1a444a1aa703a04b4dd7cb", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -1274,8 +1274,8 @@ fn family_names_type(fam: Family) -> bool {\n fn read_path(d: ebml::Doc) -> (~str, uint) {\n     reader::with_doc_data(d, |desc| {\n         let pos = u64_from_be_bytes(desc, 0u, 4u) as uint;\n-        let pathbytes = desc.slice(4u, desc.len());\n-        let path = str::from_utf8(pathbytes);\n+        let pathbytes = desc.slice_from(4u).to_owned();\n+        let path = str::from_utf8_owned(pathbytes);\n \n         (path, pos)\n     })"}, {"sha": "152c64a4b6e2fa11eef5210457686ef71aba3f4f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -1902,5 +1902,5 @@ pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n         abbrevs: tyencode::ac_no_abbrevs};\n     let wr = @mut MemWriter::new();\n     tyencode::enc_ty(wr, cx, t);\n-    str::from_utf8(*wr.inner_ref())\n+    str::from_utf8_owned(wr.inner_ref().to_owned())\n }"}, {"sha": "cbf3dcf278133595755c6a3b11a309ec5187bc7d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -97,8 +97,9 @@ pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n }\n \n fn parse_ident_(st: &mut PState, is_last: |char| -> bool) -> ast::Ident {\n-    let rslt = scan(st, is_last, str::from_utf8);\n-    return st.tcx.sess.ident_of(rslt);\n+    scan(st, is_last, |bytes| {\n+            st.tcx.sess.ident_of(str::from_utf8(bytes))\n+        })\n }\n \n pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: ast::CrateNum,\n@@ -492,10 +493,11 @@ fn parse_abi_set(st: &mut PState) -> AbiSet {\n     assert_eq!(next(st), '[');\n     let mut abis = AbiSet::empty();\n     while peek(st) != ']' {\n-        // FIXME(#5422) str API should not force this copy\n-        let abi_str = scan(st, |c| c == ',', str::from_utf8);\n-        let abi = abi::lookup(abi_str).expect(abi_str);\n-        abis.add(abi);\n+         scan(st, |c| c == ',', |bytes| {\n+                 let abi_str = str::from_utf8(bytes).to_owned();\n+                 let abi = abi::lookup(abi_str).expect(abi_str);\n+                 abis.add(abi);\n+              });\n     }\n     assert_eq!(next(st), ']');\n     return abis;"}, {"sha": "22da8d6d8a8126290aa1d06d5488c819abca501d", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -184,7 +184,7 @@ impl<'self> PkgScript<'self> {\n                                              [sysroot.as_str().unwrap().to_owned(), ~\"configs\"]);\n             debug!(\"run_custom: second pkg command did {:?}\", output.status);\n             // Run the configs() function to get the configs\n-            let cfgs = str::from_utf8_slice(output.output).words()\n+            let cfgs = str::from_utf8(output.output).words()\n                 .map(|w| w.to_owned()).collect();\n             (cfgs, output.status)\n         }"}, {"sha": "17793f232866ec9b3c4c0a6c7ecedfa15f544bb8", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -290,13 +290,13 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n     });\n     let output = prog.finish_with_output();\n     debug!(\"Output from command {} with args {:?} was {} \\\\{{}\\\\}[{:?}]\",\n-                    cmd, args, str::from_utf8(output.output),\n-                   str::from_utf8(output.error),\n-                   output.status);\n+           cmd, args, str::from_utf8(output.output),\n+           str::from_utf8(output.error),\n+           output.status);\n     if !output.status.success() {\n-        debug!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} ---\",\n+        debug!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} {} ---\",\n               cmd, args, output.status,\n-              str::from_utf8(output.output) + str::from_utf8(output.error));\n+              str::from_utf8(output.output), str::from_utf8(output.error));\n         Fail(output)\n     }\n     else {\n@@ -1204,7 +1204,7 @@ fn test_info() {\n     let expected_info = ~\"package foo\"; // fill in\n     let workspace = create_local_package(&PkgId::new(\"foo\"));\n     let output = command_line_test([~\"info\", ~\"foo\"], workspace.path());\n-    assert_eq!(str::from_utf8(output.output), expected_info);\n+    assert_eq!(str::from_utf8_owned(output.output), expected_info);\n }\n \n #[test]"}, {"sha": "eced433868f22ae5281d2beb1bc474d23848d602", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -113,19 +113,19 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n             continue;\n         }\n \n-    let mut output = None;\n-    let output_text = str::from_utf8(outp.output);\n-    for l in output_text.lines() {\n-        if !l.is_whitespace() {\n-            output = Some(l);\n-        }\n-        match output.and_then(try_parsing_version) {\n-            Some(v) => return Some(v),\n-            None    => ()\n+        let mut output = None;\n+        let output_text = str::from_utf8(outp.output);\n+        for l in output_text.lines() {\n+            if !l.is_whitespace() {\n+                output = Some(l);\n+            }\n+            match output.and_then(try_parsing_version) {\n+                Some(v) => return Some(v),\n+                None    => ()\n+            }\n         }\n     }\n-  }\n-  None\n+    None\n }\n \n /// If `remote_path` refers to a git repo that can be downloaded,"}, {"sha": "78454f3e0d0c5ed475f5ce676b7a11934cbb8804", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -487,8 +487,8 @@ mod test {\n \n             let nread = result.unwrap();\n             assert!(nread > 0);\n-            let read_str = str::from_utf8(read_mem.slice(0, nread as uint));\n-            assert_eq!(read_str, ~\"hello\");\n+            let read_str = str::from_utf8(read_mem.slice_to(nread as uint));\n+            assert_eq!(read_str, \"hello\");\n         }\n         // unlink\n         let result = FsRequest::unlink(l(), &path_str.to_c_str());"}, {"sha": "0abd476d7b91fd283f2c9cbe33f35a596248c18e", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -81,7 +81,7 @@ pub fn sockaddr_to_socket_addr(addr: *sockaddr) -> SocketAddr {\n             };\n             port as u16\n         };\n-        let ip_str = str::from_utf8_slice(ip_name).trim_right_chars(&'\\x00');\n+        let ip_str = str::from_utf8(ip_name).trim_right_chars(&'\\x00');\n         let ip_addr = FromStr::from_str(ip_str).unwrap();\n \n         SocketAddr { ip: ip_addr, port: ip_port }"}, {"sha": "11845c766ed5c4b58872a5c758aaeb77aff9e83c", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -167,7 +167,7 @@ impl CString {\n         if self.buf.is_null() { return None; }\n         let buf = self.as_bytes();\n         let buf = buf.slice_to(buf.len()-1); // chop off the trailing NUL\n-        str::from_utf8_slice_opt(buf)\n+        str::from_utf8_opt(buf)\n     }\n \n     /// Return a CString iterator."}, {"sha": "463540b367752d8f26359a49574bdd23b1a59093", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -802,7 +802,7 @@ impl<'self> Formatter<'self> {\n \n     fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) {\n         ::uint::to_str_bytes(value, 10, |buf| {\n-            let valuestr = str::from_utf8_slice(buf);\n+            let valuestr = str::from_utf8(buf);\n             for piece in pieces.iter() {\n                 self.run(piece, Some(valuestr));\n             }"}, {"sha": "4a31449e105b0691fd53f02ea552a42dfaf275f7", "filename": "src/libstd/io/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fflate.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -107,7 +107,7 @@ mod test {\n     fn smoke_test() {\n         let mem_writer = MemWriter::new();\n         let mut deflate_writer = DeflateWriter::new(mem_writer);\n-        let in_msg = \"test\";\n+        let in_msg: &str = \"test\";\n         let in_bytes = in_msg.as_bytes();\n         deflate_writer.write(in_bytes);\n         deflate_writer.flush();\n@@ -118,6 +118,6 @@ mod test {\n         let bytes_read = inflate_reader.read(out_bytes).unwrap();\n         assert_eq!(bytes_read, in_bytes.len());\n         let out_msg = str::from_utf8(out_bytes);\n-        assert!(in_msg == out_msg);\n+        assert_eq!(in_msg, out_msg);\n     }\n }"}, {"sha": "f0b51a2c3e03fe57fc5d32beb7cdb76322342142", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -770,9 +770,9 @@ mod test {\n             let mut read_buf = [0, .. 1028];\n             let read_str = match read_stream.read(read_buf).unwrap() {\n                 -1|0 => fail!(\"shouldn't happen\"),\n-                n => str::from_utf8(read_buf.slice_to(n))\n+                n => str::from_utf8_owned(read_buf.slice_to(n).to_owned())\n             };\n-            assert!(read_str == message.to_owned());\n+            assert_eq!(read_str, message.to_owned());\n         }\n         unlink(filename);\n     })\n@@ -801,7 +801,7 @@ mod test {\n     })\n \n     test!(fn file_test_io_non_positional_read() {\n-        let message = \"ten-four\";\n+        let message: &str = \"ten-four\";\n         let mut read_mem = [0, .. 8];\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_rt_io_file_test_positional.txt\");\n@@ -822,7 +822,7 @@ mod test {\n         }\n         unlink(filename);\n         let read_str = str::from_utf8(read_mem);\n-        assert!(read_str == message.to_owned());\n+        assert_eq!(read_str, message);\n     })\n \n     test!(fn file_test_io_seek_and_tell_smoke_test() {\n@@ -846,9 +846,9 @@ mod test {\n         }\n         unlink(filename);\n         let read_str = str::from_utf8(read_mem);\n-        assert!(read_str == message.slice(4, 8).to_owned());\n-        assert!(tell_pos_pre_read == set_cursor);\n-        assert!(tell_pos_post_read == message.len() as u64);\n+        assert_eq!(read_str, message.slice(4, 8));\n+        assert_eq!(tell_pos_pre_read, set_cursor);\n+        assert_eq!(tell_pos_post_read, message.len() as u64);\n     })\n \n     test!(fn file_test_io_seek_and_write() {\n@@ -877,9 +877,9 @@ mod test {\n     test!(fn file_test_io_seek_shakedown() {\n         use std::str;          // 01234567890123\n         let initial_msg =   \"qwer-asdf-zxcv\";\n-        let chunk_one = \"qwer\";\n-        let chunk_two = \"asdf\";\n-        let chunk_three = \"zxcv\";\n+        let chunk_one: &str = \"qwer\";\n+        let chunk_two: &str = \"asdf\";\n+        let chunk_three: &str = \"zxcv\";\n         let mut read_mem = [0, .. 4];\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seek_shakedown.txt\");\n@@ -892,18 +892,15 @@ mod test {\n \n             read_stream.seek(-4, SeekEnd);\n             read_stream.read(read_mem);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == chunk_three.to_owned());\n+            assert_eq!(str::from_utf8(read_mem), chunk_three);\n \n             read_stream.seek(-9, SeekCur);\n             read_stream.read(read_mem);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == chunk_two.to_owned());\n+            assert_eq!(str::from_utf8(read_mem), chunk_two);\n \n             read_stream.seek(0, SeekSet);\n             read_stream.read(read_mem);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == chunk_one.to_owned());\n+            assert_eq!(str::from_utf8(read_mem), chunk_one);\n         }\n         unlink(filename);\n     })\n@@ -982,7 +979,7 @@ mod test {\n                     None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n                     Some(n) => prefix+n\n                 };\n-                assert!(expected == read_str);\n+                assert_eq!(expected.as_slice(), read_str);\n             }\n             unlink(f);\n         }"}, {"sha": "208c64f5ef42f046e1cfe3d1314f4de623cae167", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -1049,7 +1049,7 @@ pub trait Buffer: Reader {\n             Some(n) if n == width => {}\n             Some(..) | None => return None // read error\n         }\n-        match str::from_utf8_slice_opt(buf.slice_to(width)) {\n+        match str::from_utf8_opt(buf.slice_to(width)) {\n             Some(s) => Some(s.char_at(0)),\n             None => None\n         }"}, {"sha": "8e678ab66b25e73871be80789f673f0196969d9c", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -426,7 +426,7 @@ pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+Round+\n         sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n     let (bytes, special) = float_to_str_bytes_common(num, radix,\n                                negative_zero, sign, digits);\n-    (str::from_utf8(bytes), special)\n+    (str::from_utf8_owned(bytes), special)\n }\n \n // Some constants for from_str_bytes_common's input validation,"}, {"sha": "79989b838f6026db482bfd4c8794b6f9326279a7", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -176,7 +176,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// If the path is not representable in utf-8, this returns None.\n     #[inline]\n     fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8_slice_opt(self.as_vec())\n+        str::from_utf8_opt(self.as_vec())\n     }\n \n     /// Returns the path as a byte vector\n@@ -207,7 +207,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `dirname` for details.\n     #[inline]\n     fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8_slice_opt(self.dirname())\n+        str::from_utf8_opt(self.dirname())\n     }\n     /// Returns the file component of `self`, as a byte vector.\n     /// If `self` represents the root of the file hierarchy, returns None.\n@@ -217,7 +217,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `filename` for details.\n     #[inline]\n     fn filename_str<'a>(&'a self) -> Option<&'a str> {\n-        self.filename().and_then(str::from_utf8_slice_opt)\n+        self.filename().and_then(str::from_utf8_opt)\n     }\n     /// Returns the stem of the filename of `self`, as a byte vector.\n     /// The stem is the portion of the filename just before the last '.'.\n@@ -239,7 +239,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `filestem` for details.\n     #[inline]\n     fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n-        self.filestem().and_then(str::from_utf8_slice_opt)\n+        self.filestem().and_then(str::from_utf8_opt)\n     }\n     /// Returns the extension of the filename of `self`, as an optional byte vector.\n     /// The extension is the portion of the filename just after the last '.'.\n@@ -262,7 +262,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `extension` for details.\n     #[inline]\n     fn extension_str<'a>(&'a self) -> Option<&'a str> {\n-        self.extension().and_then(str::from_utf8_slice_opt)\n+        self.extension().and_then(str::from_utf8_opt)\n     }\n \n     /// Replaces the filename portion of the path with the given byte vector or string.\n@@ -493,12 +493,12 @@ pub trait BytesContainer {\n     /// Raises `str::null_byte` if not utf-8\n     #[inline]\n     fn container_as_str<'a>(&'a self) -> &'a str {\n-        str::from_utf8_slice(self.container_as_bytes())\n+        str::from_utf8(self.container_as_bytes())\n     }\n     /// Returns the receiver interpreted as a utf-8 string, if possible\n     #[inline]\n     fn container_as_str_opt<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8_slice_opt(self.container_as_bytes())\n+        str::from_utf8_opt(self.container_as_bytes())\n     }\n     /// Returns whether .container_as_str() is guaranteed to not fail\n     // FIXME (#8888): Remove unused arg once ::<for T> works"}, {"sha": "ddf2cce21b0e653fd6c67fbeeec03d0f2c7b535f", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -396,13 +396,13 @@ impl Path {\n     /// Returns an iterator that yields each component of the path as Option<&str>.\n     /// See components() for details.\n     pub fn str_components<'a>(&'a self) -> StrComponentIter<'a> {\n-        self.components().map(str::from_utf8_slice_opt)\n+        self.components().map(str::from_utf8_opt)\n     }\n \n     /// Returns an iterator that yields each component of the path in reverse as Option<&str>.\n     /// See components() for details.\n     pub fn rev_str_components<'a>(&'a self) -> RevStrComponentIter<'a> {\n-        self.rev_components().map(str::from_utf8_slice_opt)\n+        self.rev_components().map(str::from_utf8_opt)\n     }\n }\n \n@@ -684,7 +684,7 @@ mod tests {\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n                 {\n                     let path = Path::init($path);\n-                    let left = path.$op().map(|x| str::from_utf8_slice(x));\n+                    let left = path.$op().map(|x| str::from_utf8(x));\n                     assert_eq!(left, $exp);\n                 }\n             );"}, {"sha": "6cc5e5cc9f26b09bd81d58e2c4a54273b03a1b02", "filename": "src/libstd/run.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -347,7 +347,7 @@ mod tests {\n \n         let run::ProcessOutput {status, output, error}\n              = run::process_output(\"echo\", [~\"hello\"]);\n-        let output_str = str::from_utf8(output);\n+        let output_str = str::from_utf8_owned(output);\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n@@ -439,7 +439,7 @@ mod tests {\n         let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new());\n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n-        let output_str = str::from_utf8(output);\n+        let output_str = str::from_utf8_owned(output);\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n@@ -457,7 +457,7 @@ mod tests {\n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n \n-        let output_str = str::from_utf8(output);\n+        let output_str = str::from_utf8_owned(output);\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n@@ -504,7 +504,7 @@ mod tests {\n     fn test_keep_current_working_dir() {\n         let mut prog = run_pwd(None);\n \n-        let output = str::from_utf8(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output);\n         let parent_dir = os::getcwd();\n         let child_dir = Path::init(output.trim());\n \n@@ -522,7 +522,7 @@ mod tests {\n         let parent_dir = os::getcwd().dir_path();\n         let mut prog = run_pwd(Some(&parent_dir));\n \n-        let output = str::from_utf8(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output);\n         let child_dir = Path::init(output.trim());\n \n         let parent_stat = parent_dir.stat();\n@@ -561,7 +561,7 @@ mod tests {\n         if running_on_valgrind() { return; }\n \n         let mut prog = run_env(None);\n-        let output = str::from_utf8(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output);\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -575,7 +575,7 @@ mod tests {\n         if running_on_valgrind() { return; }\n \n         let mut prog = run_env(None);\n-        let output = str::from_utf8(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output);\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -594,7 +594,7 @@ mod tests {\n         new_env.push((~\"RUN_TEST_NEW_ENV\", ~\"123\"));\n \n         let mut prog = run_env(Some(new_env));\n-        let output = str::from_utf8(prog.finish_with_output().output);\n+        let output = str::from_utf8_owned(prog.finish_with_output().output);\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"));\n     }"}, {"sha": "c1898a9b920a46f3de7842510a0a9278a9fc1e47", "filename": "src/libstd/str.rs", "status": "modified", "additions": 18, "deletions": 118, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -124,34 +124,6 @@ condition! {\n Section: Creating a string\n */\n \n-/// Convert a vector of bytes to a new UTF-8 string\n-///\n-/// # Failure\n-///\n-/// Raises the `not_utf8` condition if invalid UTF-8\n-pub fn from_utf8(vv: &[u8]) -> ~str {\n-    use str::not_utf8::cond;\n-\n-    match from_utf8_opt(vv) {\n-        None => {\n-            let first_bad_byte = *vv.iter().find(|&b| !is_utf8([*b])).unwrap();\n-            cond.raise(format!(\"from_utf8: input is not UTF-8; first bad \\\n-                                byte is {}\", first_bad_byte))\n-        }\n-        Some(s) => s\n-    }\n-}\n-\n-/// Convert a vector of bytes to a new UTF-8 string, if possible.\n-/// Returns None if the vector contains invalid UTF-8.\n-pub fn from_utf8_opt(vv: &[u8]) -> Option<~str> {\n-    if is_utf8(vv) {\n-        Some(unsafe { raw::from_utf8(vv) })\n-    } else {\n-        None\n-    }\n-}\n-\n /// Consumes a vector of bytes to create a new utf-8 string\n ///\n /// # Failure\n@@ -187,16 +159,16 @@ pub fn from_utf8_owned_opt(vv: ~[u8]) -> Option<~str> {\n /// # Failure\n ///\n /// Fails if invalid UTF-8\n-pub fn from_utf8_slice<'a>(v: &'a [u8]) -> &'a str {\n-    from_utf8_slice_opt(v).expect(\"from_utf8_slice: not utf-8\")\n+pub fn from_utf8<'a>(v: &'a [u8]) -> &'a str {\n+    from_utf8_opt(v).expect(\"from_utf8: not utf-8\")\n }\n \n /// Converts a vector to a string slice without performing any allocations.\n ///\n /// Returns None if the slice is not utf-8.\n-pub fn from_utf8_slice_opt<'a>(v: &'a [u8]) -> Option<&'a str> {\n+pub fn from_utf8_opt<'a>(v: &'a [u8]) -> Option<&'a str> {\n     if is_utf8(v) {\n-        Some(unsafe { cast::transmute(v) })\n+        Some(unsafe { raw::from_utf8(v) })\n     } else { None }\n }\n \n@@ -1055,9 +1027,10 @@ pub mod raw {\n         from_buf_len(buf as *u8, i as uint)\n     }\n \n-    /// Converts a vector of bytes to a new owned string.\n-    pub unsafe fn from_utf8(v: &[u8]) -> ~str {\n-        v.as_imm_buf(|buf, len| from_buf_len(buf, len))\n+    /// Converts a slice of bytes to a string slice without checking\n+    /// that the string contains valid UTF-8.\n+    pub unsafe fn from_utf8<'a>(v: &'a [u8]) -> &'a str {\n+        cast::transmute(v)\n     }\n \n     /// Converts an owned vector of bytes to a new owned string. This assumes\n@@ -1068,7 +1041,7 @@ pub mod raw {\n     }\n \n     /// Converts a byte to a string.\n-    pub unsafe fn from_byte(u: u8) -> ~str { from_utf8([u]) }\n+    pub unsafe fn from_byte(u: u8) -> ~str { from_utf8_owned(~[u]) }\n \n     /// Form a slice from a C string. Unsafe because the caller must ensure the\n     /// C string has the static lifetime, or else the return value may be\n@@ -3077,33 +3050,6 @@ mod tests {\n         assert_eq!(b, 67u8);\n     }\n \n-    #[test]\n-    fn test_unsafe_from_utf8() {\n-        let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n-        let b = unsafe { raw::from_utf8(a) };\n-        assert_eq!(b, ~\"AAAAAAA\");\n-    }\n-\n-    #[test]\n-    fn test_from_utf8() {\n-        let ss = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let bb = ~[0xe0_u8, 0xb8_u8, 0xa8_u8,\n-                  0xe0_u8, 0xb9_u8, 0x84_u8,\n-                  0xe0_u8, 0xb8_u8, 0x97_u8,\n-                  0xe0_u8, 0xb8_u8, 0xa2_u8,\n-                  0xe4_u8, 0xb8_u8, 0xad_u8,\n-                  0xe5_u8, 0x8d_u8, 0x8e_u8,\n-                  0x56_u8, 0x69_u8, 0xe1_u8,\n-                  0xbb_u8, 0x87_u8, 0x74_u8,\n-                  0x20_u8, 0x4e_u8, 0x61_u8,\n-                  0x6d_u8];\n-\n-\n-        assert_eq!(ss, from_utf8(bb));\n-        assert_eq!(~\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\",\n-                   from_utf8(bytes!(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\")));\n-    }\n-\n     #[test]\n     fn test_is_utf8() {\n         // deny overlong encodings\n@@ -3129,31 +3075,6 @@ mod tests {\n         assert!(is_utf8([0xF4, 0x8F, 0xBF, 0xBF]));\n     }\n \n-\n-    #[test]\n-    fn test_from_utf8_fail() {\n-        use str::not_utf8::cond;\n-\n-        let bb = ~[0xff_u8, 0xb8_u8, 0xa8_u8,\n-                  0xe0_u8, 0xb9_u8, 0x84_u8,\n-                  0xe0_u8, 0xb8_u8, 0x97_u8,\n-                  0xe0_u8, 0xb8_u8, 0xa2_u8,\n-                  0xe4_u8, 0xb8_u8, 0xad_u8,\n-                  0xe5_u8, 0x8d_u8, 0x8e_u8,\n-                  0x56_u8, 0x69_u8, 0xe1_u8,\n-                  0xbb_u8, 0x87_u8, 0x74_u8,\n-                  0x20_u8, 0x4e_u8, 0x61_u8,\n-                  0x6d_u8];\n-\n-        let mut error_happened = false;\n-        let _x = cond.trap(|err| {\n-            assert_eq!(err, ~\"from_utf8: input is not UTF-8; first bad byte is 255\");\n-            error_happened = true;\n-            ~\"\"\n-        }).inside(|| from_utf8(bb));\n-        assert!(error_happened);\n-    }\n-\n     #[test]\n     fn test_raw_from_c_str() {\n         unsafe {\n@@ -3232,7 +3153,7 @@ mod tests {\n         let s1: ~str = ~\"All mimsy were the borogoves\";\n \n         let v: ~[u8] = s1.as_bytes().to_owned();\n-        let s2: ~str = from_utf8(v);\n+        let s2: ~str = from_utf8(v).to_owned();\n         let mut i: uint = 0u;\n         let n1: uint = s1.len();\n         let n2: uint = v.len();\n@@ -3755,49 +3676,28 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_str_from_utf8_slice() {\n+    fn test_str_from_utf8() {\n         let xs = bytes!(\"hello\");\n-        assert_eq!(from_utf8_slice(xs), \"hello\");\n+        assert_eq!(from_utf8(xs), \"hello\");\n \n         let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(from_utf8_slice(xs), \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(from_utf8(xs), \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_str_from_utf8_slice_invalid() {\n+    fn test_str_from_utf8_invalid() {\n         let xs = bytes!(\"hello\", 0xff);\n-        let _ = from_utf8_slice(xs);\n-    }\n-\n-    #[test]\n-    fn test_str_from_utf8_slice_opt() {\n-        let xs = bytes!(\"hello\");\n-        assert_eq!(from_utf8_slice_opt(xs), Some(\"hello\"));\n-\n-        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(from_utf8_slice_opt(xs), Some(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n-\n-        let xs = bytes!(\"hello\", 0xff);\n-        assert_eq!(from_utf8_slice_opt(xs), None);\n-    }\n-\n-    #[test]\n-    fn test_str_from_utf8() {\n-        let xs = bytes!(\"hello\");\n-        assert_eq!(from_utf8(xs), ~\"hello\");\n-\n-        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(from_utf8(xs), ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        let _ = from_utf8(xs);\n     }\n \n     #[test]\n     fn test_str_from_utf8_opt() {\n-        let xs = bytes!(\"hello\").to_owned();\n-        assert_eq!(from_utf8_opt(xs), Some(~\"hello\"));\n+        let xs = bytes!(\"hello\");\n+        assert_eq!(from_utf8_opt(xs), Some(\"hello\"));\n \n         let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(from_utf8_opt(xs), Some(~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+        assert_eq!(from_utf8_opt(xs), Some(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = bytes!(\"hello\", 0xff);\n         assert_eq!(from_utf8_opt(xs), None);"}, {"sha": "0704bf913d7c419d1f1f35d735b653f26ac0f6dd", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -346,7 +346,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n                                     path: @str,\n                                     srdr: &mut io::Reader)\n                                  -> (~[cmnt], ~[lit]) {\n-    let src = str::from_utf8(srdr.read_to_end()).to_managed();\n+    let src = str::from_utf8_owned(srdr.read_to_end()).to_managed();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);"}, {"sha": "3c6fa86485d21e6fd2424160b1e675f5d11675fc", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -210,7 +210,7 @@ pub fn fun_to_str(decl: &ast::fn_decl, purity: ast::purity, name: ast::Ident,\n     end(s); // Close the head box\n     end(s); // Close the outer box\n     eof(s.s);\n-    str::from_utf8(*wr.inner_ref())\n+    str::from_utf8_owned(wr.inner_ref().to_owned())\n }\n \n pub fn block_to_str(blk: &ast::Block, intr: @ident_interner) -> ~str {\n@@ -222,7 +222,7 @@ pub fn block_to_str(blk: &ast::Block, intr: @ident_interner) -> ~str {\n     ibox(s, 0u);\n     print_block(s, blk);\n     eof(s.s);\n-    str::from_utf8(*wr.inner_ref())\n+    str::from_utf8_owned(wr.inner_ref().to_owned())\n }\n \n pub fn meta_item_to_str(mi: &ast::MetaItem, intr: @ident_interner) -> ~str {\n@@ -2292,7 +2292,7 @@ pub fn to_str<T>(t: &T, f: |@ps, &T|, intr: @ident_interner) -> ~str {\n     let s = rust_printer(wr as @mut io::Writer, intr);\n     f(s, t);\n     eof(s.s);\n-    str::from_utf8(*wr.inner_ref())\n+    str::from_utf8_owned(wr.inner_ref().to_owned())\n }\n \n pub fn next_comment(s: @ps) -> Option<comments::cmnt> {"}, {"sha": "76d2ca1f30bfc0078b87fbcaf2d1e2ca1a8fcbf9", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -70,12 +70,10 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n \n    let mut buffer = ~\"\";\n \n-   for kv in pairs_sorted.iter() {\n-       let (k,v) = (*kv).clone();\n+   for &(ref k, v) in pairs_sorted.iter() {\n        unsafe {\n-           let b = str::raw::from_utf8(k);\n            buffer.push_str(format!(\"{} {:0.3f}\\n\",\n-                                   b.into_ascii().to_upper().into_str(), v));\n+                                   k.to_ascii().to_upper().into_str(), v));\n        }\n    }\n "}, {"sha": "84b2d33c501dca38f80dc86e8054c8cafa326fd7", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -60,7 +60,7 @@ impl Code {\n         }\n \n         reverse(result);\n-        str::from_utf8(result)\n+        str::from_utf8_owned(result)\n     }\n }\n "}, {"sha": "b0efa3bb33f942ff5294fb6e100fb3f628f0b940", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -17,7 +17,7 @@ static C: *u8 = B as *u8;\n pub fn main() {\n     unsafe {\n         let foo = &A as *u8;\n-        assert_eq!(str::raw::from_utf8(A), ~\"hi\");\n+        assert_eq!(str::raw::from_utf8(A), \"hi\");\n         assert_eq!(str::raw::from_buf_len(foo, A.len()), ~\"hi\");\n         assert_eq!(str::raw::from_buf_len(C, B.len()), ~\"hi\");\n         assert!(*C == A[0]);"}, {"sha": "05f74ca8373ee5e02935ac0ae83721213bb31629", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -59,13 +59,13 @@ fn test_destroy_actually_kills(force: bool) {\n     #[cfg(unix,not(target_os=\"android\"))]\n     fn process_exists(pid: libc::pid_t) -> bool {\n         let run::ProcessOutput {output, ..} = run::process_output(\"ps\", [~\"-p\", pid.to_str()]);\n-        str::from_utf8(output).contains(pid.to_str())\n+        str::from_utf8_owned(output).contains(pid.to_str())\n     }\n \n     #[cfg(unix,target_os=\"android\")]\n     fn process_exists(pid: libc::pid_t) -> bool {\n         let run::ProcessOutput {output, ..} = run::process_output(\"/system/bin/ps\", [pid.to_str()]);\n-        str::from_utf8(output).contains(~\"root\")\n+        str::from_utf8_owned(output).contains(~\"root\")\n     }\n \n     #[cfg(windows)]"}, {"sha": "3d02d2c2c5bef34222bd2b2a3e9369375ef974b1", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -79,11 +79,10 @@ mod map_reduce {\n             match ctrl_port.recv() {\n               mapper_done => { num_mappers -= 1; }\n               find_reducer(k, cc) => {\n-                let mut c;\n-                match reducers.find(&str::from_utf8(k)) {\n-                  Some(&_c) => { c = _c; }\n-                  None => { c = 0; }\n-                }\n+                let c = match reducers.find(&str::from_utf8_owned(k)) {\n+                  Some(&_c) => _c,\n+                  None => 0\n+                };\n                 cc.send(c);\n               }\n             }"}, {"sha": "6463a1d5321716350c6f739599d7108e3850bee8", "filename": "src/test/run-pass/rtio-processes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9cf9892b74dc376fe740ea56858042e9bd89de/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frtio-processes.rs?ref=9b9cf9892b74dc376fe740ea56858042e9bd89de", "patch": "@@ -108,7 +108,7 @@ fn read_all(input: &mut Reader) -> ~str {\n     loop {\n         match input.read(buf) {\n             None => { break }\n-            Some(n) => { ret = ret + str::from_utf8(buf.slice_to(n)); }\n+            Some(n) => { ret.push_str(str::from_utf8(buf.slice_to(n))); }\n         }\n     }\n     return ret;"}]}