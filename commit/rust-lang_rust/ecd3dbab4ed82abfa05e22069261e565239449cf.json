{"sha": "ecd3dbab4ed82abfa05e22069261e565239449cf", "node_id": "C_kwDOAAsO6NoAKGVjZDNkYmFiNGVkODJhYmZhMDVlMjIwNjkyNjFlNTY1MjM5NDQ5Y2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-09T08:16:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-09T08:16:26Z"}, "message": "Auto merge of #111380 - Dylan-DPC:rollup-xiptbhn, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #110304 (Add GNU Property Note)\n - #110504 (Tweak borrow suggestion span)\n - #110583 (tweak \"make mut\" spans when assigning to locals)\n - #110694 (Implement builtin # syntax and use it for offset_of!(...))\n - #111120 (Suggest let for possible binding with ty)\n - #111252 (Min specialization improvements)\n - #111361 (Update books)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "03ec27f0a1765fca86fd800b41e83c39c0bd529d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03ec27f0a1765fca86fd800b41e83c39c0bd529d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecd3dbab4ed82abfa05e22069261e565239449cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecd3dbab4ed82abfa05e22069261e565239449cf", "html_url": "https://github.com/rust-lang/rust/commit/ecd3dbab4ed82abfa05e22069261e565239449cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecd3dbab4ed82abfa05e22069261e565239449cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e7483d26e3cec7a44ef00cf7ae6c9c8c918bec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e7483d26e3cec7a44ef00cf7ae6c9c8c918bec6", "html_url": "https://github.com/rust-lang/rust/commit/7e7483d26e3cec7a44ef00cf7ae6c9c8c918bec6"}, {"sha": "9d913eb9e4eb2a433e8755e1359c1cccb344ad3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d913eb9e4eb2a433e8755e1359c1cccb344ad3f", "html_url": "https://github.com/rust-lang/rust/commit/9d913eb9e4eb2a433e8755e1359c1cccb344ad3f"}], "stats": {"total": 2658, "additions": 1739, "deletions": 919}, "files": [{"sha": "3d5056d82c56c4c8c3e96f2c9a39e81290cd0fe7", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -603,6 +603,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(yeet_expr, \"`do yeet` expression is experimental\");\n     gate_all!(dyn_star, \"`dyn*` trait objects are experimental\");\n     gate_all!(const_closures, \"const closures are experimental\");\n+    gate_all!(builtin_syntax, \"`builtin #` syntax is unstable\");\n \n     if !visitor.features.negative_bounds {\n         for &span in spans.get(&sym::negative_bounds).iter().copied().flatten() {"}, {"sha": "87c32ffce1214b6ffbced065d7eb358561f0509b", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -556,8 +556,7 @@ impl<'a> State<'a> {\n                 self.pclose();\n             }\n             ast::ExprKind::OffsetOf(container, fields) => {\n-                // FIXME: This should have its own syntax, distinct from a macro invocation.\n-                self.word(\"offset_of!\");\n+                self.word(\"builtin # offset_of\");\n                 self.popen();\n                 self.rbox(0, Inconsistent);\n                 self.print_type(container);"}, {"sha": "6286033e0672d2bf2a041c1705def878ddfb582c", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 264, "deletions": 245, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1,4 +1,4 @@\n-use rustc_errors::{Applicability, Diagnostic};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n@@ -478,186 +478,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 match self.local_names[local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n-                        let label = match *local_decl.local_info() {\n-                            LocalInfo::User(mir::BindingForm::ImplicitSelf(_)) => {\n-                                let (span, suggestion) =\n-                                    suggest_ampmut_self(self.infcx.tcx, local_decl);\n-                                Some((true, span, suggestion))\n-                            }\n-\n-                            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n-                                binding_mode: ty::BindingMode::BindByValue(_),\n-                                opt_ty_info,\n-                                ..\n-                            })) => {\n-                                // check if the RHS is from desugaring\n-                                let opt_assignment_rhs_span =\n-                                    self.body.find_assignments(local).first().map(|&location| {\n-                                        if let Some(mir::Statement {\n-                                            source_info: _,\n-                                            kind:\n-                                                mir::StatementKind::Assign(box (\n-                                                    _,\n-                                                    mir::Rvalue::Use(mir::Operand::Copy(place)),\n-                                                )),\n-                                        }) = self.body[location.block]\n-                                            .statements\n-                                            .get(location.statement_index)\n-                                        {\n-                                            self.body.local_decls[place.local].source_info.span\n-                                        } else {\n-                                            self.body.source_info(location).span\n-                                        }\n-                                    });\n-                                match opt_assignment_rhs_span.and_then(|s| s.desugaring_kind()) {\n-                                    // on for loops, RHS points to the iterator part\n-                                    Some(DesugaringKind::ForLoop) => {\n-                                        self.suggest_similar_mut_method_for_for_loop(&mut err);\n-                                        err.span_label(opt_assignment_rhs_span.unwrap(), format!(\n-                                            \"this iterator yields `{pointer_sigil}` {pointer_desc}s\",\n-                                        ));\n-                                        None\n-                                    }\n-                                    // don't create labels for compiler-generated spans\n-                                    Some(_) => None,\n-                                    None => {\n-                                        let label = if name != kw::SelfLower {\n-                                            suggest_ampmut(\n-                                                self.infcx.tcx,\n-                                                local_decl,\n-                                                opt_assignment_rhs_span,\n-                                                opt_ty_info,\n-                                            )\n-                                        } else {\n-                                            match local_decl.local_info() {\n-                                                LocalInfo::User(mir::BindingForm::Var(\n-                                                    mir::VarBindingForm {\n-                                                        opt_ty_info: None, ..\n-                                                    },\n-                                                )) => {\n-                                                    let (span, sugg) = suggest_ampmut_self(\n-                                                        self.infcx.tcx,\n-                                                        local_decl,\n-                                                    );\n-                                                    (true, span, sugg)\n-                                                }\n-                                                // explicit self (eg `self: &'a Self`)\n-                                                _ => suggest_ampmut(\n-                                                    self.infcx.tcx,\n-                                                    local_decl,\n-                                                    opt_assignment_rhs_span,\n-                                                    opt_ty_info,\n-                                                ),\n-                                            }\n-                                        };\n-                                        Some(label)\n-                                    }\n-                                }\n-                            }\n-\n-                            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n-                                binding_mode: ty::BindingMode::BindByReference(_),\n-                                ..\n-                            })) => {\n-                                let pattern_span = local_decl.source_info.span;\n-                                suggest_ref_mut(self.infcx.tcx, pattern_span)\n-                                    .map(|replacement| (true, pattern_span, replacement))\n-                            }\n-\n-                            _ => unreachable!(),\n-                        };\n-\n-                        match label {\n-                            Some((true, err_help_span, suggested_code)) => {\n-                                let (is_trait_sig, local_trait) = self.is_error_in_trait(local);\n-                                if !is_trait_sig {\n-                                    err.span_suggestion_verbose(\n-                                        err_help_span,\n-                                        format!(\n-                                            \"consider changing this to be a mutable {pointer_desc}\"\n-                                        ),\n-                                        suggested_code,\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                } else if let Some(x) = local_trait {\n-                                    err.span_suggestion_verbose(\n-                                        x,\n-                                        format!(\n-                                            \"consider changing that to be a mutable {pointer_desc}\"\n-                                        ),\n-                                        suggested_code,\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                            }\n-                            Some((false, err_label_span, message)) => {\n-                                struct BindingFinder {\n-                                    span: Span,\n-                                    hir_id: Option<hir::HirId>,\n-                                }\n-\n-                                impl<'tcx> Visitor<'tcx> for BindingFinder {\n-                                    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n-                                        if let hir::StmtKind::Local(local) = s.kind {\n-                                            if local.pat.span == self.span {\n-                                                self.hir_id = Some(local.hir_id);\n-                                            }\n-                                        }\n-                                        hir::intravisit::walk_stmt(self, s);\n-                                    }\n-                                }\n-                                let hir_map = self.infcx.tcx.hir();\n-                                let def_id = self.body.source.def_id();\n-                                let hir_id = hir_map.local_def_id_to_hir_id(def_id.expect_local());\n-                                let node = hir_map.find(hir_id);\n-                                let hir_id = if let Some(hir::Node::Item(item)) = node\n-                                    && let hir::ItemKind::Fn(.., body_id) = item.kind\n-                                {\n-                                    let body = hir_map.body(body_id);\n-                                    let mut v = BindingFinder {\n-                                        span: err_label_span,\n-                                        hir_id: None,\n-                                    };\n-                                    v.visit_body(body);\n-                                    v.hir_id\n-                                } else {\n-                                    None\n-                                };\n-                                if let Some(hir_id) = hir_id\n-                                    && let Some(hir::Node::Local(local)) = hir_map.find(hir_id)\n-                                {\n-                                    let (changing, span, sugg) = match local.ty {\n-                                        Some(ty) => (\"changing\", ty.span, message),\n-                                        None => (\n-                                            \"specifying\",\n-                                            local.pat.span.shrink_to_hi(),\n-                                            format!(\": {message}\"),\n-                                        ),\n-                                    };\n-                                    err.span_suggestion_verbose(\n-                                        span,\n-                                        format!(\"consider {changing} this binding's type\"),\n-                                        sugg,\n-                                        Applicability::HasPlaceholders,\n-                                    );\n-                                } else {\n-                                    err.span_label(\n-                                        err_label_span,\n-                                        format!(\n-                                            \"consider changing this binding's type to be: `{message}`\"\n-                                        ),\n-                                    );\n-                                }\n-                            }\n-                            None => {}\n-                        }\n                         err.span_label(\n                             span,\n                             format!(\n                                 \"`{name}` is a `{pointer_sigil}` {pointer_desc}, \\\n                                  so the data it refers to cannot be {acted_on}\",\n                             ),\n                         );\n+\n+                        self.suggest_make_local_mut(&mut err, local, name);\n                     }\n                     _ => {\n                         err.span_label(\n@@ -1131,6 +960,184 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn suggest_make_local_mut(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        local: Local,\n+        name: Symbol,\n+    ) {\n+        let local_decl = &self.body.local_decls[local];\n+\n+        let (pointer_sigil, pointer_desc) =\n+            if local_decl.ty.is_ref() { (\"&\", \"reference\") } else { (\"*const\", \"pointer\") };\n+\n+        let (is_trait_sig, local_trait) = self.is_error_in_trait(local);\n+        if is_trait_sig && local_trait.is_none() {\n+            return;\n+        }\n+\n+        let decl_span = match local_trait {\n+            Some(span) => span,\n+            None => local_decl.source_info.span,\n+        };\n+\n+        let label = match *local_decl.local_info() {\n+            LocalInfo::User(mir::BindingForm::ImplicitSelf(_)) => {\n+                let suggestion = suggest_ampmut_self(self.infcx.tcx, decl_span);\n+                Some((true, decl_span, suggestion))\n+            }\n+\n+            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                binding_mode: ty::BindingMode::BindByValue(_),\n+                opt_ty_info,\n+                ..\n+            })) => {\n+                // check if the RHS is from desugaring\n+                let opt_assignment_rhs_span =\n+                    self.body.find_assignments(local).first().map(|&location| {\n+                        if let Some(mir::Statement {\n+                            source_info: _,\n+                            kind:\n+                                mir::StatementKind::Assign(box (\n+                                    _,\n+                                    mir::Rvalue::Use(mir::Operand::Copy(place)),\n+                                )),\n+                        }) = self.body[location.block].statements.get(location.statement_index)\n+                        {\n+                            self.body.local_decls[place.local].source_info.span\n+                        } else {\n+                            self.body.source_info(location).span\n+                        }\n+                    });\n+                match opt_assignment_rhs_span.and_then(|s| s.desugaring_kind()) {\n+                    // on for loops, RHS points to the iterator part\n+                    Some(DesugaringKind::ForLoop) => {\n+                        self.suggest_similar_mut_method_for_for_loop(err);\n+                        err.span_label(\n+                            opt_assignment_rhs_span.unwrap(),\n+                            format!(\"this iterator yields `{pointer_sigil}` {pointer_desc}s\",),\n+                        );\n+                        None\n+                    }\n+                    // don't create labels for compiler-generated spans\n+                    Some(_) => None,\n+                    None => {\n+                        let label = if name != kw::SelfLower {\n+                            suggest_ampmut(\n+                                self.infcx.tcx,\n+                                local_decl.ty,\n+                                decl_span,\n+                                opt_assignment_rhs_span,\n+                                opt_ty_info,\n+                            )\n+                        } else {\n+                            match local_decl.local_info() {\n+                                LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                                    opt_ty_info: None,\n+                                    ..\n+                                })) => {\n+                                    let sugg = suggest_ampmut_self(self.infcx.tcx, decl_span);\n+                                    (true, decl_span, sugg)\n+                                }\n+                                // explicit self (eg `self: &'a Self`)\n+                                _ => suggest_ampmut(\n+                                    self.infcx.tcx,\n+                                    local_decl.ty,\n+                                    decl_span,\n+                                    opt_assignment_rhs_span,\n+                                    opt_ty_info,\n+                                ),\n+                            }\n+                        };\n+                        Some(label)\n+                    }\n+                }\n+            }\n+\n+            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                binding_mode: ty::BindingMode::BindByReference(_),\n+                ..\n+            })) => {\n+                let pattern_span: Span = local_decl.source_info.span;\n+                suggest_ref_mut(self.infcx.tcx, pattern_span)\n+                    .map(|span| (true, span, \"mut \".to_owned()))\n+            }\n+\n+            _ => unreachable!(),\n+        };\n+\n+        match label {\n+            Some((true, err_help_span, suggested_code)) => {\n+                err.span_suggestion_verbose(\n+                    err_help_span,\n+                    format!(\"consider changing this to be a mutable {pointer_desc}\"),\n+                    suggested_code,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            Some((false, err_label_span, message)) => {\n+                struct BindingFinder {\n+                    span: Span,\n+                    hir_id: Option<hir::HirId>,\n+                }\n+\n+                impl<'tcx> Visitor<'tcx> for BindingFinder {\n+                    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n+                        if let hir::StmtKind::Local(local) = s.kind {\n+                            if local.pat.span == self.span {\n+                                self.hir_id = Some(local.hir_id);\n+                            }\n+                        }\n+                        hir::intravisit::walk_stmt(self, s);\n+                    }\n+                }\n+                let hir_map = self.infcx.tcx.hir();\n+                let def_id = self.body.source.def_id();\n+                let hir_id = hir_map.local_def_id_to_hir_id(def_id.expect_local());\n+                let node = hir_map.find(hir_id);\n+                let hir_id = if let Some(hir::Node::Item(item)) = node\n+                && let hir::ItemKind::Fn(.., body_id) = item.kind\n+            {\n+                let body = hir_map.body(body_id);\n+                let mut v = BindingFinder {\n+                    span: err_label_span,\n+                    hir_id: None,\n+                };\n+                v.visit_body(body);\n+                v.hir_id\n+            } else {\n+                None\n+            };\n+                if let Some(hir_id) = hir_id\n+                && let Some(hir::Node::Local(local)) = hir_map.find(hir_id)\n+            {\n+                let (changing, span, sugg) = match local.ty {\n+                    Some(ty) => (\"changing\", ty.span, message),\n+                    None => (\n+                        \"specifying\",\n+                        local.pat.span.shrink_to_hi(),\n+                        format!(\": {message}\"),\n+                    ),\n+                };\n+                err.span_suggestion_verbose(\n+                    span,\n+                    format!(\"consider {changing} this binding's type\"),\n+                    sugg,\n+                    Applicability::HasPlaceholders,\n+                );\n+            } else {\n+                err.span_label(\n+                    err_label_span,\n+                    format!(\n+                        \"consider changing this binding's type to be: `{message}`\"\n+                    ),\n+                );\n+            }\n+            }\n+            None => {}\n+        }\n+    }\n }\n \n pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n@@ -1160,25 +1167,18 @@ pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<\n     }\n }\n \n-fn suggest_ampmut_self<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    local_decl: &mir::LocalDecl<'tcx>,\n-) -> (Span, String) {\n-    let sp = local_decl.source_info.span;\n-    (\n-        sp,\n-        match tcx.sess.source_map().span_to_snippet(sp) {\n-            Ok(snippet) => {\n-                let lt_pos = snippet.find('\\'');\n-                if let Some(lt_pos) = lt_pos {\n-                    format!(\"&{}mut self\", &snippet[lt_pos..snippet.len() - 4])\n-                } else {\n-                    \"&mut self\".to_string()\n-                }\n+fn suggest_ampmut_self<'tcx>(tcx: TyCtxt<'tcx>, span: Span) -> String {\n+    match tcx.sess.source_map().span_to_snippet(span) {\n+        Ok(snippet) => {\n+            let lt_pos = snippet.find('\\'');\n+            if let Some(lt_pos) = lt_pos {\n+                format!(\"&{}mut self\", &snippet[lt_pos..snippet.len() - 4])\n+            } else {\n+                \"&mut self\".to_string()\n             }\n-            _ => \"&mut self\".to_string(),\n-        },\n-    )\n+        }\n+        _ => \"&mut self\".to_string(),\n+    }\n }\n \n // When we want to suggest a user change a local variable to be a `&mut`, there\n@@ -1198,72 +1198,89 @@ fn suggest_ampmut_self<'tcx>(\n // by trying (3.), then (2.) and finally falling back on (1.).\n fn suggest_ampmut<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    local_decl: &mir::LocalDecl<'tcx>,\n+    decl_ty: Ty<'tcx>,\n+    decl_span: Span,\n     opt_assignment_rhs_span: Option<Span>,\n     opt_ty_info: Option<Span>,\n ) -> (bool, Span, String) {\n+    // if there is a RHS and it starts with a `&` from it, then check if it is\n+    // mutable, and if not, put suggest putting `mut ` to make it mutable.\n+    // we don't have to worry about lifetime annotations here because they are\n+    // not valid when taking a reference. For example, the following is not valid Rust:\n+    //\n+    // let x: &i32 = &'a 5;\n+    //                ^^ lifetime annotation not allowed\n+    //\n     if let Some(assignment_rhs_span) = opt_assignment_rhs_span\n         && let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span)\n+        && let Some(stripped) = src.strip_prefix('&')\n     {\n-        let is_mutbl = |ty: &str| -> bool {\n-            if let Some(rest) = ty.strip_prefix(\"mut\") {\n-                match rest.chars().next() {\n-                    // e.g. `&mut x`\n-                    Some(c) if c.is_whitespace() => true,\n-                    // e.g. `&mut(x)`\n-                    Some('(') => true,\n-                    // e.g. `&mut{x}`\n-                    Some('{') => true,\n-                    // e.g. `&mutablevar`\n-                    _ => false,\n-                }\n-            } else {\n-                false\n+        let is_mut = if let Some(rest) = stripped.trim_start().strip_prefix(\"mut\") {\n+            match rest.chars().next() {\n+                // e.g. `&mut x`\n+                Some(c) if c.is_whitespace() => true,\n+                // e.g. `&mut(x)`\n+                Some('(') => true,\n+                // e.g. `&mut{x}`\n+                Some('{') => true,\n+                // e.g. `&mutablevar`\n+                _ => false,\n             }\n+        } else {\n+            false\n         };\n-        if let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace)) {\n-            let lt_name = &src[1..ws_pos];\n-            let ty = src[ws_pos..].trim_start();\n-            if !is_mutbl(ty) {\n-                return (true, assignment_rhs_span, format!(\"&{lt_name} mut {ty}\"));\n-            }\n-        } else if let Some(stripped) = src.strip_prefix('&') {\n-            let stripped = stripped.trim_start();\n-            if !is_mutbl(stripped) {\n-                return (true, assignment_rhs_span, format!(\"&mut {stripped}\"));\n-            }\n+        // if the reference is already mutable then there is nothing we can do\n+        // here.\n+        if !is_mut {\n+            let span = assignment_rhs_span;\n+            // shrink the span to just after the `&` in `&variable`\n+            let span = span.with_lo(span.lo() + BytePos(1)).shrink_to_lo();\n+\n+            // FIXME(Ezrashaw): returning is bad because we still might want to\n+            // update the annotated type, see #106857.\n+            return (true, span, \"mut \".to_owned());\n         }\n     }\n \n-    let (suggestibility, highlight_span) = match opt_ty_info {\n+    let (binding_exists, span) = match opt_ty_info {\n         // if this is a variable binding with an explicit type,\n-        // try to highlight that for the suggestion.\n+        // then we will suggest changing it to be mutable.\n+        // this is `Applicability::MachineApplicable`.\n         Some(ty_span) => (true, ty_span),\n \n-        // otherwise, just highlight the span associated with\n-        // the (MIR) LocalDecl.\n-        None => (false, local_decl.source_info.span),\n+        // otherwise, we'll suggest *adding* an annotated type, we'll suggest\n+        // the RHS's type for that.\n+        // this is `Applicability::HasPlaceholders`.\n+        None => (false, decl_span),\n     };\n \n-    if let Ok(src) = tcx.sess.source_map().span_to_snippet(highlight_span)\n-        && let (true, Some(ws_pos)) = (src.starts_with(\"&'\"), src.find(char::is_whitespace))\n+    // if the binding already exists and is a reference with a explicit\n+    // lifetime, then we can suggest adding ` mut`. this is special-cased from\n+    // the path without a explicit lifetime.\n+    if let Ok(src) = tcx.sess.source_map().span_to_snippet(span)\n+        && src.starts_with(\"&'\")\n+        // note that `&     'a T` is invalid so this is correct.\n+        && let Some(ws_pos) = src.find(char::is_whitespace)\n     {\n-        let lt_name = &src[1..ws_pos];\n-        let ty = &src[ws_pos..];\n-        return (true, highlight_span, format!(\"&{lt_name} mut{ty}\"));\n-    }\n+        let span = span.with_lo(span.lo() + BytePos(ws_pos as u32)).shrink_to_lo();\n+        (true, span, \" mut\".to_owned())\n+    // if there is already a binding, we modify it to be `mut`\n+    } else if binding_exists {\n+        // shrink the span to just after the `&` in `&variable`\n+        let span = span.with_lo(span.lo() + BytePos(1)).shrink_to_lo();\n+        (true, span, \"mut \".to_owned())\n+    } else {\n+        // otherwise, suggest that the user annotates the binding; we provide the\n+        // type of the local.\n+        let ty_mut = decl_ty.builtin_deref(true).unwrap();\n+        assert_eq!(ty_mut.mutbl, hir::Mutability::Not);\n \n-    let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n-    assert_eq!(ty_mut.mutbl, hir::Mutability::Not);\n-    (\n-        suggestibility,\n-        highlight_span,\n-        if local_decl.ty.is_ref() {\n-            format!(\"&mut {}\", ty_mut.ty)\n-        } else {\n-            format!(\"*mut {}\", ty_mut.ty)\n-        },\n-    )\n+        (\n+            false,\n+            span,\n+            format!(\"{}mut {}\", if decl_ty.is_ref() {\"&\"} else {\"*\"}, ty_mut.ty)\n+        )\n+    }\n }\n \n fn is_closure_or_generator(ty: Ty<'_>) -> bool {\n@@ -1300,11 +1317,13 @@ fn get_mut_span_in_struct_field<'tcx>(\n }\n \n /// If possible, suggest replacing `ref` with `ref mut`.\n-fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<String> {\n-    let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).ok()?;\n-    if hi_src.starts_with(\"ref\") && hi_src[\"ref\".len()..].starts_with(rustc_lexer::is_whitespace) {\n-        let replacement = format!(\"ref mut{}\", &hi_src[\"ref\".len()..]);\n-        Some(replacement)\n+fn suggest_ref_mut(tcx: TyCtxt<'_>, span: Span) -> Option<Span> {\n+    let pattern_str = tcx.sess.source_map().span_to_snippet(span).ok()?;\n+    if pattern_str.starts_with(\"ref\")\n+        && pattern_str[\"ref\".len()..].starts_with(rustc_lexer::is_whitespace)\n+    {\n+        let span = span.with_lo(span.lo() + BytePos(4)).shrink_to_lo();\n+        Some(span)\n     } else {\n         None\n     }"}, {"sha": "3b458b1d30ba7f7d7996bc31d317b6298620798e", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -150,10 +150,6 @@ builtin_macros_format_pos_mismatch = {$n} positional {$n ->\n     *[more] arguments\n     } in format string, but {$desc}\n \n-builtin_macros_offset_of_expected_field = expected field\n-\n-builtin_macros_offset_of_expected_two_args = expected 2 arguments\n-\n builtin_macros_test_case_non_item = `#[test_case]` attribute is only allowed on items\n \n builtin_macros_test_bad_fn = {$kind} functions cannot be used for tests"}, {"sha": "4e5edb4d6b1dfd1906465a4a2c4d52168dca65b1", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -44,7 +44,6 @@ mod format;\n mod format_foreign;\n mod global_allocator;\n mod log_syntax;\n-mod offset_of;\n mod source_util;\n mod test;\n mod trace_macros;\n@@ -92,7 +91,6 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n         line: source_util::expand_line,\n         log_syntax: log_syntax::expand_log_syntax,\n         module_path: source_util::expand_mod,\n-        offset_of: offset_of::expand_offset_of,\n         option_env: env::expand_option_env,\n         core_panic: edition_panic::expand_panic,\n         std_panic: edition_panic::expand_panic,"}, {"sha": "0ef3e000e414c40c69fb87601320f8f07098957f", "filename": "compiler/rustc_builtin_macros/src/offset_of.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7e7483d26e3cec7a44ef00cf7ae6c9c8c918bec6/compiler%2Frustc_builtin_macros%2Fsrc%2Foffset_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7483d26e3cec7a44ef00cf7ae6c9c8c918bec6/compiler%2Frustc_builtin_macros%2Fsrc%2Foffset_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Foffset_of.rs?ref=7e7483d26e3cec7a44ef00cf7ae6c9c8c918bec6", "patch": "@@ -1,99 +0,0 @@\n-use rustc_ast as ast;\n-use rustc_ast::ptr::P;\n-use rustc_ast::token;\n-use rustc_ast::tokenstream::TokenStream;\n-use rustc_errors::PResult;\n-use rustc_expand::base::{self, *};\n-use rustc_macros::Diagnostic;\n-use rustc_parse::parser::Parser;\n-use rustc_span::{symbol::Ident, Span};\n-\n-#[derive(Diagnostic)]\n-#[diag(builtin_macros_offset_of_expected_field)]\n-struct ExpectedField {\n-    #[primary_span]\n-    span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(builtin_macros_offset_of_expected_two_args)]\n-struct ExpectedTwoArgs {\n-    #[primary_span]\n-    span: Span,\n-}\n-\n-fn parse_field<'a>(cx: &ExtCtxt<'a>, p: &mut Parser<'a>) -> PResult<'a, Ident> {\n-    let token = p.token.uninterpolate();\n-    let field = match token.kind {\n-        token::Ident(name, _) => Ident::new(name, token.span),\n-        token::Literal(token::Lit { kind: token::Integer, symbol, suffix: None }) => {\n-            Ident::new(symbol, token.span)\n-        }\n-        _ => return Err(cx.create_err(ExpectedField { span: p.token.span })),\n-    };\n-\n-    p.bump();\n-\n-    Ok(field)\n-}\n-\n-fn parse_args<'a>(\n-    cx: &mut ExtCtxt<'a>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> PResult<'a, (P<ast::Ty>, P<[Ident]>)> {\n-    let mut p = cx.new_parser_from_tts(tts);\n-\n-    let container = p.parse_ty()?;\n-\n-    p.expect(&token::Comma)?;\n-\n-    if p.eat(&token::Eof) {\n-        return Err(cx.create_err(ExpectedTwoArgs { span: sp }));\n-    }\n-\n-    let mut fields = Vec::new();\n-\n-    loop {\n-        let field = parse_field(cx, &mut p)?;\n-        fields.push(field);\n-\n-        if p.eat(&token::Dot) {\n-            continue;\n-        }\n-\n-        p.eat(&token::Comma);\n-\n-        if !p.eat(&token::Eof) {\n-            return Err(cx.create_err(ExpectedTwoArgs { span: sp }));\n-        }\n-\n-        break;\n-    }\n-\n-    Ok((container, fields.into()))\n-}\n-\n-pub fn expand_offset_of<'cx>(\n-    cx: &'cx mut ExtCtxt<'_>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Box<dyn base::MacResult + 'cx> {\n-    match parse_args(cx, sp, tts) {\n-        Ok((container, fields)) => {\n-            let expr = P(ast::Expr {\n-                id: ast::DUMMY_NODE_ID,\n-                kind: ast::ExprKind::OffsetOf(container, fields),\n-                span: sp,\n-                attrs: ast::AttrVec::new(),\n-                tokens: None,\n-            });\n-\n-            MacEager::expr(expr)\n-        }\n-        Err(mut err) => {\n-            err.emit();\n-            DummyResult::any(sp)\n-        }\n-    }\n-}"}, {"sha": "8968133bac5ba0cdf55b31f1d203736a146b7ef7", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -12,6 +12,7 @@ use object::{\n \n use snap::write::FrameEncoder;\n \n+use object::elf::NT_GNU_PROPERTY_TYPE_0;\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owned_slice::try_slice_owned;\n use rustc_data_structures::sync::MetadataRef;\n@@ -93,6 +94,54 @@ pub(super) fn search_for_section<'a>(\n         .map_err(|e| format!(\"failed to read {} section in '{}': {}\", section, path.display(), e))\n }\n \n+fn add_gnu_property_note(\n+    file: &mut write::Object<'static>,\n+    architecture: Architecture,\n+    binary_format: BinaryFormat,\n+    endianness: Endianness,\n+) {\n+    // check bti protection\n+    if binary_format != BinaryFormat::Elf\n+        || !matches!(architecture, Architecture::X86_64 | Architecture::Aarch64)\n+    {\n+        return;\n+    }\n+\n+    let section = file.add_section(\n+        file.segment_name(StandardSegment::Data).to_vec(),\n+        b\".note.gnu.property\".to_vec(),\n+        SectionKind::Note,\n+    );\n+    let mut data: Vec<u8> = Vec::new();\n+    let n_namsz: u32 = 4; // Size of the n_name field\n+    let n_descsz: u32 = 16; // Size of the n_desc field\n+    let n_type: u32 = NT_GNU_PROPERTY_TYPE_0; // Type of note descriptor\n+    let header_values = [n_namsz, n_descsz, n_type];\n+    header_values.iter().for_each(|v| {\n+        data.extend_from_slice(&match endianness {\n+            Endianness::Little => v.to_le_bytes(),\n+            Endianness::Big => v.to_be_bytes(),\n+        })\n+    });\n+    data.extend_from_slice(b\"GNU\\0\"); // Owner of the program property note\n+    let pr_type: u32 = match architecture {\n+        Architecture::X86_64 => 0xc0000002,\n+        Architecture::Aarch64 => 0xc0000000,\n+        _ => unreachable!(),\n+    };\n+    let pr_datasz: u32 = 4; //size of the pr_data field\n+    let pr_data: u32 = 3; //program property descriptor\n+    let pr_padding: u32 = 0;\n+    let property_values = [pr_type, pr_datasz, pr_data, pr_padding];\n+    property_values.iter().for_each(|v| {\n+        data.extend_from_slice(&match endianness {\n+            Endianness::Little => v.to_le_bytes(),\n+            Endianness::Big => v.to_be_bytes(),\n+        })\n+    });\n+    file.append_section_data(section, &data, 8);\n+}\n+\n pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static>> {\n     let endianness = match sess.target.options.endian {\n         Endian::Little => Endianness::Little,\n@@ -205,6 +254,7 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n         _ => elf::ELFOSABI_NONE,\n     };\n     let abi_version = 0;\n+    add_gnu_property_note(&mut file, architecture, binary_format, endianness);\n     file.flags = FileFlags::Elf { os_abi, abi_version, e_flags };\n     Some(file)\n }"}, {"sha": "311a42aa42a3d5f2cdbea48bbcd33fab2d32e299", "filename": "compiler/rustc_data_structures/src/owned_slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -109,9 +109,11 @@ impl Borrow<[u8]> for OwnedSlice {\n }\n \n // Safety: `OwnedSlice` is conceptually `(&'self.1 [u8], Box<dyn Send + Sync>)`, which is `Send`\n+#[cfg(parallel_compiler)]\n unsafe impl Send for OwnedSlice {}\n \n // Safety: `OwnedSlice` is conceptually `(&'self.1 [u8], Box<dyn Send + Sync>)`, which is `Sync`\n+#[cfg(parallel_compiler)]\n unsafe impl Sync for OwnedSlice {}\n \n #[cfg(test)]"}, {"sha": "f4615445f8e9bb6947cda99b803c5d2a3a767f17", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -313,6 +313,8 @@ declare_features! (\n     (active, async_closure, \"1.37.0\", Some(62290), None),\n     /// Allows async functions to be declared, implemented, and used in traits.\n     (active, async_fn_in_trait, \"1.66.0\", Some(91611), None),\n+    /// Allows builtin # foo() syntax\n+    (active, builtin_syntax, \"CURRENT_RUSTC_VERSION\", Some(110680), None),\n     /// Allows `c\"foo\"` literals.\n     (active, c_str_literals, \"CURRENT_RUSTC_VERSION\", Some(105723), None),\n     /// Treat `extern \"C\"` function as nounwind."}, {"sha": "5e5c984a7ea15e75d302c0c2373e70f9365b20c1", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -279,6 +279,9 @@ hir_analysis_specialization_trait = implementing `rustc_specialization_trait` tr\n hir_analysis_closure_implicit_hrtb = implicit types in closure signatures are forbidden when `for<...>` is present\n     .label = `for<...>` is here\n \n+hir_analysis_empty_specialization = specialization impl does not specialize any associated items\n+    .note = impl is a specialization of this impl\n+\n hir_analysis_const_specialize = cannot specialize on const impl with non-const impl\n \n hir_analysis_static_specialize = cannot specialize on `'static` lifetime"}, {"sha": "6e7eb4f6cdcd8eba1fc0cfbf8e3654a2126bb76e", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -814,6 +814,15 @@ pub(crate) struct ClosureImplicitHrtb {\n     pub for_sp: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_empty_specialization)]\n+pub(crate) struct EmptySpecialization {\n+    #[primary_span]\n+    pub span: Span,\n+    #[note]\n+    pub base_impl_span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(hir_analysis_const_specialize)]\n pub(crate) struct ConstSpecialize {"}, {"sha": "e84da2519ae812bce3b4a48c17dcb65948517ef5", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -80,7 +80,7 @@ use rustc_middle::ty::{self, TyCtxt, TypeVisitableExt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n-use rustc_trait_selection::traits::{self, translate_substs, wf, ObligationCtxt};\n+use rustc_trait_selection::traits::{self, translate_substs_with_cause, wf, ObligationCtxt};\n \n pub(super) fn check_min_specialization(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) {\n     if let Some(node) = parent_specialization_node(tcx, impl_def_id) {\n@@ -100,12 +100,19 @@ fn parent_specialization_node(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId) -> Opti\n         // Implementing a normal trait isn't a specialization.\n         return None;\n     }\n+    if trait_def.is_marker {\n+        // Overlapping marker implementations are not really specializations.\n+        return None;\n+    }\n     Some(impl2_node)\n }\n \n /// Check that `impl1` is a sound specialization\n #[instrument(level = \"debug\", skip(tcx))]\n fn check_always_applicable(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node) {\n+    let span = tcx.def_span(impl1_def_id);\n+    check_has_items(tcx, impl1_def_id, impl2_node, span);\n+\n     if let Some((impl1_substs, impl2_substs)) = get_impl_substs(tcx, impl1_def_id, impl2_node) {\n         let impl2_def_id = impl2_node.def_id();\n         debug!(?impl2_def_id, ?impl2_substs);\n@@ -116,14 +123,20 @@ fn check_always_applicable(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node\n             unconstrained_parent_impl_substs(tcx, impl2_def_id, impl2_substs)\n         };\n \n-        let span = tcx.def_span(impl1_def_id);\n         check_constness(tcx, impl1_def_id, impl2_node, span);\n         check_static_lifetimes(tcx, &parent_substs, span);\n         check_duplicate_params(tcx, impl1_substs, &parent_substs, span);\n         check_predicates(tcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n     }\n }\n \n+fn check_has_items(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node, span: Span) {\n+    if let Node::Impl(impl2_id) = impl2_node && tcx.associated_item_def_ids(impl1_def_id).is_empty() {\n+        let base_impl_span = tcx.def_span(impl2_id);\n+        tcx.sess.emit_err(errors::EmptySpecialization { span, base_impl_span });\n+    }\n+}\n+\n /// Check that the specializing impl `impl1` is at least as const as the base\n /// impl `impl2`\n fn check_constness(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node, span: Span) {\n@@ -167,8 +180,21 @@ fn get_impl_substs(\n         ocx.assumed_wf_types(param_env, tcx.def_span(impl1_def_id), impl1_def_id);\n \n     let impl1_substs = InternalSubsts::identity_for_item(tcx, impl1_def_id);\n-    let impl2_substs =\n-        translate_substs(infcx, param_env, impl1_def_id.to_def_id(), impl1_substs, impl2_node);\n+    let impl1_span = tcx.def_span(impl1_def_id);\n+    let impl2_substs = translate_substs_with_cause(\n+        infcx,\n+        param_env,\n+        impl1_def_id.to_def_id(),\n+        impl1_substs,\n+        impl2_node,\n+        |_, span| {\n+            traits::ObligationCause::new(\n+                impl1_span,\n+                impl1_def_id,\n+                traits::ObligationCauseCode::BindingObligation(impl2_node.def_id(), span),\n+            )\n+        },\n+    );\n \n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {"}, {"sha": "2defca54aff24ef697a7bb7fbd904fd3ddcd23f3", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 102, "deletions": 96, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -86,9 +86,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.emit_type_mismatch_suggestions(err, expr, expr_ty, expected, expected_ty_expr, error);\n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_internal_mutation_in_method(err, expr, Some(expected), expr_ty);\n-        self.check_for_range_as_method_call(err, expr, expr_ty, expected);\n-        self.check_for_binding_assigned_block_without_tail_expression(err, expr, expr_ty, expected);\n-        self.check_wrong_return_type_due_to_generic_arg(err, expr, expr_ty);\n+        self.suggest_method_call_on_range_literal(err, expr, expr_ty, expected);\n+        self.suggest_return_binding_for_missing_tail_expr(err, expr, expr_ty, expected);\n+        self.note_wrong_return_ty_due_to_generic_arg(err, expr, expr_ty);\n     }\n \n     /// Requires that the two types unify, and prints an error message if\n@@ -1087,7 +1087,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ```ignore (illustrative)\n     /// opt.map(|param| { takes_ref(param) });\n     /// ```\n-    fn can_use_as_ref(&self, expr: &hir::Expr<'_>) -> Option<(Span, &'static str, String)> {\n+    fn can_use_as_ref(&self, expr: &hir::Expr<'_>) -> Option<(Vec<(Span, String)>, &'static str)> {\n         let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind else {\n             return None;\n         };\n@@ -1133,12 +1133,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             _ => false,\n         };\n-        match (is_as_ref_able, self.sess().source_map().span_to_snippet(method_path.ident.span)) {\n-            (true, Ok(src)) => {\n-                let suggestion = format!(\"as_ref().{}\", src);\n-                Some((method_path.ident.span, \"consider using `as_ref` instead\", suggestion))\n-            }\n-            _ => None,\n+        if is_as_ref_able {\n+            Some((\n+                vec![(method_path.ident.span.shrink_to_lo(), \"as_ref().\".to_string())],\n+                \"consider using `as_ref` instead\",\n+            ))\n+        } else {\n+            None\n         }\n     }\n \n@@ -1217,14 +1218,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// In addition of this check, it also checks between references mutability state. If the\n     /// expected is mutable but the provided isn't, maybe we could just say \"Hey, try with\n     /// `&mut`!\".\n-    pub fn check_ref(\n+    pub fn suggest_deref_or_ref(\n         &self,\n         expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> Option<(\n-        Span,\n-        String,\n+        Vec<(Span, String)>,\n         String,\n         Applicability,\n         bool, /* verbose */\n@@ -1254,30 +1254,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         && let Ok(src) = sm.span_to_snippet(sp)\n                         && replace_prefix(&src, \"b\\\"\", \"\\\"\").is_some()\n                     {\n-                                let pos = sp.lo() + BytePos(1);\n-                                return Some((\n-                                    sp.with_hi(pos),\n-                                    \"consider removing the leading `b`\".to_string(),\n-                                    String::new(),\n-                                    Applicability::MachineApplicable,\n-                                    true,\n-                                    false,\n-                                ));\n-                            }\n-                        }\n+                        let pos = sp.lo() + BytePos(1);\n+                        return Some((\n+                            vec![(sp.with_hi(pos), String::new())],\n+                            \"consider removing the leading `b`\".to_string(),\n+                            Applicability::MachineApplicable,\n+                            true,\n+                            false,\n+                        ));\n+                    }\n+                }\n                 (&ty::Array(arr, _) | &ty::Slice(arr), &ty::Str) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.kind\n                         && let Ok(src) = sm.span_to_snippet(sp)\n                         && replace_prefix(&src, \"\\\"\", \"b\\\"\").is_some()\n                     {\n-                                return Some((\n-                                    sp.shrink_to_lo(),\n-                                    \"consider adding a leading `b`\".to_string(),\n-                                    \"b\".to_string(),\n-                                    Applicability::MachineApplicable,\n-                                    true,\n-                                    false,\n-                                ));\n+                        return Some((\n+                            vec![(sp.shrink_to_lo(), \"b\".to_string())],\n+                            \"consider adding a leading `b`\".to_string(),\n+                            Applicability::MachineApplicable,\n+                            true,\n+                            false,\n+                        ));\n                     }\n                 }\n                 _ => {}\n@@ -1320,66 +1318,73 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n \n                     if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner) = expr.kind\n-                        && let Some(1) = self.deref_steps(expected, checked_ty) {\n+                        && let Some(1) = self.deref_steps(expected, checked_ty)\n+                    {\n                         // We have `*&T`, check if what was expected was `&T`.\n                         // If so, we may want to suggest removing a `*`.\n                         sugg_sp = sugg_sp.with_hi(inner.span.lo());\n                         return Some((\n-                            sugg_sp,\n+                            vec![(sugg_sp, String::new())],\n                             \"consider removing deref here\".to_string(),\n-                            \"\".to_string(),\n                             Applicability::MachineApplicable,\n                             true,\n                             false,\n                         ));\n                     }\n \n-                    if let Ok(src) = sm.span_to_snippet(sugg_sp) {\n-                        let needs_parens = match expr.kind {\n-                            // parenthesize if needed (Issue #46756)\n-                            hir::ExprKind::Cast(_, _) | hir::ExprKind::Binary(_, _, _) => true,\n-                            // parenthesize borrows of range literals (Issue #54505)\n-                            _ if is_range_literal(expr) => true,\n-                            _ => false,\n-                        };\n-\n-                        if let Some(sugg) = self.can_use_as_ref(expr) {\n-                            return Some((\n-                                sugg.0,\n-                                sugg.1.to_string(),\n-                                sugg.2,\n-                                Applicability::MachineApplicable,\n-                                false,\n-                                false,\n-                            ));\n-                        }\n-\n-                        let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n-                            Some(ident) => format!(\"{ident}: \"),\n-                            None => String::new(),\n-                        };\n-\n-                        if let Some(hir::Node::Expr(hir::Expr {\n-                            kind: hir::ExprKind::Assign(..),\n-                            ..\n-                        })) = self.tcx.hir().find_parent(expr.hir_id)\n-                        {\n-                            if mutability.is_mut() {\n-                                // Suppressing this diagnostic, we'll properly print it in `check_expr_assign`\n-                                return None;\n-                            }\n-                        }\n+                    let needs_parens = match expr.kind {\n+                        // parenthesize if needed (Issue #46756)\n+                        hir::ExprKind::Cast(_, _) | hir::ExprKind::Binary(_, _, _) => true,\n+                        // parenthesize borrows of range literals (Issue #54505)\n+                        _ if is_range_literal(expr) => true,\n+                        _ => false,\n+                    };\n \n-                        let sugg_expr = if needs_parens { format!(\"({src})\") } else { src };\n+                    if let Some((sugg, msg)) = self.can_use_as_ref(expr) {\n                         return Some((\n-                            sp,\n-                            format!(\"consider {}borrowing here\", mutability.mutably_str()),\n-                            format!(\"{prefix}{}{sugg_expr}\", mutability.ref_prefix_str()),\n+                            sugg,\n+                            msg.to_string(),\n                             Applicability::MachineApplicable,\n-                            false,\n+                            true,\n                             false,\n                         ));\n                     }\n+\n+                    let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                        Some(ident) => format!(\"{ident}: \"),\n+                        None => String::new(),\n+                    };\n+\n+                    if let Some(hir::Node::Expr(hir::Expr {\n+                        kind: hir::ExprKind::Assign(..),\n+                        ..\n+                    })) = self.tcx.hir().find_parent(expr.hir_id)\n+                    {\n+                        if mutability.is_mut() {\n+                            // Suppressing this diagnostic, we'll properly print it in `check_expr_assign`\n+                            return None;\n+                        }\n+                    }\n+\n+                    let sugg = mutability.ref_prefix_str();\n+                    let (sugg, verbose) = if needs_parens {\n+                        (\n+                            vec![\n+                                (sp.shrink_to_lo(), format!(\"{prefix}{sugg}(\")),\n+                                (sp.shrink_to_hi(), \")\".to_string()),\n+                            ],\n+                            false,\n+                        )\n+                    } else {\n+                        (vec![(sp.shrink_to_lo(), format!(\"{prefix}{sugg}\"))], true)\n+                    };\n+                    return Some((\n+                        sugg,\n+                        format!(\"consider {}borrowing here\", mutability.mutably_str()),\n+                        Applicability::MachineApplicable,\n+                        verbose,\n+                        false,\n+                    ));\n                 }\n             }\n             (\n@@ -1401,23 +1406,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         && sm.is_span_accessible(call_span)\n                     {\n                         return Some((\n-                            sp.with_hi(call_span.lo()),\n+                            vec![(sp.with_hi(call_span.lo()), String::new())],\n                             \"consider removing the borrow\".to_string(),\n-                            String::new(),\n                             Applicability::MachineApplicable,\n                             true,\n-                            true\n+                            true,\n                         ));\n                     }\n                     return None;\n                 }\n-                if sp.contains(expr.span)\n-                    && sm.is_span_accessible(expr.span)\n-                {\n+                if sp.contains(expr.span) && sm.is_span_accessible(expr.span) {\n                     return Some((\n-                        sp.with_hi(expr.span.lo()),\n+                        vec![(sp.with_hi(expr.span.lo()), String::new())],\n                         \"consider removing the borrow\".to_string(),\n-                        String::new(),\n                         Applicability::MachineApplicable,\n                         true,\n                         true,\n@@ -1441,23 +1442,30 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     let suggestion = replace_prefix(&src, old_prefix, &new_prefix).map(|_| {\n                         // skip `&` or `&mut ` if both mutabilities are mutable\n-                        let lo = sp.lo() + BytePos(min(old_prefix.len(), mutbl_b.ref_prefix_str().len()) as _);\n+                        let lo = sp.lo()\n+                            + BytePos(min(old_prefix.len(), mutbl_b.ref_prefix_str().len()) as _);\n                         // skip `&` or `&mut `\n                         let hi = sp.lo() + BytePos(old_prefix.len() as _);\n                         let sp = sp.with_lo(lo).with_hi(hi);\n \n                         (\n                             sp,\n-                            format!(\"{}{derefs}\", if mutbl_a != mutbl_b { mutbl_b.prefix_str() } else { \"\" }),\n-                            if mutbl_b <= mutbl_a { Applicability::MachineApplicable } else { Applicability::MaybeIncorrect }\n+                            format!(\n+                                \"{}{derefs}\",\n+                                if mutbl_a != mutbl_b { mutbl_b.prefix_str() } else { \"\" }\n+                            ),\n+                            if mutbl_b <= mutbl_a {\n+                                Applicability::MachineApplicable\n+                            } else {\n+                                Applicability::MaybeIncorrect\n+                            },\n                         )\n                     });\n \n                     if let Some((span, src, applicability)) = suggestion {\n                         return Some((\n-                            span,\n+                            vec![(span, src)],\n                             \"consider dereferencing\".to_string(),\n-                            src,\n                             applicability,\n                             true,\n                             false,\n@@ -1486,9 +1494,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // If we've reached our target type with just removing `&`, then just print now.\n                     if steps == 0 && !remove.trim().is_empty() {\n                         return Some((\n-                            prefix_span,\n+                            vec![(prefix_span, String::new())],\n                             format!(\"consider removing the `{}`\", remove.trim()),\n-                            String::new(),\n                             // Do not remove `&&` to get to bool, because it might be something like\n                             // { a } && b, which we have a separate fixup suggestion that is more\n                             // likely correct...\n@@ -1554,9 +1561,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n \n                         return Some((\n-                            span,\n+                            vec![(span, suggestion)],\n                             message,\n-                            suggestion,\n                             Applicability::MachineApplicable,\n                             true,\n                             false,\n@@ -1569,7 +1575,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n-    pub fn check_for_cast(\n+    pub fn suggest_cast(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n@@ -1936,7 +1942,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Identify when the user has written `foo..bar()` instead of `foo.bar()`.\n-    pub fn check_for_range_as_method_call(\n+    pub fn suggest_method_call_on_range_literal(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'tcx>,\n@@ -2005,7 +2011,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Identify when the type error is because `()` is found in a binding that was assigned a\n     /// block without a tail expression.\n-    fn check_for_binding_assigned_block_without_tail_expression(\n+    fn suggest_return_binding_for_missing_tail_expr(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n@@ -2047,7 +2053,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_wrong_return_type_due_to_generic_arg(\n+    fn note_wrong_return_ty_due_to_generic_arg(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,"}, {"sha": "c4add4dbdfb2fb29038f464931cfe04bbabe71f1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -275,13 +275,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> bool {\n         let expr = expr.peel_blocks();\n-        if let Some((sp, msg, suggestion, applicability, verbose, annotation)) =\n-            self.check_ref(expr, found, expected)\n+        if let Some((suggestion, msg, applicability, verbose, annotation)) =\n+            self.suggest_deref_or_ref(expr, found, expected)\n         {\n             if verbose {\n-                err.span_suggestion_verbose(sp, msg, suggestion, applicability);\n+                err.multipart_suggestion_verbose(msg, suggestion, applicability);\n             } else {\n-                err.span_suggestion(sp, msg, suggestion, applicability);\n+                err.multipart_suggestion(msg, suggestion, applicability);\n             }\n             if annotation {\n                 let suggest_annotation = match expr.peel_drop_temps().kind {\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.span_label(sp, format!(\"{descr} `{name}` defined here\"));\n             }\n             return true;\n-        } else if self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n+        } else if self.suggest_cast(err, expr, found, expected, expected_ty_expr) {\n             return true;\n         } else {\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);"}, {"sha": "486c217707e78cced843d0c4cdb695af9d75efb1", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1045,7 +1045,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             );\n         }\n \n-        self.check_for_inner_self(&mut err, source, rcvr_ty, item_name);\n+        self.suggest_unwrapping_inner_self(&mut err, source, rcvr_ty, item_name);\n \n         bound_spans.sort();\n         bound_spans.dedup();\n@@ -1132,7 +1132,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        self.check_for_deref_method(&mut err, source, rcvr_ty, item_name, expected);\n+        self.note_derefed_ty_has_method(&mut err, source, rcvr_ty, item_name, expected);\n         return Some(err);\n     }\n \n@@ -1805,7 +1805,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_for_inner_self(\n+    fn suggest_unwrapping_inner_self(\n         &self,\n         err: &mut Diagnostic,\n         source: SelfSource<'tcx>,\n@@ -2175,7 +2175,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_for_deref_method(\n+    fn note_derefed_ty_has_method(\n         &self,\n         err: &mut Diagnostic,\n         self_source: SelfSource<'tcx>,"}, {"sha": "a536eb3b04e69e648ed9282d05b96c8e4db6c5b3", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -140,7 +140,7 @@ pub fn lint_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n /// ```fluent\n /// parser_expected_identifier = expected identifier\n ///\n-/// parser_expected_identifier-found = expected identifier, found {$found}\n+/// parser_expected_identifier_found = expected identifier, found {$found}\n ///\n /// parser_raw_identifier = escape `{$ident}` to use it as an identifier\n /// ```"}, {"sha": "f2841182a1a372aa537300b450e4cb06adc7b37a", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2728,8 +2728,6 @@ pub struct UserTypeProjection {\n     pub projs: Vec<ProjectionKind>,\n }\n \n-impl Copy for ProjectionKind {}\n-\n impl UserTypeProjection {\n     pub(crate) fn index(mut self) -> Self {\n         self.projs.push(ProjectionElem::Index(()));"}, {"sha": "1bbf833e3cdf5c7729c10577495f8c0eabeefb79", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -257,6 +257,10 @@ parse_invalid_literal_suffix_on_tuple_index = suffixes on a tuple index are inva\n     .tuple_exception_line_2 = on proc macros, you'll want to use `syn::Index::from` or `proc_macro::Literal::*_unsuffixed` for code that will desugar to tuple field access\n     .tuple_exception_line_3 = see issue #60210 <https://github.com/rust-lang/rust/issues/60210> for more information\n \n+parse_expected_builtin_ident = expected identifier after `builtin #`\n+\n+parse_unknown_builtin_construct = unknown `builtin #` construct `{$name}`\n+\n parse_non_string_abi_literal = non-string ABI literal\n     .suggestion = specify the ABI with a string literal\n \n@@ -339,6 +343,7 @@ parse_expected_identifier = expected identifier\n parse_sugg_escape_identifier = escape `{$ident_name}` to use it as an identifier\n \n parse_sugg_remove_comma = remove this comma\n+parse_sugg_add_let_for_stmt = you might have meant to introduce a new binding\n \n parse_expected_semi_found_reserved_identifier_str = expected `;`, found reserved identifier `{$token}`\n parse_expected_semi_found_keyword_str = expected `;`, found keyword `{$token}`"}, {"sha": "b6aeaf3d59f64d2475bdbe78ecb9d26987cfa23f", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -906,6 +906,18 @@ pub(crate) struct SuggRemoveComma {\n     pub span: Span,\n }\n \n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    parse_sugg_add_let_for_stmt,\n+    style = \"verbose\",\n+    applicability = \"maybe-incorrect\",\n+    code = \"let \"\n+)]\n+pub(crate) struct SuggAddMissingLetStmt {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n #[derive(Subdiagnostic)]\n pub(crate) enum ExpectedIdentifierFound {\n     #[label(parse_expected_identifier_found_reserved_identifier)]\n@@ -2644,3 +2656,18 @@ pub(crate) struct MalformedCfgAttr {\n     pub span: Span,\n     pub sugg: &'static str,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unknown_builtin_construct)]\n+pub(crate) struct UnknownBuiltinConstruct {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expected_builtin_ident)]\n+pub(crate) struct ExpectedBuiltinIdent {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "3002f23da75cca74f7938424a2c18afb071c53f0", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -13,7 +13,7 @@ use crate::errors::{\n     IncorrectUseOfAwait, ParenthesesInForHead, ParenthesesInForHeadSugg,\n     PatternMethodParamWithoutBody, QuestionMarkInType, QuestionMarkInTypeSugg, SelfParamNotFirst,\n     StructLiteralBodyWithoutPath, StructLiteralBodyWithoutPathSugg, StructLiteralNeedingParens,\n-    StructLiteralNeedingParensSugg, SuggEscapeIdentifier, SuggRemoveComma,\n+    StructLiteralNeedingParensSugg, SuggAddMissingLetStmt, SuggEscapeIdentifier, SuggRemoveComma,\n     UnexpectedConstInGenericParam, UnexpectedConstParamDeclaration,\n     UnexpectedConstParamDeclarationSugg, UnmatchedAngleBrackets, UseEqInstead,\n };\n@@ -32,8 +32,8 @@ use rustc_ast::{\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{\n-    pluralize, Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed,\n-    FatalError, Handler, IntoDiagnostic, MultiSpan, PResult,\n+    pluralize, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage,\n+    ErrorGuaranteed, FatalError, Handler, IntoDiagnostic, MultiSpan, PResult,\n };\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n@@ -1006,6 +1006,31 @@ impl<'a> Parser<'a> {\n         Err(e)\n     }\n \n+    /// Suggest add the missing `let` before the identifier in stmt\n+    /// `a: Ty = 1` -> `let a: Ty = 1`\n+    pub(super) fn suggest_add_missing_let_for_stmt(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'a, ErrorGuaranteed>,\n+    ) {\n+        if self.token == token::Colon {\n+            let prev_span = self.prev_token.span.shrink_to_lo();\n+            let snapshot = self.create_snapshot_for_diagnostic();\n+            self.bump();\n+            match self.parse_ty() {\n+                Ok(_) => {\n+                    if self.token == token::Eq {\n+                        let sugg = SuggAddMissingLetStmt { span: prev_span };\n+                        sugg.add_to_diagnostic(err);\n+                    }\n+                }\n+                Err(e) => {\n+                    e.cancel();\n+                }\n+            }\n+            self.restore_snapshot(snapshot);\n+        }\n+    }\n+\n     /// Check to see if a pair of chained operators looks like an attempt at chained comparison,\n     /// e.g. `1 < x <= 3`. If so, suggest either splitting the comparison into two, or\n     /// parenthesising the leftmost comparison."}, {"sha": "887e155426fa1b5fe8c52da7ca18925fdaae2109", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1300,6 +1300,8 @@ impl<'a> Parser<'a> {\n             })\n         } else if self.check(&token::OpenDelim(Delimiter::Bracket)) {\n             self.parse_expr_array_or_repeat(Delimiter::Bracket)\n+        } else if self.is_builtin() {\n+            self.parse_expr_builtin()\n         } else if self.check_path() {\n             self.parse_expr_path_start()\n         } else if self.check_keyword(kw::Move)\n@@ -1766,6 +1768,61 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n+    /// Parse `builtin # ident(args,*)`.\n+    fn parse_expr_builtin(&mut self) -> PResult<'a, P<Expr>> {\n+        self.parse_builtin(|this, lo, ident| {\n+            if ident.name == sym::offset_of {\n+                return Ok(Some(this.parse_expr_offset_of(lo)?));\n+            }\n+\n+            Ok(None)\n+        })\n+    }\n+\n+    pub(crate) fn parse_builtin<T>(\n+        &mut self,\n+        parse: impl FnOnce(&mut Parser<'a>, Span, Ident) -> PResult<'a, Option<T>>,\n+    ) -> PResult<'a, T> {\n+        let lo = self.token.span;\n+\n+        self.bump(); // `builtin`\n+        self.bump(); // `#`\n+\n+        let Some((ident, false)) = self.token.ident() else {\n+            let err = errors::ExpectedBuiltinIdent { span: self.token.span }\n+                .into_diagnostic(&self.sess.span_diagnostic);\n+            return Err(err);\n+        };\n+        self.sess.gated_spans.gate(sym::builtin_syntax, ident.span);\n+        self.bump();\n+\n+        self.expect(&TokenKind::OpenDelim(Delimiter::Parenthesis))?;\n+        let ret = if let Some(res) = parse(self, lo, ident)? {\n+            Ok(res)\n+        } else {\n+            let err = errors::UnknownBuiltinConstruct { span: lo.to(ident.span), name: ident.name }\n+                .into_diagnostic(&self.sess.span_diagnostic);\n+            return Err(err);\n+        };\n+        self.expect(&TokenKind::CloseDelim(Delimiter::Parenthesis))?;\n+\n+        ret\n+    }\n+\n+    pub(crate) fn parse_expr_offset_of(&mut self, lo: Span) -> PResult<'a, P<Expr>> {\n+        let container = self.parse_ty()?;\n+        self.expect(&TokenKind::Comma)?;\n+\n+        let seq_sep = SeqSep { sep: Some(token::Dot), trailing_sep_allowed: false };\n+        let (fields, _trailing, _recovered) = self.parse_seq_to_before_end(\n+            &TokenKind::CloseDelim(Delimiter::Parenthesis),\n+            seq_sep,\n+            Parser::parse_field_name,\n+        )?;\n+        let span = lo.to(self.token.span);\n+        Ok(self.mk_expr(span, ExprKind::OffsetOf(container, fields.to_vec().into())))\n+    }\n+\n     /// Returns a string literal if the next token is a string literal.\n     /// In case of error returns `Some(lit)` if the next token is a literal with a wrong kind,\n     /// and returns `None` if the next token is not literal at all.\n@@ -2835,6 +2892,10 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    pub(crate) fn is_builtin(&self) -> bool {\n+        self.token.is_keyword(kw::Builtin) && self.look_ahead(1, |t| *t == token::Pound)\n+    }\n+\n     /// Parses a `try {...}` expression (`try` token already eaten).\n     fn parse_try_block(&mut self, span_lo: Span) -> PResult<'a, P<Expr>> {\n         let (attrs, body) = self.parse_inner_attrs_and_block()?;"}, {"sha": "840cfe908997ffbfe55525fe4684d5b64066cf39", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -265,6 +265,9 @@ impl<'a> Parser<'a> {\n             // UNION ITEM\n             self.bump(); // `union`\n             self.parse_item_union()?\n+        } else if self.is_builtin() {\n+            // BUILTIN# ITEM\n+            return self.parse_item_builtin();\n         } else if self.eat_keyword(kw::Macro) {\n             // MACROS 2.0 ITEM\n             self.parse_item_decl_macro(lo)?\n@@ -434,6 +437,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn parse_item_builtin(&mut self) -> PResult<'a, Option<ItemInfo>> {\n+        // To be expanded\n+        return Ok(None);\n+    }\n+\n     /// Parses an item macro, e.g., `item!();`.\n     fn parse_item_macro(&mut self, vis: &Visibility) -> PResult<'a, MacCall> {\n         let path = self.parse_path(PathStyle::Mod)?; // `foo::bar`"}, {"sha": "03279124177e3e30d024e028aedf117d85bb7818", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -90,7 +90,11 @@ impl<'a> Parser<'a> {\n                 attrs,\n                 errors::InvalidVariableDeclarationSub::UseLetNotVar,\n             )?\n-        } else if self.check_path() && !self.token.is_qpath_start() && !self.is_path_start_item() {\n+        } else if self.check_path()\n+            && !self.token.is_qpath_start()\n+            && !self.is_path_start_item()\n+            && !self.is_builtin()\n+        {\n             // We have avoided contextual keywords like `union`, items with `crate` visibility,\n             // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n             // that starts like a path (1 token), but it fact not a path.\n@@ -99,7 +103,13 @@ impl<'a> Parser<'a> {\n                 ForceCollect::Yes => {\n                     self.collect_tokens_no_attrs(|this| this.parse_stmt_path_start(lo, attrs))?\n                 }\n-                ForceCollect::No => self.parse_stmt_path_start(lo, attrs)?,\n+                ForceCollect::No => match self.parse_stmt_path_start(lo, attrs) {\n+                    Ok(stmt) => stmt,\n+                    Err(mut err) => {\n+                        self.suggest_add_missing_let_for_stmt(&mut err);\n+                        return Err(err);\n+                    }\n+                },\n             }\n         } else if let Some(item) = self.parse_item_common(\n             attrs.clone(),\n@@ -555,7 +565,6 @@ impl<'a> Parser<'a> {\n                     if self.token == token::Colon {\n                         // if next token is following a colon, it's likely a path\n                         // and we can suggest a path separator\n-                        let ident_span = self.prev_token.span;\n                         self.bump();\n                         if self.token.span.lo() == self.prev_token.span.hi() {\n                             err.span_suggestion_verbose(\n@@ -565,14 +574,6 @@ impl<'a> Parser<'a> {\n                                 Applicability::MaybeIncorrect,\n                             );\n                         }\n-                        if self.look_ahead(1, |token| token == &token::Eq) {\n-                            err.span_suggestion_verbose(\n-                                ident_span.shrink_to_lo(),\n-                                \"you might have meant to introduce a new binding\",\n-                                \"let \",\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n                         if self.sess.unstable_features.is_nightly_build() {\n                             // FIXME(Nilstrieb): Remove this again after a few months.\n                             err.note(\"type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\");"}, {"sha": "117e2774bd87a3eda9f1f625a7cd89158e601fb0", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -95,6 +95,7 @@ symbols! {\n \n         // Weak keywords, have special meaning only in specific contexts.\n         Auto:               \"auto\",\n+        Builtin:            \"builtin\",\n         Catch:              \"catch\",\n         Default:            \"default\",\n         MacroRules:         \"macro_rules\",\n@@ -440,6 +441,7 @@ symbols! {\n         breakpoint,\n         bridge,\n         bswap,\n+        builtin_syntax,\n         c_str,\n         c_str_literals,\n         c_unwind,"}, {"sha": "969e5fa64b0b16c147be1844c63d153cf0fcdec5", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -322,7 +322,9 @@ fn negative_impl(tcx: TyCtxt<'_>, impl1_def_id: DefId, impl2_def_id: DefId) -> b\n     let selcx = &mut SelectionContext::new(&infcx);\n     let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n     let (subject2, obligations) =\n-        impl_subject_and_oblig(selcx, impl_env, impl2_def_id, impl2_substs);\n+        impl_subject_and_oblig(selcx, impl_env, impl2_def_id, impl2_substs, |_, _| {\n+            ObligationCause::dummy()\n+        });\n \n     !equate(&infcx, impl_env, subject1, subject2, obligations, impl1_def_id)\n }"}, {"sha": "38daca5377a8b88aff473a888b1ecee889eb6e65", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -55,7 +55,9 @@ pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n-pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n+pub use self::specialize::{\n+    specialization_graph, translate_substs, translate_substs_with_cause, OverlapError,\n+};\n pub use self::structural_match::{\n     search_for_adt_const_param_violation, search_for_structural_match_violation,\n };"}, {"sha": "9a4b72013b88db225fefd83ef8097b7e3b28965f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -82,6 +82,30 @@ pub fn translate_substs<'tcx>(\n     source_impl: DefId,\n     source_substs: SubstsRef<'tcx>,\n     target_node: specialization_graph::Node,\n+) -> SubstsRef<'tcx> {\n+    translate_substs_with_cause(\n+        infcx,\n+        param_env,\n+        source_impl,\n+        source_substs,\n+        target_node,\n+        |_, _| ObligationCause::dummy(),\n+    )\n+}\n+\n+/// Like [translate_substs], but obligations from the parent implementation\n+/// are registered with the provided `ObligationCause`.\n+///\n+/// This is for reporting *region* errors from those bounds. Type errors should\n+/// not happen because the specialization graph already checks for those, and\n+/// will result in an ICE.\n+pub fn translate_substs_with_cause<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    source_impl: DefId,\n+    source_substs: SubstsRef<'tcx>,\n+    target_node: specialization_graph::Node,\n+    cause: impl Fn(usize, Span) -> ObligationCause<'tcx>,\n ) -> SubstsRef<'tcx> {\n     debug!(\n         \"translate_substs({:?}, {:?}, {:?}, {:?})\",\n@@ -99,14 +123,13 @@ pub fn translate_substs<'tcx>(\n                 return source_substs;\n             }\n \n-            fulfill_implication(infcx, param_env, source_trait_ref, target_impl).unwrap_or_else(\n-                |()| {\n+            fulfill_implication(infcx, param_env, source_trait_ref, source_impl, target_impl, cause)\n+                .unwrap_or_else(|()| {\n                     bug!(\n                         \"When translating substitutions from {source_impl:?} to {target_impl:?}, \\\n                         the expected specialization failed to hold\"\n                     )\n-                },\n-            )\n+                })\n         }\n         specialization_graph::Node::Trait(..) => source_trait_ref.substs,\n     };\n@@ -153,20 +176,12 @@ pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId,\n \n     // Create an infcx, taking the predicates of impl1 as assumptions:\n     let infcx = tcx.infer_ctxt().build();\n-    let impl1_trait_ref =\n-        match traits::fully_normalize(&infcx, ObligationCause::dummy(), penv, impl1_trait_ref) {\n-            Ok(impl1_trait_ref) => impl1_trait_ref,\n-            Err(_errors) => {\n-                tcx.sess.delay_span_bug(\n-                    tcx.def_span(impl1_def_id),\n-                    format!(\"failed to fully normalize {impl1_trait_ref}\"),\n-                );\n-                impl1_trait_ref\n-            }\n-        };\n \n     // Attempt to prove that impl2 applies, given all of the above.\n-    fulfill_implication(&infcx, penv, impl1_trait_ref, impl2_def_id).is_ok()\n+    fulfill_implication(&infcx, penv, impl1_trait_ref, impl1_def_id, impl2_def_id, |_, _| {\n+        ObligationCause::dummy()\n+    })\n+    .is_ok()\n }\n \n /// Attempt to fulfill all obligations of `target_impl` after unification with\n@@ -178,23 +193,41 @@ fn fulfill_implication<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     source_trait_ref: ty::TraitRef<'tcx>,\n+    source_impl: DefId,\n     target_impl: DefId,\n+    error_cause: impl Fn(usize, Span) -> ObligationCause<'tcx>,\n ) -> Result<SubstsRef<'tcx>, ()> {\n     debug!(\n         \"fulfill_implication({:?}, trait_ref={:?} |- {:?} applies)\",\n         param_env, source_trait_ref, target_impl\n     );\n \n+    let source_trait_ref = match traits::fully_normalize(\n+        &infcx,\n+        ObligationCause::dummy(),\n+        param_env,\n+        source_trait_ref,\n+    ) {\n+        Ok(source_trait_ref) => source_trait_ref,\n+        Err(_errors) => {\n+            infcx.tcx.sess.delay_span_bug(\n+                infcx.tcx.def_span(source_impl),\n+                format!(\"failed to fully normalize {source_trait_ref}\"),\n+            );\n+            source_trait_ref\n+        }\n+    };\n+\n     let source_trait = ImplSubject::Trait(source_trait_ref);\n \n     let selcx = &mut SelectionContext::new(&infcx);\n     let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n     let (target_trait, obligations) =\n-        util::impl_subject_and_oblig(selcx, param_env, target_impl, target_substs);\n+        util::impl_subject_and_oblig(selcx, param_env, target_impl, target_substs, error_cause);\n \n     // do the impls unify? If not, no specialization.\n     let Ok(InferOk { obligations: more_obligations, .. }) =\n-        infcx.at(&ObligationCause::dummy(), param_env, ).eq(DefineOpaqueTypes::No,source_trait, target_trait)\n+        infcx.at(&ObligationCause::dummy(), param_env).eq(DefineOpaqueTypes::No, source_trait, target_trait)\n     else {\n         debug!(\n             \"fulfill_implication: {:?} does not unify with {:?}\","}, {"sha": "82f3df401988dc94a4f43f766e8aa5d63d9d7c88", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -197,6 +197,7 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     impl_def_id: DefId,\n     impl_substs: SubstsRef<'tcx>,\n+    cause: impl Fn(usize, Span) -> ObligationCause<'tcx>,\n ) -> (ImplSubject<'tcx>, impl Iterator<Item = PredicateObligation<'tcx>>) {\n     let subject = selcx.tcx().impl_subject(impl_def_id);\n     let subject = subject.subst(selcx.tcx(), impl_substs);\n@@ -208,8 +209,7 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n     let InferOk { value: predicates, obligations: normalization_obligations2 } =\n         selcx.infcx.at(&ObligationCause::dummy(), param_env).normalize(predicates);\n-    let impl_obligations =\n-        super::predicates_for_generics(|_, _| ObligationCause::dummy(), param_env, predicates);\n+    let impl_obligations = super::predicates_for_generics(cause, param_env, predicates);\n \n     let impl_obligations = impl_obligations\n         .chain(normalization_obligations1.into_iter())"}, {"sha": "4913a6de918286ae24820d42c2df0eaaa4cb66b0", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1315,9 +1315,9 @@ impl<T> SizedTypeProperties for T {}\n ///\n /// assert_eq!(mem::offset_of!(NestedA, b.0), 0);\n /// ```\n-#[unstable(feature = \"offset_of\", issue = \"106655\")]\n-#[rustc_builtin_macro]\n #[cfg(not(bootstrap))]\n+#[unstable(feature = \"offset_of\", issue = \"106655\")]\n+#[allow_internal_unstable(builtin_syntax)]\n pub macro offset_of($Container:ty, $($fields:tt).+ $(,)?) {\n-    /* compiler built-in */\n+    builtin # offset_of($Container, $($fields).+)\n }"}, {"sha": "f63e578b92ff43e8cc38fcaa257b660f45c8a8c2", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1 +1 @@\n-Subproject commit 6038be9d37d7251c966b486154af621d1794d7af\n+Subproject commit f63e578b92ff43e8cc38fcaa257b660f45c8a8c2"}, {"sha": "d9eb4c3f75435b008881062ffa77bf0d1527b37d", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1 +1 @@\n-Subproject commit 897fcf566f16bf87bf37199bdddec1801fd00532\n+Subproject commit d9eb4c3f75435b008881062ffa77bf0d1527b37d"}, {"sha": "28dc0f3576b55f5e57c5d6e65cd68ba3161e9fd5", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1 +1 @@\n-Subproject commit 1f8dc727e94ae4ef92adf70df979521a1ea1143e\n+Subproject commit 28dc0f3576b55f5e57c5d6e65cd68ba3161e9fd5"}, {"sha": "8ee9528b72b927cff8fd32346db8bbd1198816f0", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1 +1 @@\n-Subproject commit 31961fe22521a779070a44a8f30a2b00a20b6212\n+Subproject commit 8ee9528b72b927cff8fd32346db8bbd1198816f0"}, {"sha": "28dbeaf5c44bc7f5111ad412e99f2d7c5cec6c90", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1 +1 @@\n-Subproject commit 2a5eb92197e9cf8fe91164dcbf4f9b88c0d7e73d\n+Subproject commit 28dbeaf5c44bc7f5111ad412e99f2d7c5cec6c90"}, {"sha": "e3757941c8cd179ab2a987b88fd8f7c056fdc8a1", "filename": "tests/mir-opt/const_prop/offset_of.concrete.ConstProp.diff", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fmir-opt%2Fconst_prop%2Foffset_of.concrete.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fmir-opt%2Fconst_prop%2Foffset_of.concrete.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Foffset_of.concrete.ConstProp.diff?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -22,17 +22,17 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/offset_of.rs:+1:9: +1:10\n--         _1 = OffsetOf(Alpha, [0]);       // scope 0 at $DIR/offset_of.rs:+1:13: +1:33\n-+         _1 = const 4_usize;              // scope 0 at $DIR/offset_of.rs:+1:13: +1:33\n+-         _1 = OffsetOf(Alpha, [0]);       // scope 0 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n++         _1 = const 4_usize;              // scope 0 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           StorageLive(_2);                 // scope 1 at $DIR/offset_of.rs:+2:9: +2:10\n--         _2 = OffsetOf(Alpha, [1]);       // scope 1 at $DIR/offset_of.rs:+2:13: +2:33\n-+         _2 = const 0_usize;              // scope 1 at $DIR/offset_of.rs:+2:13: +2:33\n+-         _2 = OffsetOf(Alpha, [1]);       // scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n++         _2 = const 0_usize;              // scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           StorageLive(_3);                 // scope 2 at $DIR/offset_of.rs:+3:9: +3:11\n--         _3 = OffsetOf(Alpha, [2, 0]);    // scope 2 at $DIR/offset_of.rs:+3:14: +3:36\n-+         _3 = const 2_usize;              // scope 2 at $DIR/offset_of.rs:+3:14: +3:36\n+-         _3 = OffsetOf(Alpha, [2, 0]);    // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n++         _3 = const 2_usize;              // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           StorageLive(_4);                 // scope 3 at $DIR/offset_of.rs:+4:9: +4:11\n--         _4 = OffsetOf(Alpha, [2, 1]);    // scope 3 at $DIR/offset_of.rs:+4:14: +4:36\n-+         _4 = const 3_usize;              // scope 3 at $DIR/offset_of.rs:+4:14: +4:36\n+-         _4 = OffsetOf(Alpha, [2, 1]);    // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n++         _4 = const 3_usize;              // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           _0 = const ();                   // scope 0 at $DIR/offset_of.rs:+0:15: +5:2\n           StorageDead(_4);                 // scope 3 at $DIR/offset_of.rs:+5:1: +5:2\n           StorageDead(_3);                 // scope 2 at $DIR/offset_of.rs:+5:1: +5:2"}, {"sha": "4a655604cd183076de1d50e7c389553dba194f15", "filename": "tests/mir-opt/const_prop/offset_of.generic.ConstProp.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fmir-opt%2Fconst_prop%2Foffset_of.generic.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fmir-opt%2Fconst_prop%2Foffset_of.generic.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Foffset_of.generic.ConstProp.diff?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -22,13 +22,13 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/offset_of.rs:+1:9: +1:11\n-          _1 = OffsetOf(Gamma<T>, [0]);    // scope 0 at $DIR/offset_of.rs:+1:14: +1:37\n+          _1 = OffsetOf(Gamma<T>, [0]);    // scope 0 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           StorageLive(_2);                 // scope 1 at $DIR/offset_of.rs:+2:9: +2:11\n-          _2 = OffsetOf(Gamma<T>, [1]);    // scope 1 at $DIR/offset_of.rs:+2:14: +2:37\n+          _2 = OffsetOf(Gamma<T>, [1]);    // scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           StorageLive(_3);                 // scope 2 at $DIR/offset_of.rs:+3:9: +3:11\n-          _3 = OffsetOf(Delta<T>, [1]);    // scope 2 at $DIR/offset_of.rs:+3:14: +3:37\n+          _3 = OffsetOf(Delta<T>, [1]);    // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           StorageLive(_4);                 // scope 3 at $DIR/offset_of.rs:+4:9: +4:11\n-          _4 = OffsetOf(Delta<T>, [2]);    // scope 3 at $DIR/offset_of.rs:+4:14: +4:37\n+          _4 = OffsetOf(Delta<T>, [2]);    // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           _0 = const ();                   // scope 0 at $DIR/offset_of.rs:+0:17: +5:2\n           StorageDead(_4);                 // scope 3 at $DIR/offset_of.rs:+5:1: +5:2\n           StorageDead(_3);                 // scope 2 at $DIR/offset_of.rs:+5:1: +5:2"}, {"sha": "cabe951e1c5cb2d5cbb1fbdb6d3b91e158977b8e", "filename": "tests/run-make/branch-protection-check-IBT/Makefile", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Frun-make%2Fbranch-protection-check-IBT%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Frun-make%2Fbranch-protection-check-IBT%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fbranch-protection-check-IBT%2FMakefile?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,15 @@\n+# Check for GNU Property Note\n+\n+include ../tools.mk\n+\n+# How to run this\n+# python3 x.py test --target x86_64-unknown-linux-gnu  tests/run-make/branch-protection-check-IBT/\n+\n+# only-x86_64\n+\n+all:\n+ifeq ($(filter x86,$(LLVM_COMPONENTS)),x86_64)\n+\t$(RUSTC) --target x86_64-unknown-linux-gnu -Z cf-protection=branch -L$(TMPDIR) -C link-args='-nostartfiles'  -C save-temps  ./main.rs -o $(TMPDIR)/rsmain\n+\t readelf -nW $(TMPDIR)/rsmain | $(CGREP) -e \".note.gnu.property\"\n+endif\n+"}, {"sha": "ad379d6ea4373eab048e758c128f99477cb6c8a8", "filename": "tests/run-make/branch-protection-check-IBT/main.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Frun-make%2Fbranch-protection-check-IBT%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Frun-make%2Fbranch-protection-check-IBT%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fbranch-protection-check-IBT%2Fmain.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    println!(\"hello world\");\n+}"}, {"sha": "082564fbc7f889bd6f9273d29faca5dcbc53ff60", "filename": "tests/ui/argument-suggestions/issue-97484.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fargument-suggestions%2Fissue-97484.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fargument-suggestions%2Fissue-97484.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fargument-suggestions%2Fissue-97484.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -16,7 +16,7 @@ LL | fn foo(a: &A, d: D, e: &E, g: G) {}\n help: consider borrowing here\n    |\n LL |     foo(&&A, B, C, D, &E, F, G);\n-   |                       ~~\n+   |                       +\n help: remove the extra arguments\n    |\n LL -     foo(&&A, B, C, D, E, F, G);"}, {"sha": "c33919c41cdc2c2d6bc7becb74ba5912675b2511", "filename": "tests/ui/array-slice-vec/slice-mut-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Farray-slice-vec%2Fslice-mut-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Farray-slice-vec%2Fslice-mut-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farray-slice-vec%2Fslice-mut-2.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |     let _ = &mut x[2..4];\n help: consider changing this to be a mutable reference\n    |\n LL |     let x: &[isize] = &mut [1, 2, 3, 4, 5];\n-   |                       ~~~~~~~~~~~~~~~~~~~~\n+   |                        +++\n \n error: aborting due to previous error\n "}, {"sha": "cd84505680514abe4cffb3ea97267d0a4b655304", "filename": "tests/ui/async-await/issues/issue-102206.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fasync-await%2Fissues%2Fissue-102206.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fasync-await%2Fissues%2Fissue-102206.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fissues%2Fissue-102206.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,14 +2,16 @@ error[E0308]: mismatched types\n   --> $DIR/issue-102206.rs:6:27\n    |\n LL |     std::mem::size_of_val(foo());\n-   |     --------------------- ^^^^^\n-   |     |                     |\n-   |     |                     expected `&_`, found future\n-   |     |                     help: consider borrowing here: `&foo()`\n+   |     --------------------- ^^^^^ expected `&_`, found future\n+   |     |\n    |     arguments to this function are incorrect\n    |\n note: function defined here\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+help: consider borrowing here\n+   |\n+LL |     std::mem::size_of_val(&foo());\n+   |                           +\n \n error: aborting due to previous error\n "}, {"sha": "cfc86ff0dc1216d2b274522b561ffd6dc6af453c", "filename": "tests/ui/borrowck/borrow-raw-address-of-deref-mutability.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrow-raw-address-of-deref-mutability.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |     let q = &raw mut *x;\n help: consider changing this to be a mutable reference\n    |\n LL |     let x = &mut 0;\n-   |             ~~~~~~\n+   |              +++\n \n error[E0596]: cannot borrow `*x` as mutable, as it is behind a `*const` pointer\n   --> $DIR/borrow-raw-address-of-deref-mutability.rs:14:13\n@@ -18,7 +18,7 @@ LL |     let q = &raw mut *x;\n help: consider changing this to be a mutable pointer\n    |\n LL |     let x = &mut 0 as *const i32;\n-   |             ~~~~~~\n+   |              +++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c161e2d95b43a06b0a1c62657c501e5449c65238", "filename": "tests/ui/borrowck/borrowck-access-permissions.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fborrowck-access-permissions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fborrowck-access-permissions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-access-permissions.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -35,7 +35,7 @@ LL |         let _y1 = &mut *ref_x;\n help: consider changing this to be a mutable reference\n    |\n LL |         let ref_x = &mut x;\n-   |                     ~~~~~~\n+   |                      +++\n \n error[E0596]: cannot borrow `*ptr_x` as mutable, as it is behind a `*const` pointer\n   --> $DIR/borrowck-access-permissions.rs:39:23\n@@ -46,7 +46,7 @@ LL |             let _y1 = &mut *ptr_x;\n help: consider changing this to be a mutable pointer\n    |\n LL |         let ptr_x : *const _ = &mut x;\n-   |                                ~~~~~~\n+   |                                 +++\n \n error[E0596]: cannot borrow `*foo_ref.f` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-access-permissions.rs:48:18\n@@ -57,7 +57,7 @@ LL |         let _y = &mut *foo_ref.f;\n help: consider changing this to be a mutable reference\n    |\n LL |         let foo_ref = &mut foo;\n-   |                       ~~~~~~~~\n+   |                        +++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "cf0c4127d82f43dfa8fbf2c5eeebb794fa930a30", "filename": "tests/ui/borrowck/borrowck-assign-to-andmut-in-aliasable-loc.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fborrowck-assign-to-andmut-in-aliasable-loc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fborrowck-assign-to-andmut-in-aliasable-loc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-assign-to-andmut-in-aliasable-loc.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -6,8 +6,8 @@ LL |     *s.pointer += 1;\n    |\n help: consider changing this to be a mutable reference\n    |\n-LL | fn a(s: &mut S<'_>) {\n-   |         ~~~~~~~~~~\n+LL | fn a(s: &mut S) {\n+   |          +++\n \n error[E0594]: cannot assign to `*s.pointer`, which is behind a `&` reference\n   --> $DIR/borrowck-assign-to-andmut-in-aliasable-loc.rs:17:5\n@@ -17,8 +17,8 @@ LL |     *s.pointer += 1;\n    |\n help: consider changing this to be a mutable reference\n    |\n-LL | fn c(s: &mut &mut S<'_>) {\n-   |         ~~~~~~~~~~~~~~~\n+LL | fn c(s: &mut  &mut S) {\n+   |          +++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "59ef61b19d50136390e60ca965ca8bc1208e6ecb", "filename": "tests/ui/borrowck/borrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -27,8 +27,8 @@ LL |     let x:  &mut isize = &mut **t0;\n    |\n help: consider changing this to be a mutable reference\n    |\n-LL | fn foo4(t0: &mut &mut isize) {\n-   |             ~~~~~~~~~~~~~~~\n+LL | fn foo4(t0: &mut  &mut isize) {\n+   |              +++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "12d67d536d951e1e64d282a7bd27c24080826b3a", "filename": "tests/ui/borrowck/borrowck-issue-14498.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fborrowck-issue-14498.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fborrowck-issue-14498.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-issue-14498.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |     ***p = 2;\n help: consider changing this to be a mutable reference\n    |\n LL |     let p = &mut y;\n-   |             ~~~~~~\n+   |              +++\n \n error[E0506]: cannot assign to `**y` because it is borrowed\n   --> $DIR/borrowck-issue-14498.rs:25:5"}, {"sha": "fb3db4e144635eba623865f27caeb01c16aafd77", "filename": "tests/ui/borrowck/borrowck-reborrow-from-mut.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fborrowck-reborrow-from-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fborrowck-reborrow-from-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-reborrow-from-mut.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -111,7 +111,7 @@ LL |     let _bar1 = &mut foo.bar1;\n help: consider changing this to be a mutable reference\n    |\n LL | fn borrow_mut_from_imm(foo: &mut Foo) {\n-   |                             ~~~~~~~~\n+   |                              +++\n \n error: aborting due to 11 previous errors\n "}, {"sha": "2985a658fddbef1504673c48d64ee97f9fb1d1ac", "filename": "tests/ui/borrowck/issue-85765.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fissue-85765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fissue-85765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-85765.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -18,7 +18,7 @@ LL |     *r = 0;\n help: consider changing this to be a mutable reference\n    |\n LL |     let r = &mut mutvar;\n-   |             ~~~~~~~~~~~\n+   |              +++\n \n error[E0594]: cannot assign to `*x`, which is behind a `&` reference\n   --> $DIR/issue-85765.rs:19:5"}, {"sha": "b39e57d70ec65d75b2804a134ef72007cd1b3c69", "filename": "tests/ui/borrowck/mutability-errors.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fmutability-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fborrowck%2Fmutability-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fmutability-errors.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |     *x = (1,);\n help: consider changing this to be a mutable reference\n    |\n LL | fn named_ref(x: &mut (i32,)) {\n-   |                 ~~~~~~~~~~~\n+   |                  +++\n \n error[E0594]: cannot assign to `x.0`, which is behind a `&` reference\n   --> $DIR/mutability-errors.rs:10:5\n@@ -18,7 +18,7 @@ LL |     x.0 = 1;\n help: consider changing this to be a mutable reference\n    |\n LL | fn named_ref(x: &mut (i32,)) {\n-   |                 ~~~~~~~~~~~\n+   |                  +++\n \n error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/mutability-errors.rs:11:5\n@@ -29,7 +29,7 @@ LL |     &mut *x;\n help: consider changing this to be a mutable reference\n    |\n LL | fn named_ref(x: &mut (i32,)) {\n-   |                 ~~~~~~~~~~~\n+   |                  +++\n \n error[E0596]: cannot borrow `x.0` as mutable, as it is behind a `&` reference\n   --> $DIR/mutability-errors.rs:12:5\n@@ -40,7 +40,7 @@ LL |     &mut x.0;\n help: consider changing this to be a mutable reference\n    |\n LL | fn named_ref(x: &mut (i32,)) {\n-   |                 ~~~~~~~~~~~\n+   |                  +++\n \n error[E0594]: cannot assign to data in a `&` reference\n   --> $DIR/mutability-errors.rs:16:5\n@@ -74,8 +74,8 @@ LL |     *x = (1,);\n    |\n help: consider changing this to be a mutable pointer\n    |\n-LL | unsafe fn named_ptr(x: *mut (i32,)) {\n-   |                        ~~~~~~~~~~~\n+LL | unsafe fn named_ptr(x: *mut const (i32,)) {\n+   |                         +++\n \n error[E0594]: cannot assign to `x.0`, which is behind a `*const` pointer\n   --> $DIR/mutability-errors.rs:24:5\n@@ -85,8 +85,8 @@ LL |     (*x).0 = 1;\n    |\n help: consider changing this to be a mutable pointer\n    |\n-LL | unsafe fn named_ptr(x: *mut (i32,)) {\n-   |                        ~~~~~~~~~~~\n+LL | unsafe fn named_ptr(x: *mut const (i32,)) {\n+   |                         +++\n \n error[E0596]: cannot borrow `*x` as mutable, as it is behind a `*const` pointer\n   --> $DIR/mutability-errors.rs:25:5\n@@ -96,8 +96,8 @@ LL |     &mut *x;\n    |\n help: consider changing this to be a mutable pointer\n    |\n-LL | unsafe fn named_ptr(x: *mut (i32,)) {\n-   |                        ~~~~~~~~~~~\n+LL | unsafe fn named_ptr(x: *mut const (i32,)) {\n+   |                         +++\n \n error[E0596]: cannot borrow `x.0` as mutable, as it is behind a `*const` pointer\n   --> $DIR/mutability-errors.rs:26:5\n@@ -107,8 +107,8 @@ LL |     &mut (*x).0;\n    |\n help: consider changing this to be a mutable pointer\n    |\n-LL | unsafe fn named_ptr(x: *mut (i32,)) {\n-   |                        ~~~~~~~~~~~\n+LL | unsafe fn named_ptr(x: *mut const (i32,)) {\n+   |                         +++\n \n error[E0594]: cannot assign to data in a `*const` pointer\n   --> $DIR/mutability-errors.rs:30:5"}, {"sha": "1904faa959861962f2718ab016dea159a84c1afa", "filename": "tests/ui/closures/2229_closure_analysis/diagnostics/mut_ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -10,7 +10,7 @@ LL |         **ref_mref_x = y;\n help: consider changing this to be a mutable reference\n    |\n LL |     let ref_mref_x = &mut mref_x;\n-   |                      ~~~~~~~~~~~\n+   |                       +++\n \n error[E0596]: cannot borrow `**mref_ref_x` as mutable, as it is behind a `&` reference\n   --> $DIR/mut_ref.rs:26:13"}, {"sha": "17bbca7a0bdb6d385b703f22a6feced6f82248fb", "filename": "tests/ui/coercion/coercion-slice.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fcoercion%2Fcoercion-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fcoercion%2Fcoercion-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoercion%2Fcoercion-slice.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,11 +2,14 @@ error[E0308]: mismatched types\n   --> $DIR/coercion-slice.rs:4:21\n    |\n LL |     let _: &[i32] = [0];\n-   |            ------   ^^^\n-   |            |        |\n-   |            |        expected `&[i32]`, found `[{integer}; 1]`\n-   |            |        help: consider borrowing here: `&[0]`\n+   |            ------   ^^^ expected `&[i32]`, found `[{integer}; 1]`\n+   |            |\n    |            expected due to this\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let _: &[i32] = &[0];\n+   |                     +\n \n error: aborting due to previous error\n "}, {"sha": "43647fa562b9a38465a530f694036c0847c6f704", "filename": "tests/ui/did_you_mean/issue-38147-4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fdid_you_mean%2Fissue-38147-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fdid_you_mean%2Fissue-38147-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fissue-38147-4.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -6,8 +6,8 @@ LL |     f.s.push('x');\n    |\n help: consider changing this to be a mutable reference\n    |\n-LL | fn f(x: usize, f: &mut Foo<'_>) {\n-   |                   ~~~~~~~~~~~~\n+LL | fn f(x: usize, f: &mut Foo) {\n+   |                    +++\n \n error: aborting due to previous error\n "}, {"sha": "8ccb4cbb0c1672d03b2228d7743e6a3413bdeab0", "filename": "tests/ui/did_you_mean/issue-39544.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fissue-39544.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -40,7 +40,7 @@ LL |         let _ = &mut other.x;\n help: consider changing this to be a mutable reference\n    |\n LL |     fn foo1(&self, other: &mut Z) {\n-   |                           ~~~~~~\n+   |                            +++\n \n error[E0596]: cannot borrow `self.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:25:17\n@@ -62,7 +62,7 @@ LL |         let _ = &mut other.x;\n help: consider changing this to be a mutable reference\n    |\n LL |     fn foo2<'a>(&'a self, other: &mut Z) {\n-   |                                  ~~~~~~\n+   |                                   +++\n \n error[E0596]: cannot borrow `self.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:30:17\n@@ -73,7 +73,7 @@ LL |         let _ = &mut self.x;\n help: consider changing this to be a mutable reference\n    |\n LL |     fn foo3<'a>(self: &'a mut Self, other: &Z) {\n-   |                       ~~~~~~~~~~~~\n+   |                           +++\n \n error[E0596]: cannot borrow `other.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:31:17\n@@ -84,7 +84,7 @@ LL |         let _ = &mut other.x;\n help: consider changing this to be a mutable reference\n    |\n LL |     fn foo3<'a>(self: &'a Self, other: &mut Z) {\n-   |                                        ~~~~~~\n+   |                                         +++\n \n error[E0596]: cannot borrow `other.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:35:17\n@@ -95,7 +95,7 @@ LL |         let _ = &mut other.x;\n help: consider changing this to be a mutable reference\n    |\n LL |     fn foo4(other: &mut Z) {\n-   |                    ~~~~~~\n+   |                     +++\n \n error[E0596]: cannot borrow `z.x` as mutable, as `z` is not declared as mutable\n   --> $DIR/issue-39544.rs:41:13\n@@ -117,7 +117,7 @@ LL |     let _ = &mut w.x;\n help: consider changing this to be a mutable reference\n    |\n LL | pub fn with_arg(z: Z, w: &mut Z) {\n-   |                          ~~~~~~\n+   |                           +++\n \n error[E0594]: cannot assign to `*x.0`, which is behind a `&` reference\n   --> $DIR/issue-39544.rs:48:5"}, {"sha": "ba94a570256390de93bf9b31586be094efd9e353", "filename": "tests/ui/did_you_mean/issue-40823.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fdid_you_mean%2Fissue-40823.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fdid_you_mean%2Fissue-40823.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fissue-40823.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |     buf.iter_mut();\n help: consider changing this to be a mutable reference\n    |\n LL |     let mut buf = &mut [1, 2, 3, 4];\n-   |                   ~~~~~~~~~~~~~~~~~\n+   |                    +++\n \n error: aborting due to previous error\n "}, {"sha": "e4001856c388b151a6315ea7f0a985dbefb6d759", "filename": "tests/ui/error-codes/E0389.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ferror-codes%2FE0389.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ferror-codes%2FE0389.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0389.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |     fancy_ref.num = 6;\n help: consider changing this to be a mutable reference\n    |\n LL |     let fancy_ref = &mut (&mut fancy);\n-   |                     ~~~~~~~~~~~~~~~~~\n+   |                      +++\n \n error: aborting due to previous error\n "}, {"sha": "832bb5a96bc3db5f5b8dc81884d29894d0c6b795", "filename": "tests/ui/feature-gates/feature-gate-builtin_syntax.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ffeature-gates%2Ffeature-gate-builtin_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ffeature-gates%2Ffeature-gate-builtin_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-builtin_syntax.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,7 @@\n+struct Foo {\n+    v: u8,\n+    w: u8,\n+}\n+fn main() {\n+    builtin # offset_of(Foo, v); //~ ERROR `builtin #` syntax is unstable\n+}"}, {"sha": "3bc7848f66dd305cb17bdd4e040ff11797a74083", "filename": "tests/ui/feature-gates/feature-gate-builtin_syntax.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ffeature-gates%2Ffeature-gate-builtin_syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ffeature-gates%2Ffeature-gate-builtin_syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-builtin_syntax.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: `builtin #` syntax is unstable\n+  --> $DIR/feature-gate-builtin_syntax.rs:6:15\n+   |\n+LL |     builtin # offset_of(Foo, v);\n+   |               ^^^^^^^^^\n+   |\n+   = note: see issue #110680 <https://github.com/rust-lang/rust/issues/110680> for more information\n+   = help: add `#![feature(builtin_syntax)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "c58aab42269887895e02c6ff918b88b4ea70f8cd", "filename": "tests/ui/inference/deref-suggestion.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Finference%2Fderef-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Finference%2Fderef-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Fderef-suggestion.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -98,19 +98,23 @@ error[E0308]: mismatched types\n   --> $DIR/deref-suggestion.rs:40:17\n    |\n LL |     let s = S { u };\n-   |                 ^\n-   |                 |\n-   |                 expected `&u32`, found integer\n-   |                 help: consider borrowing here: `u: &u`\n+   |                 ^ expected `&u32`, found integer\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let s = S { u: &u };\n+   |                 ++++\n \n error[E0308]: mismatched types\n   --> $DIR/deref-suggestion.rs:42:20\n    |\n LL |     let s = S { u: u };\n-   |                    ^\n-   |                    |\n-   |                    expected `&u32`, found integer\n-   |                    help: consider borrowing here: `&u`\n+   |                    ^ expected `&u32`, found integer\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let s = S { u: &u };\n+   |                    +\n \n error[E0308]: mismatched types\n   --> $DIR/deref-suggestion.rs:45:17"}, {"sha": "879dc5b76c59975fc88ccd73589396509255e6b8", "filename": "tests/ui/issues/issue-11374.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-11374.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-11374.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-11374.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,10 +2,8 @@ error[E0308]: mismatched types\n   --> $DIR/issue-11374.rs:26:15\n    |\n LL |     c.read_to(v);\n-   |       ------- ^\n-   |       |       |\n-   |       |       expected `&mut [u8]`, found `Vec<_>`\n-   |       |       help: consider mutably borrowing here: `&mut v`\n+   |       ------- ^ expected `&mut [u8]`, found `Vec<_>`\n+   |       |\n    |       arguments to this method are incorrect\n    |\n    = note: expected mutable reference `&mut [u8]`\n@@ -15,6 +13,10 @@ note: method defined here\n    |\n LL |     pub fn read_to(&mut self, vec: &mut [u8]) {\n    |            ^^^^^^^            --------------\n+help: consider mutably borrowing here\n+   |\n+LL |     c.read_to(&mut v);\n+   |               ++++\n \n error: aborting due to previous error\n "}, {"sha": "3419c0798595e2e92805bd81fa04e3f6fcee2b72", "filename": "tests/ui/issues/issue-17033.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-17033.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-17033.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-17033.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,11 +2,14 @@ error[E0308]: mismatched types\n   --> $DIR/issue-17033.rs:2:10\n    |\n LL |     (*p)(())\n-   |     ---- ^^\n-   |     |    |\n-   |     |    expected `&mut ()`, found `()`\n-   |     |    help: consider mutably borrowing here: `&mut ()`\n+   |     ---- ^^ expected `&mut ()`, found `()`\n+   |     |\n    |     arguments to this function are incorrect\n+   |\n+help: consider mutably borrowing here\n+   |\n+LL |     (*p)(&mut ())\n+   |          ++++\n \n error: aborting due to previous error\n "}, {"sha": "40098f9622fa99c8c9ef97c3879b8370e6f09331", "filename": "tests/ui/issues/issue-18819.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-18819.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-18819.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-18819.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -19,7 +19,7 @@ LL | fn print_x(_: &dyn Foo<Item=bool>, extra: &str) {\n help: consider borrowing here\n    |\n LL |     print_x(&X);\n-   |             ~~\n+   |             +\n help: provide the argument\n    |\n LL |     print_x(/* &dyn Foo<Item = bool> */, /* &str */);"}, {"sha": "6e126038cc95c074923d3cebdbc97960e6e6da53", "filename": "tests/ui/issues/issue-46302.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-46302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-46302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-46302.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,10 +2,12 @@ error[E0308]: mismatched types\n   --> $DIR/issue-46302.rs:3:27\n    |\n LL |   let u: &str = if true { s[..2] } else { s };\n-   |                           ^^^^^^\n-   |                           |\n-   |                           expected `&str`, found `str`\n-   |                           help: consider borrowing here: `&s[..2]`\n+   |                           ^^^^^^ expected `&str`, found `str`\n+   |\n+help: consider borrowing here\n+   |\n+LL |   let u: &str = if true { &s[..2] } else { s };\n+   |                           +\n \n error: aborting due to previous error\n "}, {"sha": "211dd51289595a743586decc12e1868a13376625", "filename": "tests/ui/issues/issue-46756-consider-borrowing-cast-or-binexpr.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-46756-consider-borrowing-cast-or-binexpr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-46756-consider-borrowing-cast-or-binexpr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-46756-consider-borrowing-cast-or-binexpr.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,33 +2,37 @@ error[E0308]: mismatched types\n   --> $DIR/issue-46756-consider-borrowing-cast-or-binexpr.rs:12:42\n    |\n LL |     light_flows_our_war_of_mocking_words(behold as usize);\n-   |     ------------------------------------ ^^^^^^^^^^^^^^^\n-   |     |                                    |\n-   |     |                                    expected `&usize`, found `usize`\n-   |     |                                    help: consider borrowing here: `&(behold as usize)`\n+   |     ------------------------------------ ^^^^^^^^^^^^^^^ expected `&usize`, found `usize`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n note: function defined here\n   --> $DIR/issue-46756-consider-borrowing-cast-or-binexpr.rs:5:4\n    |\n LL | fn light_flows_our_war_of_mocking_words(and_yet: &usize) -> usize {\n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ---------------\n+help: consider borrowing here\n+   |\n+LL |     light_flows_our_war_of_mocking_words(&(behold as usize));\n+   |                                          ++               +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-46756-consider-borrowing-cast-or-binexpr.rs:14:42\n    |\n LL |     light_flows_our_war_of_mocking_words(with_tears + 4);\n-   |     ------------------------------------ ^^^^^^^^^^^^^^\n-   |     |                                    |\n-   |     |                                    expected `&usize`, found `usize`\n-   |     |                                    help: consider borrowing here: `&(with_tears + 4)`\n+   |     ------------------------------------ ^^^^^^^^^^^^^^ expected `&usize`, found `usize`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n note: function defined here\n   --> $DIR/issue-46756-consider-borrowing-cast-or-binexpr.rs:5:4\n    |\n LL | fn light_flows_our_war_of_mocking_words(and_yet: &usize) -> usize {\n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ---------------\n+help: consider borrowing here\n+   |\n+LL |     light_flows_our_war_of_mocking_words(&(with_tears + 4));\n+   |                                          ++              +\n \n error: aborting due to 2 previous errors\n "}, {"sha": "33a9bf85e23ea080b6476ba3cb9269623732170c", "filename": "tests/ui/issues/issue-51515.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-51515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-51515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-51515.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1,7 +1,6 @@\n fn main() {\n     let foo = &16;\n     //~^ HELP consider changing this to be a mutable reference\n-    //~| SUGGESTION &mut 16\n     *foo = 32;\n     //~^ ERROR cannot assign to `*foo`, which is behind a `&` reference\n     let bar = foo;"}, {"sha": "88b8d2109088696971e18eb4925a35f4d957281b", "filename": "tests/ui/issues/issue-51515.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-51515.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-51515.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-51515.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1,16 +1,16 @@\n error[E0594]: cannot assign to `*foo`, which is behind a `&` reference\n-  --> $DIR/issue-51515.rs:5:5\n+  --> $DIR/issue-51515.rs:4:5\n    |\n LL |     *foo = 32;\n    |     ^^^^^^^^^ `foo` is a `&` reference, so the data it refers to cannot be written\n    |\n help: consider changing this to be a mutable reference\n    |\n LL |     let foo = &mut 16;\n-   |               ~~~~~~~\n+   |                +++\n \n error[E0594]: cannot assign to `*bar`, which is behind a `&` reference\n-  --> $DIR/issue-51515.rs:9:5\n+  --> $DIR/issue-51515.rs:8:5\n    |\n LL |     *bar = 64;\n    |     ^^^^^^^^^ `bar` is a `&` reference, so the data it refers to cannot be written"}, {"sha": "aa922e2682d8347e1992b6debd4ec0f4bbf8c26a", "filename": "tests/ui/issues/issue-61106.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-61106.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-61106.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-61106.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,17 +2,19 @@ error[E0308]: mismatched types\n   --> $DIR/issue-61106.rs:3:9\n    |\n LL |     foo(x.clone());\n-   |     --- ^^^^^^^^^\n-   |     |   |\n-   |     |   expected `&str`, found `String`\n-   |     |   help: consider borrowing here: `&x`\n+   |     --- ^^^^^^^^^ expected `&str`, found `String`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n note: function defined here\n   --> $DIR/issue-61106.rs:6:4\n    |\n LL | fn foo(_: &str) {}\n    |    ^^^ -------\n+help: consider borrowing here\n+   |\n+LL |     foo(&x.clone());\n+   |         +\n \n error: aborting due to previous error\n "}, {"sha": "bedea3890a32e73b07843aae5964b4b5e3bbbfa0", "filename": "tests/ui/issues/issue-61623.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-61623.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fissues%2Fissue-61623.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-61623.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |     f2(|| x.0, f1(x.1))\n help: consider changing this to be a mutable reference\n    |\n LL | fn f3<'a>(x: &'a mut ((), &'a mut ())) {\n-   |              ~~~~~~~~~~~~~~~~~~~~~~~~\n+   |                  +++\n \n error: aborting due to previous error\n "}, {"sha": "dcc21acc5c0f484121d571828854e37031628942", "filename": "tests/ui/methods/method-self-arg-1.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fmethods%2Fmethod-self-arg-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fmethods%2Fmethod-self-arg-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fmethod-self-arg-1.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,17 +2,19 @@ error[E0308]: mismatched types\n   --> $DIR/method-self-arg-1.rs:11:14\n    |\n LL |     Foo::bar(x);\n-   |     -------- ^\n-   |     |        |\n-   |     |        expected `&Foo`, found `Foo`\n-   |     |        help: consider borrowing here: `&x`\n+   |     -------- ^ expected `&Foo`, found `Foo`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n note: method defined here\n   --> $DIR/method-self-arg-1.rs:6:8\n    |\n LL |     fn bar(&self) {}\n    |        ^^^ -----\n+help: consider borrowing here\n+   |\n+LL |     Foo::bar(&x);\n+   |              +\n \n error[E0308]: mismatched types\n   --> $DIR/method-self-arg-1.rs:13:14"}, {"sha": "7be94ef4ad66386138abcea42c766088c97fff1c", "filename": "tests/ui/mismatched_types/dont-point-return-on-E0308.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fmismatched_types%2Fdont-point-return-on-E0308.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fmismatched_types%2Fdont-point-return-on-E0308.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fdont-point-return-on-E0308.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,17 +2,19 @@ error[E0308]: mismatched types\n   --> $DIR/dont-point-return-on-E0308.rs:11:11\n    |\n LL |         f(());\n-   |         - ^^\n-   |         | |\n-   |         | expected `&()`, found `()`\n-   |         | help: consider borrowing here: `&()`\n+   |         - ^^ expected `&()`, found `()`\n+   |         |\n    |         arguments to this function are incorrect\n    |\n note: function defined here\n   --> $DIR/dont-point-return-on-E0308.rs:3:10\n    |\n LL | async fn f(_: &()) {}\n    |          ^ ------\n+help: consider borrowing here\n+   |\n+LL |         f(&());\n+   |           +\n \n error: aborting due to previous error\n "}, {"sha": "8a3076db9b233978f4f7d13a9fd39b5ecac890f0", "filename": "tests/ui/mut/mut-cross-borrowing.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fmut%2Fmut-cross-borrowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fmut%2Fmut-cross-borrowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut%2Fmut-cross-borrowing.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,10 +2,8 @@ error[E0308]: mismatched types\n   --> $DIR/mut-cross-borrowing.rs:7:7\n    |\n LL |     f(x)\n-   |     - ^\n-   |     | |\n-   |     | expected `&mut isize`, found `Box<{integer}>`\n-   |     | help: consider mutably borrowing here: `&mut x`\n+   |     - ^ expected `&mut isize`, found `Box<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut isize`\n@@ -15,6 +13,10 @@ note: function defined here\n    |\n LL | fn f(_: &mut isize) {}\n    |    ^ -------------\n+help: consider mutably borrowing here\n+   |\n+LL |     f(&mut x)\n+   |       ++++\n \n error: aborting due to previous error\n "}, {"sha": "09b9d638afb033a1e415bda16095cbe255a3c942", "filename": "tests/ui/nll/issue-47388.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fnll%2Fissue-47388.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fnll%2Fissue-47388.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fissue-47388.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |     fancy_ref.num = 6;\n help: consider changing this to be a mutable reference\n    |\n LL |     let fancy_ref = &mut (&mut fancy);\n-   |                     ~~~~~~~~~~~~~~~~~\n+   |                      +++\n \n error: aborting due to previous error\n "}, {"sha": "8ccb5809e39729143a6be3d6cad8826a673aa428", "filename": "tests/ui/nll/issue-51244.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fnll%2Fissue-51244.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fnll%2Fissue-51244.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fissue-51244.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |     *my_ref = 0;\n help: consider changing this to be a mutable reference\n    |\n LL |     let ref mut my_ref @ _ = 0;\n-   |         ~~~~~~~~~~~~~~\n+   |             +++\n \n error: aborting due to previous error\n "}, {"sha": "6062b31d6883cc76715432fa06666001b65915d3", "filename": "tests/ui/nll/issue-57989.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fnll%2Fissue-57989.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fnll%2Fissue-57989.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fissue-57989.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |     *x = 0;\n help: consider changing this to be a mutable reference\n    |\n LL | fn f(x: &mut i32) {\n-   |         ~~~~~~~~\n+   |          +++\n \n error[E0506]: cannot assign to `*x` because it is borrowed\n   --> $DIR/issue-57989.rs:5:5"}, {"sha": "5e66e33f8a273b4ac5988401f429834b83550882", "filename": "tests/ui/offset-of/offset-of-arg-count.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Foffset-of%2Foffset-of-arg-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Foffset-of%2Foffset-of-arg-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foffset-of%2Foffset-of-arg-count.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -3,7 +3,15 @@\n use std::mem::offset_of;\n \n fn main() {\n-    offset_of!(NotEnoughArguments); //~ ERROR expected one of\n-    offset_of!(NotEnoughArgumentsWithAComma, ); //~ ERROR expected 2 arguments\n-    offset_of!(Container, field, too many arguments); //~ ERROR expected 2 arguments\n+    offset_of!(NotEnoughArguments); //~ ERROR unexpected end of macro invocation\n+    offset_of!(NotEnoughArgumentsWithAComma, ); //~ ERROR unexpected end of macro invocation\n+    offset_of!(Container, field, too many arguments); //~ ERROR no rules expected the token `too`\n+    offset_of!(S, f); // compiles fine\n+    offset_of!(S, f,); // also compiles fine\n+    offset_of!(S, f.); //~ ERROR unexpected end of macro invocation\n+    offset_of!(S, f.,); //~ ERROR expected identifier\n+    offset_of!(S, f..); //~ ERROR no rules expected the token\n+    offset_of!(S, f..,); //~ ERROR no rules expected the token\n }\n+\n+struct S { f: u8, }"}, {"sha": "4275a89545f50c24975002b8eb881babeeabf904", "filename": "tests/ui/offset-of/offset-of-arg-count.stderr", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Foffset-of%2Foffset-of-arg-count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Foffset-of%2Foffset-of-arg-count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foffset-of%2Foffset-of-arg-count.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1,20 +1,59 @@\n-error: expected one of `!`, `(`, `+`, `,`, `::`, or `<`, found `<eof>`\n-  --> $DIR/offset-of-arg-count.rs:6:16\n+error: unexpected end of macro invocation\n+  --> $DIR/offset-of-arg-count.rs:6:34\n    |\n LL |     offset_of!(NotEnoughArguments);\n-   |                ^^^^^^^^^^^^^^^^^^ expected one of `!`, `(`, `+`, `,`, `::`, or `<`\n+   |                                  ^ missing tokens in macro arguments\n+   |\n+note: while trying to match `,`\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n \n-error: expected 2 arguments\n-  --> $DIR/offset-of-arg-count.rs:7:5\n+error: unexpected end of macro invocation\n+  --> $DIR/offset-of-arg-count.rs:7:45\n    |\n LL |     offset_of!(NotEnoughArgumentsWithAComma, );\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                             ^ missing tokens in macro arguments\n+   |\n+note: while trying to match meta-variable `$fields:tt`\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n \n-error: expected 2 arguments\n-  --> $DIR/offset-of-arg-count.rs:8:5\n+error: no rules expected the token `too`\n+  --> $DIR/offset-of-arg-count.rs:8:34\n    |\n LL |     offset_of!(Container, field, too many arguments);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                  ^^^ no rules expected this token in macro call\n+   |\n+   = note: while trying to match sequence end\n+\n+error: unexpected end of macro invocation\n+  --> $DIR/offset-of-arg-count.rs:11:21\n+   |\n+LL |     offset_of!(S, f.);\n+   |                     ^ missing tokens in macro arguments\n+   |\n+note: while trying to match meta-variable `$fields:tt`\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+\n+error: expected identifier, found `,`\n+  --> $DIR/offset-of-arg-count.rs:12:21\n+   |\n+LL |     offset_of!(S, f.,);\n+   |                     ^ expected identifier\n+\n+error: no rules expected the token `..`\n+  --> $DIR/offset-of-arg-count.rs:13:20\n+   |\n+LL |     offset_of!(S, f..);\n+   |                    ^^ no rules expected this token in macro call\n+   |\n+   = note: while trying to match sequence start\n+\n+error: no rules expected the token `..`\n+  --> $DIR/offset-of-arg-count.rs:14:20\n+   |\n+LL |     offset_of!(S, f..,);\n+   |                    ^^ no rules expected this token in macro call\n+   |\n+   = note: while trying to match sequence start\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 7 previous errors\n "}, {"sha": "1be9899887b4abe9c1daffd8967835c5ab4aa8c0", "filename": "tests/ui/offset-of/offset-of-builtin.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Foffset-of%2Foffset-of-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Foffset-of%2Foffset-of-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foffset-of%2Foffset-of-builtin.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,44 @@\n+#![feature(builtin_syntax)]\n+\n+// For the exposed macro we already test these errors in the other files,\n+// but this test helps to make sure the builtin construct also errors.\n+// This has the same examples as offset-of-arg-count.rs\n+\n+fn main() {\n+    builtin # offset_of(NotEnoughArguments); //~ ERROR expected one of\n+}\n+fn t1() {\n+    // Already errored upon at the macro level. Yielding an error would require\n+    // extra effort.\n+    builtin # offset_of(NotEnoughArgumentsWithAComma, );\n+}\n+fn t2() {\n+    builtin # offset_of(Container, field, too many arguments); //~ ERROR expected identifier, found\n+    //~| ERROR found `,`\n+    //~| ERROR found `many`\n+    //~| ERROR found `arguments`\n+}\n+fn t3() {\n+    builtin # offset_of(S, f); // compiles fine\n+}\n+fn t4() {\n+    // Already errored upon at the macro level. Yielding an error would require\n+    // extra effort.\n+    builtin # offset_of(S, f);\n+}\n+fn t5() {\n+    builtin # offset_of(S, f.); //~ ERROR expected identifier\n+}\n+fn t6() {\n+    builtin # offset_of(S, f.,); //~ ERROR expected identifier\n+}\n+fn t7() {\n+    builtin # offset_of(S, f..); //~ ERROR expected one of\n+}\n+fn t8() {\n+    // Already errored upon at the macro level. Yielding an error would require\n+    // extra effort.\n+    builtin # offset_of(S, f..,);\n+}\n+\n+struct S { f: u8, }"}, {"sha": "1a1f33cc613a741cdeb9717b71d68cd643f90a3f", "filename": "tests/ui/offset-of/offset-of-builtin.stderr", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Foffset-of%2Foffset-of-builtin.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Foffset-of%2Foffset-of-builtin.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foffset-of%2Foffset-of-builtin.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,65 @@\n+error: expected one of `!`, `(`, `+`, `,`, `::`, or `<`, found `)`\n+  --> $DIR/offset-of-builtin.rs:8:43\n+   |\n+LL |     builtin # offset_of(NotEnoughArguments);\n+   |                                           ^ expected one of `!`, `(`, `+`, `,`, `::`, or `<`\n+\n+error: expected identifier, found `,`\n+  --> $DIR/offset-of-builtin.rs:16:41\n+   |\n+LL |     builtin # offset_of(Container, field, too many arguments);\n+   |                                         ^\n+   |                                         |\n+   |                                         expected identifier\n+   |                                         help: remove this comma\n+\n+error: expected one of `)` or `.`, found `,`\n+  --> $DIR/offset-of-builtin.rs:16:41\n+   |\n+LL |     builtin # offset_of(Container, field, too many arguments);\n+   |                                         ^\n+   |                                         |\n+   |                                         expected one of `)` or `.`\n+   |                                         help: missing `.`\n+\n+error: expected one of `)` or `.`, found `many`\n+  --> $DIR/offset-of-builtin.rs:16:47\n+   |\n+LL |     builtin # offset_of(Container, field, too many arguments);\n+   |                                              -^^^^ expected one of `)` or `.`\n+   |                                              |\n+   |                                              help: missing `.`\n+\n+error: expected one of `)` or `.`, found `arguments`\n+  --> $DIR/offset-of-builtin.rs:16:52\n+   |\n+LL |     builtin # offset_of(Container, field, too many arguments);\n+   |                                                   -^^^^^^^^^ expected one of `)` or `.`\n+   |                                                   |\n+   |                                                   help: missing `.`\n+\n+error: expected identifier, found `)`\n+  --> $DIR/offset-of-builtin.rs:30:30\n+   |\n+LL |     builtin # offset_of(S, f.);\n+   |                              ^ expected identifier\n+\n+error: expected identifier, found `,`\n+  --> $DIR/offset-of-builtin.rs:33:30\n+   |\n+LL |     builtin # offset_of(S, f.,);\n+   |                              ^ expected identifier\n+\n+error: expected one of `)` or `.`, found `..`\n+  --> $DIR/offset-of-builtin.rs:36:29\n+   |\n+LL |     builtin # offset_of(S, f..);\n+   |                             ^^ expected one of `)` or `.`\n+   |\n+help: if you meant to bind the contents of the rest of the array pattern into `f`, use `@`\n+   |\n+LL |     builtin # offset_of(S, f @ ..);\n+   |                              +\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "e6e0f49923620f127085ff1f869d4d5e54412e15", "filename": "tests/ui/offset-of/offset-of-dst-field.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Foffset-of%2Foffset-of-dst-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Foffset-of%2Foffset-of-dst-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foffset-of%2Foffset-of-dst-field.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -5,6 +5,7 @@ LL |     offset_of!(Alpha, z);\n    |     ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the size for values of type `(dyn Trait + 'static)` cannot be known at compilation time\n   --> $DIR/offset-of-dst-field.rs:31:5\n@@ -13,6 +14,7 @@ LL |     offset_of!(Beta, z);\n    |     ^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `(dyn Trait + 'static)`\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the size for values of type `Extern` cannot be known at compilation time\n   --> $DIR/offset-of-dst-field.rs:32:5\n@@ -21,6 +23,7 @@ LL |     offset_of!(Gamma, z);\n    |     ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `Extern`\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "c39882519a5da0e0e91adb3995e5c49bc10d5079", "filename": "tests/ui/offset-of/offset-of-unstable.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Foffset-of%2Foffset-of-unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Foffset-of%2Foffset-of-unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foffset-of%2Foffset-of-unstable.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -33,6 +33,7 @@ LL | |     );\n    | |_____^\n    |\n    = help: add `#![feature(unstable_test_feature)]` to the crate attributes to enable\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0658]: use of unstable library feature 'unstable_test_feature'\n   --> $DIR/offset-of-unstable.rs:18:5\n@@ -41,6 +42,7 @@ LL |     offset_of!(StableWithUnstableField, unstable);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(unstable_test_feature)]` to the crate attributes to enable\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0658]: use of unstable library feature 'unstable_test_feature'\n   --> $DIR/offset-of-unstable.rs:20:5\n@@ -49,6 +51,7 @@ LL |     offset_of!(StableWithUnstableFieldType, stable.unstable);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(unstable_test_feature)]` to the crate attributes to enable\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0658]: use of unstable library feature 'unstable_test_feature'\n   --> $DIR/offset-of-unstable.rs:21:5\n@@ -61,6 +64,7 @@ LL | |     );\n    | |_____^\n    |\n    = help: add `#![feature(unstable_test_feature)]` to the crate attributes to enable\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0658]: use of unstable library feature 'unstable_test_feature'\n   --> $DIR/offset-of-unstable.rs:26:5\n@@ -73,6 +77,7 @@ LL | |     );\n    | |_____^\n    |\n    = help: add `#![feature(unstable_test_feature)]` to the crate attributes to enable\n+   = note: this error originates in the macro `offset_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 8 previous errors\n "}, {"sha": "897dab8ec50aea16381bd143b0207dad181ca2b8", "filename": "tests/ui/parser/builtin-syntax.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fparser%2Fbuiltin-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fparser%2Fbuiltin-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fbuiltin-syntax.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,9 @@\n+#![feature(builtin_syntax)]\n+\n+fn main() {\n+    builtin # foobar(); //~ ERROR unknown `builtin #` construct\n+}\n+\n+fn not_identifier() {\n+    builtin # {}(); //~ ERROR expected identifier after\n+}"}, {"sha": "ee3764a62216ae3033100fecdba9c598b33f0dbd", "filename": "tests/ui/parser/builtin-syntax.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fparser%2Fbuiltin-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fparser%2Fbuiltin-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fbuiltin-syntax.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,14 @@\n+error: unknown `builtin #` construct `foobar`\n+  --> $DIR/builtin-syntax.rs:4:5\n+   |\n+LL |     builtin # foobar();\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: expected identifier after `builtin #`\n+  --> $DIR/builtin-syntax.rs:8:15\n+   |\n+LL |     builtin # {}();\n+   |               ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a033cc0655ef9015e027d1eb8445dc338ab2c472", "filename": "tests/ui/pattern/move-ref-patterns/borrowck-move-ref-pattern.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -112,7 +112,7 @@ LL |     *_x0 = U;\n help: consider changing this to be a mutable reference\n    |\n LL |     let (ref mut _x0, _x1, ref _x2, ..) = tup;\n-   |          ~~~~~~~~~~~\n+   |              +++\n \n error[E0594]: cannot assign to `*_x2`, which is behind a `&` reference\n   --> $DIR/borrowck-move-ref-pattern.rs:27:5\n@@ -123,7 +123,7 @@ LL |     *_x2 = U;\n help: consider changing this to be a mutable reference\n    |\n LL |     let (ref _x0, _x1, ref mut _x2, ..) = tup;\n-   |                        ~~~~~~~~~~~\n+   |                            +++\n \n error[E0382]: use of moved value: `tup.1`\n   --> $DIR/borrowck-move-ref-pattern.rs:28:10"}, {"sha": "71c36c741cc5eab2e0b02335a6190d98397bf69f", "filename": "tests/ui/range/issue-54505-no-literals.fixed", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505-no-literals.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505-no-literals.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange%2Fissue-54505-no-literals.fixed?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -16,60 +16,60 @@ fn main() {\n     take_range(&std::ops::Range { start: 0, end: 1 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &std::ops::Range { start: 0, end: 1 }\n+    //~| SUGGESTION &\n \n     take_range(&::std::ops::Range { start: 0, end: 1 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &::std::ops::Range { start: 0, end: 1 }\n+    //~| SUGGESTION &\n \n     take_range(&std::ops::RangeFrom { start: 1 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &std::ops::RangeFrom { start: 1 }\n+    //~| SUGGESTION &\n \n     take_range(&::std::ops::RangeFrom { start: 1 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &::std::ops::RangeFrom { start: 1 }\n+    //~| SUGGESTION &\n \n     take_range(&std::ops::RangeFull {});\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &std::ops::RangeFull {}\n+    //~| SUGGESTION &\n \n     take_range(&::std::ops::RangeFull {});\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &::std::ops::RangeFull {}\n+    //~| SUGGESTION &\n \n     take_range(&std::ops::RangeInclusive::new(0, 1));\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &std::ops::RangeInclusive::new(0, 1)\n+    //~| SUGGESTION &\n \n     take_range(&::std::ops::RangeInclusive::new(0, 1));\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &::std::ops::RangeInclusive::new(0, 1)\n+    //~| SUGGESTION &\n \n     take_range(&std::ops::RangeTo { end: 5 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &std::ops::RangeTo { end: 5 }\n+    //~| SUGGESTION &\n \n     take_range(&::std::ops::RangeTo { end: 5 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &::std::ops::RangeTo { end: 5 }\n+    //~| SUGGESTION &\n \n     take_range(&std::ops::RangeToInclusive { end: 5 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &std::ops::RangeToInclusive { end: 5 }\n+    //~| SUGGESTION &\n \n     take_range(&::std::ops::RangeToInclusive { end: 5 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &::std::ops::RangeToInclusive { end: 5 }\n+    //~| SUGGESTION &\n }"}, {"sha": "db125d1a22b6de78ed296ddabe321a7bf518fa09", "filename": "tests/ui/range/issue-54505-no-literals.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505-no-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505-no-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange%2Fissue-54505-no-literals.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -16,60 +16,60 @@ fn main() {\n     take_range(std::ops::Range { start: 0, end: 1 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &std::ops::Range { start: 0, end: 1 }\n+    //~| SUGGESTION &\n \n     take_range(::std::ops::Range { start: 0, end: 1 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &::std::ops::Range { start: 0, end: 1 }\n+    //~| SUGGESTION &\n \n     take_range(std::ops::RangeFrom { start: 1 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &std::ops::RangeFrom { start: 1 }\n+    //~| SUGGESTION &\n \n     take_range(::std::ops::RangeFrom { start: 1 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &::std::ops::RangeFrom { start: 1 }\n+    //~| SUGGESTION &\n \n     take_range(std::ops::RangeFull {});\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &std::ops::RangeFull {}\n+    //~| SUGGESTION &\n \n     take_range(::std::ops::RangeFull {});\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &::std::ops::RangeFull {}\n+    //~| SUGGESTION &\n \n     take_range(std::ops::RangeInclusive::new(0, 1));\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &std::ops::RangeInclusive::new(0, 1)\n+    //~| SUGGESTION &\n \n     take_range(::std::ops::RangeInclusive::new(0, 1));\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &::std::ops::RangeInclusive::new(0, 1)\n+    //~| SUGGESTION &\n \n     take_range(std::ops::RangeTo { end: 5 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &std::ops::RangeTo { end: 5 }\n+    //~| SUGGESTION &\n \n     take_range(::std::ops::RangeTo { end: 5 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &::std::ops::RangeTo { end: 5 }\n+    //~| SUGGESTION &\n \n     take_range(std::ops::RangeToInclusive { end: 5 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &std::ops::RangeToInclusive { end: 5 }\n+    //~| SUGGESTION &\n \n     take_range(::std::ops::RangeToInclusive { end: 5 });\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &::std::ops::RangeToInclusive { end: 5 }\n+    //~| SUGGESTION &\n }"}, {"sha": "5894bb6ba553fab6856a4d35d3fad240573401af", "filename": "tests/ui/range/issue-54505-no-literals.stderr", "status": "modified", "additions": 72, "deletions": 48, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505-no-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505-no-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange%2Fissue-54505-no-literals.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,10 +2,8 @@ error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-literals.rs:16:16\n    |\n LL |     take_range(std::ops::Range { start: 0, end: 1 });\n-   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `Range<{integer}>`\n-   |     |          help: consider borrowing here: `&std::ops::Range { start: 0, end: 1 }`\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&_`, found `Range<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -15,15 +13,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&std::ops::Range { start: 0, end: 1 });\n+   |                +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-literals.rs:21:16\n    |\n LL |     take_range(::std::ops::Range { start: 0, end: 1 });\n-   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `Range<{integer}>`\n-   |     |          help: consider borrowing here: `&::std::ops::Range { start: 0, end: 1 }`\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&_`, found `Range<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -33,15 +33,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&::std::ops::Range { start: 0, end: 1 });\n+   |                +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-literals.rs:26:16\n    |\n LL |     take_range(std::ops::RangeFrom { start: 1 });\n-   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeFrom<{integer}>`\n-   |     |          help: consider borrowing here: `&std::ops::RangeFrom { start: 1 }`\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&_`, found `RangeFrom<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -51,15 +53,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&std::ops::RangeFrom { start: 1 });\n+   |                +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-literals.rs:31:16\n    |\n LL |     take_range(::std::ops::RangeFrom { start: 1 });\n-   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeFrom<{integer}>`\n-   |     |          help: consider borrowing here: `&::std::ops::RangeFrom { start: 1 }`\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&_`, found `RangeFrom<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -69,15 +73,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&::std::ops::RangeFrom { start: 1 });\n+   |                +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-literals.rs:36:16\n    |\n LL |     take_range(std::ops::RangeFull {});\n-   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeFull`\n-   |     |          help: consider borrowing here: `&std::ops::RangeFull {}`\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^ expected `&_`, found `RangeFull`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -87,15 +93,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&std::ops::RangeFull {});\n+   |                +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-literals.rs:41:16\n    |\n LL |     take_range(::std::ops::RangeFull {});\n-   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeFull`\n-   |     |          help: consider borrowing here: `&::std::ops::RangeFull {}`\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^ expected `&_`, found `RangeFull`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -105,15 +113,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&::std::ops::RangeFull {});\n+   |                +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-literals.rs:46:16\n    |\n LL |     take_range(std::ops::RangeInclusive::new(0, 1));\n-   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeInclusive<{integer}>`\n-   |     |          help: consider borrowing here: `&std::ops::RangeInclusive::new(0, 1)`\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&_`, found `RangeInclusive<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -123,15 +133,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&std::ops::RangeInclusive::new(0, 1));\n+   |                +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-literals.rs:51:16\n    |\n LL |     take_range(::std::ops::RangeInclusive::new(0, 1));\n-   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeInclusive<{integer}>`\n-   |     |          help: consider borrowing here: `&::std::ops::RangeInclusive::new(0, 1)`\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&_`, found `RangeInclusive<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -141,15 +153,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&::std::ops::RangeInclusive::new(0, 1));\n+   |                +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-literals.rs:56:16\n    |\n LL |     take_range(std::ops::RangeTo { end: 5 });\n-   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeTo<{integer}>`\n-   |     |          help: consider borrowing here: `&std::ops::RangeTo { end: 5 }`\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&_`, found `RangeTo<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -159,15 +173,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&std::ops::RangeTo { end: 5 });\n+   |                +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-literals.rs:61:16\n    |\n LL |     take_range(::std::ops::RangeTo { end: 5 });\n-   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeTo<{integer}>`\n-   |     |          help: consider borrowing here: `&::std::ops::RangeTo { end: 5 }`\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&_`, found `RangeTo<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -177,15 +193,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&::std::ops::RangeTo { end: 5 });\n+   |                +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-literals.rs:66:16\n    |\n LL |     take_range(std::ops::RangeToInclusive { end: 5 });\n-   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeToInclusive<{integer}>`\n-   |     |          help: consider borrowing here: `&std::ops::RangeToInclusive { end: 5 }`\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&_`, found `RangeToInclusive<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -195,15 +213,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&std::ops::RangeToInclusive { end: 5 });\n+   |                +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-literals.rs:71:16\n    |\n LL |     take_range(::std::ops::RangeToInclusive { end: 5 });\n-   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeToInclusive<{integer}>`\n-   |     |          help: consider borrowing here: `&::std::ops::RangeToInclusive { end: 5 }`\n+   |     ---------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&_`, found `RangeToInclusive<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -213,6 +233,10 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&::std::ops::RangeToInclusive { end: 5 });\n+   |                +\n \n error: aborting due to 12 previous errors\n "}, {"sha": "db455fada3bd8a30adda84aef44e64147333d6b0", "filename": "tests/ui/range/issue-54505-no-std.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505-no-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505-no-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange%2Fissue-54505-no-std.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -29,30 +29,30 @@ fn main() {\n     take_range(0..1);\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(0..1)\n+    //~| SUGGESTION &(\n \n     take_range(1..);\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(1..)\n+    //~| SUGGESTION &(\n \n     take_range(..);\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(..)\n+    //~| SUGGESTION &(\n \n     take_range(0..=1);\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(0..=1)\n+    //~| SUGGESTION &(\n \n     take_range(..5);\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(..5)\n+    //~| SUGGESTION &(\n \n     take_range(..=42);\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(..=42)\n+    //~| SUGGESTION &(\n }"}, {"sha": "13563d1940cb691d1759b929457fa2d541320667", "filename": "tests/ui/range/issue-54505-no-std.stderr", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505-no-std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505-no-std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange%2Fissue-54505-no-std.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -14,10 +14,8 @@ error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-std.rs:29:16\n    |\n LL |     take_range(0..1);\n-   |     ---------- ^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `Range<{integer}>`\n-   |     |          help: consider borrowing here: `&(0..1)`\n+   |     ---------- ^^^^ expected `&_`, found `Range<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -27,15 +25,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&(0..1));\n+   |                ++    +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-std.rs:34:16\n    |\n LL |     take_range(1..);\n-   |     ---------- ^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeFrom<{integer}>`\n-   |     |          help: consider borrowing here: `&(1..)`\n+   |     ---------- ^^^ expected `&_`, found `RangeFrom<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -45,15 +45,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&(1..));\n+   |                ++   +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-std.rs:39:16\n    |\n LL |     take_range(..);\n-   |     ---------- ^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeFull`\n-   |     |          help: consider borrowing here: `&(..)`\n+   |     ---------- ^^ expected `&_`, found `RangeFull`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -63,15 +65,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&(..));\n+   |                ++  +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-std.rs:44:16\n    |\n LL |     take_range(0..=1);\n-   |     ---------- ^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeInclusive<{integer}>`\n-   |     |          help: consider borrowing here: `&(0..=1)`\n+   |     ---------- ^^^^^ expected `&_`, found `RangeInclusive<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -81,15 +85,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&(0..=1));\n+   |                ++     +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-std.rs:49:16\n    |\n LL |     take_range(..5);\n-   |     ---------- ^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeTo<{integer}>`\n-   |     |          help: consider borrowing here: `&(..5)`\n+   |     ---------- ^^^ expected `&_`, found `RangeTo<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -99,15 +105,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&(..5));\n+   |                ++   +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505-no-std.rs:54:16\n    |\n LL |     take_range(..=42);\n-   |     ---------- ^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeToInclusive<{integer}>`\n-   |     |          help: consider borrowing here: `&(..=42)`\n+   |     ---------- ^^^^^ expected `&_`, found `RangeToInclusive<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -117,6 +125,10 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&(..=42));\n+   |                ++     +\n \n error: aborting due to 8 previous errors\n "}, {"sha": "9d113ba1d35c2129f91ad1ed3d16939949639da4", "filename": "tests/ui/range/issue-54505.fixed", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange%2Fissue-54505.fixed?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -14,30 +14,30 @@ fn main() {\n     take_range(&(0..1));\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(0..1)\n+    //~| SUGGESTION &(\n \n     take_range(&(1..));\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(1..)\n+    //~| SUGGESTION &(\n \n     take_range(&(..));\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(..)\n+    //~| SUGGESTION &(\n \n     take_range(&(0..=1));\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(0..=1)\n+    //~| SUGGESTION &(\n \n     take_range(&(..5));\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(..5)\n+    //~| SUGGESTION &(\n \n     take_range(&(..=42));\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(..=42)\n+    //~| SUGGESTION &(\n }"}, {"sha": "c9929988fe539f0657e7f1254436c01bc44b4976", "filename": "tests/ui/range/issue-54505.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange%2Fissue-54505.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -14,30 +14,30 @@ fn main() {\n     take_range(0..1);\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(0..1)\n+    //~| SUGGESTION &(\n \n     take_range(1..);\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(1..)\n+    //~| SUGGESTION &(\n \n     take_range(..);\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(..)\n+    //~| SUGGESTION &(\n \n     take_range(0..=1);\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(0..=1)\n+    //~| SUGGESTION &(\n \n     take_range(..5);\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(..5)\n+    //~| SUGGESTION &(\n \n     take_range(..=42);\n     //~^ ERROR mismatched types [E0308]\n     //~| HELP consider borrowing here\n-    //~| SUGGESTION &(..=42)\n+    //~| SUGGESTION &(\n }"}, {"sha": "0e959fc05e279e935ee21848a9d13064a8a4f9da", "filename": "tests/ui/range/issue-54505.stderr", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-54505.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange%2Fissue-54505.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,10 +2,8 @@ error[E0308]: mismatched types\n   --> $DIR/issue-54505.rs:14:16\n    |\n LL |     take_range(0..1);\n-   |     ---------- ^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `Range<{integer}>`\n-   |     |          help: consider borrowing here: `&(0..1)`\n+   |     ---------- ^^^^ expected `&_`, found `Range<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -15,15 +13,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&(0..1));\n+   |                ++    +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505.rs:19:16\n    |\n LL |     take_range(1..);\n-   |     ---------- ^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeFrom<{integer}>`\n-   |     |          help: consider borrowing here: `&(1..)`\n+   |     ---------- ^^^ expected `&_`, found `RangeFrom<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -33,15 +33,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&(1..));\n+   |                ++   +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505.rs:24:16\n    |\n LL |     take_range(..);\n-   |     ---------- ^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeFull`\n-   |     |          help: consider borrowing here: `&(..)`\n+   |     ---------- ^^ expected `&_`, found `RangeFull`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -51,15 +53,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&(..));\n+   |                ++  +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505.rs:29:16\n    |\n LL |     take_range(0..=1);\n-   |     ---------- ^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeInclusive<{integer}>`\n-   |     |          help: consider borrowing here: `&(0..=1)`\n+   |     ---------- ^^^^^ expected `&_`, found `RangeInclusive<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -69,15 +73,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&(0..=1));\n+   |                ++     +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505.rs:34:16\n    |\n LL |     take_range(..5);\n-   |     ---------- ^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeTo<{integer}>`\n-   |     |          help: consider borrowing here: `&(..5)`\n+   |     ---------- ^^^ expected `&_`, found `RangeTo<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -87,15 +93,17 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&(..5));\n+   |                ++   +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-54505.rs:39:16\n    |\n LL |     take_range(..=42);\n-   |     ---------- ^^^^^\n-   |     |          |\n-   |     |          expected `&_`, found `RangeToInclusive<{integer}>`\n-   |     |          help: consider borrowing here: `&(..=42)`\n+   |     ---------- ^^^^^ expected `&_`, found `RangeToInclusive<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -105,6 +113,10 @@ note: function defined here\n    |\n LL | fn take_range(_r: &impl RangeBounds<i8>) {}\n    |    ^^^^^^^^^^ -------------------------\n+help: consider borrowing here\n+   |\n+LL |     take_range(&(..=42));\n+   |                ++     +\n \n error: aborting due to 6 previous errors\n "}, {"sha": "52efa241d0b12a4176f40c36636fb5a6cd8407c5", "filename": "tests/ui/range/issue-73553-misinterp-range-literal.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-73553-misinterp-range-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frange%2Fissue-73553-misinterp-range-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange%2Fissue-73553-misinterp-range-literal.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,10 +2,8 @@ error[E0308]: mismatched types\n   --> $DIR/issue-73553-misinterp-range-literal.rs:12:10\n    |\n LL |     demo(tell(1)..tell(10));\n-   |     ---- ^^^^^^^^^^^^^^^^^\n-   |     |    |\n-   |     |    expected `&Range<usize>`, found `Range<usize>`\n-   |     |    help: consider borrowing here: `&(tell(1)..tell(10))`\n+   |     ---- ^^^^^^^^^^^^^^^^^ expected `&Range<usize>`, found `Range<usize>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&std::ops::Range<usize>`\n@@ -15,15 +13,17 @@ note: function defined here\n    |\n LL | fn demo(r: &Range) {\n    |    ^^^^ ---------\n+help: consider borrowing here\n+   |\n+LL |     demo(&(tell(1)..tell(10)));\n+   |          ++                 +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-73553-misinterp-range-literal.rs:14:10\n    |\n LL |     demo(1..10);\n-   |     ---- ^^^^^\n-   |     |    |\n-   |     |    expected `&Range<usize>`, found `Range<{integer}>`\n-   |     |    help: consider borrowing here: `&(1..10)`\n+   |     ---- ^^^^^ expected `&Range<usize>`, found `Range<{integer}>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&std::ops::Range<usize>`\n@@ -33,6 +33,10 @@ note: function defined here\n    |\n LL | fn demo(r: &Range) {\n    |    ^^^^ ---------\n+help: consider borrowing here\n+   |\n+LL |     demo(&(1..10));\n+   |          ++     +\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f31123f16f140696eecb4fe7e837508ae4df84ca", "filename": "tests/ui/rfc-2632-const-trait-impl/specialization/const-default-bound-non-const-specialized-bound.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-bound-non-const-specialized-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-bound-non-const-specialized-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-bound-non-const-specialized-bound.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -12,7 +12,9 @@ trait Specialize {}\n trait Foo {}\n \n #[const_trait]\n-trait Bar {}\n+trait Bar {\n+    fn bar();\n+}\n \n // bgr360: I was only able to exercise the code path that raises the\n // \"missing ~const qualifier\" error by making this base impl non-const, even\n@@ -21,26 +23,36 @@ trait Bar {}\n impl<T> Bar for T\n where\n     T: ~const Foo,\n-{}\n+{\n+    default fn bar() {}\n+}\n \n impl<T> Bar for T\n where\n     T: Foo, //~ ERROR missing `~const` qualifier\n     T: Specialize,\n-{}\n+{\n+    fn bar() {}\n+}\n \n #[const_trait]\n-trait Baz {}\n+trait Baz {\n+    fn baz();\n+}\n \n impl<T> const Baz for T\n where\n     T: ~const Foo,\n-{}\n+{\n+    default fn baz() {}\n+}\n \n impl<T> const Baz for T //~ ERROR conflicting implementations of trait `Baz`\n where\n     T: Foo,\n     T: Specialize,\n-{}\n+{\n+    fn baz() {}\n+}\n \n fn main() {}"}, {"sha": "057cf4aea8a0f4a29b12ad60db669d2b004eaa3e", "filename": "tests/ui/rfc-2632-const-trait-impl/specialization/const-default-bound-non-const-specialized-bound.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-bound-non-const-specialized-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-bound-non-const-specialized-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fconst-default-bound-non-const-specialized-bound.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1,11 +1,11 @@\n error: missing `~const` qualifier for specialization\n-  --> $DIR/const-default-bound-non-const-specialized-bound.rs:28:8\n+  --> $DIR/const-default-bound-non-const-specialized-bound.rs:32:8\n    |\n LL |     T: Foo,\n    |        ^^^\n \n error[E0119]: conflicting implementations of trait `Baz`\n-  --> $DIR/const-default-bound-non-const-specialized-bound.rs:40:1\n+  --> $DIR/const-default-bound-non-const-specialized-bound.rs:50:1\n    |\n LL | impl<T> const Baz for T\n    | ----------------------- first implementation here"}, {"sha": "92d8be6bb166631593e5c161052c4afdb20d1abf", "filename": "tests/ui/rfc-2632-const-trait-impl/specialization/issue-95186-specialize-on-tilde-const.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fissue-95186-specialize-on-tilde-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fissue-95186-specialize-on-tilde-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fissue-95186-specialize-on-tilde-const.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -11,27 +11,39 @@\n trait Specialize {}\n \n #[const_trait]\n-trait Foo {}\n+trait Foo {\n+    fn foo();\n+}\n \n-impl<T> const Foo for T {}\n+impl<T> const Foo for T {\n+    default fn foo() {}\n+}\n \n impl<T> const Foo for T\n where\n     T: ~const Specialize,\n-{}\n+{\n+    fn foo() {}\n+}\n \n #[const_trait]\n-trait Bar {}\n+trait Bar {\n+    fn bar() {}\n+}\n \n impl<T> const Bar for T\n where\n     T: ~const Foo,\n-{}\n+{\n+    default fn bar() {}\n+}\n \n impl<T> const Bar for T\n where\n     T: ~const Foo,\n     T: ~const Specialize,\n-{}\n+{\n+    fn bar() {}\n+}\n \n fn main() {}"}, {"sha": "51bfaf73b57b45dae3024cd73cc2b040b333ca03", "filename": "tests/ui/rfc-2632-const-trait-impl/specialization/issue-95187-same-trait-bound-different-constness.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fissue-95187-same-trait-bound-different-constness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fissue-95187-same-trait-bound-different-constness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2632-const-trait-impl%2Fspecialization%2Fissue-95187-same-trait-bound-different-constness.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -15,31 +15,43 @@ trait Specialize {}\n trait Foo {}\n \n #[const_trait]\n-trait Bar {}\n+trait Bar {\n+    fn bar();\n+}\n \n impl<T> Bar for T\n where\n     T: Foo,\n-{}\n+{\n+    default fn bar() {}\n+}\n \n impl<T> const Bar for T\n where\n     T: ~const Foo,\n     T: Specialize,\n-{}\n+{\n+    fn bar() {}\n+}\n \n #[const_trait]\n-trait Baz {}\n+trait Baz {\n+    fn baz();\n+}\n \n impl<T> const Baz for T\n where\n     T: Foo,\n-{}\n+{\n+    default fn baz() {}\n+}\n \n impl<T> const Baz for T\n where\n     T: ~const Foo,\n     T: Specialize,\n-{}\n+{\n+    fn baz() {}\n+}\n \n fn main() {}"}, {"sha": "80c5f9da40cea17b391292a9c856f5f1fb27c71a", "filename": "tests/ui/span/borrowck-borrow-overloaded-auto-deref-mut.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -18,7 +18,7 @@ LL |     &mut x.y\n help: consider changing this to be a mutable reference\n    |\n LL | fn deref_extend_mut_field1(x: &mut Own<Point>) -> &mut isize {\n-   |                               ~~~~~~~~~~~~~~~\n+   |                                +++\n \n error[E0499]: cannot borrow `*x` as mutable more than once at a time\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:78:19\n@@ -50,7 +50,7 @@ LL |     x.y = 3;\n help: consider changing this to be a mutable reference\n    |\n LL | fn assign_field2<'a>(x: &'a mut Own<Point>) {\n-   |                         ~~~~~~~~~~~~~~~~~~\n+   |                             +++\n \n error[E0499]: cannot borrow `*x` as mutable more than once at a time\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:101:5\n@@ -82,7 +82,7 @@ LL |     x.y_mut()\n help: consider changing this to be a mutable reference\n    |\n LL | fn deref_extend_mut_method1(x: &mut Own<Point>) -> &mut isize {\n-   |                                ~~~~~~~~~~~~~~~\n+   |                                 +++\n \n error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:129:6\n@@ -104,7 +104,7 @@ LL |     *x.y_mut() = 3;\n help: consider changing this to be a mutable reference\n    |\n LL | fn assign_method2<'a>(x: &'a mut Own<Point>) {\n-   |                          ~~~~~~~~~~~~~~~~~~\n+   |                              +++\n \n error: aborting due to 10 previous errors\n "}, {"sha": "dbd52dc2d38df44b1f26403e0b80798d204be3b7", "filename": "tests/ui/span/borrowck-borrow-overloaded-deref-mut.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -18,7 +18,7 @@ LL |     &mut **x\n help: consider changing this to be a mutable reference\n    |\n LL | fn deref_extend_mut1<'a>(x: &'a mut Own<isize>) -> &'a mut isize {\n-   |                             ~~~~~~~~~~~~~~~~~~\n+   |                                 +++\n \n error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:49:6\n@@ -40,7 +40,7 @@ LL |     **x = 3;\n help: consider changing this to be a mutable reference\n    |\n LL | fn assign2<'a>(x: &'a mut Own<isize>) {\n-   |                   ~~~~~~~~~~~~~~~~~~\n+   |                       +++\n \n error: aborting due to 4 previous errors\n "}, {"sha": "99c8fa1f932d20665033e2160f1c84a9e5b4d6d5", "filename": "tests/ui/span/borrowck-call-is-borrow-issue-12224.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -19,7 +19,7 @@ LL |     (*f)();\n help: consider changing this to be a mutable reference\n    |\n LL | fn test2<F>(f: &mut F) where F: FnMut() {\n-   |                ~~~~~~\n+   |                 +++\n \n error[E0596]: cannot borrow `f.f` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-call-is-borrow-issue-12224.rs:34:5\n@@ -29,8 +29,8 @@ LL |     f.f.call_mut(())\n    |\n help: consider changing this to be a mutable reference\n    |\n-LL | fn test4(f: &mut Test<'_>) {\n-   |             ~~~~~~~~~~~~~\n+LL | fn test4(f: &mut Test) {\n+   |              +++\n \n error[E0507]: cannot move out of `f`, a captured variable in an `FnMut` closure\n   --> $DIR/borrowck-call-is-borrow-issue-12224.rs:57:13"}, {"sha": "328197ae9f42945080a8554a33beb0b81affb698", "filename": "tests/ui/span/borrowck-call-method-from-mut-aliasable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |     x.h();\n help: consider changing this to be a mutable reference\n    |\n LL | fn b(x: &mut Foo) {\n-   |         ~~~~~~~~\n+   |          +++\n \n error: aborting due to previous error\n "}, {"sha": "17fdcc622f776375073da0d5843f48bdf8b52867", "filename": "tests/ui/span/borrowck-fn-in-const-b.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fborrowck-fn-in-const-b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fborrowck-fn-in-const-b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fborrowck-fn-in-const-b.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |         x.push(format!(\"this is broken\"));\n help: consider changing this to be a mutable reference\n    |\n LL |     fn broken(x: &mut Vec<String>) {\n-   |                  ~~~~~~~~~~~~~~~~\n+   |                   +++\n \n error: aborting due to previous error\n "}, {"sha": "805a8034c184a340613b16e14908e0fd52b9f4f9", "filename": "tests/ui/span/borrowck-object-mutability.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fborrowck-object-mutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fborrowck-object-mutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fborrowck-object-mutability.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |     x.borrowed_mut();\n help: consider changing this to be a mutable reference\n    |\n LL | fn borrowed_receiver(x: &mut dyn Foo) {\n-   |                         ~~~~~~~~~~~~\n+   |                          +++\n \n error[E0596]: cannot borrow `*x` as mutable, as `x` is not declared as mutable\n   --> $DIR/borrowck-object-mutability.rs:18:5"}, {"sha": "ff840b781f0721c6f32ebf8875acdf6932ca5b90", "filename": "tests/ui/span/coerce-suggestions.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fcoerce-suggestions.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -10,11 +10,14 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-suggestions.rs:9:19\n    |\n LL |     let x: &str = String::new();\n-   |            ----   ^^^^^^^^^^^^^\n-   |            |      |\n-   |            |      expected `&str`, found `String`\n-   |            |      help: consider borrowing here: `&String::new()`\n+   |            ----   ^^^^^^^^^^^^^ expected `&str`, found `String`\n+   |            |\n    |            expected due to this\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let x: &str = &String::new();\n+   |                   +\n \n error[E0308]: mismatched types\n   --> $DIR/coerce-suggestions.rs:12:10"}, {"sha": "c8c4a5139880d8e2ccd16816787914f680e3c9cf", "filename": "tests/ui/span/issue-39018.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fissue-39018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fissue-39018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fissue-39018.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -78,10 +78,12 @@ error[E0308]: mismatched types\n   --> $DIR/issue-39018.rs:29:17\n    |\n LL |     let _ = a + b;\n-   |                 ^\n-   |                 |\n-   |                 expected `&str`, found `String`\n-   |                 help: consider borrowing here: `&b`\n+   |                 ^ expected `&str`, found `String`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let _ = a + &b;\n+   |                 +\n \n error[E0369]: cannot add `String` to `&String`\n   --> $DIR/issue-39018.rs:30:15"}, {"sha": "06011eac674c1249907a56de0553330e576873bd", "filename": "tests/ui/span/mut-arg-hint.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fmut-arg-hint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspan%2Fmut-arg-hint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fmut-arg-hint.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |         a.push_str(\"bar\");\n help: consider changing this to be a mutable reference\n    |\n LL |     fn foo(mut a: &mut String) {\n-   |                   ~~~~~~~~~~~\n+   |                    +++\n \n error[E0596]: cannot borrow `*a` as mutable, as it is behind a `&` reference\n   --> $DIR/mut-arg-hint.rs:8:5\n@@ -18,7 +18,7 @@ LL |     a.push_str(\"foo\");\n help: consider changing this to be a mutable reference\n    |\n LL | pub fn foo<'a>(mut a: &'a mut String) {\n-   |                       ~~~~~~~~~~~~~~\n+   |                           +++\n \n error[E0596]: cannot borrow `*a` as mutable, as it is behind a `&` reference\n   --> $DIR/mut-arg-hint.rs:15:9\n@@ -29,7 +29,7 @@ LL |         a.push_str(\"foo\");\n help: consider changing this to be a mutable reference\n    |\n LL |     pub fn foo(mut a: &mut String) {\n-   |                       ~~~~~~~~~~~\n+   |                        +++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "c4960b0c28e786227d2ff8940216b9ba80f090e3", "filename": "tests/ui/specialization/min_specialization/specialize-associated-type.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize-associated-type.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,37 @@\n+// Another regression test for #109815.\n+\n+// check-pass\n+\n+#![feature(min_specialization)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_specialization_trait]\n+trait X {}\n+trait Z {\n+    type Assoc: X;\n+}\n+struct A<T>(T);\n+\n+impl X for () {}\n+\n+impl<T: X> Z for A<T> {\n+    type Assoc = ();\n+}\n+\n+trait MyFrom<T> {\n+    fn from(other: T) -> Self;\n+}\n+\n+impl<T> MyFrom<()> for T {\n+    default fn from(other: ()) -> T {\n+        panic!();\n+    }\n+}\n+\n+impl<T: X> MyFrom<<A<T> as Z>::Assoc> for T {\n+    fn from(other: ()) -> T {\n+        panic!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ef92254d4651c74eae9d664568e3ed10e40b0bba", "filename": "tests/ui/specialization/min_specialization/specialize_nothing.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_nothing.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,14 @@\n+#![feature(min_specialization)]\n+\n+trait Special {\n+    fn be_special();\n+}\n+\n+impl<T> Special for T {\n+    fn be_special() {}\n+}\n+\n+impl Special for usize {}\n+//~^ ERROR specialization impl does not specialize any associated items\n+\n+fn main() {}"}, {"sha": "65f73781cae22f0bf5811fe2564bedd7e2ea0e19", "filename": "tests/ui/specialization/min_specialization/specialize_nothing.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_nothing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_nothing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_nothing.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,14 @@\n+error: specialization impl does not specialize any associated items\n+  --> $DIR/specialize_nothing.rs:11:1\n+   |\n+LL | impl Special for usize {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: impl is a specialization of this impl\n+  --> $DIR/specialize_nothing.rs:7:1\n+   |\n+LL | impl<T> Special for T {\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "24e92a0abc33ba04914ec83143d79b9e0d6278a7", "filename": "tests/ui/specialization/min_specialization/specialize_on_type_error.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_type_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_type_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_type_error.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,33 @@\n+// A regression test for #109815.\n+\n+#![feature(min_specialization)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_specialization_trait]\n+trait X {}\n+trait Y: X {}\n+trait Z {\n+    type Assoc: Y;\n+}\n+struct A<T>(T);\n+\n+impl<T: X> Z for A<T> {}\n+//~^ ERROR not all trait items implemented\n+\n+trait MyFrom<T> {\n+    fn from(other: T) -> Self;\n+}\n+\n+impl<T> MyFrom<T> for T {\n+    default fn from(other: T) -> T {\n+        other\n+    }\n+}\n+\n+impl<T: X> MyFrom<<A<T> as Z>::Assoc> for T {\n+    fn from(other: <A<T> as Z>::Assoc) -> T {\n+        other\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "cc12302bd8cf14b0efb9bd25a3f20cc8d69f8029", "filename": "tests/ui/specialization/min_specialization/specialize_on_type_error.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_type_error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_type_error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_type_error.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,12 @@\n+error[E0046]: not all trait items implemented, missing: `Assoc`\n+  --> $DIR/specialize_on_type_error.rs:14:1\n+   |\n+LL |     type Assoc: Y;\n+   |     ------------- `Assoc` from trait\n+...\n+LL | impl<T: X> Z for A<T> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^ missing `Assoc` in implementation\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0046`."}, {"sha": "d90b81f717a6c38454cf2900f2aecda88e833c25", "filename": "tests/ui/specialization/min_specialization/specialize_with_generalize_lifetimes.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_with_generalize_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_with_generalize_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_with_generalize_lifetimes.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,50 @@\n+// Regression test for #79457.\n+\n+#![feature(min_specialization)]\n+\n+use std::any::Any;\n+\n+pub trait Tr {\n+    fn method(self) -> Box<dyn Any + 'static>;\n+    fn other(self);\n+}\n+\n+impl<T: Any + 'static> Tr for T {\n+    default fn method(self) -> Box<dyn Any + 'static> {\n+        Box::new(self)\n+    }\n+\n+    default fn other(self) {}\n+}\n+\n+impl<'a> Tr for &'a i32 {\n+    //~^ ERROR does not fulfill the required lifetime\n+    fn other(self) {}\n+}\n+\n+fn promote_to_static<'a>(i: &'a i32) -> &'static i32 {\n+    *i.method().downcast().unwrap()\n+}\n+\n+struct Wrapper<'a>(&'a i32);\n+\n+impl<'a> Tr for Wrapper<'a> {\n+    //~^ ERROR does not fulfill the required lifetime\n+    fn other(self) {}\n+}\n+\n+fn promote_to_static_2<'a>(w: Wrapper<'a>) -> Wrapper<'static> {\n+    *w.method().downcast().unwrap()\n+}\n+\n+fn main() {\n+    let i = Box::new(100_i32);\n+    let static_i: &'static i32 = promote_to_static(&*i);\n+    drop(i);\n+    println!(\"{}\", *static_i);\n+\n+    let j = Box::new(200_i32);\n+    let static_w: Wrapper<'static> = promote_to_static_2(Wrapper(&*j));\n+    drop(j);\n+    println!(\"{}\", *static_w.0);\n+}"}, {"sha": "2af75876d5b0a6bb9388b979f48583305a943e7e", "filename": "tests/ui/specialization/min_specialization/specialize_with_generalize_lifetimes.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_with_generalize_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_with_generalize_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_with_generalize_lifetimes.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,27 @@\n+error[E0477]: the type `&'a i32` does not fulfill the required lifetime\n+  --> $DIR/specialize_with_generalize_lifetimes.rs:20:1\n+   |\n+LL | impl<'a> Tr for &'a i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: type must satisfy the static lifetime as required by this binding\n+  --> $DIR/specialize_with_generalize_lifetimes.rs:12:15\n+   |\n+LL | impl<T: Any + 'static> Tr for T {\n+   |               ^^^^^^^\n+\n+error[E0477]: the type `Wrapper<'a>` does not fulfill the required lifetime\n+  --> $DIR/specialize_with_generalize_lifetimes.rs:31:1\n+   |\n+LL | impl<'a> Tr for Wrapper<'a> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: type must satisfy the static lifetime as required by this binding\n+  --> $DIR/specialize_with_generalize_lifetimes.rs:12:15\n+   |\n+LL | impl<T: Any + 'static> Tr for T {\n+   |               ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0477`."}, {"sha": "515cb9e12f858c4fedd9d35e3ce9e0b26802dc73", "filename": "tests/ui/str/str-array-assignment.stderr", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fstr%2Fstr-array-assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fstr%2Fstr-array-assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstr%2Fstr-array-assignment.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -10,10 +10,12 @@ error[E0308]: mismatched types\n   --> $DIR/str-array-assignment.rs:5:27\n    |\n LL |   let u: &str = if true { s[..2] } else { s };\n-   |                           ^^^^^^\n-   |                           |\n-   |                           expected `&str`, found `str`\n-   |                           help: consider borrowing here: `&s[..2]`\n+   |                           ^^^^^^ expected `&str`, found `str`\n+   |\n+help: consider borrowing here\n+   |\n+LL |   let u: &str = if true { &s[..2] } else { s };\n+   |                           +\n \n error[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> $DIR/str-array-assignment.rs:7:7\n@@ -33,11 +35,14 @@ error[E0308]: mismatched types\n   --> $DIR/str-array-assignment.rs:9:17\n    |\n LL |   let w: &str = s[..2];\n-   |          ----   ^^^^^^\n-   |          |      |\n-   |          |      expected `&str`, found `str`\n-   |          |      help: consider borrowing here: `&s[..2]`\n+   |          ----   ^^^^^^ expected `&str`, found `str`\n+   |          |\n    |          expected due to this\n+   |\n+help: consider borrowing here\n+   |\n+LL |   let w: &str = &s[..2];\n+   |                 +\n \n error: aborting due to 4 previous errors\n "}, {"sha": "2147d2d92e389b05208a872a16b9f8ace5a2e1a3", "filename": "tests/ui/suggestions/as-ref.stderr", "status": "modified", "additions": 56, "deletions": 32, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Fas-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Fas-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fas-ref.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,61 +2,73 @@ error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:7:29\n    |\n LL |     opt.map(|arg| takes_ref(arg));\n-   |         ---       --------- ^^^ expected `&Foo`, found `Foo`\n-   |         |         |\n-   |         |         arguments to this function are incorrect\n-   |         help: consider using `as_ref` instead: `as_ref().map`\n+   |                   --------- ^^^ expected `&Foo`, found `Foo`\n+   |                   |\n+   |                   arguments to this function are incorrect\n    |\n note: function defined here\n   --> $DIR/as-ref.rs:3:4\n    |\n LL | fn takes_ref(_: &Foo) {}\n    |    ^^^^^^^^^ -------\n+help: consider using `as_ref` instead\n+   |\n+LL |     opt.as_ref().map(|arg| takes_ref(arg));\n+   |         +++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:8:39\n    |\n LL |     opt.and_then(|arg| Some(takes_ref(arg)));\n-   |         --------            --------- ^^^ expected `&Foo`, found `Foo`\n-   |         |                   |\n-   |         |                   arguments to this function are incorrect\n-   |         help: consider using `as_ref` instead: `as_ref().and_then`\n+   |                             --------- ^^^ expected `&Foo`, found `Foo`\n+   |                             |\n+   |                             arguments to this function are incorrect\n    |\n note: function defined here\n   --> $DIR/as-ref.rs:3:4\n    |\n LL | fn takes_ref(_: &Foo) {}\n    |    ^^^^^^^^^ -------\n+help: consider using `as_ref` instead\n+   |\n+LL |     opt.as_ref().and_then(|arg| Some(takes_ref(arg)));\n+   |         +++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:10:29\n    |\n LL |     opt.map(|arg| takes_ref(arg));\n-   |         ---       --------- ^^^ expected `&Foo`, found `Foo`\n-   |         |         |\n-   |         |         arguments to this function are incorrect\n-   |         help: consider using `as_ref` instead: `as_ref().map`\n+   |                   --------- ^^^ expected `&Foo`, found `Foo`\n+   |                   |\n+   |                   arguments to this function are incorrect\n    |\n note: function defined here\n   --> $DIR/as-ref.rs:3:4\n    |\n LL | fn takes_ref(_: &Foo) {}\n    |    ^^^^^^^^^ -------\n+help: consider using `as_ref` instead\n+   |\n+LL |     opt.as_ref().map(|arg| takes_ref(arg));\n+   |         +++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:11:37\n    |\n LL |     opt.and_then(|arg| Ok(takes_ref(arg)));\n-   |         --------          --------- ^^^ expected `&Foo`, found `Foo`\n-   |         |                 |\n-   |         |                 arguments to this function are incorrect\n-   |         help: consider using `as_ref` instead: `as_ref().and_then`\n+   |                           --------- ^^^ expected `&Foo`, found `Foo`\n+   |                           |\n+   |                           arguments to this function are incorrect\n    |\n note: function defined here\n   --> $DIR/as-ref.rs:3:4\n    |\n LL | fn takes_ref(_: &Foo) {}\n    |    ^^^^^^^^^ -------\n+help: consider using `as_ref` instead\n+   |\n+LL |     opt.as_ref().and_then(|arg| Ok(takes_ref(arg)));\n+   |         +++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:13:29\n@@ -101,61 +113,73 @@ error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:22:42\n    |\n LL |     multiple_ref_opt.map(|arg| takes_ref(arg));\n-   |                      ---       --------- ^^^ expected `&Foo`, found `Foo`\n-   |                      |         |\n-   |                      |         arguments to this function are incorrect\n-   |                      help: consider using `as_ref` instead: `as_ref().map`\n+   |                                --------- ^^^ expected `&Foo`, found `Foo`\n+   |                                |\n+   |                                arguments to this function are incorrect\n    |\n note: function defined here\n   --> $DIR/as-ref.rs:3:4\n    |\n LL | fn takes_ref(_: &Foo) {}\n    |    ^^^^^^^^^ -------\n+help: consider using `as_ref` instead\n+   |\n+LL |     multiple_ref_opt.as_ref().map(|arg| takes_ref(arg));\n+   |                      +++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:23:52\n    |\n LL |     multiple_ref_opt.and_then(|arg| Some(takes_ref(arg)));\n-   |                      --------            --------- ^^^ expected `&Foo`, found `Foo`\n-   |                      |                   |\n-   |                      |                   arguments to this function are incorrect\n-   |                      help: consider using `as_ref` instead: `as_ref().and_then`\n+   |                                          --------- ^^^ expected `&Foo`, found `Foo`\n+   |                                          |\n+   |                                          arguments to this function are incorrect\n    |\n note: function defined here\n   --> $DIR/as-ref.rs:3:4\n    |\n LL | fn takes_ref(_: &Foo) {}\n    |    ^^^^^^^^^ -------\n+help: consider using `as_ref` instead\n+   |\n+LL |     multiple_ref_opt.as_ref().and_then(|arg| Some(takes_ref(arg)));\n+   |                      +++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:25:45\n    |\n LL |     multiple_ref_result.map(|arg| takes_ref(arg));\n-   |                         ---       --------- ^^^ expected `&Foo`, found `Foo`\n-   |                         |         |\n-   |                         |         arguments to this function are incorrect\n-   |                         help: consider using `as_ref` instead: `as_ref().map`\n+   |                                   --------- ^^^ expected `&Foo`, found `Foo`\n+   |                                   |\n+   |                                   arguments to this function are incorrect\n    |\n note: function defined here\n   --> $DIR/as-ref.rs:3:4\n    |\n LL | fn takes_ref(_: &Foo) {}\n    |    ^^^^^^^^^ -------\n+help: consider using `as_ref` instead\n+   |\n+LL |     multiple_ref_result.as_ref().map(|arg| takes_ref(arg));\n+   |                         +++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/as-ref.rs:26:53\n    |\n LL |     multiple_ref_result.and_then(|arg| Ok(takes_ref(arg)));\n-   |                         --------          --------- ^^^ expected `&Foo`, found `Foo`\n-   |                         |                 |\n-   |                         |                 arguments to this function are incorrect\n-   |                         help: consider using `as_ref` instead: `as_ref().and_then`\n+   |                                           --------- ^^^ expected `&Foo`, found `Foo`\n+   |                                           |\n+   |                                           arguments to this function are incorrect\n    |\n note: function defined here\n   --> $DIR/as-ref.rs:3:4\n    |\n LL | fn takes_ref(_: &Foo) {}\n    |    ^^^^^^^^^ -------\n+help: consider using `as_ref` instead\n+   |\n+LL |     multiple_ref_result.as_ref().and_then(|arg| Ok(takes_ref(arg)));\n+   |                         +++++++++\n \n error: aborting due to 11 previous errors\n "}, {"sha": "6f3c78443f8293d097885a0f1267904afcb1f326", "filename": "tests/ui/suggestions/issue-68049-2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Fissue-68049-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Fissue-68049-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-68049-2.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -4,18 +4,18 @@ error[E0594]: cannot assign to `*input`, which is behind a `&` reference\n LL |       *input = self.0;\n    |       ^^^^^^^^^^^^^^^ `input` is a `&` reference, so the data it refers to cannot be written\n    |\n-help: consider changing that to be a mutable reference\n+help: consider changing this to be a mutable reference\n    |\n-LL |   fn example(&self, input: &mut i32); // should suggest here\n-   |                            ~~~~~~~~\n+LL |   fn example(&self, input: &mut i32) { // should not suggest here\n+   |                             +++\n \n error[E0594]: cannot assign to `self.0`, which is behind a `&` reference\n   --> $DIR/issue-68049-2.rs:17:5\n    |\n LL |     self.0 += *input;\n    |     ^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be written\n    |\n-help: consider changing that to be a mutable reference\n+help: consider changing this to be a mutable reference\n    |\n LL |   fn example(&mut self, input: &i32); // should suggest here\n    |              ~~~~~~~~~"}, {"sha": "730f5fa1b5e3de5455c4b092d78cc2eed0b15bd5", "filename": "tests/ui/suggestions/suggest-ref-macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Fsuggest-ref-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Fsuggest-ref-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-ref-macro.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -14,7 +14,7 @@ macro_rules! bla {\n     () => {\n         x(123);\n         //~^ ERROR mismatched types\n-        //~| SUGGESTION &mut 123\n+        //~| SUGGESTION &mut\n     };\n     ($v:expr) => {\n         x($v)\n@@ -25,5 +25,5 @@ fn main() {\n     bla!();\n     bla!(456);\n     //~^ ERROR mismatched types\n-    //~| SUGGESTION &mut 456\n+    //~| SUGGESTION &mut\n }"}, {"sha": "08bc9e86a50f87534a026522e2c1818457cfaf04", "filename": "tests/ui/suggestions/suggest-ref-macro.stderr", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Fsuggest-ref-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Fsuggest-ref-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-ref-macro.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -18,10 +18,8 @@ error[E0308]: mismatched types\n   --> $DIR/suggest-ref-macro.rs:15:11\n    |\n LL |         x(123);\n-   |         - ^^^\n-   |         | |\n-   |         | expected `&mut i32`, found integer\n-   |         | help: consider mutably borrowing here: `&mut 123`\n+   |         - ^^^ expected `&mut i32`, found integer\n+   |         |\n    |         arguments to this function are incorrect\n ...\n LL |     bla!();\n@@ -33,6 +31,10 @@ note: function defined here\n LL | fn x(_: &mut i32) {}\n    |    ^ -----------\n    = note: this error originates in the macro `bla` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider mutably borrowing here\n+   |\n+LL |         x(&mut 123);\n+   |           ++++\n \n error[E0308]: mismatched types\n   --> $DIR/suggest-ref-macro.rs:26:10\n@@ -41,16 +43,17 @@ LL |         x($v)\n    |         - arguments to this function are incorrect\n ...\n LL |     bla!(456);\n-   |          ^^^\n-   |          |\n-   |          expected `&mut i32`, found integer\n-   |          help: consider mutably borrowing here: `&mut 456`\n+   |          ^^^ expected `&mut i32`, found integer\n    |\n note: function defined here\n   --> $DIR/suggest-ref-macro.rs:11:4\n    |\n LL | fn x(_: &mut i32) {}\n    |    ^ -----------\n+help: consider mutably borrowing here\n+   |\n+LL |     bla!(&mut 456);\n+   |          ++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "b40439b8e372c65255e397b3a636d1e0f2ba4d08", "filename": "tests/ui/suggestions/suggest-ref-mut.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Fsuggest-ref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Fsuggest-ref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-ref-mut.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -12,19 +12,16 @@ impl X {\n fn main() {\n     let ref foo = 16;\n     //~^ HELP\n-    //~| SUGGESTION ref mut foo\n     *foo = 32;\n     //~^ ERROR\n     if let Some(ref bar) = Some(16) {\n         //~^ HELP\n-        //~| SUGGESTION ref mut bar\n         *bar = 32;\n         //~^ ERROR\n     }\n     match 16 {\n         ref quo => { *quo = 32; },\n         //~^ ERROR\n         //~| HELP\n-        //~| SUGGESTION ref mut quo\n     }\n }"}, {"sha": "cc00022ab8e3d552bdca107b232e4b21c0c71076", "filename": "tests/ui/suggestions/suggest-ref-mut.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Fsuggest-ref-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Fsuggest-ref-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-ref-mut.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -10,37 +10,37 @@ LL |     fn zap(&mut self) {\n    |            ~~~~~~~~~\n \n error[E0594]: cannot assign to `*foo`, which is behind a `&` reference\n-  --> $DIR/suggest-ref-mut.rs:16:5\n+  --> $DIR/suggest-ref-mut.rs:15:5\n    |\n LL |     *foo = 32;\n    |     ^^^^^^^^^ `foo` is a `&` reference, so the data it refers to cannot be written\n    |\n help: consider changing this to be a mutable reference\n    |\n LL |     let ref mut foo = 16;\n-   |         ~~~~~~~~~~~\n+   |             +++\n \n error[E0594]: cannot assign to `*bar`, which is behind a `&` reference\n-  --> $DIR/suggest-ref-mut.rs:21:9\n+  --> $DIR/suggest-ref-mut.rs:19:9\n    |\n LL |         *bar = 32;\n    |         ^^^^^^^^^ `bar` is a `&` reference, so the data it refers to cannot be written\n    |\n help: consider changing this to be a mutable reference\n    |\n LL |     if let Some(ref mut bar) = Some(16) {\n-   |                 ~~~~~~~~~~~\n+   |                     +++\n \n error[E0594]: cannot assign to `*quo`, which is behind a `&` reference\n-  --> $DIR/suggest-ref-mut.rs:25:22\n+  --> $DIR/suggest-ref-mut.rs:23:22\n    |\n LL |         ref quo => { *quo = 32; },\n    |                      ^^^^^^^^^ `quo` is a `&` reference, so the data it refers to cannot be written\n    |\n help: consider changing this to be a mutable reference\n    |\n LL |         ref mut quo => { *quo = 32; },\n-   |         ~~~~~~~~~~~\n+   |             +++\n \n error: aborting due to 4 previous errors\n "}, {"sha": "e3d03b6f22ad6a01ce3bfb7feaebfb316bc8d338", "filename": "tests/ui/suggestions/type-ascription-instead-of-let.fixed", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.fixed?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,11 @@\n+// run-rustfix\n+\n+fn fun(x: i32) -> i32 { x }\n+\n+fn main() {\n+    let _closure_annotated = |value: i32| -> i32 {\n+        let temp: i32 = fun(5i32);\n+        //~^ ERROR expected identifier, found `:`\n+        temp + value + 1\n+    };\n+}"}, {"sha": "6e1c86f96711923fb9d3447d9459e9af1cb5b1d8", "filename": "tests/ui/suggestions/type-ascription-instead-of-let.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1,7 +1,9 @@\n+// run-rustfix\n+\n fn fun(x: i32) -> i32 { x }\n \n fn main() {\n-    let closure_annotated = |value: i32| -> i32 {\n+    let _closure_annotated = |value: i32| -> i32 {\n         temp: i32 = fun(5i32);\n         //~^ ERROR expected identifier, found `:`\n         temp + value + 1"}, {"sha": "065b1f4d3538e9e44398ad4ae358f893adffefd7", "filename": "tests/ui/suggestions/type-ascription-instead-of-let.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -1,8 +1,13 @@\n error: expected identifier, found `:`\n-  --> $DIR/type-ascription-instead-of-let.rs:5:13\n+  --> $DIR/type-ascription-instead-of-let.rs:7:13\n    |\n LL |         temp: i32 = fun(5i32);\n    |             ^ expected identifier\n+   |\n+help: you might have meant to introduce a new binding\n+   |\n+LL |         let temp: i32 = fun(5i32);\n+   |         +++\n \n error: aborting due to previous error\n "}, {"sha": "c054ddb893d5c3e978d8361157e43c8f31df140e", "filename": "tests/ui/trivial-bounds/trivial-bounds-inconsistent-copy-reborrow.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-copy-reborrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-copy-reborrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-copy-reborrow.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -7,7 +7,7 @@ LL |     *t\n help: consider changing this to be a mutable reference\n    |\n LL | fn reborrow_mut<'a>(t: &'a mut &'a mut i32) -> &'a mut i32 where &'a mut i32: Copy {\n-   |                        ~~~~~~~~~~~~~~~~~~~\n+   |                            +++\n \n error[E0596]: cannot borrow `**t` as mutable, as it is behind a `&` reference\n   --> $DIR/trivial-bounds-inconsistent-copy-reborrow.rs:10:6\n@@ -18,7 +18,7 @@ LL |     {*t}\n help: consider changing this to be a mutable reference\n    |\n LL | fn copy_reborrow_mut<'a>(t: &'a mut &'a mut i32) -> &'a mut i32 where &'a mut i32: Copy {\n-   |                             ~~~~~~~~~~~~~~~~~~~\n+   |                                 +++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d64013c8c838557d5e8d609b45fdb644a252777b", "filename": "tests/ui/type/missing-let-in-binding-2.fixed", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fmissing-let-in-binding-2.fixed?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,5 @@\n+// run-rustfix\n+\n+fn main() {\n+    let _v: Vec<i32> = vec![1, 2, 3]; //~ ERROR expected identifier, found `:`\n+}"}, {"sha": "f95f7bef2158568426c3d7fbb132330ccda7598f", "filename": "tests/ui/type/missing-let-in-binding-2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fmissing-let-in-binding-2.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,5 @@\n+// run-rustfix\n+\n+fn main() {\n+    _v: Vec<i32> = vec![1, 2, 3]; //~ ERROR expected identifier, found `:`\n+}"}, {"sha": "2e10125943e7577734eda243ce4dae85c61c0408", "filename": "tests/ui/type/missing-let-in-binding-2.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fmissing-let-in-binding-2.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,13 @@\n+error: expected identifier, found `:`\n+  --> $DIR/missing-let-in-binding-2.rs:4:7\n+   |\n+LL |     _v: Vec<i32> = vec![1, 2, 3];\n+   |       ^ expected identifier\n+   |\n+help: you might have meant to introduce a new binding\n+   |\n+LL |     let _v: Vec<i32> = vec![1, 2, 3];\n+   |     +++\n+\n+error: aborting due to previous error\n+"}, {"sha": "d56b1393336b18030ba7614c03214a4c7e816372", "filename": "tests/ui/type/missing-let-in-binding-3.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fmissing-let-in-binding-3.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,5 @@\n+struct A {\n+    : :u8, //~ ERROR expected identifier, found `:`\n+}\n+\n+fn main() {}"}, {"sha": "ca828ce37eb7afbbe7b6828fd679a33777dd894e", "filename": "tests/ui/type/missing-let-in-binding-3.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fmissing-let-in-binding-3.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,10 @@\n+error: expected identifier, found `:`\n+  --> $DIR/missing-let-in-binding-3.rs:2:5\n+   |\n+LL | struct A {\n+   |        - while parsing this struct\n+LL |     : :u8,\n+   |     ^ expected identifier\n+\n+error: aborting due to previous error\n+"}, {"sha": "879a6fedcd677065bfe77b9c3b443972591bb1d4", "filename": "tests/ui/type/missing-let-in-binding-4.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fmissing-let-in-binding-4.rs?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,5 @@\n+struct A {\n+    : u8 =, //~ ERROR expected identifier, found `:`\n+}\n+\n+fn main() {}"}, {"sha": "e6f173a6658701b9f9c67388bf4664f94c2f5939", "filename": "tests/ui/type/missing-let-in-binding-4.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Fmissing-let-in-binding-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fmissing-let-in-binding-4.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -0,0 +1,10 @@\n+error: expected identifier, found `:`\n+  --> $DIR/missing-let-in-binding-4.rs:2:5\n+   |\n+LL | struct A {\n+   |        - while parsing this struct\n+LL |     : u8 =,\n+   |     ^ expected identifier\n+\n+error: aborting due to previous error\n+"}, {"sha": "ce6f29d354fd16c32fc8662bce88e67043e801a4", "filename": "tests/ui/type/type-mismatch.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Ftype-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftype%2Ftype-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-mismatch.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -378,10 +378,8 @@ error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:47:23\n    |\n LL |     want::<&Foo<foo>>(f);\n-   |     ----------------- ^\n-   |     |                 |\n-   |     |                 expected `&Foo<foo>`, found `Foo<foo>`\n-   |     |                 help: consider borrowing here: `&f`\n+   |     ----------------- ^ expected `&Foo<foo>`, found `Foo<foo>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&Foo<foo>`\n@@ -391,6 +389,10 @@ note: function defined here\n    |\n LL | fn want<T>(t: T) {}\n    |    ^^^^    ----\n+help: consider borrowing here\n+   |\n+LL |     want::<&Foo<foo>>(&f);\n+   |                       +\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:48:26\n@@ -556,10 +558,8 @@ error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:61:26\n    |\n LL |     want::<&Foo<foo, B>>(f);\n-   |     -------------------- ^\n-   |     |                    |\n-   |     |                    expected `&Foo<foo, B>`, found `Foo<foo, B>`\n-   |     |                    help: consider borrowing here: `&f`\n+   |     -------------------- ^ expected `&Foo<foo, B>`, found `Foo<foo, B>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&Foo<foo, B>`\n@@ -569,6 +569,10 @@ note: function defined here\n    |\n LL | fn want<T>(t: T) {}\n    |    ^^^^    ----\n+help: consider borrowing here\n+   |\n+LL |     want::<&Foo<foo, B>>(&f);\n+   |                          +\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:65:19"}, {"sha": "f9cdb280e276a320071154514c5fa89f6d2a9ac0", "filename": "tests/ui/typeck/bad-index-due-to-nested.stderr", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-index-due-to-nested.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -42,27 +42,29 @@ error[E0308]: mismatched types\n LL | fn index<'a, K, V>(map: &'a HashMap<K, V>, k: K) -> &'a V {\n    |              - this type parameter\n LL |     map[k]\n-   |         ^\n-   |         |\n-   |         expected `&K`, found type parameter `K`\n-   |         help: consider borrowing here: `&k`\n+   |         ^ expected `&K`, found type parameter `K`\n    |\n    = note:   expected reference `&K`\n            found type parameter `K`\n+help: consider borrowing here\n+   |\n+LL |     map[&k]\n+   |         +\n \n error[E0308]: mismatched types\n   --> $DIR/bad-index-due-to-nested.rs:20:5\n    |\n LL | fn index<'a, K, V>(map: &'a HashMap<K, V>, k: K) -> &'a V {\n    |                 - this type parameter               ----- expected `&'a V` because of return type\n LL |     map[k]\n-   |     ^^^^^^\n-   |     |\n-   |     expected `&V`, found type parameter `V`\n-   |     help: consider borrowing here: `&map[k]`\n+   |     ^^^^^^ expected `&V`, found type parameter `V`\n    |\n    = note:   expected reference `&'a V`\n            found type parameter `V`\n+help: consider borrowing here\n+   |\n+LL |     &map[k]\n+   |     +\n \n error: aborting due to 4 previous errors\n "}, {"sha": "b9b3a5fe5ec8f086c033a2389e1c2179fa0ddd1c", "filename": "tests/ui/typeck/bad-type-in-vec-contains.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -2,16 +2,18 @@ error[E0308]: mismatched types\n   --> $DIR/bad-type-in-vec-contains.rs:5:21\n    |\n LL |     primes.contains(3);\n-   |            -------- ^\n-   |            |        |\n-   |            |        expected `&_`, found integer\n-   |            |        help: consider borrowing here: `&3`\n+   |            -------- ^ expected `&_`, found integer\n+   |            |\n    |            arguments to this method are incorrect\n    |\n    = note: expected reference `&_`\n                    found type `{integer}`\n note: method defined here\n   --> $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+help: consider borrowing here\n+   |\n+LL |     primes.contains(&3);\n+   |                     +\n \n error: aborting due to previous error\n "}, {"sha": "8ecb8b680160b6e880c4c031ea50449d6bb079d9", "filename": "tests/ui/typeck/issue-13853.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftypeck%2Fissue-13853.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Ftypeck%2Fissue-13853.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-13853.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -20,10 +20,8 @@ error[E0308]: mismatched types\n   --> $DIR/issue-13853.rs:37:13\n    |\n LL |     iterate(graph);\n-   |     ------- ^^^^^\n-   |     |       |\n-   |     |       expected `&_`, found `Vec<Stuff>`\n-   |     |       help: consider borrowing here: `&graph`\n+   |     ------- ^^^^^ expected `&_`, found `Vec<Stuff>`\n+   |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected reference `&_`\n@@ -33,6 +31,10 @@ note: function defined here\n    |\n LL | fn iterate<N: Node, G: Graph<N>>(graph: &G) {\n    |    ^^^^^^^                       ---------\n+help: consider borrowing here\n+   |\n+LL |     iterate(&graph);\n+   |             +\n \n error: aborting due to 3 previous errors\n "}, {"sha": "8741b35cdcff8bf786c64fc3c38fd87c0f02dc79", "filename": "tests/ui/unsized-locals/suggest-borrow.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Funsized-locals%2Fsuggest-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecd3dbab4ed82abfa05e22069261e565239449cf/tests%2Fui%2Funsized-locals%2Fsuggest-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsized-locals%2Fsuggest-borrow.stderr?ref=ecd3dbab4ed82abfa05e22069261e565239449cf", "patch": "@@ -16,11 +16,14 @@ error[E0308]: mismatched types\n   --> $DIR/suggest-borrow.rs:3:20\n    |\n LL |     let x: &[u8] = vec!(1, 2, 3)[..];\n-   |            -----   ^^^^^^^^^^^^^^^^^\n-   |            |       |\n-   |            |       expected `&[u8]`, found `[{integer}]`\n-   |            |       help: consider borrowing here: `&vec!(1, 2, 3)[..]`\n+   |            -----   ^^^^^^^^^^^^^^^^^ expected `&[u8]`, found `[{integer}]`\n+   |            |\n    |            expected due to this\n+   |\n+help: consider borrowing here\n+   |\n+LL |     let x: &[u8] = &vec!(1, 2, 3)[..];\n+   |                    +\n \n error[E0308]: mismatched types\n   --> $DIR/suggest-borrow.rs:4:19"}]}