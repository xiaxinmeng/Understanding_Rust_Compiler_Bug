{"sha": "2375a79152b8a6554c3e97a3f127fedd75f7495f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNzVhNzkxNTJiOGE2NTU0YzNlOTdhM2YxMjdmZWRkNzVmNzQ5NWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-05T11:17:42Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-06T22:17:48Z"}, "message": "Implement impl reachability rules. This is a [breaking-change]. Type\nparameters on impls must now also appear in the trait ref, self type,\nor some associated type declared on the impl. This ensures that they\nare constrianed in some way and that the semantics of the trait system\nare well-defined (always a good thing).\n\nThere are three major ways to fix this error:\n\n1. Convert the trait to use associated types; most often the type\n   parameters are not constrained because they are in fact outputs of\n   the impl.\n\n2. Move the type parameters to methods.\n\n3. Add an additional type parameter to the self type or trait so that\n   the unused parameter can appear there.\n\nIn some cases, it is not possible to fix the impl because the trait\ndefinition needs to be changed first (and that may be out of your\ncontrol). In that case, for the time being, you can opt out of these\nrules by using `#[old_impl_check]` on the impl and adding a\n`#![feature(old_impl_check)]` to your crate declaration.", "tree": {"sha": "5e69902cf0c81942c2e79d6dba326650680b689f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e69902cf0c81942c2e79d6dba326650680b689f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2375a79152b8a6554c3e97a3f127fedd75f7495f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2375a79152b8a6554c3e97a3f127fedd75f7495f", "html_url": "https://github.com/rust-lang/rust/commit/2375a79152b8a6554c3e97a3f127fedd75f7495f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2375a79152b8a6554c3e97a3f127fedd75f7495f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ed7f067dc0319cd9e7bb6a8253ba031d0bdf1f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ed7f067dc0319cd9e7bb6a8253ba031d0bdf1f3", "html_url": "https://github.com/rust-lang/rust/commit/3ed7f067dc0319cd9e7bb6a8253ba031d0bdf1f3"}], "stats": {"total": 111, "additions": 110, "deletions": 1}, "files": [{"sha": "69da0f9a2109b2c6a082b0f4070a2299a765a64e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2375a79152b8a6554c3e97a3f127fedd75f7495f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2375a79152b8a6554c3e97a3f127fedd75f7495f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=2375a79152b8a6554c3e97a3f127fedd75f7495f", "patch": "@@ -669,6 +669,7 @@ impl LintPass for UnusedAttributes {\n \n             // FIXME: #19470 this shouldn't be needed forever\n             \"old_orphan_check\",\n+            \"old_impl_check\",\n         ];\n \n         static CRATE_ATTRS: &'static [&'static str] = &["}, {"sha": "137f33d301d1921487e644cea62cd71c9293fbf6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/2375a79152b8a6554c3e97a3f127fedd75f7495f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2375a79152b8a6554c3e97a3f127fedd75f7495f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2375a79152b8a6554c3e97a3f127fedd75f7495f", "patch": "@@ -35,7 +35,7 @@ use middle::lang_items::SizedTraitLangItem;\n use middle::region;\n use middle::resolve_lifetime;\n use middle::subst;\n-use middle::subst::{Substs};\n+use middle::subst::{Substs, TypeSpace};\n use middle::ty::{AsPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use middle::ty::{self, RegionEscape, Ty, TypeScheme};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n@@ -47,6 +47,7 @@ use util::ppaux;\n use util::ppaux::{Repr,UserString};\n use write_ty_to_tcx;\n \n+use std::collections::HashSet;\n use std::rc::Rc;\n \n use syntax::abi;\n@@ -644,6 +645,10 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                                                Some(selfty),\n                                                None);\n             }\n+\n+            enforce_impl_ty_params_are_constrained(ccx.tcx,\n+                                                   generics,\n+                                                   local_def(it.id));\n         },\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n             let trait_def = trait_def_of_item(ccx, it);\n@@ -1605,3 +1610,96 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         })\n     }\n }\n+\n+/// Checks that all the type parameters on an impl\n+fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                ast_generics: &ast::Generics,\n+                                                impl_def_id: ast::DefId)\n+{\n+    let impl_scheme = ty::lookup_item_type(tcx, impl_def_id);\n+    let impl_trait_ref = ty::impl_trait_ref(tcx, impl_def_id);\n+\n+    // The trait reference is an input, so find all type parameters\n+    // reachable from there, to start (if this is an inherent impl,\n+    // then just examine the self type).\n+    let mut input_parameters: HashSet<_> =\n+        impl_trait_ref.iter()\n+                      .flat_map(|t| t.input_types().iter()) // Types in trait ref, if any\n+                      .chain(Some(impl_scheme.ty).iter())  // Self type, always\n+                      .flat_map(|t| t.walk())\n+                      .filter_map(to_opt_param_ty)\n+                      .collect();\n+\n+    loop {\n+        let num_inputs = input_parameters.len();\n+\n+        let mut projection_predicates =\n+            impl_scheme.generics.predicates\n+            .iter()\n+            .filter_map(|predicate| {\n+                match *predicate {\n+                    // Ignore higher-ranked binders. For the purposes\n+                    // of this check, they don't matter because they\n+                    // only affect named regions, and we're just\n+                    // concerned about type parameters here.\n+                    ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n+                    _ => None,\n+                }\n+            });\n+\n+        for projection in projection_predicates {\n+            // Special case: watch out for some kind of sneaky attempt\n+            // to project out an associated type defined by this very trait.\n+            if Some(projection.projection_ty.trait_ref.clone()) == impl_trait_ref {\n+                continue;\n+            }\n+\n+            let relies_only_on_inputs =\n+                projection.projection_ty.trait_ref.input_types().iter()\n+                .flat_map(|t| t.walk())\n+                .filter_map(to_opt_param_ty)\n+                .all(|t| input_parameters.contains(&t));\n+\n+            if relies_only_on_inputs {\n+                input_parameters.extend(\n+                    projection.ty.walk().filter_map(to_opt_param_ty));\n+            }\n+        }\n+\n+        if input_parameters.len() == num_inputs {\n+            break;\n+        }\n+    }\n+\n+    for (index, ty_param) in ast_generics.ty_params.iter().enumerate() {\n+        let param_ty = ty::ParamTy { space: TypeSpace,\n+                                     idx: index as u32,\n+                                     name: ty_param.ident.name };\n+        if !input_parameters.contains(&param_ty) {\n+            if ty::has_attr(tcx, impl_def_id, \"old_impl_check\") {\n+                tcx.sess.span_warn(\n+                    ty_param.span,\n+                    format!(\"the type parameter `{}` is not constrained by the \\\n+                             impl trait, self type, or predicates\",\n+                            param_ty.user_string(tcx)).as_slice());\n+            } else {\n+                tcx.sess.span_err(\n+                    ty_param.span,\n+                    format!(\"the type parameter `{}` is not constrained by the \\\n+                             impl trait, self type, or predicates\",\n+                            param_ty.user_string(tcx)).as_slice());\n+                tcx.sess.span_help(\n+                    ty_param.span,\n+                    format!(\"you can temporarily opt out of this rule by placing \\\n+                             the `#[old_impl_check]` attribute on the impl\").as_slice());\n+            }\n+        }\n+    }\n+\n+    fn to_opt_param_ty<'tcx>(ty: Ty<'tcx>) -> Option<ty::ParamTy> {\n+        match ty.sty {\n+            ty::ty_param(ref d) => Some(d.clone()),\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "8132c9fe78b6746e99134c8ba6a20f5abb084051", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2375a79152b8a6554c3e97a3f127fedd75f7495f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2375a79152b8a6554c3e97a3f127fedd75f7495f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=2375a79152b8a6554c3e97a3f127fedd75f7495f", "patch": "@@ -86,6 +86,9 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     // A way to temporarily opt out of the new orphan rules. This will *never* be accepted.\n     (\"old_orphan_check\", Deprecated),\n \n+    // A way to temporarily opt out of the new impl rules. This will *never* be accepted.\n+    (\"old_impl_check\", Deprecated),\n+\n     // OIBIT specific features\n     (\"optin_builtin_traits\", Active),\n \n@@ -294,6 +297,13 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                         i.span,\n                         \"the new orphan check rules will eventually be strictly enforced\");\n                 }\n+\n+                if attr::contains_name(i.attrs[],\n+                                       \"old_impl_check\") {\n+                    self.gate_feature(\"old_impl_check\",\n+                                      i.span,\n+                                      \"`#[old_impl_check]` will be removed in the future\");\n+                }\n             }\n \n             _ => {}"}]}