{"sha": "dfcad8250946709e3e28311300057ada7bc98c33", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmY2FkODI1MDk0NjcwOWUzZTI4MzExMzAwMDU3YWRhN2JjOThjMzM=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-23T21:48:33Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-12-27T18:21:16Z"}, "message": "Add builtin impls for `Sized` in `chalk_context::program_clauses`", "tree": {"sha": "7671dae260e7b92a384e96c324faf8c05ac9ff52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7671dae260e7b92a384e96c324faf8c05ac9ff52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfcad8250946709e3e28311300057ada7bc98c33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfcad8250946709e3e28311300057ada7bc98c33", "html_url": "https://github.com/rust-lang/rust/commit/dfcad8250946709e3e28311300057ada7bc98c33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfcad8250946709e3e28311300057ada7bc98c33/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f488b945e6ff738f2fd0395c8505e373cac64f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f488b945e6ff738f2fd0395c8505e373cac64f5", "html_url": "https://github.com/rust-lang/rust/commit/6f488b945e6ff738f2fd0395c8505e373cac64f5"}], "stats": {"total": 151, "additions": 150, "deletions": 1}, "files": [{"sha": "b604f140762f43bed87e36baa1e556b2a80e6212", "filename": "src/librustc_traits/chalk_context/program_clauses.rs", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/dfcad8250946709e3e28311300057ada7bc98c33/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfcad8250946709e3e28311300057ada7bc98c33/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs?ref=dfcad8250946709e3e28311300057ada7bc98c33", "patch": "@@ -10,6 +10,7 @@ use rustc::traits::{\n     Environment,\n };\n use rustc::ty;\n+use rustc::ty::subst::{Substs, Subst};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc_target::spec::abi;\n@@ -48,6 +49,126 @@ fn assemble_clauses_from_assoc_ty_values<'tcx>(\n     });\n }\n \n+fn assemble_builtin_sized_impls<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    sized_def_id: DefId,\n+    ty: ty::Ty<'tcx>,\n+    clauses: &mut Vec<Clause<'tcx>>\n+) {\n+    let mut push_builtin_impl = |ty: ty::Ty<'tcx>, nested: &[ty::Ty<'tcx>]| {\n+        let clause = ProgramClause {\n+            goal: ty::TraitPredicate {\n+                trait_ref: ty::TraitRef {\n+                    def_id: sized_def_id,\n+                    substs: tcx.mk_substs_trait(ty, &[]),\n+                },\n+            }.lower(),\n+            hypotheses: tcx.mk_goals(\n+                nested.iter()\n+                    .cloned()\n+                    .map(|nested_ty| ty::TraitRef {\n+                        def_id: sized_def_id,\n+                        substs: tcx.mk_substs_trait(nested_ty, &[]),\n+                    })\n+                    .map(|trait_ref| ty::TraitPredicate { trait_ref })\n+                    .map(|pred| GoalKind::DomainGoal(pred.lower()))\n+                    .map(|goal_kind| tcx.mk_goal(goal_kind))\n+            ),\n+            category: ProgramClauseCategory::Other,\n+        };\n+        // Bind innermost bound vars that may exist in `ty` and `nested`.\n+        clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n+    };\n+\n+    match &ty.sty {\n+        // Non parametric primitive types.\n+        ty::Bool |\n+        ty::Char |\n+        ty::Int(..) |\n+        ty::Uint(..) |\n+        ty::Float(..) |\n+        ty::Error |\n+        ty::Never => push_builtin_impl(ty, &[]),\n+\n+        // These ones are always `Sized`.\n+        &ty::Array(_, length) => {\n+            push_builtin_impl(tcx.mk_ty(ty::Array(generic_types::bound(tcx, 0), length)), &[]);\n+        }\n+        ty::RawPtr(ptr) => {\n+            push_builtin_impl(generic_types::raw_ptr(tcx, ptr.mutbl), &[]);\n+        }\n+        &ty::Ref(_, _, mutbl) => {\n+            push_builtin_impl(generic_types::ref_ty(tcx, mutbl), &[]);\n+        }\n+        ty::FnPtr(fn_ptr) => {\n+            let fn_ptr = fn_ptr.skip_binder();\n+            let fn_ptr = generic_types::fn_ptr(\n+                tcx,\n+                fn_ptr.inputs_and_output.len(),\n+                fn_ptr.variadic,\n+                fn_ptr.unsafety,\n+                fn_ptr.abi\n+            );\n+            push_builtin_impl(fn_ptr, &[]);\n+        }\n+        &ty::FnDef(def_id, ..) => {\n+            push_builtin_impl(generic_types::fn_def(tcx, def_id), &[]);\n+        }\n+        &ty::Closure(def_id, ..) => {\n+            push_builtin_impl(generic_types::closure(tcx, def_id), &[]);\n+        }\n+        &ty::Generator(def_id, ..) => {\n+            push_builtin_impl(generic_types::generator(tcx, def_id), &[]);\n+        }\n+\n+        // `Sized` if the last type is `Sized` (because else we will get a WF error anyway).\n+        &ty::Tuple(type_list) => {\n+            let type_list = generic_types::type_list(tcx, type_list.len());\n+            push_builtin_impl(tcx.mk_ty(ty::Tuple(type_list)), &**type_list);\n+        }\n+\n+        // Struct def\n+        ty::Adt(adt_def, _) => {\n+            let substs = Substs::bound_vars_for_item(tcx, adt_def.did);\n+            let adt = tcx.mk_ty(ty::Adt(adt_def, substs));\n+            let sized_constraint = adt_def.sized_constraint(tcx)\n+                .iter()\n+                .map(|ty| ty.subst(tcx, substs))\n+                .collect::<Vec<_>>();\n+            push_builtin_impl(adt, &sized_constraint);\n+        }\n+\n+        // Artificially trigger an ambiguity.\n+        ty::Infer(..) => {\n+            // Everybody can find at least two types to unify against:\n+            // general ty vars, int vars and float vars.\n+            push_builtin_impl(tcx.types.i32, &[]);\n+            push_builtin_impl(tcx.types.u32, &[]);\n+            push_builtin_impl(tcx.types.f32, &[]);\n+            push_builtin_impl(tcx.types.f64, &[]);\n+        }\n+\n+        ty::Projection(_projection_ty) => {\n+            // FIXME: add builtin impls from the associated type values found in\n+            // trait impls of `projection_ty.trait_ref(tcx)`.\n+        }\n+\n+        // The `Sized` bound can only come from the environment.\n+        ty::Param(..) |\n+        ty::Placeholder(..) |\n+        ty::UnnormalizedProjection(..) => (),\n+\n+        // Definitely not `Sized`.\n+        ty::Foreign(..) |\n+        ty::Str |\n+        ty::Slice(..) |\n+        ty::Dynamic(..) |\n+        ty::Opaque(..) => (),\n+\n+        ty::Bound(..) |\n+        ty::GeneratorWitness(..) => bug!(\"unexpected type {:?}\", ty),\n+    }\n+}\n \n fn wf_clause_for_raw_ptr<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n@@ -236,12 +357,22 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n                 // * the trait decl (rule `Implemented-From-Env`)\n \n                 let mut clauses = vec![];\n+\n                 assemble_clauses_from_impls(\n                     self.infcx.tcx,\n                     trait_predicate.def_id(),\n                     &mut clauses\n                 );\n \n+                if Some(trait_predicate.def_id()) == self.infcx.tcx.lang_items().sized_trait() {\n+                    assemble_builtin_sized_impls(\n+                        self.infcx.tcx,\n+                        trait_predicate.def_id(),\n+                        trait_predicate.self_ty(),\n+                        &mut clauses\n+                    );\n+                }\n+\n                 // FIXME: we need to add special rules for builtin impls:\n                 // * `Copy` / `Clone`\n                 // * `Sized`"}, {"sha": "03511e1d76d0562cf26fcd1b30046c768a1554d2", "filename": "src/librustc_traits/generic_types.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dfcad8250946709e3e28311300057ada7bc98c33/src%2Flibrustc_traits%2Fgeneric_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfcad8250946709e3e28311300057ada7bc98c33/src%2Flibrustc_traits%2Fgeneric_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fgeneric_types.rs?ref=dfcad8250946709e3e28311300057ada7bc98c33", "patch": "@@ -1,7 +1,9 @@\n //! Utilities for creating generic types with bound vars in place of parameter values.\n \n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::Substs;\n use rustc::hir;\n+use rustc::hir::def_id::DefId;\n use rustc_target::spec::abi;\n \n crate fn bound(tcx: ty::TyCtxt<'_, '_, 'tcx>, index: u32) -> Ty<'tcx> {\n@@ -50,7 +52,7 @@ crate fn type_list(tcx: ty::TyCtxt<'_, '_, 'tcx>, arity: usize) -> &'tcx ty::Lis\n     )\n }\n \n-crate fn _ref_ty(tcx: ty::TyCtxt<'_, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n+crate fn ref_ty(tcx: ty::TyCtxt<'_, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n     let region = tcx.mk_region(\n         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n     );\n@@ -60,3 +62,19 @@ crate fn _ref_ty(tcx: ty::TyCtxt<'_, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'t\n         mutbl,\n     })\n }\n+\n+crate fn fn_def(tcx: ty::TyCtxt<'_, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+    tcx.mk_ty(ty::FnDef(def_id, Substs::bound_vars_for_item(tcx, def_id)))\n+}\n+\n+crate fn closure(tcx: ty::TyCtxt<'_, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+    tcx.mk_closure(def_id, ty::ClosureSubsts {\n+        substs: Substs::bound_vars_for_item(tcx, def_id),\n+    })\n+}\n+\n+crate fn generator(tcx: ty::TyCtxt<'_, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+    tcx.mk_generator(def_id, ty::GeneratorSubsts {\n+        substs: Substs::bound_vars_for_item(tcx, def_id),\n+    }, hir::GeneratorMovability::Movable)\n+}"}]}