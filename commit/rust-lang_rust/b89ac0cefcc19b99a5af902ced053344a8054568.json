{"sha": "b89ac0cefcc19b99a5af902ced053344a8054568", "node_id": "C_kwDOAAsO6NoAKGI4OWFjMGNlZmNjMTliOTlhNWFmOTAyY2VkMDUzMzQ0YTgwNTQ1Njg", "commit": {"author": {"name": "kraktus", "email": "kraktus@users.noreply.github.com", "date": "2022-10-03T12:11:54Z"}, "committer": {"name": "kraktus", "email": "kraktus@users.noreply.github.com", "date": "2022-10-03T12:13:15Z"}, "message": "refactor `manual_filter`\n\nMove common functions to `manual_utils.rs`, better arm matching, use clippy utils `contains_unsafe_block`", "tree": {"sha": "bc726798ef9eba011be8ca2b22d2d287dd55d061", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc726798ef9eba011be8ca2b22d2d287dd55d061"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b89ac0cefcc19b99a5af902ced053344a8054568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b89ac0cefcc19b99a5af902ced053344a8054568", "html_url": "https://github.com/rust-lang/rust/commit/b89ac0cefcc19b99a5af902ced053344a8054568", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b89ac0cefcc19b99a5af902ced053344a8054568/comments", "author": {"login": "kraktus", "id": 56031107, "node_id": "MDQ6VXNlcjU2MDMxMTA3", "avatar_url": "https://avatars.githubusercontent.com/u/56031107?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kraktus", "html_url": "https://github.com/kraktus", "followers_url": "https://api.github.com/users/kraktus/followers", "following_url": "https://api.github.com/users/kraktus/following{/other_user}", "gists_url": "https://api.github.com/users/kraktus/gists{/gist_id}", "starred_url": "https://api.github.com/users/kraktus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kraktus/subscriptions", "organizations_url": "https://api.github.com/users/kraktus/orgs", "repos_url": "https://api.github.com/users/kraktus/repos", "events_url": "https://api.github.com/users/kraktus/events{/privacy}", "received_events_url": "https://api.github.com/users/kraktus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kraktus", "id": 56031107, "node_id": "MDQ6VXNlcjU2MDMxMTA3", "avatar_url": "https://avatars.githubusercontent.com/u/56031107?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kraktus", "html_url": "https://github.com/kraktus", "followers_url": "https://api.github.com/users/kraktus/followers", "following_url": "https://api.github.com/users/kraktus/following{/other_user}", "gists_url": "https://api.github.com/users/kraktus/gists{/gist_id}", "starred_url": "https://api.github.com/users/kraktus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kraktus/subscriptions", "organizations_url": "https://api.github.com/users/kraktus/orgs", "repos_url": "https://api.github.com/users/kraktus/repos", "events_url": "https://api.github.com/users/kraktus/events{/privacy}", "received_events_url": "https://api.github.com/users/kraktus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0958f9486ba0cb8ecd0093ff3100af45d19529f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0958f9486ba0cb8ecd0093ff3100af45d19529f3", "html_url": "https://github.com/rust-lang/rust/commit/0958f9486ba0cb8ecd0093ff3100af45d19529f3"}], "stats": {"total": 644, "additions": 311, "deletions": 333}, "files": [{"sha": "66ba1f6f9c55007771d75d415ff517bea32bdbe5", "filename": "clippy_lints/src/matches/manual_filter.rs", "status": "modified", "additions": 24, "deletions": 52, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b89ac0cefcc19b99a5af902ced053344a8054568/clippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89ac0cefcc19b99a5af902ced053344a8054568/clippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs?ref=b89ac0cefcc19b99a5af902ced053344a8054568", "patch": "@@ -1,39 +1,20 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::contains_unsafe_block;\n use clippy_utils::{is_res_lang_ctor, path_res, path_to_local_id};\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n+\n use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{Arm, Block, BlockCheckMode, Expr, ExprKind, HirId, Pat, PatKind, UnsafeSource};\n+use rustc_hir::{Arm, Expr, ExprKind, HirId, Pat, PatKind};\n use rustc_lint::LateContext;\n use rustc_span::{sym, SyntaxContext};\n \n-use super::manual_map::{check_with, SomeExpr};\n+use super::manual_utils::{check_with, SomeExpr};\n use super::MANUAL_FILTER;\n \n-#[derive(Default)]\n-struct NeedsUnsafeBlock(pub bool);\n-\n-impl<'tcx> Visitor<'tcx> for NeedsUnsafeBlock {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        match expr.kind {\n-            ExprKind::Block(\n-                Block {\n-                    rules: BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n-                    ..\n-                },\n-                _,\n-            ) => {\n-                self.0 = true;\n-            },\n-            _ => walk_expr(self, expr),\n-        }\n-    }\n-}\n-\n-// Function called on the `expr` of `[&+]Some((ref | ref mut) x) => <expr>`\n-// Need to check if it's of the `if <cond> {<then_expr>} else {<else_expr>}`\n+// Function called on the <expr> of `[&+]Some((ref | ref mut) x) => <expr>`\n+// Need to check if it's of the form `<expr>=if <cond> {<then_expr>} else {<else_expr>}`\n // AND that only one `then/else_expr` resolves to `Some(x)` while the other resolves to `None`\n-// return `cond` if\n+// return the `cond` expression if so.\n fn get_cond_expr<'tcx>(\n     cx: &LateContext<'tcx>,\n     pat: &Pat<'_>,\n@@ -45,15 +26,13 @@ fn get_cond_expr<'tcx>(\n         if let ExprKind::If(cond, then_expr, Some(else_expr)) = block_expr.kind;\n         if let PatKind::Binding(_,target, ..) = pat.kind;\n         if let (then_visitor, else_visitor)\n-            = (handle_if_or_else_expr(cx, target, ctxt, then_expr),\n-                handle_if_or_else_expr(cx, target, ctxt, else_expr));\n+            = (is_some_expr(cx, target, ctxt, then_expr),\n+                is_some_expr(cx, target, ctxt, else_expr));\n         if then_visitor != else_visitor; // check that one expr resolves to `Some(x)`, the other to `None`\n         then {\n-            let mut needs_unsafe_block = NeedsUnsafeBlock::default();\n-            needs_unsafe_block.visit_expr(expr);\n             return Some(SomeExpr {\n                     expr: peels_blocks_incl_unsafe(cond.peel_drop_temps()),\n-                    needs_unsafe_block: needs_unsafe_block.0,\n+                    needs_unsafe_block: contains_unsafe_block(cx, expr),\n                     needs_negated: !then_visitor // if the `then_expr` resolves to `None`, need to negate the cond\n                 })\n             }\n@@ -63,7 +42,7 @@ fn get_cond_expr<'tcx>(\n \n fn peels_blocks_incl_unsafe_opt<'a>(expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n     // we don't want to use `peel_blocks` here because we don't care if the block is unsafe, it's\n-    // checked by `NeedsUnsafeBlock`\n+    // checked by `contains_unsafe_block`\n     if let ExprKind::Block(block, None) = expr.kind {\n         if block.stmts.is_empty() {\n             return block.expr;\n@@ -76,23 +55,18 @@ fn peels_blocks_incl_unsafe<'a>(expr: &'a Expr<'a>) -> &'a Expr<'a> {\n     peels_blocks_incl_unsafe_opt(expr).unwrap_or(expr)\n }\n \n-// function called for each <ifelse> expression:\n+// function called for each <expr> expression:\n // Some(x) => if <cond> {\n-//    <ifelse>\n+//    <expr>\n // } else {\n-//    <ifelse>\n+//    <expr>\n // }\n-// Returns true if <ifelse> resolves to `Some(x)`, `false` otherwise\n-fn handle_if_or_else_expr<'tcx>(\n-    cx: &LateContext<'_>,\n-    target: HirId,\n-    ctxt: SyntaxContext,\n-    if_or_else_expr: &'tcx Expr<'_>,\n-) -> bool {\n-    if let Some(inner_expr) = peels_blocks_incl_unsafe_opt(if_or_else_expr) {\n+// Returns true if <expr> resolves to `Some(x)`, `false` otherwise\n+fn is_some_expr<'tcx>(cx: &LateContext<'_>, target: HirId, ctxt: SyntaxContext, expr: &'tcx Expr<'_>) -> bool {\n+    if let Some(inner_expr) = peels_blocks_incl_unsafe_opt(expr) {\n         // there can be not statements in the block as they would be removed when switching to `.filter`\n         if let ExprKind::Call(callee, [arg]) = inner_expr.kind {\n-            return ctxt == if_or_else_expr.span.ctxt()\n+            return ctxt == expr.span.ctxt()\n                 && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome)\n                 && path_to_local_id(arg, target);\n         }\n@@ -119,15 +93,13 @@ pub(super) fn check_match<'tcx>(\n     expr: &'tcx Expr<'_>,\n ) {\n     let ty = cx.typeck_results().expr_ty(expr);\n-    if_chain! {\n-        if is_type_diagnostic_item(cx, ty, sym::Option);\n-        if arms.len() == 2;\n-        if arms[0].guard.is_none();\n-        if arms[1].guard.is_none();\n-        then {\n-            check(cx, expr, scrutinee, arms[0].pat, arms[0].body, Some(arms[1].pat), arms[1].body)\n+    if is_type_diagnostic_item(cx, ty, sym::Option)\n+    && let [first_arm, second_arm] = arms\n+    && first_arm.guard.is_none()\n+    && second_arm.guard.is_none()\n+         {\n+            check(cx, expr, scrutinee, first_arm.pat, first_arm.body, Some(second_arm.pat), second_arm.body);\n         }\n-    }\n }\n \n pub(super) fn check_if_let<'tcx>("}, {"sha": "aaba239677fffafa163e7e76805b30be9d037d75", "filename": "clippy_lints/src/matches/manual_map.rs", "status": "modified", "additions": 7, "deletions": 280, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/b89ac0cefcc19b99a5af902ced053344a8054568/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89ac0cefcc19b99a5af902ced053344a8054568/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs?ref=b89ac0cefcc19b99a5af902ced053344a8054568", "patch": "@@ -1,21 +1,13 @@\n+use super::manual_utils::{check_with, SomeExpr};\n use super::MANUAL_MAP;\n-use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n-use clippy_utils::ty::{is_copy, is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n-use clippy_utils::{\n-    can_move_expr_to_closure, is_else_clause, is_lint_allowed, is_res_lang_ctor, path_res, path_to_local_id,\n-    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, sugg::Sugg, CaptureKind,\n-};\n-use rustc_ast::util::parser::PREC_POSTFIX;\n-use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{\n-    def::Res, Arm, BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path,\n-    QPath, UnsafeSource,\n-};\n+\n+use clippy_utils::{is_res_lang_ctor, path_res};\n+\n+use rustc_hir::LangItem::OptionSome;\n+use rustc_hir::{Arm, Block, BlockCheckMode, Expr, ExprKind, Pat, UnsafeSource};\n use rustc_lint::LateContext;\n-use rustc_span::{sym, SyntaxContext};\n+use rustc_span::SyntaxContext;\n \n pub(super) fn check_match<'tcx>(\n     cx: &LateContext<'tcx>,\n@@ -83,266 +75,6 @@ fn check<'tcx>(\n     }\n }\n \n-#[expect(clippy::too_many_arguments)]\n-#[expect(clippy::too_many_lines)]\n-pub(super) fn check_with<'tcx, F>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'_>,\n-    scrutinee: &'tcx Expr<'_>,\n-    then_pat: &'tcx Pat<'_>,\n-    then_body: &'tcx Expr<'_>,\n-    else_pat: Option<&'tcx Pat<'_>>,\n-    else_body: &'tcx Expr<'_>,\n-    get_some_expr_fn: F,\n-) -> Option<SuggInfo<'tcx>>\n-where\n-    F: Fn(&LateContext<'tcx>, &'tcx Pat<'_>, &'tcx Expr<'_>, SyntaxContext) -> Option<SomeExpr<'tcx>>,\n-{\n-    let (scrutinee_ty, ty_ref_count, ty_mutability) =\n-        peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n-    if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::Option)\n-        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Option))\n-    {\n-        return None;\n-    }\n-\n-    let expr_ctxt = expr.span.ctxt();\n-    let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n-        try_parse_pattern(cx, then_pat, expr_ctxt),\n-        else_pat.map_or(Some(OptionPat::Wild), |p| try_parse_pattern(cx, p, expr_ctxt)),\n-    ) {\n-        (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n-            (else_body, pattern, ref_count, true)\n-        },\n-        (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n-            (else_body, pattern, ref_count, false)\n-        },\n-        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_body) => {\n-            (then_body, pattern, ref_count, true)\n-        },\n-        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n-            (then_body, pattern, ref_count, false)\n-        },\n-        _ => return None,\n-    };\n-\n-    // Top level or patterns aren't allowed in closures.\n-    if matches!(some_pat.kind, PatKind::Or(_)) {\n-        return None;\n-    }\n-\n-    let some_expr = match get_some_expr_fn(cx, some_pat, some_expr, expr_ctxt) {\n-        Some(expr) => expr,\n-        None => return None,\n-    };\n-\n-    // These two lints will go back and forth with each other.\n-    if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n-        && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n-    {\n-        return None;\n-    }\n-\n-    // `map` won't perform any adjustments.\n-    if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n-        return None;\n-    }\n-\n-    // Determine which binding mode to use.\n-    let explicit_ref = some_pat.contains_explicit_ref_binding();\n-    let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then_some(ty_mutability));\n-\n-    let as_ref_str = match binding_ref {\n-        Some(Mutability::Mut) => \".as_mut()\",\n-        Some(Mutability::Not) => \".as_ref()\",\n-        None => \"\",\n-    };\n-\n-    match can_move_expr_to_closure(cx, some_expr.expr) {\n-        Some(captures) => {\n-            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n-            // TODO: check all the references made in the scrutinee expression. This will require interacting\n-            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n-            if let Some(binding_ref_mutability) = binding_ref {\n-                let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n-                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n-                    _ => None,\n-                });\n-                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n-                    match captures.get(l) {\n-                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return None,\n-                        Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n-                            return None;\n-                        },\n-                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n-                    }\n-                }\n-            }\n-        },\n-        None => return None,\n-    };\n-\n-    let mut app = Applicability::MachineApplicable;\n-\n-    // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n-    // it's being passed by value.\n-    let scrutinee = peel_hir_expr_refs(scrutinee).0;\n-    let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n-    let scrutinee_str = if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n-        format!(\"({scrutinee_str})\")\n-    } else {\n-        scrutinee_str.into()\n-    };\n-\n-    let closure_expr_snip = some_expr.to_snippet_with_context(cx, expr_ctxt, &mut app);\n-    let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n-        if_chain! {\n-            if !some_expr.needs_unsafe_block;\n-            if let Some(func) = can_pass_as_func(cx, id, some_expr.expr);\n-            if func.span.ctxt() == some_expr.expr.span.ctxt();\n-            then {\n-                snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-            } else {\n-                if path_to_local_id(some_expr.expr, id)\n-                    && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n-                    && binding_ref.is_some()\n-                {\n-                    return None;\n-                }\n-\n-                // `ref` and `ref mut` annotations were handled earlier.\n-                let annotation = if matches!(annotation, BindingAnnotation::MUT) {\n-                    \"mut \"\n-                } else {\n-                    \"\"\n-                };\n-\n-                if some_expr.needs_unsafe_block {\n-                    format!(\"|{annotation}{some_binding}| unsafe {{ {closure_expr_snip} }}\")\n-                } else {\n-                    format!(\"|{annotation}{some_binding}| {closure_expr_snip}\")\n-                }\n-            }\n-        }\n-    } else if !is_wild_none && explicit_ref.is_none() {\n-        // TODO: handle explicit reference annotations.\n-        let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n-        if some_expr.needs_unsafe_block {\n-            format!(\"|{pat_snip}| unsafe {{ {closure_expr_snip} }}\")\n-        } else {\n-            format!(\"|{pat_snip}| {closure_expr_snip}\")\n-        }\n-    } else {\n-        // Refutable bindings and mixed reference annotations can't be handled by `map`.\n-        return None;\n-    };\n-\n-    // relies on the fact that Option<T>: Copy where T: copy\n-    let scrutinee_impl_copy = is_copy(cx, scrutinee_ty);\n-\n-    Some(SuggInfo {\n-        needs_brackets: else_pat.is_none() && is_else_clause(cx.tcx, expr),\n-        scrutinee_impl_copy,\n-        scrutinee_str,\n-        as_ref_str,\n-        body_str,\n-        app,\n-    })\n-}\n-\n-pub struct SuggInfo<'a> {\n-    pub needs_brackets: bool,\n-    pub scrutinee_impl_copy: bool,\n-    pub scrutinee_str: String,\n-    pub as_ref_str: &'a str,\n-    pub body_str: String,\n-    pub app: Applicability,\n-}\n-\n-// Checks whether the expression could be passed as a function, or whether a closure is needed.\n-// Returns the function to be passed to `map` if it exists.\n-fn can_pass_as_func<'tcx>(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    match expr.kind {\n-        ExprKind::Call(func, [arg])\n-            if path_to_local_id(arg, binding)\n-                && cx.typeck_results().expr_adjustments(arg).is_empty()\n-                && !type_is_unsafe_function(cx, cx.typeck_results().expr_ty(func).peel_refs()) =>\n-        {\n-            Some(func)\n-        },\n-        _ => None,\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub(super) enum OptionPat<'a> {\n-    Wild,\n-    None,\n-    Some {\n-        // The pattern contained in the `Some` tuple.\n-        pattern: &'a Pat<'a>,\n-        // The number of references before the `Some` tuple.\n-        // e.g. `&&Some(_)` has a ref count of 2.\n-        ref_count: usize,\n-    },\n-}\n-\n-pub(super) struct SomeExpr<'tcx> {\n-    pub expr: &'tcx Expr<'tcx>,\n-    pub needs_unsafe_block: bool,\n-    pub needs_negated: bool, // for `manual_filter` lint\n-}\n-\n-impl<'tcx> SomeExpr<'tcx> {\n-    pub fn new_no_negated(expr: &'tcx Expr<'tcx>, needs_unsafe_block: bool) -> Self {\n-        Self {\n-            expr,\n-            needs_unsafe_block,\n-            needs_negated: false,\n-        }\n-    }\n-\n-    pub fn to_snippet_with_context(\n-        &self,\n-        cx: &LateContext<'tcx>,\n-        ctxt: SyntaxContext,\n-        app: &mut Applicability,\n-    ) -> Sugg<'tcx> {\n-        let sugg = Sugg::hir_with_context(cx, self.expr, ctxt, \"..\", app);\n-        if self.needs_negated { !sugg } else { sugg }\n-    }\n-}\n-\n-// Try to parse into a recognized `Option` pattern.\n-// i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-pub(super) fn try_parse_pattern<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &'tcx Pat<'_>,\n-    ctxt: SyntaxContext,\n-) -> Option<OptionPat<'tcx>> {\n-    fn f<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        pat: &'tcx Pat<'_>,\n-        ref_count: usize,\n-        ctxt: SyntaxContext,\n-    ) -> Option<OptionPat<'tcx>> {\n-        match pat.kind {\n-            PatKind::Wild => Some(OptionPat::Wild),\n-            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n-            PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionNone) => {\n-                Some(OptionPat::None)\n-            },\n-            PatKind::TupleStruct(ref qpath, [pattern], _)\n-                if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionSome) && pat.span.ctxt() == ctxt =>\n-            {\n-                Some(OptionPat::Some { pattern, ref_count })\n-            },\n-            _ => None,\n-        }\n-    }\n-    f(cx, pat, 0, ctxt)\n-}\n-\n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n fn get_some_expr<'tcx>(\n     cx: &LateContext<'tcx>,\n@@ -382,8 +114,3 @@ fn get_some_expr<'tcx>(\n     }\n     get_some_expr_internal(cx, expr, false, ctxt)\n }\n-\n-// Checks for the `None` value.\n-fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    is_res_lang_ctor(cx, path_res(cx, peel_blocks(expr)), OptionNone)\n-}"}, {"sha": "792908aa7dfca0ec738d24490cd543cf4efdf4e2", "filename": "clippy_lints/src/matches/manual_utils.rs", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/b89ac0cefcc19b99a5af902ced053344a8054568/clippy_lints%2Fsrc%2Fmatches%2Fmanual_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89ac0cefcc19b99a5af902ced053344a8054568/clippy_lints%2Fsrc%2Fmatches%2Fmanual_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_utils.rs?ref=b89ac0cefcc19b99a5af902ced053344a8054568", "patch": "@@ -0,0 +1,278 @@\n+use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n+use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n+use clippy_utils::ty::{is_copy, is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n+use clippy_utils::{\n+    can_move_expr_to_closure, is_else_clause, is_lint_allowed, is_res_lang_ctor, path_res, path_to_local_id,\n+    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, sugg::Sugg, CaptureKind,\n+};\n+use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n+use rustc_hir::{def::Res, BindingAnnotation, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::{sym, SyntaxContext};\n+\n+#[expect(clippy::too_many_arguments)]\n+#[expect(clippy::too_many_lines)]\n+pub(super) fn check_with<'tcx, F>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    then_pat: &'tcx Pat<'_>,\n+    then_body: &'tcx Expr<'_>,\n+    else_pat: Option<&'tcx Pat<'_>>,\n+    else_body: &'tcx Expr<'_>,\n+    get_some_expr_fn: F,\n+) -> Option<SuggInfo<'tcx>>\n+where\n+    F: Fn(&LateContext<'tcx>, &'tcx Pat<'_>, &'tcx Expr<'_>, SyntaxContext) -> Option<SomeExpr<'tcx>>,\n+{\n+    let (scrutinee_ty, ty_ref_count, ty_mutability) =\n+        peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n+    if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::Option)\n+        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Option))\n+    {\n+        return None;\n+    }\n+\n+    let expr_ctxt = expr.span.ctxt();\n+    let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n+        try_parse_pattern(cx, then_pat, expr_ctxt),\n+        else_pat.map_or(Some(OptionPat::Wild), |p| try_parse_pattern(cx, p, expr_ctxt)),\n+    ) {\n+        (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+            (else_body, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+            (else_body, pattern, ref_count, false)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_body) => {\n+            (then_body, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n+            (then_body, pattern, ref_count, false)\n+        },\n+        _ => return None,\n+    };\n+\n+    // Top level or patterns aren't allowed in closures.\n+    if matches!(some_pat.kind, PatKind::Or(_)) {\n+        return None;\n+    }\n+\n+    let some_expr = match get_some_expr_fn(cx, some_pat, some_expr, expr_ctxt) {\n+        Some(expr) => expr,\n+        None => return None,\n+    };\n+\n+    // These two lints will go back and forth with each other.\n+    if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n+        && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n+    {\n+        return None;\n+    }\n+\n+    // `map` won't perform any adjustments.\n+    if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n+        return None;\n+    }\n+\n+    // Determine which binding mode to use.\n+    let explicit_ref = some_pat.contains_explicit_ref_binding();\n+    let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then_some(ty_mutability));\n+\n+    let as_ref_str = match binding_ref {\n+        Some(Mutability::Mut) => \".as_mut()\",\n+        Some(Mutability::Not) => \".as_ref()\",\n+        None => \"\",\n+    };\n+\n+    match can_move_expr_to_closure(cx, some_expr.expr) {\n+        Some(captures) => {\n+            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+            // TODO: check all the references made in the scrutinee expression. This will require interacting\n+            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+            if let Some(binding_ref_mutability) = binding_ref {\n+                let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n+                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                });\n+                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n+                    match captures.get(l) {\n+                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return None,\n+                        Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n+                            return None;\n+                        },\n+                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                    }\n+                }\n+            }\n+        },\n+        None => return None,\n+    };\n+\n+    let mut app = Applicability::MachineApplicable;\n+\n+    // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n+    // it's being passed by value.\n+    let scrutinee = peel_hir_expr_refs(scrutinee).0;\n+    let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+    let scrutinee_str = if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n+        format!(\"({scrutinee_str})\")\n+    } else {\n+        scrutinee_str.into()\n+    };\n+\n+    let closure_expr_snip = some_expr.to_snippet_with_context(cx, expr_ctxt, &mut app);\n+    let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n+        if_chain! {\n+            if !some_expr.needs_unsafe_block;\n+            if let Some(func) = can_pass_as_func(cx, id, some_expr.expr);\n+            if func.span.ctxt() == some_expr.expr.span.ctxt();\n+            then {\n+                snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+            } else {\n+                if path_to_local_id(some_expr.expr, id)\n+                    && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                    && binding_ref.is_some()\n+                {\n+                    return None;\n+                }\n+\n+                // `ref` and `ref mut` annotations were handled earlier.\n+                let annotation = if matches!(annotation, BindingAnnotation::MUT) {\n+                    \"mut \"\n+                } else {\n+                    \"\"\n+                };\n+\n+                if some_expr.needs_unsafe_block {\n+                    format!(\"|{annotation}{some_binding}| unsafe {{ {closure_expr_snip} }}\")\n+                } else {\n+                    format!(\"|{annotation}{some_binding}| {closure_expr_snip}\")\n+                }\n+            }\n+        }\n+    } else if !is_wild_none && explicit_ref.is_none() {\n+        // TODO: handle explicit reference annotations.\n+        let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n+        if some_expr.needs_unsafe_block {\n+            format!(\"|{pat_snip}| unsafe {{ {closure_expr_snip} }}\")\n+        } else {\n+            format!(\"|{pat_snip}| {closure_expr_snip}\")\n+        }\n+    } else {\n+        // Refutable bindings and mixed reference annotations can't be handled by `map`.\n+        return None;\n+    };\n+\n+    // relies on the fact that Option<T>: Copy where T: copy\n+    let scrutinee_impl_copy = is_copy(cx, scrutinee_ty);\n+\n+    Some(SuggInfo {\n+        needs_brackets: else_pat.is_none() && is_else_clause(cx.tcx, expr),\n+        scrutinee_impl_copy,\n+        scrutinee_str,\n+        as_ref_str,\n+        body_str,\n+        app,\n+    })\n+}\n+\n+pub struct SuggInfo<'a> {\n+    pub needs_brackets: bool,\n+    pub scrutinee_impl_copy: bool,\n+    pub scrutinee_str: String,\n+    pub as_ref_str: &'a str,\n+    pub body_str: String,\n+    pub app: Applicability,\n+}\n+\n+// Checks whether the expression could be passed as a function, or whether a closure is needed.\n+// Returns the function to be passed to `map` if it exists.\n+fn can_pass_as_func<'tcx>(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    match expr.kind {\n+        ExprKind::Call(func, [arg])\n+            if path_to_local_id(arg, binding)\n+                && cx.typeck_results().expr_adjustments(arg).is_empty()\n+                && !type_is_unsafe_function(cx, cx.typeck_results().expr_ty(func).peel_refs()) =>\n+        {\n+            Some(func)\n+        },\n+        _ => None,\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(super) enum OptionPat<'a> {\n+    Wild,\n+    None,\n+    Some {\n+        // The pattern contained in the `Some` tuple.\n+        pattern: &'a Pat<'a>,\n+        // The number of references before the `Some` tuple.\n+        // e.g. `&&Some(_)` has a ref count of 2.\n+        ref_count: usize,\n+    },\n+}\n+\n+pub(super) struct SomeExpr<'tcx> {\n+    pub expr: &'tcx Expr<'tcx>,\n+    pub needs_unsafe_block: bool,\n+    pub needs_negated: bool, // for `manual_filter` lint\n+}\n+\n+impl<'tcx> SomeExpr<'tcx> {\n+    pub fn new_no_negated(expr: &'tcx Expr<'tcx>, needs_unsafe_block: bool) -> Self {\n+        Self {\n+            expr,\n+            needs_unsafe_block,\n+            needs_negated: false,\n+        }\n+    }\n+\n+    pub fn to_snippet_with_context(\n+        &self,\n+        cx: &LateContext<'tcx>,\n+        ctxt: SyntaxContext,\n+        app: &mut Applicability,\n+    ) -> Sugg<'tcx> {\n+        let sugg = Sugg::hir_with_context(cx, self.expr, ctxt, \"..\", app);\n+        if self.needs_negated { !sugg } else { sugg }\n+    }\n+}\n+\n+// Try to parse into a recognized `Option` pattern.\n+// i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n+pub(super) fn try_parse_pattern<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    ctxt: SyntaxContext,\n+) -> Option<OptionPat<'tcx>> {\n+    fn f<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        pat: &'tcx Pat<'_>,\n+        ref_count: usize,\n+        ctxt: SyntaxContext,\n+    ) -> Option<OptionPat<'tcx>> {\n+        match pat.kind {\n+            PatKind::Wild => Some(OptionPat::Wild),\n+            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n+            PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionNone) => {\n+                Some(OptionPat::None)\n+            },\n+            PatKind::TupleStruct(ref qpath, [pattern], _)\n+                if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionSome) && pat.span.ctxt() == ctxt =>\n+            {\n+                Some(OptionPat::Some { pattern, ref_count })\n+            },\n+            _ => None,\n+        }\n+    }\n+    f(cx, pat, 0, ctxt)\n+}\n+\n+// Checks for the `None` value.\n+fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    is_res_lang_ctor(cx, path_res(cx, peel_blocks(expr)), OptionNone)\n+}"}, {"sha": "c472d6280985fb740fd5f5ceb86d74150eaeaaf9", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b89ac0cefcc19b99a5af902ced053344a8054568/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89ac0cefcc19b99a5af902ced053344a8054568/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=b89ac0cefcc19b99a5af902ced053344a8054568", "patch": "@@ -3,6 +3,7 @@ mod infallible_destructuring_match;\n mod manual_filter;\n mod manual_map;\n mod manual_unwrap_or;\n+mod manual_utils;\n mod match_as_ref;\n mod match_bool;\n mod match_like_matches;"}, {"sha": "f25bced0c2b3dd15ccfb3d6508fd1759002c6006", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b89ac0cefcc19b99a5af902ced053344a8054568/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89ac0cefcc19b99a5af902ced053344a8054568/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=b89ac0cefcc19b99a5af902ced053344a8054568", "patch": "@@ -112,7 +112,7 @@ impl<'a> Sugg<'a> {\n         if expr.span.ctxt() == ctxt {\n             Self::hir_from_snippet(expr, |span| snippet(cx, span, default))\n         } else {\n-            let snip = snippet_with_context(cx, expr.span, ctxt, default, applicability).0;\n+            let (snip, _) = snippet_with_context(cx, expr.span, ctxt, default, applicability);\n             Sugg::NonParen(snip)\n         }\n     }"}]}