{"sha": "a6d74a60267b80410fc189f03bf2bc8595b6cedf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2ZDc0YTYwMjY3YjgwNDEwZmMxODlmMDNiZjJiYzg1OTViNmNlZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-24T13:18:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-24T13:18:44Z"}, "message": "Auto merge of #1251 - RalfJung:win-cross, r=RalfJung\n\ncross-test on a Windows host", "tree": {"sha": "3c0feef55a4e5b2ad0720098bc3194dd23d0493a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c0feef55a4e5b2ad0720098bc3194dd23d0493a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6d74a60267b80410fc189f03bf2bc8595b6cedf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6d74a60267b80410fc189f03bf2bc8595b6cedf", "html_url": "https://github.com/rust-lang/rust/commit/a6d74a60267b80410fc189f03bf2bc8595b6cedf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6d74a60267b80410fc189f03bf2bc8595b6cedf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad7089f1946769b7e5fcb57407493dfd37636b4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad7089f1946769b7e5fcb57407493dfd37636b4c", "html_url": "https://github.com/rust-lang/rust/commit/ad7089f1946769b7e5fcb57407493dfd37636b4c"}, {"sha": "e9e04e56fc6767f63458de1c137b5231cfd77b33", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e04e56fc6767f63458de1c137b5231cfd77b33", "html_url": "https://github.com/rust-lang/rust/commit/e9e04e56fc6767f63458de1c137b5231cfd77b33"}], "stats": {"total": 197, "additions": 155, "deletions": 42}, "files": [{"sha": "e5c2f4fb7294a16085c83827d0f29e026833208e", "filename": ".appveyor.yml", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a6d74a60267b80410fc189f03bf2bc8595b6cedf/.appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a6d74a60267b80410fc189f03bf2bc8595b6cedf/.appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.appveyor.yml?ref=a6d74a60267b80410fc189f03bf2bc8595b6cedf", "patch": "@@ -2,7 +2,6 @@ environment:\n     global:\n         PROJECT_NAME: miri\n     matrix:\n-        - TARGET: x86_64-pc-windows-msvc\n         - TARGET: i686-pc-windows-msvc\n \n # branches to build\n@@ -43,18 +42,36 @@ build_script:\n     # Build and install miri\n     - cargo build --release --all-features --all-targets --locked\n     - cargo install --all-features --force --path . --locked --offline\n-    # Get ourselves a MIR-full libstd, and use it henceforth\n-    - cargo miri setup\n-    - set MIRI_SYSROOT=%USERPROFILE%\\AppData\\Local\\rust-lang\\miri\\cache\\HOST\n \n test_script:\n     - set RUST_TEST_NOCAPTURE=1\n     - set RUST_BACKTRACE=1\n-    # Test miri\n+    # Test host miri: 32bit Windows\n+    - cargo miri setup\n+    - set MIRI_SYSROOT=%USERPROFILE%\\AppData\\Local\\rust-lang\\miri\\cache\\HOST\n+    - cargo test --release --all-features --locked\n+    - cd test-cargo-miri\n+    - '\"C:\\msys64\\mingw64\\bin\\python3.exe\" run-test.py'\n+    - cd ..\n+    - ps: $env:MIRI_SYSROOT = \"\"\n+    # Test foreign miri: 64bit Linux\n+    - cargo miri setup --target x86_64-unknown-linux-gnu\n+    - set MIRI_SYSROOT=%USERPROFILE%\\AppData\\Local\\rust-lang\\miri\\cache\n+    - set MIRI_TEST_TARGET=x86_64-unknown-linux-gnu\n+    - cargo test --release --all-features --locked\n+    - cd test-cargo-miri\n+    - '\"C:\\msys64\\mingw64\\bin\\python3.exe\" run-test.py'\n+    - cd ..\n+    - ps: $env:MIRI_SYSROOT = \"\"\n+    # Test foreign miri: 64bit macOS\n+    - cargo miri setup --target x86_64-apple-darwin\n+    - set MIRI_SYSROOT=%USERPROFILE%\\AppData\\Local\\rust-lang\\miri\\cache\n+    - set MIRI_TEST_TARGET=x86_64-apple-darwin\n     - cargo test --release --all-features --locked\n-    # Test cargo integration\n     - cd test-cargo-miri\n     - '\"C:\\msys64\\mingw64\\bin\\python3.exe\" run-test.py'\n+    - cd ..\n+    - ps: $env:MIRI_SYSROOT = \"\"\n \n after_test:\n     # Don't cache \"master\" toolchain, it's a waste"}, {"sha": "7ca2b238218a176fff13dff79b3a9953fa01334b", "filename": "src/helpers.rs", "status": "modified", "additions": 90, "deletions": 6, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a6d74a60267b80410fc189f03bf2bc8595b6cedf/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d74a60267b80410fc189f03bf2bc8595b6cedf/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=a6d74a60267b80410fc189f03bf2bc8595b6cedf", "patch": "@@ -1,6 +1,13 @@\n use std::ffi::{OsStr, OsString};\n+use std::path::{Path, PathBuf};\n use std::{iter, mem};\n use std::convert::TryFrom;\n+use std::borrow::Cow;\n+\n+#[cfg(unix)]\n+use std::os::unix::ffi::{OsStrExt, OsStringExt};\n+#[cfg(windows)]\n+use std::os::windows::ffi::{OsStrExt, OsStringExt};\n \n use rustc::mir;\n use rustc::ty::{\n@@ -477,7 +484,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     {\n         #[cfg(unix)]\n         fn bytes_to_os_str<'tcx, 'a>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n-            Ok(std::os::unix::ffi::OsStrExt::from_bytes(bytes))\n+            Ok(OsStr::from_bytes(bytes))\n         }\n         #[cfg(not(unix))]\n         fn bytes_to_os_str<'tcx, 'a>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n@@ -500,7 +507,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     {\n         #[cfg(windows)]\n         pub fn u16vec_to_osstring<'tcx, 'a>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n-            Ok(std::os::windows::ffi::OsStringExt::from_wide(&u16_vec[..]))\n+            Ok(OsString::from_wide(&u16_vec[..]))\n         }\n         #[cfg(not(windows))]\n         pub fn u16vec_to_osstring<'tcx, 'a>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n@@ -513,7 +520,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         u16vec_to_osstring(u16_vec)\n     }\n \n-\n     /// Helper function to write an OsStr as a null-terminated sequence of bytes, which is what\n     /// the Unix APIs usually handle. This function returns `Ok((false, length))` without trying\n     /// to write if `size` is not large enough to fit the contents of `os_string` plus a null\n@@ -527,7 +533,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         #[cfg(unix)]\n         fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n-            Ok(std::os::unix::ffi::OsStrExt::as_bytes(os_str))\n+            Ok(os_str.as_bytes())\n         }\n         #[cfg(not(unix))]\n         fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n@@ -566,7 +572,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         #[cfg(windows)]\n         fn os_str_to_u16vec<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, Vec<u16>> {\n-            Ok(std::os::windows::ffi::OsStrExt::encode_wide(os_str).collect())\n+            Ok(os_str.encode_wide().collect())\n         }\n         #[cfg(not(windows))]\n         fn os_str_to_u16vec<'tcx>(os_str: &OsStr) -> InterpResult<'tcx, Vec<u16>> {\n@@ -592,7 +598,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Store the UTF-16 string.\n         let char_size = Size::from_bytes(2);\n         for (idx, c) in u16_vec.into_iter().chain(iter::once(0x0000)).enumerate() {\n-            let place = this.mplace_field(mplace, idx as u64)?; \n+            let place = this.mplace_field(mplace, u64::try_from(idx).unwrap())?; \n             this.write_scalar(Scalar::from_uint(c, char_size), place.into())?;\n         }\n         Ok((true, string_length))\n@@ -613,6 +619,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n+    /// Allocate enough memory to store the given `OsStr` as a null-terminated sequence of bytes.\n     fn alloc_os_str_as_c_str(\n         &mut self,\n         os_str: &OsStr,\n@@ -627,6 +634,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         arg_place.ptr.assert_ptr()\n     }\n \n+    /// Allocate enough memory to store the given `OsStr` as a null-terminated sequence of `u16`.\n     fn alloc_os_str_as_wide_str(\n         &mut self,\n         os_str: &OsStr,\n@@ -640,6 +648,82 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         assert!(self.write_os_str_to_wide_str(os_str, arg_place, size).unwrap().0);\n         arg_place.ptr.assert_ptr()\n     }\n+\n+    /// Read a null-terminated sequence of bytes, and perform path separator conversion if needed.\n+    fn read_path_from_c_str<'a>(&'a self, scalar: Scalar<Tag>) -> InterpResult<'tcx, Cow<'a, Path>>\n+    where\n+        'tcx: 'a,\n+        'mir: 'a,\n+    {\n+        let this = self.eval_context_ref();\n+        let os_str = this.read_os_str_from_c_str(scalar)?;\n+\n+        #[cfg(windows)]\n+        return Ok(if this.tcx.sess.target.target.target_os == \"windows\" {\n+            // Windows-on-Windows, all fine.\n+            Cow::Borrowed(Path::new(os_str))\n+        } else {\n+            // Unix target, Windows host. Need to convert target '/' to host '\\'.\n+            let converted = os_str\n+                .encode_wide()\n+                .map(|wchar| if wchar == '/' as u16 { '\\\\' as u16 } else { wchar })\n+                .collect::<Vec<_>>();\n+            Cow::Owned(PathBuf::from(OsString::from_wide(&converted)))\n+        });\n+        #[cfg(unix)]\n+        return Ok(if this.tcx.sess.target.target.target_os == \"windows\" {\n+            // Windows target, Unix host. Need to convert target '\\' to host '/'.\n+            let converted = os_str\n+                .as_bytes()\n+                .iter()\n+                .map(|&wchar| if wchar == '/' as u8 { '\\\\' as u8 } else { wchar })\n+                .collect::<Vec<_>>();\n+            Cow::Owned(PathBuf::from(OsString::from_vec(converted)))\n+        } else {\n+            // Unix-on-Unix, all is fine.\n+            Cow::Borrowed(Path::new(os_str))\n+        });\n+    }\n+\n+    /// Write a Path to the machine memory, adjusting path separators if needed.\n+    fn write_path_to_c_str(\n+        &mut self,\n+        path: &Path,\n+        scalar: Scalar<Tag>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        let this = self.eval_context_mut();\n+\n+        #[cfg(windows)]\n+        let os_str = if this.tcx.sess.target.target.target_os == \"windows\" {\n+            // Windows-on-Windows, all fine.\n+            Cow::Borrowed(path.as_os_str())\n+        } else {\n+            // Unix target, Windows host. Need to convert host '\\\\' to target '/'.\n+            let converted = path\n+                .as_os_str()\n+                .encode_wide()\n+                .map(|wchar| if wchar == '\\\\' as u16 { '/' as u16 } else { wchar })\n+                .collect::<Vec<_>>();\n+            Cow::Owned(OsString::from_wide(&converted))\n+        };\n+        #[cfg(unix)]\n+        let os_str = if this.tcx.sess.target.target.target_os == \"windows\" {\n+            // Windows target, Unix host. Need to convert host '/' to target '\\'.\n+            let converted = path\n+                .as_os_str()\n+                .as_bytes()\n+                .iter()\n+                .map(|&wchar| if wchar == '/' as u8 { '\\\\' as u8 } else { wchar })\n+                .collect::<Vec<_>>();\n+            Cow::Owned(OsString::from_vec(converted))\n+        } else {\n+            // Unix-on-Unix, all is fine.\n+            Cow::Borrowed(path.as_os_str())\n+        };\n+\n+        this.write_os_str_to_c_str(&os_str, scalar, size)\n+    }\n }\n \n pub fn immty_from_int_checked<'tcx>("}, {"sha": "192fc0d47abec40eb36a13b6e0f48a00b3e2a718", "filename": "src/shims/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6d74a60267b80410fc189f03bf2bc8595b6cedf/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d74a60267b80410fc189f03bf2bc8595b6cedf/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=a6d74a60267b80410fc189f03bf2bc8595b6cedf", "patch": "@@ -134,7 +134,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // If we cannot get the current directory, we return null\n         match env::current_dir() {\n             Ok(cwd) => {\n-                if this.write_os_str_to_c_str(&OsString::from(cwd), buf, size)?.0 {\n+                if this.write_path_to_c_str(&cwd, buf, size)?.0 {\n                     return Ok(buf);\n                 }\n                 let erange = this.eval_libc(\"ERANGE\")?;\n@@ -150,7 +150,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"chdir\")?;\n \n-        let path = this.read_os_str_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n+        let path = this.read_path_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n \n         match env::set_current_dir(path) {\n             Ok(()) => Ok(0),"}, {"sha": "9778775fca641372e88701823301b4fd4e5928b2", "filename": "src/shims/fs.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a6d74a60267b80410fc189f03bf2bc8595b6cedf/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d74a60267b80410fc189f03bf2bc8595b6cedf/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=a6d74a60267b80410fc189f03bf2bc8595b6cedf", "patch": "@@ -2,7 +2,7 @@ use std::collections::BTreeMap;\n use std::convert::{TryFrom, TryInto};\n use std::fs::{read_dir, remove_dir, remove_file, rename, DirBuilder, File, FileType, OpenOptions, ReadDir};\n use std::io::{Read, Seek, SeekFrom, Write};\n-use std::path::PathBuf;\n+use std::path::Path;\n use std::time::SystemTime;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -79,9 +79,9 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n         let this = self.eval_context_mut();\n \n         let path_scalar = this.read_scalar(path_op)?.not_undef()?;\n-        let path: PathBuf = this.read_os_str_from_c_str(path_scalar)?.into();\n+        let path = this.read_path_from_c_str(path_scalar)?.into_owned();\n \n-        let metadata = match FileMetadata::from_path(this, path, follow_symlink)? {\n+        let metadata = match FileMetadata::from_path(this, &path, follow_symlink)? {\n             Some(metadata) => metadata,\n             None => return Ok(-1),\n         };\n@@ -303,7 +303,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_unsup_format!(\"unsupported flags {:#x}\", flag & !mirror);\n         }\n \n-        let path = this.read_os_str_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n+        let path = this.read_path_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n \n         let fd = options.open(&path).map(|file| {\n             let fh = &mut this.machine.file_handler;\n@@ -524,10 +524,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"unlink\")?;\n \n-        let path = this.read_os_str_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n+        let path = this.read_path_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n \n         let result = remove_file(path).map(|_| 0);\n-\n         this.try_unwrap_io_result(result)\n     }\n \n@@ -537,12 +536,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         linkpath_op: OpTy<'tcx, Tag>\n     ) -> InterpResult<'tcx, i32> {\n         #[cfg(target_family = \"unix\")]\n-        fn create_link(src: PathBuf, dst: PathBuf) -> std::io::Result<()> {\n+        fn create_link(src: &Path, dst: &Path) -> std::io::Result<()> {\n             std::os::unix::fs::symlink(src, dst)\n         }\n \n         #[cfg(target_family = \"windows\")]\n-        fn create_link(src: PathBuf, dst: PathBuf) -> std::io::Result<()> {\n+        fn create_link(src: &Path, dst: &Path) -> std::io::Result<()> {\n             use std::os::windows::fs;\n             if src.is_dir() {\n                 fs::symlink_dir(src, dst)\n@@ -555,10 +554,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"symlink\")?;\n \n-        let target = this.read_os_str_from_c_str(this.read_scalar(target_op)?.not_undef()?)?.into();\n-        let linkpath = this.read_os_str_from_c_str(this.read_scalar(linkpath_op)?.not_undef()?)?.into();\n+        let target = this.read_path_from_c_str(this.read_scalar(target_op)?.not_undef()?)?;\n+        let linkpath = this.read_path_from_c_str(this.read_scalar(linkpath_op)?.not_undef()?)?;\n \n-        this.try_unwrap_io_result(create_link(target, linkpath).map(|_| 0))\n+        let result = create_link(&target, &linkpath).map(|_| 0);\n+        this.try_unwrap_io_result(result)\n     }\n \n     fn macos_stat(\n@@ -644,7 +644,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.ref_to_mplace(statxbuf_imm)?\n         };\n \n-        let path: PathBuf = this.read_os_str_from_c_str(pathname_scalar)?.into();\n+        let path = this.read_path_from_c_str(pathname_scalar)?.into_owned();\n         // `flags` should be a `c_int` but the `syscall` function provides an `isize`.\n         let flags: i32 =\n             this.read_scalar(flags_op)?.to_machine_isize(&*this.tcx)?.try_into().map_err(|e| {\n@@ -691,7 +691,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let metadata = if path.as_os_str().is_empty() && empty_path_flag {\n             FileMetadata::from_fd(this, dirfd)?\n         } else {\n-            FileMetadata::from_path(this, path, follow_symlink)?\n+            FileMetadata::from_path(this, &path, follow_symlink)?\n         };\n         let metadata = match metadata {\n             Some(metadata) => metadata,\n@@ -785,8 +785,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(-1);\n         }\n \n-        let oldpath = this.read_os_str_from_c_str(oldpath_scalar)?;\n-        let newpath = this.read_os_str_from_c_str(newpath_scalar)?;\n+        let oldpath = this.read_path_from_c_str(oldpath_scalar)?;\n+        let newpath = this.read_path_from_c_str(newpath_scalar)?;\n \n         let result = rename(oldpath, newpath).map(|_| 0);\n \n@@ -808,7 +808,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.read_scalar(mode_op)?.to_u32()?\n         };\n \n-        let path = this.read_os_str_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n+        let path = this.read_path_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n \n         let mut builder = DirBuilder::new();\n \n@@ -833,7 +833,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"rmdir\")?;\n \n-        let path = this.read_os_str_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n+        let path = this.read_path_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n \n         let result = remove_dir(path).map(|_| 0i32);\n \n@@ -845,7 +845,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"opendir\")?;\n \n-        let name = this.read_os_str_from_c_str(this.read_scalar(name_op)?.not_undef()?)?;\n+        let name = this.read_path_from_c_str(this.read_scalar(name_op)?.not_undef()?)?;\n \n         let result = read_dir(name);\n \n@@ -899,7 +899,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let entry_place = this.deref_operand(entry_op)?;\n                 let name_place = this.mplace_field(entry_place, 4)?;\n \n-                let file_name = dir_entry.file_name();\n+                let file_name = dir_entry.file_name(); // not a Path as there are no separators!\n                 let (name_fits, _) = this.write_os_str_to_c_str(\n                     &file_name,\n                     name_place.ptr,\n@@ -987,7 +987,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let entry_place = this.deref_operand(entry_op)?;\n                 let name_place = this.mplace_field(entry_place, 5)?;\n \n-                let file_name = dir_entry.file_name();\n+                let file_name = dir_entry.file_name(); // not a Path as there are no separators!\n                 let (name_fits, file_name_len) = this.write_os_str_to_c_str(\n                     &file_name,\n                     name_place.ptr,\n@@ -1082,7 +1082,7 @@ struct FileMetadata {\n impl FileMetadata {\n     fn from_path<'tcx, 'mir>(\n         ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-        path: PathBuf,\n+        path: &Path,\n         follow_symlink: bool\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n         let metadata = if follow_symlink {"}, {"sha": "d082a2cc484bd4238129f5849c3bff49ad2b4052", "filename": "tests/compiletest.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6d74a60267b80410fc189f03bf2bc8595b6cedf/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d74a60267b80410fc189f03bf2bc8595b6cedf/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=a6d74a60267b80410fc189f03bf2bc8595b6cedf", "patch": "@@ -110,6 +110,8 @@ fn get_target() -> String {\n fn test_runner(_tests: &[&()]) {\n     // Add a test env var to do environment communication tests.\n     std::env::set_var(\"MIRI_ENV_VAR_TEST\", \"0\");\n+    // Let the tests know where to store temp files (they might run for a different target, which can make this hard to find).\n+    std::env::set_var(\"MIRI_TEMP\", std::env::temp_dir());\n \n     let target = get_target();\n     miri_pass(\"tests/run-pass\", &target);"}, {"sha": "104ba46c3e458f839bde5dfff06ae9b0a90042b9", "filename": "tests/run-pass/fs.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6d74a60267b80410fc189f03bf2bc8595b6cedf/tests%2Frun-pass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d74a60267b80410fc189f03bf2bc8595b6cedf/tests%2Frun-pass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs.rs?ref=a6d74a60267b80410fc189f03bf2bc8595b6cedf", "patch": "@@ -16,19 +16,21 @@ fn main() {\n     test_directory();\n }\n \n+fn tmp() -> PathBuf {\n+    std::env::var(\"MIRI_TEMP\").map(PathBuf::from).unwrap_or_else(|_| std::env::temp_dir())\n+}\n+\n /// Prepare: compute filename and make sure the file does not exist.\n fn prepare(filename: &str) -> PathBuf {\n-    let tmp = std::env::temp_dir();\n-    let path = tmp.join(filename);\n+    let path = tmp().join(filename);\n     // Clean the paths for robustness.\n     remove_file(&path).ok();\n     path\n }\n \n /// Prepare directory: compute directory name and make sure it does not exist.\n fn prepare_dir(dirname: &str) -> PathBuf {\n-    let tmp = std::env::temp_dir();\n-    let path = tmp.join(&dirname);\n+    let path = tmp().join(&dirname);\n     // Clean the directory for robustness.\n     remove_dir_all(&path).ok();\n     path\n@@ -142,7 +144,10 @@ fn test_symlink() {\n     let symlink_path = prepare(\"miri_test_fs_symlink.txt\");\n \n     // Creating a symbolic link should succeed.\n+    #[cfg(unix)]\n     std::os::unix::fs::symlink(&path, &symlink_path).unwrap();\n+    #[cfg(windows)]\n+    std::os::windows::fs::symlink_file(&path, &symlink_path).unwrap();\n     // Test that the symbolic link has the same contents as the file.\n     let mut symlink_file = File::open(&symlink_path).unwrap();\n     let mut contents = Vec::new();"}, {"sha": "064c00e81bb86f78f1fa39d0f9321e2fd8a1750b", "filename": "tests/run-pass/libc.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6d74a60267b80410fc189f03bf2bc8595b6cedf/tests%2Frun-pass%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d74a60267b80410fc189f03bf2bc8595b6cedf/tests%2Frun-pass%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Flibc.rs?ref=a6d74a60267b80410fc189f03bf2bc8595b6cedf", "patch": "@@ -2,19 +2,24 @@\n // compile-flags: -Zmiri-disable-isolation\n \n #![feature(rustc_private)]\n+#![allow(unused)] // necessary on macos due to conditional compilation\n+\n+use std::path::PathBuf;\n \n-#[allow(unused)] // necessary on macos due to conditional compilation\n extern crate libc;\n \n+fn tmp() -> PathBuf {\n+    std::env::var(\"MIRI_TEMP\").map(PathBuf::from).unwrap_or_else(|_| std::env::temp_dir())\n+}\n+\n #[cfg(not(target_os = \"macos\"))]\n fn test_posix_fadvise() {\n     use std::convert::TryInto;\n-    use std::env::temp_dir;\n     use std::fs::{File, remove_file};\n     use std::io::Write;\n     use std::os::unix::io::AsRawFd;\n \n-    let path = temp_dir().join(\"miri_test_libc.txt\");\n+    let path = tmp().join(\"miri_test_libc.txt\");\n     // Cleanup before test\n     remove_file(&path).ok();\n "}]}