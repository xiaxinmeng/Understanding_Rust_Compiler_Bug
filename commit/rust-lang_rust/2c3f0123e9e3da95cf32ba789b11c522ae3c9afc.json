{"sha": "2c3f0123e9e3da95cf32ba789b11c522ae3c9afc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjM2YwMTIzZTllM2RhOTVjZjMyYmE3ODliMTFjNTIyYWUzYzlhZmM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-12-23T00:46:51Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-16T10:22:32Z"}, "message": "only insert global predicates into the global cache once we've\ncompletely proven them to be true", "tree": {"sha": "460449d80e0dd29af80195f50190724dbd9c75b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/460449d80e0dd29af80195f50190724dbd9c75b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c3f0123e9e3da95cf32ba789b11c522ae3c9afc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c3f0123e9e3da95cf32ba789b11c522ae3c9afc", "html_url": "https://github.com/rust-lang/rust/commit/2c3f0123e9e3da95cf32ba789b11c522ae3c9afc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c3f0123e9e3da95cf32ba789b11c522ae3c9afc/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecaa1cbc9c8bcb9a96312f1c017d347c89263094", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecaa1cbc9c8bcb9a96312f1c017d347c89263094", "html_url": "https://github.com/rust-lang/rust/commit/ecaa1cbc9c8bcb9a96312f1c017d347c89263094"}], "stats": {"total": 65, "additions": 28, "deletions": 37}, "files": [{"sha": "a13cc141608d5ea74a62c4eabdf94252d17c6620", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2c3f0123e9e3da95cf32ba789b11c522ae3c9afc/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c3f0123e9e3da95cf32ba789b11c522ae3c9afc/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=2c3f0123e9e3da95cf32ba789b11c522ae3c9afc", "patch": "@@ -86,8 +86,6 @@ pub struct FulfillmentContext<'tcx> {\n     // obligations (otherwise, it's easy to fail to walk to a\n     // particular node-id).\n     region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n-\n-    pub errors_will_be_reported: bool,\n }\n \n #[derive(Clone)]\n@@ -105,28 +103,11 @@ pub struct PendingPredicateObligation<'tcx> {\n \n impl<'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n-    ///\n-    /// `errors_will_be_reported` indicates whether ALL errors that\n-    /// are generated by this fulfillment context will be reported to\n-    /// the end user. This is used to inform caching, because it\n-    /// allows us to conclude that traits that resolve successfully\n-    /// will in fact always resolve successfully (in particular, it\n-    /// guarantees that if some dependent obligation encounters a\n-    /// problem, compilation will be aborted).  If you're not sure of\n-    /// the right value here, pass `false`, as that is the more\n-    /// conservative option.\n-    ///\n-    /// FIXME -- a better option would be to hold back on modifying\n-    /// the global cache until we know that all dependent obligations\n-    /// are also satisfied. In that case, we could actually remove\n-    /// this boolean flag, and we'd also avoid the problem of squelching\n-    /// duplicate errors that occur across fns.\n-    pub fn new(errors_will_be_reported: bool) -> FulfillmentContext<'tcx> {\n+    pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             duplicate_set: FulfilledPredicates::new(),\n             predicates: ObligationForest::new(),\n             region_obligations: NodeMap(),\n-            errors_will_be_reported: errors_will_be_reported,\n         }\n     }\n \n@@ -250,23 +231,27 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                            tcx: &ty::ctxt<'tcx>,\n                            predicate: &ty::Predicate<'tcx>)\n                            -> bool {\n-        // This is a kind of dirty hack to allow us to avoid \"rederiving\"\n-        // things that we have already proven in other methods.\n-        //\n-        // The idea is that any predicate that doesn't involve type\n-        // parameters and which only involves the 'static region (and\n-        // no other regions) is universally solvable, since impls are global.\n-        //\n-        // This is particularly important since even if we have a\n-        // cache hit in the selection context, we still wind up\n-        // evaluating the 'nested obligations'.  This cache lets us\n-        // skip those.\n-\n-        if self.errors_will_be_reported && predicate.is_global() {\n-            tcx.fulfilled_predicates.borrow_mut().is_duplicate_or_add(predicate)\n-        } else {\n-            self.duplicate_set.is_duplicate_or_add(predicate)\n+        // For \"global\" predicates -- that is, predicates that don't\n+        // involve type parameters, inference variables, or regions\n+        // other than 'static -- we can check the cache in the tcx,\n+        // which allows us to leverage work from other threads. Note\n+        // that we don't add anything to this cache yet (unlike the\n+        // local cache).  This is because the tcx cache maintains the\n+        // invariant that it only contains things that have been\n+        // proven, and we have not yet proven that `predicate` holds.\n+        if predicate.is_global() && tcx.fulfilled_predicates.borrow().is_duplicate(predicate) {\n+            return true;\n         }\n+\n+        // If `predicate` is not global, or not present in the tcx\n+        // cache, we can still check for it in our local cache and add\n+        // it if not present. Note that if we find this predicate in\n+        // the local cache we can stop immediately, without reporting\n+        // any errors, even though we don't know yet if it is\n+        // true. This is because, while we don't yet know if the\n+        // predicate holds, we know that this same fulfillment context\n+        // already is in the process of finding out.\n+        self.duplicate_set.is_duplicate_or_add(predicate)\n     }\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n@@ -294,6 +279,12 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n             debug!(\"select_where_possible: outcome={:?}\", outcome);\n \n+            // these are obligations that were proven to be true.\n+            for pending_obligation in outcome.successful {\n+                let predicate = &pending_obligation.obligation.predicate;\n+                if predicate.is_global() {\n+                    selcx.tcx().fulfilled_predicates.borrow_mut()\n+                                                    .is_duplicate_or_add(predicate);\n                 }\n             }\n "}, {"sha": "b19628baa88be5b5300d092d81d30fd68fcfcf00", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c3f0123e9e3da95cf32ba789b11c522ae3c9afc/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c3f0123e9e3da95cf32ba789b11c522ae3c9afc/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=2c3f0123e9e3da95cf32ba789b11c522ae3c9afc", "patch": "@@ -139,7 +139,7 @@ fn test_env<F>(source_string: &str,\n                                lang_items,\n                                stability::Index::new(krate),\n                                |tcx| {\n-                                   let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n+                                   let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n                                    body(Env { infcx: &infcx });\n                                    let free_regions = FreeRegionMap::new();\n                                    infcx.resolve_regions_and_report_errors(&free_regions,"}]}