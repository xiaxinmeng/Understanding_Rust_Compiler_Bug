{"sha": "b65ebc4094589a65f76a49a790321f1417c67267", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NWViYzQwOTQ1ODlhNjVmNzZhNDlhNzkwMzIxZjE0MTdjNjcyNjc=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-14T00:44:02Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-17T02:57:43Z"}, "message": "better document the hacks required to test libcollections", "tree": {"sha": "76f3212810d4ad6ead0c4b46b34a4f55af11552c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76f3212810d4ad6ead0c4b46b34a4f55af11552c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b65ebc4094589a65f76a49a790321f1417c67267", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b65ebc4094589a65f76a49a790321f1417c67267", "html_url": "https://github.com/rust-lang/rust/commit/b65ebc4094589a65f76a49a790321f1417c67267", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b65ebc4094589a65f76a49a790321f1417c67267/comments", "author": null, "committer": null, "parents": [{"sha": "8256241d3af28bd835b267e27b6e24aeb5e799bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8256241d3af28bd835b267e27b6e24aeb5e799bd", "html_url": "https://github.com/rust-lang/rust/commit/8256241d3af28bd835b267e27b6e24aeb5e799bd"}], "stats": {"total": 236, "additions": 133, "deletions": 103}, "files": [{"sha": "3c7326dbd8f04f62cf6e9fabde5276fa6c1563f1", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b65ebc4094589a65f76a49a790321f1417c67267/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b65ebc4094589a65f76a49a790321f1417c67267/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=b65ebc4094589a65f76a49a790321f1417c67267", "patch": "@@ -84,8 +84,10 @@ macro_rules! vec {\n     ($($x:expr,)*) => (vec![$($x),*])\n }\n \n-// HACK: `impl [T]` is not available in cfg(test), use `::slice::into_vec`, instead of\n-// `<[T]>::to_vec`\n+// HACK(japaric): with cfg(test) the inherent `[T]::into_vec` method, which is required for this\n+// macro definition, is not available. Instead use the `slice::into_vec`  function which is only\n+// available with cfg(test)\n+// NB see the slice::hack module in slice.rs for more information\n #[cfg(not(stage0))]\n #[cfg(test)]\n macro_rules! vec {"}, {"sha": "dd9c265874467b9f427538325d6c2bf8e5882418", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 116, "deletions": 95, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/b65ebc4094589a65f76a49a790321f1417c67267/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b65ebc4094589a65f76a49a790321f1417c67267/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=b65ebc4094589a65f76a49a790321f1417c67267", "patch": "@@ -1083,30 +1083,113 @@ impl<T> SliceExt for [T] {\n     }\n }\n \n-// HACK: With cfg(test) `impl [T]` is not available, these three functions are actually methods\n-// that are in `impl [T]` but not in `core::slice::SliceExt` - this is only need for testing\n+// HACK(japaric) needed for the implementation of `vec!` macro during testing\n+// NB see the hack module in this file for more details\n+#[cfg(not(stage0))]\n #[cfg(test)]\n-pub fn into_vec<T>(mut b: Box<[T]>) -> Vec<T> {\n-    unsafe {\n-        let xs = Vec::from_raw_parts(b.as_mut_ptr(), b.len(), b.len());\n-        mem::forget(b);\n-        xs\n-    }\n-}\n+pub use self::hack::into_vec;\n \n+// HACK(japaric) needed for the implementation of `Vec::clone` during testing\n+// NB see the hack module in this file for more details\n+#[cfg(not(stage0))]\n #[cfg(test)]\n-pub fn permutations<T>(s: &[T]) -> Permutations<T> where T: Clone {\n-    Permutations{\n-        swaps: ElementSwaps::new(s.len()),\n-        v: ::slice::to_vec(s),\n+pub use self::hack::to_vec;\n+\n+// HACK(japaric): With cfg(test) `impl [T]` is not available, these three functions are actually\n+// methods that are in `impl [T]` but not in `core::slice::SliceExt` - we need to supply these\n+// functions for the `test_permutations` test\n+#[cfg(not(stage0))]\n+mod hack {\n+    use alloc::boxed::Box;\n+    use core::clone::Clone;\n+    #[cfg(test)]\n+    use core::iter::{Iterator, IteratorExt};\n+    use core::mem;\n+    #[cfg(test)]\n+    use core::option::Option::{Some, None};\n+\n+    #[cfg(test)]\n+    use string::ToString;\n+    use vec::Vec;\n+\n+    use super::{ElementSwaps, Permutations};\n+\n+    pub fn into_vec<T>(mut b: Box<[T]>) -> Vec<T> {\n+        unsafe {\n+            let xs = Vec::from_raw_parts(b.as_mut_ptr(), b.len(), b.len());\n+            mem::forget(b);\n+            xs\n+        }\n     }\n-}\n \n-#[cfg(test)]\n-pub fn to_vec<T>(s: &[T]) -> Vec<T> where T: Clone {\n-    let mut vector = Vec::with_capacity(s.len());\n-    vector.push_all(s);\n-    vector\n+    pub fn permutations<T>(s: &[T]) -> Permutations<T> where T: Clone {\n+        Permutations{\n+            swaps: ElementSwaps::new(s.len()),\n+            v: to_vec(s),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn to_vec<T>(s: &[T]) -> Vec<T> where T: Clone {\n+        let mut vector = Vec::with_capacity(s.len());\n+        vector.push_all(s);\n+        vector\n+    }\n+\n+    // NB we can remove this hack if we move this test to libcollectionstest - but that can't be\n+    // done right now because the test needs access to the private fields of Permutations\n+    #[test]\n+    fn test_permutations() {\n+        {\n+            let v: [i32; 0] = [];\n+            let mut it = permutations(&v);\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 1);\n+            assert_eq!(max_opt.unwrap(), 1);\n+            assert_eq!(it.next(), Some(to_vec(&v)));\n+            assert_eq!(it.next(), None);\n+        }\n+        {\n+            let v = [\"Hello\".to_string()];\n+            let mut it = permutations(&v);\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 1);\n+            assert_eq!(max_opt.unwrap(), 1);\n+            assert_eq!(it.next(), Some(to_vec(&v)));\n+            assert_eq!(it.next(), None);\n+        }\n+        {\n+            let v = [1, 2, 3];\n+            let mut it = permutations(&v);\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 3*2);\n+            assert_eq!(max_opt.unwrap(), 3*2);\n+            assert_eq!(it.next().unwrap(), [1,2,3]);\n+            assert_eq!(it.next().unwrap(), [1,3,2]);\n+            assert_eq!(it.next().unwrap(), [3,1,2]);\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 3);\n+            assert_eq!(max_opt.unwrap(), 3);\n+            assert_eq!(it.next().unwrap(), [3,2,1]);\n+            assert_eq!(it.next().unwrap(), [2,3,1]);\n+            assert_eq!(it.next().unwrap(), [2,1,3]);\n+            assert_eq!(it.next(), None);\n+        }\n+        {\n+            // check that we have N! permutations\n+            let v = ['A', 'B', 'C', 'D', 'E', 'F'];\n+            let mut amt = 0;\n+            let mut it = permutations(&v);\n+            let (min_size, max_opt) = it.size_hint();\n+            for _perm in it.by_ref() {\n+                amt += 1;\n+            }\n+            assert_eq!(amt, it.swaps.swaps_made);\n+            assert_eq!(amt, min_size);\n+            assert_eq!(amt, 2 * 3 * 4 * 5 * 6);\n+            assert_eq!(amt, max_opt.unwrap());\n+        }\n+    }\n }\n \n #[cfg(not(stage0))]\n@@ -1715,9 +1798,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_vec(&self) -> Vec<T> where T: Clone {\n-        let mut vector = Vec::with_capacity(self.len());\n-        vector.push_all(self);\n-        vector\n+        // NB see hack module in this file\n+        hack::to_vec(self)\n     }\n \n     /// Creates an iterator that yields every possible permutation of the\n@@ -1745,11 +1827,10 @@ impl<T> [T] {\n     /// assert_eq!(Some(vec![3, 1, 2]), perms.next());\n     /// ```\n     #[unstable(feature = \"collections\")]\n+    #[inline]\n     pub fn permutations(&self) -> Permutations<T> where T: Clone {\n-        Permutations{\n-            swaps: ElementSwaps::new(self.len()),\n-            v: self.to_vec(),\n-        }\n+        // NB see hack module in this file\n+        hack::permutations(self)\n     }\n \n     /// Copies as many elements from `src` as it can into `self` (the\n@@ -1931,12 +2012,10 @@ impl<T> [T] {\n \n     /// Convert `self` into a vector without clones or allocation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_vec(mut self: Box<Self>) -> Vec<T> {\n-        unsafe {\n-            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n-            mem::forget(self);\n-            xs\n-        }\n+    #[inline]\n+    pub fn into_vec(self: Box<Self>) -> Vec<T> {\n+        // NB see hack module in this file\n+        hack::into_vec(self)\n     }\n }\n \n@@ -2052,10 +2131,12 @@ impl<T: Clone> ToOwned for [T] {\n     #[cfg(not(test))]\n     fn to_owned(&self) -> Vec<T> { self.to_vec() }\n \n-    // HACK: `impl [T]` is not available in cfg(test), use `::slice::to_vec` instead of\n-    // `<[T]>::to_vec`\n+    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec`, which is required for this method\n+    // definition, is not available. Since we don't require this method for testing purposes, I'll\n+    // just stub it\n+    // NB see the slice::hack module in slice.rs for more information\n     #[cfg(test)]\n-    fn to_owned(&self) -> Vec<T> { ::slice::to_vec(self) }\n+    fn to_owned(&self) -> Vec<T> { panic!(\"not available with cfg(test)\") }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -2372,63 +2453,3 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n         old\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use core::iter::{Iterator, IteratorExt};\n-    use core::option::Option::{None, Some};\n-    use string::ToString;\n-\n-    #[test]\n-    fn test_permutations() {\n-        {\n-            let v: [i32; 0] = [];\n-            let mut it = ::slice::permutations(&v);\n-            let (min_size, max_opt) = it.size_hint();\n-            assert_eq!(min_size, 1);\n-            assert_eq!(max_opt.unwrap(), 1);\n-            assert_eq!(it.next(), Some(::slice::to_vec(&v)));\n-            assert_eq!(it.next(), None);\n-        }\n-        {\n-            let v = [\"Hello\".to_string()];\n-            let mut it = ::slice::permutations(&v);\n-            let (min_size, max_opt) = it.size_hint();\n-            assert_eq!(min_size, 1);\n-            assert_eq!(max_opt.unwrap(), 1);\n-            assert_eq!(it.next(), Some(::slice::to_vec(&v)));\n-            assert_eq!(it.next(), None);\n-        }\n-        {\n-            let v = [1, 2, 3];\n-            let mut it = ::slice::permutations(&v);\n-            let (min_size, max_opt) = it.size_hint();\n-            assert_eq!(min_size, 3*2);\n-            assert_eq!(max_opt.unwrap(), 3*2);\n-            assert_eq!(it.next().unwrap(), [1,2,3]);\n-            assert_eq!(it.next().unwrap(), [1,3,2]);\n-            assert_eq!(it.next().unwrap(), [3,1,2]);\n-            let (min_size, max_opt) = it.size_hint();\n-            assert_eq!(min_size, 3);\n-            assert_eq!(max_opt.unwrap(), 3);\n-            assert_eq!(it.next().unwrap(), [3,2,1]);\n-            assert_eq!(it.next().unwrap(), [2,3,1]);\n-            assert_eq!(it.next().unwrap(), [2,1,3]);\n-            assert_eq!(it.next(), None);\n-        }\n-        {\n-            // check that we have N! permutations\n-            let v = ['A', 'B', 'C', 'D', 'E', 'F'];\n-            let mut amt = 0;\n-            let mut it = ::slice::permutations(&v);\n-            let (min_size, max_opt) = it.size_hint();\n-            for _perm in it.by_ref() {\n-                amt += 1;\n-            }\n-            assert_eq!(amt, it.swaps.swaps_made);\n-            assert_eq!(amt, min_size);\n-            assert_eq!(amt, 2 * 3 * 4 * 5 * 6);\n-            assert_eq!(amt, max_opt.unwrap());\n-        }\n-    }\n-}"}, {"sha": "9d178eb5413c30b99efb7af1a31e44a57d945513", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b65ebc4094589a65f76a49a790321f1417c67267/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b65ebc4094589a65f76a49a790321f1417c67267/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b65ebc4094589a65f76a49a790321f1417c67267", "patch": "@@ -118,12 +118,14 @@ impl String {\n         String { vec: <[_]>::to_vec(string.as_bytes()) }\n     }\n \n-    // HACK: `impl [T]` is not available in cfg(test), use `::slice::to_vec` instead of\n-    // `<[T]>::to_vec`\n+    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is required for this\n+    // method definition, is not available. Since we don't require this method for testing\n+    // purposes, I'll just stub it\n+    // NB see the slice::hack module in slice.rs for more information\n     #[inline]\n     #[cfg(test)]\n-    pub fn from_str(string: &str) -> String {\n-        String { vec: ::slice::to_vec(string.as_bytes()) }\n+    pub fn from_str(_: &str) -> String {\n+        panic!(\"not available with cfg(test)\");\n     }\n \n     /// Returns the vector as a string buffer, if possible, taking care not to"}, {"sha": "3bd57cc36244851947217c981692985a99569486", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b65ebc4094589a65f76a49a790321f1417c67267/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b65ebc4094589a65f76a49a790321f1417c67267/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=b65ebc4094589a65f76a49a790321f1417c67267", "patch": "@@ -1290,10 +1290,15 @@ impl<T:Clone> Clone for Vec<T> {\n     #[cfg(not(test))]\n     fn clone(&self) -> Vec<T> { <[T]>::to_vec(&**self) }\n \n-    // HACK: `impl [T]` not available in cfg(test), use `::slice::to_vec` instead of `<[T]>::to_vec`\n+    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is required for this\n+    // method definition, is not available. Instead use the `slice::to_vec`  function which is only\n+    // available with cfg(test)\n+    // NB see the slice::hack module in slice.rs for more information\n     #[cfg(not(stage0))]\n     #[cfg(test)]\n-    fn clone(&self) -> Vec<T> { ::slice::to_vec(&**self) }\n+    fn clone(&self) -> Vec<T> {\n+        ::slice::to_vec(&**self)\n+    }\n \n     fn clone_from(&mut self, other: &Vec<T>) {\n         // drop anything in self that will not be overwritten"}]}