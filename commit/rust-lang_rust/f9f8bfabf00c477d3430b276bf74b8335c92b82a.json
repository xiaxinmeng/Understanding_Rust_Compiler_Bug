{"sha": "f9f8bfabf00c477d3430b276bf74b8335c92b82a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZjhiZmFiZjAwYzQ3N2QzNDMwYjI3NmJmNzRiODMzNWM5MmI4MmE=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-05-30T21:27:12Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-10T21:43:57Z"}, "message": "Collect conflict information in GeneratorLayout", "tree": {"sha": "1095b5307e8c1290a861ff48406671e9cad435e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1095b5307e8c1290a861ff48406671e9cad435e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9f8bfabf00c477d3430b276bf74b8335c92b82a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f8bfabf00c477d3430b276bf74b8335c92b82a", "html_url": "https://github.com/rust-lang/rust/commit/f9f8bfabf00c477d3430b276bf74b8335c92b82a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9f8bfabf00c477d3430b276bf74b8335c92b82a/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a73ecb3d9c432f8f53117b1a6b6c209dc802dee7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a73ecb3d9c432f8f53117b1a6b6c209dc802dee7", "html_url": "https://github.com/rust-lang/rust/commit/a73ecb3d9c432f8f53117b1a6b6c209dc802dee7"}], "stats": {"total": 183, "additions": 179, "deletions": 4}, "files": [{"sha": "149d067204fa2fb07a83a27f850813570a60d718", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f9f8bfabf00c477d3430b276bf74b8335c92b82a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f8bfabf00c477d3430b276bf74b8335c92b82a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=f9f8bfabf00c477d3430b276bf74b8335c92b82a", "patch": "@@ -9,6 +9,7 @@ use crate::hir::def_id::DefId;\n use crate::hir::{self, InlineAsm as HirInlineAsm};\n use crate::mir::interpret::{ConstValue, InterpError, Scalar};\n use crate::mir::visit::MirVisitable;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n@@ -1500,6 +1501,13 @@ impl<'tcx> BasicBlockData<'tcx> {\n         self.terminator.as_mut().expect(\"invalid terminator state\")\n     }\n \n+    pub fn is_unreachable(&self) -> bool {\n+        match self.terminator().kind {\n+            TerminatorKind::Unreachable => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn retain_statements<F>(&mut self, mut f: F)\n     where\n         F: FnMut(&mut Statement<'_>) -> bool,\n@@ -2997,6 +3005,11 @@ pub struct GeneratorLayout<'tcx> {\n     /// be stored in multiple variants.\n     pub variant_fields: IndexVec<VariantIdx, IndexVec<Field, GeneratorSavedLocal>>,\n \n+    /// Which saved locals are storage-live at the same time. Locals that do not\n+    /// have conflicts with each other are allowed to overlap in the computed\n+    /// layout.\n+    pub storage_conflicts: IndexVec<GeneratorSavedLocal, BitSet<GeneratorSavedLocal>>,\n+\n     /// Names and scopes of all the stored generator locals.\n     /// NOTE(tmandry) This is *strictly* a temporary hack for codegen\n     /// debuginfo generation, and will be removed at some point.\n@@ -3193,6 +3206,7 @@ BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for GeneratorLayout<'tcx> {\n         field_tys,\n         variant_fields,\n+        storage_conflicts,\n         __local_debuginfo_codegen_only_do_not_use,\n     }\n }\n@@ -3572,6 +3586,15 @@ impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n     }\n }\n \n+impl<'tcx, T: Idx> TypeFoldable<'tcx> for BitSet<T> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> Self {\n+        self.clone()\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         Constant {"}, {"sha": "0c1a06b4a1f60e0380200c7604140cec393063de", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f9f8bfabf00c477d3430b276bf74b8335c92b82a/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f8bfabf00c477d3430b276bf74b8335c92b82a/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=f9f8bfabf00c477d3430b276bf74b8335c92b82a", "patch": "@@ -380,6 +380,62 @@ pub fn state_for_location<'tcx, T: BitDenotation<'tcx>>(loc: Location,\n     gen_set.to_dense()\n }\n \n+/// Calls `f` with the dataflow state at every location in `mir`.\n+/// Ignores blocks that terminate in `unreachable`.\n+pub fn for_each_location<'tcx, T: BitDenotation<'tcx>>(\n+    mir: &Body<'tcx>,\n+    analysis: &T,\n+    result: &DataflowResults<'tcx, T>,\n+    mut f: impl FnMut(&HybridBitSet<T::Idx>, Location)\n+) {\n+    for (block, bb_data) in mir.basic_blocks().iter_enumerated() {\n+        if bb_data.is_unreachable() {\n+            continue;\n+        }\n+        for_each_block_location(mir, block, bb_data, analysis, result, &mut f);\n+    }\n+}\n+\n+fn for_each_block_location<'tcx, T: BitDenotation<'tcx>>(\n+    mir: &Body<'tcx>,\n+    block: BasicBlock,\n+    bb_data: &BasicBlockData<'tcx>,\n+    analysis: &T,\n+    result: &DataflowResults<'tcx, T>,\n+    f: &mut impl FnMut(&HybridBitSet<T::Idx>, Location)\n+) {\n+    let statements = &bb_data.statements;\n+\n+    let mut on_entry = result.sets().on_entry_set_for(block.index()).to_owned();\n+    let mut kill_set = on_entry.to_hybrid();\n+    let mut gen_set = kill_set.clone();\n+\n+    {\n+        let mut sets = BlockSets {\n+            on_entry: &mut on_entry,\n+            kill_set: &mut kill_set,\n+            gen_set: &mut gen_set,\n+        };\n+        // FIXME: This location is technically wrong, but there isn't a way to\n+        // denote the start of a block.\n+        f(sets.gen_set, Location { block, statement_index: 0 });\n+\n+        for statement_index in 0..statements.len() {\n+            let loc = Location { block, statement_index };\n+            analysis.before_statement_effect(&mut sets, loc);\n+            f(sets.gen_set, loc);\n+            analysis.statement_effect(&mut sets, loc);\n+            f(sets.gen_set, loc);\n+        }\n+\n+        let term_loc = Location { block, statement_index: mir[block].statements.len() };\n+        analysis.before_terminator_effect(&mut sets, term_loc);\n+        f(sets.gen_set, term_loc);\n+        analysis.before_statement_effect(&mut sets, term_loc);\n+        f(sets.gen_set, term_loc);\n+    }\n+}\n+\n pub struct DataflowAnalysis<'a, 'tcx: 'a, O> where O: BitDenotation<'tcx>\n {\n     flow_state: DataflowState<'tcx, O>,"}, {"sha": "c1fc49e42c8ede92be95d5ce515c24d6b978bf2a", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 100, "deletions": 4, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f9f8bfabf00c477d3430b276bf74b8335c92b82a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f8bfabf00c477d3430b276bf74b8335c92b82a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=f9f8bfabf00c477d3430b276bf74b8335c92b82a", "patch": "@@ -66,7 +66,8 @@ use std::mem;\n use crate::transform::{MirPass, MirSource};\n use crate::transform::simplify;\n use crate::transform::no_landing_pads::no_landing_pads;\n-use crate::dataflow::{do_dataflow, DebugFormatted, state_for_location};\n+use crate::dataflow::{DataflowResults};\n+use crate::dataflow::{do_dataflow, DebugFormatted, state_for_location, for_each_location};\n use crate::dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals};\n use crate::util::dump_mir;\n use crate::util::liveness;\n@@ -400,6 +401,7 @@ fn locals_live_across_suspend_points(\n     movable: bool,\n ) -> (\n     liveness::LiveVarSet,\n+    IndexVec<GeneratorSavedLocal, BitSet<GeneratorSavedLocal>>,\n     FxHashMap<BasicBlock, liveness::LiveVarSet>,\n     BitSet<BasicBlock>,\n ) {\n@@ -503,7 +505,99 @@ fn locals_live_across_suspend_points(\n     // The generator argument is ignored\n     set.remove(self_arg());\n \n-    (set, storage_liveness_map, suspending_blocks)\n+    let storage_conflicts = compute_storage_conflicts(\n+        body,\n+        &set,\n+        &ignored,\n+        storage_live,\n+        storage_live_analysis);\n+\n+    (set, storage_conflicts, storage_liveness_map, suspending_blocks)\n+}\n+\n+/// For every saved local, looks for which locals are StorageLive at the same\n+/// time. Generates a bitset for every local of all the other locals that may be\n+/// StorageLive simultaneously with that local. This is used in the layout\n+/// computation; see `GeneratorLayout` for more.\n+fn compute_storage_conflicts(\n+    body: &'mir Body<'tcx>,\n+    stored_locals: &liveness::LiveVarSet,\n+    ignored: &StorageIgnored,\n+    storage_live: DataflowResults<'tcx, MaybeStorageLive<'mir, 'tcx>>,\n+    storage_live_analysis: MaybeStorageLive<'mir, 'tcx>,\n+) -> IndexVec<GeneratorSavedLocal, BitSet<GeneratorSavedLocal>> {\n+    debug!(\"compute_storage_conflicts({:?})\", body.span);\n+    debug!(\"ignored = {:?}\", ignored.0);\n+\n+    // Storage ignored locals are not eligible for overlap, since their storage\n+    // is always live.\n+    let mut ineligible_locals = ignored.0.clone();\n+    ineligible_locals.intersect(&stored_locals);\n+\n+    // Of our remaining candidates, find out if any have overlapping storage\n+    // liveness. Those that do must be in the same variant to remain candidates.\n+    // FIXME(tmandry): Consider using sparse bitsets here once we have good\n+    // benchmarks for generators.\n+    let mut local_conflicts: IndexVec<Local, _> =\n+        // Add conflicts for every ineligible local.\n+        iter::repeat(ineligible_locals.clone())\n+        .take(body.local_decls.len())\n+        .collect();\n+\n+    for_each_location(body, &storage_live_analysis, &storage_live, |state, loc| {\n+        let mut eligible_storage_live = state.clone().to_dense();\n+        eligible_storage_live.intersect(&stored_locals);\n+\n+        for local in eligible_storage_live.iter() {\n+            let mut overlaps = eligible_storage_live.clone();\n+            overlaps.remove(local);\n+            local_conflicts[local].union(&overlaps);\n+\n+            if !overlaps.is_empty() {\n+                trace!(\"at {:?}, local {:?} conflicts with {:?}\",\n+                       loc, local, overlaps);\n+            }\n+        }\n+    });\n+\n+    // NOTE: Today we store a full conflict bitset for every local. Technically\n+    // this is twice as many bits as we need, since the relation is symmetric.\n+    // However, in practice these bitsets are not usually large. The layout code\n+    // also needs to keep track of how many conflicts each local has, so it's\n+    // simpler to keep it this way for now.\n+    let storage_conflicts: IndexVec<GeneratorSavedLocal, _> = stored_locals\n+        .iter()\n+        .map(|local_a| {\n+            if ineligible_locals.contains(local_a) {\n+                // Conflicts with everything.\n+                BitSet::new_filled(stored_locals.count())\n+            } else {\n+                // Keep overlap information only for stored locals.\n+                renumber_bitset(&local_conflicts[local_a], stored_locals)\n+            }\n+        })\n+        .collect();\n+\n+    storage_conflicts\n+}\n+\n+/// Renumbers the items present in `stored_locals` and applies the renumbering\n+/// to 'input`.\n+///\n+/// For example, if `stored_locals = [1, 3, 5]`, this would be renumbered to\n+/// `[0, 1, 2]`. Thus, if `input = [3, 5]` we would return `[1, 2]`.\n+fn renumber_bitset(input: &BitSet<Local>, stored_locals: &liveness::LiveVarSet)\n+-> BitSet<GeneratorSavedLocal> {\n+    assert!(stored_locals.superset(&input), \"{:?} not a superset of {:?}\", stored_locals, input);\n+    let mut out = BitSet::new_empty(stored_locals.count());\n+    for (idx, local) in stored_locals.iter().enumerate() {\n+        let saved_local = GeneratorSavedLocal::from(idx);\n+        if input.contains(local) {\n+            out.insert(saved_local);\n+        }\n+    }\n+    debug!(\"renumber_bitset({:?}, {:?}) => {:?}\", input, stored_locals, out);\n+    out\n }\n \n fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -517,7 +611,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         FxHashMap<BasicBlock, liveness::LiveVarSet>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n-    let (live_locals, storage_liveness, suspending_blocks) =\n+    let (live_locals, storage_conflicts, storage_liveness, suspending_blocks) =\n         locals_live_across_suspend_points(tcx, body, source, movable);\n \n     // Erase regions from the types passed in from typeck so we can compare them with\n@@ -547,7 +641,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let dummy_local = LocalDecl::new_internal(tcx.mk_unit(), body.span);\n \n-    // Gather live locals and their indices replacing values in mir.local_decls with a dummy\n+    // Gather live locals and their indices replacing values in body.local_decls with a dummy\n     // to avoid changing local indices\n     let live_decls = live_locals.iter().map(|local| {\n         let var = mem::replace(&mut body.local_decls[local], dummy_local.clone());\n@@ -568,6 +662,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         remap.insert(local, (var.ty, variant_index, idx));\n         decls.push(var);\n     }\n+    debug!(\"generator saved local mappings: {:?}\", decls);\n     let field_tys = decls.iter().map(|field| field.ty).collect::<IndexVec<_, _>>();\n \n     // Put every var in each variant, for now.\n@@ -578,6 +673,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let layout = GeneratorLayout {\n         field_tys,\n         variant_fields: empty_variants.chain(state_variants).collect(),\n+        storage_conflicts,\n         __local_debuginfo_codegen_only_do_not_use: decls,\n     };\n "}]}