{"sha": "f4e45ff2b7fc60152ba5bbc595c4ba602dfe7680", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZTQ1ZmYyYjdmYzYwMTUyYmE1YmJjNTk1YzRiYTYwMmRmZTc2ODA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-06T16:46:54Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-08T07:29:34Z"}, "message": "sort the fields ourselves", "tree": {"sha": "4d1530fd9f566242b62d7cd350cbbb8ecbd2864b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d1530fd9f566242b62d7cd350cbbb8ecbd2864b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4e45ff2b7fc60152ba5bbc595c4ba602dfe7680", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4e45ff2b7fc60152ba5bbc595c4ba602dfe7680", "html_url": "https://github.com/rust-lang/rust/commit/f4e45ff2b7fc60152ba5bbc595c4ba602dfe7680", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4e45ff2b7fc60152ba5bbc595c4ba602dfe7680/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00936316d18b3c1cfa7924f119bbe6061c8cb9f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/00936316d18b3c1cfa7924f119bbe6061c8cb9f6", "html_url": "https://github.com/rust-lang/rust/commit/00936316d18b3c1cfa7924f119bbe6061c8cb9f6"}], "stats": {"total": 37, "additions": 32, "deletions": 5}, "files": [{"sha": "880b18c7d5426c4afa0c3ec320eda75252af8954", "filename": "src/helpers.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f4e45ff2b7fc60152ba5bbc595c4ba602dfe7680/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e45ff2b7fc60152ba5bbc595c4ba602dfe7680/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=f4e45ff2b7fc60152ba5bbc595c4ba602dfe7680", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n \n-use rustc::ty;\n+use rustc::ty::{self, layout};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n \n use crate::*;\n@@ -124,8 +124,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     let (unsafe_cell_size, _) = self.size_and_align_of_mplace(place)?\n                         // for extern types, just cover what we can\n                         .unwrap_or_else(|| place.layout.size_and_align());\n-                    // Now handle this `UnsafeCell`.\n-                    unsafe_cell_action(place.ptr.get_ptr_offset(self), unsafe_cell_size)\n+                    // Now handle this `UnsafeCell`, unless it is empty.\n+                    if unsafe_cell_size != Size::ZERO {\n+                        unsafe_cell_action(place.ptr.get_ptr_offset(self), unsafe_cell_size)\n+                    } else {\n+                        Ok(())\n+                    }\n                 },\n             };\n             visitor.visit_value(place)?;\n@@ -152,8 +156,6 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         {\n             type V = MPlaceTy<'tcx, Borrow>;\n \n-            const WANT_FIELDS_SORTED: bool = true; // sorted? yes please!\n-\n             #[inline(always)]\n             fn ecx(&self) -> &MiriEvalContext<'a, 'mir, 'tcx> {\n                 &self.ecx\n@@ -179,6 +181,31 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 }\n             }\n \n+            // Make sure we visit aggregrates in increasing offset order\n+            fn visit_aggregate(\n+                &mut self,\n+                place: MPlaceTy<'tcx, Borrow>,\n+                fields: impl Iterator<Item=EvalResult<'tcx, MPlaceTy<'tcx, Borrow>>>,\n+            ) -> EvalResult<'tcx> {\n+                match place.layout.fields {\n+                    layout::FieldPlacement::Array { .. } => {\n+                        // For the array layout, we know the iterator will yield sorted elements so\n+                        // we can avoid the allocation.\n+                        self.walk_aggregate(place, fields)\n+                    }\n+                    layout::FieldPlacement::Arbitrary { .. } => {\n+                        // Gather the subplaces and sort them before visiting.\n+                        let mut places = fields.collect::<EvalResult<'tcx, Vec<MPlaceTy<'tcx, Borrow>>>>()?;\n+                        places[..].sort_by_key(|place| place.ptr.get_ptr_offset(self.ecx()));\n+                        self.walk_aggregate(place, places.into_iter().map(Ok))\n+                    }\n+                    layout::FieldPlacement::Union { .. } => {\n+                        // Uh, what?\n+                        bug!(\"A union is not an aggregate we should ever visit\")\n+                    }\n+                }\n+            }\n+\n             // We have to do *something* for unions\n             fn visit_union(&mut self, v: MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n             {"}]}