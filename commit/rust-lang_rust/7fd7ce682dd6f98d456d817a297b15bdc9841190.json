{"sha": "7fd7ce682dd6f98d456d817a297b15bdc9841190", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmZDdjZTY4MmRkNmY5OGQ0NTZkODE3YTI5N2IxNWJkYzk4NDExOTA=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-01T16:14:35Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-19T07:31:51Z"}, "message": "Add blocking support module for channels", "tree": {"sha": "085fc03c792d463bbfd1a2532274670e4175379a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/085fc03c792d463bbfd1a2532274670e4175379a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fd7ce682dd6f98d456d817a297b15bdc9841190", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fd7ce682dd6f98d456d817a297b15bdc9841190", "html_url": "https://github.com/rust-lang/rust/commit/7fd7ce682dd6f98d456d817a297b15bdc9841190", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fd7ce682dd6f98d456d817a297b15bdc9841190/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84cb6cd9386ab01ba59f8ed98d698f9af74e65fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/84cb6cd9386ab01ba59f8ed98d698f9af74e65fe", "html_url": "https://github.com/rust-lang/rust/commit/84cb6cd9386ab01ba59f8ed98d698f9af74e65fe"}], "stats": {"total": 665, "additions": 357, "deletions": 308}, "files": [{"sha": "5e9a01d0151d02a2b2d6e47d56a57ba426229f39", "filename": "src/libstd/comm/blocking.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fblocking.rs?ref=7fd7ce682dd6f98d456d817a297b15bdc9841190", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Generic support for building blocking abstractions.\n+\n+use thread::Thread;\n+use sync::atomic::{AtomicBool, INIT_ATOMIC_BOOL, Ordering};\n+use sync::Arc;\n+use kinds::marker::NoSend;\n+use mem;\n+use clone::Clone;\n+\n+struct Inner {\n+    thread: Thread,\n+    woken: AtomicBool,\n+}\n+\n+#[deriving(Clone)]\n+pub struct SignalToken {\n+    inner: Arc<Inner>,\n+}\n+\n+pub struct WaitToken {\n+    inner: Arc<Inner>,\n+    no_send: NoSend,\n+}\n+\n+fn token() -> (WaitToken, SignalToken) {\n+    let inner = Arc::new(Inner {\n+        thread: Thread::current(),\n+        woken: INIT_ATOMIC_BOOL,\n+    });\n+    let wait_token = WaitToken {\n+        inner: inner.clone(),\n+        no_send: NoSend,\n+    };\n+    let signal_token = SignalToken {\n+        inner: inner\n+    };\n+    (wait_token, signal_token)\n+}\n+\n+impl SignalToken {\n+    fn signal(&self) -> bool {\n+        let wake = !self.inner.woken.compare_and_swap(false, true, Ordering::SeqCst);\n+        if wake {\n+            self.inner.thread.unpark();\n+        }\n+        wake\n+    }\n+\n+    /// Convert to an unsafe uint value. Useful for storing in a pipe's state\n+    /// flag.\n+    #[inline]\n+    pub unsafe fn cast_to_uint(self) -> uint {\n+        mem::transmute(self.inner)\n+    }\n+\n+    /// Convert from an unsafe uint value. Useful for retrieving a pipe's state\n+    /// flag.\n+    #[inline]\n+    pub unsafe fn cast_from_uint(signal_ptr: uint) -> SignalToken {\n+        SignalToken { inner: mem::transmute(signal_ptr) }\n+    }\n+\n+}\n+\n+impl WaitToken {\n+    fn wait(self) {\n+        while !self.inner.woken.load(Ordering::SeqCst) {\n+            Thread::park()\n+        }\n+    }\n+}"}, {"sha": "e5ec0078c5ef0b8f8468ea56a3edfdee5f46d21b", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=7fd7ce682dd6f98d456d817a297b15bdc9841190", "patch": "@@ -54,17 +54,6 @@\n //! There are methods on both of senders and receivers to perform their\n //! respective operations without panicking, however.\n //!\n-//! ## Runtime Requirements\n-//!\n-//! The channel types defined in this module generally have very few runtime\n-//! requirements in order to operate. The major requirement they have is for a\n-//! local rust `Task` to be available if any *blocking* operation is performed.\n-//!\n-//! If a local `Task` is not available (for example an FFI callback), then the\n-//! `send` operation is safe on a `Sender` (as well as a `send_opt`) as well as\n-//! the `try_send` method on a `SyncSender`, but no other operations are\n-//! guaranteed to be safe.\n-//!\n //! # Example\n //!\n //! Simple usage:\n@@ -327,9 +316,9 @@ use alloc::arc::Arc;\n use core::kinds::marker;\n use core::mem;\n use core::cell::UnsafeCell;\n-use rt::task::BlockedTask;\n \n pub use comm::select::{Select, Handle};\n+use comm::select::StartResult::*;\n \n macro_rules! test {\n     { fn $name:ident() $b:block $(#[$a:meta])*} => (\n@@ -348,6 +337,7 @@ macro_rules! test {\n     )\n }\n \n+mod blocking;\n mod oneshot;\n mod select;\n mod shared;\n@@ -947,34 +937,33 @@ impl<T: Send> select::Packet for Receiver<T> {\n         }\n     }\n \n-    fn start_selection(&self, mut task: BlockedTask) -> Result<(), BlockedTask>{\n+    fn start_selection(&self, mut token: SignalToken) -> bool {\n         loop {\n             let (t, new_port) = match *unsafe { self.inner() } {\n                 Oneshot(ref p) => {\n-                    match unsafe { (*p.get()).start_selection(task) } {\n-                        oneshot::SelSuccess => return Ok(()),\n-                        oneshot::SelCanceled(task) => return Err(task),\n+                    match unsafe { (*p.get()).start_selection(token) } {\n+                        oneshot::SelSuccess => return Installed,\n+                        oneshot::SelCanceled => return Abort,\n                         oneshot::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n                 Stream(ref p) => {\n-                    match unsafe { (*p.get()).start_selection(task) } {\n-                        stream::SelSuccess => return Ok(()),\n-                        stream::SelCanceled(task) => return Err(task),\n+                    match unsafe { (*p.get()).start_selection(token) } {\n+                        stream::SelSuccess => return Installed,\n+                        stream::SelCanceled => return Abort,\n                         stream::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n                 Shared(ref p) => {\n-                    return unsafe { (*p.get()).start_selection(task) };\n+                    return unsafe { (*p.get()).start_selection(token) };\n                 }\n                 Sync(ref p) => {\n-                    return unsafe { (*p.get()).start_selection(task) };\n+                    return unsafe { (*p.get()).start_selection(token) };\n                 }\n             };\n-            task = t;\n+            token = t;\n             unsafe {\n-                mem::swap(self.inner_mut(),\n-                          new_port.inner_mut());\n+                mem::swap(self.inner_mut(), new_port.inner_mut());\n             }\n         }\n     }"}, {"sha": "68f3f229cb48783927952db50efc4b3a17a7a6e1", "filename": "src/libstd/comm/oneshot.rs", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Foneshot.rs?ref=7fd7ce682dd6f98d456d817a297b15bdc9841190", "patch": "@@ -40,17 +40,20 @@ use self::MyUpgrade::*;\n use core::prelude::*;\n \n use alloc::boxed::Box;\n+use comm::Receiver;\n+use comm::blocking::{mod, WaitToken, SignalToken};\n use core::mem;\n-use rt::local::Local;\n-use rt::task::{Task, BlockedTask};\n-\n use sync::atomic;\n-use comm::Receiver;\n \n // Various states you can find a port in.\n-const EMPTY: uint = 0;\n-const DATA: uint = 1;\n-const DISCONNECTED: uint = 2;\n+const EMPTY: uint = 0;          // initial state: no data, no blocked reciever\n+const DATA: uint = 1;           // data ready for receiver to take\n+const DISCONNECTED: uint = 2;   // channel is disconnected OR upgraded\n+// Any other value represents a pointer to a SignalToken value. The\n+// protocol ensures that when the state moves *to* a pointer,\n+// ownership of the token is given to the packet, and when the state\n+// moves *from* a pointer, ownership of the token is transferred to\n+// whoever changed the state.\n \n pub struct Packet<T> {\n     // Internal state of the chan/port pair (stores the blocked task as well)\n@@ -71,12 +74,12 @@ pub enum Failure<T> {\n pub enum UpgradeResult {\n     UpSuccess,\n     UpDisconnected,\n-    UpWoke(BlockedTask),\n+    UpWoke(SignalToken),\n }\n \n pub enum SelectionResult<T> {\n-    SelCanceled(BlockedTask),\n-    SelUpgraded(BlockedTask, Receiver<T>),\n+    SelCanceled,\n+    SelUpgraded(SignalToken, Receiver<T>),\n     SelSuccess,\n }\n \n@@ -118,12 +121,10 @@ impl<T: Send> Packet<T> {\n             // Not possible, these are one-use channels\n             DATA => unreachable!(),\n \n-            // Anything else means that there was a task waiting on the other\n-            // end. We leave the 'DATA' state inside so it'll pick it up on the\n-            // other end.\n-            n => unsafe {\n-                let t = BlockedTask::cast_from_uint(n);\n-                t.wake().map(|t| t.reawaken());\n+            // There is a thread waiting on the other end. We leave the 'DATA'\n+            // state inside so it'll pick it up on the other end.\n+            ptr => unsafe {\n+                SignalToken::cast_from_uint(ptr).signal();\n                 Ok(())\n             }\n         }\n@@ -142,23 +143,17 @@ impl<T: Send> Packet<T> {\n         // Attempt to not block the task (it's a little expensive). If it looks\n         // like we're not empty, then immediately go through to `try_recv`.\n         if self.state.load(atomic::SeqCst) == EMPTY {\n-            let t: Box<Task> = Local::take();\n-            t.deschedule(1, |task| {\n-                let n = unsafe { task.cast_to_uint() };\n-                match self.state.compare_and_swap(EMPTY, n, atomic::SeqCst) {\n-                    // Nothing on the channel, we legitimately block\n-                    EMPTY => Ok(()),\n-\n-                    // If there's data or it's a disconnected channel, then we\n-                    // failed the cmpxchg, so we just wake ourselves back up\n-                    DATA | DISCONNECTED => {\n-                        unsafe { Err(BlockedTask::cast_from_uint(n)) }\n-                    }\n-\n-                    // Only one thread is allowed to sleep on this port\n-                    _ => unreachable!()\n-                }\n-            });\n+            let (wait_token, signal_token) = blocking::token();\n+            let ptr = unsafe { signal_token.cast_to_uint() };\n+\n+            // race with senders to enter the blocking state\n+            if self.state.compare_and_swap(EMPTY, ptr, atomic::SeqCst) == EMPTY {\n+                wait_token.wait();\n+                debug_assert!(self.state.load(atomic::SeqCst) != EMPTY);\n+            } else {\n+                // drop the signal token, since we never blocked\n+                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+            }\n         }\n \n         self.try_recv()\n@@ -197,6 +192,9 @@ impl<T: Send> Packet<T> {\n                     }\n                 }\n             }\n+\n+            // We are the sole receiver; there cannot be a blocking\n+            // receiver already.\n             _ => unreachable!()\n         }\n     }\n@@ -223,7 +221,7 @@ impl<T: Send> Packet<T> {\n             DISCONNECTED => { self.upgrade = prev; UpDisconnected }\n \n             // If someone's waiting, we gotta wake them up\n-            n => UpWoke(unsafe { BlockedTask::cast_from_uint(n) })\n+            ptr => UpWoke(unsafe { SignalToken::cast_from_uint(ptr) })\n         }\n     }\n \n@@ -232,9 +230,8 @@ impl<T: Send> Packet<T> {\n             DATA | DISCONNECTED | EMPTY => {}\n \n             // If someone's waiting, we gotta wake them up\n-            n => unsafe {\n-                let t = BlockedTask::cast_from_uint(n);\n-                t.wake().map(|t| t.reawaken());\n+            ptr => unsafe {\n+                SignalToken::cast_from_uint(ptr).signal();\n             }\n         }\n     }\n@@ -286,30 +283,34 @@ impl<T: Send> Packet<T> {\n \n     // Attempts to start selection on this port. This can either succeed, fail\n     // because there is data, or fail because there is an upgrade pending.\n-    pub fn start_selection(&mut self, task: BlockedTask) -> SelectionResult<T> {\n-        let n = unsafe { task.cast_to_uint() };\n-        match self.state.compare_and_swap(EMPTY, n, atomic::SeqCst) {\n+    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> {\n+        let ptr = unsafe { token.cast_to_uint() };\n+        match self.state.compare_and_swap(EMPTY, ptr, atomic::SeqCst) {\n             EMPTY => SelSuccess,\n-            DATA => SelCanceled(unsafe { BlockedTask::cast_from_uint(n) }),\n+            DATA => {\n+                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                SelCanceled\n+            }\n             DISCONNECTED if self.data.is_some() => {\n-                SelCanceled(unsafe { BlockedTask::cast_from_uint(n) })\n+                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                SelCanceled\n             }\n             DISCONNECTED => {\n                 match mem::replace(&mut self.upgrade, SendUsed) {\n                     // The other end sent us an upgrade, so we need to\n                     // propagate upwards whether the upgrade can receive\n                     // data\n                     GoUp(upgrade) => {\n-                        SelUpgraded(unsafe { BlockedTask::cast_from_uint(n) },\n-                                    upgrade)\n+                        SelUpgraded(unsafe { SignalToken::cast_from_uint(ptr) }, upgrade)\n                     }\n \n                     // If the other end disconnected without sending an\n                     // upgrade, then we have data to receive (the channel is\n                     // disconnected).\n                     up => {\n                         self.upgrade = up;\n-                        SelCanceled(unsafe { BlockedTask::cast_from_uint(n) })\n+                        drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                        SelCanceled\n                     }\n                 }\n             }\n@@ -331,7 +332,7 @@ impl<T: Send> Packet<T> {\n \n             // If we've got a blocked task, then use an atomic to gain ownership\n             // of it (may fail)\n-            n => self.state.compare_and_swap(n, EMPTY, atomic::SeqCst)\n+            BLOCKED => self.state.compare_and_swap(BLOCKED, EMPTY, atomic::SeqCst)\n         };\n \n         // Now that we've got ownership of our state, figure out what to do\n@@ -358,11 +359,9 @@ impl<T: Send> Packet<T> {\n                 }\n             }\n \n-            // We woke ourselves up from select. Assert that the task should be\n-            // trashed and returned that we don't have any data.\n-            n => {\n-                let t = unsafe { BlockedTask::cast_from_uint(n) };\n-                t.trash();\n+            // We woke ourselves up from select.\n+            ptr => unsafe {\n+                drop(SignalToken::cast_from_uint(ptr));\n                 Ok(false)\n             }\n         }"}, {"sha": "536d38c6e55086006015a288f212516464266359", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=7fd7ce682dd6f98d456d817a297b15bdc9841190", "patch": "@@ -59,10 +59,11 @@ use core::cell::Cell;\n use core::kinds::marker;\n use core::mem;\n use core::uint;\n-use rt::local::Local;\n-use rt::task::{Task, BlockedTask};\n \n use comm::Receiver;\n+use comm::blocking::{mod, SignalToken};\n+\n+use self::StartResult::*;\n \n /// The \"receiver set\" of the select interface. This structure is used to manage\n /// a set of receivers which are being selected over.\n@@ -93,10 +94,17 @@ pub struct Handle<'rx, T:'rx> {\n \n struct Packets { cur: *mut Handle<'static, ()> }\n \n+#[doc(hidden)]\n+#[deriving(PartialEq)]\n+pub enum StartResult {\n+    Installed,\n+    Abort,\n+}\n+\n #[doc(hidden)]\n pub trait Packet {\n     fn can_recv(&self) -> bool;\n-    fn start_selection(&self, task: BlockedTask) -> Result<(), BlockedTask>;\n+    fn start_selection(&self, token: SignalToken) -> StartResult;\n     fn abort_selection(&self) -> bool;\n }\n \n@@ -165,36 +173,39 @@ impl Select {\n         // Most notably, the iterations over all of the receivers shouldn't be\n         // necessary.\n         unsafe {\n-            let mut amt = 0;\n-            for p in self.iter() {\n-                amt += 1;\n-                if do_preflight_checks && (*p).packet.can_recv() {\n-                    return (*p).id;\n+            // Stage 1: preflight checks. Look for any packets ready to receive\n+            if do_preflight_checks {\n+                for handle in self.iter() {\n+                    if (*handle).packet.can_recv() {\n+                        return (*handle).id();\n+                    }\n                 }\n             }\n-            assert!(amt > 0);\n \n-            let mut ready_index = amt;\n-            let mut ready_id = uint::MAX;\n-            let mut iter = self.iter().enumerate();\n-\n-            // Acquire a number of blocking contexts, and block on each one\n-            // sequentially until one fails. If one fails, then abort\n-            // immediately so we can go unblock on all the other receivers.\n-            let task: Box<Task> = Local::take();\n-            task.deschedule(amt, |task| {\n-                // Prepare for the block\n-                let (i, handle) = iter.next().unwrap();\n-                match (*handle).packet.start_selection(task) {\n-                    Ok(()) => Ok(()),\n-                    Err(task) => {\n-                        ready_index = i;\n-                        ready_id = (*handle).id;\n-                        Err(task)\n+            // Stage 2: begin the blocking process\n+            //\n+            // Create a number of signal tokens, and install each one\n+            // sequentially until one fails. If one fails, then abort the\n+            // selection on the already-installed tokens.\n+            let (wait_token, signal_token) = blocking::tokens();\n+            for (i, handle) in self.iter().enumerate() {\n+                match (*handle).packet.start_selection(signal_token.clone()) {\n+                    Installed => {}\n+                    Abort => {\n+                        // Go back and abort the already-begun selections\n+                        for handle in self.iter().take(i) {\n+                            (*handle).packet.abort_selection();\n+                        }\n+                        return (*handle).id;\n                     }\n                 }\n-            });\n+            }\n+\n+            // Stage 3: no messages available, actually block\n+            wait_token.wait();\n \n+            // Stage 4: there *must* be message available; find it.\n+            //\n             // Abort the selection process on each receiver. If the abort\n             // process returns `true`, then that means that the receiver is\n             // ready to receive some data. Note that this also means that the\n@@ -216,12 +227,14 @@ impl Select {\n             // A rewrite should focus on avoiding a yield loop, and for now this\n             // implementation is tying us over to a more efficient \"don't\n             // iterate over everything every time\" implementation.\n-            for handle in self.iter().take(ready_index) {\n+            let mut ready_id = uint::MAX;\n+            for handle in self.iter() {\n                 if (*handle).packet.abort_selection() {\n                     ready_id = (*handle).id;\n                 }\n             }\n \n+            // We must have found a ready receiver\n             assert!(ready_id != uint::MAX);\n             return ready_id;\n         }"}, {"sha": "1f1ea2ca9a1b2cbeb40698e50f2ea0e97ca77801", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 67, "deletions": 75, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=7fd7ce682dd6f98d456d817a297b15bdc9841190", "patch": "@@ -25,12 +25,12 @@ use core::prelude::*;\n use alloc::boxed::Box;\n use core::cmp;\n use core::int;\n-use rt::local::Local;\n-use rt::task::{Task, BlockedTask};\n-use rt::thread::Thread;\n \n use sync::{atomic, Mutex, MutexGuard};\n use comm::mpsc_queue as mpsc;\n+use comm::blocking::{mod, SignalToken};\n+use comm::select::StartResult;\n+use comm::select::StartResult::*;\n \n const DISCONNECTED: int = int::MIN;\n const FUDGE: int = 1024;\n@@ -43,7 +43,7 @@ pub struct Packet<T> {\n     queue: mpsc::Queue<T>,\n     cnt: atomic::AtomicInt, // How many items are on this channel\n     steals: int, // How many times has a port received without blocking?\n-    to_wake: atomic::AtomicUint, // Task to wake up\n+    to_wake: atomic::AtomicUint, // SignalToken for wake up\n \n     // The number of channels which are currently using this packet.\n     channels: atomic::AtomicInt,\n@@ -95,41 +95,34 @@ impl<T: Send> Packet<T> {\n     //\n     // This can only be called at channel-creation time\n     pub fn inherit_blocker(&mut self,\n-                           task: Option<BlockedTask>,\n+                           token: Option<SignalToken>,\n                            guard: MutexGuard<()>) {\n-        match task {\n-            Some(task) => {\n-                assert_eq!(self.cnt.load(atomic::SeqCst), 0);\n-                assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n-                self.to_wake.store(unsafe { task.cast_to_uint() },\n-                                   atomic::SeqCst);\n-                self.cnt.store(-1, atomic::SeqCst);\n-\n-                // This store is a little sketchy. What's happening here is\n-                // that we're transferring a blocker from a oneshot or stream\n-                // channel to this shared channel. In doing so, we never\n-                // spuriously wake them up and rather only wake them up at the\n-                // appropriate time. This implementation of shared channels\n-                // assumes that any blocking recv() will undo the increment of\n-                // steals performed in try_recv() once the recv is complete.\n-                // This thread that we're inheriting, however, is not in the\n-                // middle of recv. Hence, the first time we wake them up,\n-                // they're going to wake up from their old port, move on to the\n-                // upgraded port, and then call the block recv() function.\n-                //\n-                // When calling this function, they'll find there's data\n-                // immediately available, counting it as a steal. This in fact\n-                // wasn't a steal because we appropriately blocked them waiting\n-                // for data.\n-                //\n-                // To offset this bad increment, we initially set the steal\n-                // count to -1. You'll find some special code in\n-                // abort_selection() as well to ensure that this -1 steal count\n-                // doesn't escape too far.\n-                self.steals = -1;\n-            }\n-            None => {}\n-        }\n+        token.map(|token| {\n+            assert_eq!(self.cnt.load(atomic::SeqCst), 0);\n+            assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n+            self.to_wake.store(unsafe { token.cast_to_uint() }, atomic::SeqCst);\n+            self.cnt.store(-1, atomic::SeqCst);\n+\n+            // This store is a little sketchy. What's happening here is that\n+            // we're transferring a blocker from a oneshot or stream channel to\n+            // this shared channel. In doing so, we never spuriously wake them\n+            // up and rather only wake them up at the appropriate time. This\n+            // implementation of shared channels assumes that any blocking\n+            // recv() will undo the increment of steals performed in try_recv()\n+            // once the recv is complete.  This thread that we're inheriting,\n+            // however, is not in the middle of recv. Hence, the first time we\n+            // wake them up, they're going to wake up from their old port, move\n+            // on to the upgraded port, and then call the block recv() function.\n+            //\n+            // When calling this function, they'll find there's data immediately\n+            // available, counting it as a steal. This in fact wasn't a steal\n+            // because we appropriately blocked them waiting for data.\n+            //\n+            // To offset this bad increment, we initially set the steal count to\n+            // -1. You'll find some special code in abort_selection() as well to\n+            // ensure that this -1 steal count doesn't escape too far.\n+            self.steals = -1;\n+        });\n \n         // When the shared packet is constructed, we grabbed this lock. The\n         // purpose of this lock is to ensure that abort_selection() doesn't\n@@ -175,7 +168,7 @@ impl<T: Send> Packet<T> {\n         self.queue.push(t);\n         match self.cnt.fetch_add(1, atomic::SeqCst) {\n             -1 => {\n-                self.take_to_wake().wake().map(|t| t.reawaken());\n+                self.take_to_wake().signal();\n             }\n \n             // In this case, we have possibly failed to send our data, and\n@@ -232,10 +225,10 @@ impl<T: Send> Packet<T> {\n             data => return data,\n         }\n \n-        let task: Box<Task> = Local::take();\n-        task.deschedule(1, |task| {\n-            self.decrement(task)\n-        });\n+        let (wait_token, signal_token) = blocking::tokens();\n+        if self.decrement(signal_token) == Installed {\n+            wait_token.wait()\n+        }\n \n         match self.try_recv() {\n             data @ Ok(..) => { self.steals -= 1; data }\n@@ -244,10 +237,11 @@ impl<T: Send> Packet<T> {\n     }\n \n     // Essentially the exact same thing as the stream decrement function.\n-    fn decrement(&mut self, task: BlockedTask) -> Result<(), BlockedTask> {\n+    // Returns true if blocking should proceed.\n+    fn decrement(&mut self, token: SignalToken) -> StartResult {\n         assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n-        let n = unsafe { task.cast_to_uint() };\n-        self.to_wake.store(n, atomic::SeqCst);\n+        let ptr = unsafe { token.cast_to_uint() };\n+        self.to_wake.store(ptr, atomic::SeqCst);\n \n         let steals = self.steals;\n         self.steals = 0;\n@@ -258,33 +252,33 @@ impl<T: Send> Packet<T> {\n             // data, we successfully sleep\n             n => {\n                 assert!(n >= 0);\n-                if n - steals <= 0 { return Ok(()) }\n+                if n - steals <= 0 { return Installed }\n             }\n         }\n \n         self.to_wake.store(0, atomic::SeqCst);\n-        Err(unsafe { BlockedTask::cast_from_uint(n) })\n+        drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+        Abort\n     }\n \n     pub fn try_recv(&mut self) -> Result<T, Failure> {\n         let ret = match self.queue.pop() {\n             mpsc::Data(t) => Some(t),\n             mpsc::Empty => None,\n \n-            // This is a bit of an interesting case. The channel is\n-            // reported as having data available, but our pop() has\n-            // failed due to the queue being in an inconsistent state.\n-            // This means that there is some pusher somewhere which has\n-            // yet to complete, but we are guaranteed that a pop will\n-            // eventually succeed. In this case, we spin in a yield loop\n-            // because the remote sender should finish their enqueue\n+            // This is a bit of an interesting case. The channel is reported as\n+            // having data available, but our pop() has failed due to the queue\n+            // being in an inconsistent state.  This means that there is some\n+            // pusher somewhere which has yet to complete, but we are guaranteed\n+            // that a pop will eventually succeed. In this case, we spin in a\n+            // yield loop because the remote sender should finish their enqueue\n             // operation \"very quickly\".\n             //\n             // Avoiding this yield loop would require a different queue\n-            // abstraction which provides the guarantee that after M\n-            // pushes have succeeded, at least M pops will succeed. The\n-            // current queues guarantee that if there are N active\n-            // pushes, you can pop N times once all N have finished.\n+            // abstraction which provides the guarantee that after M pushes have\n+            // succeeded, at least M pops will succeed. The current queues\n+            // guarantee that if there are N active pushes, you can pop N times\n+            // once all N have finished.\n             mpsc::Inconsistent => {\n                 let data;\n                 loop {\n@@ -354,7 +348,7 @@ impl<T: Send> Packet<T> {\n         }\n \n         match self.cnt.swap(DISCONNECTED, atomic::SeqCst) {\n-            -1 => { self.take_to_wake().wake().map(|t| t.reawaken()); }\n+            -1 => { self.take_to_wake().signal(); }\n             DISCONNECTED => {}\n             n => { assert!(n >= 0); }\n         }\n@@ -366,8 +360,7 @@ impl<T: Send> Packet<T> {\n         self.port_dropped.store(true, atomic::SeqCst);\n         let mut steals = self.steals;\n         while {\n-            let cnt = self.cnt.compare_and_swap(\n-                            steals, DISCONNECTED, atomic::SeqCst);\n+            let cnt = self.cnt.compare_and_swap(steals, DISCONNECTED, atomic::SeqCst);\n             cnt != DISCONNECTED && cnt != steals\n         } {\n             // See the discussion in 'try_recv' for why we yield\n@@ -382,11 +375,11 @@ impl<T: Send> Packet<T> {\n     }\n \n     // Consumes ownership of the 'to_wake' field.\n-    fn take_to_wake(&mut self) -> BlockedTask {\n-        let task = self.to_wake.load(atomic::SeqCst);\n+    fn take_to_wake(&mut self) -> SignalToken {\n+        let ptr = self.to_wake.load(atomic::SeqCst);\n         self.to_wake.store(0, atomic::SeqCst);\n-        assert!(task != 0);\n-        unsafe { BlockedTask::cast_from_uint(task) }\n+        assert!(ptr != 0);\n+        unsafe { SignalToken::cast_from_uint(ptr) }\n     }\n \n     ////////////////////////////////////////////////////////////////////////////\n@@ -414,19 +407,18 @@ impl<T: Send> Packet<T> {\n         }\n     }\n \n-    // Inserts the blocked task for selection on this port, returning it back if\n-    // the port already has data on it.\n+    // Inserts the signal token for selection on this port, returning true if\n+    // blocking should proceed.\n     //\n     // The code here is the same as in stream.rs, except that it doesn't need to\n     // peek at the channel to see if an upgrade is pending.\n-    pub fn start_selection(&mut self,\n-                           task: BlockedTask) -> Result<(), BlockedTask> {\n-        match self.decrement(task) {\n-            Ok(()) => Ok(()),\n-            Err(task) => {\n+    pub fn start_selection(&mut self, token: SignalToken) -> StartResult {\n+        match self.decrement(token) {\n+            Installed => Installed,\n+            Abort => {\n                 let prev = self.bump(1);\n                 assert!(prev == DISCONNECTED || prev >= 0);\n-                return Err(task);\n+                Abort\n             }\n         }\n     }\n@@ -464,7 +456,7 @@ impl<T: Send> Packet<T> {\n             let cur = prev + steals + 1;\n             assert!(cur >= 0);\n             if prev < 0 {\n-                self.take_to_wake().trash();\n+                drop(self.take_to_wake());\n             } else {\n                 while self.to_wake.load(atomic::SeqCst) != 0 {\n                     Thread::yield_now();"}, {"sha": "a15366d5ebc0cb700974a6195880ca32e419c4a2", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=7fd7ce682dd6f98d456d817a297b15bdc9841190", "patch": "@@ -27,13 +27,12 @@ use core::prelude::*;\n use alloc::boxed::Box;\n use core::cmp;\n use core::int;\n-use rt::local::Local;\n-use rt::task::{Task, BlockedTask};\n-use rt::thread::Thread;\n+use thread::Thread;\n \n use sync::atomic;\n use comm::spsc_queue as spsc;\n use comm::Receiver;\n+use comm::blocking::{mod, WaitToken, SignalToken};\n \n const DISCONNECTED: int = int::MIN;\n #[cfg(test)]\n@@ -46,7 +45,7 @@ pub struct Packet<T> {\n \n     cnt: atomic::AtomicInt, // How many items are on this channel\n     steals: int, // How many times has a port received without blocking?\n-    to_wake: atomic::AtomicUint, // Task to wake up\n+    to_wake: atomic::AtomicUint, // SignalToken for the blocked thread to wake up\n \n     port_dropped: atomic::AtomicBool, // flag if the channel has been destroyed.\n }\n@@ -60,13 +59,13 @@ pub enum Failure<T> {\n pub enum UpgradeResult {\n     UpSuccess,\n     UpDisconnected,\n-    UpWoke(BlockedTask),\n+    UpWoke(SignalToken),\n }\n \n pub enum SelectionResult<T> {\n     SelSuccess,\n-    SelCanceled(BlockedTask),\n-    SelUpgraded(BlockedTask, Receiver<T>),\n+    SelCanceled,\n+    SelUpgraded(SignalToken, Receiver<T>),\n }\n \n // Any message could contain an \"upgrade request\" to a new shared port, so the\n@@ -89,7 +88,6 @@ impl<T: Send> Packet<T> {\n         }\n     }\n \n-\n     pub fn send(&mut self, t: T) -> Result<(), T> {\n         // If the other port has deterministically gone away, then definitely\n         // must return the data back up the stack. Otherwise, the data is\n@@ -98,10 +96,11 @@ impl<T: Send> Packet<T> {\n \n         match self.do_send(Data(t)) {\n             UpSuccess | UpDisconnected => {},\n-            UpWoke(task) => { task.wake().map(|t| t.reawaken()); }\n+            UpWoke(token) => { token.signal(); }\n         }\n         Ok(())\n     }\n+\n     pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult {\n         // If the port has gone away, then there's no need to proceed any\n         // further.\n@@ -144,20 +143,20 @@ impl<T: Send> Packet<T> {\n     }\n \n     // Consumes ownership of the 'to_wake' field.\n-    fn take_to_wake(&mut self) -> BlockedTask {\n-        let task = self.to_wake.load(atomic::SeqCst);\n+    fn take_to_wake(&mut self) -> SignalToken {\n+        let ptr = self.to_wake.load(atomic::SeqCst);\n         self.to_wake.store(0, atomic::SeqCst);\n-        assert!(task != 0);\n-        unsafe { BlockedTask::cast_from_uint(task) }\n+        assert!(ptr != 0);\n+        unsafe { SignaToken::cast_from_uint(ptr) }\n     }\n \n     // Decrements the count on the channel for a sleeper, returning the sleeper\n     // back if it shouldn't sleep. Note that this is the location where we take\n     // steals into account.\n-    fn decrement(&mut self, task: BlockedTask) -> Result<(), BlockedTask> {\n+    fn decrement(&mut self, token: SignalToken) -> Result<(), SignalToken> {\n         assert_eq!(self.to_wake.load(atomic::SeqCst), 0);\n-        let n = unsafe { task.cast_to_uint() };\n-        self.to_wake.store(n, atomic::SeqCst);\n+        let ptr = unsafe { token.cast_to_uint() };\n+        self.to_wake.store(ptr, atomic::SeqCst);\n \n         let steals = self.steals;\n         self.steals = 0;\n@@ -173,7 +172,7 @@ impl<T: Send> Packet<T> {\n         }\n \n         self.to_wake.store(0, atomic::SeqCst);\n-        Err(unsafe { BlockedTask::cast_from_uint(n) })\n+        Err(unsafe { SignalToken::cast_from_uint(ptr) })\n     }\n \n     pub fn recv(&mut self) -> Result<T, Failure<T>> {\n@@ -185,10 +184,10 @@ impl<T: Send> Packet<T> {\n \n         // Welp, our channel has no data. Deschedule the current task and\n         // initiate the blocking protocol.\n-        let task: Box<Task> = Local::take();\n-        task.deschedule(1, |task| {\n-            self.decrement(task)\n-        });\n+        let (wait_token, signal_token) = blocking::tokens();\n+        if self.decrement(signal_token).is_ok() {\n+            wait_token.wait()\n+        }\n \n         match self.try_recv() {\n             // Messages which actually popped from the queue shouldn't count as\n@@ -269,7 +268,7 @@ impl<T: Send> Packet<T> {\n         // Dropping a channel is pretty simple, we just flag it as disconnected\n         // and then wakeup a blocker if there is one.\n         match self.cnt.swap(DISCONNECTED, atomic::SeqCst) {\n-            -1 => { self.take_to_wake().wake().map(|t| t.reawaken()); }\n+            -1 => { self.take_to_wake().signal(); }\n             DISCONNECTED => {}\n             n => { assert!(n >= 0); }\n         }\n@@ -364,19 +363,19 @@ impl<T: Send> Packet<T> {\n \n     // Attempts to start selecting on this port. Like a oneshot, this can fail\n     // immediately because of an upgrade.\n-    pub fn start_selection(&mut self, task: BlockedTask) -> SelectionResult<T> {\n-        match self.decrement(task) {\n+    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> {\n+        match self.decrement(token) {\n             Ok(()) => SelSuccess,\n-            Err(task) => {\n+            Err(token) => {\n                 let ret = match self.queue.peek() {\n                     Some(&GoUp(..)) => {\n                         match self.queue.pop() {\n-                            Some(GoUp(port)) => SelUpgraded(task, port),\n+                            Some(GoUp(port)) => SelUpgraded(token, port),\n                             _ => unreachable!(),\n                         }\n                     }\n-                    Some(..) => SelCanceled(task),\n-                    None => SelCanceled(task),\n+                    Some(..) => SelCanceled,\n+                    None => SelCanceled,\n                 };\n                 // Undo our decrement above, and we should be guaranteed that the\n                 // previous value is positive because we're not going to sleep\n@@ -439,7 +438,7 @@ impl<T: Send> Packet<T> {\n             // final solution but rather out of necessity for now to get\n             // something working.\n             if prev < 0 {\n-                self.take_to_wake().trash();\n+                drop(self.take_to_wake());\n             } else {\n                 while self.to_wake.load(atomic::SeqCst) != 0 {\n                     Thread::yield_now();"}, {"sha": "7e87596429c6f17dc9e8e3f2a28679de88a3510e", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 77, "deletions": 101, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fd7ce682dd6f98d456d817a297b15bdc9841190/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=7fd7ce682dd6f98d456d817a297b15bdc9841190", "patch": "@@ -42,11 +42,10 @@ use alloc::boxed::Box;\n use vec::Vec;\n use core::mem;\n use core::cell::UnsafeCell;\n-use rt::local::Local;\n-use rt::mutex::{NativeMutex, LockGuard};\n-use rt::task::{Task, BlockedTask};\n \n-use sync::atomic;\n+use sync::{atomic, Mutex, MutexGuard};\n+use comm::blocking::{mod, WaitToken, SignalToken};\n+use comm::select::StartResult::{mod, Installed, Abort};\n \n pub struct Packet<T> {\n     /// Only field outside of the mutex. Just done for kicks, but mainly because\n@@ -74,10 +73,10 @@ struct State<T> {\n     canceled: Option<&'static mut bool>,\n }\n \n-/// Possible flavors of tasks who can be blocked on this channel.\n+/// Possible flavors of threads who can be blocked on this channel.\n enum Blocker {\n-    BlockedSender(BlockedTask),\n-    BlockedReceiver(BlockedTask),\n+    BlockedSender(SignalToken),\n+    BlockedReceiver(SignalToken),\n     NoneBlocked\n }\n \n@@ -89,7 +88,7 @@ struct Queue {\n }\n \n struct Node {\n-    task: Option<BlockedTask>,\n+    token: Option<SignalToken>,\n     next: *mut Node,\n }\n \n@@ -106,28 +105,15 @@ pub enum Failure {\n     Disconnected,\n }\n \n-/// Atomically blocks the current task, placing it into `slot`, unlocking `lock`\n+/// Atomically blocks the current thread, placing it into `slot`, unlocking `lock`\n /// in the meantime. This re-locks the mutex upon returning.\n-fn wait(slot: &mut Blocker, f: fn(BlockedTask) -> Blocker,\n-        lock: &NativeMutex) {\n-    let me: Box<Task> = Local::take();\n-    me.deschedule(1, |task| {\n-        match mem::replace(slot, f(task)) {\n-            NoneBlocked => {}\n-            _ => unreachable!(),\n-        }\n-        unsafe { lock.unlock_noguard(); }\n-        Ok(())\n-    });\n-    unsafe { lock.lock_noguard(); }\n-}\n \n-/// Wakes up a task, dropping the lock at the correct time\n-fn wakeup(task: BlockedTask, guard: LockGuard) {\n+/// Wakes up a thread, dropping the lock at the correct time\n+fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n     // We need to be careful to wake up the waiting task *outside* of the mutex\n     // in case it incurs a context switch.\n-    mem::drop(guard);\n-    task.wake().map(|t| t.reawaken());\n+    drop(guard);\n+    token.signal();\n }\n \n impl<T: Send> Packet<T> {\n@@ -153,29 +139,27 @@ impl<T: Send> Packet<T> {\n         }\n     }\n \n-    // Locks this channel, returning a guard for the state and the mutable state\n-    // itself. Care should be taken to ensure that the state does not escape the\n-    // guard!\n-    //\n-    // Note that we're ok promoting an & reference to an &mut reference because\n-    // the lock ensures that we're the only ones in the world with a pointer to\n-    // the state.\n-    fn lock<'a>(&'a self) -> (LockGuard<'a>, &'a mut State<T>) {\n-        unsafe {\n-            let guard = self.lock.lock();\n-            (guard, &mut *self.state.get())\n+    // wait until a send slot is available, returning locked access to\n+    // the channel state.\n+    fn acquire_send_slot(&self) -> MutexGuard<State<T>> {\n+        let mut node = Node { token: None, next: 0 as *mut Node };\n+        loop {\n+            let mut guard = self.lock.lock();\n+            // are we ready to go?\n+            if guard.disconnected || guard.buf.size() < guard.buf.cap() {\n+                return guard;\n+            }\n+            // no room; actually block\n+            let wait_token = guard.queue.enqueue(&mut node);\n+            drop(guard);\n+            wait_token.wait();\n         }\n     }\n \n     pub fn send(&self, t: T) -> Result<(), T> {\n-        let (guard, state) = self.lock();\n-\n-        // wait for a slot to become available, and enqueue the data\n-        while !state.disconnected && state.buf.size() == state.buf.cap() {\n-            state.queue.enqueue(&self.lock);\n-        }\n-        if state.disconnected { return Err(t) }\n-        state.buf.enqueue(t);\n+        let guard = self.acquire_send_slot();\n+        if guard.disconnected { return Err(t) }\n+        guard.buf.enqueue(t);\n \n         match mem::replace(&mut state.blocker, NoneBlocked) {\n             // if our capacity is 0, then we need to wait for a receiver to be\n@@ -194,7 +178,7 @@ impl<T: Send> Packet<T> {\n             NoneBlocked => Ok(()),\n \n             // success, someone's about to receive our buffered data.\n-            BlockedReceiver(task) => { wakeup(task, guard); Ok(()) }\n+            BlockedReceiver(token) => { wakeup(token, guard); Ok(()) }\n \n             BlockedSender(..) => panic!(\"lolwut\"),\n         }\n@@ -212,20 +196,20 @@ impl<T: Send> Packet<T> {\n             match mem::replace(&mut state.blocker, NoneBlocked) {\n                 NoneBlocked => Err(super::Full(t)),\n                 BlockedSender(..) => unreachable!(),\n-                BlockedReceiver(task) => {\n-                    state.buf.enqueue(t);\n-                    wakeup(task, guard);\n+                BlockedReceiver(token) => {\n+                    guard.buf.enqueue(t);\n+                    wakeup(token, guard);\n                     Ok(())\n                 }\n             }\n         } else {\n             // If the buffer has some space and the capacity isn't 0, then we\n             // just enqueue the data for later retrieval, ensuring to wake up\n             // any blocked receiver if there is one.\n-            assert!(state.buf.size() < state.buf.cap());\n-            state.buf.enqueue(t);\n-            match mem::replace(&mut state.blocker, NoneBlocked) {\n-                BlockedReceiver(task) => wakeup(task, guard),\n+            assert!(guard.buf.size() < guard.buf.cap());\n+            guard.buf.enqueue(t);\n+            match mem::replace(&mut guard.blocker, NoneBlocked) {\n+                BlockedReceiver(token) => wakeup(token, guard),\n                 NoneBlocked => {}\n                 BlockedSender(..) => unreachable!(),\n             }\n@@ -238,7 +222,7 @@ impl<T: Send> Packet<T> {\n     // When reading this, remember that there can only ever be one receiver at\n     // time.\n     pub fn recv(&self) -> Result<T, ()> {\n-        let (guard, state) = self.lock();\n+        let guard = self.lock.lock();\n \n         // Wait for the buffer to have something in it. No need for a while loop\n         // because we're the only receiver.\n@@ -275,10 +259,8 @@ impl<T: Send> Packet<T> {\n     // * `waited` - flag if the receiver blocked to receive some data, or if it\n     //              just picked up some data on the way out\n     // * `guard` - the lock guard that is held over this channel's lock\n-    fn wakeup_senders(&self, waited: bool,\n-                      guard: LockGuard,\n-                      state: &mut State<T>) {\n-        let pending_sender1: Option<BlockedTask> = state.queue.dequeue();\n+    fn wakeup_senders(&self, waited: bool, guard: MutexGuard<State<T>>) {\n+        let pending_sender1: Option<SignalToken> = guard.queue.dequeue();\n \n         // If this is a no-buffer channel (cap == 0), then if we didn't wait we\n         // need to ACK the sender. If we waited, then the sender waking us up\n@@ -287,9 +269,9 @@ impl<T: Send> Packet<T> {\n             match mem::replace(&mut state.blocker, NoneBlocked) {\n                 NoneBlocked => None,\n                 BlockedReceiver(..) => unreachable!(),\n-                BlockedSender(task) => {\n-                    state.canceled.take();\n-                    Some(task)\n+                BlockedSender(token) => {\n+                    guard.canceled.take();\n+                    Some(token)\n                 }\n             }\n         } else {\n@@ -298,8 +280,8 @@ impl<T: Send> Packet<T> {\n         mem::drop((state, guard));\n \n         // only outside of the lock do we wake up the pending tasks\n-        pending_sender1.map(|t| t.wake().map(|t| t.reawaken()));\n-        pending_sender2.map(|t| t.wake().map(|t| t.reawaken()));\n+        pending_sender1.map(|t| t.signal());\n+        pending_sender2.map(|t| t.signal());\n     }\n \n     // Prepares this shared packet for a channel clone, essentially just bumping\n@@ -322,7 +304,7 @@ impl<T: Send> Packet<T> {\n         match mem::replace(&mut state.blocker, NoneBlocked) {\n             NoneBlocked => {}\n             BlockedSender(..) => unreachable!(),\n-            BlockedReceiver(task) => wakeup(task, guard),\n+            BlockedReceiver(token) => wakeup(token, guard),\n         }\n     }\n \n@@ -349,21 +331,21 @@ impl<T: Send> Packet<T> {\n \n         let waiter = match mem::replace(&mut state.blocker, NoneBlocked) {\n             NoneBlocked => None,\n-            BlockedSender(task) => {\n-                *state.canceled.take().unwrap() = true;\n-                Some(task)\n+            BlockedSender(token) => {\n+                *guard.canceled.take().unwrap() = true;\n+                Some(token)\n             }\n             BlockedReceiver(..) => unreachable!(),\n         };\n         mem::drop((state, guard));\n \n         loop {\n             match queue.dequeue() {\n-                Some(task) => { task.wake().map(|t| t.reawaken()); }\n+                Some(token) => { token.signal(); }\n                 None => break,\n             }\n         }\n-        waiter.map(|t| t.wake().map(|t| t.reawaken()));\n+        waiter.map(|t| t.signal());\n     }\n \n     ////////////////////////////////////////////////////////////////////////////\n@@ -379,17 +361,17 @@ impl<T: Send> Packet<T> {\n \n     // Attempts to start selection on this port. This can either succeed or fail\n     // because there is data waiting.\n-    pub fn start_selection(&self, task: BlockedTask) -> Result<(), BlockedTask>{\n-        let (_g, state) = self.lock();\n-        if state.disconnected || state.buf.size() > 0 {\n-            Err(task)\n+    pub fn start_selection(&self, token: SignalToken) -> StartResult {\n+        let guard = self.lock();\n+        if guard.disconnected || guard.buf.size() > 0 {\n+            Abort\n         } else {\n-            match mem::replace(&mut state.blocker, BlockedReceiver(task)) {\n+            match mem::replace(&mut guard.blocker, BlockedReceiver(token)) {\n                 NoneBlocked => {}\n                 BlockedSender(..) => unreachable!(),\n                 BlockedReceiver(..) => unreachable!(),\n             }\n-            Ok(())\n+            Installed\n         }\n     }\n \n@@ -401,11 +383,11 @@ impl<T: Send> Packet<T> {\n         let (_g, state) = self.lock();\n         match mem::replace(&mut state.blocker, NoneBlocked) {\n             NoneBlocked => true,\n-            BlockedSender(task) => {\n-                state.blocker = BlockedSender(task);\n+            BlockedSender(token) => {\n+                guard.blocker = BlockedSender(token);\n                 true\n             }\n-            BlockedReceiver(task) => { task.trash(); false }\n+            BlockedReceiver(token) => { drop(token); false }\n         }\n     }\n }\n@@ -449,31 +431,25 @@ impl<T> Buffer<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl Queue {\n-    fn enqueue(&mut self, lock: &NativeMutex) {\n-        let task: Box<Task> = Local::take();\n-        let mut node = Node {\n-            task: None,\n-            next: 0 as *mut Node,\n-        };\n-        task.deschedule(1, |task| {\n-            node.task = Some(task);\n-            if self.tail.is_null() {\n-                self.head = &mut node as *mut Node;\n-                self.tail = &mut node as *mut Node;\n-            } else {\n-                unsafe {\n-                    (*self.tail).next = &mut node as *mut Node;\n-                    self.tail = &mut node as *mut Node;\n-                }\n+    fn enqueue(&mut self, node: &mut Node) -> WaitToken {\n+        let (wait_token, signal_token) = blocking::tokens();\n+        node.token = Some(signal_token);\n+        node.next = 0 as *mut Node;\n+\n+        if self.tail.is_null() {\n+            self.head = node as *mut Node;\n+            self.tail = node as *mut Node;\n+        } else {\n+            unsafe {\n+                (*self.tail).next = node as *mut Node;\n+                self.tail = node as *mut Node;\n             }\n-            unsafe { lock.unlock_noguard(); }\n-            Ok(())\n-        });\n-        unsafe { lock.lock_noguard(); }\n-        assert!(node.next.is_null());\n+        }\n+\n+        wait_token\n     }\n \n-    fn dequeue(&mut self) -> Option<BlockedTask> {\n+    fn dequeue(&mut self) -> Option<SignalToken> {\n         if self.head.is_null() {\n             return None\n         }\n@@ -484,7 +460,7 @@ impl Queue {\n         }\n         unsafe {\n             (*node).next = 0 as *mut Node;\n-            Some((*node).task.take().unwrap())\n+            Some((*node).token.take().unwrap())\n         }\n     }\n }"}]}