{"sha": "f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZTU5Y2M2YWEzYmY5MDFhNGFlZmE4YWQ0OTU0ZWRkZGYzZGEyOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-27T21:28:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-27T21:28:06Z"}, "message": "Auto merge of #34907 - arielb1:found-parse-error, r=nikomatsakis\n\nCentralize and clean type error reporting\n\nRefactors the code that handles type errors to be cleaner and fixes various edge cases.\n\nThis made the already-bad \"type mismatch resolving\" error message somewhat uglier. I want to fix that in another commit before this PR is merged.\n\nFixes #31173\n\nr? @jonathandturner, cc @nikomatsakis", "tree": {"sha": "7a0adacdd7888b935b3cb03c2851b7631c1d869b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a0adacdd7888b935b3cb03c2851b7631c1d869b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "html_url": "https://github.com/rust-lang/rust/commit/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29abe5ec717bd58b175100cfabe833c1500c8498", "url": "https://api.github.com/repos/rust-lang/rust/commits/29abe5ec717bd58b175100cfabe833c1500c8498", "html_url": "https://github.com/rust-lang/rust/commit/29abe5ec717bd58b175100cfabe833c1500c8498"}, {"sha": "717e39294f635d90f8ba9e0968494f741878f37b", "url": "https://api.github.com/repos/rust-lang/rust/commits/717e39294f635d90f8ba9e0968494f741878f37b", "html_url": "https://github.com/rust-lang/rust/commit/717e39294f635d90f8ba9e0968494f741878f37b"}], "stats": {"total": 1861, "additions": 1017, "deletions": 844}, "files": [{"sha": "511cc32d2e1e6cfeb47d00fa65076fba5445de64", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 93, "deletions": 143, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -83,7 +83,7 @@ use hir::def_id::DefId;\n use infer::{self, TypeOrigin};\n use middle::region;\n use ty::subst;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, ReFree};\n use ty::error::TypeError;\n \n@@ -462,52 +462,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn report_type_error(&self,\n-                         trace: TypeTrace<'tcx>,\n-                         terr: &TypeError<'tcx>)\n-                         -> DiagnosticBuilder<'tcx> {\n-        let (expected, found) = match self.values_str(&trace.values) {\n-            Some(v) => v,\n-            None => {\n-                return self.tcx.sess.diagnostic().struct_dummy(); /* derived error */\n-            }\n-        };\n-\n-        let is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n-            values.expected.is_primitive() && values.found.is_primitive()\n-        } else {\n-            false\n-        };\n-\n-        let mut err = struct_span_err!(self.tcx.sess,\n-                                       trace.origin.span(),\n-                                       E0308,\n-                                       \"{}\",\n-                                       trace.origin);\n-\n-        if !is_simple_error || check_old_school() {\n-            err.note_expected_found(&\"type\", &expected, &found);\n-        }\n-\n-        err.span_label(trace.origin.span(), &terr);\n-\n-        self.check_and_note_conflicting_crates(&mut err, terr, trace.origin.span());\n-\n-        match trace.origin {\n-            TypeOrigin::MatchExpressionArm(_, arm_span, source) => match source {\n-                hir::MatchSource::IfLetDesugar{..} => {\n-                    err.span_note(arm_span, \"`if let` arm with an incompatible type\");\n-                }\n-                _ => {\n-                    err.span_note(arm_span, \"match arm with an incompatible type\");\n-                }\n-            },\n-            _ => ()\n-        }\n-\n-        err\n-    }\n-\n     /// Adds a note if the types come from similarly named crates\n     fn check_and_note_conflicting_crates(&self,\n                                          err: &mut DiagnosticBuilder,\n@@ -550,42 +504,102 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn note_error_origin(&self,\n+                         err: &mut DiagnosticBuilder<'tcx>,\n+                         origin: &TypeOrigin)\n+    {\n+        match origin {\n+            &TypeOrigin::MatchExpressionArm(_, arm_span, source) => match source {\n+                hir::MatchSource::IfLetDesugar {..} => {\n+                    err.span_note(arm_span, \"`if let` arm with an incompatible type\");\n+                }\n+                _ => {\n+                    err.span_note(arm_span, \"match arm with an incompatible type\");\n+                }\n+            },\n+            _ => ()\n+        }\n+    }\n+\n+    pub fn note_type_err(&self,\n+                         diag: &mut DiagnosticBuilder<'tcx>,\n+                         origin: TypeOrigin,\n+                         values: Option<ValuePairs<'tcx>>,\n+                         terr: &TypeError<'tcx>)\n+    {\n+        let expected_found = match values {\n+            None => None,\n+            Some(values) => match self.values_str(&values) {\n+                Some((expected, found)) => Some((expected, found)),\n+                None => {\n+                    // Derived error. Cancel the emitter.\n+                    self.tcx.sess.diagnostic().cancel(diag);\n+                    return\n+                }\n+            }\n+        };\n+\n+        let span = origin.span();\n+\n+        let mut is_simple_error = false;\n+\n+        if let Some((expected, found)) = expected_found {\n+            is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n+                values.expected.is_primitive() && values.found.is_primitive()\n+            } else {\n+                false\n+            };\n+\n+            if !is_simple_error || check_old_school() {\n+                diag.note_expected_found(&\"type\", &expected, &found);\n+            }\n+        }\n+\n+        if !is_simple_error && check_old_school() {\n+            diag.span_note(span, &format!(\"{}\", terr));\n+        } else {\n+            diag.span_label(span, &terr);\n+        }\n+\n+        self.note_error_origin(diag, &origin);\n+        self.check_and_note_conflicting_crates(diag, terr, span);\n+        self.tcx.note_and_explain_type_err(diag, terr, span);\n+    }\n+\n     pub fn report_and_explain_type_error(&self,\n                                          trace: TypeTrace<'tcx>,\n                                          terr: &TypeError<'tcx>)\n-                                         -> DiagnosticBuilder<'tcx> {\n-        let span = trace.origin.span();\n-        let mut err = self.report_type_error(trace, terr);\n-        self.tcx.note_and_explain_type_err(&mut err, terr, span);\n-        err\n+                                         -> DiagnosticBuilder<'tcx>\n+    {\n+        // FIXME: do we want to use a different error code for each origin?\n+        let mut diag = struct_span_err!(\n+            self.tcx.sess, trace.origin.span(), E0308,\n+            \"{}\", trace.origin.as_failure_str()\n+        );\n+        self.note_type_err(&mut diag, trace.origin, Some(trace.values), terr);\n+        diag\n     }\n \n-    /// Returns a string of the form \"expected `{}`, found `{}`\", or None if this is a derived\n-    /// error.\n+    /// Returns a string of the form \"expected `{}`, found `{}`\".\n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<(String, String)> {\n         match *values {\n             infer::Types(ref exp_found) => self.expected_found_str(exp_found),\n             infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n-            infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found)\n+            infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n         }\n     }\n \n-    fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + TypeFoldable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n         exp_found: &ty::error::ExpectedFound<T>)\n         -> Option<(String, String)>\n     {\n-        let expected = exp_found.expected.resolve(self);\n-        if expected.references_error() {\n-            return None;\n-        }\n-\n-        let found = exp_found.found.resolve(self);\n-        if found.references_error() {\n+        let exp_found = self.resolve_type_vars_if_possible(exp_found);\n+        if exp_found.references_error() {\n             return None;\n         }\n \n-        Some((format!(\"{}\", expected), format!(\"{}\", found)))\n+        Some((format!(\"{}\", exp_found.expected), format!(\"{}\", exp_found.found)))\n     }\n \n     fn report_generic_bound_failure(&self,\n@@ -1608,59 +1622,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn note_region_origin(&self, err: &mut DiagnosticBuilder, origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n             infer::Subtype(ref trace) => {\n-                let desc = match trace.origin {\n-                    TypeOrigin::Misc(_) => {\n-                        \"types are compatible\"\n-                    }\n-                    TypeOrigin::MethodCompatCheck(_) => {\n-                        \"method type is compatible with trait\"\n-                    }\n-                    TypeOrigin::ExprAssignable(_) => {\n-                        \"expression is assignable\"\n-                    }\n-                    TypeOrigin::RelateTraitRefs(_) => {\n-                        \"traits are compatible\"\n-                    }\n-                    TypeOrigin::RelateSelfType(_) => {\n-                        \"self type matches impl self type\"\n-                    }\n-                    TypeOrigin::RelateOutputImplTypes(_) => {\n-                        \"trait type parameters matches those \\\n-                                 specified on the impl\"\n-                    }\n-                    TypeOrigin::MatchExpressionArm(_, _, _) => {\n-                        \"match arms have compatible types\"\n-                    }\n-                    TypeOrigin::IfExpression(_) => {\n-                        \"if and else have compatible types\"\n-                    }\n-                    TypeOrigin::IfExpressionWithNoElse(_) => {\n-                        \"if may be missing an else clause\"\n-                    }\n-                    TypeOrigin::RangeExpression(_) => {\n-                        \"start and end of range have compatible types\"\n-                    }\n-                    TypeOrigin::EquatePredicate(_) => {\n-                        \"equality where clause is satisfied\"\n-                    }\n-                };\n-\n-                match self.values_str(&trace.values) {\n-                    Some((expected, found)) => {\n-                        err.span_note(\n-                            trace.origin.span(),\n-                            &format!(\"...so that {} (expected {}, found {})\",\n-                                    desc, expected, found));\n-                    }\n-                    None => {\n-                        // Really should avoid printing this error at\n-                        // all, since it is derived, but that would\n-                        // require more refactoring than I feel like\n-                        // doing right now. - nmatsakis\n-                        err.span_note(\n-                            trace.origin.span(),\n-                            &format!(\"...so that {}\", desc));\n-                    }\n+                if let Some((expected, found)) = self.values_str(&trace.values) {\n+                    // FIXME: do we want a \"the\" here?\n+                    err.span_note(\n+                        trace.origin.span(),\n+                        &format!(\"...so that {} (expected {}, found {})\",\n+                                 trace.origin.as_requirement_str(), expected, found));\n+                } else {\n+                    // FIXME: this really should be handled at some earlier stage. Our\n+                    // handling of region checking when type errors are present is\n+                    // *terrible*.\n+\n+                    err.span_note(\n+                        trace.origin.span(),\n+                        &format!(\"...so that {}\",\n+                                 trace.origin.as_requirement_str()));\n                 }\n             }\n             infer::Reborrow(span) => {\n@@ -1803,32 +1779,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub trait Resolvable<'tcx> {\n-    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self;\n-}\n-\n-impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n-    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        infcx.resolve_type_vars_if_possible(self)\n-    }\n-}\n-\n-impl<'tcx> Resolvable<'tcx> for ty::TraitRef<'tcx> {\n-    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                         -> ty::TraitRef<'tcx> {\n-        infcx.resolve_type_vars_if_possible(self)\n-    }\n-}\n-\n-impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n-    fn resolve<'a, 'gcx>(&self,\n-                         infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                         -> ty::PolyTraitRef<'tcx>\n-    {\n-        infcx.resolve_type_vars_if_possible(self)\n-    }\n-}\n-\n fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                       scope_id: ast::NodeId)\n                                       -> Vec<hir::LifetimeDef> {"}, {"sha": "87882c5528ec163cd60fce350bc9071066f9c639", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 107, "deletions": 90, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -32,7 +32,7 @@ use ty::adjustment;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use ty::fold::TypeFoldable;\n+use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n use traits::{self, PredicateObligations, ProjectionMode};\n use rustc_data_structures::unify::{self, UnificationTable};\n@@ -196,12 +196,6 @@ pub enum TypeOrigin {\n     // FIXME(eddyb) #11161 is the original Expr required?\n     ExprAssignable(Span),\n \n-    // Relating trait refs when resolving vtables\n-    RelateTraitRefs(Span),\n-\n-    // Relating self types when resolving vtables\n-    RelateSelfType(Span),\n-\n     // Relating trait type parameters to those found in impl etc\n     RelateOutputImplTypes(Span),\n \n@@ -219,16 +213,26 @@ pub enum TypeOrigin {\n \n     // `where a == b`\n     EquatePredicate(Span),\n+\n+    // `main` has wrong type\n+    MainFunctionType(Span),\n+\n+    // `start` has wrong type\n+    StartFunctionType(Span),\n+\n+    // intrinsic has wrong type\n+    IntrinsicType(Span),\n+\n+    // method receiver\n+    MethodReceiver(Span),\n }\n \n impl TypeOrigin {\n-    fn as_str(&self) -> &'static str {\n+    fn as_failure_str(&self) -> &'static str {\n         match self {\n             &TypeOrigin::Misc(_) |\n-            &TypeOrigin::RelateSelfType(_) |\n             &TypeOrigin::RelateOutputImplTypes(_) |\n             &TypeOrigin::ExprAssignable(_) => \"mismatched types\",\n-            &TypeOrigin::RelateTraitRefs(_) => \"mismatched traits\",\n             &TypeOrigin::MethodCompatCheck(_) => \"method not compatible with trait\",\n             &TypeOrigin::MatchExpressionArm(_, _, source) => match source {\n                 hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have incompatible types\",\n@@ -238,13 +242,31 @@ impl TypeOrigin {\n             &TypeOrigin::IfExpressionWithNoElse(_) => \"if may be missing an else clause\",\n             &TypeOrigin::RangeExpression(_) => \"start and end of range have incompatible types\",\n             &TypeOrigin::EquatePredicate(_) => \"equality predicate not satisfied\",\n+            &TypeOrigin::MainFunctionType(_) => \"main function has wrong type\",\n+            &TypeOrigin::StartFunctionType(_) => \"start function has wrong type\",\n+            &TypeOrigin::IntrinsicType(_) => \"intrinsic has wrong type\",\n+            &TypeOrigin::MethodReceiver(_) => \"mismatched method receiver\",\n         }\n     }\n-}\n \n-impl fmt::Display for TypeOrigin {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(),fmt::Error> {\n-        fmt::Display::fmt(self.as_str(), f)\n+    fn as_requirement_str(&self) -> &'static str {\n+        match self {\n+            &TypeOrigin::Misc(_) => \"types are compatible\",\n+            &TypeOrigin::MethodCompatCheck(_) => \"method type is compatible with trait\",\n+            &TypeOrigin::ExprAssignable(_) => \"expression is assignable\",\n+            &TypeOrigin::RelateOutputImplTypes(_) => {\n+                \"trait type parameters matches those specified on the impl\"\n+            }\n+            &TypeOrigin::MatchExpressionArm(_, _, _) => \"match arms have compatible types\",\n+            &TypeOrigin::IfExpression(_) => \"if and else have compatible types\",\n+            &TypeOrigin::IfExpressionWithNoElse(_) => \"if missing an else returns ()\",\n+            &TypeOrigin::RangeExpression(_) => \"start and end of range have compatible types\",\n+            &TypeOrigin::EquatePredicate(_) => \"equality where clause is satisfied\",\n+            &TypeOrigin::MainFunctionType(_) => \"`main` function has the correct type\",\n+            &TypeOrigin::StartFunctionType(_) => \"`start` function has the correct type\",\n+            &TypeOrigin::IntrinsicType(_) => \"intrinsic has the correct type\",\n+            &TypeOrigin::MethodReceiver(_) => \"method receiver has the correct type\",\n+        }\n     }\n }\n \n@@ -1468,104 +1490,50 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // error type, meaning that an error occurred when typechecking this expression),\n     // this is a derived error. The error cascaded from another error (that was already\n     // reported), so it's not useful to display it to the user.\n-    // The following four methods -- type_error_message_str, type_error_message_str_with_expected,\n-    // type_error_message, and report_mismatched_types -- implement this logic.\n+    // The following methods implement this logic.\n     // They check if either the actual or expected type is TyError, and don't print the error\n     // in this case. The typechecker should only ever report type errors involving mismatched\n-    // types using one of these four methods, and should not call span_err directly for such\n+    // types using one of these methods, and should not call span_err directly for such\n     // errors.\n-    pub fn type_error_message_str<M>(&self,\n-                                     sp: Span,\n-                                     mk_msg: M,\n-                                     actual_ty: String,\n-                                     err: Option<&TypeError<'tcx>>)\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n-    }\n-\n-    pub fn type_error_struct_str<M>(&self,\n-                                    sp: Span,\n-                                    mk_msg: M,\n-                                    actual_ty: String,\n-                                    err: Option<&TypeError<'tcx>>)\n-                                    -> DiagnosticBuilder<'tcx>\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        self.type_error_struct_str_with_expected(sp, mk_msg, None, actual_ty, err)\n-    }\n-\n-    pub fn type_error_message_str_with_expected<M>(&self,\n-                                                   sp: Span,\n-                                                   mk_msg: M,\n-                                                   expected_ty: Option<Ty<'tcx>>,\n-                                                   actual_ty: String,\n-                                                   err: Option<&TypeError<'tcx>>)\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        self.type_error_struct_str_with_expected(sp, mk_msg, expected_ty, actual_ty, err)\n-            .emit();\n-    }\n-\n-    pub fn type_error_struct_str_with_expected<M>(&self,\n-                                                  sp: Span,\n-                                                  mk_msg: M,\n-                                                  expected_ty: Option<Ty<'tcx>>,\n-                                                  actual_ty: String,\n-                                                  err: Option<&TypeError<'tcx>>)\n-                                                  -> DiagnosticBuilder<'tcx>\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n-\n-        let resolved_expected = expected_ty.map(|e_ty| self.resolve_type_vars_if_possible(&e_ty));\n-\n-        if !resolved_expected.references_error() {\n-            let error_str = err.map_or(\"\".to_string(), |t_err| {\n-                format!(\" ({})\", t_err)\n-            });\n-\n-            let mut db = self.tcx.sess.struct_span_err(sp, &format!(\"{}{}\",\n-                mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                error_str));\n-\n-            if let Some(err) = err {\n-                self.tcx.note_and_explain_type_err(&mut db, err, sp);\n-            }\n-            db\n-        } else {\n-            self.tcx.sess.diagnostic().struct_dummy()\n-        }\n-    }\n \n     pub fn type_error_message<M>(&self,\n                                  sp: Span,\n                                  mk_msg: M,\n-                                 actual_ty: Ty<'tcx>,\n-                                 err: Option<&TypeError<'tcx>>)\n+                                 actual_ty: Ty<'tcx>)\n         where M: FnOnce(String) -> String,\n     {\n-        self.type_error_struct(sp, mk_msg, actual_ty, err).emit();\n+        self.type_error_struct(sp, mk_msg, actual_ty).emit();\n     }\n \n+    // FIXME: this results in errors without an error code. Deprecate?\n     pub fn type_error_struct<M>(&self,\n                                 sp: Span,\n                                 mk_msg: M,\n-                                actual_ty: Ty<'tcx>,\n-                                err: Option<&TypeError<'tcx>>)\n+                                actual_ty: Ty<'tcx>)\n                                 -> DiagnosticBuilder<'tcx>\n         where M: FnOnce(String) -> String,\n+    {\n+        self.type_error_struct_with_diag(sp, |actual_ty| {\n+            self.tcx.sess.struct_span_err(sp, &mk_msg(actual_ty))\n+        }, actual_ty)\n+    }\n+\n+    pub fn type_error_struct_with_diag<M>(&self,\n+                                          sp: Span,\n+                                          mk_diag: M,\n+                                          actual_ty: Ty<'tcx>)\n+                                          -> DiagnosticBuilder<'tcx>\n+        where M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n     {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n+        debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n \n         // Don't report an error if actual type is TyError.\n         if actual_ty.references_error() {\n             return self.tcx.sess.diagnostic().struct_dummy();\n         }\n \n-        self.type_error_struct_str(sp,\n-            move |_e, a| { mk_msg(a) },\n-            self.ty_to_string(actual_ty), err)\n+        mk_diag(self.ty_to_string(actual_ty))\n     }\n \n     pub fn report_mismatched_types(&self,\n@@ -1833,14 +1801,16 @@ impl TypeOrigin {\n             TypeOrigin::MethodCompatCheck(span) => span,\n             TypeOrigin::ExprAssignable(span) => span,\n             TypeOrigin::Misc(span) => span,\n-            TypeOrigin::RelateTraitRefs(span) => span,\n-            TypeOrigin::RelateSelfType(span) => span,\n             TypeOrigin::RelateOutputImplTypes(span) => span,\n             TypeOrigin::MatchExpressionArm(match_span, _, _) => match_span,\n             TypeOrigin::IfExpression(span) => span,\n             TypeOrigin::IfExpressionWithNoElse(span) => span,\n             TypeOrigin::RangeExpression(span) => span,\n             TypeOrigin::EquatePredicate(span) => span,\n+            TypeOrigin::MainFunctionType(span) => span,\n+            TypeOrigin::StartFunctionType(span) => span,\n+            TypeOrigin::IntrinsicType(span) => span,\n+            TypeOrigin::MethodReceiver(span) => span,\n         }\n     }\n }\n@@ -1891,3 +1861,50 @@ impl RegionVariableOrigin {\n         }\n     }\n }\n+\n+impl<'tcx> TypeFoldable<'tcx> for TypeOrigin {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n+        self.clone()\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ValuePairs<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            ValuePairs::Types(ref ef) => {\n+                ValuePairs::Types(ef.fold_with(folder))\n+            }\n+            ValuePairs::TraitRefs(ref ef) => {\n+                ValuePairs::TraitRefs(ef.fold_with(folder))\n+            }\n+            ValuePairs::PolyTraitRefs(ref ef) => {\n+                ValuePairs::PolyTraitRefs(ef.fold_with(folder))\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            ValuePairs::Types(ref ef) => ef.visit_with(visitor),\n+            ValuePairs::TraitRefs(ref ef) => ef.visit_with(visitor),\n+            ValuePairs::PolyTraitRefs(ref ef) => ef.visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for TypeTrace<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        TypeTrace {\n+            origin: self.origin.fold_with(folder),\n+            values: self.values.fold_with(folder)\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.origin.visit_with(visitor) || self.values.visit_with(visitor)\n+    }\n+}"}, {"sha": "5901c42b525826881c2746a00e16c45c9bed4847", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 77, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -126,20 +126,14 @@ impl Session {\n                                                    sp: S,\n                                                    msg: &str)\n                                                    -> DiagnosticBuilder<'a>  {\n-        match split_msg_into_multilines(msg) {\n-            Some(ref msg) => self.diagnostic().struct_span_err(sp, msg),\n-            None => self.diagnostic().struct_span_err(sp, msg),\n-        }\n+        self.diagnostic().struct_span_err(sp, msg)\n     }\n     pub fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n                                                              sp: S,\n                                                              msg: &str,\n                                                              code: &str)\n                                                              -> DiagnosticBuilder<'a>  {\n-        match split_msg_into_multilines(msg) {\n-            Some(ref msg) => self.diagnostic().struct_span_err_with_code(sp, msg, code),\n-            None => self.diagnostic().struct_span_err_with_code(sp, msg, code),\n-        }\n+        self.diagnostic().struct_span_err_with_code(sp, msg, code)\n     }\n     pub fn struct_err<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n         self.diagnostic().struct_err(msg)\n@@ -178,16 +172,10 @@ impl Session {\n         }\n     }\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        match split_msg_into_multilines(msg) {\n-            Some(msg) => self.diagnostic().span_err(sp, &msg),\n-            None => self.diagnostic().span_err(sp, msg)\n-        }\n+        self.diagnostic().span_err(sp, msg)\n     }\n     pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n-        match split_msg_into_multilines(msg) {\n-            Some(msg) => self.diagnostic().span_err_with_code(sp, &msg, code),\n-            None => self.diagnostic().span_err_with_code(sp, msg, code)\n-        }\n+        self.diagnostic().span_err_with_code(sp, &msg, code)\n     }\n     pub fn err(&self, msg: &str) {\n         self.diagnostic().err(msg)\n@@ -343,67 +331,6 @@ impl Session {\n     }\n }\n \n-fn split_msg_into_multilines(msg: &str) -> Option<String> {\n-    // Conditions for enabling multi-line errors:\n-    if !msg.contains(\"mismatched types\") &&\n-        !msg.contains(\"type mismatch resolving\") &&\n-        !msg.contains(\"if and else have incompatible types\") &&\n-        !msg.contains(\"if may be missing an else clause\") &&\n-        !msg.contains(\"match arms have incompatible types\") &&\n-        !msg.contains(\"structure constructor specifies a structure of type\") &&\n-        !msg.contains(\"has an incompatible type for trait\") {\n-            return None\n-    }\n-    let first = msg.match_indices(\"expected\").filter(|s| {\n-        let last = msg[..s.0].chars().rev().next();\n-        last == Some(' ') || last == Some('(')\n-    }).map(|(a, b)| (a - 1, a + b.len()));\n-    let second = msg.match_indices(\"found\").filter(|s| {\n-        msg[..s.0].chars().rev().next() == Some(' ')\n-    }).map(|(a, b)| (a - 1, a + b.len()));\n-\n-    let mut new_msg = String::new();\n-    let mut head = 0;\n-\n-    // Insert `\\n` before expected and found.\n-    for (pos1, pos2) in first.zip(second) {\n-        new_msg = new_msg +\n-        // A `(` may be preceded by a space and it should be trimmed\n-                  msg[head..pos1.0].trim_right() + // prefix\n-                  \"\\n\" +                           // insert before first\n-                  &msg[pos1.0..pos1.1] +           // insert what first matched\n-                  &msg[pos1.1..pos2.0] +           // between matches\n-                  \"\\n   \" +                        // insert before second\n-        //           123\n-        // `expected` is 3 char longer than `found`. To align the types,\n-        // `found` gets 3 spaces prepended.\n-                  &msg[pos2.0..pos2.1];            // insert what second matched\n-\n-        head = pos2.1;\n-    }\n-\n-    let mut tail = &msg[head..];\n-    let third = tail.find(\"(values differ\")\n-                   .or(tail.find(\"(lifetime\"))\n-                   .or(tail.find(\"(cyclic type of infinite size\"));\n-    // Insert `\\n` before any remaining messages which match.\n-    if let Some(pos) = third {\n-        // The end of the message may just be wrapped in `()` without\n-        // `expected`/`found`.  Push this also to a new line and add the\n-        // final tail after.\n-        new_msg = new_msg +\n-        // `(` is usually preceded by a space and should be trimmed.\n-                  tail[..pos].trim_right() + // prefix\n-                  \"\\n\" +                     // insert before paren\n-                  &tail[pos..];              // append the tail\n-\n-        tail = \"\";\n-    }\n-\n-    new_msg.push_str(tail);\n-    return Some(new_msg);\n-}\n-\n pub fn build_session(sopts: config::Options,\n                      dep_graph: &DepGraph,\n                      local_crate_source_file: Option<PathBuf>,"}, {"sha": "67ad887530eb318ccabe450784dc9480e11e5297", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 57, "deletions": 17, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -26,8 +26,9 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n-use infer::{InferCtxt};\n+use infer::{self, InferCtxt, TypeOrigin};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n use ty::subst::{self, Subst, TypeSpace};\n@@ -107,24 +108,63 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let predicate =\n             self.resolve_type_vars_if_possible(&obligation.predicate);\n \n-        if !predicate.references_error() {\n-            if let Some(warning_node_id) = warning_node_id {\n-                self.tcx.sess.add_lint(\n-                    ::lint::builtin::UNSIZED_IN_TUPLE,\n-                    warning_node_id,\n+        if predicate.references_error() {\n+            return\n+        }\n+        if let Some(warning_node_id) = warning_node_id {\n+            self.tcx.sess.add_lint(\n+                ::lint::builtin::UNSIZED_IN_TUPLE,\n+                warning_node_id,\n+                obligation.cause.span,\n+                format!(\"type mismatch resolving `{}`: {}\",\n+                        predicate,\n+                        error.err));\n+            return\n+        }\n+        self.probe(|_| {\n+            let origin = TypeOrigin::Misc(obligation.cause.span);\n+            let err_buf;\n+            let mut err = &error.err;\n+            let mut values = None;\n+\n+            // try to find the mismatched types to report the error with.\n+            //\n+            // this can fail if the problem was higher-ranked, in which\n+            // cause I have no idea for a good error message.\n+            if let ty::Predicate::Projection(ref data) = predicate {\n+                let mut selcx = SelectionContext::new(self);\n+                let (data, _) = self.replace_late_bound_regions_with_fresh_var(\n                     obligation.cause.span,\n-                    format!(\"type mismatch resolving `{}`: {}\",\n-                            predicate,\n-                            error.err));\n-            } else {\n-                let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0271,\n-                                               \"type mismatch resolving `{}`: {}\",\n-                                               predicate,\n-                                               error.err);\n-                self.note_obligation_cause(&mut err, obligation);\n-                err.emit();\n+                    infer::LateBoundRegionConversionTime::HigherRankedType,\n+                    data);\n+                let normalized = super::normalize_projection_type(\n+                    &mut selcx,\n+                    data.projection_ty,\n+                    obligation.cause.clone(),\n+                    0\n+                );\n+                let origin = TypeOrigin::Misc(obligation.cause.span);\n+                if let Err(error) = self.eq_types(\n+                    false, origin,\n+                    data.ty, normalized.value\n+                ) {\n+                    values = Some(infer::ValuePairs::Types(ExpectedFound {\n+                        expected: normalized.value,\n+                        found: data.ty,\n+                    }));\n+                    err_buf = error;\n+                    err = &err_buf;\n+                }\n             }\n-        }\n+\n+            let mut diag = struct_span_err!(\n+                self.tcx.sess, origin.span(), E0271,\n+                \"type mismatch resolving `{}`\", predicate\n+            );\n+            self.note_type_err(&mut diag, origin, values, err);\n+            self.note_obligation_cause(&mut diag, obligation);\n+            diag.emit();\n+        });\n     }\n \n     fn impl_substs(&self,"}, {"sha": "16a54c20925deda7b8417a3747be29e6e0289bec", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -1018,3 +1018,16 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeScheme<'tcx>  {\n         self.generics.visit_with(visitor) || self.ty.visit_with(visitor)\n     }\n }\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::error::ExpectedFound<T> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::error::ExpectedFound {\n+            expected: self.expected.fold_with(folder),\n+            found: self.found.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.expected.visit_with(visitor) || self.found.visit_with(visitor)\n+    }\n+}"}, {"sha": "8967672548b101b3b35a01f04b8207ab8b5d1198", "filename": "src/librustc_const_eval/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -14,6 +14,7 @@ serialize = { path = \"../libserialize\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n syntax = { path = \"../libsyntax\" }\n graphviz = { path = \"../libgraphviz\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file"}, {"sha": "915a0cf0bdc7301ecda143b9d51745a827453b37", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -17,6 +17,7 @@ use rustc::middle::const_val::ConstVal;\n use ::{eval_const_expr, eval_const_expr_partial, compare_const_vals};\n use ::{const_expr_to_pat, lookup_const_by_id};\n use ::EvalHint::ExprTypeChecked;\n+use eval::report_const_eval_err;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{DefId};\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n@@ -42,6 +43,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir::fold::{Folder, noop_fold_pat};\n use rustc::hir::print::pat_to_string;\n use syntax::ptr::P;\n+use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n@@ -279,13 +281,7 @@ fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n                 Ok(_) => {}\n \n                 Err(err) => {\n-                    let mut diag = struct_span_err!(cx.tcx.sess, err.span, E0471,\n-                                                    \"constant evaluation error: {}\",\n-                                                    err.description());\n-                    if !p.span.contains(err.span) {\n-                        diag.span_note(p.span, \"in pattern here\");\n-                    }\n-                    diag.emit();\n+                    report_const_eval_err(cx.tcx, &err, p.span, \"pattern\").emit();\n                 }\n             }\n         }\n@@ -838,22 +834,19 @@ pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> us\n     }\n }\n \n-fn range_covered_by_constructor(ctor: &Constructor,\n-                                from: &ConstVal, to: &ConstVal) -> Option<bool> {\n+fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n+                                ctor: &Constructor,\n+                                from: &ConstVal, to: &ConstVal)\n+                                -> Result<bool, ErrorReported> {\n     let (c_from, c_to) = match *ctor {\n         ConstantValue(ref value)        => (value, value),\n         ConstantRange(ref from, ref to) => (from, to),\n-        Single                          => return Some(true),\n+        Single                          => return Ok(true),\n         _                               => bug!()\n     };\n-    let cmp_from = compare_const_vals(c_from, from);\n-    let cmp_to = compare_const_vals(c_to, to);\n-    match (cmp_from, cmp_to) {\n-        (Some(cmp_from), Some(cmp_to)) => {\n-            Some(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n-        }\n-        _ => None\n-    }\n+    let cmp_from = compare_const_vals(tcx, span, c_from, from)?;\n+    let cmp_to = compare_const_vals(tcx, span, c_to, to)?;\n+    Ok(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n }\n \n fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n@@ -965,27 +958,25 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Some(vec![(pat, Some(mt.ty))])\n             } else {\n                 let expr_value = eval_const_expr(cx.tcx, &expr);\n-                match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n-                    Some(true) => Some(vec![]),\n-                    Some(false) => None,\n-                    None => {\n-                        span_err!(cx.tcx.sess, pat_span, E0298, \"mismatched types between arms\");\n-                        None\n-                    }\n+                match range_covered_by_constructor(\n+                    cx.tcx, expr.span, constructor, &expr_value, &expr_value\n+                ) {\n+                    Ok(true) => Some(vec![]),\n+                    Ok(false) => None,\n+                    Err(ErrorReported) => None,\n                 }\n             }\n         }\n \n         PatKind::Range(ref from, ref to) => {\n             let from_value = eval_const_expr(cx.tcx, &from);\n             let to_value = eval_const_expr(cx.tcx, &to);\n-            match range_covered_by_constructor(constructor, &from_value, &to_value) {\n-                Some(true) => Some(vec![]),\n-                Some(false) => None,\n-                None => {\n-                    span_err!(cx.tcx.sess, pat_span, E0299, \"mismatched types between arms\");\n-                    None\n-                }\n+            match range_covered_by_constructor(\n+                cx.tcx, pat_span, constructor, &from_value, &to_value\n+            ) {\n+                Ok(true) => Some(vec![]),\n+                Ok(false) => None,\n+                Err(ErrorReported) => None,\n             }\n         }\n "}, {"sha": "45414c33c075448640ef116443fcaf58f23d4e0d", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -551,44 +551,46 @@ The `op_string_ref` binding has type `&Option<&String>` in both cases.\n See also https://github.com/rust-lang/rust/issues/14587\n \"##,\n \n-E0306: r##\"\n-In an array literal `[x; N]`, `N` is the number of elements in the array. This\n-must be an unsigned integer. Erroneous code example:\n+E0080: r##\"\n+This error indicates that the compiler was unable to sensibly evaluate an\n+constant expression that had to be evaluated. Attempting to divide by 0\n+or causing integer overflow are two ways to induce this error. For example:\n \n ```compile_fail\n-let x = [0i32; true]; // error: expected positive integer for repeat count,\n-                      //        found boolean\n+enum Enum {\n+    X = (1 << 500),\n+    Y = (1 / 0)\n+}\n ```\n \n-Working example:\n+Ensure that the expressions given can be evaluated as the desired integer type.\n+See the FFI section of the Reference for more information about using a custom\n+integer type:\n \n-```\n-let x = [0i32; 2];\n-```\n+https://doc.rust-lang.org/reference.html#ffi-attributes\n \"##,\n \n-E0307: r##\"\n-The length of an array is part of its type. For this reason, this length must\n-be a compile-time constant. Erroneous code example:\n+\n+E0306: r##\"\n+In an array literal `[x; N]`, `N` is the number of elements in the array. This\n+must be an unsigned integer. Erroneous code example:\n \n ```compile_fail\n-    let len = 10;\n-    let x = [0i32; len]; // error: expected constant integer for repeat count,\n-                         //        found variable\n+let x = [0i32; true]; // error: expected positive integer for repeat count,\n+                      //        found boolean\n ```\n \n Working example:\n \n ```\n-let x = [0i32; 10];\n+let x = [0i32; 2];\n ```\n \"##,\n-\n }\n \n \n register_diagnostics! {\n-E0298, // mismatched types between arms\n-E0299, // mismatched types between arms\n-E0471, // constant evaluation error: ..\n+    E0298, // cannot compare constants\n+//  E0299, // mismatched types between arms\n+//  E0471, // constant evaluation error (in pattern)\n }"}, {"sha": "dd21bb17a2da95e810945c02d3f3f0323e2fcb15", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 165, "deletions": 67, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -25,6 +25,7 @@ use rustc::hir::pat_util::def_to_path;\n use rustc::ty::{self, Ty, TyCtxt, subst};\n use rustc::ty::util::IntTypeExt;\n use rustc::traits::ProjectionMode;\n+use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n use rustc::lint;\n \n@@ -43,6 +44,7 @@ use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n \n use rustc_const_math::*;\n+use rustc_errors::{DiagnosticBuilder, check_old_school};\n \n macro_rules! math {\n     ($e:expr, $op:expr) => {\n@@ -338,20 +340,71 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Ok(P(hir::Pat { id: expr.id, node: pat, span: span }))\n }\n \n+pub fn report_const_eval_err<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    err: &ConstEvalErr,\n+    primary_span: Span,\n+    primary_kind: &str)\n+    -> DiagnosticBuilder<'tcx>\n+{\n+    let mut err = err;\n+    while let &ConstEvalErr { kind: ErroneousReferencedConstant(box ref i_err), .. } = err {\n+        err = i_err;\n+    }\n+\n+    let mut diag = struct_span_err!(tcx.sess, err.span, E0080, \"constant evaluation error\");\n+    note_const_eval_err(tcx, err, primary_span, primary_kind, &mut diag);\n+    diag\n+}\n+\n+pub fn fatal_const_eval_err<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    err: &ConstEvalErr,\n+    primary_span: Span,\n+    primary_kind: &str)\n+    -> !\n+{\n+    report_const_eval_err(tcx, err, primary_span, primary_kind).emit();\n+    tcx.sess.abort_if_errors();\n+    unreachable!()\n+}\n+\n+pub fn note_const_eval_err<'a, 'tcx>(\n+    _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    err: &ConstEvalErr,\n+    primary_span: Span,\n+    primary_kind: &str,\n+    diag: &mut DiagnosticBuilder)\n+{\n+    match err.description() {\n+        ConstEvalErrDescription::Simple(message) => {\n+            if check_old_school() {\n+                diag.note(&message);\n+            } else {\n+                diag.span_label(err.span, &message);\n+            }\n+        }\n+    }\n+\n+    if !primary_span.contains(err.span) {\n+        diag.span_note(primary_span,\n+                       &format!(\"for {} here\", primary_kind));\n+    }\n+}\n+\n pub fn eval_const_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  e: &Expr) -> ConstVal {\n     match eval_const_expr_partial(tcx, e, ExprTypeChecked, None) {\n         Ok(r) => r,\n         // non-const path still needs to be a fatal error, because enums are funky\n         Err(s) => {\n+            report_const_eval_err(tcx, &s, e.span, \"expression\").emit();\n             match s.kind {\n                 NonConstPath |\n-                UnimplementedConstVal(_) => tcx.sess.span_fatal(s.span, &s.description()),\n-                _ => {\n-                    tcx.sess.span_err(s.span, &s.description());\n-                    Dummy\n-                }\n+                UnimplementedConstVal(_) => tcx.sess.abort_if_errors(),\n+                _ => {}\n             }\n+            Dummy\n         },\n     }\n }\n@@ -400,6 +453,7 @@ pub enum ErrKind {\n     IntermediateUnsignedNegative,\n     /// Expected, Got\n     TypeMismatch(String, ConstInt),\n+\n     BadType(ConstVal),\n     ErroneousReferencedConstant(Box<ConstEvalErr>),\n     CharCast(ConstInt),\n@@ -411,57 +465,79 @@ impl From<ConstMathErr> for ErrKind {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+pub enum ConstEvalErrDescription<'a> {\n+    Simple(Cow<'a, str>),\n+}\n+\n+impl<'a> ConstEvalErrDescription<'a> {\n+    /// Return a one-line description of the error, for lints and such\n+    pub fn into_oneline(self) -> Cow<'a, str> {\n+        match self {\n+            ConstEvalErrDescription::Simple(simple) => simple,\n+        }\n+    }\n+}\n+\n impl ConstEvalErr {\n-    pub fn description(&self) -> Cow<str> {\n+    pub fn description(&self) -> ConstEvalErrDescription {\n         use self::ErrKind::*;\n+        use self::ConstEvalErrDescription::*;\n+\n+        macro_rules! simple {\n+            ($msg:expr) => ({ Simple($msg.into_cow()) });\n+            ($fmt:expr, $($arg:tt)+) => ({\n+                Simple(format!($fmt, $($arg)+).into_cow())\n+            })\n+        }\n \n         match self.kind {\n-            CannotCast => \"can't cast this type\".into_cow(),\n-            CannotCastTo(s) => format!(\"can't cast this type to {}\", s).into_cow(),\n-            InvalidOpForInts(_) =>  \"can't do this op on integrals\".into_cow(),\n-            InvalidOpForBools(_) =>  \"can't do this op on bools\".into_cow(),\n-            InvalidOpForFloats(_) => \"can't do this op on floats\".into_cow(),\n-            InvalidOpForIntUint(..) => \"can't do this op on an isize and usize\".into_cow(),\n-            InvalidOpForUintInt(..) => \"can't do this op on a usize and isize\".into_cow(),\n-            NegateOn(ref const_val) => format!(\"negate on {}\", const_val.description()).into_cow(),\n-            NotOn(ref const_val) => format!(\"not on {}\", const_val.description()).into_cow(),\n-            CallOn(ref const_val) => format!(\"call on {}\", const_val.description()).into_cow(),\n-\n-            MissingStructField  => \"nonexistent struct field\".into_cow(),\n-            NonConstPath        => \"non-constant path in constant expression\".into_cow(),\n+            CannotCast => simple!(\"can't cast this type\"),\n+            CannotCastTo(s) => simple!(\"can't cast this type to {}\", s),\n+            InvalidOpForInts(_) =>  simple!(\"can't do this op on integrals\"),\n+            InvalidOpForBools(_) =>  simple!(\"can't do this op on bools\"),\n+            InvalidOpForFloats(_) => simple!(\"can't do this op on floats\"),\n+            InvalidOpForIntUint(..) => simple!(\"can't do this op on an isize and usize\"),\n+            InvalidOpForUintInt(..) => simple!(\"can't do this op on a usize and isize\"),\n+            NegateOn(ref const_val) => simple!(\"negate on {}\", const_val.description()),\n+            NotOn(ref const_val) => simple!(\"not on {}\", const_val.description()),\n+            CallOn(ref const_val) => simple!(\"call on {}\", const_val.description()),\n+\n+            MissingStructField  => simple!(\"nonexistent struct field\"),\n+            NonConstPath        => simple!(\"non-constant path in constant expression\"),\n             UnimplementedConstVal(what) =>\n-                format!(\"unimplemented constant expression: {}\", what).into_cow(),\n-            UnresolvedPath => \"unresolved path in constant expression\".into_cow(),\n-            ExpectedConstTuple => \"expected constant tuple\".into_cow(),\n-            ExpectedConstStruct => \"expected constant struct\".into_cow(),\n-            TupleIndexOutOfBounds => \"tuple index out of bounds\".into_cow(),\n-            IndexedNonVec => \"indexing is only supported for arrays\".into_cow(),\n-            IndexNegative => \"indices must be non-negative integers\".into_cow(),\n-            IndexNotInt => \"indices must be integers\".into_cow(),\n+                simple!(\"unimplemented constant expression: {}\", what),\n+            UnresolvedPath => simple!(\"unresolved path in constant expression\"),\n+            ExpectedConstTuple => simple!(\"expected constant tuple\"),\n+            ExpectedConstStruct => simple!(\"expected constant struct\"),\n+            TupleIndexOutOfBounds => simple!(\"tuple index out of bounds\"),\n+            IndexedNonVec => simple!(\"indexing is only supported for arrays\"),\n+            IndexNegative => simple!(\"indices must be non-negative integers\"),\n+            IndexNotInt => simple!(\"indices must be integers\"),\n             IndexOutOfBounds { len, index } => {\n-                format!(\"index out of bounds: the len is {} but the index is {}\",\n-                        len, index).into_cow()\n+                simple!(\"index out of bounds: the len is {} but the index is {}\",\n+                        len, index)\n             }\n-            RepeatCountNotNatural => \"repeat count must be a natural number\".into_cow(),\n-            RepeatCountNotInt => \"repeat count must be integers\".into_cow(),\n+            RepeatCountNotNatural => simple!(\"repeat count must be a natural number\"),\n+            RepeatCountNotInt => simple!(\"repeat count must be integers\"),\n \n-            MiscBinaryOp => \"bad operands for binary\".into_cow(),\n-            MiscCatchAll => \"unsupported constant expr\".into_cow(),\n-            IndexOpFeatureGated => \"the index operation on const values is unstable\".into_cow(),\n-            Math(ref err) => err.description().into_cow(),\n+            MiscBinaryOp => simple!(\"bad operands for binary\"),\n+            MiscCatchAll => simple!(\"unsupported constant expr\"),\n+            IndexOpFeatureGated => simple!(\"the index operation on const values is unstable\"),\n+            Math(ref err) => Simple(err.description().into_cow()),\n \n-            IntermediateUnsignedNegative => \"during the computation of an unsigned a negative \\\n-                                             number was encountered. This is most likely a bug in\\\n-                                             the constant evaluator\".into_cow(),\n+            IntermediateUnsignedNegative => simple!(\n+                \"during the computation of an unsigned a negative \\\n+                 number was encountered. This is most likely a bug in\\\n+                 the constant evaluator\"),\n \n             TypeMismatch(ref expected, ref got) => {\n-                format!(\"mismatched types: expected `{}`, found `{}`\",\n-                        expected, got.description()).into_cow()\n+                simple!(\"expected {}, found {}\", expected, got.description())\n             },\n-            BadType(ref i) => format!(\"value of wrong type: {:?}\", i).into_cow(),\n-            ErroneousReferencedConstant(_) => \"could not evaluate referenced constant\".into_cow(),\n+            BadType(ref i) => simple!(\"value of wrong type: {:?}\", i),\n+            ErroneousReferencedConstant(_) => simple!(\"could not evaluate referenced constant\"),\n             CharCast(ref got) => {\n-                format!(\"only `u8` can be cast as `char`, not `{}`\", got.description()).into_cow()\n+                simple!(\"only `u8` can be cast as `char`, not `{}`\", got.description())\n             },\n         }\n     }\n@@ -1199,71 +1275,93 @@ fn parse_float(num: &str, fty_hint: Option<ast::FloatTy>, span: Span) -> ConstFl\n     })\n }\n \n-pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n-    match (a, b) {\n+pub fn compare_const_vals(tcx: TyCtxt, span: Span, a: &ConstVal, b: &ConstVal)\n+                          -> Result<Ordering, ErrorReported>\n+{\n+    let result = match (a, b) {\n         (&Integral(a), &Integral(b)) => a.try_cmp(b).ok(),\n         (&Float(a), &Float(b)) => a.try_cmp(b).ok(),\n         (&Str(ref a), &Str(ref b)) => Some(a.cmp(b)),\n         (&Bool(a), &Bool(b)) => Some(a.cmp(&b)),\n         (&ByteStr(ref a), &ByteStr(ref b)) => Some(a.cmp(b)),\n         (&Char(a), &Char(ref b)) => Some(a.cmp(b)),\n         _ => None,\n+    };\n+\n+    match result {\n+        Some(result) => Ok(result),\n+        None => {\n+            // FIXME: can this ever be reached?\n+            span_err!(tcx.sess, span, E0298,\n+                      \"type mismatch comparing {} and {}\",\n+                      a.description(),\n+                      b.description());\n+            Err(ErrorReported)\n+        }\n     }\n }\n \n pub fn compare_lit_exprs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   span: Span,\n                                    a: &Expr,\n-                                   b: &Expr) -> Option<Ordering> {\n+                                   b: &Expr) -> Result<Ordering, ErrorReported> {\n     let a = match eval_const_expr_partial(tcx, a, ExprTypeChecked, None) {\n         Ok(a) => a,\n         Err(e) => {\n-            tcx.sess.span_err(a.span, &e.description());\n-            return None;\n+            report_const_eval_err(tcx, &e, a.span, \"expression\").emit();\n+            return Err(ErrorReported);\n         }\n     };\n     let b = match eval_const_expr_partial(tcx, b, ExprTypeChecked, None) {\n         Ok(b) => b,\n         Err(e) => {\n-            tcx.sess.span_err(b.span, &e.description());\n-            return None;\n+            report_const_eval_err(tcx, &e, b.span, \"expression\").emit();\n+            return Err(ErrorReported);\n         }\n     };\n-    compare_const_vals(&a, &b)\n+    compare_const_vals(tcx, span, &a, &b)\n }\n \n \n-/// Returns the repeat count for a repeating vector expression.\n-pub fn eval_repeat_count<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   count_expr: &hir::Expr) -> usize {\n+/// Returns the value of the length-valued expression\n+pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             count_expr: &hir::Expr,\n+                             reason: &str)\n+                             -> Result<usize, ErrorReported>\n+{\n     let hint = UncheckedExprHint(tcx.types.usize);\n     match eval_const_expr_partial(tcx, count_expr, hint, None) {\n         Ok(Integral(Usize(count))) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n             assert_eq!(val as usize as u64, val);\n-            val as usize\n+            Ok(val as usize)\n         },\n         Ok(const_val) => {\n             span_err!(tcx.sess, count_expr.span, E0306,\n-                      \"expected positive integer for repeat count, found {}\",\n+                      \"expected usize for {}, found {}\",\n+                      reason,\n                       const_val.description());\n-            0\n+            Err(ErrorReported)\n         }\n         Err(err) => {\n-            let err_msg = match count_expr.node {\n+            let mut diag = report_const_eval_err(\n+                tcx, &err, count_expr.span, reason);\n+\n+            match count_expr.node {\n                 hir::ExprPath(None, hir::Path {\n                     global: false,\n                     ref segments,\n                     ..\n-                }) if segments.len() == 1 =>\n-                    format!(\"found variable\"),\n-                _ => match err.kind {\n-                    MiscCatchAll => format!(\"but found {}\", err.description()),\n-                    _ => format!(\"but {}\", err.description())\n+                }) if segments.len() == 1 => {\n+                    if let Some(Def::Local(..)) = tcx.expect_def_or_none(count_expr.id) {\n+                        diag.note(&format!(\"`{}` is a variable\", segments[0].name));\n+                    }\n                 }\n-            };\n-            span_err!(tcx.sess, count_expr.span, E0307,\n-                \"expected constant integer for repeat count, {}\", err_msg);\n-            0\n+                _ => {}\n+            }\n+\n+            diag.emit();\n+            Err(ErrorReported)\n         }\n     }\n }"}, {"sha": "a6714c178e7cf68c46e750891dd39703f285c401", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -36,6 +36,7 @@\n #[macro_use] extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_const_math;\n+extern crate rustc_errors;\n extern crate graphviz;\n extern crate syntax_pos;\n extern crate serialize as rustc_serialize; // used by deriving"}, {"sha": "610e5647d6d12893547923c65d361474d0914c00", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -531,10 +531,12 @@ impl Handler {\n         DiagnosticBuilder::new(self, Level::Fatal, msg)\n     }\n \n-    pub fn cancel(&mut self, err: &mut DiagnosticBuilder) {\n+    pub fn cancel(&self, err: &mut DiagnosticBuilder) {\n         if err.level == Level::Error || err.level == Level::Fatal {\n-            assert!(self.has_errors());\n-            self.err_count.set(self.err_count.get() + 1);\n+            self.err_count.set(\n+                self.err_count.get().checked_sub(1)\n+                    .expect(\"cancelled an error but err_count is 0\")\n+            );\n         }\n         err.cancel();\n     }"}, {"sha": "b0ba38f1db67322d33aa51dac8e0d5fd41f26492", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -40,6 +40,7 @@ use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::ProjectionMode;\n+use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n use rustc::middle::const_qualif::ConstQualif;\n use rustc::lint::builtin::CONST_ERR;\n@@ -116,7 +117,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n                 _ => self.tcx.sess.add_lint(CONST_ERR, expr.id, expr.span,\n                                          format!(\"constant evaluation error: {}. This will \\\n                                                  become a HARD ERROR in the future\",\n-                                                 err.description())),\n+                                                 err.description().into_oneline())),\n             }\n         }\n         self.with_mode(mode, |this| {\n@@ -211,15 +212,6 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n             }\n         }\n     }\n-\n-    fn msg(&self) -> &'static str {\n-        match self.mode {\n-            Mode::Const => \"constant\",\n-            Mode::ConstFn => \"constant function\",\n-            Mode::StaticMut | Mode::Static => \"static\",\n-            Mode::Var => bug!(),\n-        }\n-    }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n@@ -289,18 +281,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 self.global_expr(Mode::Const, &start);\n                 self.global_expr(Mode::Const, &end);\n \n-                match compare_lit_exprs(self.tcx, start, end) {\n-                    Some(Ordering::Less) |\n-                    Some(Ordering::Equal) => {}\n-                    Some(Ordering::Greater) => {\n+                match compare_lit_exprs(self.tcx, p.span, start, end) {\n+                    Ok(Ordering::Less) |\n+                    Ok(Ordering::Equal) => {}\n+                    Ok(Ordering::Greater) => {\n                         span_err!(self.tcx.sess, start.span, E0030,\n                             \"lower range bound must be less than or equal to upper\");\n                     }\n-                    None => {\n-                        span_err!(self.tcx.sess, p.span, E0014,\n-                                  \"paths in {}s may only refer to constants\",\n-                                  self.msg());\n-                    }\n+                    Err(ErrorReported) => {}\n                 }\n             }\n             _ => intravisit::walk_pat(self, p)\n@@ -429,7 +417,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 Err(msg) => {\n                     self.tcx.sess.add_lint(CONST_ERR, ex.id,\n                                            msg.span,\n-                                           msg.description().into_owned())\n+                                           msg.description().into_oneline().into_owned())\n                 }\n             }\n         }"}, {"sha": "a616b95ef7203ad312ba54a6a6af4c127d907aca", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_snake_case)]\n \n register_long_diagnostics! {\n-\n+/*\n E0014: r##\"\n Constants can only be initialized by a constant value or, in a future\n version of Rust, a call to a const function. This error indicates the use\n@@ -30,7 +30,7 @@ const FOO: i32 = { const X : i32 = 0; X };\n const FOO2: i32 = { 0 }; // but brackets are useless here\n ```\n \"##,\n-\n+*/\n E0030: r##\"\n When matching against a range, the compiler verifies that the range is\n non-empty.  Range patterns include both end-points, so this is equivalent to"}, {"sha": "f7fd970f37f2f89e1a4686f541ef9ea5984343bc", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -190,7 +190,7 @@ use self::FailureHandler::*;\n \n use llvm::{ValueRef, BasicBlockRef};\n use rustc_const_eval::check_match::{self, Constructor, StaticInliner};\n-use rustc_const_eval::{compare_lit_exprs, eval_const_expr};\n+use rustc_const_eval::{compare_lit_exprs, eval_const_expr, fatal_const_eval_err};\n use rustc::hir::def::{Def, DefMap};\n use rustc::hir::def_id::DefId;\n use middle::expr_use_visitor as euv;\n@@ -239,9 +239,9 @@ struct ConstantExpr<'a>(&'a hir::Expr);\n \n impl<'a> ConstantExpr<'a> {\n     fn eq<'b, 'tcx>(self, other: ConstantExpr<'a>, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> bool {\n-        match compare_lit_exprs(tcx, self.0, other.0) {\n-            Some(result) => result == Ordering::Equal,\n-            None => bug!(\"compare_list_exprs: type mismatch\"),\n+        match compare_lit_exprs(tcx, self.0.span, self.0, other.0) {\n+            Ok(result) => result == Ordering::Equal,\n+            Err(_) => bug!(\"compare_list_exprs: type mismatch\"),\n         }\n     }\n }\n@@ -288,7 +288,9 @@ impl<'a, 'b, 'tcx> Opt<'a, 'tcx> {\n                 let expr = consts::const_expr(ccx, &lit_expr, bcx.fcx.param_substs, None, Yes);\n                 let llval = match expr {\n                     Ok((llval, _)) => llval,\n-                    Err(err) => bcx.ccx().sess().span_fatal(lit_expr.span, &err.description()),\n+                    Err(err) => {\n+                        fatal_const_eval_err(bcx.tcx(), err.as_inner(), lit_expr.span, \"pattern\");\n+                    }\n                 };\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n@@ -297,11 +299,11 @@ impl<'a, 'b, 'tcx> Opt<'a, 'tcx> {\n             ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2), _) => {\n                 let l1 = match consts::const_expr(ccx, &l1, bcx.fcx.param_substs, None, Yes) {\n                     Ok((l1, _)) => l1,\n-                    Err(err) => bcx.ccx().sess().span_fatal(l1.span, &err.description()),\n+                    Err(err) => fatal_const_eval_err(bcx.tcx(), err.as_inner(), l1.span, \"pattern\"),\n                 };\n                 let l2 = match consts::const_expr(ccx, &l2, bcx.fcx.param_substs, None, Yes) {\n                     Ok((l2, _)) => l2,\n-                    Err(err) => bcx.ccx().sess().span_fatal(l2.span, &err.description()),\n+                    Err(err) => fatal_const_eval_err(bcx.tcx(), err.as_inner(), l2.span, \"pattern\"),\n                 };\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }"}, {"sha": "f662ba75cc6fea7c5e4f014d30e4c69ba67171f8", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -14,7 +14,7 @@ use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use middle::const_qualif::ConstQualif;\n use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, lookup_const_by_id, ErrKind};\n-use rustc_const_eval::eval_repeat_count;\n+use rustc_const_eval::{eval_length, report_const_eval_err, note_const_eval_err};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n@@ -44,7 +44,6 @@ use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n use rustc::hir;\n \n use std::ffi::{CStr, CString};\n-use std::borrow::Cow;\n use libc::c_uint;\n use syntax::ast::{self, LitKind};\n use syntax::attr::{self, AttrMetaMethods};\n@@ -250,10 +249,11 @@ impl ConstEvalFailure {\n             Compiletime(e) => e,\n         }\n     }\n-    pub fn description(&self) -> Cow<str> {\n+\n+    pub fn as_inner(&self) -> &ConstEvalErr {\n         match self {\n-            &Runtime(ref e) => e.description(),\n-            &Compiletime(ref e) => e.description(),\n+            &Runtime(ref e) => e,\n+            &Compiletime(ref e) => e,\n         }\n     }\n }\n@@ -274,7 +274,7 @@ fn get_const_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n     match get_const_expr_as_global(ccx, expr, ConstQualif::empty(), empty_substs, TrueConst::Yes) {\n         Err(Runtime(err)) => {\n-            ccx.tcx().sess.span_err(expr.span, &err.description());\n+            report_const_eval_err(ccx.tcx(), &err, expr.span, \"expression\").emit();\n             Err(Compiletime(err))\n         },\n         other => other,\n@@ -526,12 +526,15 @@ pub fn const_err<T>(cx: &CrateContext,\n         (Ok(x), _) => Ok(x),\n         (Err(err), TrueConst::Yes) => {\n             let err = ConstEvalErr{ span: span, kind: err };\n-            cx.tcx().sess.span_err(span, &err.description());\n+            report_const_eval_err(cx.tcx(), &err, span, \"expression\").emit();\n             Err(Compiletime(err))\n         },\n         (Err(err), TrueConst::No) => {\n             let err = ConstEvalErr{ span: span, kind: err };\n-            cx.tcx().sess.span_warn(span, &err.description());\n+            let mut diag = cx.tcx().sess.struct_span_warn(\n+                span, \"this expression will panic at run-time\");\n+            note_const_eval_err(cx.tcx(), &err, span, \"expression\", &mut diag);\n+            diag.emit();\n             Err(Runtime(err))\n         },\n     }\n@@ -875,7 +878,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir::ExprRepeat(ref elem, ref count) => {\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = eval_repeat_count(cx.tcx(), count);\n+            let n = eval_length(cx.tcx(), count, \"repeat count\").unwrap();\n             let unit_val = const_expr(cx, &elem, param_substs, fn_args, trueconst)?.0;\n             let vs = vec![unit_val; n];\n             if val_ty(unit_val) != llunitty {"}, {"sha": "e657a086581e2dadfff30deedc5c7a07288b6861", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -44,6 +44,7 @@ use syntax::ptr::P;\n use syntax::parse::token;\n \n use rustc::session::Session;\n+use rustc_const_eval::fatal_const_eval_err;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::cmp::Ordering;\n@@ -1414,7 +1415,10 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n                                          // this should probably help simd error reporting\n                                          consts::TrueConst::Yes) {\n                     Ok((vector, _)) => vector,\n-                    Err(err) => bcx.sess().span_fatal(span, &err.description()),\n+                    Err(err) => {\n+                        fatal_const_eval_err(bcx.tcx(), err.as_inner(), span,\n+                                             \"shuffle indices\");\n+                    }\n                 }\n             }\n             None => llargs[2]"}, {"sha": "1f3b13203163f7fbf6cbab2ea681e6fea84572f7", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -925,7 +925,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n             Err(ConstEvalFailure::Runtime(err)) => {\n                 span_bug!(constant.span,\n-                          \"MIR constant {:?} results in runtime panic: {}\",\n+                          \"MIR constant {:?} results in runtime panic: {:?}\",\n                           constant, err.description())\n             }\n         }"}, {"sha": "fc95d208f32ccdda8c926e2be3a03e1a6c11eb95", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -29,6 +29,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst;\n use rustc::dep_graph::DepNode;\n+use rustc_const_eval::fatal_const_eval_err;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n use syntax::{attr,errors};\n@@ -81,7 +82,11 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                 if let hir::ItemStatic(_, m, ref expr) = item.node {\n                     match consts::trans_static(&ccx, m, expr, item.id, &item.attrs) {\n                         Ok(_) => { /* Cool, everything's alright. */ },\n-                        Err(err) => ccx.tcx().sess.span_fatal(expr.span, &err.description()),\n+                        Err(err) => {\n+                            // FIXME: shouldn't this be a `span_err`?\n+                            fatal_const_eval_err(\n+                                ccx.tcx(), &err, expr.span, \"static\");\n+                        }\n                     };\n                 } else {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")"}, {"sha": "92a2d3787bfd6b60bc5184233f24893e10e91ab3", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -30,7 +30,7 @@ use value::Value;\n use rustc::ty::{self, Ty};\n \n use rustc::hir;\n-use rustc_const_eval::eval_repeat_count;\n+use rustc_const_eval::eval_length;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -218,7 +218,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     return expr::trans_into(bcx, &element, Ignore);\n                 }\n                 SaveIn(lldest) => {\n-                    match eval_repeat_count(bcx.tcx(), &count_expr) {\n+                    match eval_length(bcx.tcx(), &count_expr, \"repeat count\").unwrap() {\n                         0 => expr::trans_into(bcx, &element, Ignore),\n                         1 => expr::trans_into(bcx, &element, SaveIn(lldest)),\n                         count => {\n@@ -268,7 +268,7 @@ fn elements_required(bcx: Block, content_expr: &hir::Expr) -> usize {\n         },\n         hir::ExprVec(ref es) => es.len(),\n         hir::ExprRepeat(_, ref count_expr) => {\n-            eval_repeat_count(bcx.tcx(), &count_expr)\n+            eval_length(bcx.tcx(), &count_expr, \"repeat count\").unwrap()\n         }\n         _ => span_bug!(content_expr.span, \"unexpected vec content\")\n     }"}, {"sha": "b642a7122194de3059babc25f116b8725dbd31a1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -48,10 +48,7 @@\n //! case but `&a` in the second.  Basically, defaults that appear inside\n //! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \n-use middle::const_val::ConstVal;\n-use rustc_const_eval::{eval_const_expr_partial, ConstEvalErr};\n-use rustc_const_eval::EvalHint::UncheckedExprHint;\n-use rustc_const_eval::ErrKind::ErroneousReferencedConstant;\n+use rustc_const_eval::eval_length;\n use hir::{self, SelfKind};\n use hir::def::{Def, PathResolution};\n use hir::def_id::DefId;\n@@ -70,7 +67,6 @@ use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::{NodeMap, FnvHashSet};\n \n-use rustc_const_math::ConstInt;\n use std::cell::RefCell;\n use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n@@ -1741,33 +1737,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 ty\n             }\n             hir::TyFixedLengthVec(ref ty, ref e) => {\n-                let hint = UncheckedExprHint(tcx.types.usize);\n-                match eval_const_expr_partial(tcx.global_tcx(), &e, hint, None) {\n-                    Ok(ConstVal::Integral(ConstInt::Usize(i))) => {\n-                        let i = i.as_u64(tcx.sess.target.uint_type);\n-                        assert_eq!(i as usize as u64, i);\n-                        tcx.mk_array(self.ast_ty_to_ty(rscope, &ty), i as usize)\n-                    },\n-                    Ok(val) => {\n-                        span_err!(tcx.sess, ast_ty.span, E0249,\n-                                  \"expected usize value for array length, got {}\",\n-                                  val.description());\n-                        self.tcx().types.err\n-                    },\n-                    // array length errors happen before the global constant check\n-                    // so we need to report the real error\n-                    Err(ConstEvalErr { kind: ErroneousReferencedConstant(box r), ..}) |\n-                    Err(r) => {\n-                        let mut err = struct_span_err!(tcx.sess, r.span, E0250,\n-                                                       \"array length constant \\\n-                                                        evaluation error: {}\",\n-                                                       r.description());\n-                        if !ast_ty.span.contains(r.span) {\n-                            span_note!(&mut err, ast_ty.span, \"for array length here\")\n-                        }\n-                        err.emit();\n-                        self.tcx().types.err\n-                    }\n+                if let Ok(length) = eval_length(tcx.global_tcx(), &e, \"array length\") {\n+                    tcx.mk_array(self.ast_ty_to_ty(rscope, &ty), length)\n+                } else {\n+                    self.tcx().types.err\n                 }\n             }\n             hir::TyTypeof(ref _e) => {"}, {"sha": "aae6e3ad36dfe7ee2ba7b1ec173cd2d3f8193a82", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -103,15 +103,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     return;\n                 }\n \n-                // Check that the types of the end-points can be unified.\n-                let types_unify = self.require_same_types(pat.span, rhs_ty, lhs_ty,\n-                                                          \"mismatched types in range\");\n-\n-                // It's ok to return without a message as `require_same_types` prints an error.\n-                if !types_unify {\n-                    return;\n-                }\n-\n                 // Now that we know the types can be unified we find the unified type and use\n                 // it to type the entire expression.\n                 let common_type = self.resolve_type_vars_if_possible(&lhs_ty);\n@@ -120,6 +111,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // subtyping doesn't matter here, as the value is some kind of scalar\n                 self.demand_eqtype(pat.span, expected, lhs_ty);\n+                self.demand_eqtype(pat.span, expected, rhs_ty);\n             }\n             PatKind::Binding(bm, _, ref sub) => {\n                 let typ = self.local_ty(pat.span, pat.id);"}, {"sha": "9c6727ebbfcf955d30f6507ef5b1719b3b5314d5", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => {\n                 let mut err = self.type_error_struct(call_expr.span, |actual| {\n                     format!(\"expected function, found `{}`\", actual)\n-                }, callee_ty, None);\n+                }, callee_ty);\n \n                 if let hir::ExprCall(ref expr, _) = call_expr.node {\n                     let tcx = self.tcx;"}, {"sha": "7a4cc09a7d5064d3a9ac408103df64cdf885dca3", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None)\n+                }, self.expr_ty)\n                     .help(&format!(\"cast through {} first\", match e {\n                             CastError::NeedViaPtr => \"a raw pointer\",\n                             CastError::NeedViaThinPtr => \"a thin pointer\",\n@@ -167,35 +167,35 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             CastError::CastToChar => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n-                }, self.expr_ty, None);\n+                }, self.expr_ty);\n             }\n             CastError::NonScalar => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"non-scalar cast: `{}` as `{}`\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None);\n+                }, self.expr_ty);\n             }\n             CastError::IllegalCast => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None);\n+                }, self.expr_ty);\n             }\n             CastError::SizedUnsizedCast => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"cannot cast thin pointer `{}` to fat pointer `{}`\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None)\n+                }, self.expr_ty)\n             }\n             CastError::DifferingKinds => {\n                 fcx.type_error_struct(self.span, |actual| {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None)\n+                }, self.expr_ty)\n                     .note(\"vtable kinds may not match\")\n                     .emit();\n             }\n@@ -213,7 +213,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         let tstr = fcx.ty_to_string(self.cast_ty);\n         let mut err = fcx.type_error_struct(self.span, |actual| {\n             format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n-        }, self.expr_ty, None);\n+        }, self.expr_ty);\n         match self.expr_ty.sty {\n             ty::TyRef(_, ty::TypeAndMut { mutbl: mt, .. }) => {\n                 let mtstr = match mt {\n@@ -484,4 +484,3 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundSized, span)\n     }\n }\n-"}, {"sha": "9844377d0bd32f5241c1e0cb948f48597c1d5673", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -12,6 +12,7 @@ use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty;\n use rustc::traits::{self, ProjectionMode};\n+use rustc::ty::error::ExpectedFound;\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace};\n \n use syntax::ast;\n@@ -324,10 +325,19 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\",\n                    impl_fty,\n                    trait_fty);\n-            span_err!(tcx.sess, impl_m_span, E0053,\n-                      \"method `{}` has an incompatible type for trait: {}\",\n-                      trait_m.name,\n-                      terr);\n+\n+            let mut diag = struct_span_err!(\n+                tcx.sess, origin.span(), E0053,\n+                \"method `{}` has an incompatible type for trait\", trait_m.name\n+            );\n+            infcx.note_type_err(\n+                &mut diag, origin,\n+                Some(infer::ValuePairs::Types(ExpectedFound {\n+                    expected: trait_fty,\n+                    found: impl_fty\n+                })), &terr\n+            );\n+            diag.emit();\n             return\n         }\n \n@@ -437,10 +447,9 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // Compute skolemized form of impl and trait const tys.\n         let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n         let trait_ty = trait_c.ty.subst(tcx, &trait_to_skol_substs);\n+        let origin = TypeOrigin::Misc(impl_c_span);\n \n         let err = infcx.commit_if_ok(|_| {\n-            let origin = TypeOrigin::Misc(impl_c_span);\n-\n             // There is no \"body\" here, so just pass dummy id.\n             let impl_ty =\n                 assoc::normalize_associated_types_in(&infcx,\n@@ -473,11 +482,19 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             debug!(\"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n                    impl_ty,\n                    trait_ty);\n-            span_err!(tcx.sess, impl_c_span, E0326,\n-                      \"implemented const `{}` has an incompatible type for \\\n-                      trait: {}\",\n-                      trait_c.name,\n-                      terr);\n+            let mut diag = struct_span_err!(\n+                tcx.sess, origin.span(), E0326,\n+                \"implemented const `{}` has an incompatible type for trait\",\n+                trait_c.name\n+            );\n+            infcx.note_type_err(\n+                &mut diag, origin,\n+                Some(infer::ValuePairs::Types(ExpectedFound {\n+                    expected: trait_ty,\n+                    found: impl_ty\n+                })), &terr\n+            );\n+            diag.emit();\n         }\n     });\n }"}, {"sha": "1f3a83ebc1d567da7a2ae7174213e62feaafd451", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -33,7 +33,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn demand_eqtype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-        let origin = TypeOrigin::Misc(sp);\n+        self.demand_eqtype_with_origin(TypeOrigin::Misc(sp), expected, actual);\n+    }\n+\n+    pub fn demand_eqtype_with_origin(&self,\n+                                     origin: TypeOrigin,\n+                                     expected: Ty<'tcx>,\n+                                     actual: Ty<'tcx>)\n+    {\n         match self.eq_types(false, origin, actual, expected) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n@@ -54,16 +61,4 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.report_mismatched_types(origin, expected, expr_ty, e);\n         }\n     }\n-\n-    pub fn require_same_types(&self, span: Span, t1: Ty<'tcx>, t2: Ty<'tcx>, msg: &str)\n-                              -> bool {\n-        if let Err(err) = self.eq_types(false, TypeOrigin::Misc(span), t1, t2) {\n-            let found_ty = self.resolve_type_vars_if_possible(&t1);\n-            let expected_ty = self.resolve_type_vars_if_possible(&t2);\n-            ::emit_type_err(self.tcx, span, found_ty, expected_ty, &err, msg);\n-            false\n-        } else {\n-            true\n-        }\n-    }\n }"}, {"sha": "8a53c59b4c7fad08dafbe1215cb6d8bf52914885", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -12,6 +12,7 @@\n //! intrinsics that the compiler exposes.\n \n use intrinsics;\n+use rustc::infer::TypeOrigin;\n use rustc::ty::subst::{self, Substs};\n use rustc::ty::FnSig;\n use rustc::ty::{self, Ty};\n@@ -56,10 +57,9 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n              i_n_tps, n_tps);\n     } else {\n         require_same_types(ccx,\n-                           it.span,\n+                           TypeOrigin::IntrinsicType(it.span),\n                            i_ty.ty,\n-                           fty,\n-                           \"intrinsic has wrong type\");\n+                           fty);\n     }\n }\n "}, {"sha": "346449d0a51331465bde2b99b5eec3048bb74e7c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -160,8 +160,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 item_name,\n                                 actual)\n                     },\n-                    rcvr_ty,\n-                    None);\n+                    rcvr_ty);\n \n                 // If the item has the name of a field, give a help note\n                 if let (&ty::TyStruct(def, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {"}, {"sha": "6062bd048b3d27f8972edfbdce5efa766c448aab", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -126,7 +126,7 @@ use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n use rustc_back::slice;\n-use rustc_const_eval::eval_repeat_count;\n+use rustc_const_eval::eval_length;\n \n mod assoc;\n mod autoderef;\n@@ -2541,21 +2541,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.type_error_message(arg.span, |t| {\n                             format!(\"can't pass an `{}` to variadic \\\n                                      function, cast to `c_double`\", t)\n-                        }, arg_ty, None);\n+                        }, arg_ty);\n                     }\n                     ty::TyInt(ast::IntTy::I8) | ty::TyInt(ast::IntTy::I16) | ty::TyBool => {\n                         self.type_error_message(arg.span, |t| {\n                             format!(\"can't pass `{}` to variadic \\\n                                      function, cast to `c_int`\",\n                                            t)\n-                        }, arg_ty, None);\n+                        }, arg_ty);\n                     }\n                     ty::TyUint(ast::UintTy::U8) | ty::TyUint(ast::UintTy::U16) => {\n                         self.type_error_message(arg.span, |t| {\n                             format!(\"can't pass `{}` to variadic \\\n                                      function, cast to `c_uint`\",\n                                            t)\n-                        }, arg_ty, None);\n+                        }, arg_ty);\n                     }\n                     ty::TyFnDef(_, _, f) => {\n                         let ptr_ty = self.tcx.mk_fn_ptr(f);\n@@ -2564,7 +2564,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                 |t| {\n                             format!(\"can't pass `{}` to variadic \\\n                                      function, cast to `{}`\", t, ptr_ty)\n-                        }, arg_ty, None);\n+                        }, arg_ty);\n                     }\n                     _ => {}\n                 }\n@@ -2908,9 +2908,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.type_error_struct(field.span, |actual| {\n                 format!(\"attempted to take value of method `{}` on type \\\n                          `{}`\", field.node, actual)\n-            }, expr_t, None)\n-                .help(\n-                       \"maybe a `()` to call it is missing? \\\n+            }, expr_t)\n+                .help(\"maybe a `()` to call it is missing? \\\n                        If not, try an anonymous function\")\n                 .emit();\n             self.write_error(expr.id);\n@@ -2919,7 +2918,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"attempted access of field `{}` on type `{}`, \\\n                          but no field with that name was found\",\n                         field.node, actual)\n-            }, expr_t, None);\n+            }, expr_t);\n             if let ty::TyStruct(def, _) = expr_t.sty {\n                 Self::suggest_field_names(&mut err, def.struct_variant(), field, vec![]);\n             }\n@@ -3019,7 +3018,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     actual)\n                 }\n             },\n-            expr_t, None);\n+            expr_t);\n \n         self.write_error(expr.id);\n     }\n@@ -3029,17 +3028,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             variant: ty::VariantDef<'tcx>,\n                             field: &hir::Field,\n                             skip_fields: &[hir::Field]) {\n-        let mut err = self.type_error_struct(\n+        let mut err = self.type_error_struct_with_diag(\n             field.name.span,\n             |actual| if let ty::TyEnum(..) = ty.sty {\n-                format!(\"struct variant `{}::{}` has no field named `{}`\",\n-                        actual, variant.name.as_str(), field.name.node)\n+                struct_span_err!(self.tcx.sess, field.name.span, E0559,\n+                                 \"struct variant `{}::{}` has no field named `{}`\",\n+                                 actual, variant.name.as_str(), field.name.node)\n             } else {\n-                format!(\"structure `{}` has no field named `{}`\",\n-                        actual, field.name.node)\n+                struct_span_err!(self.tcx.sess, field.name.span, E0560,\n+                                 \"structure `{}` has no field named `{}`\",\n+                                 actual, field.name.node)\n             },\n-            ty,\n-            None);\n+            ty);\n         // prevent all specified fields from being suggested\n         let skip_fields = skip_fields.iter().map(|ref x| x.name.node.as_str());\n         Self::suggest_field_names(&mut err, variant, &field.name, skip_fields.collect());\n@@ -3272,7 +3272,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             self.type_error_message(expr.span, |actual| {\n                                 format!(\"type `{}` cannot be \\\n                                         dereferenced\", actual)\n-                            }, oprnd_t, None);\n+                            }, oprnd_t);\n                             oprnd_t = tcx.types.err;\n                         }\n                     }\n@@ -3541,7 +3541,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           }\n           hir::ExprRepeat(ref element, ref count_expr) => {\n             self.check_expr_has_type(&count_expr, tcx.types.usize);\n-            let count = eval_repeat_count(self.tcx.global_tcx(), &count_expr);\n+            let count = eval_length(self.tcx.global_tcx(), &count_expr, \"repeat count\")\n+                  .unwrap_or(0);\n \n             let uty = match expected {\n                 ExpectHasType(uty) => {\n@@ -3647,8 +3648,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   format!(\"cannot index a value of type `{}`\",\n                                           actual)\n                               },\n-                              base_t,\n-                              None);\n+                              base_t);\n                           // Try to give some advice about indexing tuples.\n                           if let ty::TyTuple(_) = base_t.sty {\n                               let mut needs_note = true;\n@@ -4523,7 +4523,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if !self.is_tainted_by_errors() {\n                     self.type_error_message(sp, |_actual| {\n                         \"the type of this value must be known in this context\".to_string()\n-                    }, ty, None);\n+                    }, ty);\n                 }\n                 self.demand_suptype(sp, self.tcx.types.err, ty);\n                 ty = self.tcx.types.err;"}, {"sha": "d02f87d0b9cd64236700279cd10bfc1744f0c7af", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.type_error_message(ex.span, |actual| {\n                     format!(\"cannot apply unary operator `{}` to type `{}`\",\n                             op_str, actual)\n-                }, operand_ty, None);\n+                }, operand_ty);\n                 self.tcx.types.err\n             }\n         }"}, {"sha": "907cb734c2ff9f00128641761e20eb9543b323fe", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -13,6 +13,7 @@ use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n use hir::def_id::DefId;\n use middle::region::{CodeExtent};\n+use rustc::infer::TypeOrigin;\n use rustc::ty::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -157,7 +158,10 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         }\n     }\n \n-    fn check_trait_or_impl_item(&mut self, item_id: ast::NodeId, span: Span) {\n+    fn check_trait_or_impl_item(&mut self,\n+                                item_id: ast::NodeId,\n+                                span: Span,\n+                                sig_if_method: Option<&hir::MethodSig>) {\n         let code = self.code.clone();\n         self.for_id(item_id, span).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n@@ -182,7 +186,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                     let predicates = fcx.instantiate_bounds(span, free_substs, &method.predicates);\n                     this.check_fn_or_method(fcx, span, &method_ty, &predicates,\n                                             free_id_outlive, &mut implied_bounds);\n-                    this.check_method_receiver(fcx, span, &method,\n+                    let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n+                    this.check_method_receiver(fcx, sig_if_method, &method,\n                                                free_id_outlive, self_ty);\n                 }\n                 ty::TypeTraitItem(assoc_type) => {\n@@ -405,20 +410,15 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n     fn check_method_receiver<'fcx, 'tcx>(&mut self,\n                                          fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                         span: Span,\n+                                         method_sig: &hir::MethodSig,\n                                          method: &ty::Method<'tcx>,\n                                          free_id_outlive: CodeExtent,\n                                          self_ty: ty::Ty<'tcx>)\n     {\n         // check that the type of the method's receiver matches the\n         // method's first parameter.\n-\n-        let free_substs = &fcx.parameter_environment.free_substs;\n-        let fty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n-        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.sig);\n-\n-        debug!(\"check_method_receiver({:?},cat={:?},self_ty={:?},sig={:?})\",\n-               method.name, method.explicit_self, self_ty, sig);\n+        debug!(\"check_method_receiver({:?},cat={:?},self_ty={:?})\",\n+               method.name, method.explicit_self, self_ty);\n \n         let rcvr_ty = match method.explicit_self {\n             ty::ExplicitSelfCategory::Static => return,\n@@ -431,14 +431,23 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             }\n             ty::ExplicitSelfCategory::ByBox => fcx.tcx.mk_box(self_ty)\n         };\n+\n+        let span = method_sig.decl.inputs[0].pat.span;\n+\n+        let free_substs = &fcx.parameter_environment.free_substs;\n+        let fty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n+        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.sig);\n+\n+        debug!(\"check_method_receiver: sig={:?}\", sig);\n+\n         let rcvr_ty = fcx.instantiate_type_scheme(span, free_substs, &rcvr_ty);\n         let rcvr_ty = fcx.tcx.liberate_late_bound_regions(free_id_outlive,\n                                                           &ty::Binder(rcvr_ty));\n \n         debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);\n \n-        fcx.require_same_types(span, sig.inputs[0], rcvr_ty,\n-                               \"mismatched method receiver\");\n+        let origin = TypeOrigin::MethodReceiver(span);\n+        fcx.demand_eqtype_with_origin(origin, rcvr_ty, sig.inputs[0]);\n     }\n \n     fn check_variances_for_type_defn(&self,\n@@ -553,13 +562,21 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'v hir::TraitItem) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n-        self.check_trait_or_impl_item(trait_item.id, trait_item.span);\n+        let method_sig = match trait_item.node {\n+            hir::TraitItem_::MethodTraitItem(ref sig, _) => Some(sig),\n+            _ => None\n+        };\n+        self.check_trait_or_impl_item(trait_item.id, trait_item.span, method_sig);\n         intravisit::walk_trait_item(self, trait_item)\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'v hir::ImplItem) {\n         debug!(\"visit_impl_item: {:?}\", impl_item);\n-        self.check_trait_or_impl_item(impl_item.id, impl_item.span);\n+        let method_sig = match impl_item.node {\n+            hir::ImplItemKind::Method(ref sig, _) => Some(sig),\n+            _ => None\n+        };\n+        self.check_trait_or_impl_item(impl_item.id, impl_item.span, method_sig);\n         intravisit::walk_impl_item(self, impl_item)\n     }\n }"}, {"sha": "57602b55cc96f10e5bb4110692cd481c361bdf95", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -66,8 +66,7 @@ use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n-use rustc_const_eval::{eval_const_expr_partial, ConstEvalErr};\n-use rustc_const_eval::ErrKind::ErroneousReferencedConstant;\n+use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n use rustc::ty::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n use rustc::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n@@ -1091,14 +1090,9 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             },\n             // enum variant evaluation happens before the global constant check\n             // so we need to report the real error\n-            Err(ConstEvalErr { kind: ErroneousReferencedConstant(box err), ..}) |\n             Err(err) => {\n-                let mut diag = struct_span_err!(ccx.tcx.sess, err.span, E0080,\n-                                                \"constant evaluation error: {}\",\n-                                                err.description());\n-                if !e.span.contains(err.span) {\n-                    diag.span_note(e.span, \"for enum discriminant here\");\n-                }\n+                let mut diag = report_const_eval_err(\n+                    ccx.tcx, &err, e.span, \"enum discriminant\");\n                 diag.emit();\n                 None\n             }"}, {"sha": "500f624ea3f72f870eece3b65108997dfc74f6f7", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 54, "deletions": 51, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -1079,25 +1079,6 @@ impl Foo {\n ```\n \"##,\n \n-E0080: r##\"\n-This error indicates that the compiler was unable to sensibly evaluate an\n-integer expression provided as an enum discriminant. Attempting to divide by 0\n-or causing integer overflow are two ways to induce this error. For example:\n-\n-```compile_fail\n-enum Enum {\n-    X = (1 << 500),\n-    Y = (1 / 0)\n-}\n-```\n-\n-Ensure that the expressions given can be evaluated as the desired integer type.\n-See the FFI section of the Reference for more information about using a custom\n-integer type:\n-\n-https://doc.rust-lang.org/reference.html#ffi-attributes\n-\"##,\n-\n E0081: r##\"\n Enum discriminants are used to differentiate enum variants stored in memory.\n This error indicates that the same value was used for two or more variants,\n@@ -2660,6 +2641,7 @@ For information on the design of the orphan rules, see [RFC 1023].\n [RFC 1023]: https://github.com/rust-lang/rfcs/pull/1023\n \"##,\n \n+/*\n E0211: r##\"\n You used a function or type which doesn't fit the requirements for where it was\n used. Erroneous code examples:\n@@ -2739,6 +2721,7 @@ impl Foo {\n }\n ```\n \"##,\n+     */\n \n E0214: r##\"\n A generic type was described using parentheses rather than angle brackets. For\n@@ -2968,38 +2951,6 @@ not a distinct static type. Likewise, it's not legal to attempt to\n behavior for specific enum variants.\n \"##,\n \n-E0249: r##\"\n-This error indicates a constant expression for the array length was found, but\n-it was not an integer (signed or unsigned) expression.\n-\n-Some examples of code that produces this error are:\n-\n-```compile_fail\n-const A: [u32; \"hello\"] = []; // error\n-const B: [u32; true] = []; // error\n-const C: [u32; 0.0] = []; // error\n-\"##,\n-\n-E0250: r##\"\n-There was an error while evaluating the expression for the length of a fixed-\n-size array type.\n-\n-Some examples of this error are:\n-\n-```compile_fail\n-// divide by zero in the length expression\n-const A: [u32; 1/0] = [];\n-\n-// Rust currently will not evaluate the function `foo` at compile time\n-fn foo() -> usize { 12 }\n-const B: [u32; foo()] = [];\n-\n-// it is an error to try to add `u8` and `f64`\n-use std::{f64, u8};\n-const C: [u32; u8::MAX + f64::EPSILON] = [];\n-```\n-\"##,\n-\n E0318: r##\"\n Default impls for a trait must be located in the same crate where the trait was\n defined. For more information see the [opt-in builtin traits RFC](https://github\n@@ -4029,6 +3980,57 @@ impl SpaceLlama for i32 {\n ```\n \"##,\n \n+E0559: r##\"\n+An unknown field was specified into an enum's structure variant.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0559\n+enum Field {\n+    Fool { x: u32 },\n+}\n+\n+let s = Field::Fool { joke: 0 };\n+// error: struct variant `Field::Fool` has no field named `joke`\n+```\n+\n+Verify you didn't misspell the field's name or that the field exists. Example:\n+\n+```\n+enum Field {\n+    Fool { joke: u32 },\n+}\n+\n+let s = Field::Fool { joke: 0 }; // ok!\n+```\n+\"##,\n+\n+E0560: r##\"\n+An unknown field was specified into a structure.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0560\n+struct Simba {\n+    mother: u32,\n+}\n+\n+let s = Simba { mother: 1, father: 0 };\n+// error: structure `Simba` has no field named `father`\n+```\n+\n+Verify you didn't misspell the field's name or that the field exists. Example:\n+\n+```\n+struct Simba {\n+    mother: u32,\n+    father: u32,\n+}\n+\n+let s = Simba { mother: 1, father: 0 }; // ok!\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {\n@@ -4086,6 +4088,7 @@ register_diagnostics! {\n     E0245, // not a trait\n //  E0246, // invalid recursive type\n //  E0247,\n+//  E0249,\n //  E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n     E0328, // cannot implement Unsize explicitly"}, {"sha": "3b2d02dc861c4c62c0b8542f0b3f0da67eddbef8", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -186,28 +186,14 @@ fn require_c_abi_if_variadic(tcx: TyCtxt,\n     }\n }\n \n-pub fn emit_type_err<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                     span: Span,\n-                                     found_ty: Ty<'tcx>,\n-                                     expected_ty: Ty<'tcx>,\n-                                     terr: &ty::error::TypeError<'tcx>,\n-                                     msg: &str) {\n-    let mut err = struct_span_err!(tcx.sess, span, E0211, \"{}\", msg);\n-    err.span_label(span, &terr);\n-    err.note_expected_found(&\"type\", &expected_ty, &found_ty);\n-    tcx.note_and_explain_type_err(&mut err, terr, span);\n-    err.emit();\n-}\n-\n fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                span: Span,\n+                                origin: TypeOrigin,\n                                 t1: Ty<'tcx>,\n-                                t2: Ty<'tcx>,\n-                                msg: &str)\n+                                t2: Ty<'tcx>)\n                                 -> bool {\n     ccx.tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n-        if let Err(err) = infcx.eq_types(false, TypeOrigin::Misc(span), t1, t2) {\n-            emit_type_err(infcx.tcx, span, t1, t2, &err, msg);\n+        if let Err(err) = infcx.eq_types(false, origin.clone(), t1, t2) {\n+            infcx.report_mismatched_types(origin, t1, t2, err);\n             false\n         } else {\n             true\n@@ -249,8 +235,11 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 })\n             }));\n \n-            require_same_types(ccx, main_span, main_t, se_ty,\n-                               \"main function has wrong type\");\n+            require_same_types(\n+                ccx,\n+                TypeOrigin::MainFunctionType(main_span),\n+                main_t,\n+                se_ty);\n         }\n         _ => {\n             span_bug!(main_span,\n@@ -298,8 +287,11 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 }),\n             }));\n \n-            require_same_types(ccx, start_span, start_t, se_ty,\n-                               \"start function has wrong type\");\n+            require_same_types(\n+                ccx,\n+                TypeOrigin::StartFunctionType(start_span),\n+                start_t,\n+                se_ty);\n         }\n         _ => {\n             span_bug!(start_span,"}, {"sha": "0b2287cf233d15becbf9d5da283d62194d473483", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -105,6 +105,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\","}, {"sha": "501c66e75cded115892fddfe02c0be9588b0c9c0", "filename": "src/test/compile-fail/array_const_index-0.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -10,7 +10,8 @@\n \n const A: &'static [i32] = &[];\n const B: i32 = (&A)[1];\n-//~^ ERROR index out of bounds: the len is 0 but the index is 1\n+//~^ ERROR constant evaluation error\n+//~| index out of bounds: the len is 0 but the index is 1\n \n fn main() {\n     let _ = B;"}, {"sha": "d3b43e83bfe5218ac914584e6424f6fd4ee4a9d4", "filename": "src/test/compile-fail/array_const_index-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -10,7 +10,8 @@\n \n const A: [i32; 0] = [];\n const B: i32 = A[1];\n-//~^ ERROR index out of bounds: the len is 0 but the index is 1\n+//~^ ERROR constant evaluation error\n+//~| index out of bounds: the len is 0 but the index is 1\n \n fn main() {\n     let _ = B;"}, {"sha": "0239986f5ad3aef5dfe5886ed2f142bc93c902e1", "filename": "src/test/compile-fail/associated-const-array-len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -14,7 +14,7 @@ trait Foo {\n     const ID: usize;\n }\n \n-const X: [i32; <i32 as Foo>::ID] = [0, 1, 2]; //~ ERROR E0250\n+const X: [i32; <i32 as Foo>::ID] = [0, 1, 2]; //~ ERROR E0080\n \n fn main() {\n     assert_eq!(1, X);"}, {"sha": "95508a31044b87797dff021bc5a6a07b23cd2ff9", "filename": "src/test/compile-fail/associated-const-impl-wrong-type.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fassociated-const-impl-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fassociated-const-impl-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-impl-wrong-type.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -18,9 +18,8 @@ struct SignedBar;\n \n impl Foo for SignedBar {\n     const BAR: i32 = -1;\n-    //~^ ERROR implemented const `BAR` has an incompatible type for trait\n-    //~| expected u32,\n-    //~| found i32 [E0326]\n+    //~^ ERROR implemented const `BAR` has an incompatible type for trait [E0326]\n+    //~| expected u32, found i32\n }\n \n fn main() {}"}, {"sha": "c3fa39659b968217fb83481c75edea49d0855a37", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -25,7 +25,8 @@ impl Foo for Def {\n }\n \n pub fn test<A: Foo, B: Foo>() {\n-    let _array = [4; <A as Foo>::Y]; //~ error: expected constant integer\n+    let _array = [4; <A as Foo>::Y]; //~ ERROR E0080\n+                                     //~| non-constant path in constant\n }\n \n fn main() {"}, {"sha": "cb952f6534f0e57da26b0e45b6d91a14c64be083", "filename": "src/test/compile-fail/associated-types-eq-3.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -47,10 +47,8 @@ pub fn main() {\n     let a = 42;\n     foo1(a);\n     //~^ ERROR type mismatch resolving\n-    //~| expected usize\n-    //~| found struct `Bar`\n+    //~| expected usize, found struct `Bar`\n     baz(&a);\n     //~^ ERROR type mismatch resolving\n-    //~| expected usize\n-    //~| found struct `Bar`\n+    //~| expected usize, found struct `Bar`\n }"}, {"sha": "12341fa8db38f790c487a7ff0382b81be3e8abb7", "filename": "src/test/compile-fail/associated-types/higher-ranked-projection.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fhigher-ranked-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fhigher-ranked-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fhigher-ranked-projection.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+// revisions: good bad\n+\n+trait Mirror {\n+    type Image;\n+}\n+\n+impl<T> Mirror for T {\n+    type Image = T;\n+}\n+\n+#[cfg(bad)]\n+fn foo<U, T>(_t: T)\n+    where for<'a> &'a T: Mirror<Image=U>\n+{}\n+\n+#[cfg(good)]\n+fn foo<U, T>(_t: T)\n+    where for<'a> &'a T: Mirror<Image=&'a U>\n+{}\n+\n+#[rustc_error]\n+fn main() { //[good]~ ERROR compilation successful\n+    foo(());\n+    //[bad]~^ ERROR type mismatch resolving `for<'a> <&'a _ as Mirror>::Image == _`\n+    //[bad]~| expected bound lifetime parameter 'a, found concrete lifetime\n+}"}, {"sha": "b980bc02c85a24fb22a4d7cb0e161768a0b858fa", "filename": "src/test/compile-fail/const-array-oob.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -16,7 +16,8 @@ const FOO: [u32; 3] = [1, 2, 3];\n const BAR: u32 = FOO[5]; // no error, because the error below occurs before regular const eval\n \n const BLUB: [u32; FOO[4]] = [5, 6];\n-//~^ ERROR array length constant evaluation error: index out of bounds: the len is 3 but the index is 4 [E0250]\n+//~^ ERROR constant evaluation error [E0080]\n+//~| index out of bounds: the len is 3 but the index is 4\n \n fn main() {\n     let _ = BAR;"}, {"sha": "7e2eabf412d6c2683646b19a0bdb27c4e65c4a21", "filename": "src/test/compile-fail/const-call.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-call.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -15,5 +15,6 @@ fn f(x: usize) -> usize {\n }\n \n fn main() {\n-    let _ = [0; f(2)]; //~ ERROR: non-constant path in constant expression [E0307]\n+    let _ = [0; f(2)]; //~ ERROR constant evaluation error [E0080]\n+                       //~| non-constant path in constant expression\n }"}, {"sha": "f2079800cad311e624ee9ca644603877889353d1", "filename": "src/test/compile-fail/const-err.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -22,21 +22,29 @@ fn black_box<T>(_: T) {\n \n // Make sure that the two uses get two errors.\n const FOO: u8 = [5u8][1];\n-//~^ ERROR index out of bounds: the len is 1 but the index is 1\n-//~^^ ERROR index out of bounds: the len is 1 but the index is 1\n+//~^ ERROR constant evaluation error\n+//~| index out of bounds: the len is 1 but the index is 1\n+//~^^^ ERROR constant evaluation error\n+//~| index out of bounds: the len is 1 but the index is 1\n \n fn main() {\n     let a = -std::i8::MIN;\n-    //~^ WARN attempted to negate with overflow\n+    //~^ WARN this expression will panic at run-time\n+    //~| attempted to negate with overflow\n     let b = 200u8 + 200u8 + 200u8;\n-    //~^ WARN attempted to add with overflow\n-    //~| WARN attempted to add with overflow\n+    //~^ WARN this expression will panic at run-time\n+    //~| attempted to add with overflow\n+    //~^^^ WARN this expression will panic at run-time\n+    //~| attempted to add with overflow\n     let c = 200u8 * 4;\n-    //~^ WARN attempted to multiply with overflow\n+    //~^ WARN this expression will panic at run-time\n+    //~| attempted to multiply with overflow\n     let d = 42u8 - (42u8 + 1);\n-    //~^ WARN attempted to subtract with overflow\n+    //~^ WARN this expression will panic at run-time\n+    //~| attempted to subtract with overflow\n     let _e = [5u8][1];\n-    //~^ WARN index out of bounds: the len is 1 but the index is 1\n+    //~^ WARN this expression will panic at run-time\n+    //~| index out of bounds: the len is 1 but the index is 1\n     black_box(a);\n     black_box(b);\n     black_box(c);"}, {"sha": "4749457da8814ba89b294c624f1397770bb495ae", "filename": "src/test/compile-fail/const-eval-overflow-2.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -19,13 +19,16 @@ use std::{u8, u16, u32, u64, usize};\n \n const NEG_128: i8 = -128;\n const NEG_NEG_128: i8 = -NEG_128;\n-//~^ ERROR constant evaluation error: attempted to negate with overflow\n-//~| ERROR attempted to negate with overflow\n-//~| ERROR attempted to negate with overflow\n+//~^ ERROR constant evaluation error\n+//~| attempted to negate with overflow\n+//~| ERROR constant evaluation error\n+//~| attempted to negate with overflow\n+//~| ERROR constant evaluation error\n+//~| attempted to negate with overflow\n \n fn main() {\n     match -128i8 {\n-        NEG_NEG_128 => println!(\"A\"), //~ NOTE in pattern here\n+        NEG_NEG_128 => println!(\"A\"), //~ NOTE for pattern here\n         _ => println!(\"B\"),\n     }\n }"}, {"sha": "c78c74e9e231b5d8ccfdfbf1b2b250c6e1e4afba", "filename": "src/test/compile-fail/const-eval-overflow-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -17,7 +17,7 @@\n // self-hosted and a cross-compiled setup; therefore resorting to\n // error-pattern for now.\n \n-// error-pattern: expected constant integer for repeat count, but attempted to add with overflow\n+// error-pattern: attempted to add with overflow\n \n #![allow(unused_imports)]\n "}, {"sha": "9e7a5ecae105a2b123a51519f20a2944b26bfe6a", "filename": "src/test/compile-fail/const-eval-overflow-4b.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -20,9 +20,8 @@ use std::{u8, u16, u32, u64, usize};\n \n const A_I8_T\n     : [u32; (i8::MAX as i8 + 1u8) as usize]\n-    //~^ ERROR mismatched types:\n-    //~| expected `i8`,\n-    //~| found `u8` [E0250]\n+    //~^ ERROR constant evaluation error [E0080]\n+    //~| expected i8, found u8\n     = [0; (i8::MAX as usize) + 1];\n \n \n@@ -33,7 +32,8 @@ const A_CHAR_USIZE\n \n const A_BAD_CHAR_USIZE\n     : [u32; 5i8 as char as usize]\n-    //~^ ERROR only `u8` can be cast as `char`, not `i8`\n+    //~^ ERROR constant evaluation error\n+    //~| only `u8` can be cast as `char`, not `i8`\n     = [0; 5];\n \n fn main() {}"}, {"sha": "c1c693544fa96e7fd224ebdeceb01341a3894d2e", "filename": "src/test/compile-fail/const-eval-overflow.rs", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -21,86 +21,114 @@ use std::{u8, u16, u32, u64, usize};\n \n const VALS_I8: (i8, i8, i8, i8) =\n     (-i8::MIN,\n-     //~^ ERROR attempted to negate with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to negate with overflow\n      i8::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      i8::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      i8::MIN * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_I16: (i16, i16, i16, i16) =\n     (-i16::MIN,\n-     //~^ ERROR attempted to negate with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to negate with overflow\n      i16::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      i16::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      i16::MIN * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_I32: (i32, i32, i32, i32) =\n     (-i32::MIN,\n-     //~^ ERROR attempted to negate with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to negate with overflow\n      i32::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      i32::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      i32::MIN * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_I64: (i64, i64, i64, i64) =\n     (-i64::MIN,\n-     //~^ ERROR attempted to negate with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to negate with overflow\n      i64::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      i64::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      i64::MAX * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_U8: (u8, u8, u8, u8) =\n     (-(u8::MIN as i8) as u8,\n      u8::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      u8::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      u8::MAX * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_U16: (u16, u16, u16, u16) =\n     (-(u16::MIN as i16) as u16,\n      u16::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      u16::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      u16::MAX * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_U32: (u32, u32, u32, u32) =\n     (-(u32::MIN as i32) as u32,\n      u32::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      u32::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      u32::MAX * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_U64: (u64, u64, u64, u64) =\n     (-(u64::MIN as i64) as u64,\n      u64::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      u64::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      u64::MAX * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n fn main() {"}, {"sha": "73351429b50608b770bb11571880aa364e46d666", "filename": "src/test/compile-fail/const-eval-span.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -14,7 +14,8 @@\n struct S(i32);\n \n const CONSTANT: S = S(0);\n-//~^ ERROR: unimplemented constant expression: tuple struct constructors [E0080]\n+//~^ ERROR E0080\n+//~| unimplemented constant expression: tuple struct constructors\n \n enum E {\n     V = CONSTANT,"}, {"sha": "dd0f058f2c95c06909e2132d64902b6a1d5c7970", "filename": "src/test/compile-fail/const-fn-error.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -17,10 +17,11 @@ const fn f(x: usize) -> usize {\n     for i in 0..x {\n         sum += i;\n     }\n-    sum //~ ERROR: E0250\n+    sum //~ ERROR E0080\n+        //~| non-constant path in constant\n }\n \n #[allow(unused_variables)]\n fn main() {\n-    let a : [i32; f(X)];\n+    let a : [i32; f(X)]; //~ NOTE for array length here\n }"}, {"sha": "4f92770df289c50c57c43c58e163158ddea6fdc7", "filename": "src/test/compile-fail/const-index-feature-gate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-index-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-index-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-index-feature-gate.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n const ARR: [usize; 1] = [2];\n-const ARR2: [i32; ARR[0]] = [5, 6]; //~ ERROR unstable\n+const ARR2: [i32; ARR[0]] = [5, 6]; //~ ERROR E0080\n+                                    //~| unstable\n \n fn main() {\n }"}, {"sha": "5dadd892f83520cca532436ce88986e7b4649476", "filename": "src/test/compile-fail/const-integer-bool-ops.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -8,30 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const X: usize = 42 && 39; //~ ERROR: can't do this op on integrals\n+const X: usize = 42 && 39; //~ ERROR E0080\n+                           //~| can't do this op on integrals\n const ARR: [i32; X] = [99; 34]; //~ NOTE: for array length here\n \n-const X1: usize = 42 || 39; //~ ERROR: can't do this op on integrals\n+const X1: usize = 42 || 39; //~ ERROR E0080\n+                            //~| can't do this op on integrals\n const ARR1: [i32; X1] = [99; 47]; //~ NOTE: for array length here\n \n-const X2: usize = -42 || -39; //~ ERROR: unary negation of unsigned integer\n+const X2: usize = -42 || -39; //~ ERROR E0080\n+                              //~| unary negation of unsigned integer\n const ARR2: [i32; X2] = [99; 18446744073709551607]; //~ NOTE: for array length here\n \n-const X3: usize = -42 && -39; //~ ERROR: unary negation of unsigned integer\n+const X3: usize = -42 && -39; //~ ERROR E0080\n+                              //~| unary negation of unsigned integer\n const ARR3: [i32; X3] = [99; 6]; //~ NOTE: for array length here\n \n const Y: usize = 42.0 == 42.0;\n-const ARRR: [i32; Y] = [99; 1]; //~ ERROR: expected usize value for array length\n+const ARRR: [i32; Y] = [99; 1]; //~ ERROR: expected usize for array length\n const Y1: usize = 42.0 >= 42.0;\n-const ARRR1: [i32; Y] = [99; 1]; //~ ERROR: expected usize value for array length\n+const ARRR1: [i32; Y] = [99; 1]; //~ ERROR: expected usize for array length\n const Y2: usize = 42.0 <= 42.0;\n-const ARRR2: [i32; Y] = [99; 1]; //~ ERROR: expected usize value for array length\n+const ARRR2: [i32; Y] = [99; 1]; //~ ERROR: expected usize for array length\n const Y3: usize = 42.0 > 42.0;\n-const ARRR3: [i32; Y] = [99; 0]; //~ ERROR: expected usize value for array length\n+const ARRR3: [i32; Y] = [99; 0]; //~ ERROR: expected usize for array length\n const Y4: usize = 42.0 < 42.0;\n-const ARRR4: [i32; Y] = [99; 0]; //~ ERROR: expected usize value for array length\n+const ARRR4: [i32; Y] = [99; 0]; //~ ERROR: expected usize for array length\n const Y5: usize = 42.0 != 42.0;\n-const ARRR5: [i32; Y] = [99; 0]; //~ ERROR: expected usize value for array length\n+const ARRR5: [i32; Y] = [99; 0]; //~ ERROR: expected usize for array length\n \n fn main() {\n     let _ = ARR;"}, {"sha": "43375ee3d18968e83645b150088189cdfef4a9ea", "filename": "src/test/compile-fail/const-len-underflow-separate-spans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -15,7 +15,8 @@\n const ONE: usize = 1;\n const TWO: usize = 2;\n const LEN: usize = ONE - TWO;\n-//~^ ERROR array length constant evaluation error: attempted to subtract with overflow [E0250]\n+//~^ ERROR E0080\n+//~| attempted to subtract with overflow\n \n fn main() {\n     let a: [i8; LEN] = unimplemented!();"}, {"sha": "e338f206553b422110dc9086c5190878b02f91c5", "filename": "src/test/compile-fail/const-len-underflow-subspans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -16,5 +16,6 @@ const TWO: usize = 2;\n \n fn main() {\n     let a: [i8; ONE - TWO] = unimplemented!();\n-    //~^ ERROR array length constant evaluation error: attempted to subtract with overflow [E0250]\n+    //~^ ERROR constant evaluation error [E0080]\n+    //~| attempted to subtract with overflow\n }"}, {"sha": "d68d63683a79cc6b2db9beddf7f4ad236bb39ae0", "filename": "src/test/compile-fail/const-pattern-not-const-evaluable.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -17,22 +17,26 @@ enum Cake {\n use Cake::*;\n \n const BOO: (Cake, Cake) = (Marmor, BlackForest);\n-//~^ ERROR: constant evaluation error: unimplemented constant expression: enum variants [E0471]\n+//~^ ERROR: constant evaluation error [E0080]\n+//~| unimplemented constant expression: enum variants\n const FOO: Cake = BOO.1;\n \n const fn foo() -> Cake {\n-    Marmor //~ ERROR: constant evaluation error: unimplemented constant expression: enum variants\n-    //~^ ERROR: unimplemented constant expression: enum variants\n+    Marmor\n+        //~^ ERROR: constant evaluation error [E0080]\n+        //~| unimplemented constant expression: enum variants\n+        //~^^^ ERROR: constant evaluation error [E0080]\n+        //~| unimplemented constant expression: enum variants\n }\n \n const WORKS: Cake = Marmor;\n \n-const GOO: Cake = foo();\n+const GOO: Cake = foo(); //~ NOTE for expression here\n \n fn main() {\n     match BlackForest {\n-        FOO => println!(\"hi\"), //~ NOTE: in pattern here\n-        GOO => println!(\"meh\"), //~ NOTE: in pattern here\n+        FOO => println!(\"hi\"), //~ NOTE: for pattern here\n+        GOO => println!(\"meh\"), //~ NOTE: for pattern here\n         WORKS => println!(\"m\u00f6p\"),\n         _ => println!(\"bye\"),\n     }"}, {"sha": "b1b4bfe2d1c39a1e2a08a9e76117699d1e1d854c", "filename": "src/test/compile-fail/const-slice-oob.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -10,7 +10,8 @@\n \n const FOO: &'static[u32] = &[1, 2, 3];\n const BAR: u32 = FOO[5];\n-//~^ ERROR index out of bounds: the len is 3 but the index is 5\n+//~^ ERROR constant evaluation error [E0080]\n+//~| index out of bounds: the len is 3 but the index is 5\n \n fn main() {\n     let _ = BAR;"}, {"sha": "6f095b3041ffedc833eef1b3ecc985f809ca60d9", "filename": "src/test/compile-fail/const-tup-index-span.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -11,7 +11,8 @@\n // Test spans of errors\n \n const TUP: (usize,) = 5 << 64;\n-//~^ ERROR: attempted to shift left with overflow [E0250]\n+//~^ ERROR E0080\n+//~| attempted to shift left with overflow\n const ARR: [i32; TUP.0] = [];\n \n fn main() {"}, {"sha": "c73b7e831b3217051eb1eef9b64372af92abda81", "filename": "src/test/compile-fail/discrim-ill-typed.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -25,7 +25,8 @@ fn f_i8() {\n         Ok = i8::MAX - 1,\n         Ok2,\n         OhNo = 0_u8,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected i8, found u8\n     }\n \n     let x = A::Ok;\n@@ -37,7 +38,8 @@ fn f_u8() {\n         Ok = u8::MAX - 1,\n         Ok2,\n         OhNo = 0_i8,\n-        //~^  ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected u8, found i8\n     }\n \n     let x = A::Ok;\n@@ -49,7 +51,8 @@ fn f_i16() {\n         Ok = i16::MAX - 1,\n         Ok2,\n         OhNo = 0_u16,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected i16, found u16\n     }\n \n     let x = A::Ok;\n@@ -61,7 +64,8 @@ fn f_u16() {\n         Ok = u16::MAX - 1,\n         Ok2,\n         OhNo = 0_i16,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected u16, found i16\n     }\n \n     let x = A::Ok;\n@@ -73,7 +77,8 @@ fn f_i32() {\n         Ok = i32::MAX - 1,\n         Ok2,\n         OhNo = 0_u32,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected i32, found u32\n     }\n \n     let x = A::Ok;\n@@ -85,7 +90,8 @@ fn f_u32() {\n         Ok = u32::MAX - 1,\n         Ok2,\n         OhNo = 0_i32,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected u32, found i32\n     }\n \n     let x = A::Ok;\n@@ -97,7 +103,8 @@ fn f_i64() {\n         Ok = i64::MAX - 1,\n         Ok2,\n         OhNo = 0_u64,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected i64, found u64\n     }\n \n     let x = A::Ok;\n@@ -109,7 +116,8 @@ fn f_u64() {\n         Ok = u64::MAX - 1,\n         Ok2,\n         OhNo = 0_i64,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected u64, found i64\n     }\n \n     let x = A::Ok;"}, {"sha": "bbdb3891d99807dbd989d231ddbcdfbb3805993c", "filename": "src/test/compile-fail/enum-discrim-too-small.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -13,28 +13,32 @@\n enum Eu8 {\n     Au8 = 23,\n     Bu8 = 223,\n-    Cu8 = -23, //~ ERROR unary negation of unsigned integer\n+    Cu8 = -23, //~ ERROR E0080\n+               //~| unary negation of unsigned integer\n }\n \n #[repr(u16)]\n enum Eu16 {\n     Au16 = 23,\n     Bu16 = 55555,\n-    Cu16 = -22333, //~ ERROR unary negation of unsigned integer\n+    Cu16 = -22333, //~ ERROR E0080\n+                   //~| unary negation of unsigned integer\n }\n \n #[repr(u32)]\n enum Eu32 {\n     Au32 = 23,\n     Bu32 = 3_000_000_000,\n-    Cu32 = -2_000_000_000, //~ ERROR unary negation of unsigned integer\n+    Cu32 = -2_000_000_000, //~ ERROR E0080\n+                           //~| unary negation of unsigned integer\n }\n \n #[repr(u64)]\n enum Eu64 {\n     Au32 = 23,\n     Bu32 = 3_000_000_000,\n-    Cu32 = -2_000_000_000, //~ ERROR unary negation of unsigned integer\n+    Cu32 = -2_000_000_000, //~ ERROR E0080\n+                           //~| unary negation of unsigned integer\n }\n \n // u64 currently allows negative numbers, and i64 allows numbers greater than `1<<63`.  This is a"}, {"sha": "57db583aefe2355cb46bde8df1027c98637b18e7", "filename": "src/test/compile-fail/eval-enum.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Feval-enum.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -9,9 +9,11 @@\n // except according to those terms.\n \n enum test {\n-    div_zero = 1/0, //~ERROR constant evaluation error: attempted to divide by zero\n+    div_zero = 1/0, //~ ERROR E0080\n+                    //~| attempted to divide by zero\n     rem_zero = 1%0,\n-//~^ ERROR constant evaluation error: attempted to calculate the remainder with a divisor of zero\n+    //~^ ERROR E0080\n+    //~| attempted to calculate the remainder with a divisor of zero\n }\n \n fn main() {}"}, {"sha": "f8aa1ea95f0f66d51039d8bb09d1c11502bf1ec2", "filename": "src/test/compile-fail/explicit-self-lifetime-mismatch.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -14,15 +14,17 @@ struct Foo<'a,'b> {\n }\n \n impl<'a,'b> Foo<'a,'b> {\n-    fn bar(self: Foo<'b,'a>) {}\n-    //~^ ERROR mismatched types\n+    fn bar(\n+        self\n+    //~^ ERROR mismatched method receiver\n     //~| expected type `Foo<'a, 'b>`\n     //~| found type `Foo<'b, 'a>`\n     //~| lifetime mismatch\n-    //~| ERROR mismatched types\n+    //~| ERROR mismatched method receiver\n     //~| expected type `Foo<'a, 'b>`\n     //~| found type `Foo<'b, 'a>`\n     //~| lifetime mismatch\n+            : Foo<'b,'a>) {}\n }\n \n fn main() {}"}, {"sha": "89ae1a09bd3e47b2eca8b28e006031c79d1b5f72", "filename": "src/test/compile-fail/feature-gate-negate-unsigned0.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned0.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -18,14 +18,17 @@ impl std::ops::Neg for S {\n \n fn main() {\n     let a = -1;\n-    //~^ ERROR unary negation of unsigned integer\n+    //~^ ERROR E0080\n+    //~| unary negation of unsigned integer\n     let _b : u8 = a; // for infering variable a to u8.\n \n     let _d = -1u8;\n-    //~^ ERROR unary negation of unsigned integer\n+    //~^ ERROR E0080\n+    //~| unary negation of unsigned integer\n \n     for _ in -10..10u8 {}\n-    //~^ ERROR unary negation of unsigned integer\n+    //~^ ERROR E0080\n+    //~| unary negation of unsigned integer\n \n     -S; // should not trigger the gate; issue 26840\n }"}, {"sha": "9a9358b787f5386cbebd0231958212dc4c61fc4d", "filename": "src/test/compile-fail/invalid-path-in-const.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -10,5 +10,6 @@\n \n fn main() {\n     fn f(a: [u8; u32::DOESNOTEXIST]) {}\n-    //~^ ERROR unresolved path in constant expression\n+    //~^ ERROR constant evaluation error\n+    //~| unresolved path in constant expression\n }"}, {"sha": "3d9d81471cb1e40da806c9348464d193ff9cfa98", "filename": "src/test/compile-fail/issue-13033.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-13033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-13033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13033.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -16,7 +16,9 @@ struct Baz;\n \n impl Foo for Baz {\n     fn bar(&mut self, other: &Foo) {}\n-    //~^ ERROR method `bar` has an incompatible type for trait: values differ in mutability [E0053]\n+    //~^ ERROR method `bar` has an incompatible type for trait\n+    //~| expected type `fn(&mut Baz, &mut Foo)`\n+    //~| found type `fn(&mut Baz, &Foo)`\n }\n \n fn main() {}"}, {"sha": "da48bbb3ecd711a99a730cf859ec74f17bc9cc06", "filename": "src/test/compile-fail/issue-15094.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -20,8 +20,8 @@ impl<T: fmt::Debug> ops::FnOnce<(),> for Debuger<T> {\n     type Output = ();\n     fn call_once(self, _args: ()) {\n     //~^ ERROR `call_once` has an incompatible type for trait\n-    //~| expected \"rust-call\" fn,\n-    //~| found \"Rust\" fn\n+    //~| expected type `extern \"rust-call\" fn\n+    //~| found type `fn\n         println!(\"{:?}\", self.x);\n     }\n }"}, {"sha": "664d62e87ae61cf2f61a5f45d308275ce6f60856", "filename": "src/test/compile-fail/issue-17740.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -14,11 +14,11 @@ struct Foo<'a> {\n \n impl <'a> Foo<'a>{\n     fn bar(self: &mut Foo) {\n-    //~^ mismatched types\n+    //~^ mismatched method receiver\n     //~| expected type `&mut Foo<'a>`\n     //~| found type `&mut Foo<'_>`\n     //~| lifetime mismatch\n-    //~| mismatched types\n+    //~| mismatched method receiver\n     //~| expected type `&mut Foo<'a>`\n     //~| found type `&mut Foo<'_>`\n     //~| lifetime mismatch"}, {"sha": "db3334834d44ec97e5230755df303f1f2e0b4a65", "filename": "src/test/compile-fail/issue-21332.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-21332.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-21332.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21332.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -14,8 +14,7 @@ impl Iterator for S {\n     type Item = i32;\n     fn next(&mut self) -> Result<i32, i32> { Ok(7) }\n     //~^ ERROR method `next` has an incompatible type for trait\n-    //~| expected enum `std::option::Option`\n-    //~|    found enum `std::result::Result` [E0053]\n+    //~| expected enum `std::option::Option`, found enum `std::result::Result`\n }\n \n fn main() {}"}, {"sha": "54a24089354614f05c4e90e04e1e3bdce16fba17", "filename": "src/test/compile-fail/issue-22933-2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -12,10 +12,12 @@ enum Delicious {\n     Pie      = 0x1,\n     Apple    = 0x2,\n     ApplePie = Delicious::Apple as isize | Delicious::PIE as isize,\n-    //~^ ERROR constant evaluation error: unresolved path in constant expression\n+    //~^ ERROR constant evaluation error\n+    //~| unresolved path in constant expression\n }\n \n const FOO: [u32; u8::MIN as usize] = [];\n-//~^ ERROR array length constant evaluation error: unresolved path in constant expression\n+//~^ ERROR constant evaluation error\n+//~| unresolved path in constant expression\n \n fn main() {}"}, {"sha": "c2bcbb9d54a9a447c1f5c0bf873d8a8542226f4a", "filename": "src/test/compile-fail/issue-23217.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-23217.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-23217.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23217.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -10,7 +10,8 @@\n \n pub enum SomeEnum {\n     B = SomeEnum::A,\n-    //~^ ERROR constant evaluation error: unresolved path in constant expression\n+    //~^ ERROR constant evaluation error\n+    //~| unresolved path in constant expression\n }\n \n fn main() {}"}, {"sha": "ede81bea32ae3bfaea3db5168a4ea23f2ed19a1d", "filename": "src/test/compile-fail/issue-24356.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-24356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-24356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24356.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -30,9 +30,6 @@ fn main() {\n         impl Deref for Thing {\n             //~^ ERROR not all trait items implemented, missing: `Target` [E0046]\n             fn deref(&self) -> i8 { self.0 }\n-            //~^ ERROR method `deref` has an incompatible type for trait\n-            //~| expected &-ptr\n-            //~| found i8 [E0053]\n         }\n \n         let thing = Thing(72);"}, {"sha": "93f75e9bfed0dddc09f23fbcede1fcad238e351a", "filename": "src/test/compile-fail/issue-25145.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-25145.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-25145.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25145.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -17,6 +17,7 @@ impl S {\n }\n \n static STUFF: [u8; S::N] = [0; S::N];\n-//~^ ERROR array length constant evaluation error: unresolved path in constant expression\n+//~^ ERROR constant evaluation error\n+//~| unresolved path in constant expression\n \n fn main() {}"}, {"sha": "ee6ec52761266607887eef14302a41e2102c6278", "filename": "src/test/compile-fail/issue-27008.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -16,5 +16,5 @@ fn main() {\n     //~| expected type `usize`\n     //~| found type `S`\n     //~| expected usize, found struct `S`\n-    //~| ERROR expected positive integer for repeat count, found struct\n+    //~| ERROR expected usize for repeat count, found struct\n }"}, {"sha": "ca8d5a1f70473563b3badf884ffd97d5ae67111a", "filename": "src/test/compile-fail/issue-27895.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -14,7 +14,8 @@ fn main() {\n \n     match i {\n         0...index => println!(\"winner\"),\n-        //~^ ERROR non-constant path in constant expression\n+        //~^ ERROR constant evaluation error\n+        //~| non-constant path in constant expression\n         _ => println!(\"hello\"),\n     }\n }"}, {"sha": "1dfd146985ff48a8df17ee421986e27306637c67", "filename": "src/test/compile-fail/issue-28586.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-28586.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-28586.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28586.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -11,6 +11,6 @@\n // Regression test for issue #28586\n \n pub trait Foo {}\n-impl Foo for [u8; usize::BYTES] {} //~ ERROR E0250\n+impl Foo for [u8; usize::BYTES] {} //~ ERROR E0080\n \n fn main() { }"}, {"sha": "fb1e3cc87e88cf610da2b7a31fbb34e8bd486621", "filename": "src/test/compile-fail/issue-31173.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-31173.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-31173.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31173.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::vec::IntoIter;\n+\n+pub fn get_tok(it: &mut IntoIter<u8>) {\n+    let mut found_e = false;\n+\n+    let temp: Vec<u8> = it.take_while(|&x| {\n+        found_e = true;\n+        false\n+    })\n+        .cloned()\n+        //~^ ERROR type mismatch resolving\n+        //~| expected type `u8`\n+        //~| found type `&_`\n+        .collect(); //~ ERROR no method named `collect`\n+}\n+\n+fn main() {}"}, {"sha": "1b6e4b1d289e42d31c25c39983f188e578c87c18", "filename": "src/test/compile-fail/issue-3521.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -15,7 +15,8 @@ fn main() {\n     enum Stuff {\n         Bar = foo\n         //~^ ERROR attempt to use a non-constant value in a constant\n-        //~^^ ERROR constant evaluation error: non-constant path in constant expression\n+        //~^^ ERROR constant evaluation error\n+        //~| non-constant path in constant expression\n     }\n \n     println!(\"{}\", Stuff::Bar);"}, {"sha": "91a07dd9ba6dd68ede4d5bf9129a180f1d579d89", "filename": "src/test/compile-fail/issue-8761.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -10,13 +10,11 @@\n \n enum Foo {\n     A = 1i64,\n-    //~^ ERROR mismatched types:\n-    //~| expected `isize`,\n-    //~| found `i64` [E0080]\n+    //~^ ERROR constant evaluation error\n+    //~| expected isize, found i64\n     B = 2u8\n-    //~^ ERROR mismatched types:\n-    //~| expected `isize`,\n-    //~| found `u8` [E0080]\n+    //~^ ERROR constant evaluation error\n+    //~| expected isize, found u8\n }\n \n fn main() {}"}, {"sha": "2c4c2563021867ddbd6c305f1500b60c6971a5e4", "filename": "src/test/compile-fail/match-range-fail.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -27,6 +27,7 @@ fn main() {\n         'c' ... 100 => { }\n         _ => { }\n     };\n-    //~^^^ ERROR mismatched types in range\n-    //~| expected char, found integral variable\n+    //~^^^ ERROR mismatched types\n+    //~| expected type `_`\n+    //~| found type `char`\n }"}, {"sha": "cadfec5a38d3d9fbdc27d1569013b31482708da2", "filename": "src/test/compile-fail/non-constant-enum-for-vec-repeat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -15,5 +15,6 @@ enum State { ST_NULL, ST_WHITESPACE }\n \n fn main() {\n     [State::ST_NULL; (State::ST_WHITESPACE as usize)];\n-    //~^ ERROR expected constant integer for repeat count, but unimplemented constant expression\n+    //~^ ERROR constant evaluation error\n+    //~| unimplemented constant expression: enum variants\n }"}, {"sha": "a6f88a57b9125846a8f5ba8b52a91b18f7157736", "filename": "src/test/compile-fail/non-constant-expr-for-vec-repeat.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -13,6 +13,8 @@\n fn main() {\n     fn bar(n: usize) {\n         let _x = [0; n];\n-        //~^ ERROR expected constant integer for repeat count, found variable\n+        //~^ ERROR constant evaluation error\n+        //~| non-constant path in constant expression\n+        //~| NOTE `n` is a variable\n     }\n }"}, {"sha": "737f80372debf55c8e99bba7cd5970b199dea579", "filename": "src/test/compile-fail/non-constant-in-const-path.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -12,6 +12,7 @@ fn main() {\n     let x = 0;\n     match 1 {\n         0 ... x => {}\n-        //~^ ERROR non-constant path in constant expression\n+        //~^ ERROR constant evaluation error\n+        //~| non-constant path in constant expression\n     };\n }"}, {"sha": "3a7e9cc4191ec2af4de80bacf0579705aefe9bd8", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -13,39 +13,38 @@\n fn main() {\n     let n = 1;\n     let a = [0; n];\n-    //~^ ERROR expected constant integer for repeat count, found variable [E0307]\n+    //~^ ERROR constant evaluation error\n+    //~| non-constant path in constant expression\n     let b = [0; ()];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `()`\n     //~| expected usize, found ()\n-    //~| ERROR expected positive integer for repeat count, found tuple [E0306]\n+    //~| ERROR expected usize for repeat count, found tuple [E0306]\n     let c = [0; true];\n     //~^ ERROR mismatched types\n     //~| expected usize, found bool\n-    //~| ERROR expected positive integer for repeat count, found boolean [E0306]\n+    //~| ERROR expected usize for repeat count, found boolean [E0306]\n     let d = [0; 0.5];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `_`\n     //~| expected usize, found floating-point variable\n-    //~| ERROR expected positive integer for repeat count, found float [E0306]\n+    //~| ERROR expected usize for repeat count, found float [E0306]\n     let e = [0; \"foo\"];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `&'static str`\n     //~| expected usize, found &-ptr\n-    //~| ERROR expected positive integer for repeat count, found string literal [E0306]\n+    //~| ERROR expected usize for repeat count, found string literal [E0306]\n     let f = [0; -4_isize];\n-    //~^ ERROR mismatched types\n-    //~| expected `usize`\n-    //~| found `isize`\n-    //~| ERROR mismatched types:\n+    //~^ ERROR constant evaluation error\n+    //~| expected usize, found isize\n+    //~| ERROR mismatched types\n     //~| expected usize, found isize\n     let f = [0_usize; -1_isize];\n-    //~^ ERROR mismatched types\n-    //~| expected `usize`\n-    //~| found `isize`\n+    //~^ ERROR constant evaluation error\n+    //~| expected usize, found isize\n     //~| ERROR mismatched types\n     //~| expected usize, found isize\n     struct G {\n@@ -56,5 +55,5 @@ fn main() {\n     //~| expected type `usize`\n     //~| found type `main::G`\n     //~| expected usize, found struct `main::G`\n-    //~| ERROR expected positive integer for repeat count, found struct [E0306]\n+    //~| ERROR expected usize for repeat count, found struct [E0306]\n }"}, {"sha": "a05e007d6b7393e5774e44d76904c35b39fb3243", "filename": "src/test/compile-fail/trait-impl-method-mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Ftrait-impl-method-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Ftrait-impl-method-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-method-mismatch.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -17,8 +17,8 @@ impl Mumbo for usize {\n     // Cannot have a larger effect than the trait:\n     unsafe fn jumbo(&self, x: &usize) { *self + *x; }\n     //~^ ERROR method `jumbo` has an incompatible type for trait\n-    //~| expected normal fn,\n-    //~| found unsafe fn\n+    //~| expected type `fn\n+    //~| found type `unsafe fn\n }\n \n fn main() {}"}, {"sha": "a98b7cd43090f3768723cdc4fdb175eb4a91d410", "filename": "src/test/compile-fail/ufcs-explicit-self-bad.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -41,14 +41,14 @@ trait SomeTrait {\n \n impl<'a, T> SomeTrait for &'a Bar<T> {\n     fn dummy1(self: &&'a Bar<T>) { }\n-    fn dummy2(self: &Bar<T>) {} //~ ERROR mismatched types\n-    //~^ ERROR mismatched types\n+    fn dummy2(self: &Bar<T>) {} //~ ERROR mismatched method receiver\n+    //~^ ERROR mismatched method receiver\n     fn dummy3(self: &&Bar<T>) {}\n-    //~^ ERROR mismatched types\n+    //~^ ERROR mismatched method receiver\n     //~| expected type `&&'a Bar<T>`\n     //~| found type `&&Bar<T>`\n     //~| lifetime mismatch\n-    //~| ERROR mismatched types\n+    //~| ERROR mismatched method receiver\n     //~| expected type `&&'a Bar<T>`\n     //~| found type `&&Bar<T>`\n     //~| lifetime mismatch"}, {"sha": "fb4652affd0d8c3ce6c8ce7f7023b57f447c3137", "filename": "src/test/compile-fail/unsafe-trait-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Funsafe-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f/src%2Ftest%2Fcompile-fail%2Funsafe-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-trait-impl.rs?ref=f2e59cc6aa3bf901a4aefa8ad4954edddf3da29f", "patch": "@@ -17,8 +17,8 @@ trait Foo {\n impl Foo for u32 {\n     fn len(&self) -> u32 { *self }\n     //~^ ERROR method `len` has an incompatible type for trait\n-    //~| expected unsafe fn,\n-    //~| found normal fn\n+    //~| expected type `unsafe fn(&u32) -> u32`\n+    //~| found type `fn(&u32) -> u32`\n }\n \n fn main() { }"}]}