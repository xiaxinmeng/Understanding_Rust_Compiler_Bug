{"sha": "db4585aa3b1ee56e4722710d7665ee011fc11145", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNDU4NWFhM2IxZWU1NmU0NzIyNzEwZDc2NjVlZTAxMWZjMTExNDU=", "commit": {"author": {"name": "Ashley Mannix", "email": "kodraus@hey.com", "date": "2021-01-06T00:04:05Z"}, "committer": {"name": "Ashley Mannix", "email": "kodraus@hey.com", "date": "2021-01-06T00:44:06Z"}, "message": "use Once instead of Mutex to manage capture resolution\n\nThis allows us to return borrows of the captured backtrace frames\nthat are tied to a borrow of the Backtrace itself, instead of to\nsome short-lived Mutex guard.\n\nIt also makes it semantically clearer what synchronization is needed\non the capture.", "tree": {"sha": "df39527b19724778422dc575ad70595068efc2e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df39527b19724778422dc575ad70595068efc2e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db4585aa3b1ee56e4722710d7665ee011fc11145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db4585aa3b1ee56e4722710d7665ee011fc11145", "html_url": "https://github.com/rust-lang/rust/commit/db4585aa3b1ee56e4722710d7665ee011fc11145", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db4585aa3b1ee56e4722710d7665ee011fc11145/comments", "author": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da305a2b00530aa34dea4e48389204c26fa35dbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/da305a2b00530aa34dea4e48389204c26fa35dbb", "html_url": "https://github.com/rust-lang/rust/commit/da305a2b00530aa34dea4e48389204c26fa35dbb"}], "stats": {"total": 49, "additions": 39, "deletions": 10}, "files": [{"sha": "95e18ef2a654343b71f3f96063b956a11c2c94fa", "filename": "library/std/src/backtrace.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/db4585aa3b1ee56e4722710d7665ee011fc11145/library%2Fstd%2Fsrc%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4585aa3b1ee56e4722710d7665ee011fc11145/library%2Fstd%2Fsrc%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace.rs?ref=db4585aa3b1ee56e4722710d7665ee011fc11145", "patch": "@@ -95,11 +95,12 @@ mod tests;\n // a backtrace or actually symbolizing it.\n \n use crate::backtrace_rs::{self, BytesOrWideString};\n+use crate::cell::UnsafeCell;\n use crate::env;\n use crate::ffi::c_void;\n use crate::fmt;\n use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-use crate::sync::Mutex;\n+use crate::sync::Once;\n use crate::sys_common::backtrace::{lock, output_filename};\n use crate::vec::Vec;\n \n@@ -132,7 +133,7 @@ pub enum BacktraceStatus {\n enum Inner {\n     Unsupported,\n     Disabled,\n-    Captured(Mutex<Capture>),\n+    Captured(LazilyResolvedCapture),\n }\n \n struct Capture {\n@@ -171,12 +172,11 @@ enum BytesOrWide {\n \n impl fmt::Debug for Backtrace {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut capture = match &self.inner {\n+        let capture = match &self.inner {\n             Inner::Unsupported => return fmt.write_str(\"<unsupported>\"),\n             Inner::Disabled => return fmt.write_str(\"<disabled>\"),\n-            Inner::Captured(c) => c.lock().unwrap(),\n+            Inner::Captured(c) => c.force(),\n         };\n-        capture.resolve();\n \n         let frames = &capture.frames[capture.actual_start..];\n \n@@ -331,7 +331,7 @@ impl Backtrace {\n         let inner = if frames.is_empty() {\n             Inner::Unsupported\n         } else {\n-            Inner::Captured(Mutex::new(Capture {\n+            Inner::Captured(LazilyResolvedCapture::new(Capture {\n                 actual_start: actual_start.unwrap_or(0),\n                 frames,\n                 resolved: false,\n@@ -355,12 +355,11 @@ impl Backtrace {\n \n impl fmt::Display for Backtrace {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut capture = match &self.inner {\n+        let capture = match &self.inner {\n             Inner::Unsupported => return fmt.write_str(\"unsupported backtrace\"),\n             Inner::Disabled => return fmt.write_str(\"disabled backtrace\"),\n-            Inner::Captured(c) => c.lock().unwrap(),\n+            Inner::Captured(c) => c.force(),\n         };\n-        capture.resolve();\n \n         let full = fmt.alternate();\n         let (frames, style) = if full {\n@@ -404,6 +403,33 @@ impl fmt::Display for Backtrace {\n     }\n }\n \n+struct LazilyResolvedCapture {\n+    sync: Once,\n+    capture: UnsafeCell<Capture>,\n+}\n+\n+impl LazilyResolvedCapture {\n+    fn new(capture: Capture) -> Self {\n+        LazilyResolvedCapture { sync: Once::new(), capture: UnsafeCell::new(capture) }\n+    }\n+\n+    fn force(&self) -> &Capture {\n+        self.sync.call_once(|| {\n+            // SAFETY: This exclusive reference can't overlap with any others\n+            // `Once` guarantees callers will block until this closure returns\n+            // `Once` also guarantees only a single caller will enter this closure\n+            unsafe { &mut *self.capture.get() }.resolve();\n+        });\n+\n+        // SAFETY: This shared reference can't overlap with the exclusive reference above\n+        unsafe { &*self.capture.get() }\n+    }\n+}\n+\n+// SAFETY: Access to the inner value is synchronized using a thread-safe `Once`\n+// So long as `Capture` is `Sync`, `LazilyResolvedCapture` is too\n+unsafe impl Sync for LazilyResolvedCapture where Capture: Sync {}\n+\n impl Capture {\n     fn resolve(&mut self) {\n         // If we're already resolved, nothing to do!"}, {"sha": "31cf0f702185c9ca47e0df66821f302b673d0334", "filename": "library/std/src/backtrace/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db4585aa3b1ee56e4722710d7665ee011fc11145/library%2Fstd%2Fsrc%2Fbacktrace%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4585aa3b1ee56e4722710d7665ee011fc11145/library%2Fstd%2Fsrc%2Fbacktrace%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace%2Ftests.rs?ref=db4585aa3b1ee56e4722710d7665ee011fc11145", "patch": "@@ -3,7 +3,7 @@ use super::*;\n #[test]\n fn test_debug() {\n     let backtrace = Backtrace {\n-        inner: Inner::Captured(Mutex::new(Capture {\n+        inner: Inner::Captured(LazilyResolvedCapture::new(Capture {\n             actual_start: 1,\n             resolved: true,\n             frames: vec![\n@@ -54,4 +54,7 @@ fn test_debug() {\n     \\n]\";\n \n     assert_eq!(format!(\"{:#?}\", backtrace), expected);\n+\n+    // Format the backtrace a second time, just to make sure lazily resolved state is stable\n+    assert_eq!(format!(\"{:#?}\", backtrace), expected);\n }"}]}