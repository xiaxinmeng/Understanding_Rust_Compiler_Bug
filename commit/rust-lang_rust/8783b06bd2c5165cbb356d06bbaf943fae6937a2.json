{"sha": "8783b06bd2c5165cbb356d06bbaf943fae6937a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ODNiMDZiZDJjNTE2NWNiYjM1NmQwNmJiYWY5NDNmYWU2OTM3YTI=", "commit": {"author": {"name": "LinkTed", "email": "LinkTed@users.noreply.github.com", "date": "2020-08-23T12:50:54Z"}, "committer": {"name": "LinkTed", "email": "LinkTed@users.noreply.github.com", "date": "2020-10-10T13:19:11Z"}, "message": "Move `add_to_ancillary_data` and `AncillaryDataIter` to ancillary.rs", "tree": {"sha": "8a3201fb1e4308af09074ef047c4b75c3f0c3374", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a3201fb1e4308af09074ef047c4b75c3f0c3374"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8783b06bd2c5165cbb356d06bbaf943fae6937a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8783b06bd2c5165cbb356d06bbaf943fae6937a2", "html_url": "https://github.com/rust-lang/rust/commit/8783b06bd2c5165cbb356d06bbaf943fae6937a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8783b06bd2c5165cbb356d06bbaf943fae6937a2/comments", "author": {"login": "LinkTed", "id": 6806266, "node_id": "MDQ6VXNlcjY4MDYyNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6806266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LinkTed", "html_url": "https://github.com/LinkTed", "followers_url": "https://api.github.com/users/LinkTed/followers", "following_url": "https://api.github.com/users/LinkTed/following{/other_user}", "gists_url": "https://api.github.com/users/LinkTed/gists{/gist_id}", "starred_url": "https://api.github.com/users/LinkTed/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LinkTed/subscriptions", "organizations_url": "https://api.github.com/users/LinkTed/orgs", "repos_url": "https://api.github.com/users/LinkTed/repos", "events_url": "https://api.github.com/users/LinkTed/events{/privacy}", "received_events_url": "https://api.github.com/users/LinkTed/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LinkTed", "id": 6806266, "node_id": "MDQ6VXNlcjY4MDYyNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6806266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LinkTed", "html_url": "https://github.com/LinkTed", "followers_url": "https://api.github.com/users/LinkTed/followers", "following_url": "https://api.github.com/users/LinkTed/following{/other_user}", "gists_url": "https://api.github.com/users/LinkTed/gists{/gist_id}", "starred_url": "https://api.github.com/users/LinkTed/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LinkTed/subscriptions", "organizations_url": "https://api.github.com/users/LinkTed/orgs", "repos_url": "https://api.github.com/users/LinkTed/repos", "events_url": "https://api.github.com/users/LinkTed/events{/privacy}", "received_events_url": "https://api.github.com/users/LinkTed/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6984eee6f04a63dea3441dd1aec7d2f81e98e6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6984eee6f04a63dea3441dd1aec7d2f81e98e6d", "html_url": "https://github.com/rust-lang/rust/commit/e6984eee6f04a63dea3441dd1aec7d2f81e98e6d"}], "stats": {"total": 173, "additions": 86, "deletions": 87}, "files": [{"sha": "03fd288b8701f4d08bb2866ae2da66519d2467e1", "filename": "library/std/src/sys/unix/ext/net/ancillary.rs", "status": "modified", "additions": 86, "deletions": 5, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8783b06bd2c5165cbb356d06bbaf943fae6937a2/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8783b06bd2c5165cbb356d06bbaf943fae6937a2/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs?ref=8783b06bd2c5165cbb356d06bbaf943fae6937a2", "patch": "@@ -1,24 +1,25 @@\n use crate::convert::TryFrom;\n use crate::io::{self, IoSliceMut};\n-use crate::mem;\n+use crate::marker::PhantomData;\n+use crate::mem::{size_of, zeroed};\n use crate::os::unix::io::RawFd;\n use crate::path::Path;\n use crate::ptr::null_mut;\n use crate::slice::from_raw_parts;\n use crate::sys::unix::ext::net::addr::{sockaddr_un, SocketAddr};\n-use crate::sys::unix::net::{add_to_ancillary_data, AncillaryDataIter, Socket};\n+use crate::sys::unix::net::Socket;\n \n pub(super) fn recv_vectored_with_ancillary_from(\n     socket: &Socket,\n     bufs: &mut [IoSliceMut<'_>],\n     ancillary: &mut SocketAncillary<'_>,\n ) -> io::Result<(usize, bool, io::Result<SocketAddr>)> {\n     unsafe {\n-        let mut msg_name: libc::sockaddr_un = mem::zeroed();\n+        let mut msg_name: libc::sockaddr_un = zeroed();\n \n         let mut msg = libc::msghdr {\n             msg_name: &mut msg_name as *mut _ as *mut _,\n-            msg_namelen: mem::size_of::<libc::sockaddr_un>() as libc::socklen_t,\n+            msg_namelen: size_of::<libc::sockaddr_un>() as libc::socklen_t,\n             msg_iov: bufs.as_mut_ptr().cast(),\n             msg_iovlen: bufs.len(),\n             msg_control: ancillary.buffer.as_mut_ptr().cast(),\n@@ -46,7 +47,7 @@ pub(super) fn send_vectored_with_ancillary_to(\n ) -> io::Result<usize> {\n     unsafe {\n         let (mut msg_name, msg_namelen) =\n-            if let Some(path) = path { sockaddr_un(path)? } else { (mem::zeroed(), 0) };\n+            if let Some(path) = path { sockaddr_un(path)? } else { (zeroed(), 0) };\n \n         let mut msg = libc::msghdr {\n             msg_name: &mut msg_name as *mut _ as *mut _,\n@@ -64,6 +65,86 @@ pub(super) fn send_vectored_with_ancillary_to(\n     }\n }\n \n+fn add_to_ancillary_data<T: Clone>(\n+    buffer: &mut [u8],\n+    length: &mut usize,\n+    source: &[T],\n+    cmsg_level: libc::c_int,\n+    cmsg_type: libc::c_int,\n+) -> bool {\n+    let len = (source.len() * size_of::<T>()) as u32;\n+\n+    unsafe {\n+        let additional_space = libc::CMSG_SPACE(len) as usize;\n+        if *length + additional_space > buffer.len() {\n+            return false;\n+        }\n+\n+        libc::memset(buffer[*length..].as_mut_ptr().cast(), 0, additional_space);\n+\n+        *length += additional_space;\n+\n+        let msg = libc::msghdr {\n+            msg_name: null_mut(),\n+            msg_namelen: 0,\n+            msg_iov: null_mut(),\n+            msg_iovlen: 0,\n+            msg_control: buffer.as_mut_ptr().cast(),\n+            msg_controllen: *length,\n+            msg_flags: 0,\n+        };\n+\n+        let mut cmsg = libc::CMSG_FIRSTHDR(&msg);\n+        let mut previous_cmsg = cmsg;\n+        while !cmsg.is_null() {\n+            previous_cmsg = cmsg;\n+            cmsg = libc::CMSG_NXTHDR(&msg, cmsg);\n+        }\n+\n+        if previous_cmsg.is_null() {\n+            return false;\n+        }\n+\n+        (*previous_cmsg).cmsg_level = cmsg_level;\n+        (*previous_cmsg).cmsg_type = cmsg_type;\n+        (*previous_cmsg).cmsg_len = libc::CMSG_LEN(len) as usize;\n+\n+        let data = libc::CMSG_DATA(previous_cmsg).cast();\n+\n+        libc::memcpy(data, source.as_ptr().cast(), len as usize);\n+    }\n+    true\n+}\n+\n+struct AncillaryDataIter<'a, T> {\n+    data: &'a [u8],\n+    phantom: crate::marker::PhantomData<T>,\n+}\n+\n+impl<'a, T> AncillaryDataIter<'a, T> {\n+    pub fn new(data: &'a [u8]) -> AncillaryDataIter<'a, T> {\n+        AncillaryDataIter { data, phantom: PhantomData }\n+    }\n+}\n+\n+impl<'a, T> Iterator for AncillaryDataIter<'a, T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        unsafe {\n+            let mut unit = zeroed();\n+            if size_of::<T>() <= self.data.len() {\n+                let unit_ptr: *mut T = &mut unit;\n+                libc::memcpy(unit_ptr.cast(), self.data.as_ptr().cast(), size_of::<T>());\n+                self.data = &self.data[size_of::<T>()..];\n+                Some(unit)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n #[derive(Clone)]\n pub struct UCred(libc::ucred);"}, {"sha": "1a514ed0238cfd00ccf65c1f7149720d4369f31b", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8783b06bd2c5165cbb356d06bbaf943fae6937a2/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8783b06bd2c5165cbb356d06bbaf943fae6937a2/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=8783b06bd2c5165cbb356d06bbaf943fae6937a2", "patch": "@@ -1,10 +1,8 @@\n use crate::cmp;\n use crate::ffi::CStr;\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::marker::PhantomData;\n use crate::mem;\n use crate::net::{Shutdown, SocketAddr};\n-use crate::ptr::null_mut;\n use crate::str;\n use crate::sys::fd::FileDesc;\n use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n@@ -20,86 +18,6 @@ pub extern crate libc as netc;\n \n pub type wrlen_t = size_t;\n \n-pub struct AncillaryDataIter<'a, T> {\n-    data: &'a [u8],\n-    phantom: crate::marker::PhantomData<T>,\n-}\n-\n-impl<'a, T> AncillaryDataIter<'a, T> {\n-    pub fn new(data: &'a [u8]) -> AncillaryDataIter<'a, T> {\n-        AncillaryDataIter { data, phantom: PhantomData }\n-    }\n-}\n-\n-impl<'a, T> Iterator for AncillaryDataIter<'a, T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        unsafe {\n-            let mut unit = mem::zeroed();\n-            if mem::size_of::<T>() <= self.data.len() {\n-                let unit_ptr: *mut T = &mut unit;\n-                libc::memcpy(unit_ptr.cast(), self.data.as_ptr().cast(), mem::size_of::<T>());\n-                self.data = &self.data[mem::size_of::<T>()..];\n-                Some(unit)\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-pub fn add_to_ancillary_data<T: core::clone::Clone>(\n-    buffer: &mut [u8],\n-    length: &mut usize,\n-    source: &[T],\n-    cmsg_level: libc::c_int,\n-    cmsg_type: libc::c_int,\n-) -> bool {\n-    let len = (source.len() * mem::size_of::<T>()) as u32;\n-\n-    unsafe {\n-        let additional_space = libc::CMSG_SPACE(len) as usize;\n-        if *length + additional_space > buffer.len() {\n-            return false;\n-        }\n-\n-        libc::memset(buffer[*length..].as_mut_ptr().cast(), 0, additional_space);\n-\n-        *length += additional_space;\n-\n-        let msg = libc::msghdr {\n-            msg_name: null_mut(),\n-            msg_namelen: 0,\n-            msg_iov: null_mut(),\n-            msg_iovlen: 0,\n-            msg_control: buffer.as_mut_ptr().cast(),\n-            msg_controllen: *length,\n-            msg_flags: 0,\n-        };\n-\n-        let mut cmsg = libc::CMSG_FIRSTHDR(&msg);\n-        let mut previous_cmsg = cmsg;\n-        while !cmsg.is_null() {\n-            previous_cmsg = cmsg;\n-            cmsg = libc::CMSG_NXTHDR(&msg, cmsg);\n-        }\n-\n-        if previous_cmsg.is_null() {\n-            return false;\n-        }\n-\n-        (*previous_cmsg).cmsg_level = cmsg_level;\n-        (*previous_cmsg).cmsg_type = cmsg_type;\n-        (*previous_cmsg).cmsg_len = libc::CMSG_LEN(len) as usize;\n-\n-        let data = libc::CMSG_DATA(previous_cmsg).cast();\n-\n-        libc::memcpy(data, source.as_ptr().cast(), len as usize);\n-    }\n-    true\n-}\n-\n pub struct Socket(FileDesc);\n \n pub fn init() {}"}]}