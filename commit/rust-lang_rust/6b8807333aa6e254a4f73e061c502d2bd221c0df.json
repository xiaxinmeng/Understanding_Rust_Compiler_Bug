{"sha": "6b8807333aa6e254a4f73e061c502d2bd221c0df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiODgwNzMzM2FhNmUyNTRhNGY3M2UwNjFjNTAyZDJiZDIyMWMwZGY=", "commit": {"author": {"name": "Hideki Sekine", "email": "sekineh@me.com", "date": "2019-10-01T10:16:51Z"}, "committer": {"name": "Hideki Sekine", "email": "sekineh@me.com", "date": "2019-10-25T08:06:58Z"}, "message": "Add .into_iter_sorted() and .drain_sorted()\n\n* `.drain_sorted()` doc change suggested by @KodrAus", "tree": {"sha": "1a56495eca7edf2bbef8f83d06499c3b9725129c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a56495eca7edf2bbef8f83d06499c3b9725129c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b8807333aa6e254a4f73e061c502d2bd221c0df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b8807333aa6e254a4f73e061c502d2bd221c0df", "html_url": "https://github.com/rust-lang/rust/commit/6b8807333aa6e254a4f73e061c502d2bd221c0df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b8807333aa6e254a4f73e061c502d2bd221c0df/comments", "author": {"login": "sekineh", "id": 3956266, "node_id": "MDQ6VXNlcjM5NTYyNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3956266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sekineh", "html_url": "https://github.com/sekineh", "followers_url": "https://api.github.com/users/sekineh/followers", "following_url": "https://api.github.com/users/sekineh/following{/other_user}", "gists_url": "https://api.github.com/users/sekineh/gists{/gist_id}", "starred_url": "https://api.github.com/users/sekineh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sekineh/subscriptions", "organizations_url": "https://api.github.com/users/sekineh/orgs", "repos_url": "https://api.github.com/users/sekineh/repos", "events_url": "https://api.github.com/users/sekineh/events{/privacy}", "received_events_url": "https://api.github.com/users/sekineh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sekineh", "id": 3956266, "node_id": "MDQ6VXNlcjM5NTYyNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3956266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sekineh", "html_url": "https://github.com/sekineh", "followers_url": "https://api.github.com/users/sekineh/followers", "following_url": "https://api.github.com/users/sekineh/following{/other_user}", "gists_url": "https://api.github.com/users/sekineh/gists{/gist_id}", "starred_url": "https://api.github.com/users/sekineh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sekineh/subscriptions", "organizations_url": "https://api.github.com/users/sekineh/orgs", "repos_url": "https://api.github.com/users/sekineh/repos", "events_url": "https://api.github.com/users/sekineh/events{/privacy}", "received_events_url": "https://api.github.com/users/sekineh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d54111afc061ef398cd8ce28984f9e8d70001b24", "url": "https://api.github.com/repos/rust-lang/rust/commits/d54111afc061ef398cd8ce28984f9e8d70001b24", "html_url": "https://github.com/rust-lang/rust/commit/d54111afc061ef398cd8ce28984f9e8d70001b24"}], "stats": {"total": 224, "additions": 219, "deletions": 5}, "files": [{"sha": "08d39d80949abaee08f57c1727f9df08d4333ba4", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 140, "deletions": 1, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/6b8807333aa6e254a4f73e061c502d2bd221c0df/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8807333aa6e254a4f73e061c502d2bd221c0df/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=6b8807333aa6e254a4f73e061c502d2bd221c0df", "patch": "@@ -146,7 +146,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::ops::{Deref, DerefMut};\n-use core::iter::{FromIterator, FusedIterator};\n+use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::mem::{swap, size_of, ManuallyDrop};\n use core::ptr;\n use core::fmt;\n@@ -672,6 +672,27 @@ impl<T> BinaryHeap<T> {\n         Iter { iter: self.data.iter() }\n     }\n \n+    /// Returns an iterator which retrieves elements in heap order.\n+    /// This method consumes the original heap.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(binary_heap_into_iter_sorted)]\n+    /// use std::collections::BinaryHeap;\n+    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);\n+    ///\n+    /// assert_eq!(heap.into_iter_sorted().take(2).collect::<Vec<_>>(), vec![5, 4]);\n+    /// ```\n+    #[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+    pub fn into_iter_sorted(self) -> IntoIterSorted<T> {\n+        IntoIterSorted {\n+            inner: self,\n+        }\n+    }\n+\n     /// Returns the greatest item in the binary heap, or `None` if it is empty.\n     ///\n     /// # Examples\n@@ -899,6 +920,47 @@ impl<T> BinaryHeap<T> {\n         Drain { iter: self.data.drain(..) }\n     }\n \n+    /// Returns an iterator which retrieves elements in heap order.\n+    /// The retrieved elements will be removed from the original heap.\n+    ///\n+    /// Note:\n+    /// * Unlike other `.drain()` methods, this method removes elements *lazily*.\n+    /// In order to remove elements in heap order, you need to retrieve elements explicitly.\n+    /// * The remaining elements are removed on drop in arbitrary order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(binary_heap_drain_sorted)]\n+    /// use std::collections::BinaryHeap;\n+    ///\n+    /// let mut heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);\n+    /// assert_eq!(heap.len(), 5);\n+    ///\n+    /// let len = heap.len();\n+    /// let removed = heap.drain_sorted()\n+    ///     .take(len).collect::<Vec<_>>(); // removes all elements in *heap* order\n+    /// assert_eq!(removed, vec![5, 4, 3, 2, 1]);\n+    /// assert_eq!(heap.len(), 0);\n+    ///\n+    ///\n+    /// let mut heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);\n+    /// assert_eq!(heap.len(), 5);\n+    ///\n+    /// let drain_sorted = heap.drain_sorted();\n+    /// drop(drain_sorted); // removes all elements in *arbitrary* order\n+    /// assert_eq!(heap.len(), 0);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+    pub fn drain_sorted(&mut self) -> DrainSorted<'_, T> {\n+        DrainSorted {\n+            inner: self,\n+        }\n+    }\n+\n     /// Drops all items from the binary heap.\n     ///\n     /// # Examples\n@@ -1115,6 +1177,37 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n+#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+#[derive(Clone, Debug)]\n+pub struct IntoIterSorted<T> {\n+    inner: BinaryHeap<T>,\n+}\n+\n+#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+impl<T: Ord> Iterator for IntoIterSorted<T> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.pop()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let exact = self.inner.len();\n+        (exact, Some(exact))\n+    }\n+}\n+\n+#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+impl<T: Ord> ExactSizeIterator for IntoIterSorted<T> {}\n+\n+#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+impl<T: Ord> FusedIterator for IntoIterSorted<T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T: Ord> TrustedLen for IntoIterSorted<T> {}\n+\n /// A draining iterator over the elements of a `BinaryHeap`.\n ///\n /// This `struct` is created by the [`drain`] method on [`BinaryHeap`]. See its\n@@ -1161,6 +1254,52 @@ impl<T> ExactSizeIterator for Drain<'_, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Drain<'_, T> {}\n \n+/// A draining iterator over the elements of a `BinaryHeap`.\n+///\n+/// This `struct` is created by the [`drain_sorted`] method on [`BinaryHeap`]. See its\n+/// documentation for more.\n+///\n+/// [`drain_sorted`]: struct.BinaryHeap.html#method.drain_sorted\n+/// [`BinaryHeap`]: struct.BinaryHeap.html\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+#[derive(Debug)]\n+pub struct DrainSorted<'a, T> {\n+    inner: &'a mut BinaryHeap<T>,\n+}\n+\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+impl<'a, T> Drop for DrainSorted<'a, T> {\n+    /// Removes heap elements in arbitrary order for efficiency.\n+    fn drop(&mut self) {\n+        self.inner.drain();\n+    }\n+}\n+\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+impl<T: Ord> Iterator for DrainSorted<'_, T> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.pop()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let exact = self.inner.len();\n+        (exact, Some(exact))\n+    }\n+}\n+\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+impl<T: Ord> ExactSizeIterator for DrainSorted<'_, T> { }\n+\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+impl<T: Ord> FusedIterator for DrainSorted<'_, T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T: Ord> TrustedLen for DrainSorted<'_, T> {}\n+\n #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {\n     /// Converts a `Vec<T>` into a `BinaryHeap<T>`."}, {"sha": "f494a3e4b3d24b4492266fa22f486575d563fec0", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 77, "deletions": 4, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6b8807333aa6e254a4f73e061c502d2bd221c0df/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8807333aa6e254a4f73e061c502d2bd221c0df/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=6b8807333aa6e254a4f73e061c502d2bd221c0df", "patch": "@@ -1,5 +1,10 @@\n use std::collections::BinaryHeap;\n use std::collections::binary_heap::{Drain, PeekMut};\n+use std::panic::{self, AssertUnwindSafe};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::iter::TrustedLen;\n+\n+use rand::{thread_rng, seq::SliceRandom};\n \n #[test]\n fn test_iterator() {\n@@ -14,7 +19,7 @@ fn test_iterator() {\n }\n \n #[test]\n-fn test_iterator_reverse() {\n+fn test_iter_rev_cloned_collect() {\n     let data = vec![5, 9, 3];\n     let iterout = vec![3, 5, 9];\n     let pq = BinaryHeap::from(data);\n@@ -24,7 +29,7 @@ fn test_iterator_reverse() {\n }\n \n #[test]\n-fn test_move_iter() {\n+fn test_into_iter_collect() {\n     let data = vec![5, 9, 3];\n     let iterout = vec![9, 5, 3];\n     let pq = BinaryHeap::from(data);\n@@ -34,7 +39,7 @@ fn test_move_iter() {\n }\n \n #[test]\n-fn test_move_iter_size_hint() {\n+fn test_into_iter_size_hint() {\n     let data = vec![5, 9];\n     let pq = BinaryHeap::from(data);\n \n@@ -51,7 +56,7 @@ fn test_move_iter_size_hint() {\n }\n \n #[test]\n-fn test_move_iter_reverse() {\n+fn test_into_iter_rev_collect() {\n     let data = vec![5, 9, 3];\n     let iterout = vec![3, 5, 9];\n     let pq = BinaryHeap::from(data);\n@@ -60,6 +65,65 @@ fn test_move_iter_reverse() {\n     assert_eq!(v, iterout);\n }\n \n+#[test]\n+fn test_into_iter_sorted_collect() {\n+    let heap = BinaryHeap::from(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+    let it = heap.into_iter_sorted();\n+    let sorted = it.collect::<Vec<_>>();\n+    assert_eq!(sorted, vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 2, 1, 1, 0]);\n+}\n+\n+#[test]\n+fn test_drain_sorted_collect() {\n+    let mut heap = BinaryHeap::from(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+    let it = heap.drain_sorted();\n+    let sorted = it.collect::<Vec<_>>();\n+    assert_eq!(sorted, vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 2, 1, 1, 0]);\n+}\n+\n+fn check_exact_size_iterator<I: ExactSizeIterator>(len: usize, it: I) {\n+    let mut it = it;\n+\n+    for i in 0..it.len() {\n+        let (lower, upper) = it.size_hint();\n+        assert_eq!(Some(lower), upper);\n+        assert_eq!(lower, len - i);\n+        assert_eq!(it.len(), len - i);\n+        it.next();\n+    }\n+    assert_eq!(it.len(), 0);\n+    assert!(it.is_empty());\n+}\n+\n+#[test]\n+fn test_exact_size_iterator() {\n+    let heap = BinaryHeap::from(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+    check_exact_size_iterator(heap.len(), heap.iter());\n+    check_exact_size_iterator(heap.len(), heap.clone().into_iter());\n+    check_exact_size_iterator(heap.len(), heap.clone().into_iter_sorted());\n+    check_exact_size_iterator(heap.len(), heap.clone().drain());\n+    check_exact_size_iterator(heap.len(), heap.clone().drain_sorted());\n+}\n+\n+fn check_trusted_len<I: TrustedLen>(len: usize, it: I) {\n+    let mut it = it;\n+    for i in 0..len {\n+        let (lower, upper) = it.size_hint();\n+        if upper.is_some() {\n+            assert_eq!(Some(lower), upper);\n+            assert_eq!(lower, len - i);\n+        }\n+        it.next();\n+    }\n+}\n+\n+#[test]\n+fn test_trusted_len() {\n+    let heap = BinaryHeap::from(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+    check_trusted_len(heap.len(), heap.clone().into_iter_sorted());\n+    check_trusted_len(heap.len(), heap.clone().drain_sorted());\n+}\n+\n #[test]\n fn test_peek_and_pop() {\n     let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n@@ -206,6 +270,15 @@ fn test_drain() {\n     assert!(q.is_empty());\n }\n \n+#[test]\n+fn test_drain_sorted() {\n+    let mut q: BinaryHeap<_> = [9, 8, 7, 6, 5, 4, 3, 2, 1].iter().cloned().collect();\n+\n+    assert_eq!(q.drain_sorted().take(5).collect::<Vec<_>>(), vec![9, 8, 7, 6, 5]);\n+\n+    assert!(q.is_empty());\n+}\n+\n #[test]\n fn test_extend_ref() {\n     let mut a = BinaryHeap::new();"}, {"sha": "4508fcc84513057fda769e9584fe7f4339aa81c7", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b8807333aa6e254a4f73e061c502d2bd221c0df/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8807333aa6e254a4f73e061c502d2bd221c0df/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=6b8807333aa6e254a4f73e061c502d2bd221c0df", "patch": "@@ -9,6 +9,8 @@\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(associated_type_bounds)]\n+#![feature(binary_heap_into_iter_sorted)]\n+#![feature(binary_heap_drain_sorted)]\n \n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;"}]}