{"sha": "f182c4af8a22df906f6e901cb11a1a804f29f32c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxODJjNGFmOGEyMmRmOTA2ZjZlOTAxY2IxMWExYTgwNGYyOWYzMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-20T09:28:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-20T09:28:25Z"}, "message": "Auto merge of #71923 - csmoe:issue-70818, r=tmandry\n\nCheck non-Send/Sync upvars captured by generator\n\nCloses #70818\nr? @tmandry", "tree": {"sha": "e85bd6034a7fa0d14658ea28e74ea1ccf9d6a804", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e85bd6034a7fa0d14658ea28e74ea1ccf9d6a804"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f182c4af8a22df906f6e901cb11a1a804f29f32c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f182c4af8a22df906f6e901cb11a1a804f29f32c", "html_url": "https://github.com/rust-lang/rust/commit/f182c4af8a22df906f6e901cb11a1a804f29f32c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f182c4af8a22df906f6e901cb11a1a804f29f32c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64ad709ad4d2863b7995d8b9e90a1bedb7d0ccf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/64ad709ad4d2863b7995d8b9e90a1bedb7d0ccf1", "html_url": "https://github.com/rust-lang/rust/commit/64ad709ad4d2863b7995d8b9e90a1bedb7d0ccf1"}, {"sha": "c9e146515ba391410069a6fe3e55a4a1935bc5ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e146515ba391410069a6fe3e55a4a1935bc5ae", "html_url": "https://github.com/rust-lang/rust/commit/c9e146515ba391410069a6fe3e55a4a1935bc5ae"}], "stats": {"total": 275, "additions": 167, "deletions": 108}, "files": [{"sha": "b8771d59dd4bde6367b8585b613cc03b5b4de419", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 135, "deletions": 108, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/f182c4af8a22df906f6e901cb11a1a804f29f32c/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f182c4af8a22df906f6e901cb11a1a804f29f32c/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=f182c4af8a22df906f6e901cb11a1a804f29f32c", "patch": "@@ -25,6 +25,14 @@ use std::fmt;\n use super::InferCtxtPrivExt;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n+#[derive(Debug)]\n+pub enum GeneratorInteriorOrUpvar {\n+    // span of interior type\n+    Interior(Span),\n+    // span of upvar\n+    Upvar(Span),\n+}\n+\n // This trait is public to expose the diagnostics methods to clippy.\n pub trait InferCtxtExt<'tcx> {\n     fn suggest_restricting_param_bound(\n@@ -128,19 +136,15 @@ pub trait InferCtxtExt<'tcx> {\n     fn note_obligation_cause_for_async_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        target_span: Span,\n-        scope_span: &Option<Span>,\n-        await_span: Span,\n-        expr: Option<hir::HirId>,\n-        snippet: String,\n+        interior_or_upvar_span: GeneratorInteriorOrUpvar,\n+        interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         inner_generator_body: Option<&hir::Body<'_>>,\n         outer_generator: Option<DefId>,\n         trait_ref: ty::TraitRef<'_>,\n         target_ty: Ty<'tcx>,\n         tables: &ty::TypeckTables<'_>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n-        from_awaited_ty: Option<Span>,\n     );\n \n     fn note_obligation_cause_code<T>(\n@@ -1205,7 +1209,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 obligation.cause.span={:?}\",\n             obligation.predicate, obligation.cause.span\n         );\n-        let source_map = self.tcx.sess.source_map();\n         let hir = self.tcx.hir();\n \n         // Attempt to detect an async-await error by looking at the obligation causes, looking\n@@ -1354,7 +1357,23 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             );\n             eq\n         };\n-        let target_span = tables\n+\n+        let mut interior_or_upvar_span = None;\n+        let mut interior_extra_info = None;\n+\n+        if let Some(upvars) = self.tcx.upvars(generator_did) {\n+            interior_or_upvar_span = upvars.iter().find_map(|(upvar_id, upvar)| {\n+                let upvar_ty = tables.node_type(*upvar_id);\n+                let upvar_ty = self.resolve_vars_if_possible(&upvar_ty);\n+                if ty_matches(&upvar_ty) {\n+                    Some(GeneratorInteriorOrUpvar::Upvar(upvar.span))\n+                } else {\n+                    None\n+                }\n+            });\n+        };\n+\n+        tables\n             .generator_interior_types\n             .iter()\n             .find(|ty::GeneratorInteriorTypeCause { ty, .. }| ty_matches(ty))\n@@ -1375,39 +1394,28 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .map(|expr| expr.span);\n                 let ty::GeneratorInteriorTypeCause { span, scope_span, yield_span, expr, .. } =\n                     cause;\n-                (\n-                    span,\n-                    source_map.span_to_snippet(*span),\n-                    scope_span,\n-                    yield_span,\n-                    expr,\n-                    from_awaited_ty,\n-                )\n+\n+                interior_or_upvar_span = Some(GeneratorInteriorOrUpvar::Interior(*span));\n+                interior_extra_info = Some((*scope_span, *yield_span, *expr, from_awaited_ty));\n             });\n \n         debug!(\n-            \"maybe_note_obligation_cause_for_async_await: target_ty={:?} \\\n-                generator_interior_types={:?} target_span={:?}\",\n-            target_ty, tables.generator_interior_types, target_span\n+            \"maybe_note_obligation_cause_for_async_await: interior_or_upvar={:?} \\\n+                generator_interior_types={:?}\",\n+            interior_or_upvar_span, tables.generator_interior_types\n         );\n-        if let Some((target_span, Ok(snippet), scope_span, yield_span, expr, from_awaited_ty)) =\n-            target_span\n-        {\n+        if let Some(interior_or_upvar_span) = interior_or_upvar_span {\n             self.note_obligation_cause_for_async_await(\n                 err,\n-                *target_span,\n-                scope_span,\n-                *yield_span,\n-                *expr,\n-                snippet,\n+                interior_or_upvar_span,\n+                interior_extra_info,\n                 generator_body,\n                 outer_generator,\n                 trait_ref,\n                 target_ty,\n                 tables,\n                 obligation,\n                 next_code,\n-                from_awaited_ty,\n             );\n             true\n         } else {\n@@ -1420,19 +1428,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn note_obligation_cause_for_async_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        target_span: Span,\n-        scope_span: &Option<Span>,\n-        yield_span: Span,\n-        expr: Option<hir::HirId>,\n-        snippet: String,\n+        interior_or_upvar_span: GeneratorInteriorOrUpvar,\n+        interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         inner_generator_body: Option<&hir::Body<'_>>,\n         outer_generator: Option<DefId>,\n         trait_ref: ty::TraitRef<'_>,\n         target_ty: Ty<'tcx>,\n         tables: &ty::TypeckTables<'_>,\n         obligation: &PredicateObligation<'tcx>,\n         next_code: Option<&ObligationCauseCode<'tcx>>,\n-        from_awaited_ty: Option<Span>,\n     ) {\n         let source_map = self.tcx.sess.source_map();\n \n@@ -1493,46 +1497,27 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             format!(\"does not implement `{}`\", trait_ref.print_only_trait_path())\n         };\n \n-        if let Some(await_span) = from_awaited_ty {\n-            // The type causing this obligation is one being awaited at await_span.\n-            let mut span = MultiSpan::from_span(await_span);\n-\n-            span.push_span_label(\n-                await_span,\n-                format!(\"await occurs here on type `{}`, which {}\", target_ty, trait_explanation),\n-            );\n-\n-            err.span_note(\n-                span,\n-                &format!(\n-                    \"future {not_trait} as it awaits another future which {not_trait}\",\n-                    not_trait = trait_explanation\n-                ),\n-            );\n-        } else {\n-            // Look at the last interior type to get a span for the `.await`.\n-            debug!(\n-                \"note_obligation_cause_for_async_await generator_interior_types: {:#?}\",\n-                tables.generator_interior_types\n-            );\n+        let mut explain_yield = |interior_span: Span,\n+                                 yield_span: Span,\n+                                 scope_span: Option<Span>| {\n             let mut span = MultiSpan::from_span(yield_span);\n-            span.push_span_label(\n-                yield_span,\n-                format!(\"{} occurs here, with `{}` maybe used later\", await_or_yield, snippet),\n-            );\n-\n-            span.push_span_label(\n-                target_span,\n-                format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n-            );\n-\n-            // If available, use the scope span to annotate the drop location.\n-            if let Some(scope_span) = scope_span {\n+            if let Ok(snippet) = source_map.span_to_snippet(interior_span) {\n                 span.push_span_label(\n-                    source_map.end_point(*scope_span),\n-                    format!(\"`{}` is later dropped here\", snippet),\n+                    yield_span,\n+                    format!(\"{} occurs here, with `{}` maybe used later\", await_or_yield, snippet),\n                 );\n+                // If available, use the scope span to annotate the drop location.\n+                if let Some(scope_span) = scope_span {\n+                    span.push_span_label(\n+                        source_map.end_point(scope_span),\n+                        format!(\"`{}` is later dropped here\", snippet),\n+                    );\n+                }\n             }\n+            span.push_span_label(\n+                interior_span,\n+                format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n+            );\n \n             err.span_note(\n                 span,\n@@ -1541,48 +1526,90 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     future_or_generator, trait_explanation, an_await_or_yield\n                 ),\n             );\n-        }\n-\n-        if let Some(expr_id) = expr {\n-            let expr = hir.expect_expr(expr_id);\n-            debug!(\"target_ty evaluated from {:?}\", expr);\n-\n-            let parent = hir.get_parent_node(expr_id);\n-            if let Some(hir::Node::Expr(e)) = hir.find(parent) {\n-                let parent_span = hir.span(parent);\n-                let parent_did = parent.owner.to_def_id();\n-                // ```rust\n-                // impl T {\n-                //     fn foo(&self) -> i32 {}\n-                // }\n-                // T.foo();\n-                // ^^^^^^^ a temporary `&T` created inside this method call due to `&self`\n-                // ```\n-                //\n-                let is_region_borrow =\n-                    tables.expr_adjustments(expr).iter().any(|adj| adj.is_region_borrow());\n-\n-                // ```rust\n-                // struct Foo(*const u8);\n-                // bar(Foo(std::ptr::null())).await;\n-                //     ^^^^^^^^^^^^^^^^^^^^^ raw-ptr `*T` created inside this struct ctor.\n-                // ```\n-                debug!(\"parent_def_kind: {:?}\", self.tcx.def_kind(parent_did));\n-                let is_raw_borrow_inside_fn_like_call = match self.tcx.def_kind(parent_did) {\n-                    DefKind::Fn | DefKind::Ctor(..) => target_ty.is_unsafe_ptr(),\n-                    _ => false,\n-                };\n+        };\n+        match interior_or_upvar_span {\n+            GeneratorInteriorOrUpvar::Interior(interior_span) => {\n+                if let Some((scope_span, yield_span, expr, from_awaited_ty)) = interior_extra_info {\n+                    if let Some(await_span) = from_awaited_ty {\n+                        // The type causing this obligation is one being awaited at await_span.\n+                        let mut span = MultiSpan::from_span(await_span);\n+                        span.push_span_label(\n+                            await_span,\n+                            format!(\n+                                \"await occurs here on type `{}`, which {}\",\n+                                target_ty, trait_explanation\n+                            ),\n+                        );\n+                        err.span_note(\n+                            span,\n+                            &format!(\n+                                \"future {not_trait} as it awaits another future which {not_trait}\",\n+                                not_trait = trait_explanation\n+                            ),\n+                        );\n+                    } else {\n+                        // Look at the last interior type to get a span for the `.await`.\n+                        debug!(\n+                            \"note_obligation_cause_for_async_await generator_interior_types: {:#?}\",\n+                            tables.generator_interior_types\n+                        );\n+                        explain_yield(interior_span, yield_span, scope_span);\n+                    }\n \n-                if (tables.is_method_call(e) && is_region_borrow)\n-                    || is_raw_borrow_inside_fn_like_call\n-                {\n-                    err.span_help(\n-                        parent_span,\n-                        \"consider moving this into a `let` \\\n+                    if let Some(expr_id) = expr {\n+                        let expr = hir.expect_expr(expr_id);\n+                        debug!(\"target_ty evaluated from {:?}\", expr);\n+\n+                        let parent = hir.get_parent_node(expr_id);\n+                        if let Some(hir::Node::Expr(e)) = hir.find(parent) {\n+                            let parent_span = hir.span(parent);\n+                            let parent_did = parent.owner.to_def_id();\n+                            // ```rust\n+                            // impl T {\n+                            //     fn foo(&self) -> i32 {}\n+                            // }\n+                            // T.foo();\n+                            // ^^^^^^^ a temporary `&T` created inside this method call due to `&self`\n+                            // ```\n+                            //\n+                            let is_region_borrow = tables\n+                                .expr_adjustments(expr)\n+                                .iter()\n+                                .any(|adj| adj.is_region_borrow());\n+\n+                            // ```rust\n+                            // struct Foo(*const u8);\n+                            // bar(Foo(std::ptr::null())).await;\n+                            //     ^^^^^^^^^^^^^^^^^^^^^ raw-ptr `*T` created inside this struct ctor.\n+                            // ```\n+                            debug!(\"parent_def_kind: {:?}\", self.tcx.def_kind(parent_did));\n+                            let is_raw_borrow_inside_fn_like_call =\n+                                match self.tcx.def_kind(parent_did) {\n+                                    DefKind::Fn | DefKind::Ctor(..) => target_ty.is_unsafe_ptr(),\n+                                    _ => false,\n+                                };\n+\n+                            if (tables.is_method_call(e) && is_region_borrow)\n+                                || is_raw_borrow_inside_fn_like_call\n+                            {\n+                                err.span_help(\n+                                    parent_span,\n+                                    \"consider moving this into a `let` \\\n                         binding to create a shorter lived borrow\",\n-                    );\n+                                );\n+                            }\n+                        }\n+                    }\n                 }\n             }\n+            GeneratorInteriorOrUpvar::Upvar(upvar_span) => {\n+                let mut span = MultiSpan::from_span(upvar_span);\n+                span.push_span_label(\n+                    upvar_span,\n+                    format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n+                );\n+                err.span_note(span, &format!(\"captured value {}\", trait_explanation));\n+            }\n         }\n \n         // Add a note for the item obligation that remains - normally a note pointing to the"}, {"sha": "0609e4fc0817073f0782d9d0ed5b748f51561c54", "filename": "src/test/ui/async-await/issue-70818.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f182c4af8a22df906f6e901cb11a1a804f29f32c/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f182c4af8a22df906f6e901cb11a1a804f29f32c/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs?ref=f182c4af8a22df906f6e901cb11a1a804f29f32c", "patch": "@@ -0,0 +1,9 @@\n+// edition:2018\n+\n+use std::future::Future;\n+fn foo<T: Send, U>(ty: T, ty1: U) -> impl Future<Output = (T, U)> + Send {\n+//~^ Error future cannot be sent between threads safely\n+    async { (ty, ty1) }\n+}\n+\n+fn main() {}"}, {"sha": "5fb772fa10acbdb46a1707233bfc12204b50735f", "filename": "src/test/ui/async-await/issue-70818.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f182c4af8a22df906f6e901cb11a1a804f29f32c/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f182c4af8a22df906f6e901cb11a1a804f29f32c/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr?ref=f182c4af8a22df906f6e901cb11a1a804f29f32c", "patch": "@@ -0,0 +1,23 @@\n+error: future cannot be sent between threads safely\n+  --> $DIR/issue-70818.rs:4:38\n+   |\n+LL | fn foo<T: Send, U>(ty: T, ty1: U) -> impl Future<Output = (T, U)> + Send {\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n+LL |\n+LL |     async { (ty, ty1) }\n+   |     ------------------- this returned value is of type `impl std::future::Future`\n+   |\n+   = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `U`\n+note: captured value is not `Send`\n+  --> $DIR/issue-70818.rs:6:18\n+   |\n+LL |     async { (ty, ty1) }\n+   |                  ^^^ has type `U` which is not `Send`\n+   = note: the return type of a function must have a statically known size\n+help: consider restricting type parameter `U`\n+   |\n+LL | fn foo<T: Send, U: std::marker::Send>(ty: T, ty1: U) -> impl Future<Output = (T, U)> + Send {\n+   |                  ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}