{"sha": "3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmOTJlOGQ4OTg2MWYwZjU0MDhhZDkzODFhNzQ2N2VjNmU3ZDc2YmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-14T16:56:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-14T16:56:15Z"}, "message": "Auto merge of #46455 - petrochenkov:pimpl, r=nikomatsakis\n\nsyntax: Rewrite parsing of impls\n\nProperly parse impls for the never type `!`\nRecover from missing `for` in `impl Trait for Type`\nProhibit inherent default impls and default impls of auto traits (https://github.com/rust-lang/rust/issues/37653#issuecomment-348687794, https://github.com/rust-lang/rust/issues/37653#issuecomment-348688785)\nChange wording in more diagnostics to use \"auto traits\"\nFix some spans in diagnostics\nSome other minor code cleanups in the parser\nDisambiguate generics and qualified paths in impls (parse `impl <Type as Trait>::AssocTy { ... }`)\nReplace the future-compatibility hack from https://github.com/rust-lang/rust/pull/38268 with actually parsing generic parameters\nAdd a test for https://github.com/rust-lang/rust/issues/46438", "tree": {"sha": "75ce47d50e9c682bc26d8e601b6d64a1c3d26092", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75ce47d50e9c682bc26d8e601b6d64a1c3d26092"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "html_url": "https://github.com/rust-lang/rust/commit/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adc9d86363e0997f8378ea0260dfec3a9d09bcf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/adc9d86363e0997f8378ea0260dfec3a9d09bcf0", "html_url": "https://github.com/rust-lang/rust/commit/adc9d86363e0997f8378ea0260dfec3a9d09bcf0"}, {"sha": "60c48dd16ae579e6f2e0ae74862b0420ff471da9", "url": "https://api.github.com/repos/rust-lang/rust/commits/60c48dd16ae579e6f2e0ae74862b0420ff471da9", "html_url": "https://github.com/rust-lang/rust/commit/60c48dd16ae579e6f2e0ae74862b0420ff471da9"}], "stats": {"total": 672, "additions": 382, "deletions": 290}, "files": [{"sha": "1af7bd46ad4135bc21be45f9dd2550b35f57d622", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -1502,8 +1502,8 @@ impl<'a> LoweringContext<'a> {\n                      fn_def_id: Option<DefId>,\n                      impl_trait_return_allow: bool)\n                      -> P<hir::FnDecl> {\n-        // NOTE: The two last paramters here have to do with impl Trait. If fn_def_id is Some,\n-        //       then impl Trait arguments are lowered into generic paramters on the given\n+        // NOTE: The two last parameters here have to do with impl Trait. If fn_def_id is Some,\n+        //       then impl Trait arguments are lowered into generic parameters on the given\n         //       fn_def_id, otherwise impl Trait is disallowed. (for now)\n         //\n         //       Furthermore, if impl_trait_return_allow is true, then impl Trait may be used in"}, {"sha": "dd7e6a5c1c8024731fb166094beb33db7c75dec9", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -215,24 +215,36 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n     fn visit_item(&mut self, item: &'a Item) {\n         match item.node {\n-            ItemKind::Impl(.., Some(..), ref ty, ref impl_items) => {\n+            ItemKind::Impl(unsafety, polarity, _, _, Some(..), ref ty, ref impl_items) => {\n                 self.invalid_visibility(&item.vis, item.span, None);\n                 if ty.node == TyKind::Err {\n                     self.err_handler()\n                         .struct_span_err(item.span, \"`impl Trait for .. {}` is an obsolete syntax\")\n                         .help(\"use `auto trait Trait {}` instead\").emit();\n                 }\n+                if unsafety == Unsafety::Unsafe && polarity == ImplPolarity::Negative {\n+                    span_err!(self.session, item.span, E0198, \"negative impls cannot be unsafe\");\n+                }\n                 for impl_item in impl_items {\n                     self.invalid_visibility(&impl_item.vis, impl_item.span, None);\n                     if let ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         self.check_trait_fn_not_const(sig.constness);\n                     }\n                 }\n             }\n-            ItemKind::Impl(.., None, _, _) => {\n+            ItemKind::Impl(unsafety, polarity, defaultness, _, None, _, _) => {\n                 self.invalid_visibility(&item.vis,\n                                         item.span,\n                                         Some(\"place qualifiers on individual impl items instead\"));\n+                if unsafety == Unsafety::Unsafe {\n+                    span_err!(self.session, item.span, E0197, \"inherent impls cannot be unsafe\");\n+                }\n+                if polarity == ImplPolarity::Negative {\n+                    self.err_handler().span_err(item.span, \"inherent impls cannot be negative\");\n+                }\n+                if defaultness == Defaultness::Default {\n+                    self.err_handler().span_err(item.span, \"inherent impls cannot be default\");\n+                }\n             }\n             ItemKind::ForeignMod(..) => {\n                 self.invalid_visibility(&item.vis,"}, {"sha": "743f7b7326e9e5c2526d4a09949fba928f549544", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -82,6 +82,52 @@ extern {\n ```\n \"##,\n \n+E0197: r##\"\n+Inherent implementations (one that do not implement a trait but provide\n+methods associated with a type) are always safe because they are not\n+implementing an unsafe trait. Removing the `unsafe` keyword from the inherent\n+implementation will resolve this error.\n+\n+```compile_fail,E0197\n+struct Foo;\n+\n+// this will cause this error\n+unsafe impl Foo { }\n+// converting it to this will fix it\n+impl Foo { }\n+```\n+\"##,\n+\n+E0198: r##\"\n+A negative implementation is one that excludes a type from implementing a\n+particular trait. Not being able to use a trait is always a safe operation,\n+so negative implementations are always safe and never need to be marked as\n+unsafe.\n+\n+```compile_fail\n+#![feature(optin_builtin_traits)]\n+\n+struct Foo;\n+\n+// unsafe is unnecessary\n+unsafe impl !Clone for Foo { }\n+```\n+\n+This will compile:\n+\n+```ignore (ignore auto_trait future compatibility warning)\n+#![feature(optin_builtin_traits)]\n+\n+struct Foo;\n+\n+auto trait Enterprise {}\n+\n+impl !Enterprise for Foo { }\n+```\n+\n+Please note that negative impls are only allowed for auto traits.\n+\"##,\n+\n E0265: r##\"\n This error indicates that a static or constant references itself.\n All statics and constants need to resolve to a value in an acyclic manner."}, {"sha": "3668fc46ddc27b0e0fbba290fa762cc4f809f757", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -107,16 +107,21 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             //\n             // won't be allowed unless there's an *explicit* implementation of `Send`\n             // for `T`\n-            hir::ItemImpl(_, hir::ImplPolarity::Positive, _, _,\n-                          ref trait_ref, ref self_ty, _) => {\n-                self.check_impl(item, self_ty, trait_ref);\n-            }\n-            hir::ItemImpl(_, hir::ImplPolarity::Negative, _, _, Some(_), ..) => {\n-                // FIXME(#27579) what amount of WF checking do we need for neg impls?\n-\n-                let trait_ref = tcx.impl_trait_ref(tcx.hir.local_def_id(item.id)).unwrap();\n-                if !tcx.trait_is_auto(trait_ref.def_id) {\n-                    error_192(tcx, item.span);\n+            hir::ItemImpl(_, polarity, defaultness, _, ref trait_ref, ref self_ty, _) => {\n+                let is_auto = tcx.impl_trait_ref(tcx.hir.local_def_id(item.id))\n+                                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n+                if let (hir::Defaultness::Default { .. }, true) = (defaultness, is_auto) {\n+                    tcx.sess.span_err(item.span, \"impls of auto traits cannot be default\");\n+                }\n+                if polarity == hir::ImplPolarity::Positive {\n+                    self.check_impl(item, self_ty, trait_ref);\n+                } else {\n+                    // FIXME(#27579) what amount of WF checking do we need for neg impls?\n+                    if trait_ref.is_some() && !is_auto {\n+                        span_err!(tcx.sess, item.span, E0192,\n+                                  \"negative impls are only allowed for \\\n+                                   auto traits (e.g., `Send` and `Sync`)\")\n+                    }\n                 }\n             }\n             hir::ItemFn(..) => {\n@@ -661,12 +666,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn error_192(tcx: TyCtxt, span: Span) {\n-    span_err!(tcx.sess, span, E0192,\n-              \"negative impls are only allowed for traits with \\\n-               default impls (e.g., `Send` and `Sync`)\")\n-}\n-\n fn error_392<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, param_name: ast::Name)\n                        -> DiagnosticBuilder<'tcx> {\n     let mut err = struct_span_err!(tcx.sess, span, E0392,"}, {"sha": "2b81c82bc2945f9176dc34fbeea7b551e66eca56", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -93,23 +93,11 @@ struct InherentCollect<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let (unsafety, ty) = match item.node {\n-            hir::ItemImpl(unsafety, .., None, ref ty, _) => (unsafety, ty),\n+        let ty = match item.node {\n+            hir::ItemImpl(.., None, ref ty, _) => ty,\n             _ => return\n         };\n \n-        match unsafety {\n-            hir::Unsafety::Normal => {\n-                // OK\n-            }\n-            hir::Unsafety::Unsafe => {\n-                span_err!(self.tcx.sess,\n-                          item.span,\n-                          E0197,\n-                          \"inherent impls cannot be declared as unsafe\");\n-            }\n-        }\n-\n         let def_id = self.tcx.hir.local_def_id(item.id);\n         let self_ty = self.tcx.type_of(def_id);\n         let lang_items = self.tcx.lang_items();"}, {"sha": "c2dfd798a3c4a7d9be89fde45bebedb98b2dc518", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -67,16 +67,15 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                     }\n                 }\n \n-                // In addition to the above rules, we restrict impls of defaulted traits\n+                // In addition to the above rules, we restrict impls of auto traits\n                 // so that they can only be implemented on nominal types, such as structs,\n                 // enums or foreign types. To see why this restriction exists, consider the\n-                // following example (#22978). Imagine that crate A defines a defaulted trait\n+                // following example (#22978). Imagine that crate A defines an auto trait\n                 // `Foo` and a fn that operates on pairs of types:\n                 //\n                 // ```\n                 // // Crate A\n-                // trait Foo { }\n-                // impl Foo for .. { }\n+                // auto trait Foo { }\n                 // fn two_foos<A:Foo,B:Foo>(..) {\n                 //     one_foo::<(A,B)>(..)\n                 // }"}, {"sha": "4aa876e85b69a5e2d0e1ee60e2c1f2cc43185fbb", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -37,14 +37,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n                 let trait_def = self.tcx.trait_def(trait_ref.def_id);\n                 let unsafe_attr = impl_generics.and_then(|g| g.carries_unsafe_attr());\n                 match (trait_def.unsafety, unsafe_attr, unsafety, polarity) {\n-                    (_, _, Unsafety::Unsafe, hir::ImplPolarity::Negative) => {\n-                        span_err!(self.tcx.sess,\n-                                  item.span,\n-                                  E0198,\n-                                  \"negative implementations are not unsafe\");\n-                    }\n-\n-                    (Unsafety::Normal, None, Unsafety::Unsafe, _) => {\n+                    (Unsafety::Normal, None, Unsafety::Unsafe, hir::ImplPolarity::Positive) => {\n                         span_err!(self.tcx.sess,\n                                   item.span,\n                                   E0199,\n@@ -69,6 +62,10 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n                                   g.attr_name());\n                     }\n \n+                    (_, _, Unsafety::Unsafe, hir::ImplPolarity::Negative) => {\n+                        // Reported in AST validation\n+                        self.tcx.sess.delay_span_bug(item.span, \"unsafe negative impl\");\n+                    }\n                     (_, _, Unsafety::Normal, hir::ImplPolarity::Negative) |\n                     (Unsafety::Unsafe, _, Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n                     (Unsafety::Normal, Some(_), Unsafety::Unsafe, hir::ImplPolarity::Positive) |"}, {"sha": "1913b940c08fe2db38d48fbe297c00cb322bca6a", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 47, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -1715,7 +1715,7 @@ type Foo = Trait<Bar=i32>; // ok!\n \"##,\n \n E0192: r##\"\n-Negative impls are only allowed for traits with default impls. For more\n+Negative impls are only allowed for auto traits. For more\n information see the [opt-in builtin traits RFC][RFC 19].\n \n [RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md\n@@ -1821,52 +1821,6 @@ impl Trait for Foo {\n ```\n \"##,\n \n-E0197: r##\"\n-Inherent implementations (one that do not implement a trait but provide\n-methods associated with a type) are always safe because they are not\n-implementing an unsafe trait. Removing the `unsafe` keyword from the inherent\n-implementation will resolve this error.\n-\n-```compile_fail,E0197\n-struct Foo;\n-\n-// this will cause this error\n-unsafe impl Foo { }\n-// converting it to this will fix it\n-impl Foo { }\n-```\n-\"##,\n-\n-E0198: r##\"\n-A negative implementation is one that excludes a type from implementing a\n-particular trait. Not being able to use a trait is always a safe operation,\n-so negative implementations are always safe and never need to be marked as\n-unsafe.\n-\n-```compile_fail\n-#![feature(optin_builtin_traits)]\n-\n-struct Foo;\n-\n-// unsafe is unnecessary\n-unsafe impl !Clone for Foo { }\n-```\n-\n-This will compile:\n-\n-```\n-#![feature(optin_builtin_traits)]\n-\n-struct Foo;\n-\n-auto trait Enterprise {}\n-\n-impl !Enterprise for Foo { }\n-```\n-\n-Please note that negative impls are only allowed for traits with default impls.\n-\"##,\n-\n E0199: r##\"\n Safe traits should not have unsafe implementations, therefore marking an\n implementation for a safe trait unsafe will cause a compiler error. Removing"}, {"sha": "e7565d357397cbce0f1a91eed9bb00d6db582e9a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 156, "deletions": 167, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -71,7 +71,7 @@ bitflags! {\n     }\n }\n \n-type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute> >);\n+type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute>>);\n \n /// How to parse a path.\n #[derive(Copy, Clone, PartialEq)]\n@@ -151,10 +151,9 @@ macro_rules! maybe_whole {\n     };\n }\n \n-fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)\n-                -> Vec<Attribute> {\n-    if let Some(ref attrs) = rhs {\n-        lhs.extend(attrs.iter().cloned())\n+fn maybe_append(mut lhs: Vec<Attribute>, mut rhs: Option<Vec<Attribute>>) -> Vec<Attribute> {\n+    if let Some(ref mut rhs) = rhs {\n+        lhs.append(rhs);\n     }\n     lhs\n }\n@@ -1347,7 +1346,7 @@ impl<'a> Parser<'a> {\n         Function Style\n         */\n \n-        let unsafety = self.parse_unsafety()?;\n+        let unsafety = self.parse_unsafety();\n         let abi = if self.eat_keyword(keywords::Extern) {\n             self.parse_opt_abi()?.unwrap_or(Abi::C)\n         } else {\n@@ -1370,11 +1369,12 @@ impl<'a> Parser<'a> {\n         })))\n     }\n \n-    pub fn parse_unsafety(&mut self) -> PResult<'a, Unsafety> {\n+    /// Parse unsafety: `unsafe` or nothing.\n+    fn parse_unsafety(&mut self) -> Unsafety {\n         if self.eat_keyword(keywords::Unsafe) {\n-            return Ok(Unsafety::Unsafe);\n+            Unsafety::Unsafe\n         } else {\n-            return Ok(Unsafety::Normal);\n+            Unsafety::Normal\n         }\n     }\n \n@@ -4094,28 +4094,6 @@ impl<'a> Parser<'a> {\n          self.look_ahead(2, |t| t.is_keyword(keywords::Trait)))\n     }\n \n-    fn is_defaultness(&self) -> bool {\n-        // `pub` is included for better error messages\n-        self.token.is_keyword(keywords::Default) &&\n-        self.look_ahead(1, |t| t.is_keyword(keywords::Impl) ||\n-                        t.is_keyword(keywords::Const) ||\n-                        t.is_keyword(keywords::Fn) ||\n-                        t.is_keyword(keywords::Unsafe) ||\n-                        t.is_keyword(keywords::Extern) ||\n-                        t.is_keyword(keywords::Type) ||\n-                        t.is_keyword(keywords::Pub))\n-    }\n-\n-    fn eat_defaultness(&mut self) -> bool {\n-        let is_defaultness = self.is_defaultness();\n-        if is_defaultness {\n-            self.bump()\n-        } else {\n-            self.expected_tokens.push(TokenType::Keyword(keywords::Default));\n-        }\n-        is_defaultness\n-    }\n-\n     fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility, lo: Span)\n                      -> PResult<'a, Option<P<Item>>> {\n         let token_lo = self.span;\n@@ -4794,21 +4772,13 @@ impl<'a> Parser<'a> {\n         }\n         let lo = self.prev_span;\n \n-        // This is a temporary future proofing.\n-        //\n         // We are considering adding generics to the `where` keyword as an alternative higher-rank\n         // parameter syntax (as in `where<'a>` or `where<T>`. To avoid that being a breaking\n-        // change, for now we refuse to parse `where < (ident | lifetime) (> | , | :)`.\n-        if token::Lt == self.token {\n-            let ident_or_lifetime = self.look_ahead(1, |t| t.is_ident() || t.is_lifetime());\n-            if ident_or_lifetime {\n-                let gt_comma_or_colon = self.look_ahead(2, |t| {\n-                    *t == token::Gt || *t == token::Comma || *t == token::Colon\n-                });\n-                if gt_comma_or_colon {\n-                    self.span_err(self.span, \"syntax `where<T>` is reserved for future use\");\n-                }\n-            }\n+        // change we parse those generics now, but report an error.\n+        if self.choose_generics_over_qpath() {\n+            let generics = self.parse_generics()?;\n+            self.span_err(generics.span,\n+                          \"generic parameters on `where` clauses are reserved for future use\");\n         }\n \n         loop {\n@@ -5126,7 +5096,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_fn(&mut self,\n                      unsafety: Unsafety,\n                      constness: Spanned<Constness>,\n-                     abi: abi::Abi)\n+                     abi: Abi)\n                      -> PResult<'a, ItemInfo> {\n         let (ident, mut generics) = self.parse_fn_header()?;\n         let decl = self.parse_fn_decl(false)?;\n@@ -5150,13 +5120,10 @@ impl<'a> Parser<'a> {\n     /// - `const unsafe fn`\n     /// - `extern fn`\n     /// - etc\n-    pub fn parse_fn_front_matter(&mut self)\n-                                 -> PResult<'a, (Spanned<ast::Constness>,\n-                                                ast::Unsafety,\n-                                                abi::Abi)> {\n+    pub fn parse_fn_front_matter(&mut self) -> PResult<'a, (Spanned<Constness>, Unsafety, Abi)> {\n         let is_const_fn = self.eat_keyword(keywords::Const);\n         let const_span = self.prev_span;\n-        let unsafety = self.parse_unsafety()?;\n+        let unsafety = self.parse_unsafety();\n         let (constness, unsafety, abi) = if is_const_fn {\n             (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n         } else {\n@@ -5191,7 +5158,7 @@ impl<'a> Parser<'a> {\n                         mut attrs: Vec<Attribute>) -> PResult<'a, ImplItem> {\n         let lo = self.span;\n         let vis = self.parse_visibility(false)?;\n-        let defaultness = self.parse_defaultness()?;\n+        let defaultness = self.parse_defaultness();\n         let (name, node, generics) = if self.eat_keyword(keywords::Type) {\n             // This parses the grammar:\n             //     ImplItemAssocTy = Ident [\"<\"...\">\"] [\"where\" ...] \"=\" Ty \";\"\n@@ -5284,7 +5251,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a method or a macro invocation in a trait impl.\n     fn parse_impl_method(&mut self, vis: &Visibility, at_end: &mut bool)\n-                         -> PResult<'a, (Ident, Vec<ast::Attribute>, ast::Generics,\n+                         -> PResult<'a, (Ident, Vec<Attribute>, ast::Generics,\n                              ast::ImplItemKind)> {\n         // code copied from parse_macro_use_or_failure... abstraction!\n         if self.token.is_path_start() && !self.is_extern_non_path() {\n@@ -5373,83 +5340,123 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses items implementations variants\n-    ///    impl<T> Foo { ... }\n-    ///    impl<T> ToString for &'static T { ... }\n-    fn parse_item_impl(&mut self,\n-                       unsafety: ast::Unsafety,\n-                       defaultness: Defaultness) -> PResult<'a, ItemInfo> {\n+    fn choose_generics_over_qpath(&self) -> bool {\n+        // There's an ambiguity between generic parameters and qualified paths in impls.\n+        // If we see `<` it may start both, so we have to inspect some following tokens.\n+        // The following combinations can only start generics,\n+        // but not qualified paths (with one exception):\n+        //     `<` `>` - empty generic parameters\n+        //     `<` `#` - generic parameters with attributes\n+        //     `<` (LIFETIME|IDENT) `>` - single generic parameter\n+        //     `<` (LIFETIME|IDENT) `,` - first generic parameter in a list\n+        //     `<` (LIFETIME|IDENT) `:` - generic parameter with bounds\n+        //     `<` (LIFETIME|IDENT) `=` - generic parameter with a default\n+        // The only truly ambiguous case is\n+        //     `<` IDENT `>` `::` IDENT ...\n+        // we disambiguate it in favor of generics (`impl<T> ::absolute::Path<T> { ... }`)\n+        // because this is what almost always expected in practice, qualified paths in impls\n+        // (`impl <Type>::AssocTy { ... }`) aren't even allowed by type checker at the moment.\n+        self.token == token::Lt &&\n+            (self.look_ahead(1, |t| t == &token::Pound || t == &token::Gt) ||\n+             self.look_ahead(1, |t| t.is_lifetime() || t.is_ident()) &&\n+                self.look_ahead(2, |t| t == &token::Gt || t == &token::Comma ||\n+                                       t == &token::Colon || t == &token::Eq))\n+    }\n+\n+    fn parse_impl_body(&mut self) -> PResult<'a, (Vec<ImplItem>, Vec<Attribute>)> {\n+        self.expect(&token::OpenDelim(token::Brace))?;\n+        let attrs = self.parse_inner_attributes()?;\n \n-        // First, parse type parameters if necessary.\n-        let mut generics = self.parse_generics()?;\n+        let mut impl_items = Vec::new();\n+        while !self.eat(&token::CloseDelim(token::Brace)) {\n+            let mut at_end = false;\n+            match self.parse_impl_item(&mut at_end) {\n+                Ok(impl_item) => impl_items.push(impl_item),\n+                Err(mut err) => {\n+                    err.emit();\n+                    if !at_end {\n+                        self.recover_stmt_(SemiColonMode::Break, BlockMode::Break);\n+                    }\n+                }\n+            }\n+        }\n+        Ok((impl_items, attrs))\n+    }\n \n-        // Special case: if the next identifier that follows is '(', don't\n-        // allow this to be parsed as a trait.\n-        let could_be_trait = self.token != token::OpenDelim(token::Paren);\n+    /// Parses an implementation item, `impl` keyword is already parsed.\n+    ///    impl<'a, T> TYPE { /* impl items */ }\n+    ///    impl<'a, T> TRAIT for TYPE { /* impl items */ }\n+    ///    impl<'a, T> !TRAIT for TYPE { /* impl items */ }\n+    /// We actually parse slightly more relaxed grammar for better error reporting and recovery.\n+    ///     `impl` GENERICS `!`? TYPE `for`? (TYPE | `..`) (`where` PREDICATES)? `{` BODY `}`\n+    ///     `impl` GENERICS `!`? TYPE (`where` PREDICATES)? `{` BODY `}`\n+    fn parse_item_impl(&mut self, unsafety: Unsafety, defaultness: Defaultness)\n+                       -> PResult<'a, ItemInfo> {\n+        // First, parse generic parameters if necessary.\n+        let mut generics = if self.choose_generics_over_qpath() {\n+            self.parse_generics()?\n+        } else {\n+            ast::Generics::default()\n+        };\n \n-        let neg_span = self.span;\n-        let polarity = if self.eat(&token::Not) {\n+        // Disambiguate `impl !Trait for Type { ... }` and `impl ! { ... }` for the never type.\n+        let polarity = if self.check(&token::Not) && self.look_ahead(1, |t| t.can_begin_type()) {\n+            self.bump(); // `!`\n             ast::ImplPolarity::Negative\n         } else {\n             ast::ImplPolarity::Positive\n         };\n \n-        // Parse the trait.\n-        let mut ty = self.parse_ty()?;\n-\n-        // Parse traits, if necessary.\n-        let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n-            // New-style trait. Reinterpret the type as a trait.\n-            match ty.node {\n-                TyKind::Path(None, ref path) => {\n-                    Some(TraitRef {\n-                        path: (*path).clone(),\n-                        ref_id: ty.id,\n-                    })\n-                }\n-                _ => {\n-                    self.span_err(ty.span, \"not a trait\");\n-                    None\n-                }\n-            }\n+        // Parse both types and traits as a type, then reinterpret if necessary.\n+        let ty_first = self.parse_ty()?;\n+\n+        // If `for` is missing we try to recover.\n+        let has_for = self.eat_keyword(keywords::For);\n+        let missing_for_span = self.prev_span.between(self.span);\n+\n+        let ty_second = if self.token == token::DotDot {\n+            // We need to report this error after `cfg` expansion for compatibility reasons\n+            self.bump(); // `..`, do not add it to expected tokens\n+            Some(P(Ty { node: TyKind::Err, span: self.prev_span, id: ast::DUMMY_NODE_ID }))\n+        } else if has_for || self.token.can_begin_type() {\n+            Some(self.parse_ty()?)\n         } else {\n-            if polarity == ast::ImplPolarity::Negative {\n-                // This is a negated type implementation\n-                // `impl !MyType {}`, which is not allowed.\n-                self.span_err(neg_span, \"inherent implementation can't be negated\");\n-            }\n             None\n         };\n \n-        if opt_trait.is_some() {\n-            ty = if self.eat(&token::DotDot) {\n-                P(Ty { node: TyKind::Err, span: self.prev_span, id: ast::DUMMY_NODE_ID })\n-            } else {\n-                self.parse_ty()?\n-            }\n-        }\n         generics.where_clause = self.parse_where_clause()?;\n \n-        self.expect(&token::OpenDelim(token::Brace))?;\n-        let attrs = self.parse_inner_attributes()?;\n+        let (impl_items, attrs) = self.parse_impl_body()?;\n \n-        let mut impl_items = vec![];\n-        while !self.eat(&token::CloseDelim(token::Brace)) {\n-            let mut at_end = false;\n-            match self.parse_impl_item(&mut at_end) {\n-                Ok(item) => impl_items.push(item),\n-                Err(mut e) => {\n-                    e.emit();\n-                    if !at_end {\n-                        self.recover_stmt_(SemiColonMode::Break, BlockMode::Break);\n-                    }\n+        let item_kind = match ty_second {\n+            Some(ty_second) => {\n+                // impl Trait for Type\n+                if !has_for {\n+                    self.span_err(missing_for_span, \"missing `for` in a trait impl\");\n                 }\n+\n+                let ty_first = ty_first.into_inner();\n+                let path = match ty_first.node {\n+                    // This notably includes paths passed through `ty` macro fragments (#46438).\n+                    TyKind::Path(None, path) => path,\n+                    _ => {\n+                        self.span_err(ty_first.span, \"expected a trait, found type\");\n+                        ast::Path::from_ident(ty_first.span, keywords::Invalid.ident())\n+                    }\n+                };\n+                let trait_ref = TraitRef { path, ref_id: ty_first.id };\n+\n+                ItemKind::Impl(unsafety, polarity, defaultness,\n+                               generics, Some(trait_ref), ty_second, impl_items)\n             }\n-        }\n+            None => {\n+                // impl Type\n+                ItemKind::Impl(unsafety, polarity, defaultness,\n+                               generics, None, ty_first, impl_items)\n+            }\n+        };\n \n-        Ok((keywords::Invalid.ident(),\n-            ItemKind::Impl(unsafety, polarity, defaultness, generics, opt_trait, ty, impl_items),\n-            Some(attrs)))\n+        Ok((keywords::Invalid.ident(), item_kind, Some(attrs)))\n     }\n \n     fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<GenericParam>> {\n@@ -5722,12 +5729,21 @@ impl<'a> Parser<'a> {\n         Ok(Visibility::Public)\n     }\n \n-    /// Parse defaultness: DEFAULT or nothing\n-    fn parse_defaultness(&mut self) -> PResult<'a, Defaultness> {\n-        if self.eat_defaultness() {\n-            Ok(Defaultness::Default)\n+    /// Parse defaultness: `default` or nothing.\n+    fn parse_defaultness(&mut self) -> Defaultness {\n+        // `pub` is included for better error messages\n+        if self.check_keyword(keywords::Default) &&\n+           self.look_ahead(1, |t| t.is_keyword(keywords::Impl) ||\n+                                  t.is_keyword(keywords::Const) ||\n+                                  t.is_keyword(keywords::Fn) ||\n+                                  t.is_keyword(keywords::Unsafe) ||\n+                                  t.is_keyword(keywords::Extern) ||\n+                                  t.is_keyword(keywords::Type) ||\n+                                  t.is_keyword(keywords::Pub)) {\n+            self.bump(); // `default`\n+            Defaultness::Default\n         } else {\n-            Ok(Defaultness::Final)\n+            Defaultness::Final\n         }\n     }\n \n@@ -5797,7 +5813,7 @@ impl<'a> Parser<'a> {\n                 let (module, mut attrs) =\n                     self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?;\n                 if warn {\n-                    let attr = ast::Attribute {\n+                    let attr = Attribute {\n                         id: attr::mk_attr_id(),\n                         style: ast::AttrStyle::Outer,\n                         path: ast::Path::from_ident(syntax_pos::DUMMY_SP,\n@@ -5837,7 +5853,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn submod_path_from_attr(attrs: &[ast::Attribute], dir_path: &Path) -> Option<PathBuf> {\n+    pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n         attr::first_attr_value_str_by_name(attrs, \"path\").map(|d| dir_path.join(&d.as_str()))\n     }\n \n@@ -5906,7 +5922,7 @@ impl<'a> Parser<'a> {\n \n     fn submod_path(&mut self,\n                    id: ast::Ident,\n-                   outer_attrs: &[ast::Attribute],\n+                   outer_attrs: &[Attribute],\n                    id_sp: Span)\n                    -> PResult<'a, ModulePathSuccess> {\n         if let Some(path) = Parser::submod_path_from_attr(outer_attrs, &self.directory.path) {\n@@ -5999,7 +6015,7 @@ impl<'a> Parser<'a> {\n                     directory_ownership: DirectoryOwnership,\n                     name: String,\n                     id_sp: Span)\n-                    -> PResult<'a, (ast::ItemKind, Vec<ast::Attribute> )> {\n+                    -> PResult<'a, (ast::ItemKind, Vec<Attribute> )> {\n         let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n         if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n             let mut err = String::from(\"circular modules: \");\n@@ -6122,7 +6138,7 @@ impl<'a> Parser<'a> {\n     /// extern {}\n     fn parse_item_foreign_mod(&mut self,\n                               lo: Span,\n-                              opt_abi: Option<abi::Abi>,\n+                              opt_abi: Option<Abi>,\n                               visibility: Visibility,\n                               mut attrs: Vec<Attribute>)\n                               -> PResult<'a, P<Item>> {\n@@ -6225,7 +6241,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a string as an ABI spec on an extern type or module. Consumes\n     /// the `extern` keyword, if one is found.\n-    fn parse_opt_abi(&mut self) -> PResult<'a, Option<abi::Abi>> {\n+    fn parse_opt_abi(&mut self) -> PResult<'a, Option<Abi>> {\n         match self.token {\n             token::Literal(token::Str_(s), suf) | token::Literal(token::StrRaw(s, _), suf) => {\n                 let sp = self.span;\n@@ -6330,11 +6346,7 @@ impl<'a> Parser<'a> {\n                 || (self.check_keyword(keywords::Unsafe)\n                     && self.look_ahead(1, |t| t.is_keyword(keywords::Fn))) {\n                 // CONST FUNCTION ITEM\n-                let unsafety = if self.eat_keyword(keywords::Unsafe) {\n-                    Unsafety::Unsafe\n-                } else {\n-                    Unsafety::Normal\n-                };\n+                let unsafety = self.parse_unsafety();\n                 self.bump();\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(unsafety,\n@@ -6370,7 +6382,7 @@ impl<'a> Parser<'a> {\n             self.look_ahead(1, |t| t.is_keyword(keywords::Auto)))\n         {\n             // UNSAFE TRAIT ITEM\n-            self.expect_keyword(keywords::Unsafe)?;\n+            self.bump(); // `unsafe`\n             let is_auto = if self.eat_keyword(keywords::Trait) {\n                 IsAuto::No\n             } else {\n@@ -6379,7 +6391,7 @@ impl<'a> Parser<'a> {\n                 IsAuto::Yes\n             };\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_trait(is_auto, ast::Unsafety::Unsafe)?;\n+                self.parse_item_trait(is_auto, Unsafety::Unsafe)?;\n             let prev_span = self.prev_span;\n             let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n@@ -6388,26 +6400,21 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n-        if (self.check_keyword(keywords::Unsafe) &&\n-            self.look_ahead(1, |t| t.is_keyword(keywords::Impl))) ||\n-           (self.check_keyword(keywords::Default) &&\n-            self.look_ahead(1, |t| t.is_keyword(keywords::Unsafe)) &&\n-            self.look_ahead(2, |t| t.is_keyword(keywords::Impl)))\n-        {\n+        if self.check_keyword(keywords::Impl) ||\n+           self.check_keyword(keywords::Unsafe) &&\n+                self.look_ahead(1, |t| t.is_keyword(keywords::Impl)) ||\n+           self.check_keyword(keywords::Default) &&\n+                self.look_ahead(1, |t| t.is_keyword(keywords::Impl)) ||\n+           self.check_keyword(keywords::Default) &&\n+                self.look_ahead(1, |t| t.is_keyword(keywords::Unsafe)) {\n             // IMPL ITEM\n-            let defaultness = self.parse_defaultness()?;\n-            self.expect_keyword(keywords::Unsafe)?;\n+            let defaultness = self.parse_defaultness();\n+            let unsafety = self.parse_unsafety();\n             self.expect_keyword(keywords::Impl)?;\n-            let (ident,\n-                 item_,\n-                 extra_attrs) = self.parse_item_impl(ast::Unsafety::Unsafe, defaultness)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n+            let (ident, item, extra_attrs) = self.parse_item_impl(unsafety, defaultness)?;\n+            let span = lo.to(self.prev_span);\n+            return Ok(Some(self.mk_item(span, ident, item, visibility,\n+                                        maybe_append(attrs, extra_attrs))));\n         }\n         if self.check_keyword(keywords::Fn) {\n             // FUNCTION ITEM\n@@ -6428,7 +6435,7 @@ impl<'a> Parser<'a> {\n         if self.check_keyword(keywords::Unsafe)\n             && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace)) {\n             // UNSAFE FUNCTION ITEM\n-            self.bump();\n+            self.bump(); // `unsafe`\n             let abi = if self.eat_keyword(keywords::Extern) {\n                 self.parse_opt_abi()?.unwrap_or(Abi::C)\n             } else {\n@@ -6495,25 +6502,7 @@ impl<'a> Parser<'a> {\n             };\n             // TRAIT ITEM\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_trait(is_auto, ast::Unsafety::Normal)?;\n-            let prev_span = self.prev_span;\n-            let item = self.mk_item(lo.to(prev_span),\n-                                    ident,\n-                                    item_,\n-                                    visibility,\n-                                    maybe_append(attrs, extra_attrs));\n-            return Ok(Some(item));\n-        }\n-        if (self.check_keyword(keywords::Impl)) ||\n-           (self.check_keyword(keywords::Default) &&\n-            self.look_ahead(1, |t| t.is_keyword(keywords::Impl)))\n-        {\n-            // IMPL ITEM\n-            let defaultness = self.parse_defaultness()?;\n-            self.expect_keyword(keywords::Impl)?;\n-            let (ident,\n-                 item_,\n-                 extra_attrs) = self.parse_item_impl(ast::Unsafety::Normal, defaultness)?;\n+                self.parse_item_trait(is_auto, Unsafety::Normal)?;\n             let prev_span = self.prev_span;\n             let item = self.mk_item(lo.to(prev_span),\n                                     ident,"}, {"sha": "1a779a41e66604615838974c937c5641b3205102", "filename": "src/test/compile-fail/E0198.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2FE0198.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2FE0198.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0198.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -12,7 +12,7 @@\n \n struct Foo;\n \n-unsafe impl !Clone for Foo { } //~ ERROR negative implementations are not unsafe [E0198]\n+unsafe impl !Send for Foo { } //~ ERROR E0198\n \n fn main() {\n }"}, {"sha": "1ae07b646855737c716ff85751d07ac9eb6e807f", "filename": "src/test/compile-fail/coherence-negative-impls-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fcoherence-negative-impls-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fcoherence-negative-impls-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-negative-impls-safe.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -15,6 +15,6 @@ use std::marker::Send;\n struct TestType;\n \n unsafe impl !Send for TestType {}\n-//~^ ERROR negative implementations are not unsafe\n+//~^ ERROR negative impls cannot be unsafe\n \n fn main() {}"}, {"sha": "d84b58133853f7dd1a622191a01550c342e55a25", "filename": "src/test/compile-fail/issue-46438.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fissue-46438.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fissue-46438.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-46438.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! m {\n+    ($my_type: ty) => {\n+        impl $my_type for u8 {}\n+    }\n+}\n+\n+trait Trait {}\n+\n+m!(Tr);\n+\n+m!(&'static u8); //~ ERROR expected a trait, found type\n+\n+fn main() {}"}, {"sha": "e36c4835ca1c9390fd2fcfe3a29725aa1f32c12c", "filename": "src/test/compile-fail/phantom-oibit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fphantom-oibit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fphantom-oibit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fphantom-oibit.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n // Ensure that OIBIT checks `T` when it encounters a `PhantomData<T>` field, instead of checking\n-// the `PhantomData<T>` type itself (which almost always implements a \"default\" trait\n-// (`impl Trait for ..`))\n+// the `PhantomData<T>` type itself (which almost always implements an auto trait)\n \n #![feature(optin_builtin_traits)]\n "}, {"sha": "480406054adb52d11b2ec3cf75472604b48f384c", "filename": "src/test/compile-fail/private-in-public-ill-formed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-ill-formed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-ill-formed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-ill-formed.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -21,7 +21,7 @@ mod aliases_pub {\n         type AssocAlias = m::Pub3;\n     }\n \n-    impl (<Priv as PrivTr>::AssocAlias) { //~ ERROR no base type found for inherent implementation\n+    impl <Priv as PrivTr>::AssocAlias { //~ ERROR no base type found for inherent implementation\n         pub fn f(arg: Priv) {} // private type `aliases_pub::Priv` in public interface\n     }\n }\n@@ -37,7 +37,7 @@ mod aliases_priv {\n         type AssocAlias = Priv3;\n     }\n \n-    impl (<Priv as PrivTr>::AssocAlias) { //~ ERROR no base type found for inherent implementation\n+    impl <Priv as PrivTr>::AssocAlias { //~ ERROR no base type found for inherent implementation\n         pub fn f(arg: Priv) {} // OK\n     }\n }"}, {"sha": "26b8b737f340d7a7e418adef7853977a0e8cf442", "filename": "src/test/compile-fail/specialization/defaultimpl/validation.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fdefaultimpl%2Fvalidation.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+#![feature(specialization)]\n+\n+struct S;\n+struct Z;\n+\n+default impl S {} //~ ERROR inherent impls cannot be default\n+\n+default unsafe impl Send for S {} //~ ERROR impls of auto traits cannot be default\n+default impl !Send for Z {} //~ ERROR impls of auto traits cannot be default\n+\n+trait Tr {}\n+default impl !Tr for S {} //~ ERROR negative impls are only allowed for auto traits"}, {"sha": "8d5e89cc66f753d408025a57e4e6900407804067", "filename": "src/test/compile-fail/syntax-trait-polarity-feature-gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fsyntax-trait-polarity-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fsyntax-trait-polarity-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-trait-polarity-feature-gate.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -14,7 +14,7 @@ struct TestType;\n \n trait TestTrait {}\n \n-unsafe impl !Send for TestType {}\n+impl !Send for TestType {}\n //~^ ERROR negative trait bounds\n \n fn main() {}"}, {"sha": "1a5d058cb9aa80f678a9b7bd64608fb50dc0ae07", "filename": "src/test/compile-fail/syntax-trait-polarity.rs", "status": "renamed", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fsyntax-trait-polarity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Fsyntax-trait-polarity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-trait-polarity.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -8,28 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only -Z continue-parse-after-error\n-\n #![feature(optin_builtin_traits)]\n \n use std::marker::Send;\n \n struct TestType;\n \n impl !TestType {}\n-//~^ ERROR inherent implementation can't be negated\n+//~^ ERROR inherent impls cannot be negative\n \n trait TestTrait {}\n \n unsafe impl !Send for TestType {}\n+//~^ ERROR negative impls cannot be unsafe\n impl !TestTrait for TestType {}\n+//~^ ERROR negative impls are only allowed for auto traits\n \n-struct TestType2<T>;\n+struct TestType2<T>(T);\n \n impl<T> !TestType2<T> {}\n-//~^ ERROR inherent implementation can't be negated\n+//~^ ERROR inherent impls cannot be negative\n \n unsafe impl<T> !Send for TestType2<T> {}\n+//~^ ERROR negative impls cannot be unsafe\n impl<T> !TestTrait for TestType2<T> {}\n+//~^ ERROR negative impls are only allowed for auto traits\n \n fn main() {}", "previous_filename": "src/test/parse-fail/syntax-trait-polarity.rs"}, {"sha": "059fdc100c94407d2df29e8d7bdb380744f55582", "filename": "src/test/compile-fail/trait-safety-inherent-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Ftrait-safety-inherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Ftrait-safety-inherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-safety-inherent-impl.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -12,7 +12,7 @@\n \n struct SomeStruct;\n \n-unsafe impl SomeStruct { //~ ERROR inherent impls cannot be declared as unsafe\n+unsafe impl SomeStruct { //~ ERROR inherent impls cannot be unsafe\n     fn foo(self) { }\n }\n "}, {"sha": "d6d8fb6235d386f8aed71342f5a01b980158db36", "filename": "src/test/compile-fail/typeck-negative-impls-builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Ftypeck-negative-impls-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fcompile-fail%2Ftypeck-negative-impls-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-negative-impls-builtin.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -17,6 +17,6 @@ trait TestTrait {\n }\n \n impl !TestTrait for TestType {}\n-//~^ ERROR negative impls are only allowed for traits with default impls (e.g., `Send` and `Sync`)\n+//~^ ERROR negative impls are only allowed for auto traits (e.g., `Send` and `Sync`)\n \n fn main() {}"}, {"sha": "48dd888b2e530d92b93c8716e72b963005724e14", "filename": "src/test/parse-fail/impl-qpath.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fparse-fail%2Fimpl-qpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fparse-fail%2Fimpl-qpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fimpl-qpath.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+impl <*const u8>::AssocTy {} // OK\n+impl <Type as Trait>::AssocTy {} // OK\n+impl <'a + Trait>::AssocTy {} // OK\n+impl <<Type>::AssocTy>::AssocTy {} // OK\n+\n+FAIL //~ ERROR"}, {"sha": "7cd2774fe39b2ce78ef16f8ecf3c670288daefc0", "filename": "src/test/parse-fail/trait-bounds-not-on-impl.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fparse-fail%2Ftrait-bounds-not-on-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fparse-fail%2Ftrait-bounds-not-on-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-bounds-not-on-impl.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -15,9 +15,7 @@ trait Foo {\n \n struct Bar;\n \n-impl Foo + Owned for Bar {\n-//~^ ERROR not a trait\n-//~^^ ERROR expected one of `where` or `{`, found `Bar`\n+impl Foo + Owned for Bar { //~ ERROR expected a trait, found type\n }\n \n fn main() { }"}, {"sha": "2948619ccd07dce770b2837074a565c22b74d557", "filename": "src/test/parse-fail/where_with_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fparse-fail%2Fwhere_with_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fparse-fail%2Fwhere_with_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fwhere_with_bound.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -11,6 +11,6 @@\n // compile-flags: -Z parse-only\n \n fn foo<T>() where <T>::Item: ToString, T: Iterator { }\n-               //~^ syntax `where<T>` is reserved for future use\n+//~^ ERROR generic parameters on `where` clauses are reserved for future use\n \n fn main() {}"}, {"sha": "0d9dc3cf60556aabfc95630d3229ff5b3f24b136", "filename": "src/test/run-pass/issue-25693.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Frun-pass%2Fissue-25693.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Frun-pass%2Fissue-25693.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25693.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -8,16 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait Paramters { type SelfRef; }\n+pub trait Parameters { type SelfRef; }\n \n struct RP<'a> { _marker: std::marker::PhantomData<&'a ()> }\n struct BP;\n \n-impl<'a> Paramters for RP<'a> { type SelfRef = &'a X<RP<'a>>; }\n-impl Paramters for BP { type SelfRef = Box<X<BP>>; }\n+impl<'a> Parameters for RP<'a> { type SelfRef = &'a X<RP<'a>>; }\n+impl Parameters for BP { type SelfRef = Box<X<BP>>; }\n \n pub struct Y;\n-pub enum X<P: Paramters> {\n+pub enum X<P: Parameters> {\n     Nothing,\n     SameAgain(P::SelfRef, Y)\n }"}, {"sha": "064e3c3ac482d8e98ccc033bcec49c9231540ac9", "filename": "src/test/ui/span/impl-parsing.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fui%2Fspan%2Fimpl-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fui%2Fspan%2Fimpl-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimpl-parsing.rs?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n+\n+impl ! {} // OK\n+impl ! where u8: Copy {} // OK\n+\n+impl Trait Type {} //~ ERROR missing `for` in a trait impl\n+impl Trait .. {} //~ ERROR missing `for` in a trait impl\n+impl ?Sized for Type {} //~ ERROR expected a trait, found type\n+impl ?Sized for .. {} //~ ERROR expected a trait, found type\n+\n+default unsafe FAIL //~ ERROR expected `impl`, found `FAIL`"}, {"sha": "912638446b961cd918a3ced7cecfb122510d21c7", "filename": "src/test/ui/span/impl-parsing.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fui%2Fspan%2Fimpl-parsing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f92e8d89861f0f5408ad9381a7467ec6e7d76bc/src%2Ftest%2Fui%2Fspan%2Fimpl-parsing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimpl-parsing.stderr?ref=3f92e8d89861f0f5408ad9381a7467ec6e7d76bc", "patch": "@@ -0,0 +1,32 @@\n+error: missing `for` in a trait impl\n+  --> $DIR/impl-parsing.rs:16:11\n+   |\n+16 | impl Trait Type {} //~ ERROR missing `for` in a trait impl\n+   |           ^\n+\n+error: missing `for` in a trait impl\n+  --> $DIR/impl-parsing.rs:17:11\n+   |\n+17 | impl Trait .. {} //~ ERROR missing `for` in a trait impl\n+   |           ^\n+\n+error: expected a trait, found type\n+  --> $DIR/impl-parsing.rs:18:6\n+   |\n+18 | impl ?Sized for Type {} //~ ERROR expected a trait, found type\n+   |      ^^^^^^\n+\n+error: expected a trait, found type\n+  --> $DIR/impl-parsing.rs:19:6\n+   |\n+19 | impl ?Sized for .. {} //~ ERROR expected a trait, found type\n+   |      ^^^^^^\n+\n+error: expected `impl`, found `FAIL`\n+  --> $DIR/impl-parsing.rs:21:16\n+   |\n+21 | default unsafe FAIL //~ ERROR expected `impl`, found `FAIL`\n+   |                ^^^^ expected `impl` here\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "6b50fde01d8a2e368443f3389639655e0c9c7140", "filename": "src/test/ui/typeck-default-trait-impl-outside-crate.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc9d86363e0997f8378ea0260dfec3a9d09bcf0/src%2Ftest%2Fui%2Ftypeck-default-trait-impl-outside-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/adc9d86363e0997f8378ea0260dfec3a9d09bcf0/src%2Ftest%2Fui%2Ftypeck-default-trait-impl-outside-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck-default-trait-impl-outside-crate.stderr?ref=adc9d86363e0997f8378ea0260dfec3a9d09bcf0", "patch": "@@ -1,8 +0,0 @@\n-error[E0318]: cannot create default implementations for traits outside the crate they're defined in; define a new trait instead\n-  --> $DIR/typeck-default-trait-impl-outside-crate.rs:14:6\n-   |\n-14 | impl Copy for .. {} //~ ERROR E0318\n-   |      ^^^^ `Copy` trait not defined in this crate\n-\n-error: aborting due to previous error\n-"}]}