{"sha": "022a7b3cfb8014f79c79ba85a8273d16cda6e423", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMmE3YjNjZmI4MDE0Zjc5Yzc5YmE4NWE4MjczZDE2Y2RhNmU0MjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-22T08:06:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-22T08:06:25Z"}, "message": "auto merge of #14322 : thestinger/rust/secret_santa_heap, r=alexcrichton", "tree": {"sha": "69f59e3fdf58d2fa67fb10a218562f2b6362be86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69f59e3fdf58d2fa67fb10a218562f2b6362be86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/022a7b3cfb8014f79c79ba85a8273d16cda6e423", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/022a7b3cfb8014f79c79ba85a8273d16cda6e423", "html_url": "https://github.com/rust-lang/rust/commit/022a7b3cfb8014f79c79ba85a8273d16cda6e423", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/022a7b3cfb8014f79c79ba85a8273d16cda6e423/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22e2204c3d6f09f5bd1311d1d0a7b086e19b1b96", "url": "https://api.github.com/repos/rust-lang/rust/commits/22e2204c3d6f09f5bd1311d1d0a7b086e19b1b96", "html_url": "https://github.com/rust-lang/rust/commit/22e2204c3d6f09f5bd1311d1d0a7b086e19b1b96"}, {"sha": "f1ce693e618dbf4273e0e1af8fd101e15964f5f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ce693e618dbf4273e0e1af8fd101e15964f5f0", "html_url": "https://github.com/rust-lang/rust/commit/f1ce693e618dbf4273e0e1af8fd101e15964f5f0"}], "stats": {"total": 112, "additions": 67, "deletions": 45}, "files": [{"sha": "631b72cb8978ef791c42bba74a61c44f9cb2b4f9", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=022a7b3cfb8014f79c79ba85a8273d16cda6e423", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // FIXME: #13994: port to the sized deallocation API when available\n-// FIXME: #13996: need a way to mark the `allocate` and `reallocate` return values as `noalias`\n+// FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias` and `nonnull`\n \n use core::intrinsics::{abort, cttz32};\n use core::option::{None, Option};\n@@ -119,14 +119,8 @@ pub fn stats_print() {\n /// The allocator for unique pointers.\n #[cfg(not(test))]\n #[lang=\"exchange_malloc\"]\n-#[inline(always)]\n-pub unsafe fn exchange_malloc_(size: uint, align: uint) -> *mut u8 {\n-    exchange_malloc(size, align)\n-}\n-\n-/// The allocator for unique pointers.\n #[inline]\n-pub unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n+unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n     // The compiler never calls `exchange_free` on ~ZeroSizeType, so zero-size\n     // allocations can point to this `static`. It would be incorrect to use a null\n     // pointer, due to enums assuming types like unique pointers are never null.\n@@ -139,14 +133,20 @@ pub unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n     }\n }\n \n-#[cfg(not(test))]\n+#[cfg(not(test), stage0)]\n #[lang=\"exchange_free\"]\n #[inline]\n-// FIXME: #13994 (rustc should pass align and size here)\n unsafe fn exchange_free(ptr: *mut u8) {\n     deallocate(ptr, 0, 8);\n }\n \n+#[cfg(not(test), not(stage0))]\n+#[lang=\"exchange_free\"]\n+#[inline]\n+unsafe fn exchange_free(ptr: *mut u8, size: uint, align: uint) {\n+    deallocate(ptr, size, align);\n+}\n+\n // FIXME: #7496\n #[cfg(not(test))]\n #[lang=\"closure_exchange_malloc\"]\n@@ -167,16 +167,16 @@ unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint, align: uin\n #[doc(hidden)]\n #[deprecated]\n #[cfg(not(test))]\n-pub unsafe extern \"C\" fn rust_malloc(size: uint, align: uint) -> *mut u8 {\n-    exchange_malloc(size, align)\n+pub unsafe extern \"C\" fn rust_allocate(size: uint, align: uint) -> *mut u8 {\n+    allocate(size, align)\n }\n \n // hack for libcore\n #[no_mangle]\n #[doc(hidden)]\n #[deprecated]\n #[cfg(not(test))]\n-pub unsafe extern \"C\" fn rust_free(ptr: *mut u8, size: uint, align: uint) {\n+pub unsafe extern \"C\" fn rust_deallocate(ptr: *mut u8, size: uint, align: uint) {\n     deallocate(ptr, size, align)\n }\n "}, {"sha": "2f654bdd3004a134a2444ce5a87f74a3766597ca", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=022a7b3cfb8014f79c79ba85a8273d16cda6e423", "patch": "@@ -38,7 +38,7 @@ use std::mem;\n use std::num;\n use std::ptr::read;\n use std::rc::Rc;\n-use std::rt::heap::exchange_malloc;\n+use std::rt::heap::allocate;\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n@@ -358,8 +358,7 @@ impl<T> TypedArenaChunk<T> {\n         size = size.checked_add(&elems_size).unwrap();\n \n         let mut chunk = unsafe {\n-            let chunk = exchange_malloc(size,\n-                                        mem::min_align_of::<TypedArenaChunk<T>>());\n+            let chunk = allocate(size, mem::min_align_of::<TypedArenaChunk<T>>());\n             let mut chunk: Box<TypedArenaChunk<T>> = mem::transmute(chunk);\n             mem::overwrite(&mut chunk.next, next);\n             chunk"}, {"sha": "2046017869dea9ef44fb2321a5e91ff109a2bce2", "filename": "src/libcore/should_not_exist.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=022a7b3cfb8014f79c79ba85a8273d16cda6e423", "patch": "@@ -44,14 +44,14 @@ use str::StrSlice;\n \n #[allow(ctypes)]\n extern {\n-    fn rust_malloc(size: uint, align: uint) -> *u8;\n-    fn rust_free(ptr: *u8, size: uint, align: uint);\n+    fn rust_allocate(size: uint, align: uint) -> *u8;\n+    fn rust_deallocate(ptr: *u8, size: uint, align: uint);\n }\n \n unsafe fn alloc(cap: uint) -> *mut Vec<()> {\n     let cap = cap.checked_add(&mem::size_of::<Vec<()>>()).unwrap();\n     // this should use the real alignment, but the new representation will take care of that\n-    let ret = rust_malloc(cap, 8) as *mut Vec<()>;\n+    let ret = rust_allocate(cap, 8) as *mut Vec<()>;\n     if ret.is_null() {\n         intrinsics::abort();\n     }\n@@ -119,7 +119,7 @@ impl FromIterator<char> for ~str {\n                                                     &(*ptr).data,\n                                                     len);\n                     // FIXME: #13994: port to the sized deallocation API when available\n-                    rust_free(ptr as *u8, 0, 8);\n+                    rust_deallocate(ptr as *u8, 0, 8);\n                     mem::forget(ret);\n                     ret = mem::transmute(ptr2);\n                     ptr = ptr2;\n@@ -191,7 +191,7 @@ impl<A: Clone> Clone for ~[A] {\n                     for j in range(0, *i as int) {\n                         ptr::read(&*p.offset(j));\n                     }\n-                    rust_free(ret as *u8, 0, 8);\n+                    rust_deallocate(ret as *u8, 0, 8);\n                 });\n             mem::transmute(ret)\n         }"}, {"sha": "80ee555971d83412139a3b2c84f454c1ad555a57", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=022a7b3cfb8014f79c79ba85a8273d16cda6e423", "patch": "@@ -278,13 +278,14 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n     fn schedule_free_value(&self,\n                            cleanup_scope: ScopeId,\n                            val: ValueRef,\n-                           heap: Heap) {\n+                           heap: Heap,\n+                           content_ty: ty::t) {\n         /*!\n          * Schedules a call to `free(val)`. Note that this is a shallow\n          * operation.\n          */\n \n-        let drop = box FreeValue { ptr: val, heap: heap };\n+        let drop = box FreeValue { ptr: val, heap: heap, content_ty: content_ty };\n \n         debug!(\"schedule_free_value({:?}, val={}, heap={:?})\",\n                cleanup_scope,\n@@ -847,6 +848,7 @@ pub enum Heap {\n pub struct FreeValue {\n     ptr: ValueRef,\n     heap: Heap,\n+    content_ty: ty::t\n }\n \n impl Cleanup for FreeValue {\n@@ -860,7 +862,7 @@ impl Cleanup for FreeValue {\n                 glue::trans_free(bcx, self.ptr)\n             }\n             HeapExchange => {\n-                glue::trans_exchange_free(bcx, self.ptr)\n+                glue::trans_exchange_free_ty(bcx, self.ptr, self.content_ty)\n             }\n         }\n     }\n@@ -931,7 +933,8 @@ pub trait CleanupMethods<'a> {\n     fn schedule_free_value(&self,\n                            cleanup_scope: ScopeId,\n                            val: ValueRef,\n-                           heap: Heap);\n+                           heap: Heap,\n+                           content_ty: ty::t);\n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n                       cleanup: Box<Cleanup>);"}, {"sha": "bd25acad21d4d0cc30257eada8030cf8518515b7", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=022a7b3cfb8014f79c79ba85a8273d16cda6e423", "patch": "@@ -1183,7 +1183,7 @@ fn trans_uniq_expr<'a>(bcx: &'a Block<'a>,\n     } else {\n         let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n         fcx.schedule_free_value(cleanup::CustomScope(custom_cleanup_scope),\n-                                val, cleanup::HeapExchange);\n+                                val, cleanup::HeapExchange, contents_ty);\n         let bcx = trans_into(bcx, contents, SaveIn(val));\n         fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n         bcx\n@@ -1205,7 +1205,7 @@ fn trans_managed_expr<'a>(bcx: &'a Block<'a>,\n \n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n     fcx.schedule_free_value(cleanup::CustomScope(custom_cleanup_scope),\n-                            bx, cleanup::HeapManaged);\n+                            bx, cleanup::HeapManaged, contents_ty);\n     let bcx = trans_into(bcx, contents, SaveIn(body));\n     fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n     immediate_rvalue_bcx(bcx, bx, box_ty).to_expr_datumblock()\n@@ -1789,13 +1789,14 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n                 let scope = cleanup::temporary_scope(bcx.tcx(), expr.id);\n                 let ptr = Load(bcx, datum.val);\n                 if !type_is_zero_size(bcx.ccx(), content_ty) {\n-                    bcx.fcx.schedule_free_value(scope, ptr, cleanup::HeapExchange);\n+                    bcx.fcx.schedule_free_value(scope, ptr, cleanup::HeapExchange, content_ty);\n                 }\n             }\n             RvalueExpr(Rvalue { mode: ByValue }) => {\n                 let scope = cleanup::temporary_scope(bcx.tcx(), expr.id);\n                 if !type_is_zero_size(bcx.ccx(), content_ty) {\n-                    bcx.fcx.schedule_free_value(scope, datum.val, cleanup::HeapExchange);\n+                    bcx.fcx.schedule_free_value(scope, datum.val, cleanup::HeapExchange,\n+                                                content_ty);\n                 }\n             }\n             LvalueExpr => { }"}, {"sha": "b1b684ca3713aa9c7e3a404d5eaa1830ffce6614", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=022a7b3cfb8014f79c79ba85a8273d16cda6e423", "patch": "@@ -50,15 +50,30 @@ pub fn trans_free<'a>(cx: &'a Block<'a>, v: ValueRef) -> &'a Block<'a> {\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef)\n-                           -> &'a Block<'a> {\n+fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef, size: u64,\n+                               align: u64) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n+    let ccx = cx.ccx();\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n-        [PointerCast(cx, v, Type::i8p(cx.ccx()))],\n+        [PointerCast(cx, v, Type::i8p(ccx)), C_uint(ccx, size as uint), C_uint(ccx, align as uint)],\n         Some(expr::Ignore)).bcx\n }\n \n+pub fn trans_exchange_free_ty<'a>(bcx: &'a Block<'a>, ptr: ValueRef,\n+                                  content_ty: ty::t) -> &'a Block<'a> {\n+    let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n+    let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n+\n+    // `Box<ZeroSizeType>` does not allocate.\n+    if content_size != 0 {\n+        let content_align = llalign_of_min(bcx.ccx(), sizing_type);\n+        trans_exchange_free(bcx, ptr, content_size, content_align)\n+    } else {\n+        bcx\n+    }\n+}\n+\n pub fn take_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n                -> &'a Block<'a> {\n     // NB: v is an *alias* of type t here, not a direct value.\n@@ -87,17 +102,15 @@ fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n                 ty::ty_vec(_, None) | ty::ty_str => t,\n                 _ => {\n                     let llty = sizing_type_of(ccx, typ);\n-                    // Unique boxes do not allocate for zero-size types. The standard\n-                    // library may assume that `free` is never called on the pointer\n-                    // returned for `Box<ZeroSizeType>`.\n+                    // `Box<ZeroSizeType>` does not allocate.\n                     if llsize_of_alloc(ccx, llty) == 0 {\n                         ty::mk_i8()\n                     } else {\n                         ty::mk_uniq(tcx, ty::mk_i8())\n                     }\n-                        }\n-                    }\n                 }\n+            }\n+        }\n         _ => t\n     }\n }\n@@ -285,20 +298,22 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 ty::ty_vec(mt, None) => {\n                     with_cond(bcx, not_null, |bcx| {\n                         let bcx = tvec::make_drop_glue_unboxed(bcx, llbox, mt.ty);\n-                        trans_exchange_free(bcx, llbox)\n+                        // FIXME: #13994: the old `Box<[T]>` will not support sized deallocation\n+                        trans_exchange_free(bcx, llbox, 0, 8)\n                     })\n                 }\n                 ty::ty_str => {\n                     with_cond(bcx, not_null, |bcx| {\n                         let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n                         let bcx = tvec::make_drop_glue_unboxed(bcx, llbox, unit_ty);\n-                        trans_exchange_free(bcx, llbox)\n+                        // FIXME: #13994: the old `Box<str>` will not support sized deallocation\n+                        trans_exchange_free(bcx, llbox, 0, 8)\n                     })\n                 }\n                 _ => {\n                     with_cond(bcx, not_null, |bcx| {\n                         let bcx = drop_ty(bcx, llbox, content_ty);\n-                        trans_exchange_free(bcx, llbox)\n+                        trans_exchange_free_ty(bcx, llbox, content_ty)\n                     })\n                 }\n             }\n@@ -340,7 +355,8 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 Call(bcx, dtor, [PointerCast(bcx, cdata, Type::i8p(bcx.ccx()))], []);\n \n                 // Free the environment itself\n-                trans_exchange_free(bcx, env)\n+                // FIXME: #13994: pass align and size here\n+                trans_exchange_free(bcx, env, 0, 8)\n             })\n         }\n         _ => {"}, {"sha": "24518bdeeca7157eff3b3529b314c2d0bcca7040", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=022a7b3cfb8014f79c79ba85a8273d16cda6e423", "patch": "@@ -287,8 +287,11 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n     // Create a temporary scope lest execution should fail while\n     // constructing the vector.\n     let temp_scope = fcx.push_custom_cleanup_scope();\n+\n+    // FIXME: #13994: the old `Box<[T]> will not support sized deallocation, this is a placeholder\n+    let content_ty = vt.unit_ty;\n     fcx.schedule_free_value(cleanup::CustomScope(temp_scope),\n-                            val, cleanup::HeapExchange);\n+                            val, cleanup::HeapExchange, content_ty);\n \n     let dataptr = get_dataptr(bcx, val);\n "}, {"sha": "0838211b9a59f610764c09e370bc323b077f9798", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/022a7b3cfb8014f79c79ba85a8273d16cda6e423/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=022a7b3cfb8014f79c79ba85a8273d16cda6e423", "patch": "@@ -109,7 +109,7 @@ use ops::Drop;\n use option::{None, Option, Some};\n use ptr::RawPtr;\n use ptr;\n-use rt::heap::{exchange_malloc, deallocate};\n+use rt::heap::{allocate, deallocate};\n use unstable::finally::try_finally;\n use vec::Vec;\n \n@@ -304,7 +304,7 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n \n         unsafe {\n             // this should pass the real required alignment\n-            let ret = exchange_malloc(size, 8) as *mut RawVec<()>;\n+            let ret = allocate(size, 8) as *mut RawVec<()>;\n \n             let a_size = mem::size_of::<T>();\n             let a_size = if a_size == 0 {1} else {a_size};\n@@ -968,7 +968,7 @@ mod tests {\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n-        // Test on exchange heap.\n+        // Test `Box<[T]>`\n         let vec_unique = box [1, 2, 3, 4, 5, 6];\n         let v_d = vec_unique.slice(1u, 6u).to_owned();\n         assert_eq!(v_d.len(), 5u);"}]}