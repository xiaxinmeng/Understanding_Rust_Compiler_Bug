{"sha": "8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjOTM3OThlOWY4MGQ2ZDZlZDlhMmFiNGIwMWFmMDZhOGZlYTIzYjc=", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2018-12-15T21:25:50Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2019-01-15T02:21:21Z"}, "message": "rustdoc: check code block syntax in early pass", "tree": {"sha": "43874bdc32b8aca520aace508d119bfa5aa3fda3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43874bdc32b8aca520aace508d119bfa5aa3fda3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFKBAABCAA0FiEELriChyEaiMu0yCg7viIhAz7bw3QFAlw9Q6QWHGFydXNzZWxs\nMTIzQGdtYWlsLmNvbQAKCRC+IiEDPtvDdCYSCACe8Kdh/EaR1C+s5lSZb2cG5p4D\ndFf+mhCjLdKAYSY2nKDWAs50+YmnorIaA8qgcNyPLbxYWY82mwwDkyRK0ZHhc08J\nI0cbXDb2huan6NaDI6qdLXLLJId2ueCCV3Cex77GDn37EBBhUidgFpmK5v6vVCb0\nT+Jnxb2v59MlPH1VB6QcZL/UK6gvezKa+5zMXWy/n8ZjIaFq0M5wtUI6Gh0mDdsR\nwVKvvjyXSDczofWQCzpbvgkkYfFTeI8rlXlyGACn9+lDnsS1qdIK3cDGCxXFOLNX\nh/mnX3CKoSZ1RTpTZkNMz9D10Wt/KlX0wITOHO/5OHiu4IbE2XMEBs/pndPy\n=AVZz\n-----END PGP SIGNATURE-----", "payload": "tree 43874bdc32b8aca520aace508d119bfa5aa3fda3\nparent ee10d99b9a44c57f450678310b16e651d08075cd\nauthor Andy Russell <arussell123@gmail.com> 1544909150 -0500\ncommitter Andy Russell <arussell123@gmail.com> 1547518881 -0500\n\nrustdoc: check code block syntax in early pass\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "html_url": "https://github.com/rust-lang/rust/commit/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee10d99b9a44c57f450678310b16e651d08075cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee10d99b9a44c57f450678310b16e651d08075cd", "html_url": "https://github.com/rust-lang/rust/commit/ee10d99b9a44c57f450678310b16e651d08075cd"}], "stats": {"total": 549, "additions": 476, "deletions": 73}, "files": [{"sha": "29a41384edcda784231d5cc9c12b480f30768322", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 55, "deletions": 37, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "patch": "@@ -25,40 +25,51 @@ pub fn render_with_highlighting(\n     tooltip: Option<(&str, &str)>,\n ) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n-    let sess = parse::ParseSess::new(FilePathMapping::empty());\n-    let fm = sess.source_map().new_source_file(FileName::Custom(\"stdin\".to_string()),\n-                                               src.to_string());\n-\n     let mut out = Vec::new();\n     if let Some((tooltip, class)) = tooltip {\n         write!(out, \"<div class='information'><div class='tooltip {}'>\u24d8<span \\\n                      class='tooltiptext'>{}</span></div></div>\",\n                class, tooltip).unwrap();\n     }\n-    write_header(class, &mut out).unwrap();\n-\n-    let lexer = match lexer::StringReader::new_without_err(&sess, fm, None, \"Output from rustc:\") {\n-        Ok(l) => l,\n-        Err(_) => {\n-            let first_line = src.lines().next().unwrap_or_else(|| \"\");\n-            let mut err = sess.span_diagnostic\n-                              .struct_warn(&format!(\"Invalid doc comment starting with: `{}`\\n\\\n-                                                     (Ignoring this codeblock)\",\n-                                                    first_line));\n-            err.emit();\n-            return String::new();\n+\n+    let sess = parse::ParseSess::new(FilePathMapping::empty());\n+    let fm = sess.source_map().new_source_file(\n+        FileName::Custom(String::from(\"rustdoc-highlighting\")),\n+        src.to_owned(),\n+    );\n+    let highlight_result =\n+        lexer::StringReader::new_or_buffered_errs(&sess, fm, None).and_then(|lexer| {\n+            let mut classifier = Classifier::new(lexer, sess.source_map());\n+\n+            let mut highlighted_source = vec![];\n+            if classifier.write_source(&mut highlighted_source).is_err() {\n+                Err(classifier.lexer.buffer_fatal_errors())\n+            } else {\n+                Ok(String::from_utf8_lossy(&highlighted_source).into_owned())\n+            }\n+        });\n+\n+    match highlight_result {\n+        Ok(highlighted_source) => {\n+            write_header(class, &mut out).unwrap();\n+            write!(out, \"{}\", highlighted_source).unwrap();\n+            if let Some(extension) = extension {\n+                write!(out, \"{}\", extension).unwrap();\n+            }\n+            write_footer(&mut out).unwrap();\n         }\n-    };\n-    let mut classifier = Classifier::new(lexer, sess.source_map());\n-    if classifier.write_source(&mut out).is_err() {\n-        classifier.lexer.emit_fatal_errors();\n-        return format!(\"<pre>{}</pre>\", src);\n-    }\n+        Err(errors) => {\n+            // If errors are encountered while trying to highlight, cancel the errors and just emit\n+            // the unhighlighted source. The errors will have already been reported in the\n+            // `check-code-block-syntax` pass.\n+            for mut error in errors {\n+                error.cancel();\n+            }\n \n-    if let Some(extension) = extension {\n-        write!(out, \"{}\", extension).unwrap();\n+            write!(out, \"<pre><code>{}</code></pre>\", src).unwrap();\n+        }\n     }\n-    write_footer(&mut out).unwrap();\n+\n     String::from_utf8_lossy(&out[..]).into_owned()\n }\n \n@@ -151,6 +162,17 @@ impl<U: Write> Writer for U {\n     }\n }\n \n+enum HighlightError {\n+    LexError,\n+    IoError(io::Error),\n+}\n+\n+impl From<io::Error> for HighlightError {\n+    fn from(err: io::Error) -> Self {\n+        HighlightError::IoError(err)\n+    }\n+}\n+\n impl<'a> Classifier<'a> {\n     fn new(lexer: lexer::StringReader<'a>, source_map: &'a SourceMap) -> Classifier<'a> {\n         Classifier {\n@@ -162,17 +184,11 @@ impl<'a> Classifier<'a> {\n         }\n     }\n \n-    /// Gets the next token out of the lexer, emitting fatal errors if lexing fails.\n-    fn try_next_token(&mut self) -> io::Result<TokenAndSpan> {\n+    /// Gets the next token out of the lexer.\n+    fn try_next_token(&mut self) -> Result<TokenAndSpan, HighlightError> {\n         match self.lexer.try_next_token() {\n             Ok(tas) => Ok(tas),\n-            Err(_) => {\n-                let mut err = self.lexer.sess.span_diagnostic\n-                                  .struct_warn(\"Backing out of syntax highlighting\");\n-                err.note(\"You probably did not intend to render this as a rust code-block\");\n-                err.emit();\n-                Err(io::Error::new(io::ErrorKind::Other, \"\"))\n-            }\n+            Err(_) => Err(HighlightError::LexError),\n         }\n     }\n \n@@ -185,7 +201,7 @@ impl<'a> Classifier<'a> {\n     /// source.\n     fn write_source<W: Writer>(&mut self,\n                                    out: &mut W)\n-                                   -> io::Result<()> {\n+                                   -> Result<(), HighlightError> {\n         loop {\n             let next = self.try_next_token()?;\n             if next.tok == token::Eof {\n@@ -202,7 +218,7 @@ impl<'a> Classifier<'a> {\n     fn write_token<W: Writer>(&mut self,\n                               out: &mut W,\n                               tas: TokenAndSpan)\n-                              -> io::Result<()> {\n+                              -> Result<(), HighlightError> {\n         let klass = match tas.tok {\n             token::Shebang(s) => {\n                 out.string(Escape(&s.as_str()), Class::None)?;\n@@ -341,7 +357,9 @@ impl<'a> Classifier<'a> {\n \n         // Anything that didn't return above is the simple case where we the\n         // class just spans a single token, so we can use the `string` method.\n-        out.string(Escape(&self.snip(tas.sp)), klass)\n+        out.string(Escape(&self.snip(tas.sp)), klass)?;\n+\n+        Ok(())\n     }\n \n     // Helper function to get a snippet from the source_map."}, {"sha": "6b7f54044ca1d23b533653713b61115e28361099", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "patch": "@@ -919,6 +919,115 @@ pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n     links\n }\n \n+#[derive(Debug)]\n+crate struct RustCodeBlock {\n+    /// The range in the markdown that the code block occupies. Note that this includes the fences\n+    /// for fenced code blocks.\n+    pub range: Range<usize>,\n+    /// The range in the markdown that the code within the code block occupies.\n+    pub code: Range<usize>,\n+    pub is_fenced: bool,\n+    pub syntax: Option<String>,\n+}\n+\n+/// Returns a range of bytes for each code block in the markdown that is tagged as `rust` or\n+/// untagged (and assumed to be rust).\n+crate fn rust_code_blocks(md: &str) -> Vec<RustCodeBlock> {\n+    let mut code_blocks = vec![];\n+\n+    if md.is_empty() {\n+        return code_blocks;\n+    }\n+\n+    let mut opts = Options::empty();\n+    opts.insert(OPTION_ENABLE_TABLES);\n+    opts.insert(OPTION_ENABLE_FOOTNOTES);\n+    let mut p = Parser::new_ext(md, opts);\n+\n+    let mut code_block_start = 0;\n+    let mut code_start = 0;\n+    let mut is_fenced = false;\n+    let mut previous_offset = 0;\n+    let mut in_rust_code_block = false;\n+    while let Some(event) = p.next() {\n+        let offset = p.get_offset();\n+\n+        match event {\n+            Event::Start(Tag::CodeBlock(syntax)) => {\n+                let lang_string = if syntax.is_empty() {\n+                    LangString::all_false()\n+                } else {\n+                    LangString::parse(&*syntax, ErrorCodes::Yes)\n+                };\n+\n+                if lang_string.rust {\n+                    in_rust_code_block = true;\n+\n+                    code_start = offset;\n+                    code_block_start = match md[previous_offset..offset].find(\"```\") {\n+                        Some(fence_idx) => {\n+                            is_fenced = true;\n+                            previous_offset + fence_idx\n+                        }\n+                        None => offset,\n+                    };\n+                }\n+            }\n+            Event::End(Tag::CodeBlock(syntax)) if in_rust_code_block => {\n+                in_rust_code_block = false;\n+\n+                let code_block_end = if is_fenced {\n+                    let fence_str = &md[previous_offset..offset]\n+                        .chars()\n+                        .rev()\n+                        .collect::<String>();\n+                    fence_str\n+                        .find(\"```\")\n+                        .map(|fence_idx| offset - fence_idx)\n+                        .unwrap_or_else(|| offset)\n+                } else if md\n+                    .as_bytes()\n+                    .get(offset)\n+                    .map(|b| *b == b'\\n')\n+                    .unwrap_or_default()\n+                {\n+                    offset - 1\n+                } else {\n+                    offset\n+                };\n+\n+                let code_end = if is_fenced {\n+                    previous_offset\n+                } else {\n+                    code_block_end\n+                };\n+\n+                code_blocks.push(RustCodeBlock {\n+                    is_fenced,\n+                    range: Range {\n+                        start: code_block_start,\n+                        end: code_block_end,\n+                    },\n+                    code: Range {\n+                        start: code_start,\n+                        end: code_end,\n+                    },\n+                    syntax: if !syntax.is_empty() {\n+                        Some(syntax.into_owned())\n+                    } else {\n+                        None\n+                    },\n+                });\n+            }\n+            _ => (),\n+        }\n+\n+        previous_offset = offset;\n+    }\n+\n+    code_blocks\n+}\n+\n #[derive(Clone, Default, Debug)]\n pub struct IdMap {\n     map: FxHashMap<String, usize>,"}, {"sha": "6e7141f94a7766791af546b68da4222d6b0c4823", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "patch": "@@ -3,6 +3,7 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\")]\n \n+#![feature(bind_by_move_pattern_guards)]\n #![feature(rustc_private)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]"}, {"sha": "a013cc36c722dd3bf7343e0e7aa6401bc95e9ca6", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "patch": "@@ -0,0 +1,109 @@\n+use errors::Applicability;\n+use syntax::parse::lexer::{TokenAndSpan, StringReader as Lexer};\n+use syntax::parse::{ParseSess, token};\n+use syntax::source_map::FilePathMapping;\n+use syntax_pos::FileName;\n+\n+use clean;\n+use core::DocContext;\n+use fold::DocFolder;\n+use html::markdown::{self, RustCodeBlock};\n+use passes::Pass;\n+\n+pub const CHECK_CODE_BLOCK_SYNTAX: Pass =\n+    Pass::early(\"check-code-block-syntax\", check_code_block_syntax,\n+                \"validates syntax inside Rust code blocks\");\n+\n+pub fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext) -> clean::Crate {\n+    SyntaxChecker { cx }.fold_crate(krate)\n+}\n+\n+struct SyntaxChecker<'a, 'tcx: 'a, 'rcx: 'a> {\n+    cx: &'a DocContext<'a, 'tcx, 'rcx>,\n+}\n+\n+impl<'a, 'tcx, 'rcx> SyntaxChecker<'a, 'tcx, 'rcx> {\n+    fn check_rust_syntax(&self, item: &clean::Item, dox: &str, code_block: RustCodeBlock) {\n+        let sess = ParseSess::new(FilePathMapping::empty());\n+        let source_file = sess.source_map().new_source_file(\n+            FileName::Custom(String::from(\"doctest\")),\n+            dox[code_block.code].to_owned(),\n+        );\n+\n+        let errors = Lexer::new_or_buffered_errs(&sess, source_file, None).and_then(|mut lexer| {\n+            while let Ok(TokenAndSpan { tok, .. }) = lexer.try_next_token() {\n+                if tok == token::Eof {\n+                    break;\n+                }\n+            }\n+\n+            let errors = lexer.buffer_fatal_errors();\n+\n+            if !errors.is_empty() {\n+                Err(errors)\n+            } else {\n+                Ok(())\n+            }\n+        });\n+\n+        if let Err(errors) = errors {\n+            let mut diag = if let Some(sp) =\n+                super::source_span_for_markdown_range(self.cx, &dox, &code_block.range, &item.attrs)\n+            {\n+                let mut diag = self\n+                    .cx\n+                    .sess()\n+                    .struct_span_warn(sp, \"could not parse code block as Rust code\");\n+\n+                for mut err in errors {\n+                    diag.note(&format!(\"error from rustc: {}\", err.message()));\n+                    err.cancel();\n+                }\n+\n+                if code_block.syntax.is_none() && code_block.is_fenced {\n+                    let sp = sp.from_inner_byte_pos(0, 3);\n+                    diag.span_suggestion_with_applicability(\n+                        sp,\n+                        \"mark blocks that do not contain Rust code as text\",\n+                        String::from(\"```text\"),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+\n+                diag\n+            } else {\n+                // We couldn't calculate the span of the markdown block that had the error, so our\n+                // diagnostics are going to be a bit lacking.\n+                let mut diag = self.cx.sess().struct_span_warn(\n+                    super::span_of_attrs(&item.attrs),\n+                    \"doc comment contains an invalid Rust code block\",\n+                );\n+\n+                for mut err in errors {\n+                    // Don't bother reporting the error, because we can't show where it happened.\n+                    err.cancel();\n+                }\n+\n+                if code_block.syntax.is_none() && code_block.is_fenced {\n+                    diag.help(\"mark blocks that do not contain Rust code as text: ```text\");\n+                }\n+\n+                diag\n+            };\n+\n+            diag.emit();\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'rcx> DocFolder for SyntaxChecker<'a, 'tcx, 'rcx> {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        if let Some(dox) = &item.attrs.collapsed_doc_value() {\n+            for code_block in markdown::rust_code_blocks(&dox) {\n+                self.check_rust_syntax(&item, &dox, code_block);\n+            }\n+        }\n+\n+        self.fold_item_recur(item)\n+    }\n+}"}, {"sha": "3d6096b07ce435b6b2ec9c47a397aebe7999f68f", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "patch": "@@ -6,7 +6,7 @@ use syntax;\n use syntax::ast::{self, Ident, NodeId};\n use syntax::feature_gate::UnstableFeatures;\n use syntax::symbol::Symbol;\n-use syntax_pos::{self, DUMMY_SP};\n+use syntax_pos::DUMMY_SP;\n \n use std::ops::Range;\n \n@@ -16,6 +16,7 @@ use html::markdown::markdown_links;\n \n use clean::*;\n use passes::{look_for_tests, Pass};\n+use super::span_of_attrs;\n \n pub const COLLECT_INTRA_DOC_LINKS: Pass =\n     Pass::early(\"collect-intra-doc-links\", collect_intra_doc_links,\n@@ -440,15 +441,6 @@ fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     None\n }\n \n-pub fn span_of_attrs(attrs: &Attributes) -> syntax_pos::Span {\n-    if attrs.doc_strings.is_empty() {\n-        return DUMMY_SP;\n-    }\n-    let start = attrs.doc_strings[0].span();\n-    let end = attrs.doc_strings.last().expect(\"No doc strings provided\").span();\n-    start.to(end)\n-}\n-\n /// Reports a resolution failure diagnostic.\n ///\n /// If we cannot find the exact source span of the resolution failure, we use the span of the"}, {"sha": "c9a3a2c003fe05415f11ef20ca3b676bffa45385", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "patch": "@@ -8,7 +8,7 @@ use rustc::util::nodemap::DefIdSet;\n use std::mem;\n use std::fmt;\n use syntax::ast::NodeId;\n-use syntax_pos::Span;\n+use syntax_pos::{DUMMY_SP, Span};\n use std::ops::Range;\n \n use clean::{self, GetDefId, Item};\n@@ -18,8 +18,6 @@ use fold::StripItem;\n \n use html::markdown::{find_testable_code, ErrorCodes, LangString};\n \n-use self::collect_intra_doc_links::span_of_attrs;\n-\n mod collapse_docs;\n pub use self::collapse_docs::COLLAPSE_DOCS;\n \n@@ -47,6 +45,9 @@ pub use self::private_items_doc_tests::CHECK_PRIVATE_ITEMS_DOC_TESTS;\n mod collect_trait_impls;\n pub use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n \n+mod check_code_block_syntax;\n+pub use self::check_code_block_syntax::CHECK_CODE_BLOCK_SYNTAX;\n+\n /// Represents a single pass.\n #[derive(Copy, Clone)]\n pub enum Pass {\n@@ -137,6 +138,7 @@ pub const PASSES: &'static [Pass] = &[\n     STRIP_PRIV_IMPORTS,\n     PROPAGATE_DOC_CFG,\n     COLLECT_INTRA_DOC_LINKS,\n+    CHECK_CODE_BLOCK_SYNTAX,\n     COLLECT_TRAIT_IMPLS,\n ];\n \n@@ -147,6 +149,7 @@ pub const DEFAULT_PASSES: &'static [&'static str] = &[\n     \"strip-hidden\",\n     \"strip-private\",\n     \"collect-intra-doc-links\",\n+    \"check-code-block-syntax\",\n     \"collapse-docs\",\n     \"unindent-comments\",\n     \"propagate-doc-cfg\",\n@@ -158,6 +161,7 @@ pub const DEFAULT_PRIVATE_PASSES: &'static [&'static str] = &[\n     \"check-private-items-doc-tests\",\n     \"strip-priv-imports\",\n     \"collect-intra-doc-links\",\n+    \"check-code-block-syntax\",\n     \"collapse-docs\",\n     \"unindent-comments\",\n     \"propagate-doc-cfg\",\n@@ -399,6 +403,16 @@ pub fn look_for_tests<'a, 'tcx: 'a, 'rcx: 'a>(\n     }\n }\n \n+/// Return a span encompassing all the given attributes.\n+crate fn span_of_attrs(attrs: &clean::Attributes) -> Span {\n+    if attrs.doc_strings.is_empty() {\n+        return DUMMY_SP;\n+    }\n+    let start = attrs.doc_strings[0].span();\n+    let end = attrs.doc_strings.last().expect(\"No doc strings provided\").span();\n+    start.to(end)\n+}\n+\n /// Attempts to match a range of bytes from parsed markdown to a `Span` in the source code.\n ///\n /// This method will return `None` if we cannot construct a span from the source map or if the"}, {"sha": "53650bd55aea3e2253fa5ba98cd665392fa16099", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "patch": "@@ -238,19 +238,6 @@ impl<'a> StringReader<'a> {\n         sr\n     }\n \n-    pub fn new_without_err(sess: &'a ParseSess,\n-                           source_file: Lrc<syntax_pos::SourceFile>,\n-                           override_span: Option<Span>,\n-                           prepend_error_text: &str) -> Result<Self, ()> {\n-        let mut sr = StringReader::new_raw(sess, source_file, override_span);\n-        if sr.advance_token().is_err() {\n-            eprintln!(\"{}\", prepend_error_text);\n-            sr.emit_fatal_errors();\n-            return Err(());\n-        }\n-        Ok(sr)\n-    }\n-\n     pub fn new_or_buffered_errs(sess: &'a ParseSess,\n                                 source_file: Lrc<syntax_pos::SourceFile>,\n                                 override_span: Option<Span>) -> Result<Self, Vec<Diagnostic>> {"}, {"sha": "924e0386d3191e00b3414db3392ee43af9e26133", "filename": "src/test/rustdoc-ui/invalid-syntax.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.rs?ref=8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "patch": "@@ -1,7 +1,66 @@\n // compile-pass\n-// compile-flags: --error-format=human\n \n /// ```\n /// \\__________pkt->size___________/          \\_result->size_/ \\__pkt->size__/\n /// ```\n pub fn foo() {}\n+\n+/// ```\n+///    |\n+/// LL | use foobar::Baz;\n+///    |     ^^^^^^ did you mean `baz::foobar`?\n+/// ```\n+pub fn bar() {}\n+\n+/// ```\n+/// valid\n+/// ```\n+///\n+/// ```\n+/// \\_\n+/// ```\n+///\n+/// ```text\n+/// \"invalid\n+/// ```\n+pub fn valid_and_invalid() {}\n+\n+/// This is a normal doc comment, but...\n+///\n+/// There's a code block with bad syntax in it:\n+///\n+/// ```rust\n+/// \\_\n+/// ```\n+///\n+/// Good thing we tested it!\n+pub fn baz() {}\n+\n+/// Indented block start\n+///\n+///     code with bad syntax\n+///     \\_\n+///\n+/// Indented block end\n+pub fn quux() {}\n+\n+/// Unclosed fence\n+///\n+/// ```\n+/// slkdjf\n+pub fn xyzzy() {}\n+\n+/// Indented code that contains a fence\n+///\n+///     ```\n+pub fn blah() {}\n+\n+/// ```edition2018\n+/// \\_\n+/// ```\n+pub fn blargh() {}\n+\n+#[doc = \"```\"]\n+/// \\_\n+#[doc = \"```\"]\n+pub fn crazy_attrs() {}"}, {"sha": "10800380a05d3ca34d13d4ab0fd04431d426edb7", "filename": "src/test/rustdoc-ui/invalid-syntax.stderr", "status": "modified", "additions": 96, "deletions": 9, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr?ref=8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "patch": "@@ -1,10 +1,97 @@\n-Output from rustc:\n-error: unknown start of token: /\n- --> <stdin>:1:1\n-  |\n-1 | /__________pkt->size___________/          /_result->size_/ /__pkt->size__/\n-  | ^\n-\n-warning: Invalid doc comment starting with: `/__________pkt->size___________/          /_result->size_/ /__pkt->size__/`\n-(Ignoring this codeblock)\n+warning: could not parse code block as Rust code\n+  --> $DIR/invalid-syntax.rs:3:5\n+   |\n+LL |   /// ```\n+   |  _____^\n+LL | | /// /__________pkt->size___________/          /_result->size_/ /__pkt->size__/\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = note: error from rustc: unknown start of token: /\n+help: mark blocks that do not contain Rust code as text\n+   |\n+LL | /// ```text\n+   |     ^^^^^^^\n+\n+warning: could not parse code block as Rust code\n+  --> $DIR/invalid-syntax.rs:8:5\n+   |\n+LL |   /// ```\n+   |  _____^\n+LL | | ///    |\n+LL | | /// LL | use foobar::Baz;\n+LL | | ///    |     ^^^^^^ did you mean `baz::foobar`?\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = note: error from rustc: unknown start of token: `\n+help: mark blocks that do not contain Rust code as text\n+   |\n+LL | /// ```text\n+   |     ^^^^^^^\n+\n+warning: could not parse code block as Rust code\n+  --> $DIR/invalid-syntax.rs:19:5\n+   |\n+LL |   /// ```\n+   |  _____^\n+LL | | /// /_\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = note: error from rustc: unknown start of token: /\n+help: mark blocks that do not contain Rust code as text\n+   |\n+LL | /// ```text\n+   |     ^^^^^^^\n+\n+warning: could not parse code block as Rust code\n+  --> $DIR/invalid-syntax.rs:32:5\n+   |\n+LL |   /// ```rust\n+   |  _____^\n+LL | | /// /_\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = note: error from rustc: unknown start of token: /\n+\n+warning: could not parse code block as Rust code\n+  --> $DIR/invalid-syntax.rs:41:9\n+   |\n+LL |   ///     code with bad syntax\n+   |  _________^\n+LL | | ///     /_\n+   | |__________^\n+   |\n+   = note: error from rustc: unknown start of token: /\n+\n+warning: could not parse code block as Rust code\n+  --> $DIR/invalid-syntax.rs:55:9\n+   |\n+LL | ///     ```\n+   |         ^^^\n+   |\n+   = note: error from rustc: unknown start of token: `\n+\n+warning: could not parse code block as Rust code\n+  --> $DIR/invalid-syntax.rs:58:5\n+   |\n+LL |   /// ```edition2018\n+   |  _____^\n+LL | | /// /_\n+LL | | /// ```\n+   | |_______^\n+   |\n+   = note: error from rustc: unknown start of token: /\n+\n+warning: doc comment contains an invalid Rust code block\n+  --> $DIR/invalid-syntax.rs:63:1\n+   |\n+LL | / #[doc = \"```\"]\n+LL | | /// /_\n+LL | | #[doc = \"```\"]\n+   | |______________^\n+   |\n+   = help: mark blocks that do not contain Rust code as text: ```text\n "}, {"sha": "0ab2f68fcdebe555e9139706f148e58bfc43d363", "filename": "src/test/rustdoc/bad-codeblock-syntax.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Ftest%2Frustdoc%2Fbad-codeblock-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7/src%2Ftest%2Frustdoc%2Fbad-codeblock-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fbad-codeblock-syntax.rs?ref=8c93798e9f80d6d6ed9a2ab4b01af06a8fea23b7", "patch": "@@ -0,0 +1,27 @@\n+// @has bad_codeblock_syntax/fn.foo.html\n+// @has - '//*[@class=\"docblock\"]/pre/code' '\\_'\n+/// ```\n+/// \\_\n+/// ```\n+pub fn foo() {}\n+\n+// @has bad_codeblock_syntax/fn.bar.html\n+// @has - '//*[@class=\"docblock\"]/pre/code' '`baz::foobar`'\n+/// ```\n+/// `baz::foobar`\n+/// ```\n+pub fn bar() {}\n+\n+// @has bad_codeblock_syntax/fn.quux.html\n+// @has - '//*[@class=\"docblock\"]/pre/code' '\\_'\n+/// ```rust\n+/// \\_\n+/// ```\n+pub fn quux() {}\n+\n+// @has bad_codeblock_syntax/fn.ok.html\n+// @has - '//*[@class=\"docblock\"]/pre/code[@class=\"language-text\"]' '\\_'\n+/// ```text\n+/// \\_\n+/// ```\n+pub fn ok() {}"}]}