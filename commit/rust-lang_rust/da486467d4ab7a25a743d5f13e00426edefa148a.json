{"sha": "da486467d4ab7a25a743d5f13e00426edefa148a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNDg2NDY3ZDRhYjdhMjVhNzQzZDVmMTNlMDA0MjZlZGVmYTE0OGE=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-10-24T12:12:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-24T12:12:18Z"}, "message": "Rollup merge of #78300 - richkadel:coverage-cx, r=wesleywiser\n\nMake codegen coverage_context optional, and check\n\nAddresses Issue #78286\n\nLibraries compiled with coverage and linked with out enabling coverage\nwould fail when attempting to add the library's coverage statements to\nthe codegen coverage context (None).\n\nNow, if coverage statements are encountered while compiling / linking\nwith `-Z instrument-coverage` disabled, codegen will *not* attempt to\nadd code regions to a coverage map, and it will not inject the LLVM\ninstrprof_increment intrinsic calls.", "tree": {"sha": "9f02aa54126da5a0543bd310e75a83b51457a2f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f02aa54126da5a0543bd310e75a83b51457a2f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da486467d4ab7a25a743d5f13e00426edefa148a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJflBoiCRBK7hj4Ov3rIwAAdHIIADbt8rrI2pRAUvALkAGepU8M\nHF1/moJ4vS9e5pGkPBcGpQmwubOw6ThhZS8SxogYH5vrRMTgSDCpNHnk3fh2K+np\nasLPcPnAc/5QE1SwojaoartVx7+I8eF/0i/HXT8EpuwOicA9nRJe9wSifuKYTHTY\nSoNSCPfhtYLwgnPsdmYDFYwiYmGTOjg8kRcuzdqNHszuXYz+W25bGXb4d/HWsYvb\nhS9mOwLCWaxkrR79gyBhxpnsue6jpP+/ru2ywkaU3Dniavn8LeDrAw3/gp3iJHTV\nU/Z100BUFZkuAq/Lktsn1ChL1u9Fpfpm0fhrEvw7uspXojmD4vwvwGO1xDlmUAs=\n=uFLP\n-----END PGP SIGNATURE-----\n", "payload": "tree 9f02aa54126da5a0543bd310e75a83b51457a2f1\nparent a07fc3d86508c43476a7721c091482243544bfcf\nparent f75a236fe0751a0d9bfb740c32eec14da787f112\nauthor Jonas Schievink <jonasschievink@gmail.com> 1603541538 +0200\ncommitter GitHub <noreply@github.com> 1603541538 +0200\n\nRollup merge of #78300 - richkadel:coverage-cx, r=wesleywiser\n\nMake codegen coverage_context optional, and check\n\nAddresses Issue #78286\n\nLibraries compiled with coverage and linked with out enabling coverage\nwould fail when attempting to add the library's coverage statements to\nthe codegen coverage context (None).\n\nNow, if coverage statements are encountered while compiling / linking\nwith `-Z instrument-coverage` disabled, codegen will *not* attempt to\nadd code regions to a coverage map, and it will not inject the LLVM\ninstrprof_increment intrinsic calls.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da486467d4ab7a25a743d5f13e00426edefa148a", "html_url": "https://github.com/rust-lang/rust/commit/da486467d4ab7a25a743d5f13e00426edefa148a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da486467d4ab7a25a743d5f13e00426edefa148a/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a07fc3d86508c43476a7721c091482243544bfcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a07fc3d86508c43476a7721c091482243544bfcf", "html_url": "https://github.com/rust-lang/rust/commit/a07fc3d86508c43476a7721c091482243544bfcf"}, {"sha": "f75a236fe0751a0d9bfb740c32eec14da787f112", "url": "https://api.github.com/repos/rust-lang/rust/commits/f75a236fe0751a0d9bfb740c32eec14da787f112", "html_url": "https://github.com/rust-lang/rust/commit/f75a236fe0751a0d9bfb740c32eec14da787f112"}], "stats": {"total": 124, "additions": 74, "deletions": 50}, "files": [{"sha": "56ff580b43b5989ba293e3ab31381dd17d22a194", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da486467d4ab7a25a743d5f13e00426edefa148a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da486467d4ab7a25a743d5f13e00426edefa148a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=da486467d4ab7a25a743d5f13e00426edefa148a", "patch": "@@ -324,8 +324,8 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn coverage_context(&'a self) -> &'a coverageinfo::CrateCoverageContext<'tcx> {\n-        self.coverage_cx.as_ref().unwrap()\n+    pub fn coverage_context(&'a self) -> Option<&'a coverageinfo::CrateCoverageContext<'tcx>> {\n+        self.coverage_cx.as_ref()\n     }\n }\n "}, {"sha": "c1163a871cf1f311047ad6ad61daf274592cf0c9", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/da486467d4ab7a25a743d5f13e00426edefa148a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da486467d4ab7a25a743d5f13e00426edefa148a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=da486467d4ab7a25a743d5f13e00426edefa148a", "patch": "@@ -26,7 +26,10 @@ use tracing::debug;\n /// undocumented details in Clang's implementation (that may or may not be important) were also\n /// replicated for Rust's Coverage Map.\n pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n-    let function_coverage_map = cx.coverage_context().take_function_coverage_map();\n+    let function_coverage_map = match cx.coverage_context() {\n+        Some(ctx) => ctx.take_function_coverage_map(),\n+        None => return,\n+    };\n     if function_coverage_map.is_empty() {\n         // This module has no functions with coverage instrumentation\n         return;"}, {"sha": "7fdbe1a55128ae2f438b5afc5a1c03baa12ab559", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/da486467d4ab7a25a743d5f13e00426edefa148a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da486467d4ab7a25a743d5f13e00426edefa148a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=da486467d4ab7a25a743d5f13e00426edefa148a", "patch": "@@ -64,17 +64,22 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         function_source_hash: u64,\n         id: CounterValueReference,\n         region: CodeRegion,\n-    ) {\n-        debug!(\n-            \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={:?}, \\\n-             at {:?}\",\n-            instance, function_source_hash, id, region,\n-        );\n-        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n-        coverage_regions\n-            .entry(instance)\n-            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_counter(function_source_hash, id, region);\n+    ) -> bool {\n+        if let Some(coverage_context) = self.coverage_context() {\n+            debug!(\n+                \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={:?}, \\\n+                at {:?}\",\n+                instance, function_source_hash, id, region,\n+            );\n+            let mut coverage_regions = coverage_context.function_coverage_map.borrow_mut();\n+            coverage_regions\n+                .entry(instance)\n+                .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+                .add_counter(function_source_hash, id, region);\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     fn add_counter_expression_region(\n@@ -85,29 +90,39 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         op: Op,\n         rhs: ExpressionOperandId,\n         region: CodeRegion,\n-    ) {\n-        debug!(\n-            \"adding counter expression to coverage_regions: instance={:?}, id={:?}, {:?} {:?} {:?}, \\\n-             at {:?}\",\n-            instance, id, lhs, op, rhs, region,\n-        );\n-        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n-        coverage_regions\n-            .entry(instance)\n-            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_counter_expression(id, lhs, op, rhs, region);\n+    ) -> bool {\n+        if let Some(coverage_context) = self.coverage_context() {\n+            debug!(\n+                \"adding counter expression to coverage_regions: instance={:?}, id={:?}, {:?} {:?} {:?}, \\\n+                at {:?}\",\n+                instance, id, lhs, op, rhs, region,\n+            );\n+            let mut coverage_regions = coverage_context.function_coverage_map.borrow_mut();\n+            coverage_regions\n+                .entry(instance)\n+                .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+                .add_counter_expression(id, lhs, op, rhs, region);\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n-    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion) {\n-        debug!(\n-            \"adding unreachable code to coverage_regions: instance={:?}, at {:?}\",\n-            instance, region,\n-        );\n-        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n-        coverage_regions\n-            .entry(instance)\n-            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_unreachable_region(region);\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion) -> bool {\n+        if let Some(coverage_context) = self.coverage_context() {\n+            debug!(\n+                \"adding unreachable code to coverage_regions: instance={:?}, at {:?}\",\n+                instance, region,\n+            );\n+            let mut coverage_regions = coverage_context.function_coverage_map.borrow_mut();\n+            coverage_regions\n+                .entry(instance)\n+                .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+                .add_unreachable_region(region);\n+            true\n+        } else {\n+            false\n+        }\n     }\n }\n "}, {"sha": "4811adea9ec060851466bddf3a9256c9d2958f42", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/da486467d4ab7a25a743d5f13e00426edefa148a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da486467d4ab7a25a743d5f13e00426edefa148a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=da486467d4ab7a25a743d5f13e00426edefa148a", "patch": "@@ -10,19 +10,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let Coverage { kind, code_region } = coverage;\n         match kind {\n             CoverageKind::Counter { function_source_hash, id } => {\n-                bx.add_counter_region(self.instance, function_source_hash, id, code_region);\n+                if bx.add_counter_region(self.instance, function_source_hash, id, code_region) {\n+                    let coverageinfo = bx.tcx().coverageinfo(self.instance.def_id());\n \n-                let coverageinfo = bx.tcx().coverageinfo(self.instance.def_id());\n-\n-                let fn_name = bx.create_pgo_func_name_var(self.instance);\n-                let hash = bx.const_u64(function_source_hash);\n-                let num_counters = bx.const_u32(coverageinfo.num_counters);\n-                let id = bx.const_u32(u32::from(id));\n-                debug!(\n-                    \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n-                    fn_name, hash, num_counters, id,\n-                );\n-                bx.instrprof_increment(fn_name, hash, num_counters, id);\n+                    let fn_name = bx.create_pgo_func_name_var(self.instance);\n+                    let hash = bx.const_u64(function_source_hash);\n+                    let num_counters = bx.const_u32(coverageinfo.num_counters);\n+                    let id = bx.const_u32(u32::from(id));\n+                    debug!(\n+                        \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n+                        fn_name, hash, num_counters, id,\n+                    );\n+                    bx.instrprof_increment(fn_name, hash, num_counters, id);\n+                }\n             }\n             CoverageKind::Expression { id, lhs, op, rhs } => {\n                 bx.add_counter_expression_region(self.instance, id, lhs, op, rhs, code_region);"}, {"sha": "3b1654f3ad4fc94681bc0eff9f5821538afc2d47", "filename": "compiler/rustc_codegen_ssa/src/traits/coverageinfo.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da486467d4ab7a25a743d5f13e00426edefa148a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da486467d4ab7a25a743d5f13e00426edefa148a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs?ref=da486467d4ab7a25a743d5f13e00426edefa148a", "patch": "@@ -9,14 +9,18 @@ pub trait CoverageInfoMethods: BackendTypes {\n pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n     fn create_pgo_func_name_var(&self, instance: Instance<'tcx>) -> Self::Value;\n \n+    /// Returns true if the counter was added to the coverage map; false if `-Z instrument-coverage`\n+    /// is not enabled (a coverage map is not being generated).\n     fn add_counter_region(\n         &mut self,\n         instance: Instance<'tcx>,\n         function_source_hash: u64,\n         id: CounterValueReference,\n         region: CodeRegion,\n-    );\n+    ) -> bool;\n \n+    /// Returns true if the expression was added to the coverage map; false if\n+    /// `-Z instrument-coverage` is not enabled (a coverage map is not being generated).\n     fn add_counter_expression_region(\n         &mut self,\n         instance: Instance<'tcx>,\n@@ -25,7 +29,9 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n         op: Op,\n         rhs: ExpressionOperandId,\n         region: CodeRegion,\n-    );\n+    ) -> bool;\n \n-    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion);\n+    /// Returns true if the region was added to the coverage map; false if `-Z instrument-coverage`\n+    /// is not enabled (a coverage map is not being generated).\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion) -> bool;\n }"}]}