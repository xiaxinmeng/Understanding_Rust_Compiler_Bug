{"sha": "df889c9821970020abb8dbb1ed9b0014e38c6137", "node_id": "C_kwDOAAsO6NoAKGRmODg5Yzk4MjE5NzAwMjBhYmI4ZGJiMWVkOWIwMDE0ZTM4YzYxMzc", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-03T16:39:10Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-06T22:05:05Z"}, "message": "Rename assign_idx methods.", "tree": {"sha": "3147e72ef28963bd71867fac837fa2dabfa7c7da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3147e72ef28963bd71867fac837fa2dabfa7c7da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df889c9821970020abb8dbb1ed9b0014e38c6137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df889c9821970020abb8dbb1ed9b0014e38c6137", "html_url": "https://github.com/rust-lang/rust/commit/df889c9821970020abb8dbb1ed9b0014e38c6137", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df889c9821970020abb8dbb1ed9b0014e38c6137/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67a8c16fe285dc5dc3ca8a0c74fb1bcfa58ce8dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/67a8c16fe285dc5dc3ca8a0c74fb1bcfa58ce8dc", "html_url": "https://github.com/rust-lang/rust/commit/67a8c16fe285dc5dc3ca8a0c74fb1bcfa58ce8dc"}], "stats": {"total": 70, "additions": 39, "deletions": 31}, "files": [{"sha": "2da7cdd02a7f8f4303ae7e03f09b7d8656dc6f57", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/df889c9821970020abb8dbb1ed9b0014e38c6137/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df889c9821970020abb8dbb1ed9b0014e38c6137/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=df889c9821970020abb8dbb1ed9b0014e38c6137", "patch": "@@ -24,7 +24,7 @@\n //! - The bottom state denotes uninitialized memory. Because we are only doing a sound approximation\n //! of the actual execution, we can also use this state for places where access would be UB.\n //!\n-//! - The assignment logic in `State::assign_place_idx` assumes that the places are non-overlapping,\n+//! - The assignment logic in `State::insert_place_idx` assumes that the places are non-overlapping,\n //! or identical. Note that this refers to place expressions, not memory locations.\n //!\n //! - Currently, places that have their reference taken cannot be tracked. Although this would be\n@@ -470,59 +470,68 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n         self.flood_discr_with(place, map, V::top())\n     }\n \n+    /// Low-level method that assigns to a place.\n+    /// This does nothing if the place is not tracked.\n+    ///\n+    /// The target place must have been flooded before calling this method.\n+    pub fn insert_idx(&mut self, target: PlaceIndex, result: ValueOrPlace<V>, map: &Map) {\n+        match result {\n+            ValueOrPlace::Value(value) => self.insert_value_idx(target, value, map),\n+            ValueOrPlace::Place(source) => self.insert_place_idx(target, source, map),\n+        }\n+    }\n+\n+    /// Low-level method that assigns a value to a place.\n+    /// This does nothing if the place is not tracked.\n+    ///\n+    /// The target place must have been flooded before calling this method.\n+    pub fn insert_value_idx(&mut self, target: PlaceIndex, value: V, map: &Map) {\n+        let StateData::Reachable(values) = &mut self.0 else { return };\n+        if let Some(value_index) = map.places[target].value_index {\n+            values[value_index] = value;\n+        }\n+    }\n+\n     /// Copies `source` to `target`, including all tracked places beneath.\n     ///\n     /// If `target` contains a place that is not contained in `source`, it will be overwritten with\n     /// Top. Also, because this will copy all entries one after another, it may only be used for\n     /// places that are non-overlapping or identical.\n     ///\n     /// The target place must have been flooded before calling this method.\n-    fn assign_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n+    fn insert_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n \n-        // If both places are tracked, we copy the value to the target. If the target is tracked,\n-        // but the source is not, we have to invalidate the value in target. If the target is not\n-        // tracked, then we don't have to do anything.\n+        // If both places are tracked, we copy the value to the target.\n+        // If the target is tracked, but the source is not, we do nothing, as invalidation has\n+        // already been performed.\n         if let Some(target_value) = map.places[target].value_index {\n             if let Some(source_value) = map.places[source].value_index {\n                 values[target_value] = values[source_value].clone();\n-            } else {\n-                values[target_value] = V::top();\n             }\n         }\n         for target_child in map.children(target) {\n             // Try to find corresponding child and recurse. Reasoning is similar as above.\n             let projection = map.places[target_child].proj_elem.unwrap();\n             if let Some(source_child) = map.projections.get(&(source, projection)) {\n-                self.assign_place_idx(target_child, *source_child, map);\n+                self.insert_place_idx(target_child, *source_child, map);\n             }\n         }\n     }\n \n+    /// Helper method to interpret `target = result`.\n     pub fn assign(&mut self, target: PlaceRef<'_>, result: ValueOrPlace<V>, map: &Map) {\n         self.flood(target, map);\n         if let Some(target) = map.find(target) {\n-            self.assign_idx(target, result, map);\n+            self.insert_idx(target, result, map);\n         }\n     }\n \n+    /// Helper method for assignments to a discriminant.\n     pub fn assign_discr(&mut self, target: PlaceRef<'_>, result: ValueOrPlace<V>, map: &Map) {\n         self.flood_discr(target, map);\n         if let Some(target) = map.find_discr(target) {\n-            self.assign_idx(target, result, map);\n-        }\n-    }\n-\n-    /// The target place must have been flooded before calling this method.\n-    pub fn assign_idx(&mut self, target: PlaceIndex, result: ValueOrPlace<V>, map: &Map) {\n-        match result {\n-            ValueOrPlace::Value(value) => {\n-                let StateData::Reachable(values) = &mut self.0 else { return };\n-                if let Some(value_index) = map.places[target].value_index {\n-                    values[value_index] = value;\n-                }\n-            }\n-            ValueOrPlace::Place(source) => self.assign_place_idx(target, source, map),\n+            self.insert_idx(target, result, map);\n         }\n     }\n "}, {"sha": "d715e250ca4eb325650c1e40e2b3146cbab1e836", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/df889c9821970020abb8dbb1ed9b0014e38c6137/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df889c9821970020abb8dbb1ed9b0014e38c6137/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=df889c9821970020abb8dbb1ed9b0014e38c6137", "patch": "@@ -144,7 +144,7 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n                                 .apply(target, TrackElem::Field(Field::from_usize(field_index)))\n                             {\n                                 let result = self.handle_operand(operand, state);\n-                                state.assign_idx(field, result, self.map());\n+                                state.insert_idx(field, result, self.map());\n                             }\n                         }\n                     }\n@@ -153,12 +153,13 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n                     {\n                         let enum_ty = target.ty(self.local_decls, self.tcx).ty;\n                         if let Some(discr_val) = self.eval_disciminant(enum_ty, variant_index) {\n-                            state.assign_idx(discr_idx, ValueOrPlace::Value(FlatSet::Elem(discr_val)), &self.map);\n+                            state.insert_value_idx(discr_idx, FlatSet::Elem(discr_val), &self.map);\n                         }\n                     }\n                 }\n             }\n             Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n+                // Flood everything now, so we can use `insert_value_idx` directly later.\n                 state.flood(target.as_ref(), self.map());\n \n                 let target = self.map().find(target.as_ref());\n@@ -172,7 +173,8 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n                     let (val, overflow) = self.binary_op(state, *op, left, right);\n \n                     if let Some(value_target) = value_target {\n-                        state.assign_idx(value_target, ValueOrPlace::Value(val), self.map());\n+                        // We have flooded `target` earlier.\n+                        state.insert_value_idx(value_target, val, self.map());\n                     }\n                     if let Some(overflow_target) = overflow_target {\n                         let overflow = match overflow {\n@@ -187,11 +189,8 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n                             }\n                             FlatSet::Bottom => FlatSet::Bottom,\n                         };\n-                        state.assign_idx(\n-                            overflow_target,\n-                            ValueOrPlace::Value(overflow),\n-                            self.map(),\n-                        );\n+                        // We have flooded `target` earlier.\n+                        state.insert_value_idx(overflow_target, overflow, self.map());\n                     }\n                 }\n             }"}]}