{"sha": "3ba876a4a6528a6d1615346776492a41ecf66db2", "node_id": "C_kwDOAAsO6NoAKDNiYTg3NmE0YTY1MjhhNmQxNjE1MzQ2Nzc2NDkyYTQxZWNmNjZkYjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-03T17:03:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-03T17:03:39Z"}, "message": "Auto merge of #14240 - Veykril:coerce-many, r=Veykril\n\nDiagnose value breaks in incorrect breakables", "tree": {"sha": "8b0849c653186b7b3c71cd6b0664f577a5341482", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b0849c653186b7b3c71cd6b0664f577a5341482"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ba876a4a6528a6d1615346776492a41ecf66db2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba876a4a6528a6d1615346776492a41ecf66db2", "html_url": "https://github.com/rust-lang/rust/commit/3ba876a4a6528a6d1615346776492a41ecf66db2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ba876a4a6528a6d1615346776492a41ecf66db2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6756294aa0e8c0f41fd7a14acfa4fb2f77306be1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6756294aa0e8c0f41fd7a14acfa4fb2f77306be1", "html_url": "https://github.com/rust-lang/rust/commit/6756294aa0e8c0f41fd7a14acfa4fb2f77306be1"}, {"sha": "41f234df09440dcd9420cc752649c68135fc09ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/41f234df09440dcd9420cc752649c68135fc09ed", "html_url": "https://github.com/rust-lang/rust/commit/41f234df09440dcd9420cc752649c68135fc09ed"}], "stats": {"total": 370, "additions": 251, "deletions": 119}, "files": [{"sha": "336de14282147aee3213f5532ff1cbed81111de6", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ba876a4a6528a6d1615346776492a41ecf66db2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba876a4a6528a6d1615346776492a41ecf66db2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=3ba876a4a6528a6d1615346776492a41ecf66db2", "patch": "@@ -66,8 +66,10 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n     let mut ctx = InferenceContext::new(db, def, &body, resolver);\n \n     match def {\n+        DefWithBodyId::FunctionId(f) => {\n+            ctx.collect_fn(f);\n+        }\n         DefWithBodyId::ConstId(c) => ctx.collect_const(&db.const_data(c)),\n-        DefWithBodyId::FunctionId(f) => ctx.collect_fn(f),\n         DefWithBodyId::StaticId(s) => ctx.collect_static(&db.static_data(s)),\n         DefWithBodyId::VariantId(v) => {\n             ctx.return_ty = TyBuilder::builtin(match db.enum_data(v.parent).variant_body_type() {\n@@ -165,7 +167,8 @@ pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n     PrivateField { expr: ExprId, field: FieldId },\n     PrivateAssocItem { id: ExprOrPatId, item: AssocItemId },\n-    BreakOutsideOfLoop { expr: ExprId, is_break: bool },\n+    // FIXME: Make this proper\n+    BreakOutsideOfLoop { expr: ExprId, is_break: bool, bad_value_break: bool },\n     MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n }\n \n@@ -392,9 +395,12 @@ pub(crate) struct InferenceContext<'a> {\n     /// currently within one.\n     ///\n     /// We might consider using a nested inference context for checking\n-    /// closures, but currently this is the only field that will change there,\n-    /// so it doesn't make sense.\n+    /// closures so we can swap all shared things out at once.\n     return_ty: Ty,\n+    /// If `Some`, this stores coercion information for returned\n+    /// expressions. If `None`, this is in a context where return is\n+    /// inappropriate, such as a const expression.\n+    return_coercion: Option<CoerceMany>,\n     /// The resume type and the yield type, respectively, of the generator being inferred.\n     resume_yield_tys: Option<(Ty, Ty)>,\n     diverges: Diverges,\n@@ -406,7 +412,7 @@ struct BreakableContext {\n     /// Whether this context contains at least one break expression.\n     may_break: bool,\n     /// The coercion target of the context.\n-    coerce: CoerceMany,\n+    coerce: Option<CoerceMany>,\n     /// The optional label of the context.\n     label: Option<name::Name>,\n     kind: BreakableKind,\n@@ -462,6 +468,7 @@ impl<'a> InferenceContext<'a> {\n             trait_env,\n             return_ty: TyKind::Error.intern(Interner), // set in collect_* calls\n             resume_yield_tys: None,\n+            return_coercion: None,\n             db,\n             owner,\n             body,\n@@ -595,10 +602,19 @@ impl<'a> InferenceContext<'a> {\n         };\n \n         self.return_ty = self.normalize_associated_types_in(return_ty);\n+        self.return_coercion = Some(CoerceMany::new(self.return_ty.clone()));\n     }\n \n     fn infer_body(&mut self) {\n-        self.infer_expr_coerce(self.body.body_expr, &Expectation::has_type(self.return_ty.clone()));\n+        match self.return_coercion {\n+            Some(_) => self.infer_return(self.body.body_expr),\n+            None => {\n+                _ = self.infer_expr_coerce(\n+                    self.body.body_expr,\n+                    &Expectation::has_type(self.return_ty.clone()),\n+                )\n+            }\n+        }\n     }\n \n     fn write_expr_ty(&mut self, expr: ExprId, ty: Ty) {"}, {"sha": "8bce47d71cba64b9f2a376fb24d856d11380216e", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3ba876a4a6528a6d1615346776492a41ecf66db2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba876a4a6528a6d1615346776492a41ecf66db2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=3ba876a4a6528a6d1615346776492a41ecf66db2", "patch": "@@ -50,11 +50,44 @@ fn success(\n #[derive(Clone, Debug)]\n pub(super) struct CoerceMany {\n     expected_ty: Ty,\n+    final_ty: Option<Ty>,\n }\n \n impl CoerceMany {\n     pub(super) fn new(expected: Ty) -> Self {\n-        CoerceMany { expected_ty: expected }\n+        CoerceMany { expected_ty: expected, final_ty: None }\n+    }\n+\n+    /// Returns the \"expected type\" with which this coercion was\n+    /// constructed. This represents the \"downward propagated\" type\n+    /// that was given to us at the start of typing whatever construct\n+    /// we are typing (e.g., the match expression).\n+    ///\n+    /// Typically, this is used as the expected type when\n+    /// type-checking each of the alternative expressions whose types\n+    /// we are trying to merge.\n+    pub(super) fn expected_ty(&self) -> Ty {\n+        self.expected_ty.clone()\n+    }\n+\n+    /// Returns the current \"merged type\", representing our best-guess\n+    /// at the LUB of the expressions we've seen so far (if any). This\n+    /// isn't *final* until you call `self.complete()`, which will return\n+    /// the merged type.\n+    pub(super) fn merged_ty(&self) -> Ty {\n+        self.final_ty.clone().unwrap_or_else(|| self.expected_ty.clone())\n+    }\n+\n+    pub(super) fn complete(self, ctx: &mut InferenceContext<'_>) -> Ty {\n+        if let Some(final_ty) = self.final_ty {\n+            final_ty\n+        } else {\n+            ctx.result.standard_types.never.clone()\n+        }\n+    }\n+\n+    pub(super) fn coerce_forced_unit(&mut self, ctx: &mut InferenceContext<'_>) {\n+        self.coerce(ctx, None, &ctx.result.standard_types.unit.clone())\n     }\n \n     /// Merge two types from different branches, with possible coercion.\n@@ -76,51 +109,46 @@ impl CoerceMany {\n         // Special case: two function types. Try to coerce both to\n         // pointers to have a chance at getting a match. See\n         // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n-        let sig = match (self.expected_ty.kind(Interner), expr_ty.kind(Interner)) {\n+        let sig = match (self.merged_ty().kind(Interner), expr_ty.kind(Interner)) {\n             (TyKind::FnDef(..) | TyKind::Closure(..), TyKind::FnDef(..) | TyKind::Closure(..)) => {\n                 // FIXME: we're ignoring safety here. To be more correct, if we have one FnDef and one Closure,\n                 // we should be coercing the closure to a fn pointer of the safety of the FnDef\n                 cov_mark::hit!(coerce_fn_reification);\n                 let sig =\n-                    self.expected_ty.callable_sig(ctx.db).expect(\"FnDef without callable sig\");\n+                    self.merged_ty().callable_sig(ctx.db).expect(\"FnDef without callable sig\");\n                 Some(sig)\n             }\n             _ => None,\n         };\n         if let Some(sig) = sig {\n             let target_ty = TyKind::Function(sig.to_fn_ptr()).intern(Interner);\n-            let result1 = ctx.table.coerce_inner(self.expected_ty.clone(), &target_ty);\n+            let result1 = ctx.table.coerce_inner(self.merged_ty(), &target_ty);\n             let result2 = ctx.table.coerce_inner(expr_ty.clone(), &target_ty);\n             if let (Ok(result1), Ok(result2)) = (result1, result2) {\n                 ctx.table.register_infer_ok(result1);\n                 ctx.table.register_infer_ok(result2);\n-                return self.expected_ty = target_ty;\n+                return self.final_ty = Some(target_ty);\n             }\n         }\n \n         // It might not seem like it, but order is important here: If the expected\n         // type is a type variable and the new one is `!`, trying it the other\n         // way around first would mean we make the type variable `!`, instead of\n         // just marking it as possibly diverging.\n-        if ctx.coerce(expr, &expr_ty, &self.expected_ty).is_ok() {\n-            /* self.expected_ty is already correct */\n-        } else if ctx.coerce(expr, &self.expected_ty, &expr_ty).is_ok() {\n-            self.expected_ty = expr_ty;\n+        if let Ok(res) = ctx.coerce(expr, &expr_ty, &self.merged_ty()) {\n+            self.final_ty = Some(res);\n+        } else if let Ok(res) = ctx.coerce(expr, &self.merged_ty(), &expr_ty) {\n+            self.final_ty = Some(res);\n         } else {\n             if let Some(id) = expr {\n                 ctx.result.type_mismatches.insert(\n                     id.into(),\n-                    TypeMismatch { expected: self.expected_ty.clone(), actual: expr_ty },\n+                    TypeMismatch { expected: self.merged_ty().clone(), actual: expr_ty.clone() },\n                 );\n             }\n             cov_mark::hit!(coerce_merge_fail_fallback);\n-            /* self.expected_ty is already correct */\n         }\n     }\n-\n-    pub(super) fn complete(self) -> Ty {\n-        self.expected_ty\n-    }\n }\n \n pub fn could_coerce("}, {"sha": "e64b020c7fbd2ab3d1471d0a09175184fce91979", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 158, "deletions": 94, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/3ba876a4a6528a6d1615346776492a41ecf66db2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba876a4a6528a6d1615346776492a41ecf66db2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=3ba876a4a6528a6d1615346776492a41ecf66db2", "patch": "@@ -60,6 +60,10 @@ impl<'a> InferenceContext<'a> {\n         ty\n     }\n \n+    pub(crate) fn infer_expr_no_expect(&mut self, tgt_expr: ExprId) -> Ty {\n+        self.infer_expr_inner(tgt_expr, &Expectation::None)\n+    }\n+\n     /// Infer type of expression with possibly implicit coerce to the expected type.\n     /// Return the type after possible coercion.\n     pub(super) fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n@@ -99,17 +103,20 @@ impl<'a> InferenceContext<'a> {\n                 both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut coerce = CoerceMany::new(expected.coercion_target_type(&mut self.table));\n                 coerce.coerce(self, Some(then_branch), &then_ty);\n-                let else_ty = match else_branch {\n-                    Some(else_branch) => self.infer_expr_inner(else_branch, expected),\n-                    None => TyBuilder::unit(),\n-                };\n+                match else_branch {\n+                    Some(else_branch) => {\n+                        let else_ty = self.infer_expr_inner(else_branch, expected);\n+                        coerce.coerce(self, Some(else_branch), &else_ty);\n+                    }\n+                    None => {\n+                        coerce.coerce_forced_unit(self);\n+                    }\n+                }\n                 both_arms_diverge &= self.diverges;\n-                // FIXME: create a synthetic `else {}` so we have something to refer to here instead of None?\n-                coerce.coerce(self, else_branch, &else_ty);\n \n                 self.diverges = condition_diverges | both_arms_diverge;\n \n-                coerce.complete()\n+                coerce.complete(self)\n             }\n             &Expr::Let { pat, expr } => {\n                 let input_ty = self.infer_expr(expr, &Expectation::none());\n@@ -126,7 +133,7 @@ impl<'a> InferenceContext<'a> {\n                         let break_ty = self.table.new_type_var();\n                         let (breaks, ty) = self.with_breakable_ctx(\n                             BreakableKind::Block,\n-                            break_ty.clone(),\n+                            Some(break_ty.clone()),\n                             *label,\n                             |this| {\n                                 this.infer_block(\n@@ -146,7 +153,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Unsafe { body } => self.infer_expr(*body, expected),\n             Expr::Const { body } => {\n-                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n                     this.infer_expr(*body, expected)\n                 })\n                 .1\n@@ -162,7 +169,7 @@ impl<'a> InferenceContext<'a> {\n                 let ok_ty =\n                     self.resolve_associated_type(try_ty.clone(), self.resolve_ops_try_output());\n \n-                self.with_breakable_ctx(BreakableKind::Block, ok_ty.clone(), None, |this| {\n+                self.with_breakable_ctx(BreakableKind::Block, Some(ok_ty.clone()), None, |this| {\n                     this.infer_expr(*body, &Expectation::has_type(ok_ty));\n                 });\n \n@@ -172,14 +179,17 @@ impl<'a> InferenceContext<'a> {\n                 let ret_ty = self.table.new_type_var();\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_ret_coercion =\n+                    mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty.clone())));\n \n                 let (_, inner_ty) =\n-                    self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                    self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n                         this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty))\n                     });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n+                self.return_coercion = prev_ret_coercion;\n \n                 // Use the first type parameter as the output type of future.\n                 // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n@@ -193,7 +203,7 @@ impl<'a> InferenceContext<'a> {\n                 // let ty = expected.coercion_target_type(&mut self.table);\n                 let ty = self.table.new_type_var();\n                 let (breaks, ()) =\n-                    self.with_breakable_ctx(BreakableKind::Loop, ty, label, |this| {\n+                    self.with_breakable_ctx(BreakableKind::Loop, Some(ty), label, |this| {\n                         this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                     });\n \n@@ -206,7 +216,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n             &Expr::While { condition, body, label } => {\n-                self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n+                self.with_breakable_ctx(BreakableKind::Loop, None, label, |this| {\n                     this.infer_expr(\n                         condition,\n                         &Expectation::HasType(this.result.standard_types.bool_.clone()),\n@@ -226,7 +236,7 @@ impl<'a> InferenceContext<'a> {\n                     self.resolve_associated_type(into_iter_ty, self.resolve_iterator_item());\n \n                 self.infer_top_pat(pat, &pat_ty);\n-                self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n+                self.with_breakable_ctx(BreakableKind::Loop, None, label, |this| {\n                     this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                 });\n \n@@ -303,17 +313,21 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_top_pat(*arg_pat, &arg_ty);\n                 }\n \n+                // FIXME: lift these out into a struct\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_ret_coercion =\n+                    mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty.clone())));\n                 let prev_resume_yield_tys =\n                     mem::replace(&mut self.resume_yield_tys, resume_yield_tys);\n \n-                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n-                    this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n+                self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n+                    this.infer_return(*body);\n                 });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n+                self.return_coercion = prev_ret_coercion;\n                 self.resume_yield_tys = prev_resume_yield_tys;\n \n                 ty\n@@ -413,7 +427,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.diverges = matchee_diverges | all_arms_diverge;\n \n-                coerce.complete()\n+                coerce.complete(self)\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n@@ -425,51 +439,56 @@ impl<'a> InferenceContext<'a> {\n                     self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                         expr: tgt_expr,\n                         is_break: false,\n+                        bad_value_break: false,\n                     });\n                 };\n                 self.result.standard_types.never.clone()\n             }\n             Expr::Break { expr, label } => {\n                 let val_ty = if let Some(expr) = *expr {\n-                    self.infer_expr(expr, &Expectation::none())\n+                    let opt_coerce_to = match find_breakable(&mut self.breakables, label.as_ref()) {\n+                        Some(ctxt) => match &ctxt.coerce {\n+                            Some(coerce) => coerce.expected_ty(),\n+                            None => {\n+                                self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n+                                    expr: tgt_expr,\n+                                    is_break: true,\n+                                    bad_value_break: true,\n+                                });\n+                                self.err_ty()\n+                            }\n+                        },\n+                        None => self.err_ty(),\n+                    };\n+                    self.infer_expr_inner(expr, &Expectation::HasType(opt_coerce_to))\n                 } else {\n                     TyBuilder::unit()\n                 };\n \n                 match find_breakable(&mut self.breakables, label.as_ref()) {\n-                    Some(ctxt) => {\n-                        // avoiding the borrowck\n-                        let mut coerce = mem::replace(\n-                            &mut ctxt.coerce,\n-                            CoerceMany::new(expected.coercion_target_type(&mut self.table)),\n-                        );\n-\n-                        // FIXME: create a synthetic `()` during lowering so we have something to refer to here?\n-                        coerce.coerce(self, *expr, &val_ty);\n-\n-                        let ctxt = find_breakable(&mut self.breakables, label.as_ref())\n-                            .expect(\"breakable stack changed during coercion\");\n-                        ctxt.coerce = coerce;\n-                        ctxt.may_break = true;\n-                    }\n+                    Some(ctxt) => match ctxt.coerce.take() {\n+                        Some(mut coerce) => {\n+                            coerce.coerce(self, *expr, &val_ty);\n+\n+                            // Avoiding borrowck\n+                            let ctxt = find_breakable(&mut self.breakables, label.as_ref())\n+                                .expect(\"breakable stack changed during coercion\");\n+                            ctxt.may_break = true;\n+                            ctxt.coerce = Some(coerce);\n+                        }\n+                        None => ctxt.may_break = true,\n+                    },\n                     None => {\n                         self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                             expr: tgt_expr,\n                             is_break: true,\n+                            bad_value_break: false,\n                         });\n                     }\n                 }\n                 self.result.standard_types.never.clone()\n             }\n-            Expr::Return { expr } => {\n-                if let Some(expr) = expr {\n-                    self.infer_expr_coerce(*expr, &Expectation::has_type(self.return_ty.clone()));\n-                } else {\n-                    let unit = TyBuilder::unit();\n-                    let _ = self.coerce(Some(tgt_expr), &unit, &self.return_ty.clone());\n-                }\n-                self.result.standard_types.never.clone()\n-            }\n+            &Expr::Return { expr } => self.infer_expr_return(expr),\n             Expr::Yield { expr } => {\n                 if let Some((resume_ty, yield_ty)) = self.resume_yield_tys.clone() {\n                     if let Some(expr) = expr {\n@@ -486,7 +505,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Yeet { expr } => {\n                 if let &Some(expr) = expr {\n-                    self.infer_expr_inner(expr, &Expectation::None);\n+                    self.infer_expr_no_expect(expr);\n                 }\n                 self.result.standard_types.never.clone()\n             }\n@@ -614,7 +633,7 @@ impl<'a> InferenceContext<'a> {\n             Expr::Cast { expr, type_ref } => {\n                 let cast_ty = self.make_ty(type_ref);\n                 // FIXME: propagate the \"castable to\" expectation\n-                let _inner_ty = self.infer_expr_inner(*expr, &Expectation::None);\n+                let _inner_ty = self.infer_expr_no_expect(*expr);\n                 // FIXME check the cast...\n                 cast_ty\n             }\n@@ -810,53 +829,7 @@ impl<'a> InferenceContext<'a> {\n \n                 TyKind::Tuple(tys.len(), Substitution::from_iter(Interner, tys)).intern(Interner)\n             }\n-            Expr::Array(array) => {\n-                let elem_ty =\n-                    match expected.to_option(&mut self.table).as_ref().map(|t| t.kind(Interner)) {\n-                        Some(TyKind::Array(st, _) | TyKind::Slice(st)) => st.clone(),\n-                        _ => self.table.new_type_var(),\n-                    };\n-                let mut coerce = CoerceMany::new(elem_ty.clone());\n-\n-                let expected = Expectation::has_type(elem_ty.clone());\n-                let len = match array {\n-                    Array::ElementList { elements, .. } => {\n-                        for &expr in elements.iter() {\n-                            let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n-                            coerce.coerce(self, Some(expr), &cur_elem_ty);\n-                        }\n-                        consteval::usize_const(\n-                            self.db,\n-                            Some(elements.len() as u128),\n-                            self.resolver.krate(),\n-                        )\n-                    }\n-                    &Array::Repeat { initializer, repeat } => {\n-                        self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty));\n-                        self.infer_expr(\n-                            repeat,\n-                            &Expectation::HasType(\n-                                TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(Interner),\n-                            ),\n-                        );\n-\n-                        if let Some(g_def) = self.owner.as_generic_def_id() {\n-                            let generics = generics(self.db.upcast(), g_def);\n-                            consteval::eval_to_const(\n-                                repeat,\n-                                ParamLoweringMode::Placeholder,\n-                                self,\n-                                || generics,\n-                                DebruijnIndex::INNERMOST,\n-                            )\n-                        } else {\n-                            consteval::usize_const(self.db, None, self.resolver.krate())\n-                        }\n-                    }\n-                };\n-\n-                TyKind::Array(coerce.complete(), len).intern(Interner)\n-            }\n+            Expr::Array(array) => self.infer_expr_array(array, expected),\n             Expr::Literal(lit) => match lit {\n                 Literal::Bool(..) => self.result.standard_types.bool_.clone(),\n                 Literal::String(..) => {\n@@ -915,6 +888,97 @@ impl<'a> InferenceContext<'a> {\n         ty\n     }\n \n+    fn infer_expr_array(\n+        &mut self,\n+        array: &Array,\n+        expected: &Expectation,\n+    ) -> chalk_ir::Ty<Interner> {\n+        let elem_ty = match expected.to_option(&mut self.table).as_ref().map(|t| t.kind(Interner)) {\n+            Some(TyKind::Array(st, _) | TyKind::Slice(st)) => st.clone(),\n+            _ => self.table.new_type_var(),\n+        };\n+\n+        let krate = self.resolver.krate();\n+\n+        let expected = Expectation::has_type(elem_ty.clone());\n+        let (elem_ty, len) = match array {\n+            Array::ElementList { elements, .. } if elements.is_empty() => {\n+                (elem_ty, consteval::usize_const(self.db, Some(0), krate))\n+            }\n+            Array::ElementList { elements, .. } => {\n+                let mut coerce = CoerceMany::new(elem_ty.clone());\n+                for &expr in elements.iter() {\n+                    let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n+                    coerce.coerce(self, Some(expr), &cur_elem_ty);\n+                }\n+                (\n+                    coerce.complete(self),\n+                    consteval::usize_const(self.db, Some(elements.len() as u128), krate),\n+                )\n+            }\n+            &Array::Repeat { initializer, repeat } => {\n+                self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty.clone()));\n+                self.infer_expr(\n+                    repeat,\n+                    &Expectation::HasType(\n+                        TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(Interner),\n+                    ),\n+                );\n+\n+                (\n+                    elem_ty,\n+                    if let Some(g_def) = self.owner.as_generic_def_id() {\n+                        let generics = generics(self.db.upcast(), g_def);\n+                        consteval::eval_to_const(\n+                            repeat,\n+                            ParamLoweringMode::Placeholder,\n+                            self,\n+                            || generics,\n+                            DebruijnIndex::INNERMOST,\n+                        )\n+                    } else {\n+                        consteval::usize_const(self.db, None, krate)\n+                    },\n+                )\n+            }\n+        };\n+\n+        TyKind::Array(elem_ty, len).intern(Interner)\n+    }\n+\n+    pub(super) fn infer_return(&mut self, expr: ExprId) {\n+        let ret_ty = self\n+            .return_coercion\n+            .as_mut()\n+            .expect(\"infer_return called outside function body\")\n+            .expected_ty();\n+        let return_expr_ty = self.infer_expr_inner(expr, &Expectation::HasType(ret_ty));\n+        let mut coerce_many = self.return_coercion.take().unwrap();\n+        coerce_many.coerce(self, Some(expr), &return_expr_ty);\n+        self.return_coercion = Some(coerce_many);\n+    }\n+\n+    fn infer_expr_return(&mut self, expr: Option<ExprId>) -> Ty {\n+        match self.return_coercion {\n+            Some(_) => {\n+                if let Some(expr) = expr {\n+                    self.infer_return(expr);\n+                } else {\n+                    let mut coerce = self.return_coercion.take().unwrap();\n+                    coerce.coerce_forced_unit(self);\n+                    self.return_coercion = Some(coerce);\n+                }\n+            }\n+            None => {\n+                // FIXME: diagnose return outside of function\n+                if let Some(expr) = expr {\n+                    self.infer_expr_no_expect(expr);\n+                }\n+            }\n+        }\n+        self.result.standard_types.never.clone()\n+    }\n+\n     fn infer_expr_box(&mut self, inner_expr: ExprId, expected: &Expectation) -> Ty {\n         if let Some(box_id) = self.resolve_boxed_box() {\n             let table = &mut self.table;\n@@ -1656,16 +1720,16 @@ impl<'a> InferenceContext<'a> {\n     fn with_breakable_ctx<T>(\n         &mut self,\n         kind: BreakableKind,\n-        ty: Ty,\n+        ty: Option<Ty>,\n         label: Option<LabelId>,\n         cb: impl FnOnce(&mut Self) -> T,\n     ) -> (Option<Ty>, T) {\n         self.breakables.push({\n             let label = label.map(|label| self.body[label].name.clone());\n-            BreakableContext { kind, may_break: false, coerce: CoerceMany::new(ty), label }\n+            BreakableContext { kind, may_break: false, coerce: ty.map(CoerceMany::new), label }\n         });\n         let res = cb(self);\n         let ctx = self.breakables.pop().expect(\"breakable stack broken\");\n-        (ctx.may_break.then(|| ctx.coerce.complete()), res)\n+        (if ctx.may_break { ctx.coerce.map(|ctx| ctx.complete(self)) } else { None }, res)\n     }\n }"}, {"sha": "bb7468d466047ef79ab429b36252c792b660f425", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ba876a4a6528a6d1615346776492a41ecf66db2/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba876a4a6528a6d1615346776492a41ecf66db2/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=3ba876a4a6528a6d1615346776492a41ecf66db2", "patch": "@@ -140,6 +140,7 @@ pub struct PrivateField {\n pub struct BreakOutsideOfLoop {\n     pub expr: InFile<AstPtr<ast::Expr>>,\n     pub is_break: bool,\n+    pub bad_value_break: bool,\n }\n \n #[derive(Debug)]"}, {"sha": "bfc0d58cc783844484b42b8d625e70765f2cb93a", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ba876a4a6528a6d1615346776492a41ecf66db2/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba876a4a6528a6d1615346776492a41ecf66db2/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=3ba876a4a6528a6d1615346776492a41ecf66db2", "patch": "@@ -1381,11 +1381,15 @@ impl DefWithBody {\n                     let field = source_map.field_syntax(*expr);\n                     acc.push(NoSuchField { field }.into())\n                 }\n-                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n+                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop {\n+                    expr,\n+                    is_break,\n+                    bad_value_break,\n+                } => {\n                     let expr = source_map\n                         .expr_syntax(expr)\n                         .expect(\"break outside of loop in synthetic syntax\");\n-                    acc.push(BreakOutsideOfLoop { expr, is_break }.into())\n+                    acc.push(BreakOutsideOfLoop { expr, is_break, bad_value_break }.into())\n                 }\n                 hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n                     match source_map.expr_syntax(*call_expr) {"}, {"sha": "114face2dca8566ed569c5bddfd2dfc813dcf1f8", "filename": "crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3ba876a4a6528a6d1615346776492a41ecf66db2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba876a4a6528a6d1615346776492a41ecf66db2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs?ref=3ba876a4a6528a6d1615346776492a41ecf66db2", "patch": "@@ -7,10 +7,15 @@ pub(crate) fn break_outside_of_loop(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::BreakOutsideOfLoop,\n ) -> Diagnostic {\n-    let construct = if d.is_break { \"break\" } else { \"continue\" };\n+    let message = if d.bad_value_break {\n+        \"can't break with a value in this position\".to_owned()\n+    } else {\n+        let construct = if d.is_break { \"break\" } else { \"continue\" };\n+        format!(\"{construct} outside of loop\")\n+    };\n     Diagnostic::new(\n         \"break-outside-of-loop\",\n-        format!(\"{construct} outside of loop\"),\n+        message,\n         ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n     )\n }\n@@ -132,6 +137,20 @@ fn foo() {\n       //^^^^^^^^^^^ error: continue outside of loop\n     }\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn value_break_in_for_loop() {\n+        check_diagnostics(\n+            r#\"\n+fn test() {\n+    for _ in [()] {\n+        break 3;\n+     // ^^^^^^^ error: can't break with a value in this position\n+    }\n+}\n \"#,\n         );\n     }"}]}