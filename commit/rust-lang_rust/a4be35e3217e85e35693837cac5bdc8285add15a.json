{"sha": "a4be35e3217e85e35693837cac5bdc8285add15a", "node_id": "C_kwDOAAsO6NoAKGE0YmUzNWUzMjE3ZTg1ZTM1NjkzODM3Y2FjNWJkYzgyODVhZGQxNWE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-17T22:01:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-17T22:01:00Z"}, "message": "Rollup merge of #94041 - a-lafrance:try-collect, r=scottmcm\n\nAdd a `try_collect()` helper method to `Iterator`\n\nImplement `Iterator::try_collect()` as a helper around `Iterator::collect()` as discussed [here](https://internals.rust-lang.org/t/idea-fallible-iterator-mapping-with-try-map/15715/5?u=a.lafrance).\n\nFirst time contributor so definitely open to any feedback about my implementation! Specifically wondering if I should open a tracking issue for the unstable feature I introduced.\n\nAs the main participant in the internals discussion: r? `@scottmcm`", "tree": {"sha": "608b3473c0e899a5077912dc447b3678b94b68e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/608b3473c0e899a5077912dc447b3678b94b68e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4be35e3217e85e35693837cac5bdc8285add15a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiDsWcCRBK7hj4Ov3rIwAAVqoIAFNLIEsSNWgrC/3wRJV6wIBH\n9hJg23iRdsQz14HH234kakrRrY+9YPMjgEhtr9W6QaBsvNHsn+3jh4GetMO1g28d\nQYgIOmfTFJIaY0LPOYDCyTCKz9NyWeOlJSPMr3dM871nfpAeyXVXe7URm0W4+ED1\nLQaZ+vP4Jkt4jtkI1zsxCI76hwqs98XJE4LZK92fOWLXL2V2VFJFSVXVpJwJhh0f\nrtv0SBHl3GVjc/8yxq92yJD97datOZf4H49HOiW4M22FzQy48lgecApC4Fw9+QlY\nm4dyvBWQXOTEensok7PohbDGn209vgurevv+pkqPF/dZM9GODhDdWr02sJ0NaTo=\n=Rqbx\n-----END PGP SIGNATURE-----\n", "payload": "tree 608b3473c0e899a5077912dc447b3678b94b68e5\nparent 637d8b89e8b433f5eb93f9d7ea8e8599a15a6451\nparent 47d5196a00e25ef5683fd58f472ce44c82f8ae06\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645135260 +0100\ncommitter GitHub <noreply@github.com> 1645135260 +0100\n\nRollup merge of #94041 - a-lafrance:try-collect, r=scottmcm\n\nAdd a `try_collect()` helper method to `Iterator`\n\nImplement `Iterator::try_collect()` as a helper around `Iterator::collect()` as discussed [here](https://internals.rust-lang.org/t/idea-fallible-iterator-mapping-with-try-map/15715/5?u=a.lafrance).\n\nFirst time contributor so definitely open to any feedback about my implementation! Specifically wondering if I should open a tracking issue for the unstable feature I introduced.\n\nAs the main participant in the internals discussion: r? `@scottmcm`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4be35e3217e85e35693837cac5bdc8285add15a", "html_url": "https://github.com/rust-lang/rust/commit/a4be35e3217e85e35693837cac5bdc8285add15a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4be35e3217e85e35693837cac5bdc8285add15a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "637d8b89e8b433f5eb93f9d7ea8e8599a15a6451", "url": "https://api.github.com/repos/rust-lang/rust/commits/637d8b89e8b433f5eb93f9d7ea8e8599a15a6451", "html_url": "https://github.com/rust-lang/rust/commit/637d8b89e8b433f5eb93f9d7ea8e8599a15a6451"}, {"sha": "47d5196a00e25ef5683fd58f472ce44c82f8ae06", "url": "https://api.github.com/repos/rust-lang/rust/commits/47d5196a00e25ef5683fd58f472ce44c82f8ae06", "html_url": "https://github.com/rust-lang/rust/commit/47d5196a00e25ef5683fd58f472ce44c82f8ae06"}], "stats": {"total": 129, "additions": 129, "deletions": 0}, "files": [{"sha": "5a361edecd9c00298e95a3d91446d73a241a8f4d", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a4be35e3217e85e35693837cac5bdc8285add15a/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4be35e3217e85e35693837cac5bdc8285add15a/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=a4be35e3217e85e35693837cac5bdc8285add15a", "patch": "@@ -1,6 +1,7 @@\n use crate::cmp::{self, Ordering};\n use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, Residual, Try};\n \n+use super::super::try_process;\n use super::super::TrustedRandomAccessNoCoerce;\n use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n@@ -1777,6 +1778,87 @@ pub trait Iterator {\n         FromIterator::from_iter(self)\n     }\n \n+    /// Fallibly transforms an iterator into a collection, short circuiting if\n+    /// a failure is encountered.\n+    ///\n+    /// `try_collect()` is a variation of [`collect()`][`collect`] that allows fallible\n+    /// conversions during collection. Its main use case is simplifying conversions from\n+    /// iterators yielding [`Option<T>`][`Option`] into `Option<Collection<T>>`, or similarly for other [`Try`]\n+    /// types (e.g. [`Result`]).\n+    ///\n+    /// Importantly, `try_collect()` doesn't require that the outer [`Try`] type also implements [`FromIterator`];\n+    /// only the inner type produced on `Try::Output` must implement it. Concretely,\n+    /// this means that collecting into `ControlFlow<_, Vec<i32>>` is valid because `Vec<i32>` implements\n+    /// [`FromIterator`], even though [`ControlFlow`] doesn't.\n+    ///\n+    /// Also, if a failure is encountered during `try_collect()`, the iterator is still valid and\n+    /// may continue to be used, in which case it will continue iterating starting after the element that\n+    /// triggered the failure. See the last example below for an example of how this works.\n+    ///\n+    /// # Examples\n+    /// Successfully collecting an iterator of `Option<i32>` into `Option<Vec<i32>>`:\n+    /// ```\n+    /// #![feature(iterator_try_collect)]\n+    ///\n+    /// let u = vec![Some(1), Some(2), Some(3)];\n+    /// let v = u.into_iter().try_collect::<Vec<i32>>();\n+    /// assert_eq!(v, Some(vec![1, 2, 3]));\n+    /// ```\n+    ///\n+    /// Failing to collect in the same way:\n+    /// ```\n+    /// #![feature(iterator_try_collect)]\n+    ///\n+    /// let u = vec![Some(1), Some(2), None, Some(3)];\n+    /// let v = u.into_iter().try_collect::<Vec<i32>>();\n+    /// assert_eq!(v, None);\n+    /// ```\n+    ///\n+    /// A similar example, but with `Result`:\n+    /// ```\n+    /// #![feature(iterator_try_collect)]\n+    ///\n+    /// let u: Vec<Result<i32, ()>> = vec![Ok(1), Ok(2), Ok(3)];\n+    /// let v = u.into_iter().try_collect::<Vec<i32>>();\n+    /// assert_eq!(v, Ok(vec![1, 2, 3]));\n+    ///\n+    /// let u = vec![Ok(1), Ok(2), Err(()), Ok(3)];\n+    /// let v = u.into_iter().try_collect::<Vec<i32>>();\n+    /// assert_eq!(v, Err(()));\n+    /// ```\n+    ///\n+    /// Finally, even [`ControlFlow`] works, despite the fact that it\n+    /// doesn't implement [`FromIterator`]. Note also that the iterator can\n+    /// continue to be used, even if a failure is encountered:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_collect)]\n+    ///\n+    /// use core::ops::ControlFlow::{Break, Continue};\n+    ///\n+    /// let u = [Continue(1), Continue(2), Break(3), Continue(4), Continue(5)];\n+    /// let mut it = u.into_iter();\n+    ///\n+    /// let v = it.try_collect::<Vec<_>>();\n+    /// assert_eq!(v, Break(3));\n+    ///\n+    /// let v = it.try_collect::<Vec<_>>();\n+    /// assert_eq!(v, Continue(vec![4, 5]));\n+    /// ```\n+    ///\n+    /// [`collect`]: Iterator::collect\n+    #[inline]\n+    #[unstable(feature = \"iterator_try_collect\", issue = \"94047\")]\n+    fn try_collect<B>(&mut self) -> ChangeOutputType<Self::Item, B>\n+    where\n+        Self: Sized,\n+        <Self as Iterator>::Item: Try,\n+        <<Self as Iterator>::Item as Try>::Residual: Residual<B>,\n+        B: FromIterator<<Self::Item as Try>::Output>,\n+    {\n+        try_process(self, |i| i.collect())\n+    }\n+\n     /// Consumes an iterator, creating two collections from it.\n     ///\n     /// The predicate passed to `partition()` can return `true`, or `false`."}, {"sha": "cf69f0a7a4d7e7e687bf781a33f4b050554a3c87", "filename": "library/core/tests/iter/traits/iterator.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a4be35e3217e85e35693837cac5bdc8285add15a/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4be35e3217e85e35693837cac5bdc8285add15a/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs?ref=a4be35e3217e85e35693837cac5bdc8285add15a", "patch": "@@ -497,6 +497,52 @@ fn test_collect() {\n     assert!(a == b);\n }\n \n+#[test]\n+fn test_try_collect() {\n+    use core::ops::ControlFlow::{Break, Continue};\n+\n+    let u = vec![Some(1), Some(2), Some(3)];\n+    let v = u.into_iter().try_collect::<Vec<i32>>();\n+    assert_eq!(v, Some(vec![1, 2, 3]));\n+\n+    let u = vec![Some(1), Some(2), None, Some(3)];\n+    let mut it = u.into_iter();\n+    let v = it.try_collect::<Vec<i32>>();\n+    assert_eq!(v, None);\n+    let v = it.try_collect::<Vec<i32>>();\n+    assert_eq!(v, Some(vec![3]));\n+\n+    let u: Vec<Result<i32, ()>> = vec![Ok(1), Ok(2), Ok(3)];\n+    let v = u.into_iter().try_collect::<Vec<i32>>();\n+    assert_eq!(v, Ok(vec![1, 2, 3]));\n+\n+    let u = vec![Ok(1), Ok(2), Err(()), Ok(3)];\n+    let v = u.into_iter().try_collect::<Vec<i32>>();\n+    assert_eq!(v, Err(()));\n+\n+    let numbers = vec![1, 2, 3, 4, 5];\n+    let all_positive = numbers\n+        .iter()\n+        .cloned()\n+        .map(|n| if n > 0 { Some(n) } else { None })\n+        .try_collect::<Vec<i32>>();\n+    assert_eq!(all_positive, Some(numbers));\n+\n+    let numbers = vec![-2, -1, 0, 1, 2];\n+    let all_positive =\n+        numbers.into_iter().map(|n| if n > 0 { Some(n) } else { None }).try_collect::<Vec<i32>>();\n+    assert_eq!(all_positive, None);\n+\n+    let u = [Continue(1), Continue(2), Break(3), Continue(4), Continue(5)];\n+    let mut it = u.into_iter();\n+\n+    let v = it.try_collect::<Vec<_>>();\n+    assert_eq!(v, Break(3));\n+\n+    let v = it.try_collect::<Vec<_>>();\n+    assert_eq!(v, Continue(vec![4, 5]));\n+}\n+\n // just tests by whether or not this compiles\n fn _empty_impl_all_auto_traits<T>() {\n     use std::panic::{RefUnwindSafe, UnwindSafe};"}, {"sha": "32f3405243ceaa6d8cfff8ab074ddc5f22bff116", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4be35e3217e85e35693837cac5bdc8285add15a/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4be35e3217e85e35693837cac5bdc8285add15a/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=a4be35e3217e85e35693837cac5bdc8285add15a", "patch": "@@ -67,6 +67,7 @@\n #![feature(iter_intersperse)]\n #![feature(iter_is_partitioned)]\n #![feature(iter_order_by)]\n+#![feature(iterator_try_collect)]\n #![feature(iterator_try_reduce)]\n #![feature(const_mut_refs)]\n #![feature(const_pin)]"}]}