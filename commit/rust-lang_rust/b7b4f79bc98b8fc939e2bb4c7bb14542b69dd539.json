{"sha": "b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539", "node_id": "C_kwDOAAsO6NoAKGI3YjRmNzliYzk4YjhmYzkzOWUyYmI0YzdiYjE0NTQyYjY5ZGQ1Mzk", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-08-16T20:08:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-16T20:08:03Z"}, "message": "Rollup merge of #100625 - reitermarkus:ip-display-buffer, r=thomcc\n\nAdd `IpDisplayBuffer` helper struct.\n\nThis removes the dependency on `std::io::Write` for implementing `Display`, allowing it to be moved to `core` as proposed in https://github.com/rust-lang/rfcs/pull/2832.", "tree": {"sha": "ee541db088eae9e8db00cc8a6837e7ae17394733", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee541db088eae9e8db00cc8a6837e7ae17394733"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi+/kjCRBK7hj4Ov3rIwAAZOsIAC+pCdv6272adfJI5Dr1GKig\nFmm8e2Jz6B5s1aY5ZBjKpDuD12vvzcOsxDuya8EgIW3WellbIrgQX5+KRbsoKW1J\nPdFn8J4nECo/vGlv8SXMk4ZnW/1TWaQbU7DEdXiFFnEfxSbpU6ZBMRDkTIOfL75e\ntj+asedWX7l1IBAFUDdO7USFrCNlkzqCOFzixN3Ay1otj7qD2+rolh/HTDr/dIQw\n7Mse/y8hy3lOsOidqh44eOVPeU23l8c3yHhobOWnoUp31NrznHWbV9pax01JM2LM\ntNs8kPZzhE0hk5Mca+J+Ccbc5O7NAuY5ej73G3+nWIrCug9Ao7gPJ2Eygc9KS58=\n=Qs3s\n-----END PGP SIGNATURE-----\n", "payload": "tree ee541db088eae9e8db00cc8a6837e7ae17394733\nparent e6d47925af6a01bb2403e5ac6998295c31d9b731\nparent 44d62425b9e08c1eebd329766b5e4dd7f8bc3216\nauthor Takayuki Maeda <takoyaki0316@gmail.com> 1660680483 +0900\ncommitter GitHub <noreply@github.com> 1660680483 +0900\n\nRollup merge of #100625 - reitermarkus:ip-display-buffer, r=thomcc\n\nAdd `IpDisplayBuffer` helper struct.\n\nThis removes the dependency on `std::io::Write` for implementing `Display`, allowing it to be moved to `core` as proposed in https://github.com/rust-lang/rfcs/pull/2832.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539", "html_url": "https://github.com/rust-lang/rust/commit/b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6d47925af6a01bb2403e5ac6998295c31d9b731", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6d47925af6a01bb2403e5ac6998295c31d9b731", "html_url": "https://github.com/rust-lang/rust/commit/e6d47925af6a01bb2403e5ac6998295c31d9b731"}, {"sha": "44d62425b9e08c1eebd329766b5e4dd7f8bc3216", "url": "https://api.github.com/repos/rust-lang/rust/commits/44d62425b9e08c1eebd329766b5e4dd7f8bc3216", "html_url": "https://github.com/rust-lang/rust/commit/44d62425b9e08c1eebd329766b5e4dd7f8bc3216"}], "stats": {"total": 93, "additions": 63, "deletions": 30}, "files": [{"sha": "a8d6645794ae5d5fcd06ef2bca51018cb620aa10", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539", "patch": "@@ -294,6 +294,8 @@\n #![feature(std_internals)]\n #![feature(str_internals)]\n #![feature(strict_provenance)]\n+#![feature(maybe_uninit_uninit_array)]\n+#![feature(const_maybe_uninit_uninit_array)]\n //\n // Library features (alloc):\n #![feature(alloc_layout_extra)]"}, {"sha": "189754a161e71860dba0614ad0e150fa040a8599", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539", "patch": "@@ -3,12 +3,14 @@\n mod tests;\n \n use crate::cmp::Ordering;\n-use crate::fmt::{self, Write as FmtWrite};\n-use crate::io::Write as IoWrite;\n+use crate::fmt::{self, Write};\n use crate::mem::transmute;\n use crate::sys::net::netc as c;\n use crate::sys_common::{FromInner, IntoInner};\n \n+mod display_buffer;\n+use display_buffer::IpDisplayBuffer;\n+\n /// An IP address, either IPv4 or IPv6.\n ///\n /// This enum can contain either an [`Ipv4Addr`] or an [`Ipv6Addr`], see their\n@@ -991,21 +993,19 @@ impl From<Ipv6Addr> for IpAddr {\n impl fmt::Display for Ipv4Addr {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let octets = self.octets();\n-        // Fast Path: if there's no alignment stuff, write directly to the buffer\n+\n+        // If there are no alignment requirements, write the IP address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n         if fmt.precision().is_none() && fmt.width().is_none() {\n             write!(fmt, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3])\n         } else {\n-            const IPV4_BUF_LEN: usize = 15; // Long enough for the longest possible IPv4 address\n-            let mut buf = [0u8; IPV4_BUF_LEN];\n-            let mut buf_slice = &mut buf[..];\n+            const LONGEST_IPV4_ADDR: &str = \"255.255.255.255\";\n \n-            // Note: The call to write should never fail, hence the unwrap\n-            write!(buf_slice, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n-            let len = IPV4_BUF_LEN - buf_slice.len();\n+            let mut buf = IpDisplayBuffer::<{ LONGEST_IPV4_ADDR.len() }>::new();\n+            // Buffer is long enough for the longest possible IPv4 address, so this should never fail.\n+            write!(buf, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n \n-            // This unsafe is OK because we know what is being written to the buffer\n-            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n-            fmt.pad(buf)\n+            fmt.pad(buf.as_str())\n         }\n     }\n }\n@@ -1708,8 +1708,8 @@ impl Ipv6Addr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Ipv6Addr {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // If there are no alignment requirements, write out the IP address to\n-        // f. Otherwise, write it to a local buffer, then use f.pad.\n+        // If there are no alignment requirements, write the IP address directly to `f`.\n+        // Otherwise, write it to a local buffer and then use `f.pad`.\n         if f.precision().is_none() && f.width().is_none() {\n             let segments = self.segments();\n \n@@ -1780,22 +1780,13 @@ impl fmt::Display for Ipv6Addr {\n                 }\n             }\n         } else {\n-            // Slow path: write the address to a local buffer, then use f.pad.\n-            // Defined recursively by using the fast path to write to the\n-            // buffer.\n-\n-            // This is the largest possible size of an IPv6 address\n-            const IPV6_BUF_LEN: usize = (4 * 8) + 7;\n-            let mut buf = [0u8; IPV6_BUF_LEN];\n-            let mut buf_slice = &mut buf[..];\n-\n-            // Note: This call to write should never fail, so unwrap is okay.\n-            write!(buf_slice, \"{}\", self).unwrap();\n-            let len = IPV6_BUF_LEN - buf_slice.len();\n-\n-            // This is safe because we know exactly what can be in this buffer\n-            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n-            f.pad(buf)\n+            const LONGEST_IPV6_ADDR: &str = \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\";\n+\n+            let mut buf = IpDisplayBuffer::<{ LONGEST_IPV6_ADDR.len() }>::new();\n+            // Buffer is long enough for the longest possible IPv6 address, so this should never fail.\n+            write!(buf, \"{}\", self).unwrap();\n+\n+            f.pad(buf.as_str())\n         }\n     }\n }"}, {"sha": "bd852d5da8ec5eca87defa2b346e4e6b90ff9651", "filename": "library/std/src/net/ip/display_buffer.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539/library%2Fstd%2Fsrc%2Fnet%2Fip%2Fdisplay_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539/library%2Fstd%2Fsrc%2Fnet%2Fip%2Fdisplay_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip%2Fdisplay_buffer.rs?ref=b7b4f79bc98b8fc939e2bb4c7bb14542b69dd539", "patch": "@@ -0,0 +1,40 @@\n+use crate::fmt;\n+use crate::mem::MaybeUninit;\n+use crate::str;\n+\n+/// Used for slow path in `Display` implementations when alignment is required.\n+pub struct IpDisplayBuffer<const SIZE: usize> {\n+    buf: [MaybeUninit<u8>; SIZE],\n+    len: usize,\n+}\n+\n+impl<const SIZE: usize> IpDisplayBuffer<SIZE> {\n+    #[inline]\n+    pub const fn new() -> Self {\n+        Self { buf: MaybeUninit::uninit_array(), len: 0 }\n+    }\n+\n+    #[inline]\n+    pub fn as_str(&self) -> &str {\n+        // SAFETY: `buf` is only written to by the `fmt::Write::write_str` implementation\n+        // which writes a valid UTF-8 string to `buf` and correctly sets `len`.\n+        unsafe {\n+            let s = MaybeUninit::slice_assume_init_ref(&self.buf[..self.len]);\n+            str::from_utf8_unchecked(s)\n+        }\n+    }\n+}\n+\n+impl<const SIZE: usize> fmt::Write for IpDisplayBuffer<SIZE> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        let bytes = s.as_bytes();\n+\n+        if let Some(buf) = self.buf.get_mut(self.len..(self.len + bytes.len())) {\n+            MaybeUninit::write_slice(buf, bytes);\n+            self.len += bytes.len();\n+            Ok(())\n+        } else {\n+            Err(fmt::Error)\n+        }\n+    }\n+}"}]}