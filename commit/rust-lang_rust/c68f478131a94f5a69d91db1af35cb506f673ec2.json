{"sha": "c68f478131a94f5a69d91db1af35cb506f673ec2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2OGY0NzgxMzFhOTRmNWE2OWQ5MWRiMWFmMzVjYjUwNmY2NzNlYzI=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-06-25T16:46:59Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-06-30T15:06:33Z"}, "message": "Deny unsafe ops in unsafe fns, part 4", "tree": {"sha": "3d56c9d1485c79c8e82a657862ef0c39dff5ac2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d56c9d1485c79c8e82a657862ef0c39dff5ac2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c68f478131a94f5a69d91db1af35cb506f673ec2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c68f478131a94f5a69d91db1af35cb506f673ec2", "html_url": "https://github.com/rust-lang/rust/commit/c68f478131a94f5a69d91db1af35cb506f673ec2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c68f478131a94f5a69d91db1af35cb506f673ec2/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac7539c6d1036e42e84d388a57a656c420cb9eee", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac7539c6d1036e42e84d388a57a656c420cb9eee", "html_url": "https://github.com/rust-lang/rust/commit/ac7539c6d1036e42e84d388a57a656c420cb9eee"}], "stats": {"total": 148, "additions": 108, "deletions": 40}, "files": [{"sha": "7bdd7d009e1568017f5ce19b2e65ef381f1aab88", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c68f478131a94f5a69d91db1af35cb506f673ec2/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68f478131a94f5a69d91db1af35cb506f673ec2/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=c68f478131a94f5a69d91db1af35cb506f673ec2", "patch": "@@ -1,3 +1,7 @@\n+// ignore-tidy-undocumented-unsafe\n+\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::cmp;\n use crate::mem::{self, MaybeUninit};\n use crate::ptr;\n@@ -77,9 +81,9 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // the way until about `left + right == 32`, but the worst case performance breaks even\n             // around 16. 24 was chosen as middle ground. If the size of `T` is larger than 4\n             // `usize`s, this algorithm also outperforms other algorithms.\n-            let x = mid.sub(left);\n+            let x = unsafe { mid.sub(left) };\n             // beginning of first round\n-            let mut tmp: T = x.read();\n+            let mut tmp: T = unsafe { x.read() };\n             let mut i = right;\n             // `gcd` can be found before hand by calculating `gcd(left + right, right)`,\n             // but it is faster to do one loop which calculates the gcd as a side effect, then\n@@ -90,15 +94,15 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // the very end. This is possibly due to the fact that swapping or replacing temporaries\n             // uses only one memory address in the loop instead of needing to manage two.\n             loop {\n-                tmp = x.add(i).replace(tmp);\n+                tmp = unsafe { x.add(i).replace(tmp) };\n                 // instead of incrementing `i` and then checking if it is outside the bounds, we\n                 // check if `i` will go outside the bounds on the next increment. This prevents\n                 // any wrapping of pointers or `usize`.\n                 if i >= left {\n                     i -= left;\n                     if i == 0 {\n                         // end of first round\n-                        x.write(tmp);\n+                        unsafe { x.write(tmp) };\n                         break;\n                     }\n                     // this conditional must be here if `left + right >= 15`\n@@ -111,14 +115,14 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             }\n             // finish the chunk with more rounds\n             for start in 1..gcd {\n-                tmp = x.add(start).read();\n+                tmp = unsafe { x.add(start).read() };\n                 i = start + right;\n                 loop {\n-                    tmp = x.add(i).replace(tmp);\n+                    tmp = unsafe { x.add(i).replace(tmp) };\n                     if i >= left {\n                         i -= left;\n                         if i == start {\n-                            x.add(start).write(tmp);\n+                            unsafe { x.add(start).write(tmp) };\n                             break;\n                         }\n                     } else {\n@@ -133,15 +137,19 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // The `[T; 0]` here is to ensure this is appropriately aligned for T\n             let mut rawarray = MaybeUninit::<(BufType, [T; 0])>::uninit();\n             let buf = rawarray.as_mut_ptr() as *mut T;\n-            let dim = mid.sub(left).add(right);\n+            let dim = unsafe { mid.sub(left).add(right) };\n             if left <= right {\n-                ptr::copy_nonoverlapping(mid.sub(left), buf, left);\n-                ptr::copy(mid, mid.sub(left), right);\n-                ptr::copy_nonoverlapping(buf, dim, left);\n+                unsafe {\n+                    ptr::copy_nonoverlapping(mid.sub(left), buf, left);\n+                    ptr::copy(mid, mid.sub(left), right);\n+                    ptr::copy_nonoverlapping(buf, dim, left);\n+                }\n             } else {\n-                ptr::copy_nonoverlapping(mid, buf, right);\n-                ptr::copy(mid.sub(left), dim, left);\n-                ptr::copy_nonoverlapping(buf, mid.sub(left), right);\n+                unsafe {\n+                    ptr::copy_nonoverlapping(mid, buf, right);\n+                    ptr::copy(mid.sub(left), dim, left);\n+                    ptr::copy_nonoverlapping(buf, mid.sub(left), right);\n+                }\n             }\n             return;\n         } else if left >= right {\n@@ -150,8 +158,10 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // of this algorithm would be, and swapping using that last chunk instead of swapping\n             // adjacent chunks like this algorithm is doing, but this way is still faster.\n             loop {\n-                ptr::swap_nonoverlapping(mid.sub(right), mid, right);\n-                mid = mid.sub(right);\n+                unsafe {\n+                    ptr::swap_nonoverlapping(mid.sub(right), mid, right);\n+                    mid = mid.sub(right);\n+                }\n                 left -= right;\n                 if left < right {\n                     break;\n@@ -160,8 +170,10 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n         } else {\n             // Algorithm 3, `left < right`\n             loop {\n-                ptr::swap_nonoverlapping(mid.sub(left), mid, left);\n-                mid = mid.add(left);\n+                unsafe {\n+                    ptr::swap_nonoverlapping(mid.sub(left), mid, left);\n+                    mid = mid.add(left);\n+                }\n                 right -= left;\n                 if right < left {\n                     break;"}, {"sha": "cbbeaa81d4572b66bfa3b23615783df7915ad6d8", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 78, "deletions": 22, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c68f478131a94f5a69d91db1af35cb506f673ec2/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c68f478131a94f5a69d91db1af35cb506f673ec2/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c68f478131a94f5a69d91db1af35cb506f673ec2", "patch": "@@ -7,6 +7,7 @@\n //! [`std::str`]: ../../std/str/index.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n use self::pattern::Pattern;\n use self::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n@@ -419,7 +420,11 @@ pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n-    &*(v as *const [u8] as *const str)\n+    // SAFETY: the caller must guarantee that the bytes `v`\n+    // are valid UTF-8, thus the cast to `*const str` is safe.\n+    // Also, the pointer dereference is safe because that pointer\n+    // comes from a reference which is guaranteed to be valid for reads.\n+    unsafe { &*(v as *const [u8] as *const str) }\n }\n \n /// Converts a slice of bytes to a string slice without checking\n@@ -444,7 +449,11 @@ pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n #[inline]\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n-    &mut *(v as *mut [u8] as *mut str)\n+    // SAFETY: the caller must guarantee that the bytes `v`\n+    // are valid UTF-8, thus the cast to `*mut str` is safe.\n+    // Also, the pointer dereference is safe because that pointer\n+    // comes from a reference which is guaranteed to be valid for writes.\n+    unsafe { &mut *(v as *mut [u8] as *mut str) }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -867,7 +876,9 @@ unsafe impl TrustedLen for Bytes<'_> {}\n #[doc(hidden)]\n unsafe impl TrustedRandomAccess for Bytes<'_> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> u8 {\n-        self.0.get_unchecked(i)\n+        // SAFETY: the caller must uphold the safety contract\n+        // for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { self.0.get_unchecked(i) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -1904,15 +1915,27 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            let ptr = slice.as_ptr().add(self.start);\n+            // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n+            // which satisfies all the conditions for `add`.\n+            let ptr = unsafe { slice.as_ptr().add(self.start) };\n             let len = self.end - self.start;\n-            super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n+            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n+            // we can safely construct a subslice with `from_raw_parts` and use it\n+            // since we return a shared thus immutable reference.\n+            // The call to `from_utf8_unchecked` is safe since the data comes from\n+            // a `str` which is guaranteed to be valid utf8, since the caller\n+            // must guarantee that `self.start` and `self.end` are char boundaries.\n+            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, len)) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            let ptr = slice.as_mut_ptr().add(self.start);\n+            // SAFETY: see comments for `get_unchecked`.\n+            let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n             let len = self.end - self.start;\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len))\n+            // SAFETY: mostly identical to the comments for `get_unchecked`, except that we\n+            // can return a mutable reference since the caller passed a mutable reference\n+            // and is thus guaranteed to have exclusive write access to `slice`.\n+            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len)) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -1974,12 +1997,21 @@ mod traits {\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n             let ptr = slice.as_ptr();\n-            super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end))\n+            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n+            // we can safely construct a subslice with `from_raw_parts` and use it\n+            // since we return a shared thus immutable reference.\n+            // The call to `from_utf8_unchecked` is safe since the data comes from\n+            // a `str` which is guaranteed to be valid utf8, since the caller\n+            // must guarantee that `self.end` is a char boundary.\n+            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end)) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n             let ptr = slice.as_mut_ptr();\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, self.end))\n+            // SAFETY: mostly identical to `get_unchecked`, except that we can safely\n+            // return a mutable reference since the caller passed a mutable reference\n+            // and is thus guaranteed to have exclusive write access to `slice`.\n+            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, self.end)) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2036,15 +2068,27 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            let ptr = slice.as_ptr().add(self.start);\n+            // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n+            // which satisfies all the conditions for `add`.\n+            let ptr = unsafe { slice.as_ptr().add(self.start) };\n             let len = slice.len() - self.start;\n-            super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n+            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n+            // we can safely construct a subslice with `from_raw_parts` and use it\n+            // since we return a shared thus immutable reference.\n+            // The call to `from_utf8_unchecked` is safe since the data comes from\n+            // a `str` which is guaranteed to be valid utf8, since the caller\n+            // must guarantee that `self.start` is a char boundary.\n+            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, len)) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            let ptr = slice.as_mut_ptr().add(self.start);\n+            // SAFETY: identical to `get_unchecked`.\n+            let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n             let len = slice.len() - self.start;\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len))\n+            // SAFETY: mostly identical to `get_unchecked`, except that we can safely\n+            // return a mutable reference since the caller passed a mutable reference\n+            // and is thus guaranteed to have exclusive write access to `slice`.\n+            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len)) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2099,11 +2143,13 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            (*self.start()..self.end() + 1).get_unchecked(slice)\n+            // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+            unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            (*self.start()..self.end() + 1).get_unchecked_mut(slice)\n+            // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+            unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2148,11 +2194,13 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            (..self.end + 1).get_unchecked(slice)\n+            // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+            unsafe { (..self.end + 1).get_unchecked(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            (..self.end + 1).get_unchecked_mut(slice)\n+            // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+            unsafe { (..self.end + 1).get_unchecked_mut(slice) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2373,7 +2421,11 @@ impl str {\n     #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n     #[inline(always)]\n     pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n-        &mut *(self as *mut str as *mut [u8])\n+        // SAFETY: the cast from `&str` to `&[u8]` is safe since `str`\n+        // has the same layout as `&[u8]` (only libstd can make this guarantee).\n+        // The pointer dereference is safe since it comes from a mutable reference which\n+        // is guaranteed to be valid for writes.\n+        unsafe { &mut *(self as *mut str as *mut [u8]) }\n     }\n \n     /// Converts a string slice to a raw pointer.\n@@ -2509,7 +2561,8 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n-        i.get_unchecked(self)\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+        unsafe { i.get_unchecked(self) }\n     }\n \n     /// Returns a mutable, unchecked subslice of `str`.\n@@ -2541,7 +2594,8 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n-        i.get_unchecked_mut(self)\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { i.get_unchecked_mut(self) }\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2591,7 +2645,8 @@ impl str {\n     #[rustc_deprecated(since = \"1.29.0\", reason = \"use `get_unchecked(begin..end)` instead\")]\n     #[inline]\n     pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        (begin..end).get_unchecked(self)\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+        unsafe { (begin..end).get_unchecked(self) }\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2622,7 +2677,8 @@ impl str {\n     #[rustc_deprecated(since = \"1.29.0\", reason = \"use `get_unchecked_mut(begin..end)` instead\")]\n     #[inline]\n     pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        (begin..end).get_unchecked_mut(self)\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (begin..end).get_unchecked_mut(self) }\n     }\n \n     /// Divide one string slice into two at an index."}]}