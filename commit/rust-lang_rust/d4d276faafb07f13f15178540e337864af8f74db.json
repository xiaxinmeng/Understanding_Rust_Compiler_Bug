{"sha": "d4d276faafb07f13f15178540e337864af8f74db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZDI3NmZhYWZiMDdmMTNmMTUxNzg1NDBlMzM3ODY0YWY4Zjc0ZGI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-01-19T23:49:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-01-20T16:34:30Z"}, "message": "Rollup merge of #38842 - abonander:proc_macro_attribute, r=jseyfried\n\nImplement `#[proc_macro_attribute]`\n\nThis implements `#[proc_macro_attribute]` as described in https://github.com/rust-lang/rfcs/pull/1566\n\nThe following major (hopefully non-breaking) changes are included:\n\n* Refactor `proc_macro::TokenStream` to use `syntax::tokenstream::TokenStream`.\n    * `proc_macro::tokenstream::TokenStream` no longer emits newlines between items, this can be trivially restored if desired\n    * `proc_macro::TokenStream::from_str` does not try to parse an item anymore, moved to `impl MultiItemModifier for CustomDerive` with more informative error message\n\n* Implement `#[proc_macro_attribute]`, which expects functions of the kind `fn(TokenStream, TokenStream) -> TokenStream`\n    * Reactivated `#![feature(proc_macro)]` and gated `#[proc_macro_attribute]` under it\n    * `#![feature(proc_macro)]` and `#![feature(custom_attribute)]` are mutually exclusive\n    * adding `#![feature(proc_macro)]` makes the expansion pass assume that any attributes that are not built-in, or introduced by existing syntax extensions, are proc-macro attributes\n\n* Fix `feature_gate::find_lang_feature_issue()` to not use `unwrap()`\n\n    * This change wasn't necessary for this PR, but it helped debugging a problem where I was using the wrong feature string.\n\n* Move \"completed feature gate checking\" pass to after \"name resolution\" pass\n\n    * This was necessary for proper feature-gating of `#[proc_macro_attribute]` invocations when the `proc_macro` feature flag isn't set.\n\nPrototype/Litmus Test: [Implementation](https://github.com/abonander/anterofit/blob/proc_macro/service-attr/src/lib.rs#L13) -- [Usage](https://github.com/abonander/anterofit/blob/proc_macro/service-attr/examples/post_service.rs#L35)", "tree": {"sha": "2619f62b9c8d6ec8e9c0901a57109877313f5a99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2619f62b9c8d6ec8e9c0901a57109877313f5a99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4d276faafb07f13f15178540e337864af8f74db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d276faafb07f13f15178540e337864af8f74db", "html_url": "https://github.com/rust-lang/rust/commit/d4d276faafb07f13f15178540e337864af8f74db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4d276faafb07f13f15178540e337864af8f74db/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "437d2b5e2840b220772c8d58a925c2b232bd0c2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/437d2b5e2840b220772c8d58a925c2b232bd0c2e", "html_url": "https://github.com/rust-lang/rust/commit/437d2b5e2840b220772c8d58a925c2b232bd0c2e"}, {"sha": "04ecee158c2c56f4a6d81ad17ac3547848ec1e4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/04ecee158c2c56f4a6d81ad17ac3547848ec1e4c", "html_url": "https://github.com/rust-lang/rust/commit/04ecee158c2c56f4a6d81ad17ac3547848ec1e4c"}], "stats": {"total": 740, "additions": 613, "deletions": 127}, "files": [{"sha": "ab5962779feebca424f0ad1d3045536cc98ad7d8", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -39,9 +39,9 @@ extern crate syntax;\n use std::fmt;\n use std::str::FromStr;\n \n-use syntax::ast;\n+use syntax::errors::DiagnosticBuilder;\n use syntax::parse;\n-use syntax::ptr::P;\n+use syntax::tokenstream::TokenStream as TokenStream_;\n \n /// The main type provided by this crate, representing an abstract stream of\n /// tokens.\n@@ -54,7 +54,7 @@ use syntax::ptr::P;\n /// time!\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n pub struct TokenStream {\n-    inner: Vec<P<ast::Item>>,\n+    inner: TokenStream_,\n }\n \n /// Error returned from `TokenStream::from_str`.\n@@ -77,17 +77,41 @@ pub struct LexError {\n #[doc(hidden)]\n pub mod __internal {\n     use std::cell::Cell;\n+    use std::rc::Rc;\n \n     use syntax::ast;\n     use syntax::ptr::P;\n-    use syntax::parse::ParseSess;\n-    use super::TokenStream;\n+    use syntax::parse::{self, token, ParseSess};\n+    use syntax::tokenstream::TokenStream as TokenStream_;\n+\n+    use super::{TokenStream, LexError};\n \n     pub fn new_token_stream(item: P<ast::Item>) -> TokenStream {\n-        TokenStream { inner: vec![item] }\n+        TokenStream { inner: TokenStream_::from_tokens(vec![\n+            token::Interpolated(Rc::new(token::NtItem(item)))\n+        ])}\n+    }\n+\n+    pub fn token_stream_wrap(inner: TokenStream_) -> TokenStream {\n+        TokenStream {\n+            inner: inner\n+        }\n+    }\n+\n+    pub fn token_stream_parse_items(stream: TokenStream) -> Result<Vec<P<ast::Item>>, LexError> {\n+        with_parse_sess(move |sess| {\n+            let mut parser = parse::new_parser_from_ts(sess, stream.inner);\n+            let mut items = Vec::new();\n+\n+            while let Some(item) = try!(parser.parse_item().map_err(super::parse_to_lex_err)) {\n+                items.push(item)\n+            }\n+\n+            Ok(items)\n+        })\n     }\n \n-    pub fn token_stream_items(stream: TokenStream) -> Vec<P<ast::Item>> {\n+    pub fn token_stream_inner(stream: TokenStream) -> TokenStream_ {\n         stream.inner\n     }\n \n@@ -96,6 +120,10 @@ pub mod __internal {\n                                   trait_name: &str,\n                                   expand: fn(TokenStream) -> TokenStream,\n                                   attributes: &[&'static str]);\n+\n+        fn register_attr_proc_macro(&mut self,\n+                                    name: &str,\n+                                    expand: fn(TokenStream, TokenStream) -> TokenStream);\n     }\n \n     // Emulate scoped_thread_local!() here essentially\n@@ -125,11 +153,17 @@ pub mod __internal {\n         where F: FnOnce(&ParseSess) -> R\n     {\n         let p = CURRENT_SESS.with(|p| p.get());\n-        assert!(!p.is_null());\n+        assert!(!p.is_null(), \"proc_macro::__internal::with_parse_sess() called \\\n+                               before set_parse_sess()!\");\n         f(unsafe { &*p })\n     }\n }\n \n+fn parse_to_lex_err(mut err: DiagnosticBuilder) -> LexError {\n+    err.cancel();\n+    LexError { _inner: () }\n+}\n+\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl FromStr for TokenStream {\n     type Err = LexError;\n@@ -138,30 +172,17 @@ impl FromStr for TokenStream {\n         __internal::with_parse_sess(|sess| {\n             let src = src.to_string();\n             let name = \"<proc-macro source code>\".to_string();\n-            let mut parser = parse::new_parser_from_source_str(sess, name, src);\n-            let mut ret = TokenStream { inner: Vec::new() };\n-            loop {\n-                match parser.parse_item() {\n-                    Ok(Some(item)) => ret.inner.push(item),\n-                    Ok(None) => return Ok(ret),\n-                    Err(mut err) => {\n-                        err.cancel();\n-                        return Err(LexError { _inner: () })\n-                    }\n-                }\n-            }\n+            let tts = try!(parse::parse_tts_from_source_str(name, src, sess)\n+                .map_err(parse_to_lex_err));\n+\n+            Ok(__internal::token_stream_wrap(TokenStream_::from_tts(tts)))\n         })\n     }\n }\n \n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl fmt::Display for TokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        for item in self.inner.iter() {\n-            let item = syntax::print::pprust::item_to_string(item);\n-            try!(f.write_str(&item));\n-            try!(f.write_str(\"\\n\"));\n-        }\n-        Ok(())\n+        self.inner.fmt(f)\n     }\n }"}, {"sha": "83dec4b0b77ab3967efcb6b32292ec98d05d19bb", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -681,6 +681,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n             should_test: sess.opts.test,\n             ..syntax::ext::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n+\n         let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver);\n         let err_count = ecx.parse_sess.span_diagnostic.err_count();\n \n@@ -740,17 +741,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n          \"checking for inline asm in case the target doesn't support it\",\n          || no_asm::check_crate(sess, &krate));\n \n-    // Needs to go *after* expansion to be able to check the results of macro expansion.\n-    time(time_passes, \"complete gated feature checking\", || {\n-        sess.track_errors(|| {\n-            syntax::feature_gate::check_crate(&krate,\n-                                              &sess.parse_sess,\n-                                              &sess.features.borrow(),\n-                                              &attributes,\n-                                              sess.opts.unstable_features);\n-        })\n-    })?;\n-\n     time(sess.time_passes(),\n          \"early lint checks\",\n          || lint::check_ast_crate(sess, &krate));\n@@ -768,6 +758,17 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         Ok(())\n     })?;\n \n+    // Needs to go *after* expansion to be able to check the results of macro expansion.\n+    time(time_passes, \"complete gated feature checking\", || {\n+        sess.track_errors(|| {\n+            syntax::feature_gate::check_crate(&krate,\n+                                              &sess.parse_sess,\n+                                              &sess.features.borrow(),\n+                                              &attributes,\n+                                              sess.opts.unstable_features);\n+        })\n+    })?;\n+\n     // Lower ast -> hir.\n     let hir_forest = time(sess.time_passes(), \"lowering ast -> hir\", || {\n         let hir_crate = lower_crate(sess, &krate, &mut resolver);"}, {"sha": "161331b1728bcd0deb0973b3a52ff1d45e6faec1", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -578,6 +578,7 @@ impl<'a> CrateLoader<'a> {\n         use proc_macro::__internal::Registry;\n         use rustc_back::dynamic_lib::DynamicLibrary;\n         use syntax_ext::deriving::custom::CustomDerive;\n+        use syntax_ext::proc_macro_impl::AttrProcMacro;\n \n         let path = match dylib {\n             Some(dylib) => dylib,\n@@ -613,6 +614,15 @@ impl<'a> CrateLoader<'a> {\n                 );\n                 self.0.push((Symbol::intern(trait_name), Rc::new(derive)));\n             }\n+\n+            fn register_attr_proc_macro(&mut self,\n+                                        name: &str,\n+                                        expand: fn(TokenStream, TokenStream) -> TokenStream) {\n+                let expand = SyntaxExtension::AttrProcMacro(\n+                    Box::new(AttrProcMacro { inner: expand })\n+                );\n+                self.0.push((Symbol::intern(name), Rc::new(expand)));\n+            }\n         }\n \n         let mut my_registrar = MyRegistrar(Vec::new());"}, {"sha": "2c5e338563816712921759ce8af44a56fc5b71dc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -61,7 +61,7 @@ use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n-use syntax::feature_gate::{emit_feature_err, GateIssue};\n+use syntax::feature_gate::{feature_err, emit_feature_err, GateIssue};\n \n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use errors::DiagnosticBuilder;\n@@ -1123,6 +1123,12 @@ pub struct Resolver<'a> {\n \n     // Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n+\n+    // If `#![feature(proc_macro)]` is set\n+    proc_macro_enabled: bool,\n+\n+    // A set of procedural macros imported by `#[macro_use]` that have already been warned about\n+    warned_proc_macros: FxHashSet<Name>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1227,6 +1233,8 @@ impl<'a> Resolver<'a> {\n         invocations.insert(Mark::root(),\n                            arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n \n+        let features = session.features.borrow();\n+\n         Resolver {\n             session: session,\n \n@@ -1284,7 +1292,9 @@ impl<'a> Resolver<'a> {\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             }),\n-            use_extern_macros: session.features.borrow().use_extern_macros,\n+\n+            // `#![feature(proc_macro)]` implies `#[feature(extern_macros)]`\n+            use_extern_macros: features.use_extern_macros || features.proc_macro,\n \n             exported_macros: Vec::new(),\n             crate_loader: crate_loader,\n@@ -1296,6 +1306,8 @@ impl<'a> Resolver<'a> {\n             invocations: invocations,\n             name_already_seen: FxHashMap(),\n             whitelisted_legacy_custom_derives: Vec::new(),\n+            proc_macro_enabled: features.proc_macro,\n+            warned_proc_macros: FxHashSet(),\n         }\n     }\n \n@@ -1525,6 +1537,8 @@ impl<'a> Resolver<'a> {\n \n         debug!(\"(resolving item) resolving {}\", name);\n \n+        self.check_proc_macro_attrs(&item.attrs);\n+\n         match item.node {\n             ItemKind::Enum(_, ref generics) |\n             ItemKind::Ty(_, ref generics) |\n@@ -1554,6 +1568,8 @@ impl<'a> Resolver<'a> {\n                         walk_list!(this, visit_ty_param_bound, bounds);\n \n                         for trait_item in trait_items {\n+                            this.check_proc_macro_attrs(&trait_item.attrs);\n+\n                             match trait_item.node {\n                                 TraitItemKind::Const(_, ref default) => {\n                                     // Only impose the restrictions of\n@@ -1738,6 +1754,7 @@ impl<'a> Resolver<'a> {\n                 this.with_self_rib(Def::SelfTy(trait_id, Some(item_def_id)), |this| {\n                     this.with_current_self_type(self_type, |this| {\n                         for impl_item in impl_items {\n+                            this.check_proc_macro_attrs(&impl_item.attrs);\n                             this.resolve_visibility(&impl_item.vis);\n                             match impl_item.node {\n                                 ImplItemKind::Const(..) => {\n@@ -3184,6 +3201,31 @@ impl<'a> Resolver<'a> {\n         let msg = \"`self` no longer imports values\".to_string();\n         self.session.add_lint(lint::builtin::LEGACY_IMPORTS, id, span, msg);\n     }\n+\n+    fn check_proc_macro_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        if self.proc_macro_enabled { return; }\n+\n+        for attr in attrs {\n+            let maybe_binding = self.builtin_macros.get(&attr.name()).cloned().or_else(|| {\n+                let ident = Ident::with_empty_ctxt(attr.name());\n+                self.resolve_lexical_macro_path_segment(ident, MacroNS, None).ok()\n+            });\n+\n+            if let Some(binding) = maybe_binding {\n+                if let SyntaxExtension::AttrProcMacro(..) = *binding.get_macro(self) {\n+                    attr::mark_known(attr);\n+\n+                    let msg = \"attribute procedural macros are experimental\";\n+                    let feature = \"proc_macro\";\n+\n+                    feature_err(&self.session.parse_sess, feature,\n+                                attr.span, GateIssue::Language, msg)\n+                        .span_note(binding.span, \"procedural macro imported here\")\n+                        .emit();\n+                }\n+            }\n+        }\n+    }\n }\n \n fn is_struct_like(def: Def) -> bool {"}, {"sha": "9b7d6f33a7f3b45e90eb0ea16e33ecd0bb0d6f32", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -27,7 +27,7 @@ use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n-use syntax::feature_gate::{emit_feature_err, GateIssue};\n+use syntax::feature_gate::{emit_feature_err, GateIssue, is_builtin_attr};\n use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n@@ -183,6 +183,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 },\n                 None => {}\n             }\n+\n+            if self.proc_macro_enabled && !is_builtin_attr(&attrs[i]) {\n+                return Some(attrs.remove(i));\n+            }\n         }\n         None\n     }\n@@ -373,6 +377,10 @@ impl<'a> Resolver<'a> {\n             let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, Some(span));\n             let (legacy_resolution, resolution) = match (legacy_resolution, resolution) {\n                 (Some(legacy_resolution), Ok(resolution)) => (legacy_resolution, resolution),\n+                (Some(MacroBinding::Modern(binding)), Err(_)) => {\n+                    self.err_if_macro_use_proc_macro(ident.name, span, binding);\n+                    continue\n+                },\n                 _ => continue,\n             };\n             let (legacy_span, participle) = match legacy_resolution {\n@@ -469,4 +477,37 @@ impl<'a> Resolver<'a> {\n             self.exported_macros.push(def);\n         }\n     }\n+\n+    /// Error if `ext` is a Macros 1.1 procedural macro being imported by `#[macro_use]`\n+    fn err_if_macro_use_proc_macro(&mut self, name: Name, use_span: Span,\n+                                   binding: &NameBinding<'a>) {\n+        use self::SyntaxExtension::*;\n+\n+        let krate = binding.def().def_id().krate;\n+\n+        // Plugin-based syntax extensions are exempt from this check\n+        if krate == BUILTIN_MACROS_CRATE { return; }\n+\n+        let ext = binding.get_macro(self);\n+\n+        match *ext {\n+            // If `ext` is a procedural macro, check if we've already warned about it\n+            AttrProcMacro(_) | ProcMacro(_) => if !self.warned_proc_macros.insert(name) { return; },\n+            _ => return,\n+        }\n+\n+        let warn_msg = match *ext {\n+            AttrProcMacro(_) => \"attribute procedural macros cannot be \\\n+                                 imported with `#[macro_use]`\",\n+            ProcMacro(_) => \"procedural macros cannot be imported with `#[macro_use]`\",\n+            _ => return,\n+        };\n+\n+        let crate_name = self.session.cstore.crate_name(krate);\n+\n+        self.session.struct_span_err(use_span, warn_msg)\n+            .help(&format!(\"instead, import the procedural macro like any other item: \\\n+                             `use {}::{};`\", crate_name, name))\n+            .emit();\n+    }\n }"}, {"sha": "bc3c11b36c2c3ec7470975391b2d37b28fc202bf", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -364,7 +364,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 kind.expect_from_annotatables(items)\n             }\n             SyntaxExtension::AttrProcMacro(ref mac) => {\n-                let attr_toks = TokenStream::from_tts(tts_for_attr(&attr, &self.cx.parse_sess));\n+                let attr_toks = TokenStream::from_tts(tts_for_attr_args(&attr,\n+                                                                        &self.cx.parse_sess));\n+\n                 let item_toks = TokenStream::from_tts(tts_for_item(&item, &self.cx.parse_sess));\n \n                 let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n@@ -640,8 +642,30 @@ fn tts_for_item(item: &Annotatable, parse_sess: &ParseSess) -> Vec<TokenTree> {\n     string_to_tts(text, parse_sess)\n }\n \n-fn tts_for_attr(attr: &ast::Attribute, parse_sess: &ParseSess) -> Vec<TokenTree> {\n-    string_to_tts(pprust::attr_to_string(attr), parse_sess)\n+fn tts_for_attr_args(attr: &ast::Attribute, parse_sess: &ParseSess) -> Vec<TokenTree> {\n+    use ast::MetaItemKind::*;\n+    use print::pp::Breaks;\n+    use print::pprust::PrintState;\n+\n+    let token_string = match attr.value.node {\n+        // For `#[foo]`, an empty token\n+        Word => return vec![],\n+        // For `#[foo(bar, baz)]`, returns `(bar, baz)`\n+        List(ref items) => pprust::to_string(|s| {\n+            s.popen()?;\n+            s.commasep(Breaks::Consistent,\n+                       &items[..],\n+                       |s, i| s.print_meta_list_item(&i))?;\n+            s.pclose()\n+        }),\n+        // For `#[foo = \"bar\"]`, returns `= \"bar\"`\n+        NameValue(ref lit) => pprust::to_string(|s| {\n+            s.word_space(\"=\")?;\n+            s.print_literal(lit)\n+        }),\n+    };\n+\n+    string_to_tts(token_string, parse_sess)\n }\n \n fn string_to_tts(text: String, parse_sess: &ParseSess) -> Vec<TokenTree> {"}, {"sha": "c25020caf857e7f8d24bf9a316850fdd2ba21df7", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -30,7 +30,7 @@ use ast::{self, NodeId, PatKind};\n use attr;\n use codemap::{CodeMap, Spanned};\n use syntax_pos::Span;\n-use errors::{DiagnosticBuilder, Handler};\n+use errors::{DiagnosticBuilder, Handler, FatalError};\n use visit::{self, FnKind, Visitor};\n use parse::ParseSess;\n use symbol::Symbol;\n@@ -319,6 +319,9 @@ declare_features! (\n     // The `unadjusted` ABI. Perma unstable.\n     (active, abi_unadjusted, \"1.16.0\", None),\n \n+    // Macros 1.1\n+    (active, proc_macro, \"1.16.0\", Some(35900)),\n+\n     // Allows attributes on struct literal fields.\n     (active, struct_field_attributes, \"1.16.0\", Some(38814)),\n \n@@ -375,8 +378,6 @@ declare_features! (\n     // Allows `..` in tuple (struct) patterns\n     (accepted, dotdot_in_tuple_patterns, \"1.14.0\", Some(33627)),\n     (accepted, item_like_imports, \"1.14.0\", Some(35120)),\n-    // Macros 1.1\n-    (accepted, proc_macro, \"1.15.0\", Some(35900)),\n );\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -444,6 +445,10 @@ pub fn deprecated_attributes() -> Vec<&'static (&'static str, AttributeType, Att\n     BUILTIN_ATTRIBUTES.iter().filter(|a| a.2.is_deprecated()).collect()\n }\n \n+pub fn is_builtin_attr(attr: &ast::Attribute) -> bool {\n+    BUILTIN_ATTRIBUTES.iter().any(|&(builtin_name, _, _)| attr.check_name(builtin_name))\n+}\n+\n // Attributes that have a special meaning to rustc or rustdoc\n pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGate)] = &[\n     // Normal attributes\n@@ -737,6 +742,16 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                               is currently unstable\",\n                                              cfg_fn!(windows_subsystem))),\n \n+    (\"proc_macro_attribute\", Normal, Gated(Stability::Unstable,\n+                                           \"proc_macro\",\n+                                           \"attribute proc macros are currently unstable\",\n+                                           cfg_fn!(proc_macro))),\n+\n+    (\"rustc_derive_registrar\", Normal, Gated(Stability::Unstable,\n+                                             \"rustc_derive_registrar\",\n+                                             \"used internally by rustc\",\n+                                             cfg_fn!(rustc_attrs))),\n+\n     // Crate level attributes\n     (\"crate_name\", CrateLevel, Ungated),\n     (\"crate_type\", CrateLevel, Ungated),\n@@ -879,9 +894,10 @@ fn find_lang_feature_issue(feature: &str) -> Option<u32> {\n         issue\n     } else {\n         // search in Accepted or Removed features\n-        ACCEPTED_FEATURES.iter().chain(REMOVED_FEATURES.iter())\n-            .find(|t| t.0 == feature)\n-            .unwrap().2\n+        match ACCEPTED_FEATURES.iter().chain(REMOVED_FEATURES).find(|t| t.0 == feature) {\n+            Some(&(_, _, issue)) => issue,\n+            None => panic!(\"Feature `{}` is not declared anywhere\", feature),\n+        }\n     }\n }\n \n@@ -1382,6 +1398,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> Features {\n     let mut features = Features::new();\n \n+    let mut feature_checker = MutexFeatureChecker::default();\n+\n     for attr in krate_attrs {\n         if !attr.check_name(\"feature\") {\n             continue\n@@ -1405,6 +1423,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n                     if let Some(&(_, _, _, setter)) = ACTIVE_FEATURES.iter()\n                         .find(|& &(n, _, _, _)| name == n) {\n                         *(setter(&mut features)) = true;\n+                        feature_checker.collect(&features, mi.span);\n                     }\n                     else if let Some(&(_, _, _)) = REMOVED_FEATURES.iter()\n                         .find(|& &(n, _, _)| name == n) {\n@@ -1421,9 +1440,45 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n         }\n     }\n \n+    feature_checker.check(span_handler);\n+\n     features\n }\n \n+// A collector for mutually-exclusive features and their flag spans\n+#[derive(Default)]\n+struct MutexFeatureChecker {\n+    proc_macro: Option<Span>,\n+    custom_attribute: Option<Span>,\n+}\n+\n+impl MutexFeatureChecker {\n+    // If this method turns out to be a hotspot due to branching,\n+    // the branching can be eliminated by modifying `setter!()` to set these spans\n+    // only for the features that need to be checked for mutual exclusion.\n+    fn collect(&mut self, features: &Features, span: Span) {\n+        if features.proc_macro {\n+            // If self.proc_macro is None, set to Some(span)\n+            self.proc_macro = self.proc_macro.or(Some(span));\n+        }\n+\n+        if features.custom_attribute {\n+            self.custom_attribute = self.custom_attribute.or(Some(span));\n+        }\n+    }\n+\n+    fn check(self, handler: &Handler) {\n+        if let (Some(pm_span), Some(ca_span)) = (self.proc_macro, self.custom_attribute) {\n+            handler.struct_span_err(pm_span, \"Cannot use `#![feature(proc_macro)]` and \\\n+                                              `#![feature(custom_attribute)] at the same time\")\n+                .span_note(ca_span, \"`#![feature(custom_attribute)]` declared here\")\n+                .emit();\n+\n+            panic!(FatalError);\n+        }\n+    }\n+}\n+\n pub fn check_crate(krate: &ast::Crate,\n                    sess: &ParseSess,\n                    features: &Features,"}, {"sha": "2ce6fc03f7731a5d85f230b4c167d6cacc01fa6a", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -77,8 +77,9 @@ impl MultiItemModifier for CustomDerive {\n             let inner = self.inner;\n             panic::catch_unwind(panic::AssertUnwindSafe(|| inner(input)))\n         });\n-        let new_items = match res {\n-            Ok(stream) => __internal::token_stream_items(stream),\n+\n+        let stream = match res {\n+            Ok(stream) => stream,\n             Err(e) => {\n                 let msg = \"custom derive attribute panicked\";\n                 let mut err = ecx.struct_span_fatal(span, msg);\n@@ -94,6 +95,18 @@ impl MultiItemModifier for CustomDerive {\n             }\n         };\n \n+        let new_items = __internal::set_parse_sess(&ecx.parse_sess, || {\n+            match __internal::token_stream_parse_items(stream) {\n+                Ok(new_items) => new_items,\n+                Err(_) => {\n+                    // FIXME: handle this better\n+                    let msg = \"custom derive produced unparseable tokens\";\n+                    ecx.struct_span_fatal(span, msg).emit();\n+                    panic!(FatalError);\n+                }\n+            }\n+        });\n+\n         let mut res = vec![Annotatable::Item(item)];\n         // Reassign spans of all expanded items to the input `item`\n         // for better errors here."}, {"sha": "ebec23d0901a0409ea705cf3db7cbe7fa1275204", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -47,6 +47,8 @@ pub mod proc_macro_registrar;\n // for custom_derive\n pub mod deriving;\n \n+pub mod proc_macro_impl;\n+\n use std::rc::Rc;\n use syntax::ast;\n use syntax::ext::base::{MacroExpanderFn, NormalTT, MultiModifier, NamedSyntaxExtension};"}, {"sha": "b454628acb1c09bf95b0dabcd04ed18411daf1f8", "filename": "src/libsyntax_ext/proc_macro_impl.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_impl.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::panic;\n+\n+use errors::FatalError;\n+\n+use syntax::codemap::Span;\n+use syntax::ext::base::*;\n+use syntax::tokenstream::TokenStream;\n+use syntax::ext::base;\n+\n+use proc_macro::TokenStream as TsShim;\n+use proc_macro::__internal;\n+\n+pub struct AttrProcMacro {\n+    pub inner: fn(TsShim, TsShim) -> TsShim,\n+}\n+\n+impl base::AttrProcMacro for AttrProcMacro {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt,\n+                   span: Span,\n+                   annotation: TokenStream,\n+                   annotated: TokenStream)\n+                   -> TokenStream {\n+        let annotation = __internal::token_stream_wrap(annotation);\n+        let annotated = __internal::token_stream_wrap(annotated);\n+\n+        let res = __internal::set_parse_sess(&ecx.parse_sess, || {\n+            panic::catch_unwind(panic::AssertUnwindSafe(|| (self.inner)(annotation, annotated)))\n+        });\n+\n+        match res {\n+            Ok(stream) => __internal::token_stream_inner(stream),\n+            Err(e) => {\n+                let msg = \"custom attribute panicked\";\n+                let mut err = ecx.struct_span_fatal(span, msg);\n+                if let Some(s) = e.downcast_ref::<String>() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+                if let Some(s) = e.downcast_ref::<&'static str>() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+\n+                err.emit();\n+                panic!(FatalError);\n+            }\n+        }\n+    }\n+}"}, {"sha": "c8af16e9242f05c8277578b04576d11c13d08b04", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 135, "deletions": 69, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -11,18 +11,20 @@\n use std::mem;\n \n use errors;\n+\n use syntax::ast::{self, Ident, NodeId};\n use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n-use syntax::parse::ParseSess;\n use syntax::fold::Folder;\n+use syntax::parse::ParseSess;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n-use syntax_pos::{Span, DUMMY_SP};\n use syntax::visit::{self, Visitor};\n \n+use syntax_pos::{Span, DUMMY_SP};\n+\n use deriving;\n \n struct CustomDerive {\n@@ -32,8 +34,14 @@ struct CustomDerive {\n     attrs: Vec<ast::Name>,\n }\n \n-struct CollectCustomDerives<'a> {\n+struct AttrProcMacro {\n+    function_name: Ident,\n+    span: Span,\n+}\n+\n+struct CollectProcMacros<'a> {\n     derives: Vec<CustomDerive>,\n+    attr_macros: Vec<AttrProcMacro>,\n     in_root: bool,\n     handler: &'a errors::Handler,\n     is_proc_macro_crate: bool,\n@@ -50,16 +58,17 @@ pub fn modify(sess: &ParseSess,\n     let ecfg = ExpansionConfig::default(\"proc_macro\".to_string());\n     let mut cx = ExtCtxt::new(sess, ecfg, resolver);\n \n-    let derives = {\n-        let mut collect = CollectCustomDerives {\n+    let (derives, attr_macros) = {\n+        let mut collect = CollectProcMacros {\n             derives: Vec::new(),\n+            attr_macros: Vec::new(),\n             in_root: true,\n             handler: handler,\n             is_proc_macro_crate: is_proc_macro_crate,\n             is_test_crate: is_test_crate,\n         };\n         visit::walk_crate(&mut collect, &krate);\n-        collect.derives\n+        (collect.derives, collect.attr_macros)\n     };\n \n     if !is_proc_macro_crate {\n@@ -74,7 +83,7 @@ pub fn modify(sess: &ParseSess,\n         return krate;\n     }\n \n-    krate.module.items.push(mk_registrar(&mut cx, &derives));\n+    krate.module.items.push(mk_registrar(&mut cx, &derives, &attr_macros));\n \n     if krate.exported_macros.len() > 0 {\n         handler.err(\"cannot export macro_rules! macros from a `proc-macro` \\\n@@ -84,69 +93,19 @@ pub fn modify(sess: &ParseSess,\n     return krate\n }\n \n-impl<'a> CollectCustomDerives<'a> {\n+impl<'a> CollectProcMacros<'a> {\n     fn check_not_pub_in_root(&self, vis: &ast::Visibility, sp: Span) {\n         if self.is_proc_macro_crate &&\n            self.in_root &&\n            *vis == ast::Visibility::Public {\n             self.handler.span_err(sp,\n                                   \"`proc-macro` crate types cannot \\\n                                    export any items other than functions \\\n-                                   tagged with `#[proc_macro_derive]` \\\n-                                   currently\");\n+                                   tagged with `#[proc_macro_derive]` currently\");\n         }\n     }\n-}\n-\n-impl<'a> Visitor<'a> for CollectCustomDerives<'a> {\n-    fn visit_item(&mut self, item: &'a ast::Item) {\n-        let mut attrs = item.attrs.iter().filter(|a| a.check_name(\"proc_macro_derive\"));\n-\n-        // First up, make sure we're checking a bare function. If we're not then\n-        // we're just not interested in this item.\n-        //\n-        // If we find one, try to locate a `#[proc_macro_derive]` attribute on\n-        // it.\n-        match item.node {\n-            ast::ItemKind::Fn(..) => {}\n-            _ => {\n-                // Check for invalid use of proc_macro_derive\n-                if let Some(attr) = attrs.next() {\n-                    self.handler.span_err(attr.span(),\n-                                          \"the `#[proc_macro_derive]` \\\n-                                          attribute may only be used \\\n-                                          on bare functions\");\n-                    return;\n-                }\n-                self.check_not_pub_in_root(&item.vis, item.span);\n-                return visit::walk_item(self, item)\n-            }\n-        }\n-\n-        let attr = match attrs.next() {\n-            Some(attr) => attr,\n-            None => {\n-                self.check_not_pub_in_root(&item.vis, item.span);\n-                return visit::walk_item(self, item)\n-            }\n-        };\n-\n-        if let Some(a) = attrs.next() {\n-            self.handler.span_err(a.span(), \"multiple `#[proc_macro_derive]` \\\n-                                             attributes found\");\n-        }\n-\n-        if self.is_test_crate {\n-            return;\n-        }\n-\n-        if !self.is_proc_macro_crate {\n-            self.handler.span_err(attr.span(),\n-                                  \"the `#[proc_macro_derive]` attribute is \\\n-                                   only usable with crates of the `proc-macro` \\\n-                                   crate type\");\n-        }\n \n+    fn collect_custom_derive(&mut self, item: &'a ast::Item, attr: &'a ast::Attribute) {\n         // Once we've located the `#[proc_macro_derive]` attribute, verify\n         // that it's of the form `#[proc_macro_derive(Foo)]` or\n         // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n@@ -232,6 +191,101 @@ impl<'a> Visitor<'a> for CollectCustomDerives<'a> {\n             };\n             self.handler.span_err(item.span, msg);\n         }\n+    }\n+\n+    fn collect_attr_proc_macro(&mut self, item: &'a ast::Item, attr: &'a ast::Attribute) {\n+        if let Some(_) = attr.meta_item_list() {\n+            self.handler.span_err(attr.span, \"`#[proc_macro_attribute]` attribute\n+                cannot contain any meta items\");\n+            return;\n+        }\n+\n+        if self.in_root && item.vis == ast::Visibility::Public {\n+            self.attr_macros.push(AttrProcMacro {\n+                span: item.span,\n+                function_name: item.ident,\n+            });\n+        } else {\n+            let msg = if !self.in_root {\n+                \"functions tagged with `#[proc_macro_attribute]` must \\\n+                 currently reside in the root of the crate\"\n+            } else {\n+                \"functions tagged with `#[proc_macro_attribute]` must be `pub`\"\n+            };\n+            self.handler.span_err(item.span, msg);\n+        }\n+    }\n+}\n+\n+impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n+    fn visit_item(&mut self, item: &'a ast::Item) {\n+        // First up, make sure we're checking a bare function. If we're not then\n+        // we're just not interested in this item.\n+        //\n+        // If we find one, try to locate a `#[proc_macro_derive]` attribute on\n+        // it.\n+        let is_fn = match item.node {\n+            ast::ItemKind::Fn(..) => true,\n+            _ => false,\n+        };\n+\n+        let mut found_attr: Option<&'a ast::Attribute> = None;\n+\n+        for attr in &item.attrs {\n+            if attr.check_name(\"proc_macro_derive\") || attr.check_name(\"proc_macro_attribute\") {\n+                if let Some(prev_attr) = found_attr {\n+                    let msg = if attr.name() == prev_attr.name() {\n+                        format!(\"Only one `#[{}]` attribute is allowed on any given function\",\n+                                attr.name())\n+                    } else {\n+                        format!(\"`#[{}]` and `#[{}]` attributes cannot both be applied \\\n+                                to the same function\", attr.name(), prev_attr.name())\n+                    };\n+\n+                    self.handler.struct_span_err(attr.span(), &msg)\n+                        .span_note(prev_attr.span(), \"Previous attribute here\")\n+                        .emit();\n+\n+                    return;\n+                }\n+\n+                found_attr = Some(attr);\n+            }\n+        }\n+\n+        let attr = match found_attr {\n+            None => {\n+                self.check_not_pub_in_root(&item.vis, item.span);\n+                return visit::walk_item(self, item);\n+            },\n+            Some(attr) => attr,\n+        };\n+\n+        if !is_fn {\n+            let msg = format!(\"the `#[{}]` attribute may only be used on bare functions\",\n+                              attr.name());\n+\n+            self.handler.span_err(attr.span(), &msg);\n+            return;\n+        }\n+\n+        if self.is_test_crate {\n+            return;\n+        }\n+\n+        if !self.is_proc_macro_crate {\n+            let msg = format!(\"the `#[{}]` attribute is only usable with crates of the \\\n+                              `proc-macro` crate type\", attr.name());\n+\n+            self.handler.span_err(attr.span(), &msg);\n+            return;\n+        }\n+\n+        if attr.check_name(\"proc_macro_derive\") {\n+            self.collect_custom_derive(item, attr);\n+        } else if attr.check_name(\"proc_macro_attribute\") {\n+            self.collect_attr_proc_macro(item, attr);\n+        };\n \n         visit::walk_item(self, item);\n     }\n@@ -265,7 +319,8 @@ impl<'a> Visitor<'a> for CollectCustomDerives<'a> {\n //          }\n //      }\n fn mk_registrar(cx: &mut ExtCtxt,\n-                custom_derives: &[CustomDerive]) -> P<ast::Item> {\n+                custom_derives: &[CustomDerive],\n+                custom_attrs: &[AttrProcMacro]) -> P<ast::Item> {\n     let eid = cx.codemap().record_expansion(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n@@ -286,25 +341,36 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let registry = Ident::from_str(\"Registry\");\n     let registrar = Ident::from_str(\"registrar\");\n     let register_custom_derive = Ident::from_str(\"register_custom_derive\");\n-    let stmts = custom_derives.iter().map(|cd| {\n+    let register_attr_proc_macro = Ident::from_str(\"register_attr_proc_macro\");\n+\n+    let mut stmts = custom_derives.iter().map(|cd| {\n         let path = cx.path_global(cd.span, vec![cd.function_name]);\n         let trait_name = cx.expr_str(cd.span, cd.trait_name);\n         let attrs = cx.expr_vec_slice(\n             span,\n             cd.attrs.iter().map(|&s| cx.expr_str(cd.span, s)).collect::<Vec<_>>()\n         );\n-        (path, trait_name, attrs)\n-    }).map(|(path, trait_name, attrs)| {\n         let registrar = cx.expr_ident(span, registrar);\n         let ufcs_path = cx.path(span, vec![proc_macro, __internal, registry,\n                                            register_custom_derive]);\n-        cx.expr_call(span,\n-                     cx.expr_path(ufcs_path),\n-                     vec![registrar, trait_name, cx.expr_path(path), attrs])\n-    }).map(|expr| {\n-        cx.stmt_expr(expr)\n+\n+        cx.stmt_expr(cx.expr_call(span, cx.expr_path(ufcs_path),\n+                                  vec![registrar, trait_name, cx.expr_path(path), attrs]))\n+\n     }).collect::<Vec<_>>();\n \n+    stmts.extend(custom_attrs.iter().map(|ca| {\n+        let name = cx.expr_str(ca.span, ca.function_name.name);\n+        let path = cx.path_global(ca.span, vec![ca.function_name]);\n+        let registrar = cx.expr_ident(ca.span, registrar);\n+\n+        let ufcs_path = cx.path(span,\n+                                vec![proc_macro, __internal, registry, register_attr_proc_macro]);\n+\n+        cx.stmt_expr(cx.expr_call(span, cx.expr_path(ufcs_path),\n+                                  vec![registrar, name, cx.expr_path(path)]))\n+    }));\n+\n     let path = cx.path(span, vec![proc_macro, __internal, registry]);\n     let registrar_path = cx.ty_path(path);\n     let arg_ty = cx.ty_rptr(span, registrar_path, None, ast::Mutability::Mutable);"}, {"sha": "db0c19e96f8211a2996bb6df3e21b8e21b52e0db", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attr_proc_macro.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr_proc_macro.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_attribute]\n+pub fn attr_proc_macro(_: TokenStream, input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "a5359946c09c2626557ba7fbb023b39f9c7db5e2", "filename": "src/test/compile-fail-fulldeps/proc-macro/derive-bad.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fderive-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fderive-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fderive-bad.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -16,8 +16,7 @@ extern crate derive_bad;\n #[derive(\n     A\n )]\n-//~^^ ERROR: custom derive attribute panicked\n-//~| HELP: called `Result::unwrap()` on an `Err` value: LexError\n+//~^^ ERROR: custom derive produced unparseable tokens\n struct A;\n \n fn main() {}"}, {"sha": "7e32800e0f9b8a915e597c5936e905f4dd0882f5", "filename": "src/test/compile-fail-fulldeps/proc-macro/feature-gate-proc_macro.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ffeature-gate-proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ffeature-gate-proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Ffeature-gate-proc_macro.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attr_proc_macro.rs\n+// gate-test-proc_macro\n+#![feature(use_extern_macros)]\n+\n+extern crate attr_proc_macro;\n+use attr_proc_macro::attr_proc_macro;\n+\n+#[attr_proc_macro]\n+//~^ ERROR: attribute procedural macros are experimental\n+struct Foo;\n+\n+fn main() {\n+    let _ = Foo;\n+}\n\\ No newline at end of file"}, {"sha": "76253487b51fc294f5abd7468e9a4d2a4a9f1a10", "filename": "src/test/compile-fail-fulldeps/proc-macro/macro-use-attr.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacro-use-attr.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attr_proc_macro.rs\n+#![feature(proc_macro)]\n+\n+#[macro_use] extern crate attr_proc_macro;\n+\n+#[attr_proc_macro]\n+//~^ ERROR: attribute procedural macros cannot be imported with `#[macro_use]`\n+struct Foo;\n+\n+fn main() {\n+    let _ = Foo;\n+}"}, {"sha": "288cab71ff49c24faf9fefeeaaca5aa150ba5e68", "filename": "src/test/compile-fail-fulldeps/proc-macro/proc-macro-custom-attr-mutex.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-custom-attr-mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-custom-attr-mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-custom-attr-mutex.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attr_proc_macro.rs\n+\n+#![feature(proc_macro, custom_attribute)]\n+//~^ ERROR Cannot use `#![feature(proc_macro)]` and `#![feature(custom_attribute)] at the same time\n+\n+extern crate attr_proc_macro;\n+use attr_proc_macro::attr_proc_macro;\n+\n+#[attr_proc_macro]\n+fn foo() {}\n+\n+fn main() {\n+    foo();\n+}"}, {"sha": "d093364497a9234988d65ecd2d10857ae74fc988", "filename": "src/test/compile-fail/const-fn-stability.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail%2Fconst-fn-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail%2Fconst-fn-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-stability.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -16,7 +16,9 @@ const fn foo() -> usize { 0 } //~ ERROR const fn is unstable\n \n trait Foo {\n     const fn foo() -> u32; //~ ERROR const fn is unstable\n+                           //~| ERROR trait fns cannot be declared const\n     const fn bar() -> u32 { 0 } //~ ERROR const fn is unstable\n+                                //~| ERROR trait fns cannot be declared const\n }\n \n impl Foo {\n@@ -25,6 +27,7 @@ impl Foo {\n \n impl Foo for u32 {\n     const fn foo() -> u32 { 0 } //~ ERROR const fn is unstable\n+                                //~| ERROR trait fns cannot be declared const\n }\n \n static FOO: usize = foo();"}, {"sha": "9815db6550d66cc99751050870bde7dc91efc7b9", "filename": "src/test/compile-fail/feature-gate-no-debug.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail%2Ffeature-gate-no-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Fcompile-fail%2Ffeature-gate-no-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-no-debug.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -8,5 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(deprecated)]\n+\n #[no_debug] //~ ERROR the `#[no_debug]` attribute is\n fn main() {}"}, {"sha": "d28d75d81a2fb7ca5f35d42d60afdc0d49e0a792", "filename": "src/test/run-pass-fulldeps/proc-macro/attr-args.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-args.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attr-args.rs\n+\n+#![allow(warnings)]\n+#![feature(proc_macro)]\n+\n+extern crate attr_args;\n+use attr_args::attr_with_args;\n+\n+#[attr_with_args(text = \"Hello, world!\")]\n+fn foo() {}\n+\n+fn main() {\n+    assert_eq!(foo(), \"Hello, world!\");\n+}"}, {"sha": "6e1eb395a0a1923f6a215cbaf6400060a8462dd6", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/attr-args.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-args.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_attribute]\n+pub fn attr_with_args(args: TokenStream, input: TokenStream) -> TokenStream {\n+    let args = args.to_string();\n+\n+    assert_eq!(args, r#\"( text = \"Hello, world!\" )\"#);\n+\n+    let input = input.to_string();\n+\n+    assert_eq!(input, \"fn foo (  ) {  }\");\n+\n+    r#\"\n+        fn foo() -> &'static str { \"Hello, world!\" }\n+    \"#.parse().unwrap()\n+}"}, {"sha": "4624891c1a32d3279ed5b4e4b7bf22c731f0d6c1", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-atob.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -19,6 +19,6 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AToB)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert_eq!(input, \"#[derive(Copy, Clone)]\\nstruct A;\\n\");\n+    assert_eq!(input, \"#[derive(Copy, Clone)]\\nstruct A;\");\n     \"struct B;\".parse().unwrap()\n }"}, {"sha": "550ffe9400db88a3707bdfe3b52f3452869c7b4c", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-ctod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-ctod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-ctod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-ctod.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -19,6 +19,6 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(CToD)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert_eq!(input, \"struct C;\\n\");\n+    assert_eq!(input, \"struct C;\");\n     \"struct D;\".parse().unwrap()\n }"}, {"sha": "cf96f52823f0f0fcb3b2bdbd2ff5923468c66069", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-same-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -18,12 +18,12 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AToB)]\n pub fn derive1(input: TokenStream) -> TokenStream {\n     println!(\"input1: {:?}\", input.to_string());\n-    assert_eq!(input.to_string(), \"struct A;\\n\");\n+    assert_eq!(input.to_string(), \"struct A;\");\n     \"#[derive(BToC)] struct B;\".parse().unwrap()\n }\n \n #[proc_macro_derive(BToC)]\n pub fn derive2(input: TokenStream) -> TokenStream {\n-    assert_eq!(input.to_string(), \"struct B;\\n\");\n+    assert_eq!(input.to_string(), \"struct B;\");\n     \"struct C;\".parse().unwrap()\n }"}, {"sha": "9e365456a6c0dbda0322f38d523ef9020f5ab814", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4d276faafb07f13f15178540e337864af8f74db/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=d4d276faafb07f13f15178540e337864af8f74db", "patch": "@@ -172,7 +172,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n         \"use_extern_macros\", \"staged_api\", \"const_indexing\",\n         \"unboxed_closures\", \"stmt_expr_attributes\",\n         \"cfg_target_thread_local\", \"unwind_attributes\",\n-        \"inclusive_range_syntax\"\n+        \"inclusive_range_syntax\", \"proc_macro\"\n     ];\n \n     // Only check the number of lang features."}]}