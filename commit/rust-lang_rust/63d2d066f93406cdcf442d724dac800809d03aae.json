{"sha": "63d2d066f93406cdcf442d724dac800809d03aae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZDJkMDY2ZjkzNDA2Y2RjZjQ0MmQ3MjRkYWM4MDA4MDlkMDNhYWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-14T10:59:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-14T10:59:36Z"}, "message": "Auto merge of #4369 - mikerite:fix-4293, r=flip1995\n\n Fix `wrong_self_convention` issue\n\nResolves #4293\n\nchangelog: Fix `wrong_self_convention` issue", "tree": {"sha": "ba29866a48b1ce26205a9abd0db52d63c8373bff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba29866a48b1ce26205a9abd0db52d63c8373bff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63d2d066f93406cdcf442d724dac800809d03aae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63d2d066f93406cdcf442d724dac800809d03aae", "html_url": "https://github.com/rust-lang/rust/commit/63d2d066f93406cdcf442d724dac800809d03aae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63d2d066f93406cdcf442d724dac800809d03aae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f8bdf3587d653b229fa7056085d9a7630d36a71", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f8bdf3587d653b229fa7056085d9a7630d36a71", "html_url": "https://github.com/rust-lang/rust/commit/4f8bdf3587d653b229fa7056085d9a7630d36a71"}, {"sha": "77278ccda9f8bfadb81e685255a3411f4287149d", "url": "https://api.github.com/repos/rust-lang/rust/commits/77278ccda9f8bfadb81e685255a3411f4287149d", "html_url": "https://github.com/rust-lang/rust/commit/77278ccda9f8bfadb81e685255a3411f4287149d"}], "stats": {"total": 278, "additions": 118, "deletions": 160}, "files": [{"sha": "9481cf4c861407087f2e12be66974d7b7dc15d83", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 99, "deletions": 160, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/63d2d066f93406cdcf442d724dac800809d03aae/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d2d066f93406cdcf442d724dac800809d03aae/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=63d2d066f93406cdcf442d724dac800809d03aae", "patch": "@@ -23,10 +23,10 @@ use crate::utils::sugg;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n     get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, in_macro, is_copy,\n-    is_ctor_function, is_expn_of, is_self, is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path,\n-    match_qpath, match_trait_method, match_type, match_var, method_calls, method_chain_args, remove_blocks, return_ty,\n-    same_tys, single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n+    is_ctor_function, is_expn_of, iter_input_pats, last_path_segment, match_def_path, match_qpath, match_trait_method,\n+    match_type, match_var, method_calls, method_chain_args, remove_blocks, return_ty, same_tys, single_segment_path,\n+    snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_sugg,\n+    span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -1015,69 +1015,76 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, implitem: &'tcx hir::ImplItem) {\n-        if in_external_macro(cx.sess(), implitem.span) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx hir::ImplItem) {\n+        if in_external_macro(cx.sess(), impl_item.span) {\n             return;\n         }\n-        let name = implitem.ident.name.as_str();\n-        let parent = cx.tcx.hir().get_parent_item(implitem.hir_id);\n+        let name = impl_item.ident.name.as_str();\n+        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id);\n         let item = cx.tcx.hir().expect_item(parent);\n         let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         let ty = cx.tcx.type_of(def_id);\n         if_chain! {\n-            if let hir::ImplItemKind::Method(ref sig, id) = implitem.node;\n-            if let Some(first_arg_ty) = sig.decl.inputs.get(0);\n+            if let hir::ImplItemKind::Method(ref sig, id) = impl_item.node;\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n-            if let hir::ItemKind::Impl(_, _, _, _, None, ref self_ty, _) = item.node;\n+            if let hir::ItemKind::Impl(_, _, _, _, None, _, _) = item.node;\n             then {\n-                if cx.access_levels.is_exported(implitem.hir_id) {\n-                // check missing trait implementations\n-                    for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                        if name == method_name &&\n-                        sig.decl.inputs.len() == n_args &&\n-                        out_type.matches(cx, &sig.decl.output) &&\n-                        self_kind.matches(cx, first_arg_ty, first_arg, self_ty, false, &implitem.generics) {\n-                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n-                                \"defining a method called `{}` on this type; consider implementing \\\n-                                the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n-                        }\n-                    }\n-                }\n+                let method_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n+                let method_sig = cx.tcx.fn_sig(method_def_id);\n+                let method_sig = cx.tcx.erase_late_bound_regions(&method_sig);\n+\n+                let first_arg_ty = &method_sig.inputs().iter().next();\n \n                 // check conventions w.r.t. conversion method names and predicates\n-                let is_copy = is_copy(cx, ty);\n-                for &(ref conv, self_kinds) in &CONVENTIONS {\n-                    if conv.check(&name) {\n-                        if !self_kinds\n-                                .iter()\n-                                .any(|k| k.matches(cx, first_arg_ty, first_arg, self_ty, is_copy, &implitem.generics)) {\n-                            let lint = if item.vis.node.is_pub() {\n-                                WRONG_PUB_SELF_CONVENTION\n-                            } else {\n-                                WRONG_SELF_CONVENTION\n-                            };\n-                            span_lint(cx,\n-                                      lint,\n-                                      first_arg.pat.span,\n-                                      &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n-                                                ambiguous name\",\n-                                               conv,\n-                                               &self_kinds.iter()\n-                                                          .map(|k| k.description())\n-                                                          .collect::<Vec<_>>()\n-                                                          .join(\" or \")));\n+                if let Some(first_arg_ty) = first_arg_ty {\n+\n+                    if cx.access_levels.is_exported(impl_item.hir_id) {\n+                    // check missing trait implementations\n+                        for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n+                            if name == method_name &&\n+                            sig.decl.inputs.len() == n_args &&\n+                            out_type.matches(cx, &sig.decl.output) &&\n+                            self_kind.matches(cx, ty, first_arg_ty) {\n+                                span_lint(cx, SHOULD_IMPLEMENT_TRAIT, impl_item.span, &format!(\n+                                    \"defining a method called `{}` on this type; consider implementing \\\n+                                    the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                            }\n                         }\n+                    }\n \n-                        // Only check the first convention to match (CONVENTIONS should be listed from most to least\n-                        // specific)\n-                        break;\n+                    for &(ref conv, self_kinds) in &CONVENTIONS {\n+                        if conv.check(&name) {\n+                            if !self_kinds\n+                                    .iter()\n+                                    .any(|k| k.matches(cx, ty, first_arg_ty)) {\n+                                let lint = if item.vis.node.is_pub() {\n+                                    WRONG_PUB_SELF_CONVENTION\n+                                } else {\n+                                    WRONG_SELF_CONVENTION\n+                                };\n+                                span_lint(cx,\n+                                          lint,\n+                                          first_arg.pat.span,\n+                                          &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n+                                                    ambiguous name\",\n+                                                   conv,\n+                                                   &self_kinds.iter()\n+                                                              .map(|k| k.description())\n+                                                              .collect::<Vec<_>>()\n+                                                              .join(\" or \")));\n+                            }\n+\n+                            // Only check the first convention to match (CONVENTIONS should be listed from most to least\n+                            // specific)\n+                            break;\n+                        }\n                     }\n                 }\n             }\n         }\n \n-        if let hir::ImplItemKind::Method(_, _) = implitem.node {\n-            let ret_ty = return_ty(cx, implitem.hir_id);\n+        if let hir::ImplItemKind::Method(_, _) = impl_item.node {\n+            let ret_ty = return_ty(cx, impl_item.hir_id);\n \n             // walk the return type and check for Self (this does not check associated types)\n             for inner_type in ret_ty.walk() {\n@@ -1111,7 +1118,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                 span_lint(\n                     cx,\n                     NEW_RET_NO_SELF,\n-                    implitem.span,\n+                    impl_item.span,\n                     \"methods called `new` usually return `Self`\",\n                 );\n             }\n@@ -2614,55 +2621,49 @@ enum SelfKind {\n }\n \n impl SelfKind {\n-    fn matches(\n-        self,\n-        cx: &LateContext<'_, '_>,\n-        ty: &hir::Ty,\n-        arg: &hir::Arg,\n-        self_ty: &hir::Ty,\n-        allow_value_for_ref: bool,\n-        generics: &hir::Generics,\n-    ) -> bool {\n-        // Self types in the HIR are desugared to explicit self types. So it will\n-        // always be `self:\n-        // SomeType`,\n-        // where SomeType can be `Self` or an explicit impl self type (e.g., `Foo` if\n-        // the impl is on `Foo`)\n-        // Thus, we only need to test equality against the impl self type or if it is\n-        // an explicit\n-        // `Self`. Furthermore, the only possible types for `self: ` are `&Self`,\n-        // `Self`, `&mut Self`,\n-        // and `Box<Self>`, including the equivalent types with `Foo`.\n-\n-        let is_actually_self = |ty| is_self_ty(ty) || SpanlessEq::new(cx).eq_ty(ty, self_ty);\n-        if is_self(arg) {\n-            match self {\n-                Self::Value => is_actually_self(ty),\n-                Self::Ref | Self::RefMut => {\n-                    if allow_value_for_ref && is_actually_self(ty) {\n-                        return true;\n-                    }\n-                    match ty.node {\n-                        hir::TyKind::Rptr(_, ref mt_ty) => {\n-                            let mutability_match = if self == Self::Ref {\n-                                mt_ty.mutbl == hir::MutImmutable\n-                            } else {\n-                                mt_ty.mutbl == hir::MutMutable\n-                            };\n-                            is_actually_self(&mt_ty.ty) && mutability_match\n-                        },\n-                        _ => false,\n-                    }\n-                },\n-                _ => false,\n+    fn matches<'a>(self, cx: &LateContext<'_, 'a>, parent_ty: Ty<'a>, ty: Ty<'a>) -> bool {\n+        fn matches_value(parent_ty: Ty<'_>, ty: Ty<'_>) -> bool {\n+            if ty == parent_ty {\n+                true\n+            } else if ty.is_box() {\n+                ty.boxed_ty() == parent_ty\n+            } else if ty.is_rc() || ty.is_arc() {\n+                if let ty::Adt(_, substs) = ty.sty {\n+                    substs.types().next().map_or(false, |t| t == parent_ty)\n+                } else {\n+                    false\n+                }\n+            } else {\n+                false\n             }\n-        } else {\n-            match self {\n-                Self::Value => false,\n-                Self::Ref => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASREF_TRAIT),\n-                Self::RefMut => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASMUT_TRAIT),\n-                Self::No => true,\n+        }\n+\n+        fn matches_ref<'a>(\n+            cx: &LateContext<'_, 'a>,\n+            mutability: hir::Mutability,\n+            parent_ty: Ty<'a>,\n+            ty: Ty<'a>,\n+        ) -> bool {\n+            if let ty::Ref(_, t, m) = ty.sty {\n+                return m == mutability && t == parent_ty;\n             }\n+\n+            let trait_path = match mutability {\n+                hir::Mutability::MutImmutable => &paths::ASREF_TRAIT,\n+                hir::Mutability::MutMutable => &paths::ASMUT_TRAIT,\n+            };\n+\n+            let trait_def_id = get_trait_def_id(cx, trait_path).expect(\"trait def id not found\");\n+            implements_trait(cx, ty, trait_def_id, &[parent_ty.into()])\n+        }\n+\n+        match self {\n+            Self::Value => matches_value(parent_ty, ty),\n+            Self::Ref => {\n+                matches_ref(cx, hir::Mutability::MutImmutable, parent_ty, ty) || ty == parent_ty && is_copy(cx, ty)\n+            },\n+            Self::RefMut => matches_ref(cx, hir::Mutability::MutMutable, parent_ty, ty),\n+            Self::No => ty != parent_ty,\n         }\n     }\n \n@@ -2676,68 +2677,6 @@ impl SelfKind {\n     }\n }\n \n-fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Generics, name: &[&str]) -> bool {\n-    single_segment_ty(ty).map_or(false, |seg| {\n-        generics.params.iter().any(|param| match param.kind {\n-            hir::GenericParamKind::Type { .. } => {\n-                param.name.ident().name == seg.ident.name\n-                    && param.bounds.iter().any(|bound| {\n-                        if let hir::GenericBound::Trait(ref ptr, ..) = *bound {\n-                            let path = &ptr.trait_ref.path;\n-                            match_path(path, name)\n-                                && path.segments.last().map_or(false, |s| {\n-                                    if let Some(ref params) = s.args {\n-                                        if params.parenthesized {\n-                                            false\n-                                        } else {\n-                                            // FIXME(flip1995): messy, improve if there is a better option\n-                                            // in the compiler\n-                                            let types: Vec<_> = params\n-                                                .args\n-                                                .iter()\n-                                                .filter_map(|arg| match arg {\n-                                                    hir::GenericArg::Type(ty) => Some(ty),\n-                                                    _ => None,\n-                                                })\n-                                                .collect();\n-                                            types.len() == 1 && (is_self_ty(&types[0]) || is_ty(&*types[0], self_ty))\n-                                        }\n-                                    } else {\n-                                        false\n-                                    }\n-                                })\n-                        } else {\n-                            false\n-                        }\n-                    })\n-            },\n-            _ => false,\n-        })\n-    })\n-}\n-\n-fn is_ty(ty: &hir::Ty, self_ty: &hir::Ty) -> bool {\n-    match (&ty.node, &self_ty.node) {\n-        (\n-            &hir::TyKind::Path(hir::QPath::Resolved(_, ref ty_path)),\n-            &hir::TyKind::Path(hir::QPath::Resolved(_, ref self_ty_path)),\n-        ) => ty_path\n-            .segments\n-            .iter()\n-            .map(|seg| seg.ident.name)\n-            .eq(self_ty_path.segments.iter().map(|seg| seg.ident.name)),\n-        _ => false,\n-    }\n-}\n-\n-fn single_segment_ty(ty: &hir::Ty) -> Option<&hir::PathSegment> {\n-    if let hir::TyKind::Path(ref path) = ty.node {\n-        single_segment_path(path)\n-    } else {\n-        None\n-    }\n-}\n-\n impl Convention {\n     fn check(&self, other: &str) -> bool {\n         match *self {"}, {"sha": "7567fa7158cb0b3666211a91628c50c2855051ac", "filename": "tests/ui/wrong_self_convention.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/63d2d066f93406cdcf442d724dac800809d03aae/tests%2Fui%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d2d066f93406cdcf442d724dac800809d03aae/tests%2Fui%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.rs?ref=63d2d066f93406cdcf442d724dac800809d03aae", "patch": "@@ -56,3 +56,22 @@ impl Bar {\n     fn from_(self) {}\n     fn to_mut(&mut self) {}\n }\n+\n+// Allow Box<Self>, Rc<Self>, Arc<Self> for methods that take conventionally take Self by value\n+#[allow(clippy::boxed_local)]\n+mod issue4293 {\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n+\n+    struct T;\n+\n+    impl T {\n+        fn into_s1(self: Box<Self>) {}\n+        fn into_s2(self: Rc<Self>) {}\n+        fn into_s3(self: Arc<Self>) {}\n+\n+        fn into_t1(self: Box<T>) {}\n+        fn into_t2(self: Rc<T>) {}\n+        fn into_t3(self: Arc<T>) {}\n+    }\n+}"}]}