{"sha": "0aacacd4a2ece0801287cf3e8f3f7c9115f6b548", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhYWNhY2Q0YTJlY2UwODAxMjg3Y2YzZThmM2Y3YzkxMTVmNmI1NDg=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-03-28T10:12:51Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-03-31T14:20:18Z"}, "message": "Simple cross-process message protocol", "tree": {"sha": "922d9440f7bf8449adb5a05bc03a22e0805e0824", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/922d9440f7bf8449adb5a05bc03a22e0805e0824"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0aacacd4a2ece0801287cf3e8f3f7c9115f6b548", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0aacacd4a2ece0801287cf3e8f3f7c9115f6b548", "html_url": "https://github.com/rust-lang/rust/commit/0aacacd4a2ece0801287cf3e8f3f7c9115f6b548", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0aacacd4a2ece0801287cf3e8f3f7c9115f6b548/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7155d5df89e6b36018f8844774c4164eba64b49f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7155d5df89e6b36018f8844774c4164eba64b49f", "html_url": "https://github.com/rust-lang/rust/commit/7155d5df89e6b36018f8844774c4164eba64b49f"}], "stats": {"total": 311, "additions": 86, "deletions": 225}, "files": [{"sha": "aa95bcc8f7bc5d5d5537d2dbf4e541dddd6af887", "filename": "crates/ra_proc_macro/src/msg.rs", "status": "modified", "additions": 53, "deletions": 178, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/0aacacd4a2ece0801287cf3e8f3f7c9115f6b548/crates%2Fra_proc_macro%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aacacd4a2ece0801287cf3e8f3f7c9115f6b548/crates%2Fra_proc_macro%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Fmsg.rs?ref=0aacacd4a2ece0801287cf3e8f3f7c9115f6b548", "patch": "@@ -1,218 +1,93 @@\n-//! A simplified version of lsp base protocol for rpc\n+//! Defines messages for cross-process message based on `ndjson` wire protocol\n \n use std::{\n-    fmt,\n+    convert::TryFrom,\n     io::{self, BufRead, Write},\n };\n \n+use crate::{\n+    rpc::{ListMacrosResult, ListMacrosTask},\n+    ExpansionResult, ExpansionTask,\n+};\n use serde::{de::DeserializeOwned, Deserialize, Serialize};\n \n-#[derive(Serialize, Deserialize, Debug, Clone)]\n-#[serde(untagged)]\n-pub enum Message {\n-    Request(Request),\n-    Response(Response),\n-}\n-\n-impl From<Request> for Message {\n-    fn from(request: Request) -> Message {\n-        Message::Request(request)\n-    }\n-}\n-\n-impl From<Response> for Message {\n-    fn from(response: Response) -> Message {\n-        Message::Response(response)\n-    }\n-}\n-\n-#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-#[serde(transparent)]\n-pub struct RequestId(IdRepr);\n-\n-#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-#[serde(untagged)]\n-enum IdRepr {\n-    U64(u64),\n-    String(String),\n-}\n-\n-impl From<u64> for RequestId {\n-    fn from(id: u64) -> RequestId {\n-        RequestId(IdRepr::U64(id))\n-    }\n-}\n-\n-impl From<String> for RequestId {\n-    fn from(id: String) -> RequestId {\n-        RequestId(IdRepr::String(id))\n-    }\n-}\n-\n-impl fmt::Display for RequestId {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.0 {\n-            IdRepr::U64(it) => fmt::Display::fmt(it, f),\n-            IdRepr::String(it) => fmt::Display::fmt(it, f),\n-        }\n-    }\n-}\n-\n #[derive(Debug, Serialize, Deserialize, Clone)]\n-pub struct Request {\n-    pub id: RequestId,\n-    pub method: String,\n-    pub params: serde_json::Value,\n+pub enum Request {\n+    ListMacro(ListMacrosTask),\n+    ExpansionMacro(ExpansionTask),\n }\n \n #[derive(Debug, Serialize, Deserialize, Clone)]\n-pub struct Response {\n-    // JSON RPC allows this to be null if it was impossible\n-    // to decode the request's id. Ignore this special case\n-    // and just die horribly.\n-    pub id: RequestId,\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub result: Option<serde_json::Value>,\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub error: Option<ResponseError>,\n+pub enum Response {\n+    Error(ResponseError),\n+    ListMacro(ListMacrosResult),\n+    ExpansionMacro(ExpansionResult),\n+}\n+\n+macro_rules! impl_try_from_response {\n+    ($ty:ty, $tag:ident) => {\n+        impl TryFrom<Response> for $ty {\n+            type Error = &'static str;\n+            fn try_from(value: Response) -> Result<Self, Self::Error> {\n+                match value {\n+                    Response::$tag(res) => Ok(res),\n+                    _ => Err(\"Fail to convert from response\"),\n+                }\n+            }\n+        }\n+    };\n }\n \n+impl_try_from_response!(ListMacrosResult, ListMacro);\n+impl_try_from_response!(ExpansionResult, ExpansionMacro);\n+\n #[derive(Debug, Serialize, Deserialize, Clone)]\n pub struct ResponseError {\n-    pub code: i32,\n+    pub code: ErrorCode,\n     pub message: String,\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub data: Option<serde_json::Value>,\n-}\n-\n-#[derive(Clone, Copy, Debug)]\n-#[allow(unused)]\n-pub enum ErrorCode {\n-    // Defined by JSON RPC\n-    ParseError = -32700,\n-    InvalidRequest = -32600,\n-    MethodNotFound = -32601,\n-    InvalidParams = -32602,\n-    InternalError = -32603,\n-    ServerErrorStart = -32099,\n-    ServerErrorEnd = -32000,\n-    ServerNotInitialized = -32002,\n-    UnknownErrorCode = -32001,\n-\n-    // Defined by protocol\n-    ExpansionError = -32900,\n }\n \n #[derive(Debug, Serialize, Deserialize, Clone)]\n-pub struct Notification {\n-    pub method: String,\n-    pub params: serde_json::Value,\n+pub enum ErrorCode {\n+    ServerErrorEnd,\n+    ExpansionError,\n }\n \n-impl Message {\n-    pub fn read(r: &mut impl BufRead) -> io::Result<Option<Message>> {\n-        let text = match read_msg_text(r)? {\n+pub trait Message: Sized + Serialize + DeserializeOwned {\n+    fn read(r: &mut impl BufRead) -> io::Result<Option<Self>> {\n+        let text = match read_json(r)? {\n             None => return Ok(None),\n             Some(text) => text,\n         };\n         let msg = serde_json::from_str(&text)?;\n         Ok(Some(msg))\n     }\n-    pub fn write(self, w: &mut impl Write) -> io::Result<()> {\n-        #[derive(Serialize)]\n-        struct JsonRpc {\n-            jsonrpc: &'static str,\n-            #[serde(flatten)]\n-            msg: Message,\n-        }\n-        let text = serde_json::to_string(&JsonRpc { jsonrpc: \"2.0\", msg: self })?;\n-        write_msg_text(w, &text)\n+    fn write(self, w: &mut impl Write) -> io::Result<()> {\n+        let text = serde_json::to_string(&self)?;\n+        write_json(w, &text)\n     }\n }\n \n-impl Response {\n-    pub fn new_ok<R: Serialize>(id: RequestId, result: R) -> Response {\n-        Response { id, result: Some(serde_json::to_value(result).unwrap()), error: None }\n-    }\n-    pub fn new_err(id: RequestId, code: i32, message: String) -> Response {\n-        let error = ResponseError { code, message, data: None };\n-        Response { id, result: None, error: Some(error) }\n-    }\n-}\n+impl Message for Request {}\n+impl Message for Response {}\n \n-impl Request {\n-    pub fn new<P: Serialize>(id: RequestId, method: String, params: P) -> Request {\n-        Request { id, method, params: serde_json::to_value(params).unwrap() }\n-    }\n-    pub fn extract<P: DeserializeOwned>(self, method: &str) -> Result<(RequestId, P), Request> {\n-        if self.method == method {\n-            let params = serde_json::from_value(self.params).unwrap_or_else(|err| {\n-                panic!(\"Invalid request\\nMethod: {}\\n error: {}\", method, err)\n-            });\n-            Ok((self.id, params))\n-        } else {\n-            Err(self)\n-        }\n-    }\n-}\n-\n-impl Notification {\n-    pub fn new(method: String, params: impl Serialize) -> Notification {\n-        Notification { method, params: serde_json::to_value(params).unwrap() }\n-    }\n-    pub fn extract<P: DeserializeOwned>(self, method: &str) -> Result<P, Notification> {\n-        if self.method == method {\n-            let params = serde_json::from_value(self.params).unwrap();\n-            Ok(params)\n-        } else {\n-            Err(self)\n-        }\n-    }\n-}\n-\n-fn read_msg_text(inp: &mut impl BufRead) -> io::Result<Option<String>> {\n-    fn invalid_data(error: impl Into<Box<dyn std::error::Error + Send + Sync>>) -> io::Error {\n-        io::Error::new(io::ErrorKind::InvalidData, error)\n-    }\n-    macro_rules! invalid_data {\n-        ($($tt:tt)*) => (invalid_data(format!($($tt)*)))\n-    }\n-\n-    let mut size = None;\n+fn read_json(inp: &mut impl BufRead) -> io::Result<Option<String>> {\n     let mut buf = String::new();\n-    loop {\n-        buf.clear();\n-        if inp.read_line(&mut buf)? == 0 {\n-            return Ok(None);\n-        }\n-        if !buf.ends_with(\"\\r\\n\") {\n-            return Err(invalid_data!(\"malformed header: {:?}\", buf));\n-        }\n-        let buf = &buf[..buf.len() - 2];\n-        if buf.is_empty() {\n-            break;\n-        }\n-        let mut parts = buf.splitn(2, \": \");\n-        let header_name = parts.next().unwrap();\n-        let header_value =\n-            parts.next().ok_or_else(|| invalid_data!(\"malformed header: {:?}\", buf))?;\n-        if header_name == \"Content-Length\" {\n-            size = Some(header_value.parse::<usize>().map_err(invalid_data)?);\n-        }\n+    if inp.read_line(&mut buf)? == 0 {\n+        return Ok(None);\n+    }\n+    // Remove ending '\\n'\n+    let buf = &buf[..buf.len() - 1];\n+    if buf.is_empty() {\n+        return Ok(None);\n     }\n-    let size: usize = size.ok_or_else(|| invalid_data!(\"no Content-Length\"))?;\n-    let mut buf = buf.into_bytes();\n-    buf.resize(size, 0);\n-    inp.read_exact(&mut buf)?;\n-    let buf = String::from_utf8(buf).map_err(invalid_data)?;\n-    log::debug!(\"< {}\", buf);\n-    Ok(Some(buf))\n+    Ok(Some(buf.to_string()))\n }\n \n-fn write_msg_text(out: &mut impl Write, msg: &str) -> io::Result<()> {\n+fn write_json(out: &mut impl Write, msg: &str) -> io::Result<()> {\n     log::debug!(\"> {}\", msg);\n-    write!(out, \"Content-Length: {}\\r\\n\\r\\n\", msg.len())?;\n     out.write_all(msg.as_bytes())?;\n+    out.write_all(b\"\\n\")?;\n     out.flush()?;\n     Ok(())\n }"}, {"sha": "2b1f8535a14fc414eec7773f67ec968c4691685f", "filename": "crates/ra_proc_macro/src/process.rs", "status": "modified", "additions": 27, "deletions": 47, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0aacacd4a2ece0801287cf3e8f3f7c9115f6b548/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aacacd4a2ece0801287cf3e8f3f7c9115f6b548/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs?ref=0aacacd4a2ece0801287cf3e8f3f7c9115f6b548", "patch": "@@ -3,11 +3,12 @@\n use crossbeam_channel::{bounded, Receiver, Sender};\n use ra_tt::Subtree;\n \n-use crate::msg::{ErrorCode, Message, Request, Response, ResponseError};\n+use crate::msg::{ErrorCode, Request, Response, ResponseError, Message};\n use crate::rpc::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask, ProcMacroKind};\n \n use io::{BufRead, BufReader};\n use std::{\n+    convert::{TryFrom, TryInto},\n     io::{self, Write},\n     path::{Path, PathBuf},\n     process::{Child, Command, Stdio},\n@@ -26,7 +27,7 @@ pub(crate) struct ProcMacroProcessThread {\n }\n \n enum Task {\n-    Request { req: Message, result_tx: Sender<Message> },\n+    Request { req: Request, result_tx: Sender<Response> },\n     Close,\n }\n \n@@ -96,7 +97,7 @@ impl ProcMacroProcessSrv {\n     ) -> Result<Vec<(String, ProcMacroKind)>, ra_tt::ExpansionError> {\n         let task = ListMacrosTask { lib: dylib_path.to_path_buf() };\n \n-        let result: ListMacrosResult = self.send_task(\"list_macros\", task)?;\n+        let result: ListMacrosResult = self.send_task(Request::ListMacro(task))?;\n         Ok(result.macros)\n     }\n \n@@ -113,26 +114,19 @@ impl ProcMacroProcessSrv {\n             lib: dylib_path.to_path_buf(),\n         };\n \n-        let result: ExpansionResult = self.send_task(\"custom_derive\", task)?;\n+        let result: ExpansionResult = self.send_task(Request::ExpansionMacro(task))?;\n         Ok(result.expansion)\n     }\n \n-    pub fn send_task<'a, T, R>(&self, method: &str, task: T) -> Result<R, ra_tt::ExpansionError>\n+    pub fn send_task<R>(&self, req: Request) -> Result<R, ra_tt::ExpansionError>\n     where\n-        T: serde::Serialize,\n-        R: serde::de::DeserializeOwned + Default,\n+        R: TryFrom<Response, Error = &'static str>,\n     {\n         let sender = match &self.inner {\n             None => return Err(ra_tt::ExpansionError::Unknown(\"No sender is found.\".to_string())),\n             Some(it) => it,\n         };\n \n-        let msg = serde_json::to_value(task).unwrap();\n-\n-        // FIXME: use a proper request id\n-        let id = 0;\n-        let req = Request { id: id.into(), method: method.into(), params: msg };\n-\n         let (result_tx, result_rx) = bounded(0);\n \n         sender.send(Task::Request { req: req.into(), result_tx }).map_err(|err| {\n@@ -141,27 +135,18 @@ impl ProcMacroProcessSrv {\n                 err\n             ))\n         })?;\n-        let response = result_rx.recv().unwrap();\n \n-        match response {\n-            Message::Request(_) => {\n-                return Err(ra_tt::ExpansionError::Unknown(\n-                    \"Return request from ra_proc_srv\".into(),\n-                ))\n-            }\n-            Message::Response(res) => {\n-                if let Some(err) = res.error {\n-                    return Err(ra_tt::ExpansionError::ExpansionError(err.message));\n-                }\n-                match res.result {\n-                    None => Ok(R::default()),\n-                    Some(res) => {\n-                        let result: R = serde_json::from_value(res)\n-                            .map_err(|err| ra_tt::ExpansionError::JsonError(err.to_string()))?;\n-                        Ok(result)\n-                    }\n-                }\n+        let res = result_rx.recv().unwrap();\n+        match res {\n+            Response::Error(err) => {\n+                return Err(ra_tt::ExpansionError::ExpansionError(err.message));\n             }\n+            _ => Ok(res.try_into().map_err(|err| {\n+                ra_tt::ExpansionError::Unknown(format!(\n+                    \"Fail to get response, reason : {:#?} \",\n+                    err\n+                ))\n+            })?),\n         }\n     }\n }\n@@ -183,18 +168,13 @@ fn client_loop(task_rx: Receiver<Task>, mut process: Process) {\n             Task::Close => break,\n         };\n \n-        let res = match send_message(&mut stdin, &mut stdout, req) {\n+        let res = match send_request(&mut stdin, &mut stdout, req) {\n             Ok(res) => res,\n             Err(_err) => {\n-                let res = Response {\n-                    id: 0.into(),\n-                    result: None,\n-                    error: Some(ResponseError {\n-                        code: ErrorCode::ServerErrorEnd as i32,\n-                        message: \"Server closed\".into(),\n-                        data: None,\n-                    }),\n-                };\n+                let res = Response::Error(ResponseError {\n+                    code: ErrorCode::ServerErrorEnd,\n+                    message: \"Server closed\".into(),\n+                });\n                 if result_tx.send(res.into()).is_err() {\n                     break;\n                 }\n@@ -222,11 +202,11 @@ fn client_loop(task_rx: Receiver<Task>, mut process: Process) {\n     let _ = process.child.kill();\n }\n \n-fn send_message(\n+fn send_request(\n     mut writer: &mut impl Write,\n     mut reader: &mut impl BufRead,\n-    msg: Message,\n-) -> Result<Option<Message>, io::Error> {\n-    msg.write(&mut writer)?;\n-    Ok(Message::read(&mut reader)?)\n+    req: Request,\n+) -> Result<Option<Response>, io::Error> {\n+    req.write(&mut writer)?;\n+    Ok(Response::read(&mut reader)?)\n }"}, {"sha": "fc8b04e28895eb110ba4fd07c922f7cc65a63d9b", "filename": "crates/ra_proc_macro/src/rpc.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aacacd4a2ece0801287cf3e8f3f7c9115f6b548/crates%2Fra_proc_macro%2Fsrc%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aacacd4a2ece0801287cf3e8f3f7c9115f6b548/crates%2Fra_proc_macro%2Fsrc%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Frpc.rs?ref=0aacacd4a2ece0801287cf3e8f3f7c9115f6b548", "patch": "@@ -1,4 +1,10 @@\n //! Data struture serialization related stuffs for RPC\n+//! \n+//! Define all necessary rpc serialization data structure, \n+//! which include ra_tt related data and some task messages. \n+//! Although adding Serialize and Deserialize trait to ra_tt directly seem to be much easier, \n+//! we deliberately duplicate the ra_tt struct with #[serde(with = \"XXDef\")] \n+//! for separation of code responsibility.\n \n use ra_tt::{\n     Delimiter, DelimiterKind, Ident, Leaf, Literal, Punct, SmolStr, Spacing, Subtree, TokenId,"}]}