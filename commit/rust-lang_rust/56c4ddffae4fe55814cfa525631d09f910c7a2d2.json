{"sha": "56c4ddffae4fe55814cfa525631d09f910c7a2d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2YzRkZGZmYWU0ZmU1NTgxNGNmYTUyNTYzMWQwOWY5MTBjN2EyZDI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-26T04:12:31Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-14T01:34:38Z"}, "message": "Remove irrelevant tests", "tree": {"sha": "9e95dd305903d717562764aadca55b1d649e23e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e95dd305903d717562764aadca55b1d649e23e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56c4ddffae4fe55814cfa525631d09f910c7a2d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56c4ddffae4fe55814cfa525631d09f910c7a2d2", "html_url": "https://github.com/rust-lang/rust/commit/56c4ddffae4fe55814cfa525631d09f910c7a2d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56c4ddffae4fe55814cfa525631d09f910c7a2d2/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0701571fe741866b4d0d9ad34b6c99717d1e1893", "url": "https://api.github.com/repos/rust-lang/rust/commits/0701571fe741866b4d0d9ad34b6c99717d1e1893", "html_url": "https://github.com/rust-lang/rust/commit/0701571fe741866b4d0d9ad34b6c99717d1e1893"}], "stats": {"total": 172, "additions": 3, "deletions": 169}, "files": [{"sha": "b94079984eb7511526d2c04f6248862202523c3b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 130, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/56c4ddffae4fe55814cfa525631d09f910c7a2d2/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56c4ddffae4fe55814cfa525631d09f910c7a2d2/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=56c4ddffae4fe55814cfa525631d09f910c7a2d2", "patch": "@@ -757,18 +757,11 @@ fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n \n #[cfg(test)]\n mod tests {\n-    use super::{pattern_bindings, expand_crate};\n-    use super::{PatIdentFinder, IdentRenamer, PatIdentRenamer, ExpansionConfig};\n+    use super::{expand_crate, ExpansionConfig};\n     use ast;\n-    use ast::Name;\n-    use syntax_pos;\n     use ext::base::{ExtCtxt, DummyMacroLoader};\n-    use ext::mtwt;\n-    use fold::Folder;\n     use parse;\n-    use parse::token;\n     use util::parser_testing::{string_to_parser};\n-    use util::parser_testing::{string_to_pat, string_to_crate, strs_to_idents};\n     use visit;\n     use visit::Visitor;\n \n@@ -789,32 +782,6 @@ mod tests {\n         }\n     }\n \n-    // find the variable references in a crate\n-    fn crate_varrefs(the_crate : &ast::Crate) -> Vec<ast::Path> {\n-        let mut path_finder = PathExprFinderContext{path_accumulator:Vec::new()};\n-        visit::walk_crate(&mut path_finder, the_crate);\n-        path_finder.path_accumulator\n-    }\n-\n-    /// A Visitor that extracts the identifiers from a thingy.\n-    // as a side note, I'm starting to want to abstract over these....\n-    struct IdentFinder {\n-        ident_accumulator: Vec<ast::Ident>\n-    }\n-\n-    impl Visitor for IdentFinder {\n-        fn visit_ident(&mut self, _: syntax_pos::Span, id: ast::Ident){\n-            self.ident_accumulator.push(id);\n-        }\n-    }\n-\n-    /// Find the idents in a crate\n-    fn crate_idents(the_crate: &ast::Crate) -> Vec<ast::Ident> {\n-        let mut ident_finder = IdentFinder{ident_accumulator: Vec::new()};\n-        visit::walk_crate(&mut ident_finder, the_crate);\n-        ident_finder.ident_accumulator\n-    }\n-\n     // these following tests are quite fragile, in that they don't test what\n     // *kind* of failure occurs.\n \n@@ -876,13 +843,6 @@ mod tests {\n         expand_crate(ecx, vec![], crate_ast).0\n     }\n \n-    // find the pat_ident paths in a crate\n-    fn crate_bindings(the_crate : &ast::Crate) -> Vec<ast::Ident> {\n-        let mut name_finder = PatIdentFinder{ident_accumulator:Vec::new()};\n-        visit::walk_crate(&mut name_finder, the_crate);\n-        name_finder.ident_accumulator\n-    }\n-\n     #[test] fn macro_tokens_should_match(){\n         expand_crate_str(\n             \"macro_rules! m((a)=>(13)) ;fn main(){m!(a);}\".to_string());\n@@ -899,93 +859,4 @@ mod tests {\n     // create a really evil test case where a $x appears inside a binding of $x\n     // but *shouldn't* bind because it was inserted by a different macro....\n     // can't write this test case until we have macro-generating macros.\n-\n-    #[test]\n-    fn fmt_in_macro_used_inside_module_macro() {\n-        let crate_str = \"macro_rules! fmt_wrap(($b:expr)=>($b.to_string()));\n-macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}));\n-foo_module!();\n-\".to_string();\n-        let cr = expand_crate_str(crate_str);\n-        // find the xx binding\n-        let bindings = crate_bindings(&cr);\n-        let cxbinds: Vec<&ast::Ident> =\n-            bindings.iter().filter(|b| b.name.as_str() == \"xx\").collect();\n-        let cxbinds: &[&ast::Ident] = &cxbinds[..];\n-        let cxbind = match (cxbinds.len(), cxbinds.get(0)) {\n-            (1, Some(b)) => *b,\n-            _ => panic!(\"expected just one binding for ext_cx\")\n-        };\n-        let resolved_binding = mtwt::resolve(*cxbind);\n-        let varrefs = crate_varrefs(&cr);\n-\n-        // the xx binding should bind all of the xx varrefs:\n-        for (idx,v) in varrefs.iter().filter(|p| {\n-            p.segments.len() == 1\n-            && p.segments[0].identifier.name.as_str() == \"xx\"\n-        }).enumerate() {\n-            if mtwt::resolve(v.segments[0].identifier) != resolved_binding {\n-                println!(\"uh oh, xx binding didn't match xx varref:\");\n-                println!(\"this is xx varref \\\\# {}\", idx);\n-                println!(\"binding: {}\", cxbind);\n-                println!(\"resolves to: {}\", resolved_binding);\n-                println!(\"varref: {}\", v.segments[0].identifier);\n-                println!(\"resolves to: {}\",\n-                         mtwt::resolve(v.segments[0].identifier));\n-                mtwt::with_sctable(|x| mtwt::display_sctable(x));\n-            }\n-            assert_eq!(mtwt::resolve(v.segments[0].identifier),\n-                       resolved_binding);\n-        };\n-    }\n-\n-    #[test]\n-    fn pat_idents(){\n-        let pat = string_to_pat(\n-            \"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\".to_string());\n-        let idents = pattern_bindings(&pat);\n-        assert_eq!(idents, strs_to_idents(vec!(\"a\",\"c\",\"b\",\"d\")));\n-    }\n-\n-    // test the list of identifier patterns gathered by the visitor. Note that\n-    // 'None' is listed as an identifier pattern because we don't yet know that\n-    // it's the name of a 0-ary variant, and that 'i' appears twice in succession.\n-    #[test]\n-    fn crate_bindings_test(){\n-        let the_crate = string_to_crate(\"fn main (a: i32) -> i32 {|b| {\n-        match 34 {None => 3, Some(i) | i => j, Foo{k:z,l:y} => \\\"banana\\\"}} }\".to_string());\n-        let idents = crate_bindings(&the_crate);\n-        assert_eq!(idents, strs_to_idents(vec!(\"a\",\"b\",\"None\",\"i\",\"i\",\"z\",\"y\")));\n-    }\n-\n-    // test the IdentRenamer directly\n-    #[test]\n-    fn ident_renamer_test () {\n-        let the_crate = string_to_crate(\"fn f(x: i32){let x = x; x}\".to_string());\n-        let f_ident = token::str_to_ident(\"f\");\n-        let x_ident = token::str_to_ident(\"x\");\n-        let int_ident = token::str_to_ident(\"i32\");\n-        let renames = vec!((x_ident,Name(16)));\n-        let mut renamer = IdentRenamer{renames: &renames};\n-        let renamed_crate = renamer.fold_crate(the_crate);\n-        let idents = crate_idents(&renamed_crate);\n-        let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n-        assert_eq!(resolved, [f_ident.name,Name(16),int_ident.name,Name(16),Name(16),Name(16)]);\n-    }\n-\n-    // test the PatIdentRenamer; only PatIdents get renamed\n-    #[test]\n-    fn pat_ident_renamer_test () {\n-        let the_crate = string_to_crate(\"fn f(x: i32){let x = x; x}\".to_string());\n-        let f_ident = token::str_to_ident(\"f\");\n-        let x_ident = token::str_to_ident(\"x\");\n-        let int_ident = token::str_to_ident(\"i32\");\n-        let renames = vec!((x_ident,Name(16)));\n-        let mut renamer = PatIdentRenamer{renames: &renames};\n-        let renamed_crate = renamer.fold_crate(the_crate);\n-        let idents = crate_idents(&renamed_crate);\n-        let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n-        let x_name = x_ident.name;\n-        assert_eq!(resolved, [f_ident.name,Name(16),int_ident.name,Name(16),x_name,x_name]);\n-    }\n }"}, {"sha": "d2f6df9d5dbd3f1936609ee2b613a257c70fe5eb", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/56c4ddffae4fe55814cfa525631d09f910c7a2d2/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56c4ddffae4fe55814cfa525631d09f910c7a2d2/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=56c4ddffae4fe55814cfa525631d09f910c7a2d2", "patch": "@@ -71,14 +71,6 @@ fn new_sctable_internal() -> SCTable {\n     }\n }\n \n-/// Print out an SCTable for debugging\n-pub fn display_sctable(table: &SCTable) {\n-    error!(\"SC table:\");\n-    for (idx,val) in table.table.borrow().iter().enumerate() {\n-        error!(\"{:4} : {:?}\",idx,val);\n-    }\n-}\n-\n /// Clear the tables from TLD to reclaim memory.\n pub fn clear_tables() {\n     with_sctable(|table| {\n@@ -128,13 +120,8 @@ pub fn source(ident: Ident) -> Option<(Ident /* source ident */, Mrk /* source m\n \n #[cfg(test)]\n mod tests {\n-    use ast::{EMPTY_CTXT, Ident, Mrk, Name, SyntaxContext};\n-    use super::{resolve, apply_mark_internal, new_sctable_internal};\n-    use super::{SCTable, Mark};\n-\n-    fn id(n: u32, s: SyntaxContext) -> Ident {\n-        Ident::new(Name(n), s)\n-    }\n+    use ast::{EMPTY_CTXT, Mrk, SyntaxContext};\n+    use super::{apply_mark_internal, new_sctable_internal, Mark, SCTable};\n \n     // extend a syntax context with a sequence of marks given\n     // in a vector. v[0] will be the outermost mark.\n@@ -155,12 +142,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn mtwt_resolve_test(){\n-        let a = 40;\n-        assert_eq!(resolve(id(a,EMPTY_CTXT)),Name(a));\n-    }\n-\n     #[test]\n     fn hashing_tests () {\n         let mut t = new_sctable_internal();"}, {"sha": "64547414d07aa66b10d20b810c39f8a93f7e39c6", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/56c4ddffae4fe55814cfa525631d09f910c7a2d2/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56c4ddffae4fe55814cfa525631d09f910c7a2d2/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=56c4ddffae4fe55814cfa525631d09f910c7a2d2", "patch": "@@ -637,21 +637,3 @@ pub fn fresh_name(src: ast::Ident) -> ast::Name {\n pub fn fresh_mark() -> ast::Mrk {\n     gensym(\"mark\").0\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use ast;\n-    use ext::mtwt;\n-\n-    fn mark_ident(id : ast::Ident, m : ast::Mrk) -> ast::Ident {\n-        ast::Ident::new(id.name, mtwt::apply_mark(m, id.ctxt))\n-    }\n-\n-    #[test] fn mtwt_token_eq_test() {\n-        assert!(Gt.mtwt_eq(&Gt));\n-        let a = str_to_ident(\"bac\");\n-        let a1 = mark_ident(a,92);\n-        assert!(Ident(a).mtwt_eq(&Ident(a1)));\n-    }\n-}"}]}