{"sha": "81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "node_id": "C_kwDOAAsO6NoAKDgxNzk5Y2Q4ZmQ4NDFlMjNiNTI4NzZhZTVlMjJmYWViM2FkMDRlYjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-28T01:37:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-28T01:37:03Z"}, "message": "Auto merge of #96495 - Dylan-DPC:rollup-9lm4tpp, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #96377 (make `fn() -> _ { .. }` suggestion MachineApplicable)\n - #96397 (Make EncodeWide implement FusedIterator)\n - #96421 (Less `NoDelim`)\n - #96432 (not need `Option` for `dbg_scope`)\n - #96466 (Better error messages when collecting into `[T; n]`)\n - #96471 (replace let else with `?`)\n - #96483 (Add missing `target_feature` to the list of well known cfg names)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c71d7bc6f9a603865bdcdc32361ded0f199f686f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c71d7bc6f9a603865bdcdc32361ded0f199f686f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "html_url": "https://github.com/rust-lang/rust/commit/81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c95346b8ac8f10927b4aec31e61d45c75b10ba74", "url": "https://api.github.com/repos/rust-lang/rust/commits/c95346b8ac8f10927b4aec31e61d45c75b10ba74", "html_url": "https://github.com/rust-lang/rust/commit/c95346b8ac8f10927b4aec31e61d45c75b10ba74"}, {"sha": "89db345859a3f4e33aa334713767e79870319369", "url": "https://api.github.com/repos/rust-lang/rust/commits/89db345859a3f4e33aa334713767e79870319369", "html_url": "https://github.com/rust-lang/rust/commit/89db345859a3f4e33aa334713767e79870319369"}], "stats": {"total": 452, "additions": 243, "deletions": 209}, "files": [{"sha": "4233f7806248ba3efddf1b44415dcbc0d4a4d312", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -1542,10 +1542,10 @@ pub enum MacArgs {\n }\n \n impl MacArgs {\n-    pub fn delim(&self) -> DelimToken {\n+    pub fn delim(&self) -> Option<DelimToken> {\n         match self {\n-            MacArgs::Delimited(_, delim, _) => delim.to_token(),\n-            MacArgs::Empty | MacArgs::Eq(..) => token::NoDelim,\n+            MacArgs::Delimited(_, delim, _) => Some(delim.to_token()),\n+            MacArgs::Empty | MacArgs::Eq(..) => None,\n         }\n     }\n "}, {"sha": "39824095e86636cdfbd040a219084f735feded7a", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -464,7 +464,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 Some(MacHeader::Path(&item.path)),\n                 false,\n                 None,\n-                delim.to_token(),\n+                Some(delim.to_token()),\n                 tokens,\n                 true,\n                 span,\n@@ -530,7 +530,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     None,\n                     false,\n                     None,\n-                    *delim,\n+                    Some(*delim),\n                     tts,\n                     convert_dollar_crate,\n                     dspan.entire(),\n@@ -556,12 +556,12 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         header: Option<MacHeader<'_>>,\n         has_bang: bool,\n         ident: Option<Ident>,\n-        delim: DelimToken,\n+        delim: Option<DelimToken>,\n         tts: &TokenStream,\n         convert_dollar_crate: bool,\n         span: Span,\n     ) {\n-        if delim == DelimToken::Brace {\n+        if delim == Some(DelimToken::Brace) {\n             self.cbox(INDENT_UNIT);\n         }\n         match header {\n@@ -577,31 +577,33 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             self.print_ident(ident);\n         }\n         match delim {\n-            DelimToken::Brace => {\n+            Some(DelimToken::Brace) => {\n                 if header.is_some() || has_bang || ident.is_some() {\n                     self.nbsp();\n                 }\n                 self.word(\"{\");\n                 if !tts.is_empty() {\n                     self.space();\n                 }\n-            }\n-            _ => {\n-                let token_str = self.token_kind_to_string(&token::OpenDelim(delim));\n-                self.word(token_str)\n-            }\n-        }\n-        self.ibox(0);\n-        self.print_tts(tts, convert_dollar_crate);\n-        self.end();\n-        match delim {\n-            DelimToken::Brace => {\n+                self.ibox(0);\n+                self.print_tts(tts, convert_dollar_crate);\n+                self.end();\n                 let empty = tts.is_empty();\n                 self.bclose(span, empty);\n             }\n-            _ => {\n+            Some(delim) => {\n+                let token_str = self.token_kind_to_string(&token::OpenDelim(delim));\n+                self.word(token_str);\n+                self.ibox(0);\n+                self.print_tts(tts, convert_dollar_crate);\n+                self.end();\n                 let token_str = self.token_kind_to_string(&token::CloseDelim(delim));\n-                self.word(token_str)\n+                self.word(token_str);\n+            }\n+            None => {\n+                self.ibox(0);\n+                self.print_tts(tts, convert_dollar_crate);\n+                self.end();\n             }\n         }\n     }"}, {"sha": "99e4ded62f1a7f3ae75997b134c8677173182e76", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -20,7 +20,6 @@ pub fn compute_mir_scopes<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     instance: Instance<'tcx>,\n     mir: &Body<'tcx>,\n-    fn_dbg_scope: &'ll DIScope,\n     debug_context: &mut FunctionDebugContext<&'ll DIScope, &'ll DILocation>,\n ) {\n     // Find all scopes with variables defined in them.\n@@ -38,47 +37,49 @@ pub fn compute_mir_scopes<'ll, 'tcx>(\n         // Nothing to emit, of course.\n         None\n     };\n-\n+    let mut instantiated = BitSet::new_empty(mir.source_scopes.len());\n     // Instantiate all scopes.\n     for idx in 0..mir.source_scopes.len() {\n         let scope = SourceScope::new(idx);\n-        make_mir_scope(cx, instance, mir, fn_dbg_scope, &variables, debug_context, scope);\n+        make_mir_scope(cx, instance, mir, &variables, debug_context, &mut instantiated, scope);\n     }\n+    assert!(instantiated.count() == mir.source_scopes.len());\n }\n \n fn make_mir_scope<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     instance: Instance<'tcx>,\n     mir: &Body<'tcx>,\n-    fn_dbg_scope: &'ll DIScope,\n     variables: &Option<BitSet<SourceScope>>,\n     debug_context: &mut FunctionDebugContext<&'ll DIScope, &'ll DILocation>,\n+    instantiated: &mut BitSet<SourceScope>,\n     scope: SourceScope,\n ) {\n-    if debug_context.scopes[scope].dbg_scope.is_some() {\n+    if instantiated.contains(scope) {\n         return;\n     }\n \n     let scope_data = &mir.source_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n-        make_mir_scope(cx, instance, mir, fn_dbg_scope, variables, debug_context, parent);\n+        make_mir_scope(cx, instance, mir, variables, debug_context, instantiated, parent);\n         debug_context.scopes[parent]\n     } else {\n         // The root is the function itself.\n         let loc = cx.lookup_debug_loc(mir.span.lo());\n         debug_context.scopes[scope] = DebugScope {\n-            dbg_scope: Some(fn_dbg_scope),\n-            inlined_at: None,\n             file_start_pos: loc.file.start_pos,\n             file_end_pos: loc.file.end_pos,\n+            ..debug_context.scopes[scope]\n         };\n+        instantiated.insert(scope);\n         return;\n     };\n \n     if let Some(vars) = variables && !vars.contains(scope) && scope_data.inlined.is_none() {\n         // Do not create a DIScope if there are no variables defined in this\n         // MIR `SourceScope`, and it's not `inlined`, to avoid debuginfo bloat.\n         debug_context.scopes[scope] = parent_scope;\n+        instantiated.insert(scope);\n         return;\n     }\n \n@@ -100,7 +101,7 @@ fn make_mir_scope<'ll, 'tcx>(\n         None => unsafe {\n             llvm::LLVMRustDIBuilderCreateLexicalBlock(\n                 DIB(cx),\n-                parent_scope.dbg_scope.unwrap(),\n+                parent_scope.dbg_scope,\n                 file_metadata,\n                 loc.line,\n                 loc.col,\n@@ -116,9 +117,10 @@ fn make_mir_scope<'ll, 'tcx>(\n     });\n \n     debug_context.scopes[scope] = DebugScope {\n-        dbg_scope: Some(dbg_scope),\n+        dbg_scope,\n         inlined_at: inlined_at.or(parent_scope.inlined_at),\n         file_start_pos: loc.file.start_pos,\n         file_end_pos: loc.file.end_pos,\n     };\n+    instantiated.insert(scope);\n }"}, {"sha": "6a164557a4719ae97fac9a1bbe98610d8242d6f4", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -286,9 +286,8 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n \n         // Initialize fn debug context (including scopes).\n-        // FIXME(eddyb) figure out a way to not need `Option` for `dbg_scope`.\n         let empty_scope = DebugScope {\n-            dbg_scope: None,\n+            dbg_scope: self.dbg_scope_fn(instance, fn_abi, Some(llfn)),\n             inlined_at: None,\n             file_start_pos: BytePos(0),\n             file_end_pos: BytePos(0),\n@@ -297,13 +296,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             FunctionDebugContext { scopes: IndexVec::from_elem(empty_scope, &mir.source_scopes) };\n \n         // Fill in all the scopes, with the information from the MIR body.\n-        compute_mir_scopes(\n-            self,\n-            instance,\n-            mir,\n-            self.dbg_scope_fn(instance, fn_abi, Some(llfn)),\n-            &mut fn_debug_context,\n-        );\n+        compute_mir_scopes(self, instance, mir, &mut fn_debug_context);\n \n         Some(fn_debug_context)\n     }"}, {"sha": "f2d1827c792dbb38fda30623fb861dad8797cad7", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -39,8 +39,7 @@ pub struct PerLocalVarDebugInfo<'tcx, D> {\n \n #[derive(Clone, Copy, Debug)]\n pub struct DebugScope<S, L> {\n-    // FIXME(eddyb) this should never be `None`, after initialization.\n-    pub dbg_scope: Option<S>,\n+    pub dbg_scope: S,\n \n     /// Call site location, if this scope was inlined from another function.\n     pub inlined_at: Option<L>,\n@@ -61,17 +60,12 @@ impl<'tcx, S: Copy, L: Copy> DebugScope<S, L> {\n         cx: &Cx,\n         span: Span,\n     ) -> S {\n-        // FIXME(eddyb) this should never be `None`.\n-        let dbg_scope = self\n-            .dbg_scope\n-            .unwrap_or_else(|| bug!(\"`dbg_scope` is only `None` during initialization\"));\n-\n         let pos = span.lo();\n         if pos < self.file_start_pos || pos >= self.file_end_pos {\n             let sm = cx.sess().source_map();\n-            cx.extend_scope_to_file(dbg_scope, &sm.lookup_char_pos(pos).file)\n+            cx.extend_scope_to_file(self.dbg_scope, &sm.lookup_char_pos(pos).file)\n         } else {\n-            dbg_scope\n+            self.dbg_scope\n         }\n     }\n }"}, {"sha": "ae1b50a4176873ef2900182fa247039af2a9ecbd", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -1272,9 +1272,7 @@ pub fn parse_macro_name_and_helper_attrs(\n     // Once we've located the `#[proc_macro_derive]` attribute, verify\n     // that it's of the form `#[proc_macro_derive(Foo)]` or\n     // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n-    let Some(list) = attr.meta_item_list() else {\n-        return None;\n-    };\n+    let list = attr.meta_item_list()?;\n     if list.len() != 1 && list.len() != 2 {\n         diag.span_err(attr.span, \"attribute must have either one or two arguments\");\n         return None;"}, {"sha": "f3dcdbf93c5f14af8eb472de9f46fc983b1f535f", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -260,16 +260,15 @@ fn generic_extension<'cx, 'tt>(\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n                 sess.gated_spans.merge(gated_spans_snapshot);\n \n-                // Ignore the delimiters on the RHS.\n-                let rhs = match &rhses[i] {\n-                    mbe::TokenTree::Delimited(_, delimited) => &delimited.tts,\n+                let (rhs, rhs_span): (&mbe::Delimited, DelimSpan) = match &rhses[i] {\n+                    mbe::TokenTree::Delimited(span, delimited) => (&delimited, *span),\n                     _ => cx.span_bug(sp, \"malformed macro rhs\"),\n                 };\n                 let arm_span = rhses[i].span();\n \n-                let rhs_spans = rhs.iter().map(|t| t.span()).collect::<Vec<_>>();\n+                let rhs_spans = rhs.tts.iter().map(|t| t.span()).collect::<Vec<_>>();\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let mut tts = match transcribe(cx, &named_matches, &rhs, transparency) {\n+                let mut tts = match transcribe(cx, &named_matches, &rhs, rhs_span, transparency) {\n                     Ok(tts) => tts,\n                     Err(mut err) => {\n                         err.emit();"}, {"sha": "d5b1913e1440cb7138fc51d840a29f0bbe26ec8f", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -29,8 +29,8 @@ impl MutVisitor for Marker {\n enum Frame<'a> {\n     Delimited {\n         tts: &'a [mbe::TokenTree],\n-        delim_token: token::DelimToken,\n         idx: usize,\n+        delim_token: token::DelimToken,\n         span: DelimSpan,\n     },\n     Sequence {\n@@ -42,8 +42,8 @@ enum Frame<'a> {\n \n impl<'a> Frame<'a> {\n     /// Construct a new frame around the delimited set of tokens.\n-    fn new(tts: &'a [mbe::TokenTree]) -> Frame<'a> {\n-        Frame::Delimited { tts, delim_token: token::NoDelim, idx: 0, span: DelimSpan::dummy() }\n+    fn new(src: &'a mbe::Delimited, span: DelimSpan) -> Frame<'a> {\n+        Frame::Delimited { tts: &src.tts, idx: 0, delim_token: src.delim, span }\n     }\n }\n \n@@ -85,17 +85,18 @@ impl<'a> Iterator for Frame<'a> {\n pub(super) fn transcribe<'a>(\n     cx: &ExtCtxt<'a>,\n     interp: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n-    src: &[mbe::TokenTree],\n+    src: &mbe::Delimited,\n+    src_span: DelimSpan,\n     transparency: Transparency,\n ) -> PResult<'a, TokenStream> {\n     // Nothing for us to transcribe...\n-    if src.is_empty() {\n+    if src.tts.is_empty() {\n         return Ok(TokenStream::default());\n     }\n \n     // We descend into the RHS (`src`), expanding things as we go. This stack contains the things\n     // we have yet to expand/are still expanding. We start the stack off with the whole RHS.\n-    let mut stack: SmallVec<[Frame<'_>; 1]> = smallvec![Frame::new(&src)];\n+    let mut stack: SmallVec<[Frame<'_>; 1]> = smallvec![Frame::new(&src, src_span)];\n \n     // As we descend in the RHS, we will need to be able to match nested sequences of matchers.\n     // `repeats` keeps track of where we are in matching at each level, with the last element being"}, {"sha": "33a8d6c11ff9954e99b41d1d1afd59a3cb31e04a", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -1714,7 +1714,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     }\n \n     pub fn row(&self, row: R) -> Option<&HybridBitSet<C>> {\n-        if let Some(Some(row)) = self.rows.get(row) { Some(row) } else { None }\n+        self.rows.get(row)?.as_ref()\n     }\n \n     /// Intersects `row` with `set`. `set` can be either `BitSet` or"}, {"sha": "66d73f546afadd8ca1af93917a3c4e81f528c603", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -25,21 +25,16 @@ pub(crate) fn find_anon_type<'tcx>(\n     region: Region<'tcx>,\n     br: &ty::BoundRegionKind,\n ) -> Option<(&'tcx hir::Ty<'tcx>, &'tcx hir::FnSig<'tcx>)> {\n-    if let Some(anon_reg) = tcx.is_suitable_region(region) {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(anon_reg.def_id);\n-        let Some(fn_sig) = tcx.hir().get(hir_id).fn_sig() else {\n-            return None\n-        };\n+    let anon_reg = tcx.is_suitable_region(region)?;\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(anon_reg.def_id);\n+    let fn_sig = tcx.hir().get(hir_id).fn_sig()?;\n \n-        fn_sig\n-            .decl\n-            .inputs\n-            .iter()\n-            .find_map(|arg| find_component_for_bound_region(tcx, arg, br))\n-            .map(|ty| (ty, fn_sig))\n-    } else {\n-        None\n-    }\n+    fn_sig\n+        .decl\n+        .inputs\n+        .iter()\n+        .find_map(|arg| find_component_for_bound_region(tcx, arg, br))\n+        .map(|ty| (ty, fn_sig))\n }\n \n // This method creates a FindNestedTypeVisitor which returns the type corresponding"}, {"sha": "8c8a2650fd65790cd91a3d34d3b23d4db2e8fd43", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -3,8 +3,8 @@\n use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::TyKind::*;\n use crate::ty::{\n-    ConstKind, ExistentialPredicate, ExistentialProjection, ExistentialTraitRef, InferTy,\n-    ProjectionTy, Term, Ty, TyCtxt, TypeAndMut,\n+    ConstKind, DefIdTree, ExistentialPredicate, ExistentialProjection, ExistentialTraitRef,\n+    InferTy, ProjectionTy, Term, Ty, TyCtxt, TypeAndMut,\n };\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -74,10 +74,10 @@ impl<'tcx> Ty<'tcx> {\n     }\n \n     /// Whether the type can be safely suggested during error recovery.\n-    pub fn is_suggestable(self) -> bool {\n-        fn generic_arg_is_suggestible(arg: GenericArg<'_>) -> bool {\n+    pub fn is_suggestable(self, tcx: TyCtxt<'tcx>) -> bool {\n+        fn generic_arg_is_suggestible<'tcx>(arg: GenericArg<'tcx>, tcx: TyCtxt<'tcx>) -> bool {\n             match arg.unpack() {\n-                GenericArgKind::Type(ty) => ty.is_suggestable(),\n+                GenericArgKind::Type(ty) => ty.is_suggestable(tcx),\n                 GenericArgKind::Const(c) => const_is_suggestable(c.val()),\n                 _ => true,\n             }\n@@ -99,36 +99,46 @@ impl<'tcx> Ty<'tcx> {\n         // temporary, so I'll leave this as a fixme.\n \n         match self.kind() {\n-            Opaque(..)\n-            | FnDef(..)\n+            FnDef(..)\n             | Closure(..)\n             | Infer(..)\n             | Generator(..)\n             | GeneratorWitness(..)\n             | Bound(_, _)\n             | Placeholder(_)\n             | Error(_) => false,\n+            Opaque(did, substs) => {\n+                let parent = tcx.parent(*did).expect(\"opaque types always have a parent\");\n+                if let hir::def::DefKind::TyAlias | hir::def::DefKind::AssocTy = tcx.def_kind(parent)\n+                    && let Opaque(parent_did, _) = tcx.type_of(parent).kind()\n+                    && parent_did == did\n+                {\n+                    substs.iter().all(|a| generic_arg_is_suggestible(a, tcx))\n+                } else {\n+                    false\n+                }\n+            }\n             Dynamic(dty, _) => dty.iter().all(|pred| match pred.skip_binder() {\n                 ExistentialPredicate::Trait(ExistentialTraitRef { substs, .. }) => {\n-                    substs.iter().all(generic_arg_is_suggestible)\n+                    substs.iter().all(|a| generic_arg_is_suggestible(a, tcx))\n                 }\n                 ExistentialPredicate::Projection(ExistentialProjection {\n                     substs, term, ..\n                 }) => {\n                     let term_is_suggestable = match term {\n-                        Term::Ty(ty) => ty.is_suggestable(),\n+                        Term::Ty(ty) => ty.is_suggestable(tcx),\n                         Term::Const(c) => const_is_suggestable(c.val()),\n                     };\n-                    term_is_suggestable && substs.iter().all(generic_arg_is_suggestible)\n+                    term_is_suggestable && substs.iter().all(|a| generic_arg_is_suggestible(a, tcx))\n                 }\n                 _ => true,\n             }),\n             Projection(ProjectionTy { substs: args, .. }) | Adt(_, args) => {\n-                args.iter().all(generic_arg_is_suggestible)\n+                args.iter().all(|a| generic_arg_is_suggestible(a, tcx))\n             }\n-            Tuple(args) => args.iter().all(|ty| ty.is_suggestable()),\n-            Slice(ty) | RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => ty.is_suggestable(),\n-            Array(ty, c) => ty.is_suggestable() && const_is_suggestable(c.val()),\n+            Tuple(args) => args.iter().all(|ty| ty.is_suggestable(tcx)),\n+            Slice(ty) | RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => ty.is_suggestable(tcx),\n+            Array(ty, c) => ty.is_suggestable(tcx) && const_is_suggestable(c.val()),\n             _ => true,\n         }\n     }"}, {"sha": "33f201cbd28326bb92ff61547a2f22ef2f9db410", "filename": "compiler/rustc_mir_transform/src/early_otherwise_branch.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -336,9 +336,7 @@ fn evaluate_candidate<'tcx>(\n             Some(poss)\n         }\n     };\n-    let Some((_, child)) = targets.iter().next() else {\n-        return None\n-    };\n+    let (_, child) = targets.iter().next()?;\n     let child_terminator = &bbs[child].terminator();\n     let TerminatorKind::SwitchInt {\n         switch_ty: child_ty,"}, {"sha": "2e8e23a50eb0a6938da6dccfff1e26e790575cfe", "filename": "compiler/rustc_parse/src/lexer/unicode_chars.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -338,9 +338,7 @@ pub(super) fn check_for_substitution<'a>(\n     ch: char,\n     err: &mut Diagnostic,\n ) -> Option<token::TokenKind> {\n-    let Some(&(_u_char, u_name, ascii_char)) = UNICODE_ARRAY.iter().find(|&&(c, _, _)| c == ch) else {\n-        return None;\n-    };\n+    let &(_u_char, u_name, ascii_char) = UNICODE_ARRAY.iter().find(|&&(c, _, _)| c == ch)?;\n \n     let span = Span::with_root_ctxt(pos, pos + Pos::from_usize(ch.len_utf8()));\n "}, {"sha": "575b01180df77be00f2cac9899b732f971429863", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::tokenstream::{AttrAnnotatedTokenTree, DelimSpan, LazyTokenStream,\n use rustc_ast::{self as ast};\n use rustc_ast::{AstLike, AttrVec, Attribute};\n use rustc_errors::PResult;\n-use rustc_span::{sym, Span, DUMMY_SP};\n+use rustc_span::{sym, Span};\n \n use std::convert::TryInto;\n use std::ops::Range;\n@@ -400,24 +400,26 @@ fn make_token_stream(\n ) -> AttrAnnotatedTokenStream {\n     #[derive(Debug)]\n     struct FrameData {\n-        open: Span,\n-        open_delim: DelimToken,\n+        // This is `None` for the first frame, `Some` for all others.\n+        open_delim_sp: Option<(DelimToken, Span)>,\n         inner: Vec<(AttrAnnotatedTokenTree, Spacing)>,\n     }\n-    let mut stack =\n-        vec![FrameData { open: DUMMY_SP, open_delim: DelimToken::NoDelim, inner: vec![] }];\n+    let mut stack = vec![FrameData { open_delim_sp: None, inner: vec![] }];\n     let mut token_and_spacing = iter.next();\n     while let Some((token, spacing)) = token_and_spacing {\n         match token {\n             FlatToken::Token(Token { kind: TokenKind::OpenDelim(delim), span }) => {\n-                stack.push(FrameData { open: span, open_delim: delim, inner: vec![] });\n+                stack.push(FrameData { open_delim_sp: Some((delim, span)), inner: vec![] });\n             }\n             FlatToken::Token(Token { kind: TokenKind::CloseDelim(delim), span }) => {\n                 // HACK: If we encounter a mismatched `None` delimiter at the top\n                 // level, just ignore it.\n                 if matches!(delim, DelimToken::NoDelim)\n                     && (stack.len() == 1\n-                        || !matches!(stack.last_mut().unwrap().open_delim, DelimToken::NoDelim))\n+                        || !matches!(\n+                            stack.last_mut().unwrap().open_delim_sp.unwrap().0,\n+                            DelimToken::NoDelim\n+                        ))\n                 {\n                     token_and_spacing = iter.next();\n                     continue;\n@@ -430,7 +432,7 @@ fn make_token_stream(\n                 // merge our current frame with the one above it. That is, transform\n                 // `[ { < first second } third ]` into `[ { first second } third ]`\n                 if !matches!(delim, DelimToken::NoDelim)\n-                    && matches!(frame_data.open_delim, DelimToken::NoDelim)\n+                    && matches!(frame_data.open_delim_sp.unwrap().0, DelimToken::NoDelim)\n                 {\n                     stack.last_mut().unwrap().inner.extend(frame_data.inner);\n                     // Process our closing delimiter again, this time at the previous\n@@ -439,12 +441,13 @@ fn make_token_stream(\n                     continue;\n                 }\n \n+                let (open_delim, open_sp) = frame_data.open_delim_sp.unwrap();\n                 assert_eq!(\n-                    frame_data.open_delim, delim,\n+                    open_delim, delim,\n                     \"Mismatched open/close delims: open={:?} close={:?}\",\n-                    frame_data.open, span\n+                    open_delim, span\n                 );\n-                let dspan = DelimSpan::from_pair(frame_data.open, span);\n+                let dspan = DelimSpan::from_pair(open_sp, span);\n                 let stream = AttrAnnotatedTokenStream::new(frame_data.inner);\n                 let delimited = AttrAnnotatedTokenTree::Delimited(dspan, delim, stream);\n                 stack\n@@ -472,7 +475,7 @@ fn make_token_stream(\n     // HACK: If we don't have a closing `None` delimiter for our last\n     // frame, merge the frame with the top-level frame. That is,\n     // turn `< first second` into `first second`\n-    if stack.len() == 2 && stack[1].open_delim == DelimToken::NoDelim {\n+    if stack.len() == 2 && stack[1].open_delim_sp.unwrap().0 == DelimToken::NoDelim {\n         let temp_buf = stack.pop().unwrap();\n         stack.last_mut().unwrap().inner.extend(temp_buf.inner);\n     }"}, {"sha": "e4370809ebc24023052bbf180083e56d5965c30b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -2043,7 +2043,8 @@ impl<'a> Parser<'a> {\n             self.sess.gated_spans.gate(sym::async_closure, span);\n         }\n \n-        if self.token.kind == TokenKind::Semi && self.token_cursor.frame.delim == DelimToken::Paren\n+        if self.token.kind == TokenKind::Semi\n+            && matches!(self.token_cursor.frame.delim_sp, Some((DelimToken::Paren, _)))\n         {\n             // It is likely that the closure body is a block but where the\n             // braces have been removed. We will recover and eat the next"}, {"sha": "dfe758d0cdf019406876e2f018699dd736c7a774", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -244,14 +244,13 @@ struct TokenCursor {\n \n #[derive(Clone)]\n struct TokenCursorFrame {\n-    delim: token::DelimToken,\n-    span: DelimSpan,\n+    delim_sp: Option<(DelimToken, DelimSpan)>,\n     tree_cursor: tokenstream::Cursor,\n }\n \n impl TokenCursorFrame {\n-    fn new(span: DelimSpan, delim: DelimToken, tts: TokenStream) -> Self {\n-        TokenCursorFrame { delim, span, tree_cursor: tts.into_trees() }\n+    fn new(delim_sp: Option<(DelimToken, DelimSpan)>, tts: TokenStream) -> Self {\n+        TokenCursorFrame { delim_sp, tree_cursor: tts.into_trees() }\n     }\n }\n \n@@ -266,7 +265,7 @@ impl TokenCursor {\n         loop {\n             // FIXME: we currently don't return `NoDelim` open/close delims. To fix #67062 we will\n             // need to, whereupon the `delim != DelimToken::NoDelim` conditions below can be\n-            // removed, as well as the loop.\n+            // removed.\n             if let Some((tree, spacing)) = self.frame.tree_cursor.next_with_spacing_ref() {\n                 match tree {\n                     &TokenTree::Token(ref token) => match (desugar_doc_comments, token) {\n@@ -277,7 +276,7 @@ impl TokenCursor {\n                     },\n                     &TokenTree::Delimited(sp, delim, ref tts) => {\n                         // Set `open_delim` to true here because we deal with it immediately.\n-                        let frame = TokenCursorFrame::new(sp, delim, tts.clone());\n+                        let frame = TokenCursorFrame::new(Some((delim, sp)), tts.clone());\n                         self.stack.push(mem::replace(&mut self.frame, frame));\n                         if delim != DelimToken::NoDelim {\n                             return (Token::new(token::OpenDelim(delim), sp.open), Spacing::Alone);\n@@ -286,12 +285,11 @@ impl TokenCursor {\n                     }\n                 };\n             } else if let Some(frame) = self.stack.pop() {\n-                let delim = self.frame.delim;\n-                let span = self.frame.span;\n-                self.frame = frame;\n-                if delim != DelimToken::NoDelim {\n+                if let Some((delim, span)) = self.frame.delim_sp && delim != DelimToken::NoDelim {\n+                    self.frame = frame;\n                     return (Token::new(token::CloseDelim(delim), span.close), Spacing::Alone);\n                 }\n+                self.frame = frame;\n                 // No close delimiter to return; continue on to the next iteration.\n             } else {\n                 return (Token::new(token::Eof, DUMMY_SP), Spacing::Alone);\n@@ -330,8 +328,7 @@ impl TokenCursor {\n         self.stack.push(mem::replace(\n             &mut self.frame,\n             TokenCursorFrame::new(\n-                delim_span,\n-                token::NoDelim,\n+                None,\n                 if attr_style == AttrStyle::Inner {\n                     [TokenTree::token(token::Pound, span), TokenTree::token(token::Not, span), body]\n                         .iter()\n@@ -431,10 +428,6 @@ impl<'a> Parser<'a> {\n         desugar_doc_comments: bool,\n         subparser_name: Option<&'static str>,\n     ) -> Self {\n-        // Note: because of the way `TokenCursor::inlined_next` is structured, the `span` and\n-        // `delim` arguments here are never used.\n-        let start_frame = TokenCursorFrame::new(DelimSpan::dummy(), token::NoDelim, tokens);\n-\n         let mut parser = Parser {\n             sess,\n             token: Token::dummy(),\n@@ -444,7 +437,7 @@ impl<'a> Parser<'a> {\n             restrictions: Restrictions::empty(),\n             expected_tokens: Vec::new(),\n             token_cursor: TokenCursor {\n-                frame: start_frame,\n+                frame: TokenCursorFrame::new(None, tokens),\n                 stack: Vec::new(),\n                 num_next_calls: 0,\n                 desugar_doc_comments,\n@@ -1025,7 +1018,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let frame = &self.token_cursor.frame;\n-        if frame.delim != DelimToken::NoDelim {\n+        if let Some((delim, span)) = frame.delim_sp && delim != DelimToken::NoDelim {\n             let all_normal = (0..dist).all(|i| {\n                 let token = frame.tree_cursor.look_ahead(i);\n                 !matches!(token, Some(TokenTree::Delimited(_, DelimToken::NoDelim, _)))\n@@ -1038,7 +1031,7 @@ impl<'a> Parser<'a> {\n                             looker(&Token::new(token::OpenDelim(*delim), dspan.open))\n                         }\n                     },\n-                    None => looker(&Token::new(token::CloseDelim(frame.delim), frame.span.close)),\n+                    None => looker(&Token::new(token::CloseDelim(delim), span.close)),\n                 };\n             }\n         }\n@@ -1198,8 +1191,7 @@ impl<'a> Parser<'a> {\n                 // Grab the tokens from this frame.\n                 let frame = &self.token_cursor.frame;\n                 let stream = frame.tree_cursor.stream.clone();\n-                let span = frame.span;\n-                let delim = frame.delim;\n+                let (delim, span) = frame.delim_sp.unwrap();\n \n                 // Advance the token cursor through the entire delimited\n                 // sequence. After getting the `OpenDelim` we are *within* the"}, {"sha": "14f1208b71f516c339cf72e8e87bb238700ab153", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -164,25 +164,29 @@ impl<'a> Parser<'a> {\n         let delim = args.delim();\n         let hi = self.prev_token.span;\n \n-        let style =\n-            if delim == token::Brace { MacStmtStyle::Braces } else { MacStmtStyle::NoBraces };\n+        let style = match delim {\n+            Some(token::Brace) => MacStmtStyle::Braces,\n+            Some(_) => MacStmtStyle::NoBraces,\n+            None => unreachable!(),\n+        };\n \n         let mac = MacCall { path, args, prior_type_ascription: self.last_type_ascription };\n \n-        let kind =\n-            if (delim == token::Brace && self.token != token::Dot && self.token != token::Question)\n-                || self.token == token::Semi\n-                || self.token == token::Eof\n-            {\n-                StmtKind::MacCall(P(MacCallStmt { mac, style, attrs, tokens: None }))\n-            } else {\n-                // Since none of the above applied, this is an expression statement macro.\n-                let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac), AttrVec::new());\n-                let e = self.maybe_recover_from_bad_qpath(e, true)?;\n-                let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n-                let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                StmtKind::Expr(e)\n-            };\n+        let kind = if (style == MacStmtStyle::Braces\n+            && self.token != token::Dot\n+            && self.token != token::Question)\n+            || self.token == token::Semi\n+            || self.token == token::Eof\n+        {\n+            StmtKind::MacCall(P(MacCallStmt { mac, style, attrs, tokens: None }))\n+        } else {\n+            // Since none of the above applied, this is an expression statement macro.\n+            let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac), AttrVec::new());\n+            let e = self.maybe_recover_from_bad_qpath(e, true)?;\n+            let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n+            let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+            StmtKind::Expr(e)\n+        };\n         Ok(self.mk_stmt(lo.to(hi), kind))\n     }\n "}, {"sha": "a9edb713b0da70a677feea41b242f53ee7720b88", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -1183,9 +1183,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         ident: Symbol,\n         kind: &AssocItemKind,\n     ) -> Option<Symbol> {\n-        let Some((module, _)) = &self.current_trait_ref else {\n-            return None;\n-        };\n+        let (module, _) = self.current_trait_ref.as_ref()?;\n         if ident == kw::Underscore {\n             // We do nothing for `_`.\n             return None;"}, {"sha": "adb2b79038f66c80185c118c6a5578a957bbbe3f", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -1043,6 +1043,7 @@ impl CrateCheckConfig {\n             sym::target_has_atomic_load_store,\n             sym::target_has_atomic,\n             sym::target_has_atomic_equal_alignment,\n+            sym::target_feature,\n             sym::panic,\n             sym::sanitize,\n             sym::debug_assertions,\n@@ -1086,6 +1087,10 @@ impl CrateCheckConfig {\n             .into_iter()\n             .map(|sanitizer| Symbol::intern(sanitizer.as_str().unwrap()));\n \n+        // Unknown possible values:\n+        //  - `feature`\n+        //  - `target_feature`\n+\n         // No-values\n         for name in [\n             sym::doc,"}, {"sha": "9e9c230aebb85b2a597cf5dad201e09aa02eda42", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -217,22 +217,42 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 flags.push((sym::_Self, Some(shortname.to_owned())));\n             }\n \n+            // Slices give us `[]`, `[{ty}]`\n+            if let ty::Slice(aty) = self_ty.kind() {\n+                flags.push((sym::_Self, Some(\"[]\".to_string())));\n+                if let Some(def) = aty.ty_adt_def() {\n+                    // We also want to be able to select the slice's type's original\n+                    // signature with no type arguments resolved\n+                    let type_string = self.tcx.type_of(def.did()).to_string();\n+                    flags.push((sym::_Self, Some(format!(\"[{type_string}]\"))));\n+                }\n+                if aty.is_integral() {\n+                    flags.push((sym::_Self, Some(\"[{integral}]\".to_string())));\n+                }\n+            }\n+\n+            // Arrays give us `[]`, `[{ty}; _]` and `[{ty}; N]`\n             if let ty::Array(aty, len) = self_ty.kind() {\n-                flags.push((sym::_Self, Some(\"[]\".to_owned())));\n-                flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n+                flags.push((sym::_Self, Some(\"[]\".to_string())));\n+                let len = len.val().try_to_value().and_then(|v| v.try_to_machine_usize(self.tcx));\n+                flags.push((sym::_Self, Some(format!(\"[{}; _]\", aty))));\n+                if let Some(n) = len {\n+                    flags.push((sym::_Self, Some(format!(\"[{}; {}]\", aty, n))));\n+                }\n                 if let Some(def) = aty.ty_adt_def() {\n                     // We also want to be able to select the array's type's original\n                     // signature with no type arguments resolved\n                     let type_string = self.tcx.type_of(def.did()).to_string();\n-                    flags.push((sym::_Self, Some(format!(\"[{}]\", type_string))));\n-\n-                    let len =\n-                        len.val().try_to_value().and_then(|v| v.try_to_machine_usize(self.tcx));\n-                    let string = match len {\n-                        Some(n) => format!(\"[{}; {}]\", type_string, n),\n-                        None => format!(\"[{}; _]\", type_string),\n-                    };\n-                    flags.push((sym::_Self, Some(string)));\n+                    flags.push((sym::_Self, Some(format!(\"[{type_string}; _]\"))));\n+                    if let Some(n) = len {\n+                        flags.push((sym::_Self, Some(format!(\"[{type_string}; {n}]\"))));\n+                    }\n+                }\n+                if aty.is_integral() {\n+                    flags.push((sym::_Self, Some(\"[{integral}; _]\".to_string())));\n+                    if let Some(n) = len {\n+                        flags.push((sym::_Self, Some(format!(\"[{{integral}}; {n}]\"))));\n+                    }\n                 }\n             }\n             if let ty::Dynamic(traits, _) = self_ty.kind() {"}, {"sha": "794e711b6c83106940755fd831f3d6aed117eb2a", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -86,7 +86,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         let param_type = tcx.infer_ctxt().enter(|infcx| {\n                             infcx.resolve_numeric_literals_with_default(tcx.type_of(param.def_id))\n                         });\n-                        if param_type.is_suggestable() {\n+                        if param_type.is_suggestable(tcx) {\n                             err.span_suggestion(\n                                 tcx.def_span(src_def_id),\n                                 \"consider changing this type parameter to be a `const` generic\","}, {"sha": "3e36ffa7fe0d2f4291dfae5a032f7cb9752ca61f", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -2466,7 +2466,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     span,\n                     ty,\n                     opt_sugg: Some((span, Applicability::MachineApplicable))\n-                        .filter(|_| ty.is_suggestable()),\n+                        .filter(|_| ty.is_suggestable(tcx)),\n                 });\n \n                 ty"}, {"sha": "8feb7170983d64c091ad1de2aeb2778ebbed40b0", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -757,7 +757,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         formal_args: &[Ty<'tcx>],\n     ) -> Option<Vec<Ty<'tcx>>> {\n         let formal_ret = self.resolve_vars_with_obligations(formal_ret);\n-        let Some(ret_ty) = expected_ret.only_has_type(self) else { return None };\n+        let ret_ty = expected_ret.only_has_type(self)?;\n \n         // HACK(oli-obk): This is a hack to keep RPIT and TAIT in sync wrt their behaviour.\n         // Without it, the inference"}, {"sha": "8db9da7fcb23a67d0f47cc9b625563783699bd1b", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -525,7 +525,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.resolve_numeric_literals_with_default(self.resolve_vars_if_possible(found));\n         // Only suggest changing the return type for methods that\n         // haven't set a return type at all (and aren't `fn main()` or an impl).\n-        match (&fn_decl.output, found.is_suggestable(), can_suggest, expected.is_unit()) {\n+        match (&fn_decl.output, found.is_suggestable(self.tcx), can_suggest, expected.is_unit()) {\n             (&hir::FnRetTy::DefaultReturn(span), true, true, true) => {\n                 err.span_suggestion(\n                     span,"}, {"sha": "0ccc2b6b182c4c6ecb66b7919f38507fce125ca7", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -41,7 +41,7 @@ use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::Discr;\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, Ty, TyCtxt};\n-use rustc_middle::ty::{ReprOptions, ToPredicate, TypeFoldable};\n+use rustc_middle::ty::{ReprOptions, ToPredicate};\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -2004,28 +2004,29 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n             visitor.visit_ty(ty);\n             let mut diag = bad_placeholder(tcx, visitor.0, \"return type\");\n             let ret_ty = fn_sig.skip_binder().output();\n-            if !ret_ty.references_error() {\n-                if !ret_ty.is_closure() {\n-                    let ret_ty_str = match ret_ty.kind() {\n-                        // Suggest a function pointer return type instead of a unique function definition\n-                        // (e.g. `fn() -> i32` instead of `fn() -> i32 { f }`, the latter of which is invalid\n-                        // syntax)\n-                        ty::FnDef(..) => ret_ty.fn_sig(tcx).to_string(),\n-                        _ => ret_ty.to_string(),\n-                    };\n+            if ret_ty.is_suggestable(tcx) {\n+                diag.span_suggestion(\n+                    ty.span,\n+                    \"replace with the correct return type\",\n+                    ret_ty.to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else if matches!(ret_ty.kind(), ty::FnDef(..)) {\n+                let fn_sig = ret_ty.fn_sig(tcx);\n+                if fn_sig.skip_binder().inputs_and_output.iter().all(|t| t.is_suggestable(tcx)) {\n                     diag.span_suggestion(\n                         ty.span,\n                         \"replace with the correct return type\",\n-                        ret_ty_str,\n-                        Applicability::MaybeIncorrect,\n+                        fn_sig.to_string(),\n+                        Applicability::MachineApplicable,\n                     );\n-                } else {\n-                    // We're dealing with a closure, so we should suggest using `impl Fn` or trait bounds\n-                    // to prevent the user from getting a papercut while trying to use the unique closure\n-                    // syntax (e.g. `[closure@src/lib.rs:2:5: 2:9]`).\n-                    diag.help(\"consider using an `Fn`, `FnMut`, or `FnOnce` trait bound\");\n-                    diag.note(\"for more information on `Fn` traits and closure types, see https://doc.rust-lang.org/book/ch13-01-closures.html\");\n                 }\n+            } else if ret_ty.is_closure() {\n+                // We're dealing with a closure, so we should suggest using `impl Fn` or trait bounds\n+                // to prevent the user from getting a papercut while trying to use the unique closure\n+                // syntax (e.g. `[closure@src/lib.rs:2:5: 2:9]`).\n+                diag.help(\"consider using an `Fn`, `FnMut`, or `FnOnce` trait bound\");\n+                diag.note(\"for more information on `Fn` traits and closure types, see https://doc.rust-lang.org/book/ch13-01-closures.html\");\n             }\n             diag.emit();\n "}, {"sha": "12ca508bed2b93e5e49d494c9f7429e676c68d3b", "filename": "library/core/src/iter/traits/collect.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -96,30 +96,24 @@\n #[rustc_on_unimplemented(\n     on(\n         _Self = \"[{A}]\",\n-        message = \"a value of type `{Self}` cannot be built since `{Self}` has no definite size\",\n+        message = \"a slice of type `{Self}` cannot be built since `{Self}` has no definite size\",\n         label = \"try explicitly collecting into a `Vec<{A}>`\",\n     ),\n     on(\n-        all(\n-            A = \"{integer}\",\n-            any(\n-                _Self = \"[i8]\",\n-                _Self = \"[i16]\",\n-                _Self = \"[i32]\",\n-                _Self = \"[i64]\",\n-                _Self = \"[i128]\",\n-                _Self = \"[isize]\",\n-                _Self = \"[u8]\",\n-                _Self = \"[u16]\",\n-                _Self = \"[u32]\",\n-                _Self = \"[u64]\",\n-                _Self = \"[u128]\",\n-                _Self = \"[usize]\"\n-            )\n-        ),\n-        message = \"a value of type `{Self}` cannot be built since `{Self}` has no definite size\",\n+        all(A = \"{integer}\", any(_Self = \"[{integral}]\",)),\n+        message = \"a slice of type `{Self}` cannot be built since `{Self}` has no definite size\",\n         label = \"try explicitly collecting into a `Vec<{A}>`\",\n     ),\n+    on(\n+        _Self = \"[{A}; _]\",\n+        message = \"an array of type `{Self}` cannot be built directly from an iterator\",\n+        label = \"try collecting into a `Vec<{A}>`, then using `.try_into()`\",\n+    ),\n+    on(\n+        all(A = \"{integer}\", any(_Self = \"[{integral}; _]\",)),\n+        message = \"an array of type `{Self}` cannot be built directly from an iterator\",\n+        label = \"try collecting into a `Vec<{A}>`, then using `.try_into()`\",\n+    ),\n     message = \"a value of type `{Self}` cannot be built from an iterator \\\n                over elements of type `{A}`\",\n     label = \"value of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\""}, {"sha": "7d66973bed6f58736e13f2923ad571f6b26388cf", "filename": "library/std/src/sys_common/wtf8.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -25,7 +25,7 @@ use crate::char;\n use crate::collections::TryReserveError;\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n-use crate::iter::FromIterator;\n+use crate::iter::{FromIterator, FusedIterator};\n use crate::mem;\n use crate::ops;\n use crate::rc::Rc;\n@@ -899,6 +899,9 @@ impl<'a> Iterator for EncodeWide<'a> {\n     }\n }\n \n+#[stable(feature = \"encode_wide_fused_iterator\", since = \"1.62.0\")]\n+impl FusedIterator for EncodeWide<'_> {}\n+\n impl Hash for CodePoint {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {"}, {"sha": "476a89523a56a61dbcc9844946292142cf4cf0cb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -1305,7 +1305,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n fn maybe_expand_private_type_alias(cx: &mut DocContext<'_>, path: &hir::Path<'_>) -> Option<Type> {\n     let Res::Def(DefKind::TyAlias, def_id) = path.res else { return None };\n     // Substitute private type aliases\n-    let Some(def_id) = def_id.as_local() else { return None };\n+    let def_id = def_id.as_local()?;\n     let alias = if !cx.cache.access_levels.is_exported(def_id.to_def_id()) {\n         &cx.tcx.hir().expect_item(def_id).kind\n     } else {"}, {"sha": "a1144c8cb8c6ae72eef12533c75420e038c4eb51", "filename": "src/test/ui/iterators/collect-into-array.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    //~^ NOTE required by a bound in this\n+    let whatever: [u32; 10] = (0..10).collect();\n+    //~^ ERROR an array of type `[u32; 10]` cannot be built directly from an iterator\n+    //~| NOTE try collecting into a `Vec<{integer}>`, then using `.try_into()`\n+    //~| NOTE required by a bound in `collect`\n+}"}, {"sha": "7be53a4873bccd45d12eb78e47a3e390988d7f37", "filename": "src/test/ui/iterators/collect-into-array.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -0,0 +1,16 @@\n+error[E0277]: an array of type `[u32; 10]` cannot be built directly from an iterator\n+  --> $DIR/collect-into-array.rs:3:39\n+   |\n+LL |     let whatever: [u32; 10] = (0..10).collect();\n+   |                                       ^^^^^^^ try collecting into a `Vec<{integer}>`, then using `.try_into()`\n+   |\n+   = help: the trait `FromIterator<{integer}>` is not implemented for `[u32; 10]`\n+note: required by a bound in `collect`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `collect`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "aafa6bc8b951476245a47f487237e96baa4dc2e8", "filename": "src/test/ui/iterators/collect-into-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -6,7 +6,7 @@ fn process_slice(data: &[i32]) {\n fn main() {\n     let some_generated_vec = (0..10).collect();\n     //~^ ERROR the size for values of type `[i32]` cannot be known at compilation time\n-    //~| ERROR a value of type `[i32]` cannot be built since `[i32]` has no definite size\n+    //~| ERROR a slice of type `[i32]` cannot be built since `[i32]` has no definite size\n     //~| NOTE try explicitly collecting into a `Vec<{integer}>`\n     //~| NOTE required by a bound in `collect`\n     //~| NOTE all local variables must have a statically known size"}, {"sha": "4842e65fe976b205f05726c4ea876f55e273f460", "filename": "src/test/ui/iterators/collect-into-slice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -8,7 +8,7 @@ LL |     let some_generated_vec = (0..10).collect();\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n \n-error[E0277]: a value of type `[i32]` cannot be built since `[i32]` has no definite size\n+error[E0277]: a slice of type `[i32]` cannot be built since `[i32]` has no definite size\n   --> $DIR/collect-into-slice.rs:7:38\n    |\n LL |     let some_generated_vec = (0..10).collect();"}, {"sha": "cd724373f4d16292d6ff00cd441a7a9067b42b07", "filename": "src/tools/rustfmt/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -1325,7 +1325,7 @@ pub(crate) fn can_be_overflowed_expr(\n         }\n         ast::ExprKind::MacCall(ref mac) => {\n             match (\n-                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim()),\n+                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim().unwrap()),\n                 context.config.overflow_delimited_expr(),\n             ) {\n                 (Some(ast::MacDelimiter::Bracket), true)"}, {"sha": "92606902c57894fbed9014d1c6f5b263f99effd2", "filename": "src/tools/rustfmt/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81799cd8fd841e23b52876ae5e22faeb3ad04eb5/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs?ref=81799cd8fd841e23b52876ae5e22faeb3ad04eb5", "patch": "@@ -562,7 +562,7 @@ fn delim_token_to_str(\n                 (\"{ \", \" }\")\n             }\n         }\n-        DelimToken::NoDelim => (\"\", \"\"),\n+        DelimToken::NoDelim => unreachable!(),\n     };\n     if use_multiple_lines {\n         let indent_str = shape.indent.to_string_with_newline(context.config);"}]}