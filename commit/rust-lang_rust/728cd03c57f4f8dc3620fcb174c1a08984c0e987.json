{"sha": "728cd03c57f4f8dc3620fcb174c1a08984c0e987", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOGNkMDNjNTdmNGY4ZGMzNjIwZmNiMTc0YzFhMDg5ODRjMGU5ODc=", "commit": {"author": {"name": "Tamir Duberstein", "email": "tamird@gmail.com", "date": "2016-05-01T21:41:28Z"}, "committer": {"name": "Tamir Duberstein", "email": "tamird@gmail.com", "date": "2016-05-02T21:38:16Z"}, "message": "rustc_back: use a common musl base", "tree": {"sha": "9332073a1962fd1a63a10e7a62ce5d805f4018c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9332073a1962fd1a63a10e7a62ce5d805f4018c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/728cd03c57f4f8dc3620fcb174c1a08984c0e987", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/728cd03c57f4f8dc3620fcb174c1a08984c0e987", "html_url": "https://github.com/rust-lang/rust/commit/728cd03c57f4f8dc3620fcb174c1a08984c0e987", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/728cd03c57f4f8dc3620fcb174c1a08984c0e987/comments", "author": {"login": "tamird", "id": 1535036, "node_id": "MDQ6VXNlcjE1MzUwMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamird", "html_url": "https://github.com/tamird", "followers_url": "https://api.github.com/users/tamird/followers", "following_url": "https://api.github.com/users/tamird/following{/other_user}", "gists_url": "https://api.github.com/users/tamird/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamird/subscriptions", "organizations_url": "https://api.github.com/users/tamird/orgs", "repos_url": "https://api.github.com/users/tamird/repos", "events_url": "https://api.github.com/users/tamird/events{/privacy}", "received_events_url": "https://api.github.com/users/tamird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tamird", "id": 1535036, "node_id": "MDQ6VXNlcjE1MzUwMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamird", "html_url": "https://github.com/tamird", "followers_url": "https://api.github.com/users/tamird/followers", "following_url": "https://api.github.com/users/tamird/following{/other_user}", "gists_url": "https://api.github.com/users/tamird/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamird/subscriptions", "organizations_url": "https://api.github.com/users/tamird/orgs", "repos_url": "https://api.github.com/users/tamird/repos", "events_url": "https://api.github.com/users/tamird/events{/privacy}", "received_events_url": "https://api.github.com/users/tamird/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d80497e628945c3f11ff351030b4c62a8533e01e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d80497e628945c3f11ff351030b4c62a8533e01e", "html_url": "https://github.com/rust-lang/rust/commit/d80497e628945c3f11ff351030b4c62a8533e01e"}], "stats": {"total": 147, "additions": 74, "deletions": 73}, "files": [{"sha": "95fc0abece01bf6d29a18ee6d4d3b4a7f020a074", "filename": "src/librustc_back/target/i686_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/728cd03c57f4f8dc3620fcb174c1a08984c0e987/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728cd03c57f4f8dc3620fcb174c1a08984c0e987/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs?ref=728cd03c57f4f8dc3620fcb174c1a08984c0e987", "patch": "@@ -8,31 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// See x86_64_unknown_linux_musl for explanation of arguments\n-\n use target::Target;\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_musl_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.pre_link_args.push(\"-m32\".to_string());\n     base.pre_link_args.push(\"-Wl,-melf_i386\".to_string());\n \n-    base.pre_link_args.push(\"-nostdlib\".to_string());\n-    base.pre_link_args.push(\"-static\".to_string());\n-    base.pre_link_args.push(\"-Wl,--eh-frame-hdr\".to_string());\n-\n-    base.pre_link_args.push(\"-Wl,-(\".to_string());\n-    base.post_link_args.push(\"-Wl,-)\".to_string());\n-\n-    base.pre_link_objects_exe.push(\"crt1.o\".to_string());\n-    base.pre_link_objects_exe.push(\"crti.o\".to_string());\n-    base.post_link_objects.push(\"crtn.o\".to_string());\n-\n-    base.dynamic_linking = false;\n-    base.has_rpath = false;\n-    base.position_independent_executables = false;\n-\n     Target {\n         llvm_target: \"i686-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "d55907aeedfbc4ab08690c989fc16efa4e34d9a7", "filename": "src/librustc_back/target/linux_musl_base.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/728cd03c57f4f8dc3620fcb174c1a08984c0e987/src%2Flibrustc_back%2Ftarget%2Flinux_musl_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728cd03c57f4f8dc3620fcb174c1a08984c0e987/src%2Flibrustc_back%2Ftarget%2Flinux_musl_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_musl_base.rs?ref=728cd03c57f4f8dc3620fcb174c1a08984c0e987", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::TargetOptions;\n+\n+pub fn opts() -> TargetOptions {\n+    let mut base = super::linux_base::opts();\n+\n+    // Make sure that the linker/gcc really don't pull in anything, including\n+    // default objects, libs, etc.\n+    base.pre_link_args.push(\"-nostdlib\".to_string());\n+    base.pre_link_args.push(\"-static\".to_string());\n+\n+    // At least when this was tested, the linker would not add the\n+    // `GNU_EH_FRAME` program header to executables generated, which is required\n+    // when unwinding to locate the unwinding information. I'm not sure why this\n+    // argument is *not* necessary for normal builds, but it can't hurt!\n+    base.pre_link_args.push(\"-Wl,--eh-frame-hdr\".to_string());\n+\n+    // There's a whole bunch of circular dependencies when dealing with MUSL\n+    // unfortunately. To put this in perspective libc is statically linked to\n+    // liblibc and libunwind is statically linked to libstd:\n+    //\n+    // * libcore depends on `fmod` which is in libc (transitively in liblibc).\n+    //   liblibc, however, depends on libcore.\n+    // * compiler-rt has personality symbols that depend on libunwind, but\n+    //   libunwind is in libstd which depends on compiler-rt.\n+    //\n+    // Recall that linkers discard libraries and object files as much as\n+    // possible, and with all the static linking and archives flying around with\n+    // MUSL the linker is super aggressively stripping out objects. For example\n+    // the first case has fmod stripped from liblibc (it's in its own object\n+    // file) so it's not there when libcore needs it. In the second example all\n+    // the unused symbols from libunwind are stripped (each is in its own object\n+    // file in libstd) before we end up linking compiler-rt which depends on\n+    // those symbols.\n+    //\n+    // To deal with these circular dependencies we just force the compiler to\n+    // link everything as a group, not stripping anything out until everything\n+    // is processed. The linker will still perform a pass to strip out object\n+    // files but it won't do so until all objects/archives have been processed.\n+    base.pre_link_args.push(\"-Wl,-(\".to_string());\n+    base.post_link_args.push(\"-Wl,-)\".to_string());\n+\n+    // When generating a statically linked executable there's generally some\n+    // small setup needed which is listed in these files. These are provided by\n+    // a musl toolchain and are linked by default by the `musl-gcc` script. Note\n+    // that `gcc` also does this by default, it just uses some different files.\n+    //\n+    // Each target directory for musl has these object files included in it so\n+    // they'll be included from there.\n+    base.pre_link_objects_exe.push(\"crt1.o\".to_string());\n+    base.pre_link_objects_exe.push(\"crti.o\".to_string());\n+    base.post_link_objects.push(\"crtn.o\".to_string());\n+\n+    // MUSL support doesn't currently include dynamic linking, so there's no\n+    // need for dylibs or rpath business. Additionally `-pie` is incompatible\n+    // with `-static`, so we can't pass `-pie`.\n+    base.dynamic_linking = false;\n+    base.has_rpath = false;\n+    base.position_independent_executables = false;\n+\n+    base\n+}"}, {"sha": "739107afcbd75428d1032466d7c8d54b74ea1d85", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/728cd03c57f4f8dc3620fcb174c1a08984c0e987/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728cd03c57f4f8dc3620fcb174c1a08984c0e987/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=728cd03c57f4f8dc3620fcb174c1a08984c0e987", "patch": "@@ -56,6 +56,7 @@ mod bitrig_base;\n mod dragonfly_base;\n mod freebsd_base;\n mod linux_base;\n+mod linux_musl_base;\n mod openbsd_base;\n mod netbsd_base;\n mod solaris_base;"}, {"sha": "f8f85e5c0660967d7979369f5724506409ec6526", "filename": "src/librustc_back/target/x86_64_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 55, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/728cd03c57f4f8dc3620fcb174c1a08984c0e987/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728cd03c57f4f8dc3620fcb174c1a08984c0e987/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs?ref=728cd03c57f4f8dc3620fcb174c1a08984c0e987", "patch": "@@ -11,64 +11,10 @@\n use target::Target;\n \n pub fn target() -> Target {\n-    let mut base = super::linux_base::opts();\n+    let mut base = super::linux_musl_base::opts();\n     base.cpu = \"x86-64\".to_string();\n     base.pre_link_args.push(\"-m64\".to_string());\n \n-    // Make sure that the linker/gcc really don't pull in anything, including\n-    // default objects, libs, etc.\n-    base.pre_link_args.push(\"-nostdlib\".to_string());\n-    base.pre_link_args.push(\"-static\".to_string());\n-\n-    // At least when this was tested, the linker would not add the\n-    // `GNU_EH_FRAME` program header to executables generated, which is required\n-    // when unwinding to locate the unwinding information. I'm not sure why this\n-    // argument is *not* necessary for normal builds, but it can't hurt!\n-    base.pre_link_args.push(\"-Wl,--eh-frame-hdr\".to_string());\n-\n-    // There's a whole bunch of circular dependencies when dealing with MUSL\n-    // unfortunately. To put this in perspective libc is statically linked to\n-    // liblibc and libunwind is statically linked to libstd:\n-    //\n-    // * libcore depends on `fmod` which is in libc (transitively in liblibc).\n-    //   liblibc, however, depends on libcore.\n-    // * compiler-rt has personality symbols that depend on libunwind, but\n-    //   libunwind is in libstd which depends on compiler-rt.\n-    //\n-    // Recall that linkers discard libraries and object files as much as\n-    // possible, and with all the static linking and archives flying around with\n-    // MUSL the linker is super aggressively stripping out objects. For example\n-    // the first case has fmod stripped from liblibc (it's in its own object\n-    // file) so it's not there when libcore needs it. In the second example all\n-    // the unused symbols from libunwind are stripped (each is in its own object\n-    // file in libstd) before we end up linking compiler-rt which depends on\n-    // those symbols.\n-    //\n-    // To deal with these circular dependencies we just force the compiler to\n-    // link everything as a group, not stripping anything out until everything\n-    // is processed. The linker will still perform a pass to strip out object\n-    // files but it won't do so until all objects/archives have been processed.\n-    base.pre_link_args.push(\"-Wl,-(\".to_string());\n-    base.post_link_args.push(\"-Wl,-)\".to_string());\n-\n-    // When generating a statically linked executable there's generally some\n-    // small setup needed which is listed in these files. These are provided by\n-    // a musl toolchain and are linked by default by the `musl-gcc` script. Note\n-    // that `gcc` also does this by default, it just uses some different files.\n-    //\n-    // Each target directory for musl has these object files included in it so\n-    // they'll be included from there.\n-    base.pre_link_objects_exe.push(\"crt1.o\".to_string());\n-    base.pre_link_objects_exe.push(\"crti.o\".to_string());\n-    base.post_link_objects.push(\"crtn.o\".to_string());\n-\n-    // MUSL support doesn't currently include dynamic linking, so there's no\n-    // need for dylibs or rpath business. Additionally `-pie` is incompatible\n-    // with `-static`, so we can't pass `-pie`.\n-    base.dynamic_linking = false;\n-    base.has_rpath = false;\n-    base.position_independent_executables = false;\n-\n     Target {\n         llvm_target: \"x86_64-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),"}]}