{"sha": "368f08a65f66cdd0b26298fb86a175188d9c34bb", "node_id": "C_kwDOAAsO6NoAKDM2OGYwOGE2NWY2NmNkZDBiMjYyOThmYjg2YTE3NTE4OGQ5YzM0YmI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-20T05:08:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-20T05:08:58Z"}, "message": "Rollup merge of #100383 - fortanix:raoul/aepic_leak_mitigation, r=cuviper\n\nMitigate stale data reads on SGX platform\n\nIntel disclosed the Stale Data Read vulnerability yesterday. In order to mitigate this issue completely, reading userspace from an SGX enclave must be aligned and in 8-bytes chunks. This PR implements this mitigation\n\nReferences:\n - https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00657.html\n - https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/stale-data-read-from-xapic.html\n\ncc: ``@jethrogb``", "tree": {"sha": "e17f6897e14d6cb0fde787beeae98a124ff89e80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e17f6897e14d6cb0fde787beeae98a124ff89e80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/368f08a65f66cdd0b26298fb86a175188d9c34bb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjAGxqCRBK7hj4Ov3rIwAApmoIAEv4oHBE2rmM8OFLIToaabTX\nK58FfBbMdf8bb23USEjB0mVOxC2zPh/D0sl0N49TMJGTg68htNuI7Bj4/hzGN8AQ\nWiLx37lknoqdhezpxqnA1fSv/NmYZsEDk8gNwQj+EKsaeyA2rpXe1B+13VR8BA8N\nL1YsOER5tpZbpub0sy/m8aU4err1QKYA54LVFjMuLKQienyYzo+EkDxo7Jgix8kZ\nNajq7CToIN2VVHLCczRAy8DjMnKQpiIjJe6UqCLNDZw5sVFxiFoIo9A7LF5CLEfp\nMiFrtC60uo+dFLwu92Qabqcb1p6POOZNfkMPnovJJrdUfNuwSd2wW/B1Uy/3HMA=\n=UkhT\n-----END PGP SIGNATURE-----\n", "payload": "tree e17f6897e14d6cb0fde787beeae98a124ff89e80\nparent 3cca14093a9b2fb46c3a8deb9b48f233621066db\nparent 2a23d08aaefd60d294d63600a707575a6efcf292\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1660972138 +0200\ncommitter GitHub <noreply@github.com> 1660972138 +0200\n\nRollup merge of #100383 - fortanix:raoul/aepic_leak_mitigation, r=cuviper\n\nMitigate stale data reads on SGX platform\n\nIntel disclosed the Stale Data Read vulnerability yesterday. In order to mitigate this issue completely, reading userspace from an SGX enclave must be aligned and in 8-bytes chunks. This PR implements this mitigation\n\nReferences:\n - https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00657.html\n - https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/stale-data-read-from-xapic.html\n\ncc: ``@jethrogb``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/368f08a65f66cdd0b26298fb86a175188d9c34bb", "html_url": "https://github.com/rust-lang/rust/commit/368f08a65f66cdd0b26298fb86a175188d9c34bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/368f08a65f66cdd0b26298fb86a175188d9c34bb/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cca14093a9b2fb46c3a8deb9b48f233621066db", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cca14093a9b2fb46c3a8deb9b48f233621066db", "html_url": "https://github.com/rust-lang/rust/commit/3cca14093a9b2fb46c3a8deb9b48f233621066db"}, {"sha": "2a23d08aaefd60d294d63600a707575a6efcf292", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a23d08aaefd60d294d63600a707575a6efcf292", "html_url": "https://github.com/rust-lang/rust/commit/2a23d08aaefd60d294d63600a707575a6efcf292"}], "stats": {"total": 189, "additions": 166, "deletions": 23}, "files": [{"sha": "34634da44de67f257814a6f2c2a119d90e2fe0a2", "filename": "library/std/src/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 138, "deletions": 21, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/368f08a65f66cdd0b26298fb86a175188d9c34bb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368f08a65f66cdd0b26298fb86a175188d9c34bb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=368f08a65f66cdd0b26298fb86a175188d9c34bb", "patch": "@@ -305,6 +305,34 @@ where\n     }\n }\n \n+// Split a memory region ptr..ptr + len into three parts:\n+//   +--------+\n+//   | small0 | Chunk smaller than 8 bytes\n+//   +--------+\n+//   |   big  | Chunk 8-byte aligned, and size a multiple of 8 bytes\n+//   +--------+\n+//   | small1 | Chunk smaller than 8 bytes\n+//   +--------+\n+fn region_as_aligned_chunks(ptr: *const u8, len: usize) -> (usize, usize, usize) {\n+    let small0_size = if ptr as usize % 8 == 0 { 0 } else { 8 - ptr as usize % 8 };\n+    let small1_size = (len - small0_size as usize) % 8;\n+    let big_size = len - small0_size as usize - small1_size as usize;\n+\n+    (small0_size, big_size, small1_size)\n+}\n+\n+unsafe fn copy_quadwords(src: *const u8, dst: *mut u8, len: usize) {\n+    unsafe {\n+        asm!(\n+            \"rep movsq (%rsi), (%rdi)\",\n+            inout(\"rcx\") len / 8 => _,\n+            inout(\"rdi\") dst => _,\n+            inout(\"rsi\") src => _,\n+            options(att_syntax, nostack, preserves_flags)\n+        );\n+    }\n+}\n+\n /// Copies `len` bytes of data from enclave pointer `src` to userspace `dst`\n ///\n /// This function mitigates stale data vulnerabilities by ensuring all writes to untrusted memory are either:\n@@ -343,17 +371,6 @@ pub(crate) unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize)\n         }\n     }\n \n-    unsafe fn copy_aligned_quadwords_to_userspace(src: *const u8, dst: *mut u8, len: usize) {\n-        unsafe {\n-            asm!(\n-                \"rep movsq (%rsi), (%rdi)\",\n-                inout(\"rcx\") len / 8 => _,\n-                inout(\"rdi\") dst => _,\n-                inout(\"rsi\") src => _,\n-                options(att_syntax, nostack, preserves_flags)\n-            );\n-        }\n-    }\n     assert!(!src.is_null());\n     assert!(!dst.is_null());\n     assert!(is_enclave_range(src, len));\n@@ -370,7 +387,7 @@ pub(crate) unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize)\n     } else if len % 8 == 0 && dst as usize % 8 == 0 {\n         // Copying 8-byte aligned quadwords: copy quad word per quad word\n         unsafe {\n-            copy_aligned_quadwords_to_userspace(src, dst, len);\n+            copy_quadwords(src, dst, len);\n         }\n     } else {\n         // Split copies into three parts:\n@@ -381,20 +398,16 @@ pub(crate) unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize)\n         //   +--------+\n         //   | small1 | Chunk smaller than 8 bytes\n         //   +--------+\n+        let (small0_size, big_size, small1_size) = region_as_aligned_chunks(dst, len);\n \n         unsafe {\n             // Copy small0\n-            let small0_size = (8 - dst as usize % 8) as u8;\n-            let small0_src = src;\n-            let small0_dst = dst;\n-            copy_bytewise_to_userspace(small0_src as _, small0_dst, small0_size as _);\n+            copy_bytewise_to_userspace(src, dst, small0_size as _);\n \n             // Copy big\n-            let small1_size = ((len - small0_size as usize) % 8) as u8;\n-            let big_size = len - small0_size as usize - small1_size as usize;\n             let big_src = src.offset(small0_size as _);\n             let big_dst = dst.offset(small0_size as _);\n-            copy_aligned_quadwords_to_userspace(big_src as _, big_dst, big_size);\n+            copy_quadwords(big_src as _, big_dst, big_size);\n \n             // Copy small1\n             let small1_src = src.offset(big_size as isize + small0_size as isize);\n@@ -404,6 +417,106 @@ pub(crate) unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize)\n     }\n }\n \n+/// Copies `len` bytes of data from userspace pointer `src` to enclave pointer `dst`\n+///\n+/// This function mitigates AEPIC leak vulnerabilities by ensuring all reads from untrusted memory are 8-byte aligned\n+///\n+/// # Panics\n+/// This function panics if:\n+///\n+/// * The `src` pointer is null\n+/// * The `dst` pointer is null\n+/// * The `src` memory range is not in user memory\n+/// * The `dst` memory range is not in enclave memory\n+///\n+/// # References\n+///  - https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00657.html\n+///  - https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/stale-data-read-from-xapic.html\n+pub(crate) unsafe fn copy_from_userspace(src: *const u8, dst: *mut u8, len: usize) {\n+    // Copies memory region `src..src + len` to the enclave at `dst`. The source memory region\n+    // is:\n+    //  - strictly less than 8 bytes in size and may be\n+    //  - located at a misaligned memory location\n+    fn copy_misaligned_chunk_to_enclave(src: *const u8, dst: *mut u8, len: usize) {\n+        let mut tmp_buff = [0u8; 16];\n+\n+        unsafe {\n+            // Compute an aligned memory region to read from\n+            // +--------+ <-- aligned_src + aligned_len (8B-aligned)\n+            // |  pad1  |\n+            // +--------+ <-- src + len (misaligned)\n+            // |        |\n+            // |        |\n+            // |        |\n+            // +--------+ <-- src (misaligned)\n+            // |  pad0  |\n+            // +--------+ <-- aligned_src (8B-aligned)\n+            let pad0_size = src as usize % 8;\n+            let aligned_src = src.sub(pad0_size);\n+\n+            let pad1_size = 8 - (src.add(len) as usize % 8);\n+            let aligned_len = pad0_size + len + pad1_size;\n+\n+            debug_assert!(len < 8);\n+            debug_assert_eq!(aligned_src as usize % 8, 0);\n+            debug_assert_eq!(aligned_len % 8, 0);\n+            debug_assert!(aligned_len <= 16);\n+\n+            // Copy the aligned buffer to a temporary buffer\n+            // Note: copying from a slightly different memory location is a bit odd. In this case it\n+            // can't lead to page faults or inadvertent copying from the enclave as we only ensured\n+            // that the `src` pointer is aligned at an 8 byte boundary. As pages are 4096 bytes\n+            // aligned, `aligned_src` must be on the same page as `src`. A similar argument can be made\n+            // for `src + len`\n+            copy_quadwords(aligned_src as _, tmp_buff.as_mut_ptr(), aligned_len);\n+\n+            // Copy the correct parts of the temporary buffer to the destination\n+            ptr::copy(tmp_buff.as_ptr().add(pad0_size), dst, len);\n+        }\n+    }\n+\n+    assert!(!src.is_null());\n+    assert!(!dst.is_null());\n+    assert!(is_user_range(src, len));\n+    assert!(is_enclave_range(dst, len));\n+    assert!(!(src as usize).overflowing_add(len + 8).1);\n+    assert!(!(dst as usize).overflowing_add(len + 8).1);\n+\n+    if len < 8 {\n+        copy_misaligned_chunk_to_enclave(src, dst, len);\n+    } else if len % 8 == 0 && src as usize % 8 == 0 {\n+        // Copying 8-byte aligned quadwords: copy quad word per quad word\n+        unsafe {\n+            copy_quadwords(src, dst, len);\n+        }\n+    } else {\n+        // Split copies into three parts:\n+        //   +--------+\n+        //   | small0 | Chunk smaller than 8 bytes\n+        //   +--------+\n+        //   |   big  | Chunk 8-byte aligned, and size a multiple of 8 bytes\n+        //   +--------+\n+        //   | small1 | Chunk smaller than 8 bytes\n+        //   +--------+\n+        let (small0_size, big_size, small1_size) = region_as_aligned_chunks(dst, len);\n+\n+        unsafe {\n+            // Copy small0\n+            copy_misaligned_chunk_to_enclave(src, dst, small0_size);\n+\n+            // Copy big\n+            let big_src = src.add(small0_size);\n+            let big_dst = dst.add(small0_size);\n+            copy_quadwords(big_src, big_dst, big_size);\n+\n+            // Copy small1\n+            let small1_src = src.add(big_size + small0_size);\n+            let small1_dst = dst.add(big_size + small0_size);\n+            copy_misaligned_chunk_to_enclave(small1_src, small1_dst, small1_size);\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> UserRef<T>\n where\n@@ -468,7 +581,7 @@ where\n     pub fn copy_to_enclave(&self, dest: &mut T) {\n         unsafe {\n             assert_eq!(mem::size_of_val(dest), mem::size_of_val(&*self.0.get()));\n-            ptr::copy(\n+            copy_from_userspace(\n                 self.0.get() as *const T as *const u8,\n                 dest as *mut T as *mut u8,\n                 mem::size_of_val(dest),\n@@ -494,7 +607,11 @@ where\n {\n     /// Copies the value from user memory into enclave memory.\n     pub fn to_enclave(&self) -> T {\n-        unsafe { ptr::read(self.0.get()) }\n+        unsafe {\n+            let mut data: T = mem::MaybeUninit::uninit().assume_init();\n+            copy_from_userspace(self.0.get() as _, &mut data as *mut T as _, mem::size_of::<T>());\n+            data\n+        }\n     }\n }\n "}, {"sha": "4320f0bccd199b99b3301393508b04e56a74e0d8", "filename": "library/std/src/sys/sgx/abi/usercalls/tests.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/368f08a65f66cdd0b26298fb86a175188d9c34bb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368f08a65f66cdd0b26298fb86a175188d9c34bb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs?ref=368f08a65f66cdd0b26298fb86a175188d9c34bb", "patch": "@@ -1,8 +1,8 @@\n-use super::alloc::copy_to_userspace;\n use super::alloc::User;\n+use super::alloc::{copy_from_userspace, copy_to_userspace};\n \n #[test]\n-fn test_copy_function() {\n+fn test_copy_to_userspace_function() {\n     let mut src = [0u8; 100];\n     let mut dst = User::<[u8]>::uninitialized(100);\n \n@@ -28,3 +28,29 @@ fn test_copy_function() {\n         }\n     }\n }\n+\n+#[test]\n+fn test_copy_from_userspace_function() {\n+    let mut dst = [0u8; 100];\n+    let mut src = User::<[u8]>::uninitialized(100);\n+\n+    src.copy_from_enclave(&[0u8; 100]);\n+\n+    for size in 0..48 {\n+        // For all possible alignment\n+        for offset in 0..8 {\n+            // overwrite complete dst\n+            dst = [0u8; 100];\n+\n+            // Copy src[0..size] to dst + offset\n+            unsafe { copy_from_userspace(src.as_ptr().offset(offset), dst.as_mut_ptr(), size) };\n+\n+            // Verify copy\n+            for byte in 0..size {\n+                unsafe {\n+                    assert_eq!(dst[byte as usize], *src.as_ptr().offset(offset + byte as isize));\n+                }\n+            }\n+        }\n+    }\n+}"}]}