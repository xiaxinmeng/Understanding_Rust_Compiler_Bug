{"sha": "a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2ZjliMDQxNGNmNWJmNDlhZDdmNzE0YjlkM2ZlNWFmOTFhMTY0MDQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-02-11T14:59:58Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-02-11T14:59:58Z"}, "message": "Merge #50\n\n50: Shiny new parser r=matklad a=matklad\n\nbors r+", "tree": {"sha": "2fc1e8ccc43bbee85a06026270d7c8de5959e323", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fc1e8ccc43bbee85a06026270d7c8de5959e323"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404", "html_url": "https://github.com/rust-lang/rust/commit/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "7a0ada860b57acd44b1d53e944ae621e438652da", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0ada860b57acd44b1d53e944ae621e438652da", "html_url": "https://github.com/rust-lang/rust/commit/7a0ada860b57acd44b1d53e944ae621e438652da"}, {"sha": "f356628ad8392c6e3ffd72a9ac50a7be87d3d183", "url": "https://api.github.com/repos/rust-lang/rust/commits/f356628ad8392c6e3ffd72a9ac50a7be87d3d183", "html_url": "https://github.com/rust-lang/rust/commit/f356628ad8392c6e3ffd72a9ac50a7be87d3d183"}], "stats": {"total": 578, "additions": 330, "deletions": 248}, "files": [{"sha": "6b4434396aaa4a976b30e0f14d1708ca2233e589", "filename": "docs/ARCHITECTURE.md", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/docs%2FARCHITECTURE.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/docs%2FARCHITECTURE.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2FARCHITECTURE.md?ref=a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404", "patch": "@@ -33,19 +33,22 @@ The centerpiece of this whole endeavor is the syntax tree, in the\n \n The syntax tree is produced using a three-staged process. \n \n-First, a raw text is split into tokens with a lexer. Lexer has a\n-peculiar signature: it is an `Fn(&str) -> Token`, where token is a\n-pair of `SyntaxKind` (you should have read the `tree` module and RFC\n+First, a raw text is split into tokens with a lexer (the `lexer` module).\n+Lexer has a peculiar signature: it is an `Fn(&str) -> Token`, where token \n+is a pair of `SyntaxKind` (you should have read the `tree` module and RFC\n by this time! :)) and a len. That is, lexer chomps only the first\n token of the input. This forces the lexer to be stateless, and makes\n it possible to implement incremental relexing easily.\n \n Then, the bulk of work, the parser turns a stream of tokens into\n-stream of events. Not that parser **does not** construct a tree right\n-away. This is done for several reasons:\n+stream of events (the `parser` module; of particular interest are \n+the `parser/event` and `parser/parser` modules, which contain parsing \n+API, and the `parser/grammar` module, which contains actual parsing code\n+for various Rust syntactic constructs). Not that parser **does not** \n+construct a tree right away. This is done for several reasons:\n \n * to decouple the actual tree data structure from the parser: you can\n-  build any datastructre you want from the stream of events\n+  build any data structure you want from the stream of events\n   \n * to make parsing fast: you can produce a list of events without\n   allocations\n@@ -77,12 +80,6 @@ And at last, the TreeBuilder converts a flat stream of events into a\n tree structure. It also *should* be responsible for attaching comments\n and rebalancing the tree, but it does not do this yet :) \n \n-\n-## Error reporing\n-\n-TODO: describe how stuff like `skip_to_first` works\n-\n-\n ## Validator\n \n Parser and lexer accept a lot of *invalid* code intentionally. The"}, {"sha": "1c0905a38f3fc90534e60f1e2291fb481e77647b", "filename": "src/parser/event.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent.rs?ref=a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404", "patch": "@@ -42,7 +42,7 @@ pub(crate) enum Event {\n     ///    |\n     ///   'foo'\n     ///\n-    /// See also `CompleteMarker::precede`.\n+    /// See also `CompletedMarker::precede`.\n     Start {\n         kind: SyntaxKind,\n         forward_parent: Option<u32>,\n@@ -61,7 +61,7 @@ pub(crate) enum Event {\n     },\n \n     Error {\n-        message: String,\n+        msg: String,\n     },\n }\n \n@@ -140,9 +140,7 @@ pub(super) fn to_file(text: String, tokens: &[Token], events: Vec<Event>) -> Fil\n                 }\n                 builder.leaf(kind, len);\n             }\n-            &Event::Error { ref message } => builder.error(ErrorMsg {\n-                message: message.clone(),\n-            }),\n+            &Event::Error { ref msg } => builder.error(ErrorMsg { msg: msg.clone() }),\n         }\n     }\n     builder.finish()"}, {"sha": "3af6d13a19e0b76153be713cda7396573db35ffd", "filename": "src/parser/grammar/items/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Fgrammar%2Fitems%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Fgrammar%2Fitems%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Fitems%2Fmod.rs?ref=a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404", "patch": "@@ -94,7 +94,7 @@ fn item(p: &mut Parser) {\n \n                 // test unsafe_auto_trait\n                 // unsafe auto trait T {}\n-                IDENT if p.at_kw(\"auto\") && la == TRAIT_KW => {\n+                IDENT if p.at_contextual_kw(\"auto\") && la == TRAIT_KW => {\n                     p.bump_remap(AUTO_KW);\n                     traits::trait_item(p);\n                     TRAIT_ITEM\n@@ -109,7 +109,7 @@ fn item(p: &mut Parser) {\n \n                 // test unsafe_default_impl\n                 // unsafe default impl Foo {}\n-                IDENT if p.at_kw(\"default\") && la == IMPL_KW => {\n+                IDENT if p.at_contextual_kw(\"default\") && la == IMPL_KW => {\n                     p.bump_remap(DEFAULT_KW);\n                     traits::impl_item(p);\n                     IMPL_ITEM"}, {"sha": "ee0263203e7b78e4a79628f6480fde52d6a50284", "filename": "src/parser/grammar/mod.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Fgrammar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Fgrammar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fgrammar%2Fmod.rs?ref=a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404", "patch": "@@ -1,4 +1,28 @@\n-use super::parser::{Parser, TokenSet};\n+//! This is the actual \"grammar\" of the Rust language.\n+//!\n+//! Each function in this module and its children corresponds\n+//! to a production of the format grammar. Submodules roughly\n+//! correspond to different *areas* of the grammar. By convention,\n+//! each submodule starts with `use super::*` import and exports\n+//! \"public\" productions via `pub(super)`.\n+//!\n+//! See docs for `Parser` to learn about API, available to the grammar,\n+//! and see docs for `Event` to learn how this actually manages to\n+//! produce parse trees.\n+//!\n+//! Code in this module also contains inline tests, which start with\n+//! `// test name-of-the-test` comment and look like this:\n+//!\n+//! ```\n+//! // test fn_item_with_zero_parameters\n+//! // fn foo() {}\n+//! ```\n+//!\n+//! After adding a new inline-test, run `cargo collect-tests` to extract\n+//! it as a standalone text-fixture into `tests/data/parser/inline`, and\n+//! run `cargo test` once to create the \"gold\" value.\n+use parser::parser::Parser;\n+use parser::token_set::TokenSet;\n use SyntaxKind;\n use syntax_kinds::*;\n "}, {"sha": "3814837e11a214e2d68108fe2d619e277dfdb6f5", "filename": "src/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fmod.rs?ref=a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404", "patch": "@@ -3,19 +3,20 @@ use {File, SyntaxKind, Token};\n use syntax_kinds::*;\n \n #[macro_use]\n+mod token_set;\n mod parser;\n mod input;\n mod event;\n mod grammar;\n-use self::event::Event;\n \n /// Parse a sequence of tokens into the representative node tree\n pub fn parse(text: String, tokens: &[Token]) -> File {\n     let events = {\n         let input = input::ParserInput::new(&text, tokens);\n-        let mut parser = parser::Parser::new(&input);\n+        let parser_impl = parser::imp::ParserImpl::new(&input);\n+        let mut parser = parser::Parser(parser_impl);\n         grammar::file(&mut parser);\n-        parser.into_events()\n+        parser.0.into_events()\n     };\n     event::to_file(text, tokens, events)\n }\n@@ -26,33 +27,3 @@ fn is_insignificant(kind: SyntaxKind) -> bool {\n         _ => false,\n     }\n }\n-\n-impl<'p> parser::Parser<'p> {\n-    fn at(&self, kind: SyntaxKind) -> bool {\n-        self.current() == kind\n-    }\n-\n-    fn err_and_bump(&mut self, message: &str) {\n-        let err = self.start();\n-        self.error(message);\n-        self.bump();\n-        err.complete(self, ERROR);\n-    }\n-\n-    fn expect(&mut self, kind: SyntaxKind) -> bool {\n-        if self.at(kind) {\n-            self.bump();\n-            true\n-        } else {\n-            self.error(format!(\"expected {:?}\", kind));\n-            false\n-        }\n-    }\n-\n-    fn eat(&mut self, kind: SyntaxKind) -> bool {\n-        self.at(kind) && {\n-            self.bump();\n-            true\n-        }\n-    }\n-}"}, {"sha": "7c8e47cb6f693a09729b4f3b527330869e921e0e", "filename": "src/parser/parser.rs", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ada860b57acd44b1d53e944ae621e438652da/src%2Fparser%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ada860b57acd44b1d53e944ae621e438652da/src%2Fparser%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fparser.rs?ref=7a0ada860b57acd44b1d53e944ae621e438652da", "patch": "@@ -1,193 +0,0 @@\n-use super::Event;\n-use super::input::{InputPosition, ParserInput};\n-use SyntaxKind::{self, EOF, TOMBSTONE};\n-\n-pub(crate) struct Marker {\n-    pos: u32,\n-}\n-\n-impl Marker {\n-    pub fn complete(self, p: &mut Parser, kind: SyntaxKind) -> CompleteMarker {\n-        match self.event(p) {\n-            &mut Event::Start {\n-                kind: ref mut slot, ..\n-            } => {\n-                *slot = kind;\n-            }\n-            _ => unreachable!(),\n-        }\n-        p.event(Event::Finish);\n-        let result = CompleteMarker { pos: self.pos };\n-        ::std::mem::forget(self);\n-        result\n-    }\n-\n-    pub fn abandon(self, p: &mut Parser) {\n-        let idx = self.pos as usize;\n-        if idx == p.events.len() - 1 {\n-            match p.events.pop() {\n-                Some(Event::Start {\n-                    kind: TOMBSTONE,\n-                    forward_parent: None,\n-                }) => (),\n-                _ => unreachable!(),\n-            }\n-        }\n-        ::std::mem::forget(self);\n-    }\n-\n-    fn event<'p>(&self, p: &'p mut Parser) -> &'p mut Event {\n-        &mut p.events[self.idx()]\n-    }\n-\n-    fn idx(&self) -> usize {\n-        self.pos as usize\n-    }\n-}\n-\n-impl Drop for Marker {\n-    fn drop(&mut self) {\n-        if !::std::thread::panicking() {\n-            panic!(\"Each marker should be eithe completed or abandoned\");\n-        }\n-    }\n-}\n-\n-pub(crate) struct CompleteMarker {\n-    pos: u32,\n-}\n-\n-impl CompleteMarker {\n-    pub(crate) fn precede(self, p: &mut Parser) -> Marker {\n-        let m = p.start();\n-        match p.events[self.pos as usize] {\n-            Event::Start {\n-                ref mut forward_parent,\n-                ..\n-            } => {\n-                *forward_parent = Some(m.pos - self.pos);\n-            }\n-            _ => unreachable!(),\n-        }\n-        m\n-    }\n-}\n-\n-pub(crate) struct TokenSet {\n-    pub tokens: &'static [SyntaxKind],\n-}\n-\n-impl TokenSet {\n-    pub fn contains(&self, kind: SyntaxKind) -> bool {\n-        self.tokens.contains(&kind)\n-    }\n-}\n-\n-#[macro_export]\n-macro_rules! token_set {\n-    ($($t:ident),*) => {\n-        TokenSet {\n-            tokens: &[$($t),*],\n-        }\n-    };\n-\n-    ($($t:ident),* ,) => {\n-        token_set!($($t),*)\n-    };\n-}\n-\n-pub(crate) struct Parser<'t> {\n-    inp: &'t ParserInput<'t>,\n-\n-    pos: InputPosition,\n-    events: Vec<Event>,\n-}\n-\n-impl<'t> Parser<'t> {\n-    pub(crate) fn new(inp: &'t ParserInput<'t>) -> Parser<'t> {\n-        Parser {\n-            inp,\n-\n-            pos: InputPosition::new(),\n-            events: Vec::new(),\n-        }\n-    }\n-\n-    pub(crate) fn into_events(self) -> Vec<Event> {\n-        assert_eq!(self.current(), EOF);\n-        self.events\n-    }\n-\n-    pub(crate) fn start(&mut self) -> Marker {\n-        let m = Marker {\n-            pos: self.events.len() as u32,\n-        };\n-        self.event(Event::Start {\n-            kind: TOMBSTONE,\n-            forward_parent: None,\n-        });\n-        m\n-    }\n-\n-    pub(crate) fn error<'p, T: Into<String>>(&'p mut self, msg: T) -> ErrorBuilder<'p, 't> {\n-        ErrorBuilder::new(self, msg.into())\n-    }\n-\n-    pub(crate) fn bump(&mut self) {\n-        let kind = self.current();\n-        if kind == EOF {\n-            return;\n-        }\n-        self.pos += 1;\n-        self.event(Event::Token {\n-            kind,\n-            n_raw_tokens: 1,\n-        });\n-    }\n-\n-    pub(crate) fn bump_remap(&mut self, kind: SyntaxKind) {\n-        if self.current() == EOF {\n-            // TODO: panic!?\n-            return;\n-        }\n-        self.pos += 1;\n-        self.event(Event::Token {\n-            kind,\n-            n_raw_tokens: 1,\n-        });\n-    }\n-\n-    pub(crate) fn nth(&self, n: u32) -> SyntaxKind {\n-        self.inp.kind(self.pos + n)\n-    }\n-\n-    pub(crate) fn at_kw(&self, t: &str) -> bool {\n-        self.inp.text(self.pos) == t\n-    }\n-\n-    pub(crate) fn current(&self) -> SyntaxKind {\n-        self.nth(0)\n-    }\n-\n-    fn event(&mut self, event: Event) {\n-        self.events.push(event)\n-    }\n-}\n-\n-pub(crate) struct ErrorBuilder<'p, 't: 'p> {\n-    message: String,\n-    parser: &'p mut Parser<'t>,\n-}\n-\n-impl<'p, 't: 'p> Drop for ErrorBuilder<'p, 't> {\n-    fn drop(&mut self) {\n-        let message = ::std::mem::replace(&mut self.message, String::new());\n-        self.parser.event(Event::Error { message });\n-    }\n-}\n-\n-impl<'t, 'p> ErrorBuilder<'p, 't> {\n-    fn new(parser: &'p mut Parser<'t>, message: String) -> Self {\n-        ErrorBuilder { message, parser }\n-    }\n-}"}, {"sha": "f2641c3886e4cade1d068996e3fff037b7363fea", "filename": "src/parser/parser/imp.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Fparser%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Fparser%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fparser%2Fimp.rs?ref=a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404", "patch": "@@ -0,0 +1,119 @@\n+use parser::input::{InputPosition, ParserInput};\n+use parser::event::Event;\n+\n+use SyntaxKind;\n+use syntax_kinds::{EOF, TOMBSTONE};\n+\n+/// Implementation details of `Parser`, extracted\n+/// to a separate struct in order not to pollute\n+/// the public API of the `Parser`.\n+pub(crate) struct ParserImpl<'t> {\n+    inp: &'t ParserInput<'t>,\n+\n+    pos: InputPosition,\n+    events: Vec<Event>,\n+}\n+\n+impl<'t> ParserImpl<'t> {\n+    pub(crate) fn new(inp: &'t ParserInput<'t>) -> ParserImpl<'t> {\n+        ParserImpl {\n+            inp,\n+\n+            pos: InputPosition::new(),\n+            events: Vec::new(),\n+        }\n+    }\n+\n+    pub(crate) fn into_events(self) -> Vec<Event> {\n+        assert_eq!(self.nth(0), EOF);\n+        self.events\n+    }\n+\n+    pub(super) fn nth(&self, n: u32) -> SyntaxKind {\n+        self.inp.kind(self.pos + n)\n+    }\n+\n+    pub(super) fn at_kw(&self, t: &str) -> bool {\n+        self.inp.text(self.pos) == t\n+    }\n+\n+    pub(super) fn start(&mut self) -> u32 {\n+        let pos = self.events.len() as u32;\n+        self.event(Event::Start {\n+            kind: TOMBSTONE,\n+            forward_parent: None,\n+        });\n+        pos\n+    }\n+\n+    pub(super) fn bump(&mut self) {\n+        let kind = self.nth(0);\n+        if kind == EOF {\n+            return;\n+        }\n+        self.do_bump(kind);\n+    }\n+\n+    pub(super) fn bump_remap(&mut self, kind: SyntaxKind) {\n+        if self.nth(0) == EOF {\n+            // TODO: panic!?\n+            return;\n+        }\n+        self.do_bump(kind);\n+    }\n+\n+    fn do_bump(&mut self, kind: SyntaxKind) {\n+        self.pos += 1;\n+        self.event(Event::Token {\n+            kind,\n+            n_raw_tokens: 1,\n+        });\n+    }\n+\n+    pub(super) fn error(&mut self, msg: String) {\n+        self.event(Event::Error { msg })\n+    }\n+\n+    pub(super) fn complete(&mut self, pos: u32, kind: SyntaxKind) {\n+        match self.events[pos as usize] {\n+            Event::Start {\n+                kind: ref mut slot, ..\n+            } => {\n+                *slot = kind;\n+            }\n+            _ => unreachable!(),\n+        }\n+        self.event(Event::Finish);\n+    }\n+\n+    pub(super) fn abandon(&mut self, pos: u32) {\n+        let idx = pos as usize;\n+        if idx == self.events.len() - 1 {\n+            match self.events.pop() {\n+                Some(Event::Start {\n+                    kind: TOMBSTONE,\n+                    forward_parent: None,\n+                }) => (),\n+                _ => unreachable!(),\n+            }\n+        }\n+    }\n+\n+    pub(super) fn precede(&mut self, pos: u32) -> u32 {\n+        let new_pos = self.start();\n+        match self.events[pos as usize] {\n+            Event::Start {\n+                ref mut forward_parent,\n+                ..\n+            } => {\n+                *forward_parent = Some(new_pos - pos);\n+            }\n+            _ => unreachable!(),\n+        }\n+        new_pos\n+    }\n+\n+    fn event(&mut self, event: Event) {\n+        self.events.push(event)\n+    }\n+}"}, {"sha": "58f8207381a1b63f7b7577b6fae2015e9e362bf0", "filename": "src/parser/parser/mod.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fparser%2Fmod.rs?ref=a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404", "patch": "@@ -0,0 +1,142 @@\n+use SyntaxKind;\n+use syntax_kinds::ERROR;\n+\n+pub(super) mod imp;\n+use self::imp::ParserImpl;\n+\n+/// `Parser` struct provides the low-level API for\n+/// navigating through the stream of tokens and\n+/// constructing the parse tree. The actual parsing\n+/// happens in the `grammar` module.\n+///\n+/// However, the result of this `Parser` is not a real\n+/// tree, but rather a flat stream of events of the form\n+/// \"start expression, consume number literal,\n+/// finish expression\". See `Event` docs for more.\n+pub(crate) struct Parser<'t>(pub(super) ParserImpl<'t>);\n+\n+impl<'t> Parser<'t> {\n+    /// Returns the kind of the current token.\n+    /// If parser has already reached the end of input,\n+    /// the special `EOF` kind is returned.\n+    pub(crate) fn current(&self) -> SyntaxKind {\n+        self.nth(0)\n+    }\n+\n+    /// Lookahead operation: returns the kind of the next nth\n+    /// token.\n+    pub(crate) fn nth(&self, n: u32) -> SyntaxKind {\n+        self.0.nth(n)\n+    }\n+\n+    /// Checks if the current token is `kind`.\n+    pub(crate) fn at(&self, kind: SyntaxKind) -> bool {\n+        self.current() == kind\n+    }\n+\n+    /// Checks if the current token is contextual keyword with text `t`.\n+    pub(crate) fn at_contextual_kw(&self, t: &str) -> bool {\n+        self.0.at_kw(t)\n+    }\n+\n+    /// Starts a new node in the syntax tree. All nodes and tokens\n+    /// consumed between the `start` and the corresponding `Marker::complete`\n+    /// belong to the same node.\n+    pub(crate) fn start(&mut self) -> Marker {\n+        Marker(self.0.start())\n+    }\n+\n+    /// Advances the parser by one token.\n+    pub(crate) fn bump(&mut self) {\n+        self.0.bump();\n+    }\n+\n+    /// Advances the parser by one token, remapping its kind.\n+    /// This is useful to create contextual keywords from\n+    /// identifiers. For example, the lexer creates an `union`\n+    /// *identifier* token, but the parser remaps it to the\n+    /// `union` keyword, and keyword is what ends up in the\n+    /// final tree.\n+    pub(crate) fn bump_remap(&mut self, kind: SyntaxKind) {\n+        self.0.bump_remap(kind);\n+    }\n+\n+    /// Emit error with the `message`\n+    /// TODO: this should be much more fancy and support\n+    /// structured errors with spans and notes, like rustc\n+    /// does.\n+    pub(crate) fn error<T: Into<String>>(&mut self, message: T) {\n+        self.0.error(message.into())\n+    }\n+\n+    /// Consume the next token if it is `kind`.\n+    pub(crate) fn eat(&mut self, kind: SyntaxKind) -> bool {\n+        if !self.at(kind) {\n+            return false;\n+        }\n+        self.bump();\n+        true\n+    }\n+\n+    /// Consume the next token if it is `kind` or emit an error\n+    /// otherwise.\n+    pub(crate) fn expect(&mut self, kind: SyntaxKind) -> bool {\n+        if self.eat(kind) {\n+            return true;\n+        }\n+        self.error(format!(\"expected {:?}\", kind));\n+        false\n+    }\n+\n+    /// Create an error node and consume the next token.\n+    pub(crate) fn err_and_bump(&mut self, message: &str) {\n+        let m = self.start();\n+        self.error(message);\n+        self.bump();\n+        m.complete(self, ERROR);\n+    }\n+}\n+\n+/// See `Parser::start`.\n+pub(crate) struct Marker(u32);\n+\n+impl Marker {\n+    /// Finishes the syntax tree node and assigns `kind` to it.\n+    pub(crate) fn complete(self, p: &mut Parser, kind: SyntaxKind) -> CompletedMarker {\n+        let pos = self.0;\n+        ::std::mem::forget(self);\n+        p.0.complete(pos, kind);\n+        CompletedMarker(pos)\n+    }\n+\n+    /// Abandons the syntax tree node. All its children\n+    /// are attached to its parent instead.\n+    pub(crate) fn abandon(self, p: &mut Parser) {\n+        let pos = self.0;\n+        ::std::mem::forget(self);\n+        p.0.abandon(pos);\n+    }\n+}\n+\n+impl Drop for Marker {\n+    fn drop(&mut self) {\n+        if !::std::thread::panicking() {\n+            panic!(\"Marker must be either completed or abandoned\");\n+        }\n+    }\n+}\n+\n+pub(crate) struct CompletedMarker(u32);\n+\n+impl CompletedMarker {\n+    /// This one is tricky :-)\n+    /// This method allows to create a new node which starts\n+    /// *before* the current one. That is, parser could start\n+    /// node `A`, then complete it, and then after parsing the\n+    /// whole `A`, decide that it should have started some node\n+    /// `B` before starting `A`. `precede` allows to do exactly\n+    /// that. See also docs about `forward_parent` in `Event::Start`.\n+    pub(crate) fn precede(self, p: &mut Parser) -> Marker {\n+        Marker(p.0.precede(self.0))\n+    }\n+}"}, {"sha": "a800f200db6fe5706e40025f8bc37e69fcea0265", "filename": "src/parser/token_set.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Ftoken_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Fparser%2Ftoken_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Ftoken_set.rs?ref=a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404", "patch": "@@ -0,0 +1,24 @@\n+use SyntaxKind;\n+\n+pub(crate) struct TokenSet {\n+    pub tokens: &'static [SyntaxKind],\n+}\n+\n+impl TokenSet {\n+    pub fn contains(&self, kind: SyntaxKind) -> bool {\n+        self.tokens.contains(&kind)\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! token_set {\n+    ($($t:ident),*) => {\n+        TokenSet {\n+            tokens: &[$($t),*],\n+        }\n+    };\n+\n+    ($($t:ident),* ,) => {\n+        token_set!($($t),*)\n+    };\n+}"}, {"sha": "f831676c739ccf2fcb9007bed1a3ef102e689378", "filename": "src/tree/file_builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Ftree%2Ffile_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404/src%2Ftree%2Ffile_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftree%2Ffile_builder.rs?ref=a6f9b0414cf5bf49ad7f714b9d3fe5af91a16404", "patch": "@@ -70,7 +70,7 @@ impl Sink for FileBuilder {\n         let &(node, after_child) = self.in_progress.last().unwrap();\n         self.errors.push(SyntaxErrorData {\n             node,\n-            message: err.message,\n+            message: err.msg,\n             after_child,\n         })\n     }\n@@ -157,5 +157,5 @@ fn grow(left: &mut TextRange, right: TextRange) {\n \n #[derive(Default)]\n pub(crate) struct ErrorMsg {\n-    pub(crate) message: String,\n+    pub(crate) msg: String,\n }"}]}