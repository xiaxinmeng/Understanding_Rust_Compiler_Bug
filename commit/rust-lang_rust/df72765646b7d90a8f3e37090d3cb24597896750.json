{"sha": "df72765646b7d90a8f3e37090d3cb24597896750", "node_id": "C_kwDOAAsO6NoAKGRmNzI3NjU2NDZiN2Q5MGE4ZjNlMzcwOTBkM2NiMjQ1OTc4OTY3NTA", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2023-02-26T00:37:51Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2023-02-26T00:37:51Z"}, "message": "Implement simd_scatter", "tree": {"sha": "4e93d76c38ed3ce5ccafeb4fddf440f7b593d217", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e93d76c38ed3ce5ccafeb4fddf440f7b593d217"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df72765646b7d90a8f3e37090d3cb24597896750", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df72765646b7d90a8f3e37090d3cb24597896750", "html_url": "https://github.com/rust-lang/rust/commit/df72765646b7d90a8f3e37090d3cb24597896750", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df72765646b7d90a8f3e37090d3cb24597896750/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0898eab220ab0447a578ebaa3b5f08eabf480201", "url": "https://api.github.com/repos/rust-lang/rust/commits/0898eab220ab0447a578ebaa3b5f08eabf480201", "html_url": "https://github.com/rust-lang/rust/commit/0898eab220ab0447a578ebaa3b5f08eabf480201"}], "stats": {"total": 176, "additions": 151, "deletions": 25}, "files": [{"sha": "5ab1f9e4300ef8c1a7972d241423820eb2fb9bd8", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 151, "deletions": 25, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/df72765646b7d90a8f3e37090d3cb24597896750/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df72765646b7d90a8f3e37090d3cb24597896750/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=df72765646b7d90a8f3e37090d3cb24597896750", "patch": "@@ -519,6 +519,50 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         cx.type_vector(elem_ty, vec_len)\n     }\n \n+    fn gather<'a, 'gcc, 'tcx>(default: RValue<'gcc>, pointers: RValue<'gcc>, mask: RValue<'gcc>, pointer_count: usize, bx: &mut Builder<'a, 'gcc, 'tcx>, in_len: u64, underlying_ty: Ty<'tcx>, invert: bool) -> RValue<'gcc> {\n+        let vector_type =\n+            if pointer_count > 1 {\n+                bx.context.new_vector_type(bx.usize_type, in_len)\n+            }\n+            else {\n+                vector_ty(bx, underlying_ty, in_len)\n+            };\n+        let elem_type = vector_type.dyncast_vector().expect(\"vector type\").get_element_type();\n+\n+        let mut values = vec![];\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_long(bx.i32_type, i as i64);\n+            let int = bx.context.new_vector_access(None, pointers, index).to_rvalue();\n+\n+            let ptr_type = elem_type.make_pointer();\n+            let ptr = bx.context.new_bitcast(None, int, ptr_type);\n+            let value = ptr.dereference(None).to_rvalue();\n+            values.push(value);\n+        }\n+\n+        let vector = bx.context.new_rvalue_from_vector(None, vector_type, &values);\n+\n+        let mut mask_types = vec![];\n+        let mut mask_values = vec![];\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_long(bx.i32_type, i as i64);\n+            mask_types.push(bx.context.new_field(None, bx.i32_type, \"m\")); // TODO: choose an integer based on the size of the vector element type.\n+            let mask_value = bx.context.new_vector_access(None, mask, index).to_rvalue();\n+            let masked = bx.context.new_rvalue_from_int(bx.i32_type, in_len as i32) & mask_value;\n+            let value = index + masked;\n+            mask_values.push(value);\n+        }\n+        let mask_type = bx.context.new_struct_type(None, \"mask_type\", &mask_types);\n+        let mask = bx.context.new_struct_constructor(None, mask_type.as_type(), None, &mask_values);\n+\n+        if invert {\n+            bx.shuffle_vector(vector, default, mask)\n+        }\n+        else {\n+            bx.shuffle_vector(default, vector, mask)\n+        }\n+    }\n+\n     if name == sym::simd_gather {\n         // simd_gather(values: <N x T>, pointers: <N x *_ T>,\n         //             mask: <N x i{M}>) -> <N x T>\n@@ -616,6 +660,108 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             }\n         }\n \n+        return Ok(gather(args[0].immediate(), args[1].immediate(), args[2].immediate(), pointer_count, bx, in_len, underlying_ty, false));\n+    }\n+\n+    if name == sym::simd_scatter {\n+        // simd_scatter(values: <N x T>, pointers: <N x *mut T>,\n+        //             mask: <N x i{M}>) -> ()\n+        // * N: number of elements in the input vectors\n+        // * T: type of the element to load\n+        // * M: any integer width is supported, will be truncated to i1\n+\n+        // All types must be simd vector types\n+        require_simd!(in_ty, \"first\");\n+        require_simd!(arg_tys[1], \"second\");\n+        require_simd!(arg_tys[2], \"third\");\n+\n+        // Of the same length:\n+        let (element_len1, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (element_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == element_len1,\n+            \"expected {} argument with length {} (same as input type `{}`), \\\n+            found `{}` with length {}\",\n+            \"second\",\n+            in_len,\n+            in_ty,\n+            arg_tys[1],\n+            element_len1\n+        );\n+        require!(\n+            in_len == element_len2,\n+            \"expected {} argument with length {} (same as input type `{}`), \\\n+            found `{}` with length {}\",\n+            \"third\",\n+            in_len,\n+            in_ty,\n+            arg_tys[2],\n+            element_len2\n+        );\n+\n+        // This counts how many pointers\n+        fn ptr_count(t: Ty<'_>) -> usize {\n+            match t.kind() {\n+                ty::RawPtr(p) => 1 + ptr_count(p.ty),\n+                _ => 0,\n+            }\n+        }\n+\n+        // Non-ptr type\n+        fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n+            match t.kind() {\n+                ty::RawPtr(p) => non_ptr(p.ty),\n+                _ => t,\n+            }\n+        }\n+\n+        // The second argument must be a simd vector with an element type that's a pointer\n+        // to the element type of the first argument\n+        let (_, element_ty0) = arg_tys[0].simd_size_and_type(bx.tcx());\n+        let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        let (pointer_count, underlying_ty) = match element_ty1.kind() {\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mut => {\n+                (ptr_count(element_ty1), non_ptr(element_ty1))\n+            }\n+            _ => {\n+                require!(\n+                    false,\n+                    \"expected element type `{}` of second argument `{}` \\\n+                    to be a pointer to the element type `{}` of the first \\\n+                        argument `{}`, found `{}` != `*mut {}`\",\n+                        element_ty1,\n+                        arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        element_ty1,\n+                        in_elem\n+                );\n+                unreachable!();\n+            }\n+        };\n+        assert!(pointer_count > 0);\n+        assert_eq!(pointer_count - 1, ptr_count(element_ty0));\n+        assert_eq!(underlying_ty, non_ptr(element_ty0));\n+\n+        // The element type of the third argument must be a signed integer type of any width:\n+        match element_ty2.kind() {\n+            ty::Int(_) => (),\n+            _ => {\n+                require!(\n+                    false,\n+                    \"expected element type `{}` of third argument `{}` \\\n+                    be a signed integer type\",\n+                    element_ty2,\n+                    arg_tys[2]\n+                );\n+            }\n+        }\n+\n+        let result = gather(args[0].immediate(), args[1].immediate(), args[2].immediate(), pointer_count, bx, in_len, underlying_ty, true);\n+\n+        let pointers = args[1].immediate();\n+\n         let vector_type =\n             if pointer_count > 1 {\n                 bx.context.new_vector_type(bx.usize_type, in_len)\n@@ -625,37 +771,17 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             };\n         let elem_type = vector_type.dyncast_vector().expect(\"vector type\").get_element_type();\n \n-        let mut values = vec![];\n-        let pointers = args[1].immediate();\n         for i in 0..in_len {\n-            let index = bx.context.new_rvalue_from_long(bx.i32_type, i as i64);\n-            let int = bx.context.new_vector_access(None, pointers, index).to_rvalue();\n+            let index = bx.context.new_rvalue_from_int(bx.int_type, i as i32);\n+            let value = bx.context.new_vector_access(None, result, index);\n \n+            let int = bx.context.new_vector_access(None, pointers, index).to_rvalue();\n             let ptr_type = elem_type.make_pointer();\n-\n             let ptr = bx.context.new_bitcast(None, int, ptr_type);\n-            let value = ptr.dereference(None).to_rvalue();\n-            values.push(value);\n-        }\n-\n-        let vector = bx.context.new_rvalue_from_vector(None, vector_type, &values);\n-        let default = args[0].immediate();\n-        let mask = args[2].immediate();\n-\n-        let mut mask_types = vec![];\n-        let mut mask_values = vec![];\n-        for i in 0..in_len {\n-            let index = bx.context.new_rvalue_from_long(bx.i32_type, i as i64);\n-            mask_types.push(bx.context.new_field(None, bx.i32_type, \"m\")); // TODO: choose an integer based on the size of the vector element type.\n-            let mask_value = bx.context.new_vector_access(None, mask, index).to_rvalue();\n-            let masked = bx.context.new_rvalue_from_int(bx.i32_type, in_len as i32) & mask_value;\n-            let value = index + masked;\n-            mask_values.push(value);\n+            bx.llbb().add_assignment(None, ptr.dereference(None), value);\n         }\n-        let mask_type = bx.context.new_struct_type(None, \"mask_type\", &mask_types);\n-        let mask = bx.context.new_struct_constructor(None, mask_type.as_type(), None, &mask_values);\n \n-        return Ok(bx.shuffle_vector(default, vector, mask));\n+        return Ok(bx.context.new_rvalue_zero(bx.i32_type));\n     }\n \n     arith_binary! {"}]}