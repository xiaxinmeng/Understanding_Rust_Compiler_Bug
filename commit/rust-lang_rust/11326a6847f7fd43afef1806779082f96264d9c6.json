{"sha": "11326a6847f7fd43afef1806779082f96264d9c6", "node_id": "C_kwDOAAsO6NoAKDExMzI2YTY4NDdmN2ZkNDNhZmVmMTgwNjc3OTA4MmY5NjI2NGQ5YzY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-20T20:54:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-20T20:54:36Z"}, "message": "Merge #10387\n\n10387: Move `IdxRange` into la-arena r=Veykril a=arzg\n\nCurrently, `IdxRange` (named `IdRange`) is located in `hir_def::item_tree`, when really it isn\u2019t specific to `hir_def` and could become part of la-arena. The rename from `IdRange` to `IdxRange` is to maintain consistency with the naming convention used throughout la-arena (`Idx` instead of `Id`, `RawIdx` instead of `RawId`). This PR also adds a few new APIs to la-arena on top of `IdxRange` for convenience, namely:\r\n\r\n- indexing into an `Arena` by an `IdxRange` and getting a slice of values back\r\n- creating an `IdxRange` from an inclusive range\r\n\r\nCurrently this PR also exposes a new `Arena::next_idx` method to make constructing inclusive`IdxRange`s using `IdxRange::new` easier; however, it would in my opinion be better to remove this as it allows for easy creation of out-of-bounds `Idx`s, when `IdxRange::new_inclusive` mostly covers the same use-case while being less error-prone.\r\n\r\nI decided to bump the la-arena version to 0.3.0 from 0.2.0 because adding a new `Index` impl for `Arena` turned out to be a breaking change: I had to add a type hint in `crates/hir_def/src/body/scope.rs` when one wasn\u2019t necessary before, since rustc couldn\u2019t work out the type of a closure parameter now that there are multiple `Index` impls. I\u2019m not sure whether this is the right decision, though. \n\nCo-authored-by: Aramis Razzaghipour <aramisnoah@gmail.com>", "tree": {"sha": "6bef1446027c9d546885979764ec937b22484937", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bef1446027c9d546885979764ec937b22484937"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11326a6847f7fd43afef1806779082f96264d9c6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhcIIMCRBK7hj4Ov3rIwAAI2cIACJOgCFVbzkUVLTQ0T/clRgK\nbB+lGjWrPP3pd+P0I4NAwfemxQh1y20C5+G6p32vFJERdDlSaRijnNCkCirBVfi9\nlvxHiPcJT6Wpx2eUcGJJZpjW3UtdtNE+Il27/eLy9t0zNUZlH68iV8ICQ3nptAHd\ncGOgwcrZY2HuIdx2P9wWcpvW15BdaANXli5n1VBCTiLBdJdbQ6fdhXfB3kRzmjaF\n6Whc8j8q/zwVbqb3CCjhT+ANv5LgXi/IwST5UFj6d3nyFMnaEgJwiWRHR0lx2oPe\n/6ded3HcMW0rJKY7DgE72V3zM/vhaCIEes9Apx+mZoCOnB+oPJX6PKwEE5KHFQA=\n=2vIP\n-----END PGP SIGNATURE-----\n", "payload": "tree 6bef1446027c9d546885979764ec937b22484937\nparent d1cdfa800c78f945081b16cd9c3733bfcd133ecc\nparent dce5c640f8f4b8fa3f9eded0c115689f85250877\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1634763276 +0000\ncommitter GitHub <noreply@github.com> 1634763276 +0000\n\nMerge #10387\n\n10387: Move `IdxRange` into la-arena r=Veykril a=arzg\n\nCurrently, `IdxRange` (named `IdRange`) is located in `hir_def::item_tree`, when really it isn\u2019t specific to `hir_def` and could become part of la-arena. The rename from `IdRange` to `IdxRange` is to maintain consistency with the naming convention used throughout la-arena (`Idx` instead of `Id`, `RawIdx` instead of `RawId`). This PR also adds a few new APIs to la-arena on top of `IdxRange` for convenience, namely:\r\n\r\n- indexing into an `Arena` by an `IdxRange` and getting a slice of values back\r\n- creating an `IdxRange` from an inclusive range\r\n\r\nCurrently this PR also exposes a new `Arena::next_idx` method to make constructing inclusive`IdxRange`s using `IdxRange::new` easier; however, it would in my opinion be better to remove this as it allows for easy creation of out-of-bounds `Idx`s, when `IdxRange::new_inclusive` mostly covers the same use-case while being less error-prone.\r\n\r\nI decided to bump the la-arena version to 0.3.0 from 0.2.0 because adding a new `Index` impl for `Arena` turned out to be a breaking change: I had to add a type hint in `crates/hir_def/src/body/scope.rs` when one wasn\u2019t necessary before, since rustc couldn\u2019t work out the type of a closure parameter now that there are multiple `Index` impls. I\u2019m not sure whether this is the right decision, though. \n\nCo-authored-by: Aramis Razzaghipour <aramisnoah@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11326a6847f7fd43afef1806779082f96264d9c6", "html_url": "https://github.com/rust-lang/rust/commit/11326a6847f7fd43afef1806779082f96264d9c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11326a6847f7fd43afef1806779082f96264d9c6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1cdfa800c78f945081b16cd9c3733bfcd133ecc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1cdfa800c78f945081b16cd9c3733bfcd133ecc", "html_url": "https://github.com/rust-lang/rust/commit/d1cdfa800c78f945081b16cd9c3733bfcd133ecc"}, {"sha": "dce5c640f8f4b8fa3f9eded0c115689f85250877", "url": "https://api.github.com/repos/rust-lang/rust/commits/dce5c640f8f4b8fa3f9eded0c115689f85250877", "html_url": "https://github.com/rust-lang/rust/commit/dce5c640f8f4b8fa3f9eded0c115689f85250877"}], "stats": {"total": 213, "additions": 137, "deletions": 76}, "files": [{"sha": "6dab239d388dbd312085d640b3d893408dfef892", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11326a6847f7fd43afef1806779082f96264d9c6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/11326a6847f7fd43afef1806779082f96264d9c6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=11326a6847f7fd43afef1806779082f96264d9c6", "patch": "@@ -796,7 +796,7 @@ dependencies = [\n \n [[package]]\n name = \"la-arena\"\n-version = \"0.2.1\"\n+version = \"0.3.0\"\n \n [[package]]\n name = \"lazy_static\""}, {"sha": "8f989bc0aeff2974770d7fd05095466426ae8ff2", "filename": "crates/hir_def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fhir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fhir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2FCargo.toml?ref=11326a6847f7fd43afef1806779082f96264d9c6", "patch": "@@ -21,7 +21,7 @@ fst = { version = \"0.4\", default-features = false }\n itertools = \"0.10.0\"\n indexmap = \"1.4.0\"\n smallvec = \"1.4.0\"\n-la-arena = { version = \"0.2.0\", path = \"../../lib/arena\" }\n+la-arena = { version = \"0.3.0\", path = \"../../lib/arena\" }\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n base_db = { path = \"../base_db\", version = \"0.0.0\" }"}, {"sha": "82b23f2f4674e46a12cfe4251c23e11867478c7c", "filename": "crates/hir_def/src/body/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs?ref=11326a6847f7fd43afef1806779082f96264d9c6", "patch": "@@ -174,7 +174,7 @@ fn compute_block_scopes(\n \n fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope: ScopeId) {\n     let make_label =\n-        |label: &Option<_>| label.map(|label| (label, body.labels[label].name.clone()));\n+        |label: &Option<LabelId>| label.map(|label| (label, body.labels[label].name.clone()));\n \n     scopes.set_scope(expr, scope);\n     match &body[expr] {"}, {"sha": "73b00887e766468d21b1c5c176052f0d6fc3f519", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 6, "deletions": 56, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=11326a6847f7fd43afef1806779082f96264d9c6", "patch": "@@ -36,11 +36,10 @@ mod pretty;\n mod tests;\n \n use std::{\n-    any::type_name,\n     fmt::{self, Debug},\n     hash::{Hash, Hasher},\n     marker::PhantomData,\n-    ops::{Index, Range},\n+    ops::Index,\n     sync::Arc,\n };\n \n@@ -53,7 +52,7 @@ use hir_expand::{\n     name::{name, AsName, Name},\n     ExpandTo, HirFileId, InFile,\n };\n-use la_arena::{Arena, Idx, RawIdx};\n+use la_arena::{Arena, Idx, IdxRange, RawIdx};\n use profile::Count;\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n@@ -606,7 +605,7 @@ pub struct Function {\n     pub visibility: RawVisibilityId,\n     pub explicit_generic_params: Interned<GenericParams>,\n     pub abi: Option<Interned<str>>,\n-    pub params: IdRange<Param>,\n+    pub params: IdxRange<Param>,\n     pub ret_type: Interned<TypeRef>,\n     pub async_ret_type: Option<Interned<TypeRef>>,\n     pub ast_id: FileAstId<ast::Fn>,\n@@ -659,7 +658,7 @@ pub struct Enum {\n     pub name: Name,\n     pub visibility: RawVisibilityId,\n     pub generic_params: Interned<GenericParams>,\n-    pub variants: IdRange<Variant>,\n+    pub variants: IdxRange<Variant>,\n     pub ast_id: FileAstId<ast::Enum>,\n }\n \n@@ -947,59 +946,10 @@ pub struct Variant {\n     pub fields: Fields,\n }\n \n-/// A range of densely allocated ItemTree IDs.\n-pub struct IdRange<T> {\n-    range: Range<u32>,\n-    _p: PhantomData<T>,\n-}\n-\n-impl<T> IdRange<T> {\n-    fn new(range: Range<Idx<T>>) -> Self {\n-        Self { range: range.start.into_raw().into()..range.end.into_raw().into(), _p: PhantomData }\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.range.is_empty()\n-    }\n-}\n-\n-impl<T> Iterator for IdRange<T> {\n-    type Item = Idx<T>;\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.range.next().map(|raw| Idx::from_raw(raw.into()))\n-    }\n-}\n-\n-impl<T> DoubleEndedIterator for IdRange<T> {\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        self.range.next_back().map(|raw| Idx::from_raw(raw.into()))\n-    }\n-}\n-\n-impl<T> fmt::Debug for IdRange<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(&format!(\"IdRange::<{}>\", type_name::<T>())).field(&self.range).finish()\n-    }\n-}\n-\n-impl<T> Clone for IdRange<T> {\n-    fn clone(&self) -> Self {\n-        Self { range: self.range.clone(), _p: PhantomData }\n-    }\n-}\n-\n-impl<T> PartialEq for IdRange<T> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.range == other.range\n-    }\n-}\n-\n-impl<T> Eq for IdRange<T> {}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum Fields {\n-    Record(IdRange<Field>),\n-    Tuple(IdRange<Field>),\n+    Record(IdxRange<Field>),\n+    Tuple(IdxRange<Field>),\n     Unit,\n }\n "}, {"sha": "a15125c3d4d286b1154cae3364fad66af7d68455", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=11326a6847f7fd43afef1806779082f96264d9c6", "patch": "@@ -229,7 +229,7 @@ impl<'a> Ctx<'a> {\n         }\n     }\n \n-    fn lower_record_fields(&mut self, fields: &ast::RecordFieldList) -> IdRange<Field> {\n+    fn lower_record_fields(&mut self, fields: &ast::RecordFieldList) -> IdxRange<Field> {\n         let start = self.next_field_idx();\n         for field in fields.fields() {\n             if let Some(data) = self.lower_record_field(&field) {\n@@ -238,7 +238,7 @@ impl<'a> Ctx<'a> {\n             }\n         }\n         let end = self.next_field_idx();\n-        IdRange::new(start..end)\n+        IdxRange::new(start..end)\n     }\n \n     fn lower_record_field(&mut self, field: &ast::RecordField) -> Option<Field> {\n@@ -249,15 +249,15 @@ impl<'a> Ctx<'a> {\n         Some(res)\n     }\n \n-    fn lower_tuple_fields(&mut self, fields: &ast::TupleFieldList) -> IdRange<Field> {\n+    fn lower_tuple_fields(&mut self, fields: &ast::TupleFieldList) -> IdxRange<Field> {\n         let start = self.next_field_idx();\n         for (i, field) in fields.fields().enumerate() {\n             let data = self.lower_tuple_field(i, &field);\n             let idx = self.data().fields.alloc(data);\n             self.add_attrs(idx.into(), RawAttrs::new(self.db, &field, &self.hygiene));\n         }\n         let end = self.next_field_idx();\n-        IdRange::new(start..end)\n+        IdxRange::new(start..end)\n     }\n \n     fn lower_tuple_field(&mut self, idx: usize, field: &ast::TupleField) -> Field {\n@@ -273,7 +273,7 @@ impl<'a> Ctx<'a> {\n         let generic_params = self.lower_generic_params(GenericsOwner::Union, union);\n         let fields = match union.record_field_list() {\n             Some(record_field_list) => self.lower_fields(&StructKind::Record(record_field_list)),\n-            None => Fields::Record(IdRange::new(self.next_field_idx()..self.next_field_idx())),\n+            None => Fields::Record(IdxRange::new(self.next_field_idx()..self.next_field_idx())),\n         };\n         let ast_id = self.source_ast_id_map.ast_id(union);\n         let res = Union { name, visibility, generic_params, fields, ast_id };\n@@ -287,14 +287,14 @@ impl<'a> Ctx<'a> {\n         let variants =\n             self.with_inherited_visibility(visibility, |this| match &enum_.variant_list() {\n                 Some(variant_list) => this.lower_variants(variant_list),\n-                None => IdRange::new(this.next_variant_idx()..this.next_variant_idx()),\n+                None => IdxRange::new(this.next_variant_idx()..this.next_variant_idx()),\n             });\n         let ast_id = self.source_ast_id_map.ast_id(enum_);\n         let res = Enum { name, visibility, generic_params, variants, ast_id };\n         Some(id(self.data().enums.alloc(res)))\n     }\n \n-    fn lower_variants(&mut self, variants: &ast::VariantList) -> IdRange<Variant> {\n+    fn lower_variants(&mut self, variants: &ast::VariantList) -> IdxRange<Variant> {\n         let start = self.next_variant_idx();\n         for variant in variants.variants() {\n             if let Some(data) = self.lower_variant(&variant) {\n@@ -303,7 +303,7 @@ impl<'a> Ctx<'a> {\n             }\n         }\n         let end = self.next_variant_idx();\n-        IdRange::new(start..end)\n+        IdxRange::new(start..end)\n     }\n \n     fn lower_variant(&mut self, variant: &ast::Variant) -> Option<Variant> {\n@@ -358,7 +358,7 @@ impl<'a> Ctx<'a> {\n             }\n         }\n         let end_param = self.next_param_idx();\n-        let params = IdRange::new(start_param..end_param);\n+        let params = IdxRange::new(start_param..end_param);\n \n         let ret_type = match func.ret_type().and_then(|rt| rt.ty()) {\n             Some(type_ref) => TypeRef::from_ast(&self.body_ctx, type_ref),"}, {"sha": "b73a0c420fde013d5452cb0fa98ab704761daa02", "filename": "crates/hir_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fhir_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fhir_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2FCargo.toml?ref=11326a6847f7fd43afef1806779082f96264d9c6", "patch": "@@ -13,7 +13,7 @@ cov-mark = \"2.0.0-pre.1\"\n tracing = \"0.1\"\n either = \"1.5.3\"\n rustc-hash = \"1.0.0\"\n-la-arena = { version = \"0.2.0\", path = \"../../lib/arena\" }\n+la-arena = { version = \"0.3.0\", path = \"../../lib/arena\" }\n itertools = \"0.10.0\"\n \n base_db = { path = \"../base_db\", version = \"0.0.0\" }"}, {"sha": "d05c3ee5c3f64343466237b3e309b88a10e14ab3", "filename": "crates/hir_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fhir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fhir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2FCargo.toml?ref=11326a6847f7fd43afef1806779082f96264d9c6", "patch": "@@ -20,7 +20,7 @@ scoped-tls = \"1\"\n chalk-solve = { version = \"0.71\", default-features = false }\n chalk-ir = \"0.71\"\n chalk-recursive = { version = \"0.71\", default-features = false }\n-la-arena = { version = \"0.2.0\", path = \"../../lib/arena\" }\n+la-arena = { version = \"0.3.0\", path = \"../../lib/arena\" }\n once_cell = { version = \"1.5.0\" }\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "6014ef3e1c2c17abf5a22a8cd842544c363544d1", "filename": "crates/profile/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fprofile%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fprofile%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fprofile%2FCargo.toml?ref=11326a6847f7fd43afef1806779082f96264d9c6", "patch": "@@ -12,7 +12,7 @@ doctest = false\n once_cell = \"1.3.1\"\n cfg-if = \"1\"\n libc = \"0.2\"\n-la-arena = { version = \"0.2.0\", path = \"../../lib/arena\" }\n+la-arena = { version = \"0.3.0\", path = \"../../lib/arena\" }\n countme = { version = \"2.0.1\", features = [\"enable\"] }\n jemalloc-ctl = { version = \"0.4.1\", package = \"tikv-jemalloc-ctl\", optional = true }\n "}, {"sha": "2cba46a59b5b231546bdfbfc56c70d6175de7e98", "filename": "crates/project_model/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fproject_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/11326a6847f7fd43afef1806779082f96264d9c6/crates%2Fproject_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2FCargo.toml?ref=11326a6847f7fd43afef1806779082f96264d9c6", "patch": "@@ -17,7 +17,7 @@ serde = { version = \"1.0.106\", features = [\"derive\"] }\n serde_json = \"1.0.48\"\n anyhow = \"1.0.26\"\n expect-test = \"1.2.0-pre.1\"\n-la-arena = { version = \"0.2.0\", path = \"../../lib/arena\" }\n+la-arena = { version = \"0.3.0\", path = \"../../lib/arena\" }\n \n cfg = { path = \"../cfg\", version = \"0.0.0\" }\n base_db = { path = \"../base_db\", version = \"0.0.0\" }"}, {"sha": "23f1d9e8817ae6d8dfc578a1f141f3704cc909cc", "filename": "lib/arena/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11326a6847f7fd43afef1806779082f96264d9c6/lib%2Farena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/11326a6847f7fd43afef1806779082f96264d9c6/lib%2Farena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Farena%2FCargo.toml?ref=11326a6847f7fd43afef1806779082f96264d9c6", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"la-arena\"\n-version = \"0.2.1\"\n+version = \"0.3.0\"\n description = \"Simple index-based arena without deletion.\"\n license = \"MIT OR Apache-2.0\"\n repository = \"https://github.com/rust-analyzer/rust-analyzer\""}, {"sha": "9fe6d6062342175c6ac60320a6281a8982353858", "filename": "lib/arena/src/lib.rs", "status": "modified", "additions": 114, "deletions": 3, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/11326a6847f7fd43afef1806779082f96264d9c6/lib%2Farena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11326a6847f7fd43afef1806779082f96264d9c6/lib%2Farena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Farena%2Fsrc%2Flib.rs?ref=11326a6847f7fd43afef1806779082f96264d9c6", "patch": "@@ -7,7 +7,7 @@ use std::{\n     hash::{Hash, Hasher},\n     iter::FromIterator,\n     marker::PhantomData,\n-    ops::{Index, IndexMut},\n+    ops::{Index, IndexMut, Range, RangeInclusive},\n };\n \n mod map;\n@@ -89,6 +89,101 @@ impl<T> Idx<T> {\n     }\n }\n \n+/// A range of densely allocated arena values.\n+pub struct IdxRange<T> {\n+    range: Range<u32>,\n+    _p: PhantomData<T>,\n+}\n+\n+impl<T> IdxRange<T> {\n+    /// Creates a new index range\n+    /// inclusive of the start value and exclusive of the end value.\n+    ///\n+    /// ```\n+    /// let mut arena = la_arena::Arena::new();\n+    /// let a = arena.alloc(\"a\");\n+    /// let b = arena.alloc(\"b\");\n+    /// let c = arena.alloc(\"c\");\n+    /// let d = arena.alloc(\"d\");\n+    ///\n+    /// let range = la_arena::IdxRange::new(b..d);\n+    /// assert_eq!(&arena[range], &[\"b\", \"c\"]);\n+    /// ```\n+    pub fn new(range: Range<Idx<T>>) -> Self {\n+        Self { range: range.start.into_raw().into()..range.end.into_raw().into(), _p: PhantomData }\n+    }\n+\n+    /// Creates a new index range\n+    /// inclusive of the start value and end value.\n+    ///\n+    /// ```\n+    /// let mut arena = la_arena::Arena::new();\n+    /// let foo = arena.alloc(\"foo\");\n+    /// let bar = arena.alloc(\"bar\");\n+    /// let baz = arena.alloc(\"baz\");\n+    ///\n+    /// let range = la_arena::IdxRange::new_inclusive(foo..=baz);\n+    /// assert_eq!(&arena[range], &[\"foo\", \"bar\", \"baz\"]);\n+    ///\n+    /// let range = la_arena::IdxRange::new_inclusive(foo..=foo);\n+    /// assert_eq!(&arena[range], &[\"foo\"]);\n+    /// ```\n+    pub fn new_inclusive(range: RangeInclusive<Idx<T>>) -> Self {\n+        Self {\n+            range: u32::from(range.start().into_raw())..u32::from(range.end().into_raw()) + 1,\n+            _p: PhantomData,\n+        }\n+    }\n+\n+    /// Returns whether the index range is empty.\n+    ///\n+    /// ```\n+    /// let mut arena = la_arena::Arena::new();\n+    /// let one = arena.alloc(1);\n+    /// let two = arena.alloc(2);\n+    ///\n+    /// assert!(la_arena::IdxRange::new(one..one).is_empty());\n+    /// ```\n+    pub fn is_empty(&self) -> bool {\n+        self.range.is_empty()\n+    }\n+}\n+\n+impl<T> Iterator for IdxRange<T> {\n+    type Item = Idx<T>;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.range.next().map(|raw| Idx::from_raw(raw.into()))\n+    }\n+}\n+\n+impl<T> DoubleEndedIterator for IdxRange<T> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.range.next_back().map(|raw| Idx::from_raw(raw.into()))\n+    }\n+}\n+\n+impl<T> fmt::Debug for IdxRange<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(&format!(\"IdxRange::<{}>\", std::any::type_name::<T>()))\n+            .field(&self.range)\n+            .finish()\n+    }\n+}\n+\n+impl<T> Clone for IdxRange<T> {\n+    fn clone(&self) -> Self {\n+        Self { range: self.range.clone(), _p: PhantomData }\n+    }\n+}\n+\n+impl<T> PartialEq for IdxRange<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.range == other.range\n+    }\n+}\n+\n+impl<T> Eq for IdxRange<T> {}\n+\n /// Yet another index-based arena.\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Arena<T> {\n@@ -170,9 +265,9 @@ impl<T> Arena<T> {\n     /// assert_eq!(arena[idx], 50);\n     /// ```\n     pub fn alloc(&mut self, value: T) -> Idx<T> {\n-        let idx = RawIdx(self.data.len() as u32);\n+        let idx = self.next_idx();\n         self.data.push(value);\n-        Idx::from_raw(idx)\n+        idx\n     }\n \n     /// Returns an iterator over the arena\u2019s elements.\n@@ -221,6 +316,13 @@ impl<T> Arena<T> {\n     pub fn shrink_to_fit(&mut self) {\n         self.data.shrink_to_fit();\n     }\n+\n+    /// Returns the index of the next value allocated on the arena.\n+    ///\n+    /// This method should remain private to make creating invalid `Idx`s harder.\n+    fn next_idx(&self) -> Idx<T> {\n+        Idx::from_raw(RawIdx(self.data.len() as u32))\n+    }\n }\n \n impl<T> Default for Arena<T> {\n@@ -244,6 +346,15 @@ impl<T> IndexMut<Idx<T>> for Arena<T> {\n     }\n }\n \n+impl<T> Index<IdxRange<T>> for Arena<T> {\n+    type Output = [T];\n+    fn index(&self, range: IdxRange<T>) -> &[T] {\n+        let start = range.range.start as usize;\n+        let end = range.range.end as usize;\n+        &self.data[start..end]\n+    }\n+}\n+\n impl<T> FromIterator<T> for Arena<T> {\n     fn from_iter<I>(iter: I) -> Self\n     where"}]}