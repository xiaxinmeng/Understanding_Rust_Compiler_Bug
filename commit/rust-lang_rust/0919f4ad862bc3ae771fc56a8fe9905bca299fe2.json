{"sha": "0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MTlmNGFkODYyYmMzYWU3NzFmYzU2YThmZTk5MDViY2EyOTlmZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-31T15:28:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-31T15:28:54Z"}, "message": "Auto merge of #27414 - Gankro:tarpl-fixes, r=alexcrichton\n\nThis is *mostly* reducing *my* use of *italics* but there's some other misc changes interspersed as I went along.\r\n\r\nThis updates the italicizing alphabetically from `a` to `ra`.\r\n\r\nr? @steveklabnik", "tree": {"sha": "6a3b12bb04ee8d3b1796a5ec3e67a5d46f9a9cae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a3b12bb04ee8d3b1796a5ec3e67a5d46f9a9cae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "html_url": "https://github.com/rust-lang/rust/commit/0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "759726276733a6c63fcb9d5b0ca75128736f8539", "url": "https://api.github.com/repos/rust-lang/rust/commits/759726276733a6c63fcb9d5b0ca75128736f8539", "html_url": "https://github.com/rust-lang/rust/commit/759726276733a6c63fcb9d5b0ca75128736f8539"}, {"sha": "554efc013481b45b8336299074a86491e4ef436e", "url": "https://api.github.com/repos/rust-lang/rust/commits/554efc013481b45b8336299074a86491e4ef436e", "html_url": "https://github.com/rust-lang/rust/commit/554efc013481b45b8336299074a86491e4ef436e"}], "stats": {"total": 466, "additions": 237, "deletions": 229}, "files": [{"sha": "e4a46827f46b4a8f4c0d67485b8d8ccd7715fa68", "filename": "src/doc/tarpl/README.md", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2FREADME.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -2,38 +2,33 @@\n \n # NOTE: This is a draft document, and may contain serious errors\n \n-So you've played around with Rust a bit. You've written a few simple programs and\n-you think you grok the basics. Maybe you've even read through\n-*[The Rust Programming Language][trpl]*. Now you want to get neck-deep in all the\n+So you've played around with Rust a bit. You've written a few simple programs\n+and you think you grok the basics. Maybe you've even read through *[The Rust\n+Programming Language][trpl]* (TRPL). Now you want to get neck-deep in all the\n nitty-gritty details of the language. You want to know those weird corner-cases.\n-You want to know what the heck `unsafe` really means, and how to properly use it.\n-This is the book for you.\n+You want to know what the heck `unsafe` really means, and how to properly use\n+it. This is the book for you.\n \n-To be clear, this book goes into *serious* detail. We're going to dig into\n+To be clear, this book goes into serious detail. We're going to dig into\n exception-safety and pointer aliasing. We're going to talk about memory\n models. We're even going to do some type-theory. This is stuff that you\n-absolutely *don't* need to know to write fast and safe Rust programs.\n+absolutely don't need to know to write fast and safe Rust programs.\n You could probably close this book *right now* and still have a productive\n and happy career in Rust.\n \n-However if you intend to write unsafe code -- or just *really* want to dig into\n-the guts of the language -- this book contains *invaluable* information.\n+However if you intend to write unsafe code -- or just really want to dig into\n+the guts of the language -- this book contains invaluable information.\n \n-Unlike *The Rust Programming Language* we *will* be assuming considerable prior\n-knowledge. In particular, you should be comfortable with:\n+Unlike TRPL we will be assuming considerable prior knowledge. In particular, you\n+should be comfortable with basic systems programming and basic Rust. If you\n+don't feel comfortable with these topics, you should consider [reading\n+TRPL][trpl], though we will not be assuming that you have. You can skip\n+straight to this book if you want; just know that we won't be explaining\n+everything from the ground up.\n \n-* Basic Systems Programming:\n-    * Pointers\n-    * [The stack and heap][]\n-    * The memory hierarchy (caches)\n-    * Threads\n-\n-* [Basic Rust][]\n-\n-Due to the nature of advanced Rust programming, we will be spending a lot of time\n-talking about *safety* and *guarantees*. In particular, a significant portion of\n-the book will be dedicated to correctly writing and understanding Unsafe Rust.\n+Due to the nature of advanced Rust programming, we will be spending a lot of\n+time talking about *safety* and *guarantees*. In particular, a significant\n+portion of the book will be dedicated to correctly writing and understanding\n+Unsafe Rust.\n \n [trpl]: ../book/\n-[The stack and heap]: ../book/the-stack-and-the-heap.html\n-[Basic Rust]: ../book/syntax-and-semantics.html"}, {"sha": "7d4ef9c25148c48ab432aa46bd61349a345333d0", "filename": "src/doc/tarpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2FSUMMARY.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -10,7 +10,7 @@\n * [Ownership](ownership.md)\n \t* [References](references.md)\n \t* [Lifetimes](lifetimes.md)\n-\t* [Limits of lifetimes](lifetime-mismatch.md)\n+\t* [Limits of Lifetimes](lifetime-mismatch.md)\n \t* [Lifetime Elision](lifetime-elision.md)\n \t* [Unbounded Lifetimes](unbounded-lifetimes.md)\n \t* [Higher-Rank Trait Bounds](hrtb.md)"}, {"sha": "2d567e39f8fda66a51cca49d9db2ac662c3d2409", "filename": "src/doc/tarpl/atomics.md", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fatomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fatomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fatomics.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -17,7 +17,7 @@ face.\n The C11 memory model is fundamentally about trying to bridge the gap between the\n semantics we want, the optimizations compilers want, and the inconsistent chaos\n our hardware wants. *We* would like to just write programs and have them do\n-exactly what we said but, you know, *fast*. Wouldn't that be great?\n+exactly what we said but, you know, fast. Wouldn't that be great?\n \n \n \n@@ -35,20 +35,20 @@ y = 3;\n x = 2;\n ```\n \n-The compiler may conclude that it would *really* be best if your program did\n+The compiler may conclude that it would be best if your program did\n \n ```rust,ignore\n x = 2;\n y = 3;\n ```\n \n-This has inverted the order of events *and* completely eliminated one event.\n+This has inverted the order of events and completely eliminated one event.\n From a single-threaded perspective this is completely unobservable: after all\n the statements have executed we are in exactly the same state. But if our\n-program is multi-threaded, we may have been relying on `x` to *actually* be\n-assigned to 1 before `y` was assigned. We would *really* like the compiler to be\n+program is multi-threaded, we may have been relying on `x` to actually be\n+assigned to 1 before `y` was assigned. We would like the compiler to be\n able to make these kinds of optimizations, because they can seriously improve\n-performance. On the other hand, we'd really like to be able to depend on our\n+performance. On the other hand, we'd also like to be able to depend on our\n program *doing the thing we said*.\n \n \n@@ -57,15 +57,15 @@ program *doing the thing we said*.\n # Hardware Reordering\n \n On the other hand, even if the compiler totally understood what we wanted and\n-respected our wishes, our *hardware* might instead get us in trouble. Trouble\n+respected our wishes, our hardware might instead get us in trouble. Trouble\n comes from CPUs in the form of memory hierarchies. There is indeed a global\n shared memory space somewhere in your hardware, but from the perspective of each\n CPU core it is *so very far away* and *so very slow*. Each CPU would rather work\n-with its local cache of the data and only go through all the *anguish* of\n-talking to shared memory *only* when it doesn't actually have that memory in\n+with its local cache of the data and only go through all the anguish of\n+talking to shared memory only when it doesn't actually have that memory in\n cache.\n \n-After all, that's the whole *point* of the cache, right? If every read from the\n+After all, that's the whole point of the cache, right? If every read from the\n cache had to run back to shared memory to double check that it hadn't changed,\n what would the point be? The end result is that the hardware doesn't guarantee\n that events that occur in the same order on *one* thread, occur in the same\n@@ -99,13 +99,13 @@ provides weak ordering guarantees. This has two consequences for concurrent\n programming:\n \n * Asking for stronger guarantees on strongly-ordered hardware may be cheap or\n-  even *free* because they already provide strong guarantees unconditionally.\n+  even free because they already provide strong guarantees unconditionally.\n   Weaker guarantees may only yield performance wins on weakly-ordered hardware.\n \n-* Asking for guarantees that are *too* weak on strongly-ordered hardware   is\n+* Asking for guarantees that are too weak on strongly-ordered hardware is\n   more likely to *happen* to work, even though your program is strictly\n-  incorrect. If possible, concurrent algorithms should be tested on   weakly-\n-  ordered hardware.\n+  incorrect. If possible, concurrent algorithms should be tested on\n+  weakly-ordered hardware.\n \n \n \n@@ -115,10 +115,10 @@ programming:\n \n The C11 memory model attempts to bridge the gap by allowing us to talk about the\n *causality* of our program. Generally, this is by establishing a *happens\n-before* relationships between parts of the program and the threads that are\n+before* relationship between parts of the program and the threads that are\n running them. This gives the hardware and compiler room to optimize the program\n more aggressively where a strict happens-before relationship isn't established,\n-but forces them to be more careful where one *is* established. The way we\n+but forces them to be more careful where one is established. The way we\n communicate these relationships are through *data accesses* and *atomic\n accesses*.\n \n@@ -130,8 +130,10 @@ propagate the changes made in data accesses to other threads as lazily and\n inconsistently as it wants. Mostly critically, data accesses are how data races\n happen. Data accesses are very friendly to the hardware and compiler, but as\n we've seen they offer *awful* semantics to try to write synchronized code with.\n-Actually, that's too weak. *It is literally impossible to write correct\n-synchronized code using only data accesses*.\n+Actually, that's too weak.\n+\n+**It is literally impossible to write correct synchronized code using only data\n+accesses.**\n \n Atomic accesses are how we tell the hardware and compiler that our program is\n multi-threaded. Each atomic access can be marked with an *ordering* that\n@@ -141,7 +143,10 @@ they *can't* do. For the compiler, this largely revolves around re-ordering of\n instructions. For the hardware, this largely revolves around how writes are\n propagated to other threads. The set of orderings Rust exposes are:\n \n-* Sequentially Consistent (SeqCst) Release Acquire Relaxed\n+* Sequentially Consistent (SeqCst)\n+* Release\n+* Acquire\n+* Relaxed\n \n (Note: We explicitly do not expose the C11 *consume* ordering)\n \n@@ -154,13 +159,13 @@ synchronize\"\n \n Sequentially Consistent is the most powerful of all, implying the restrictions\n of all other orderings. Intuitively, a sequentially consistent operation\n-*cannot* be reordered: all accesses on one thread that happen before and after a\n-SeqCst access *stay* before and after it. A data-race-free program that uses\n+cannot be reordered: all accesses on one thread that happen before and after a\n+SeqCst access stay before and after it. A data-race-free program that uses\n only sequentially consistent atomics and data accesses has the very nice\n property that there is a single global execution of the program's instructions\n that all threads agree on. This execution is also particularly nice to reason\n about: it's just an interleaving of each thread's individual executions. This\n-*does not* hold if you start using the weaker atomic orderings.\n+does not hold if you start using the weaker atomic orderings.\n \n The relative developer-friendliness of sequential consistency doesn't come for\n free. Even on strongly-ordered platforms sequential consistency involves\n@@ -170,8 +175,8 @@ In practice, sequential consistency is rarely necessary for program correctness.\n However sequential consistency is definitely the right choice if you're not\n confident about the other memory orders. Having your program run a bit slower\n than it needs to is certainly better than it running incorrectly! It's also\n-*mechanically* trivial to downgrade atomic operations to have a weaker\n-consistency later on. Just change `SeqCst` to e.g. `Relaxed` and you're done! Of\n+mechanically trivial to downgrade atomic operations to have a weaker\n+consistency later on. Just change `SeqCst` to `Relaxed` and you're done! Of\n course, proving that this transformation is *correct* is a whole other matter.\n \n \n@@ -183,15 +188,15 @@ Acquire and Release are largely intended to be paired. Their names hint at their\n use case: they're perfectly suited for acquiring and releasing locks, and\n ensuring that critical sections don't overlap.\n \n-Intuitively, an acquire access ensures that every access after it *stays* after\n+Intuitively, an acquire access ensures that every access after it stays after\n it. However operations that occur before an acquire are free to be reordered to\n occur after it. Similarly, a release access ensures that every access before it\n-*stays* before it. However operations that occur after a release are free to be\n+stays before it. However operations that occur after a release are free to be\n reordered to occur before it.\n \n When thread A releases a location in memory and then thread B subsequently\n acquires *the same* location in memory, causality is established. Every write\n-that happened *before* A's release will be observed by B *after* its release.\n+that happened before A's release will be observed by B after its release.\n However no causality is established with any other threads. Similarly, no\n causality is established if A and B access *different* locations in memory.\n \n@@ -230,7 +235,7 @@ weakly-ordered platforms.\n # Relaxed\n \n Relaxed accesses are the absolute weakest. They can be freely re-ordered and\n-provide no happens-before relationship. Still, relaxed operations *are* still\n+provide no happens-before relationship. Still, relaxed operations are still\n atomic. That is, they don't count as data accesses and any read-modify-write\n operations done to them occur atomically. Relaxed operations are appropriate for\n things that you definitely want to happen, but don't particularly otherwise care"}, {"sha": "da484385788079fc25992deca7890691c63535ac", "filename": "src/doc/tarpl/borrow-splitting.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fborrow-splitting.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fborrow-splitting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fborrow-splitting.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -2,7 +2,7 @@\n \n The mutual exclusion property of mutable references can be very limiting when\n working with a composite structure. The borrow checker understands some basic\n-stuff, but will fall over pretty easily. It *does* understand structs\n+stuff, but will fall over pretty easily. It does understand structs\n sufficiently to know that it's possible to borrow disjoint fields of a struct\n simultaneously. So this works today:\n \n@@ -50,7 +50,7 @@ to the same value.\n \n In order to \"teach\" borrowck that what we're doing is ok, we need to drop down\n to unsafe code. For instance, mutable slices expose a `split_at_mut` function\n-that consumes the slice and returns *two* mutable slices. One for everything to\n+that consumes the slice and returns two mutable slices. One for everything to\n the left of the index, and one for everything to the right. Intuitively we know\n this is safe because the slices don't overlap, and therefore alias. However\n the implementation requires some unsafety:\n@@ -93,10 +93,10 @@ completely incompatible with this API, as it would produce multiple mutable\n references to the same object!\n \n However it actually *does* work, exactly because iterators are one-shot objects.\n-Everything an IterMut yields will be yielded *at most* once, so we don't\n-*actually* ever yield multiple mutable references to the same piece of data.\n+Everything an IterMut yields will be yielded at most once, so we don't\n+actually ever yield multiple mutable references to the same piece of data.\n \n-Perhaps surprisingly, mutable iterators *don't* require unsafe code to be\n+Perhaps surprisingly, mutable iterators don't require unsafe code to be\n implemented for many types!\n \n For instance here's a singly linked list:"}, {"sha": "5f07709cf4542efbd6a46bb3ce16eac783fd3b52", "filename": "src/doc/tarpl/casts.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fcasts.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fcasts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fcasts.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -1,13 +1,13 @@\n % Casts\n \n Casts are a superset of coercions: every coercion can be explicitly\n-invoked via a cast. However some conversions *require* a cast.\n+invoked via a cast. However some conversions require a cast.\n While coercions are pervasive and largely harmless, these \"true casts\"\n are rare and potentially dangerous. As such, casts must be explicitly invoked\n using the `as` keyword: `expr as Type`.\n \n True casts generally revolve around raw pointers and the primitive numeric\n-types. Even though they're dangerous, these casts are *infallible* at runtime.\n+types. Even though they're dangerous, these casts are infallible at runtime.\n If a cast triggers some subtle corner case no indication will be given that\n this occurred. The cast will simply succeed. That said, casts must be valid\n at the type level, or else they will be prevented statically. For instance,"}, {"sha": "f7c4482a4abf8adad7c79075759552dab1d324f8", "filename": "src/doc/tarpl/checked-uninit.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -80,7 +80,7 @@ loop {\n     // because it relies on actual values.\n     if true {\n         // But it does understand that it will only be taken once because\n-        // we *do* unconditionally break out of it. Therefore `x` doesn't\n+        // we unconditionally break out of it. Therefore `x` doesn't\n         // need to be marked as mutable.\n         x = 0;\n         break;"}, {"sha": "9dcbecdd5b329c0d78d2fb315b7c9c64adc6bcd3", "filename": "src/doc/tarpl/concurrency.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fconcurrency.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -2,12 +2,12 @@\n \n Rust as a language doesn't *really* have an opinion on how to do concurrency or\n parallelism. The standard library exposes OS threads and blocking sys-calls\n-because *everyone* has those, and they're uniform enough that you can provide\n+because everyone has those, and they're uniform enough that you can provide\n an abstraction over them in a relatively uncontroversial way. Message passing,\n green threads, and async APIs are all diverse enough that any abstraction over\n them tends to involve trade-offs that we weren't willing to commit to for 1.0.\n \n However the way Rust models concurrency makes it relatively easy design your own\n-concurrency paradigm as a library and have *everyone else's* code Just Work\n+concurrency paradigm as a library and have everyone else's code Just Work\n with yours. Just require the right lifetimes and Send and Sync where appropriate\n-and you're off to the races. Or rather, off to the... not... having... races.\n\\ No newline at end of file\n+and you're off to the races. Or rather, off to the... not... having... races."}, {"sha": "97817cd1f9080bae4790ad3a452d6f42f75c88e1", "filename": "src/doc/tarpl/constructors.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fconstructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fconstructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fconstructors.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -37,14 +37,14 @@ blindly memcopied to somewhere else in memory. This means pure on-the-stack-but-\n still-movable intrusive linked lists are simply not happening in Rust (safely).\n \n Assignment and copy constructors similarly don't exist because move semantics\n-are the *only* semantics in Rust. At most `x = y` just moves the bits of y into\n-the x variable. Rust *does* provide two facilities for providing C++'s copy-\n+are the only semantics in Rust. At most `x = y` just moves the bits of y into\n+the x variable. Rust does provide two facilities for providing C++'s copy-\n oriented semantics: `Copy` and `Clone`. Clone is our moral equivalent of a copy\n constructor, but it's never implicitly invoked. You have to explicitly call\n `clone` on an element you want to be cloned. Copy is a special case of Clone\n where the implementation is just \"copy the bits\". Copy types *are* implicitly\n cloned whenever they're moved, but because of the definition of Copy this just\n-means *not* treating the old copy as uninitialized -- a no-op.\n+means not treating the old copy as uninitialized -- a no-op.\n \n While Rust provides a `Default` trait for specifying the moral equivalent of a\n default constructor, it's incredibly rare for this trait to be used. This is"}, {"sha": "b099a789ec352b0d0b363cc16c42c07876f32f14", "filename": "src/doc/tarpl/conversions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fconversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fconversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fconversions.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -8,7 +8,7 @@ a different type. Because Rust encourages encoding important properties in the\n type system, these problems are incredibly pervasive. As such, Rust\n consequently gives you several ways to solve them.\n \n-First we'll look at the ways that *Safe Rust* gives you to reinterpret values.\n+First we'll look at the ways that Safe Rust gives you to reinterpret values.\n The most trivial way to do this is to just destructure a value into its\n constituent parts and then build a new type out of them. e.g.\n "}, {"sha": "d0a796b7f0bbaaa08ae768c8766a5b0b4bb9aa5f", "filename": "src/doc/tarpl/data.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fdata.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fdata.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdata.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -1,5 +1,5 @@\n % Data Representation in Rust\n \n-Low-level programming cares a lot about data layout. It's a big deal. It also pervasively\n-influences the rest of the language, so we're going to start by digging into how data is\n-represented in Rust.\n+Low-level programming cares a lot about data layout. It's a big deal. It also\n+pervasively influences the rest of the language, so we're going to start by\n+digging into how data is represented in Rust."}, {"sha": "568f7c07f59ef88d0a648532c8e8e1fc36243ed2", "filename": "src/doc/tarpl/destructors.md", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdestructors.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -7,16 +7,19 @@ What the language *does* provide is full-blown automatic destructors through the\n fn drop(&mut self);\n ```\n \n-This method gives the type time to somehow finish what it was doing. **After\n-`drop` is run, Rust will recursively try to drop all of the fields of `self`**.\n+This method gives the type time to somehow finish what it was doing.\n+\n+**After `drop` is run, Rust will recursively try to drop all of the fields\n+of `self`.**\n+\n This is a convenience feature so that you don't have to write \"destructor\n boilerplate\" to drop children. If a struct has no special logic for being\n dropped other than dropping its children, then it means `Drop` doesn't need to\n be implemented at all!\n \n-**There is no stable way to prevent this behaviour in Rust 1.0.\n+**There is no stable way to prevent this behaviour in Rust 1.0.**\n \n-Note that taking `&mut self` means that even if you *could* suppress recursive\n+Note that taking `&mut self` means that even if you could suppress recursive\n Drop, Rust will prevent you from e.g. moving fields out of self. For most types,\n this is totally fine.\n \n@@ -90,7 +93,7 @@ After we deallocate the `box`'s ptr in SuperBox's destructor, Rust will\n happily proceed to tell the box to Drop itself and everything will blow up with\n use-after-frees and double-frees.\n \n-Note that the recursive drop behaviour applies to *all* structs and enums\n+Note that the recursive drop behaviour applies to all structs and enums\n regardless of whether they implement Drop. Therefore something like\n \n ```rust\n@@ -114,7 +117,7 @@ enum Link {\n }\n ```\n \n-will have its inner Box field dropped *if and only if* an instance stores the\n+will have its inner Box field dropped if and only if an instance stores the\n Next variant.\n \n In general this works really nice because you don't need to worry about\n@@ -165,7 +168,7 @@ impl<T> Drop for SuperBox<T> {\n ```\n \n However this has fairly odd semantics: you're saying that a field that *should*\n-always be Some may be None, just because that happens in the destructor. Of\n+always be Some *may* be None, just because that happens in the destructor. Of\n course this conversely makes a lot of sense: you can call arbitrary methods on\n self during the destructor, and this should prevent you from ever doing so after\n deinitializing the field. Not that it will prevent you from producing any other"}, {"sha": "1e81c97479b8fd05950748268c7621c137d829f6", "filename": "src/doc/tarpl/drop-flags.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fdrop-flags.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fdrop-flags.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdrop-flags.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -10,7 +10,7 @@ How can it do this with conditional initialization?\n \n Note that this is not a problem that all assignments need worry about. In\n particular, assigning through a dereference unconditionally drops, and assigning\n-in a `let` unconditionally *doesn't* drop:\n+in a `let` unconditionally doesn't drop:\n \n ```\n let mut x = Box::new(0); // let makes a fresh variable, so never need to drop\n@@ -23,11 +23,11 @@ one of its subfields.\n \n It turns out that Rust actually tracks whether a type should be dropped or not\n *at runtime*. As a variable becomes initialized and uninitialized, a *drop flag*\n-for that variable is toggled. When a variable *might* need to be dropped, this\n-flag is evaluated to determine if it *should* be dropped.\n+for that variable is toggled. When a variable might need to be dropped, this\n+flag is evaluated to determine if it should be dropped.\n \n-Of course, it is *often* the case that a value's initialization state can be\n-*statically* known at every point in the program. If this is the case, then the\n+Of course, it is often the case that a value's initialization state can be\n+statically known at every point in the program. If this is the case, then the\n compiler can theoretically generate more efficient code! For instance, straight-\n line code has such *static drop semantics*:\n \n@@ -40,8 +40,8 @@ y = x;                   // y was init; Drop y, overwrite it, and make x uninit!\n                          // x goes out of scope; x was uninit; do nothing.\n ```\n \n-And even branched code where all branches have the same behaviour with respect\n-to initialization:\n+Similarly, branched code where all branches have the same behaviour with respect\n+to initialization has static drop semantics:\n \n ```rust\n # let condition = true;\n@@ -65,7 +65,7 @@ if condition {\n     x = Box::new(0);        // x was uninit; just overwrite.\n     println!(\"{}\", x);\n }\n-                            // x goes out of scope; x *might* be uninit;\n+                            // x goes out of scope; x might be uninit;\n                             // check the flag!\n ```\n \n@@ -81,7 +81,7 @@ if condition {\n \n As of Rust 1.0, the drop flags are actually not-so-secretly stashed in a hidden\n field of any type that implements Drop. Rust sets the drop flag by overwriting\n-the *entire* value with a particular bit pattern. This is pretty obviously Not\n+the entire value with a particular bit pattern. This is pretty obviously Not\n The Fastest and causes a bunch of trouble with optimizing code. It's legacy from\n a time when you could do much more complex conditional initialization.\n \n@@ -92,4 +92,4 @@ as it requires fairly substantial changes to the compiler.\n Regardless, Rust programs don't need to worry about uninitialized values on\n the stack for correctness. Although they might care for performance. Thankfully,\n Rust makes it easy to take control here! Uninitialized values are there, and\n-you can work with them in Safe Rust, but you're *never* in danger.\n+you can work with them in Safe Rust, but you're never in danger."}, {"sha": "df09d1a17447deaeaa64ba806465cf5a63eb4c22", "filename": "src/doc/tarpl/dropck.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdropck.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -30,7 +30,7 @@ let (x, y) = (vec![], vec![]);\n ```\n \n Does either value strictly outlive the other? The answer is in fact *no*,\n-neither value  strictly outlives the other. Of course, one of x or y will be\n+neither value strictly outlives the other. Of course, one of x or y will be\n dropped before the other, but the actual order is not specified. Tuples aren't\n special in this regard; composite structures just don't guarantee their\n destruction order as of Rust 1.0.\n@@ -100,11 +100,11 @@ fn main() {\n <anon>:15 }\n ```\n \n-Implementing Drop lets the Inspector execute some arbitrary code *during* its\n+Implementing Drop lets the Inspector execute some arbitrary code during its\n death. This means it can potentially observe that types that are supposed to\n live as long as it does actually were destroyed first.\n \n-Interestingly, only *generic* types need to worry about this. If they aren't\n+Interestingly, only generic types need to worry about this. If they aren't\n generic, then the only lifetimes they can harbor are `'static`, which will truly\n live *forever*. This is why this problem is referred to as *sound generic drop*.\n Sound generic drop is enforced by the *drop checker*. As of this writing, some\n@@ -116,12 +116,12 @@ section:\n strictly outlive it.**\n \n This rule is sufficient but not necessary to satisfy the drop checker. That is,\n-if your type obeys this rule then it's *definitely* sound to drop. However\n+if your type obeys this rule then it's definitely sound to drop. However\n there are special cases where you can fail to satisfy this, but still\n successfully pass the borrow checker. These are the precise rules that are\n currently up in the air.\n \n It turns out that when writing unsafe code, we generally don't need to\n worry at all about doing the right thing for the drop checker. However there\n-is *one* special case that you need to worry about, which we will look at in\n+is one special case that you need to worry about, which we will look at in\n the next section."}, {"sha": "74f7831a72afb81f26b789b4cc825ab518636f93", "filename": "src/doc/tarpl/exception-safety.md", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fexception-safety.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fexception-safety.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fexception-safety.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -1,8 +1,8 @@\n % Exception Safety\n \n-Although programs should use unwinding sparingly, there's *a lot* of code that\n+Although programs should use unwinding sparingly, there's a lot of code that\n *can* panic. If you unwrap a None, index out of bounds, or divide by 0, your\n-program *will* panic. On debug builds, *every* arithmetic operation can panic\n+program will panic. On debug builds, every arithmetic operation can panic\n if it overflows. Unless you are very careful and tightly control what code runs,\n pretty much everything can unwind, and you need to be ready for it.\n \n@@ -22,7 +22,7 @@ unsound states must be careful that a panic does not cause that state to be\n used. Generally this means ensuring that only non-panicking code is run while\n these states exist, or making a guard that cleans up the state in the case of\n a panic. This does not necessarily mean that the state a panic witnesses is a\n-fully *coherent* state. We need only guarantee that it's a *safe* state.\n+fully coherent state. We need only guarantee that it's a *safe* state.\n \n Most Unsafe code is leaf-like, and therefore fairly easy to make exception-safe.\n It controls all the code that runs, and most of that code can't panic. However\n@@ -58,17 +58,16 @@ impl<T: Clone> Vec<T> {\n We bypass `push` in order to avoid redundant capacity and `len` checks on the\n Vec that we definitely know has capacity. The logic is totally correct, except\n there's a subtle problem with our code: it's not exception-safe! `set_len`,\n-`offset`, and `write` are all fine, but *clone* is the panic bomb we over-\n-looked.\n+`offset`, and `write` are all fine; `clone` is the panic bomb we over-looked.\n \n Clone is completely out of our control, and is totally free to panic. If it\n does, our function will exit early with the length of the Vec set too large. If\n the Vec is looked at or dropped, uninitialized memory will be read!\n \n The fix in this case is fairly simple. If we want to guarantee that the values\n-we *did* clone are dropped we can set the len *in* the loop. If we just want to\n-guarantee that uninitialized memory can't be observed, we can set the len\n-*after* the loop.\n+we *did* clone are dropped, we can set the `len` every loop iteration. If we\n+just want to guarantee that uninitialized memory can't be observed, we can set\n+the `len` after the loop.\n \n \n \n@@ -89,7 +88,7 @@ bubble_up(heap, index):\n \n A literal transcription of this code to Rust is totally fine, but has an annoying\n performance characteristic: the `self` element is swapped over and over again\n-uselessly. We would *rather* have the following:\n+uselessly. We would rather have the following:\n \n ```text\n bubble_up(heap, index):\n@@ -128,7 +127,7 @@ actually touched the state of the heap yet. Once we do start messing with the\n heap, we're working with only data and functions that we trust, so there's no\n concern of panics.\n \n-Perhaps you're not happy with this design. Surely, it's cheating! And we have\n+Perhaps you're not happy with this design. Surely it's cheating! And we have\n to do the complex heap traversal *twice*! Alright, let's bite the bullet. Let's\n intermix untrusted and unsafe code *for reals*.\n "}, {"sha": "0b653a7ad3a3e53c6f54e5eabd57e4a1e7198d38", "filename": "src/doc/tarpl/exotic-sizes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -48,7 +48,7 @@ a variable position based on its alignment][dst-issue].**\n \n # Zero Sized Types (ZSTs)\n \n-Rust actually allows types to be specified that occupy *no* space:\n+Rust actually allows types to be specified that occupy no space:\n \n ```rust\n struct Foo; // No fields = no size\n@@ -124,7 +124,7 @@ let res: Result<u32, Void> = Ok(0);\n let Ok(num) = res;\n ```\n \n-But neither of these tricks work today, so all Void types get you today is\n+But neither of these tricks work today, so all Void types get you is\n the ability to be confident that certain situations are statically impossible.\n \n One final subtle detail about empty types is that raw pointers to them are"}, {"sha": "8692832e2c77ccc7b02345957a5bf668cc94b3bc", "filename": "src/doc/tarpl/hrtb.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fhrtb.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fhrtb.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fhrtb.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -55,7 +55,7 @@ fn main() {\n How on earth are we supposed to express the lifetimes on `F`'s trait bound? We\n need to provide some lifetime there, but the lifetime we care about can't be\n named until we enter the body of `call`! Also, that isn't some fixed lifetime;\n-call works with *any* lifetime `&self` happens to have at that point.\n+`call` works with *any* lifetime `&self` happens to have at that point.\n \n This job requires The Magic of Higher-Rank Trait Bounds (HRTBs). The way we\n desugar this is as follows:"}, {"sha": "1aa78e112ea187d98b9f8cccd78a59503acd4cf6", "filename": "src/doc/tarpl/leaking.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fleaking.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fleaking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fleaking.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -21,21 +21,21 @@ uselessly, holding on to its precious resources until the program terminates (at\n which point all those resources would have been reclaimed by the OS anyway).\n \n We may consider a more restricted form of leak: failing to drop a value that is\n-unreachable. Rust also doesn't prevent this. In fact Rust has a *function for\n+unreachable. Rust also doesn't prevent this. In fact Rust *has a function for\n doing this*: `mem::forget`. This function consumes the value it is passed *and\n then doesn't run its destructor*.\n \n In the past `mem::forget` was marked as unsafe as a sort of lint against using\n it, since failing to call a destructor is generally not a well-behaved thing to\n do (though useful for some special unsafe code). However this was generally\n-determined to be an untenable stance to take: there are *many* ways to fail to\n+determined to be an untenable stance to take: there are many ways to fail to\n call a destructor in safe code. The most famous example is creating a cycle of\n reference-counted pointers using interior mutability.\n \n It is reasonable for safe code to assume that destructor leaks do not happen, as\n any program that leaks destructors is probably wrong. However *unsafe* code\n-cannot rely on destructors to be run to be *safe*. For most types this doesn't\n-matter: if you leak the destructor then the type is *by definition*\n+cannot rely on destructors to be run in order to be safe. For most types this\n+doesn't matter: if you leak the destructor then the type is by definition\n inaccessible, so it doesn't matter, right? For instance, if you leak a `Box<u8>`\n then you waste some memory but that's hardly going to violate memory-safety.\n \n@@ -64,7 +64,7 @@ uninitialized data! We could backshift all the elements in the Vec every time we\n remove a value, but this would have pretty catastrophic performance\n consequences.\n \n-Instead, we would like Drain to *fix* the Vec's backing storage when it is\n+Instead, we would like Drain to fix the Vec's backing storage when it is\n dropped. It should run itself to completion, backshift any elements that weren't\n removed (drain supports subranges), and then fix Vec's `len`. It's even\n unwinding-safe! Easy!\n@@ -97,13 +97,13 @@ consistent state gives us Undefined Behaviour in safe code (making the API\n unsound).\n \n So what can we do? Well, we can pick a trivially consistent state: set the Vec's\n-len to be 0 when we *start* the iteration, and fix it up if necessary in the\n+len to be 0 when we start the iteration, and fix it up if necessary in the\n destructor. That way, if everything executes like normal we get the desired\n behaviour with minimal overhead. But if someone has the *audacity* to\n mem::forget us in the middle of the iteration, all that does is *leak even more*\n-(and possibly leave the Vec in an *unexpected* but consistent state). Since\n-we've accepted that mem::forget is safe, this is definitely safe. We call leaks\n-causing more leaks a *leak amplification*.\n+(and possibly leave the Vec in an unexpected but otherwise consistent state).\n+Since we've accepted that mem::forget is safe, this is definitely safe. We call\n+leaks causing more leaks a *leak amplification*.\n \n \n \n@@ -167,16 +167,16 @@ impl<T> Drop for Rc<T> {\n }\n ```\n \n-This code contains an implicit and subtle assumption: ref_count can fit in a\n+This code contains an implicit and subtle assumption: `ref_count` can fit in a\n `usize`, because there can't be more than `usize::MAX` Rcs in memory. However\n-this itself assumes that the ref_count accurately reflects the number of Rcs\n-in memory, which we know is false with mem::forget. Using mem::forget we can\n-overflow the ref_count, and then get it down to 0 with outstanding Rcs. Then we\n-can happily use-after-free the inner data. Bad Bad Not Good.\n+this itself assumes that the `ref_count` accurately reflects the number of Rcs\n+in memory, which we know is false with `mem::forget`. Using `mem::forget` we can\n+overflow the `ref_count`, and then get it down to 0 with outstanding Rcs. Then\n+we can happily use-after-free the inner data. Bad Bad Not Good.\n \n-This can be solved by *saturating* the ref_count, which is sound because\n-decreasing the refcount by `n` still requires `n` Rcs simultaneously living\n-in memory.\n+This can be solved by just checking the `ref_count` and doing *something*. The\n+standard library's stance is to just abort, because your program has become\n+horribly degenerate. Also *oh my gosh* it's such a ridiculous corner case.\n \n \n \n@@ -237,7 +237,7 @@ In principle, this totally works! Rust's ownership system perfectly ensures it!\n let mut data = Box::new(0);\n {\n     let guard = thread::scoped(|| {\n-        // This is at best a data race. At worst, it's *also* a use-after-free.\n+        // This is at best a data race. At worst, it's also a use-after-free.\n         *data += 1;\n     });\n     // Because the guard is forgotten, expiring the loan without blocking this"}, {"sha": "8b01616ee0d109efbf037b6f11dd593c42fee187", "filename": "src/doc/tarpl/lifetime-mismatch.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Flifetime-mismatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Flifetime-mismatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetime-mismatch.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -18,7 +18,7 @@ fn main() {\n ```\n \n One might expect it to compile. We call `mutate_and_share`, which mutably borrows\n-`foo` *temporarily*, but then returns *only* a shared reference. Therefore we\n+`foo` temporarily, but then returns only a shared reference. Therefore we\n would expect `foo.share()` to succeed as `foo` shouldn't be mutably borrowed.\n \n However when we try to compile it:\n@@ -69,7 +69,7 @@ due to the lifetime of `loan` and mutate_and_share's signature. Then when we\n try to call `share`, and it sees we're trying to alias that `&'c mut foo` and\n blows up in our face!\n \n-This program is clearly correct according to the reference semantics we *actually*\n+This program is clearly correct according to the reference semantics we actually\n care about, but the lifetime system is too coarse-grained to handle that.\n \n \n@@ -78,4 +78,4 @@ TODO: other common problems? SEME regions stuff, mostly?\n \n \n \n-[ex2]: lifetimes.html#example-2:-aliasing-a-mutable-reference\n\\ No newline at end of file\n+[ex2]: lifetimes.html#example-2:-aliasing-a-mutable-reference"}, {"sha": "f211841ec0ce792e7193594558c7e891f0a70b53", "filename": "src/doc/tarpl/lifetimes.md", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetimes.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -6,11 +6,11 @@ and anything that contains a reference, is tagged with a lifetime specifying\n the scope it's valid for.\n \n Within a function body, Rust generally doesn't let you explicitly name the\n-lifetimes involved. This is because it's generally not really *necessary*\n+lifetimes involved. This is because it's generally not really necessary\n to talk about lifetimes in a local context; Rust has all the information and\n can work out everything as optimally as possible. Many anonymous scopes and\n temporaries that you would otherwise have to write are often introduced to\n-make your code *just work*.\n+make your code Just Work.\n \n However once you cross the function boundary, you need to start talking about\n lifetimes. Lifetimes are denoted with an apostrophe: `'a`, `'static`. To dip\n@@ -42,7 +42,7 @@ likely desugar to the following:\n 'a: {\n     let x: i32 = 0;\n     'b: {\n-        // lifetime used is 'b because that's *good enough*.\n+        // lifetime used is 'b because that's good enough.\n         let y: &'b i32 = &'b x;\n         'c: {\n             // ditto on 'c\n@@ -107,8 +107,9 @@ fn as_str<'a>(data: &'a u32) -> &'a str {\n This signature of `as_str` takes a reference to a u32 with *some* lifetime, and\n promises that it can produce a reference to a str that can live *just as long*.\n Already we can see why this signature might be trouble. That basically implies\n-that we're going to *find* a str somewhere in the scope the scope the reference\n-to the u32 originated in, or somewhere *even* earlier. That's a *bit* of a big ask.\n+that we're going to find a str somewhere in the scope the reference\n+to the u32 originated in, or somewhere *even earlier*. That's a bit of a big\n+ask.\n \n We then proceed to compute the string `s`, and return a reference to it. Since\n the contract of our function says the reference must outlive `'a`, that's the\n@@ -135,7 +136,7 @@ fn main() {\n         'd: {\n             // An anonymous scope is introduced because the borrow does not\n             // need to last for the whole scope x is valid for. The return\n-            // of as_str must find a str somewhere *before* this function\n+            // of as_str must find a str somewhere before this function\n             // call. Obviously not happening.\n             println!(\"{}\", as_str::<'d>(&'d x));\n         }\n@@ -195,21 +196,21 @@ println!(\"{}\", x);\n \n The problem here is is bit more subtle and interesting. We want Rust to\n reject this program for the following reason: We have a live shared reference `x`\n-to a descendent of `data` when try to take a *mutable* reference to `data`\n-when we call `push`. This would create an aliased mutable reference, which would\n+to a descendent of `data` when we try to take a mutable reference to `data`\n+to `push`. This would create an aliased mutable reference, which would\n violate the *second* rule of references.\n \n However this is *not at all* how Rust reasons that this program is bad. Rust\n doesn't understand that `x` is a reference to a subpath of `data`. It doesn't\n understand Vec at all. What it *does* see is that `x` has to live for `'b` to\n be printed. The signature of `Index::index` subsequently demands that the\n-reference we take to *data* has to survive for `'b`. When we try to call `push`,\n+reference we take to `data` has to survive for `'b`. When we try to call `push`,\n it then sees us try to make an `&'c mut data`. Rust knows that `'c` is contained\n within `'b`, and rejects our program because the `&'b data` must still be live!\n \n-Here we see that the lifetime system is *much* more coarse than the reference\n+Here we see that the lifetime system is much more coarse than the reference\n semantics we're actually interested in preserving. For the most part, *that's\n totally ok*, because it keeps us from spending all day explaining our program\n-to the compiler. However it does mean that several programs that are *totally*\n+to the compiler. However it does mean that several programs that are totally\n correct with respect to Rust's *true* semantics are rejected because lifetimes\n are too dumb."}, {"sha": "15e49c747b81075f46b83c59b142db0b0928f274", "filename": "src/doc/tarpl/meet-safe-and-unsafe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fmeet-safe-and-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fmeet-safe-and-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fmeet-safe-and-unsafe.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -29,7 +29,7 @@ Rust, you will never have to worry about type-safety or memory-safety. You will\n never endure a null or dangling pointer, or any of that Undefined Behaviour\n nonsense.\n \n-*That's totally awesome*.\n+*That's totally awesome.*\n \n The standard library also gives you enough utilities out-of-the-box that you'll\n be able to write awesome high-performance applications and libraries in pure\n@@ -41,7 +41,7 @@ low-level abstraction not exposed by the standard library. Maybe you're\n need to do something the type-system doesn't understand and just *frob some dang\n bits*. Maybe you need Unsafe Rust.\n \n-Unsafe Rust is exactly like Safe Rust with *all* the same rules and semantics.\n+Unsafe Rust is exactly like Safe Rust with all the same rules and semantics.\n However Unsafe Rust lets you do some *extra* things that are Definitely Not Safe.\n \n The only things that are different in Unsafe Rust are that you can:"}, {"sha": "e80c64c3543f8a18503d58db992b63aba2d12930", "filename": "src/doc/tarpl/ownership.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fownership.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -12,7 +12,7 @@ language?\n \n Regardless of your feelings on GC, it is pretty clearly a *massive* boon to\n making code safe. You never have to worry about things going away *too soon*\n-(although whether you still *wanted* to be pointing at that thing is a different\n+(although whether you still wanted to be pointing at that thing is a different\n issue...). This is a pervasive problem that C and C++ programs need to deal\n with. Consider this simple mistake that all of us who have used a non-GC'd\n language have made at one point:"}, {"sha": "0d7ec7f161796e3cf8bc26760e173d419b6e02f9", "filename": "src/doc/tarpl/phantom-data.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fphantom-data.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fphantom-data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fphantom-data.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -14,11 +14,11 @@ struct Iter<'a, T: 'a> {\n \n However because `'a` is unused within the struct's body, it's *unbounded*.\n Because of the troubles this has historically caused, unbounded lifetimes and\n-types are *illegal* in struct definitions. Therefore we must somehow refer\n+types are *forbidden* in struct definitions. Therefore we must somehow refer\n to these types in the body. Correctly doing this is necessary to have\n correct variance and drop checking.\n \n-We do this using *PhantomData*, which is a special marker type. PhantomData\n+We do this using `PhantomData`, which is a special marker type. `PhantomData`\n consumes no space, but simulates a field of the given type for the purpose of\n static analysis. This was deemed to be less error-prone than explicitly telling\n the type-system the kind of variance that you want, while also providing other\n@@ -57,7 +57,7 @@ Good to go!\n Nope.\n \n The drop checker will generously determine that Vec<T> does not own any values\n-of type T. This will in turn make it conclude that it does *not* need to worry\n+of type T. This will in turn make it conclude that it doesn't need to worry\n about Vec dropping any T's in its destructor for determining drop check\n soundness. This will in turn allow people to create unsoundness using\n Vec's destructor."}, {"sha": "70de91af61f6f900c8746422fb7999d4a74be040", "filename": "src/doc/tarpl/poisoning.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fpoisoning.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fpoisoning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fpoisoning.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -20,7 +20,7 @@ standard library's Mutex type. A Mutex will poison itself if one of its\n MutexGuards (the thing it returns when a lock is obtained) is dropped during a\n panic. Any future attempts to lock the Mutex will return an `Err` or panic.\n \n-Mutex poisons not for *true* safety in the sense that Rust normally cares about. It\n+Mutex poisons not for true safety in the sense that Rust normally cares about. It\n poisons as a safety-guard against blindly using the data that comes out of a Mutex\n that has witnessed a panic while locked. The data in such a Mutex was likely in the\n middle of being modified, and as such may be in an inconsistent or incomplete state."}, {"sha": "3b47502ebfe790a9f6ce55454eef864bb6591fd2", "filename": "src/doc/tarpl/races.md", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fraces.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fraces.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fraces.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -12,11 +12,13 @@ it's impossible to alias a mutable reference, so it's impossible to perform a\n data race. Interior mutability makes this more complicated, which is largely why\n we have the Send and Sync traits (see below).\n \n-However Rust *does not* prevent general race conditions. This is\n-pretty fundamentally impossible, and probably honestly undesirable. Your hardware\n-is racy, your OS is racy, the other programs on your computer are racy, and the\n-world this all runs in is racy. Any system that could genuinely claim to prevent\n-*all* race conditions would be pretty awful to use, if not just incorrect.\n+**However Rust does not prevent general race conditions.**\n+\n+This is pretty fundamentally impossible, and probably honestly undesirable. Your\n+hardware is racy, your OS is racy, the other programs on your computer are racy,\n+and the world this all runs in is racy. Any system that could genuinely claim to\n+prevent *all* race conditions would be pretty awful to use, if not just\n+incorrect.\n \n So it's perfectly \"fine\" for a Safe Rust program to get deadlocked or do\n something incredibly stupid with incorrect synchronization. Obviously such a\n@@ -46,7 +48,7 @@ thread::spawn(move || {\n });\n \n // Index with the value loaded from the atomic. This is safe because we\n-// read the atomic memory only once, and then pass a *copy* of that value\n+// read the atomic memory only once, and then pass a copy of that value\n // to the Vec's indexing implementation. This indexing will be correctly\n // bounds checked, and there's no chance of the value getting changed\n // in the middle. However our program may panic if the thread we spawned\n@@ -75,7 +77,7 @@ thread::spawn(move || {\n \n if idx.load(Ordering::SeqCst) < data.len() {\n     unsafe {\n-        // Incorrectly loading the idx *after* we did the bounds check.\n+        // Incorrectly loading the idx after we did the bounds check.\n         // It could have changed. This is a race condition, *and dangerous*\n         // because we decided to do `get_unchecked`, which is `unsafe`.\n         println!(\"{}\", data.get_unchecked(idx.load(Ordering::SeqCst)));"}, {"sha": "9073495c517670594e3baadd90eb49b8f3110a3b", "filename": "src/doc/tarpl/repr-rust.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Frepr-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Frepr-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Frepr-rust.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -70,7 +70,7 @@ struct B {\n Rust *does* guarantee that two instances of A have their data laid out in\n exactly the same way. However Rust *does not* guarantee that an instance of A\n has the same field ordering or padding as an instance of B (in practice there's\n-no *particular* reason why they wouldn't, other than that its not currently\n+no particular reason why they wouldn't, other than that its not currently\n guaranteed).\n \n With A and B as written, this is basically nonsensical, but several other\n@@ -88,9 +88,9 @@ struct Foo<T, U> {\n ```\n \n Now consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If\n-Rust lays out the fields in the order specified, we expect it to *pad* the\n-values in the struct to satisfy their *alignment* requirements. So if Rust\n-didn't reorder fields, we would expect Rust to produce the following:\n+Rust lays out the fields in the order specified, we expect it to pad the\n+values in the struct to satisfy their alignment requirements. So if Rust\n+didn't reorder fields, we would expect it to produce the following:\n \n ```rust,ignore\n struct Foo<u16, u32> {\n@@ -112,7 +112,7 @@ The latter case quite simply wastes space. An optimal use of space therefore\n requires different monomorphizations to have *different field orderings*.\n \n **Note: this is a hypothetical optimization that is not yet implemented in Rust\n-**1.0\n+1.0**\n \n Enums make this consideration even more complicated. Naively, an enum such as:\n \n@@ -128,8 +128,8 @@ would be laid out as:\n \n ```rust\n struct FooRepr {\n-    data: u64, // this is *really* either a u64, u32, or u8 based on `tag`\n-    tag: u8, // 0 = A, 1 = B, 2 = C\n+    data: u64, // this is either a u64, u32, or u8 based on `tag`\n+    tag: u8,   // 0 = A, 1 = B, 2 = C\n }\n ```\n "}, {"sha": "2f15b7050e362018f3701b63805e673fea109806", "filename": "src/doc/tarpl/safe-unsafe-meaning.md", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -5,7 +5,7 @@ So what's the relationship between Safe and Unsafe Rust? How do they interact?\n Rust models the separation between Safe and Unsafe Rust with the `unsafe`\n keyword, which can be thought as a sort of *foreign function interface* (FFI)\n between Safe and Unsafe Rust. This is the magic behind why we can say Safe Rust\n-is a safe language: all the scary unsafe bits are relegated *exclusively* to FFI\n+is a safe language: all the scary unsafe bits are relegated exclusively to FFI\n *just like every other safe language*.\n \n However because one language is a subset of the other, the two can be cleanly\n@@ -61,50 +61,50 @@ The need for unsafe traits boils down to the fundamental property of safe code:\n **No matter how completely awful Safe code is, it can't cause Undefined\n Behaviour.**\n \n-This means that Unsafe, **the royal vanguard of Undefined Behaviour**, has to be\n-*super paranoid* about generic safe code. Unsafe is free to trust *specific* safe\n-code (or else you would degenerate into infinite spirals of paranoid despair).\n-It is generally regarded as ok to trust the standard library to be correct, as\n-`std` is effectively an extension of the language (and you *really* just have\n-to trust the language). If `std` fails to uphold the guarantees it declares,\n-then it's basically a language bug.\n+This means that Unsafe Rust, **the royal vanguard of Undefined Behaviour**, has to be\n+*super paranoid* about generic safe code. To be clear, Unsafe Rust is totally free to trust\n+specific safe code. Anything else would degenerate into infinite spirals of\n+paranoid despair. In particular it's generally regarded as ok to trust the standard library\n+to be correct. `std` is effectively an extension of the language, and you\n+really just have to trust the language. If `std` fails to uphold the\n+guarantees it declares, then it's basically a language bug.\n \n That said, it would be best to minimize *needlessly* relying on properties of\n concrete safe code. Bugs happen! Of course, I must reinforce that this is only\n a concern for Unsafe code. Safe code can blindly trust anyone and everyone\n as far as basic memory-safety is concerned.\n \n On the other hand, safe traits are free to declare arbitrary contracts, but because\n-implementing them is Safe, Unsafe can't trust those contracts to actually\n+implementing them is safe, unsafe code can't trust those contracts to actually\n be upheld. This is different from the concrete case because *anyone* can\n randomly implement the interface. There is something fundamentally different\n-about trusting a *particular* piece of code to be correct, and trusting *all the\n+about trusting a particular piece of code to be correct, and trusting *all the\n code that will ever be written* to be correct.\n \n For instance Rust has `PartialOrd` and `Ord` traits to try to differentiate\n between types which can \"just\" be compared, and those that actually implement a\n-*total* ordering. Pretty much every API that wants to work with data that can be\n-compared *really* wants Ord data. For instance, a sorted map like BTreeMap\n+total ordering. Pretty much every API that wants to work with data that can be\n+compared wants Ord data. For instance, a sorted map like BTreeMap\n *doesn't even make sense* for partially ordered types. If you claim to implement\n Ord for a type, but don't actually provide a proper total ordering, BTreeMap will\n get *really confused* and start making a total mess of itself. Data that is\n inserted may be impossible to find!\n \n But that's okay. BTreeMap is safe, so it guarantees that even if you give it a\n-*completely* garbage Ord implementation, it will still do something *safe*. You\n-won't start reading uninitialized memory or unallocated memory. In fact, BTreeMap\n+completely garbage Ord implementation, it will still do something *safe*. You\n+won't start reading uninitialized or unallocated memory. In fact, BTreeMap\n manages to not actually lose any of your data. When the map is dropped, all the\n destructors will be successfully called! Hooray!\n \n-However BTreeMap is implemented using a modest spoonful of Unsafe (most collections\n-are). That means that it is not necessarily *trivially true* that a bad Ord\n-implementation will make BTreeMap behave safely. Unsafe must be sure not to rely\n-on Ord *where safety is at stake*. Ord is provided by Safe, and safety is not\n-Safe's responsibility to uphold.\n+However BTreeMap is implemented using a modest spoonful of Unsafe Rust (most collections\n+are). That means that it's not necessarily *trivially true* that a bad Ord\n+implementation will make BTreeMap behave safely. BTreeMap must be sure not to rely\n+on Ord *where safety is at stake*. Ord is provided by safe code, and safety is not\n+safe code's responsibility to uphold.\n \n-But wouldn't it be grand if there was some way for Unsafe to trust *some* trait\n+But wouldn't it be grand if there was some way for Unsafe to trust some trait\n contracts *somewhere*? This is the problem that unsafe traits tackle: by marking\n-*the trait itself* as unsafe *to implement*, Unsafe can trust the implementation\n+*the trait itself* as unsafe to implement, unsafe code can trust the implementation\n to uphold the trait's contract. Although the trait implementation may be\n incorrect in arbitrary other ways.\n \n@@ -126,7 +126,7 @@ But it's probably not the implementation you want.\n \n Rust has traditionally avoided making traits unsafe because it makes Unsafe\n pervasive, which is not desirable. Send and Sync are unsafe is because thread\n-safety is a *fundamental property* that Unsafe cannot possibly hope to defend\n+safety is a *fundamental property* that unsafe code cannot possibly hope to defend\n against in the same way it would defend against a bad Ord implementation. The\n only way to possibly defend against thread-unsafety would be to *not use\n threading at all*. Making every load and store atomic isn't even sufficient,\n@@ -135,10 +135,10 @@ in memory. For instance, the pointer and capacity of a Vec must be in sync.\n \n Even concurrent paradigms that are traditionally regarded as Totally Safe like\n message passing implicitly rely on some notion of thread safety -- are you\n-really message-passing if you pass a *pointer*? Send and Sync therefore require\n-some *fundamental* level of trust that Safe code can't provide, so they must be\n+really message-passing if you pass a pointer? Send and Sync therefore require\n+some fundamental level of trust that Safe code can't provide, so they must be\n unsafe to implement. To help obviate the pervasive unsafety that this would\n-introduce, Send (resp. Sync) is *automatically* derived for all types composed only\n+introduce, Send (resp. Sync) is automatically derived for all types composed only\n of Send (resp. Sync) values. 99% of types are Send and Sync, and 99% of those\n never actually say it (the remaining 1% is overwhelmingly synchronization\n primitives)."}, {"sha": "af8fb43f2e9133fcfeea1914347710732d4938e0", "filename": "src/doc/tarpl/send-and-sync.md", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -8,20 +8,19 @@ captures this with through the `Send` and `Sync` traits.\n * A type is Send if it is safe to send it to another thread. A type is Sync if\n * it is safe to share between threads (`&T` is Send).\n \n-Send and Sync are *very* fundamental to Rust's concurrency story. As such, a\n+Send and Sync are fundamental to Rust's concurrency story. As such, a\n substantial amount of special tooling exists to make them work right. First and\n-foremost, they're *unsafe traits*. This means that they are unsafe *to\n-implement*, and other unsafe code can *trust* that they are correctly\n+foremost, they're [unsafe traits][]. This means that they are unsafe to\n+implement, and other unsafe code can  that they are correctly\n implemented. Since they're *marker traits* (they have no associated items like\n methods), correctly implemented simply means that they have the intrinsic\n properties an implementor should have. Incorrectly implementing Send or Sync can\n cause Undefined Behaviour.\n \n-Send and Sync are also what Rust calls *opt-in builtin traits*. This means that,\n-unlike every other trait, they are *automatically* derived: if a type is\n-composed entirely of Send or Sync types, then it is Send or Sync. Almost all\n-primitives are Send and Sync, and as a consequence pretty much all types you'll\n-ever interact with are Send and Sync.\n+Send and Sync are also automatically derived traits. This means that, unlike\n+every other trait, if a type is composed entirely of Send or Sync types, then it\n+is Send or Sync. Almost all primitives are Send and Sync, and as a consequence\n+pretty much all types you'll ever interact with are Send and Sync.\n \n Major exceptions include:\n \n@@ -37,13 +36,12 @@ sense, one could argue that it would be \"fine\" for them to be marked as thread\n safe.\n \n However it's important that they aren't thread safe to prevent types that\n-*contain them* from being automatically marked as thread safe. These types have\n+contain them from being automatically marked as thread safe. These types have\n non-trivial untracked ownership, and it's unlikely that their author was\n necessarily thinking hard about thread safety. In the case of Rc, we have a nice\n-example of a type that contains a `*mut` that is *definitely* not thread safe.\n+example of a type that contains a `*mut` that is definitely not thread safe.\n \n-Types that aren't automatically derived can *opt-in* to Send and Sync by simply\n-implementing them:\n+Types that aren't automatically derived can simply implement them if desired:\n \n ```rust\n struct MyBox(*mut u8);\n@@ -52,12 +50,13 @@ unsafe impl Send for MyBox {}\n unsafe impl Sync for MyBox {}\n ```\n \n-In the *incredibly rare* case that a type is *inappropriately* automatically\n-derived to be Send or Sync, then one can also *unimplement* Send and Sync:\n+In the *incredibly rare* case that a type is inappropriately automatically\n+derived to be Send or Sync, then one can also unimplement Send and Sync:\n \n ```rust\n #![feature(optin_builtin_traits)]\n \n+// I have some magic semantics for some synchronization primitive!\n struct SpecialThreadToken(u8);\n \n impl !Send for SpecialThreadToken {}\n@@ -77,3 +76,5 @@ largely behave like an `&` or `&mut` into the collection.\n \n TODO: better explain what can or can't be Send or Sync. Sufficient to appeal\n only to data races?\n+\n+[unsafe traits]: safe-unsafe-meaning.html"}, {"sha": "3c57297f323cc7ad69f2545c148886a5e1d1a50a", "filename": "src/doc/tarpl/subtyping.md", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsubtyping.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -1,14 +1,14 @@\n % Subtyping and Variance\n \n Although Rust doesn't have any notion of structural inheritance, it *does*\n-include subtyping. In Rust, subtyping derives entirely from *lifetimes*. Since\n+include subtyping. In Rust, subtyping derives entirely from lifetimes. Since\n lifetimes are scopes, we can partially order them based on the *contains*\n (outlives) relationship. We can even express this as a generic bound.\n \n-Subtyping on lifetimes in terms of that relationship: if `'a: 'b` (\"a contains\n+Subtyping on lifetimes is in terms of that relationship: if `'a: 'b` (\"a contains\n b\" or \"a outlives b\"), then `'a` is a subtype of `'b`. This is a large source of\n confusion, because it seems intuitively backwards to many: the bigger scope is a\n-*sub type* of the smaller scope.\n+*subtype* of the smaller scope.\n \n This does in fact make sense, though. The intuitive reason for this is that if\n you expect an `&'a u8`, then it's totally fine for me to hand you an `&'static\n@@ -72,7 +72,7 @@ to be able to pass `&&'static str` where an `&&'a str` is expected. The\n additional level of indirection does not change the desire to be able to pass\n longer lived things where shorted lived things are expected.\n \n-However this logic *does not* apply to `&mut`. To see why `&mut` should\n+However this logic doesn't apply to `&mut`. To see why `&mut` should\n be invariant over T, consider the following code:\n \n ```rust,ignore\n@@ -109,7 +109,7 @@ between `'a` and T is that `'a` is a property of the reference itself,\n while T is something the reference is borrowing. If you change T's type, then\n the source still remembers the original type. However if you change the\n lifetime's type, no one but the reference knows this information, so it's fine.\n-Put another way, `&'a mut T` owns `'a`, but only *borrows* T.\n+Put another way: `&'a mut T` owns `'a`, but only *borrows* T.\n \n `Box` and `Vec` are interesting cases because they're variant, but you can\n definitely store values in them! This is where Rust gets really clever: it's\n@@ -118,15 +118,15 @@ in them *via a mutable reference*! The mutable reference makes the whole type\n invariant, and therefore prevents you from smuggling a short-lived type into\n them.\n \n-Being variant *does* allows `Box` and `Vec` to be weakened when shared\n+Being variant allows `Box` and `Vec` to be weakened when shared\n immutably. So you can pass a `&Box<&'static str>` where a `&Box<&'a str>` is\n expected.\n \n However what should happen when passing *by-value* is less obvious. It turns out\n that, yes, you can use subtyping when passing by-value. That is, this works:\n \n ```rust\n-fn get_box<'a>(str: &'a u8) -> Box<&'a str> {\n+fn get_box<'a>(str: &'a str) -> Box<&'a str> {\n     // string literals are `&'static str`s\n     Box::new(\"hello\")\n }\n@@ -150,7 +150,7 @@ signature:\n fn foo(&'a str) -> usize;\n ```\n \n-This signature claims that it can handle any `&str` that lives *at least* as\n+This signature claims that it can handle any `&str` that lives at least as\n long as `'a`. Now if this signature was variant over `&'a str`, that\n would mean\n \n@@ -159,10 +159,12 @@ fn foo(&'static str) -> usize;\n ```\n \n could be provided in its place, as it would be a subtype. However this function\n-has a *stronger* requirement: it says that it can *only* handle `&'static str`s,\n-and nothing else. Therefore functions are not variant over their arguments.\n+has a stronger requirement: it says that it can only handle `&'static str`s,\n+and nothing else. Giving `&'a str`s to it would be unsound, as it's free to\n+assume that what it's given lives forever. Therefore functions are not variant\n+over their arguments.\n \n-To see why `Fn(T) -> U` should be *variant* over U, consider the following\n+To see why `Fn(T) -> U` should be variant over U, consider the following\n function signature:\n \n ```rust,ignore\n@@ -177,7 +179,7 @@ therefore completely reasonable to provide\n fn foo(usize) -> &'static str;\n ```\n \n-in its place. Therefore functions *are* variant over their return type.\n+in its place. Therefore functions are variant over their return type.\n \n `*const` has the exact same semantics as `&`, so variance follows. `*mut` on the\n other hand can dereference to an `&mut` whether shared or not, so it is marked"}, {"sha": "3ad95dde39deda47fc61395384af3915a6221097", "filename": "src/doc/tarpl/unwinding.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Funwinding.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Funwinding.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Funwinding.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -31,12 +31,12 @@ panics can only be caught by the parent thread. This means catching a panic\n requires spinning up an entire OS thread! This unfortunately stands in conflict\n to Rust's philosophy of zero-cost abstractions.\n \n-There is an *unstable* API called `catch_panic` that enables catching a panic\n+There is an unstable API called `catch_panic` that enables catching a panic\n without spawning a thread. Still, we would encourage you to only do this\n sparingly. In particular, Rust's current unwinding implementation is heavily\n optimized for the \"doesn't unwind\" case. If a program doesn't unwind, there\n should be no runtime cost for the program being *ready* to unwind. As a\n-consequence, *actually* unwinding will be more expensive than in e.g. Java.\n+consequence, actually unwinding will be more expensive than in e.g. Java.\n Don't build your programs to unwind under normal circumstances. Ideally, you\n should only panic for programming errors or *extreme* problems.\n "}, {"sha": "fc7feba2356d5a4fb742a5b9ea06a99d32e86085", "filename": "src/doc/tarpl/vec-alloc.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fvec-alloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fvec-alloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-alloc.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -60,7 +60,7 @@ of memory at once (e.g. half the theoretical address space). As such it's\n like the standard library as much as possible, so we'll just kill the whole\n program.\n \n-We said we don't want to use intrinsics, so doing *exactly* what `std` does is\n+We said we don't want to use intrinsics, so doing exactly what `std` does is\n out. Instead, we'll call `std::process::exit` with some random number.\n \n ```rust\n@@ -84,7 +84,7 @@ But Rust's only supported allocator API is so low level that we'll need to do a\n fair bit of extra work. We also need to guard against some special\n conditions that can occur with really large allocations or empty allocations.\n \n-In particular, `ptr::offset` will cause us *a lot* of trouble, because it has\n+In particular, `ptr::offset` will cause us a lot of trouble, because it has\n the semantics of LLVM's GEP inbounds instruction. If you're fortunate enough to\n not have dealt with this instruction, here's the basic story with GEP: alias\n analysis, alias analysis, alias analysis. It's super important to an optimizing\n@@ -102,7 +102,7 @@ As a simple example, consider the following fragment of code:\n If the compiler can prove that `x` and `y` point to different locations in\n memory, the two operations can in theory be executed in parallel (by e.g.\n loading them into different registers and working on them independently).\n-However in *general* the compiler can't do this because if x and y point to\n+However the compiler can't do this in general because if x and y point to\n the same location in memory, the operations need to be done to the same value,\n and they can't just be merged afterwards.\n \n@@ -118,7 +118,7 @@ possible.\n So that's what GEP's about, how can it cause us trouble?\n \n The first problem is that we index into arrays with unsigned integers, but\n-GEP (and as a consequence `ptr::offset`) takes a *signed integer*. This means\n+GEP (and as a consequence `ptr::offset`) takes a signed integer. This means\n that half of the seemingly valid indices into an array will overflow GEP and\n actually go in the wrong direction! As such we must limit all allocations to\n `isize::MAX` elements. This actually means we only need to worry about\n@@ -138,7 +138,7 @@ However since this is a tutorial, we're not going to be particularly optimal\n here, and just unconditionally check, rather than use clever platform-specific\n `cfg`s.\n \n-The other corner-case we need to worry about is *empty* allocations. There will\n+The other corner-case we need to worry about is empty allocations. There will\n be two kinds of empty allocations we need to worry about: `cap = 0` for all T,\n and `cap > 0` for zero-sized types.\n \n@@ -165,9 +165,9 @@ protected from being allocated anyway (a whole 4k, on many platforms).\n \n However what about for positive-sized types? That one's a bit trickier. In\n principle, you can argue that offsetting by 0 gives LLVM no information: either\n-there's an element before the address, or after it, but it can't know which.\n+there's an element before the address or after it, but it can't know which.\n However we've chosen to conservatively assume that it may do bad things. As\n-such we *will* guard against this case explicitly.\n+such we will guard against this case explicitly.\n \n *Phew*\n "}, {"sha": "4521bbdd05e6b0456df7e86f38f548f67c20cfc3", "filename": "src/doc/tarpl/vec-drain.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-drain.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -130,7 +130,7 @@ impl<'a, T> Drop for Drain<'a, T> {\n impl<T> Vec<T> {\n     pub fn drain(&mut self) -> Drain<T> {\n         // this is a mem::forget safety thing. If Drain is forgotten, we just\n-        // leak the whole Vec's contents. Also we need to do this *eventually*\n+        // leak the whole Vec's contents. Also we need to do this eventually\n         // anyway, so why not do it now?\n         self.len = 0;\n "}, {"sha": "0a37170c52ca34bf39bef5bd96a80dbec6492f1f", "filename": "src/doc/tarpl/vec-insert-remove.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -10,7 +10,7 @@ handling the case where the source and destination overlap (which will\n definitely happen here).\n \n If we insert at index `i`, we want to shift the `[i .. len]` to `[i+1 .. len+1]`\n-using the *old* len.\n+using the old len.\n \n ```rust,ignore\n pub fn insert(&mut self, index: usize, elem: T) {"}, {"sha": "ebb0a79bb651ac05a83f24bfcf68633a636ba97e", "filename": "src/doc/tarpl/vec-into-iter.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -21,8 +21,8 @@ read out the value pointed to at that end and move the pointer over by one. When\n the two pointers are equal, we know we're done.\n \n Note that the order of read and offset are reversed for `next` and `next_back`\n-For `next_back` the pointer is always *after* the element it wants to read next,\n-while for `next` the pointer is always *at* the element it wants to read next.\n+For `next_back` the pointer is always after the element it wants to read next,\n+while for `next` the pointer is always at the element it wants to read next.\n To see why this is, consider the case where every element but one has been\n yielded.\n \n@@ -124,7 +124,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n ```\n \n Because IntoIter takes ownership of its allocation, it needs to implement Drop\n-to free it. However it *also* wants to implement Drop to drop any elements it\n+to free it. However it also wants to implement Drop to drop any elements it\n contains that weren't yielded.\n \n "}, {"sha": "b518e8aa48ffb1beb82b0b796cce45d60e6192f3", "filename": "src/doc/tarpl/vec-push-pop.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fvec-push-pop.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fvec-push-pop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-push-pop.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -32,14 +32,14 @@ pub fn push(&mut self, elem: T) {\n \n Easy! How about `pop`? Although this time the index we want to access is\n initialized, Rust won't just let us dereference the location of memory to move\n-the value out, because that *would* leave the memory uninitialized! For this we\n+the value out, because that would leave the memory uninitialized! For this we\n need `ptr::read`, which just copies out the bits from the target address and\n intrprets it as a value of type T. This will leave the memory at this address\n-*logically* uninitialized, even though there is in fact a perfectly good instance\n+logically uninitialized, even though there is in fact a perfectly good instance\n of T there.\n \n For `pop`, if the old len is 1, we want to read out of the 0th index. So we\n-should offset by the *new* len.\n+should offset by the new len.\n \n ```rust,ignore\n pub fn pop(&mut self) -> Option<T> {"}, {"sha": "72e8a34488bae73751aa6306d60613d32321bbdc", "filename": "src/doc/tarpl/vec-zsts.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fvec-zsts.md", "raw_url": "https://github.com/rust-lang/rust/raw/0919f4ad862bc3ae771fc56a8fe9905bca299fe2/src%2Fdoc%2Ftarpl%2Fvec-zsts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-zsts.md?ref=0919f4ad862bc3ae771fc56a8fe9905bca299fe2", "patch": "@@ -2,7 +2,7 @@\n \n It's time. We're going to fight the spectre that is zero-sized types. Safe Rust\n *never* needs to care about this, but Vec is very intensive on raw pointers and\n-raw allocations, which are exactly the *only* two things that care about\n+raw allocations, which are exactly the two things that care about\n zero-sized types. We need to be careful of two things:\n \n * The raw allocator API has undefined behaviour if you pass in 0 for an\n@@ -22,7 +22,7 @@ So if the allocator API doesn't support zero-sized allocations, what on earth\n do we store as our allocation? Why, `heap::EMPTY` of course! Almost every operation\n with a ZST is a no-op since ZSTs have exactly one value, and therefore no state needs\n to be considered to store or load them. This actually extends to `ptr::read` and\n-`ptr::write`: they won't actually look at the pointer at all. As such we *never* need\n+`ptr::write`: they won't actually look at the pointer at all. As such we never need\n to change the pointer.\n \n Note however that our previous reliance on running out of memory before overflow is"}]}