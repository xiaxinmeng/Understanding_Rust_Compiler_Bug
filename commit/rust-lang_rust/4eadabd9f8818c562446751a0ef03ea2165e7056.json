{"sha": "4eadabd9f8818c562446751a0ef03ea2165e7056", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYWRhYmQ5Zjg4MThjNTYyNDQ2NzUxYTBlZjAzZWEyMTY1ZTcwNTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-18T00:24:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-18T00:24:05Z"}, "message": "Auto merge of #29907 - nagisa:mir-moar-constants, r=nikomatsakis\n\nStill will not translate references to items like `X` or `Y::V` where\n\n```\nstruct X;\nenum Y { V }\n```\n\nbut I must go work on university things so I\u2019m PRing what I have.\n\nr? @nikomatsakis", "tree": {"sha": "52456c40e248d31a72bae602dc86c0054c49581e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52456c40e248d31a72bae602dc86c0054c49581e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eadabd9f8818c562446751a0ef03ea2165e7056", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eadabd9f8818c562446751a0ef03ea2165e7056", "html_url": "https://github.com/rust-lang/rust/commit/4eadabd9f8818c562446751a0ef03ea2165e7056", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eadabd9f8818c562446751a0ef03ea2165e7056/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48700be9cbf04d798a6f6ab65c50ab0afe86bc94", "url": "https://api.github.com/repos/rust-lang/rust/commits/48700be9cbf04d798a6f6ab65c50ab0afe86bc94", "html_url": "https://github.com/rust-lang/rust/commit/48700be9cbf04d798a6f6ab65c50ab0afe86bc94"}, {"sha": "7dd95799c2d31cd7b1ab573936b5ed26757fd08c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dd95799c2d31cd7b1ab573936b5ed26757fd08c", "html_url": "https://github.com/rust-lang/rust/commit/7dd95799c2d31cd7b1ab573936b5ed26757fd08c"}], "stats": {"total": 518, "additions": 490, "deletions": 28}, "files": [{"sha": "e83fe60f419a6dcb928df5d9a59ca7302e35658e", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -698,10 +698,20 @@ pub struct Constant<'tcx> {\n     pub literal: Literal<'tcx>,\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+pub enum ItemKind {\n+    Constant,\n+    Function,\n+    Struct,\n+    Variant,\n+    Method,\n+}\n+\n #[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n     Item {\n         def_id: DefId,\n+        kind: ItemKind,\n         substs: &'tcx Substs<'tcx>,\n     },\n     Value {"}, {"sha": "5d040bcb40ad8e72c2a1e111e47923df09e05d99", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -66,6 +66,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                             -> Operand<'tcx> {\n         let literal = Literal::Item {\n             def_id: item_ref.def_id,\n+            kind: item_ref.kind,\n             substs: item_ref.substs,\n         };\n         self.literal_operand(span, item_ref.ty, literal)"}, {"sha": "d1455e7016524117b4a0fe86831890602d543686", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -480,6 +480,7 @@ fn method_callee<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n         kind: ExprKind::Literal {\n             literal: Literal::Item {\n                 def_id: callee.def_id,\n+                kind: ItemKind::Method,\n                 substs: callee.substs,\n             },\n         },\n@@ -514,16 +515,39 @@ fn convert_arm<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<\n \n fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> ExprKind<'tcx> {\n     let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(expr.id).substs);\n-    match cx.tcx.def_map.borrow()[&expr.id].full_def() {\n+    // Otherwise there may be def_map borrow conflicts\n+    let def = cx.tcx.def_map.borrow()[&expr.id].full_def();\n+    match def {\n         def::DefVariant(_, def_id, false) |\n         def::DefStruct(def_id) |\n         def::DefFn(def_id, _) |\n-        def::DefConst(def_id) |\n-        def::DefMethod(def_id) |\n-        def::DefAssociatedConst(def_id) =>\n+        def::DefMethod(def_id) => {\n+            let kind = match def {\n+                def::DefVariant(..) => ItemKind::Variant,\n+                def::DefStruct(..) => ItemKind::Struct,\n+                def::DefFn(..) => ItemKind::Function,\n+                def::DefMethod(..) => ItemKind::Method,\n+                _ => panic!()\n+            };\n             ExprKind::Literal {\n-                literal: Literal::Item { def_id: def_id, substs: substs }\n-            },\n+                literal: Literal::Item { def_id: def_id, kind: kind, substs: substs }\n+            }\n+        },\n+        def::DefConst(def_id) |\n+        def::DefAssociatedConst(def_id) => {\n+            if let Some(v) = cx.try_const_eval_literal(expr) {\n+                ExprKind::Literal { literal: v }\n+            } else {\n+                ExprKind::Literal {\n+                    literal: Literal::Item {\n+                        def_id: def_id,\n+                        kind: ItemKind::Constant,\n+                        substs: substs\n+                    }\n+                }\n+            }\n+        }\n+\n \n         def::DefStatic(node_id, _) =>\n             ExprKind::StaticRef {"}, {"sha": "d6cfd1a2c6ecf532e4452c3b94299acf6a27c498", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -76,6 +76,13 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n         Literal::Value { value: const_eval::eval_const_expr(self.tcx, e) }\n     }\n \n+    pub fn try_const_eval_literal(&mut self, e: &hir::Expr) -> Option<Literal<'tcx>> {\n+        let hint = const_eval::EvalHint::ExprTypeChecked;\n+        const_eval::eval_const_expr_partial(self.tcx, e, hint, None)\n+            .ok()\n+            .map(|v| Literal::Value { value: v })\n+    }\n+\n     pub fn partial_eq(&mut self, ty: Ty<'tcx>) -> ItemRef<'tcx> {\n         let eq_def_id = self.tcx.lang_items.eq_trait().unwrap();\n         self.cmp_method_ref(eq_def_id, \"eq\", ty)\n@@ -132,6 +139,7 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n                         let method_ty = method_ty.ty.subst(self.tcx, &substs);\n                         return ItemRef {\n                             ty: method_ty,\n+                            kind: ItemKind::Method,\n                             def_id: method.def_id,\n                             substs: self.tcx.mk_substs(substs),\n                         };"}, {"sha": "c32efcd1a7dab03c322bae69896453e42678c86b", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -97,7 +97,11 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                                     Literal::Value { value: value }\n                                 } else {\n                                     let substs = self.cx.tcx.mk_substs(Substs::empty());\n-                                    Literal::Item { def_id: def_id, substs: substs }\n+                                    Literal::Item {\n+                                        def_id: def_id,\n+                                        kind: ItemKind::Constant,\n+                                        substs: substs\n+                                    }\n                                 };\n                                 PatternKind::Constant { value: literal }\n                             }"}, {"sha": "99e6d6633f2889c767839c57491b86f5b92f21ed", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -14,7 +14,7 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp};\n+use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, Mutability, UnOp, ItemKind};\n use rustc::middle::def_id::DefId;\n use rustc::middle::region::CodeExtent;\n use rustc::middle::subst::Substs;\n@@ -29,6 +29,7 @@ pub mod cx;\n #[derive(Clone, Debug)]\n pub struct ItemRef<'tcx> {\n     pub ty: Ty<'tcx>,\n+    pub kind: ItemKind,\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n }"}, {"sha": "4b33e50ec52182ee57ec66f4e973c4be25fdd9f3", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -108,12 +108,13 @@ pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &ast::Lit)\n     }\n }\n \n-pub fn trans_constval<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn trans_constval<'blk, 'tcx>(bcx: common::Block<'blk, 'tcx>,\n                                 cv: &ConstVal,\n                                 ty: Ty<'tcx>,\n                                 param_substs: &'tcx Substs<'tcx>)\n                                 -> ValueRef\n {\n+    let ccx = bcx.ccx();\n     let llty = type_of::type_of(ccx, ty);\n     match *cv {\n         ConstVal::Float(v) => C_floating_f64(v, llty),\n@@ -123,19 +124,17 @@ pub fn trans_constval<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n         ConstVal::ByteStr(ref v) => addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n         ConstVal::Struct(id) | ConstVal::Tuple(id) => {\n-            let expr = ccx.tcx().map.expect_expr(id);\n+            let expr = bcx.tcx().map.expect_expr(id);\n             match const_expr(ccx, expr, param_substs, None, TrueConst::Yes) {\n                 Ok((val, _)) => val,\n                 Err(e) => panic!(\"const eval failure: {}\", e.description()),\n             }\n         },\n-        ConstVal::Function(_) => {\n-            unimplemented!()\n+        ConstVal::Array(id, _) | ConstVal::Repeat(id, _) => {\n+            let expr = bcx.tcx().map.expect_expr(id);\n+            expr::trans(bcx, expr).datum.val\n         },\n-        ConstVal::Array(..) => {\n-            unimplemented!()\n-        },\n-        ConstVal::Repeat(..) => {\n+        ConstVal::Function(_) => {\n             unimplemented!()\n         },\n     }"}, {"sha": "d29ab2ee6fbf62383e11f92439e68ce98e89fc53", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -472,7 +472,7 @@ fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n ///\n /// In fact, all virtual calls can be thought of as normal trait calls\n /// that go through this shim function.\n-fn trans_object_shim<'a, 'tcx>(\n+pub fn trans_object_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n     method_id: DefId,"}, {"sha": "38fab1dbf07f9016e02049c0a100af06f03e256a", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -14,7 +14,8 @@ use rustc::mir::repr as mir;\n use trans::consts;\n use trans::common::{self, Block};\n \n-use super::operand::OperandRef;\n+\n+use super::operand::{OperandRef, OperandValue};\n use super::MirContext;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n@@ -24,14 +25,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           ty: Ty<'tcx>)\n                           -> OperandRef<'tcx>\n     {\n-        use super::operand::OperandValue::{Ref, Immediate};\n-\n         let ccx = bcx.ccx();\n-        let val = consts::trans_constval(ccx, cv, ty, bcx.fcx.param_substs);\n+        let val = consts::trans_constval(bcx, cv, ty, bcx.fcx.param_substs);\n         let val = if common::type_is_immediate(ccx, ty) {\n-            Immediate(val)\n+            OperandValue::Immediate(val)\n         } else {\n-            Ref(val)\n+            OperandValue::Ref(val)\n         };\n \n         assert!(!ty.has_erasable_regions());\n@@ -47,13 +46,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           constant: &mir::Constant<'tcx>)\n                           -> OperandRef<'tcx>\n     {\n-        let constant_ty = bcx.monomorphize(&constant.ty);\n+        let ty = bcx.monomorphize(&constant.ty);\n         match constant.literal {\n-            mir::Literal::Item { .. } => {\n-                unimplemented!()\n-            }\n+            mir::Literal::Item { def_id, kind, substs } =>\n+                self.trans_item_ref(bcx, ty, kind, substs, def_id),\n             mir::Literal::Value { ref value } => {\n-                self.trans_constval(bcx, value, constant_ty)\n+                self.trans_constval(bcx, value, ty)\n             }\n         }\n     }"}, {"sha": "368708d470bef12c94aae6d1565160a9b7b62759", "filename": "src/librustc_trans/trans/mir/did.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -0,0 +1,160 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code for translating references to other items (DefIds).\n+\n+use syntax::codemap::DUMMY_SP;\n+use rustc::front::map;\n+use rustc::middle::ty::{self, Ty, HasTypeFlags};\n+use rustc::middle::subst::Substs;\n+use rustc::middle::const_eval;\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::subst;\n+use rustc::middle::traits;\n+use rustc::mir::repr::ItemKind;\n+use trans::common::{Block, fulfill_obligation};\n+use trans::base;\n+use trans::expr;\n+use trans::monomorphize;\n+use trans::meth;\n+use trans::inline;\n+\n+use super::MirContext;\n+use super::operand::{OperandRef, OperandValue};\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    /// Translate reference to item.\n+    pub fn trans_item_ref(&mut self,\n+                          bcx: Block<'bcx, 'tcx>,\n+                          ty: Ty<'tcx>,\n+                          kind: ItemKind,\n+                          substs: &'tcx Substs<'tcx>,\n+                          did: DefId)\n+                          -> OperandRef<'tcx> {\n+        match kind {\n+            ItemKind::Function |\n+            ItemKind::Struct |\n+            ItemKind::Variant => self.trans_fn_ref(bcx, ty, substs, did),\n+            ItemKind::Method => match bcx.tcx().impl_or_trait_item(did).container() {\n+                ty::ImplContainer(_) => self.trans_fn_ref(bcx, ty, substs, did),\n+                ty::TraitContainer(tdid) => self.trans_static_method(bcx, ty, did, tdid, substs)\n+            },\n+            ItemKind::Constant => {\n+                let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n+                let expr = const_eval::lookup_const_by_id(bcx.tcx(), did, None)\n+                            .expect(\"def was const, but lookup_const_by_id failed\");\n+                // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n+                // because we would have somehow adapt const_eval to work on MIR rather than HIR.\n+                let d = expr::trans(bcx, expr);\n+                OperandRef::from_rvalue_datum(d.datum.to_rvalue_datum(d.bcx, \"\").datum)\n+            }\n+        }\n+    }\n+\n+    /// Translates references to a function-like items.\n+    ///\n+    /// That includes regular functions, non-static methods, struct and enum variant constructors,\n+    /// closures and possibly more.\n+    ///\n+    /// This is an adaptation of callee::trans_fn_ref_with_substs.\n+    pub fn trans_fn_ref(&mut self,\n+                        bcx: Block<'bcx, 'tcx>,\n+                        ty: Ty<'tcx>,\n+                        substs: &'tcx Substs<'tcx>,\n+                        did: DefId)\n+                        -> OperandRef<'tcx> {\n+        let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n+\n+        if !substs.types.is_empty() || is_named_tuple_constructor(bcx.tcx(), did) {\n+            let (val, fn_ty, _) = monomorphize::monomorphic_fn(bcx.ccx(), did, substs, None);\n+            // FIXME: cast fnptr to proper type if necessary\n+            OperandRef {\n+                ty: fn_ty,\n+                val: OperandValue::Immediate(val)\n+            }\n+        } else {\n+            let val = if let Some(node_id) = bcx.tcx().map.as_local_node_id(did) {\n+                base::get_item_val(bcx.ccx(), node_id)\n+            } else {\n+                base::trans_external_path(bcx.ccx(), did, ty)\n+            };\n+            // FIXME: cast fnptr to proper type if necessary\n+            OperandRef {\n+                ty: ty,\n+                val: OperandValue::Immediate(val)\n+            }\n+        }\n+    }\n+\n+    /// Translates references to static methods.\n+    ///\n+    /// This is an adaptation of meth::trans_static_method_callee\n+    pub fn trans_static_method(&mut self,\n+                               bcx: Block<'bcx, 'tcx>,\n+                               ty: Ty<'tcx>,\n+                               method_id: DefId,\n+                               trait_id: DefId,\n+                               substs: &'tcx Substs<'tcx>)\n+                               -> OperandRef<'tcx> {\n+        let ccx = bcx.ccx();\n+        let tcx = bcx.tcx();\n+        let mname = tcx.item_name(method_id);\n+        let subst::SeparateVecsPerParamSpace {\n+            types: rcvr_type,\n+            selfs: rcvr_self,\n+            fns: rcvr_method\n+        } = substs.clone().types.split();\n+        let trait_substs = Substs::erased(\n+            subst::VecPerParamSpace::new(rcvr_type, rcvr_self, Vec::new())\n+        );\n+        let trait_substs = tcx.mk_substs(trait_substs);\n+        let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, trait_substs));\n+        let vtbl = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+        match vtbl {\n+            traits::VtableImpl(traits::VtableImplData { impl_def_id, substs: imp_substs, .. }) => {\n+                assert!(!imp_substs.types.needs_infer());\n+                let subst::SeparateVecsPerParamSpace {\n+                    types: impl_type,\n+                    selfs: impl_self,\n+                    fns: _\n+                } = imp_substs.types.split();\n+                let callee_substs = Substs::erased(\n+                    subst::VecPerParamSpace::new(impl_type, impl_self, rcvr_method)\n+                );\n+                let mth = tcx.get_impl_method(impl_def_id, callee_substs, mname);\n+                let mthsubsts = tcx.mk_substs(mth.substs);\n+                self.trans_fn_ref(bcx, ty, mthsubsts, mth.method.def_id)\n+            },\n+            traits::VtableObject(ref data) => {\n+                let idx = traits::get_vtable_index_of_object_method(tcx, data, method_id);\n+                OperandRef::from_rvalue_datum(\n+                    meth::trans_object_shim(ccx, data.upcast_trait_ref.clone(), method_id, idx)\n+                )\n+            }\n+            _ => {\n+                tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\", vtbl));\n+            }\n+        }\n+   }\n+}\n+\n+fn is_named_tuple_constructor(tcx: &ty::ctxt, def_id: DefId) -> bool {\n+    let node_id = match tcx.map.as_local_node_id(def_id) {\n+        Some(n) => n,\n+        None => { return false; }\n+    };\n+    match tcx.map.find(node_id).expect(\"local item should be in ast map\") {\n+        map::NodeVariant(v) => {\n+            v.node.data.is_tuple()\n+        }\n+        map::NodeStructCtor(_) => true,\n+        _ => false\n+    }\n+}"}, {"sha": "0ed76ebeb4362aabde20923530a8111e42260ae6", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -192,3 +192,4 @@ mod lvalue;\n mod rvalue;\n mod operand;\n mod statement;\n+mod did;"}, {"sha": "3a3087b478852166f4a121a033ea05af45b07a12", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -76,6 +76,16 @@ impl<'tcx> OperandRef<'tcx> {\n             }\n         }\n     }\n+\n+    pub fn from_rvalue_datum(datum: datum::Datum<'tcx, datum::Rvalue>) -> OperandRef {\n+        OperandRef {\n+            ty: datum.ty,\n+            val: match datum.kind.mode {\n+                datum::RvalueMode::ByRef => OperandValue::Ref(datum.val),\n+                datum::RvalueMode::ByValue => OperandValue::Immediate(datum.val),\n+            }\n+        }\n+    }\n }\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {"}, {"sha": "4cad98004d7e46563064ac716a2020289261461c", "filename": "src/test/auxiliary/mir_external_refs.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Ftest%2Fauxiliary%2Fmir_external_refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Ftest%2Fauxiliary%2Fmir_external_refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmir_external_refs.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+pub struct S(pub u8);\n+\n+impl S {\n+    pub fn hey() -> u8 { 24 }\n+}\n+\n+pub trait X {\n+    fn hoy(&self) -> u8 { 25 }\n+}\n+\n+impl X for S {}\n+\n+pub enum E {\n+    U(u8)\n+}\n+\n+pub fn regular_fn() -> u8 { 12 }"}, {"sha": "2da1a7587096433a3a95dab0900b1c9ef5fc9335", "filename": "src/test/run-pass/mir_refs_correct.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eadabd9f8818c562446751a0ef03ea2165e7056/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs?ref=4eadabd9f8818c562446751a0ef03ea2165e7056", "patch": "@@ -0,0 +1,218 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+// aux-build:mir_external_refs.rs\n+\n+\n+extern crate mir_external_refs as ext;\n+\n+struct S(u8);\n+\n+impl S {\n+    fn hey() -> u8 { 42 }\n+    fn hey2(&self) -> u8 { 44 }\n+}\n+\n+trait X {\n+    fn hoy(&self) -> u8 { 43 }\n+    fn hoy2() -> u8 { 45 }\n+}\n+\n+trait F<U> {\n+    fn f(self, other: U) -> u64;\n+}\n+\n+impl F<u32> for u32 {\n+    fn f(self, other: u32) -> u64 { self as u64 + other as u64 }\n+}\n+\n+impl F<u64> for u32 {\n+    fn f(self, other: u64) -> u64 { self as u64 - other }\n+}\n+\n+impl F<u64> for u64 {\n+    fn f(self, other: u64) -> u64 { self * other }\n+}\n+\n+impl F<u32> for u64 {\n+    fn f(self, other: u32) -> u64 { self ^ other as u64 }\n+}\n+\n+trait T<I, O> {\n+    fn staticmeth(i: I, o: O) -> (I, O) { (i, o) }\n+}\n+\n+impl<I, O> T<I, O> for O {}\n+\n+impl X for S {}\n+\n+enum E {\n+    U(u8)\n+}\n+\n+const C: u8 = 84;\n+const C2: [u8; 5] = [42; 5];\n+const C3: [u8; 3] = [42, 41, 40];\n+\n+fn regular() -> u8 {\n+    21\n+}\n+\n+fn parametric<T>(u: T) -> T {\n+    u\n+}\n+\n+#[rustc_mir]\n+fn t1() -> fn()->u8 {\n+    regular\n+}\n+\n+#[rustc_mir]\n+fn t2() -> fn(u8)->E {\n+    E::U\n+}\n+\n+#[rustc_mir]\n+fn t3() -> fn(u8)->S {\n+    S\n+}\n+\n+#[rustc_mir]\n+fn t4() -> fn()->u8 {\n+    S::hey\n+}\n+\n+#[rustc_mir]\n+fn t5() -> fn(&S)-> u8 {\n+    <S as X>::hoy\n+}\n+\n+\n+#[rustc_mir]\n+fn t6() -> fn()->u8{\n+    ext::regular_fn\n+}\n+\n+#[rustc_mir]\n+fn t7() -> fn(u8)->ext::E {\n+    ext::E::U\n+}\n+\n+#[rustc_mir]\n+fn t8() -> fn(u8)->ext::S {\n+    ext::S\n+}\n+\n+#[rustc_mir]\n+fn t9() -> fn()->u8 {\n+    ext::S::hey\n+}\n+\n+#[rustc_mir]\n+fn t10() -> fn(&ext::S)->u8 {\n+    <ext::S as ext::X>::hoy\n+}\n+\n+#[rustc_mir]\n+fn t11() -> fn(u8)->u8 {\n+    parametric\n+}\n+\n+#[rustc_mir]\n+fn t12() -> u8 {\n+    C\n+}\n+\n+#[rustc_mir]\n+fn t13() -> [u8; 5] {\n+    C2\n+}\n+\n+#[rustc_mir]\n+fn t13_2() -> [u8; 3] {\n+    C3\n+}\n+\n+#[rustc_mir]\n+fn t14() -> fn()-> u8 {\n+    <S as X>::hoy2\n+}\n+\n+#[rustc_mir]\n+fn t15() -> fn(&S)-> u8 {\n+    S::hey2\n+}\n+\n+#[rustc_mir]\n+fn t16() -> fn(u32, u32)->u64 {\n+    F::f\n+}\n+\n+#[rustc_mir]\n+fn t17() -> fn(u32, u64)->u64 {\n+    F::f\n+}\n+\n+#[rustc_mir]\n+fn t18() -> fn(u64, u64)->u64 {\n+    F::f\n+}\n+\n+#[rustc_mir]\n+fn t19() -> fn(u64, u32)->u64 {\n+    F::f\n+}\n+\n+#[rustc_mir]\n+fn t20() -> fn(u64, u32)->(u64, u32) {\n+    <u32 as T<_, _>>::staticmeth\n+}\n+\n+fn main(){\n+    unsafe {\n+        assert_eq!(t1()(), regular());\n+\n+        assert!(::std::mem::transmute::<_, *mut ()>(t2()) ==\n+                ::std::mem::transmute::<_, *mut ()>(E::U));\n+        assert!(::std::mem::transmute::<_, *mut ()>(t3()) ==\n+                ::std::mem::transmute::<_, *mut ()>(S));\n+\n+        assert_eq!(t4()(), S::hey());\n+        let s = S(42);\n+        assert_eq!(t5()(&s), <S as X>::hoy(&s));\n+\n+\n+        assert_eq!(t6()(), ext::regular_fn());\n+        assert!(::std::mem::transmute::<_, *mut ()>(t7()) ==\n+                ::std::mem::transmute::<_, *mut ()>(ext::E::U));\n+        assert!(::std::mem::transmute::<_, *mut ()>(t8()) ==\n+                ::std::mem::transmute::<_, *mut ()>(ext::S));\n+\n+        assert_eq!(t9()(), ext::S::hey());\n+        let sext = ext::S(6);\n+        assert_eq!(t10()(&sext), <ext::S as ext::X>::hoy(&sext));\n+\n+        let p = parametric::<u8>;\n+        assert!(::std::mem::transmute::<_, *mut ()>(t11()) ==\n+                ::std::mem::transmute::<_, *mut ()>(p));\n+\n+        assert_eq!(t12(), C);\n+        assert_eq!(t13(), C2);\n+        assert_eq!(t13_2(), C3);\n+\n+        assert_eq!(t14()(), <S as X>::hoy2());\n+        assert_eq!(t15()(&s), S::hey2(&s));\n+        assert_eq!(t16()(10u32, 20u32), F::f(10u32, 20u32));\n+        assert_eq!(t17()(30u32, 10u64), F::f(30u32, 10u64));\n+        assert_eq!(t18()(50u64, 5u64), F::f(50u64, 5u64));\n+        assert_eq!(t19()(322u64, 2u32), F::f(322u64, 2u32));\n+        assert_eq!(t20()(123u64, 38u32), <u32 as T<_, _>>::staticmeth(123, 38));\n+    }\n+}"}]}