{"sha": "f1a87014820ba13b3c2fd47749e480cc545c4d45", "node_id": "C_kwDOAAsO6NoAKGYxYTg3MDE0ODIwYmExM2IzYzJmZDQ3NzQ5ZTQ4MGNjNTQ1YzRkNDU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-16T09:55:02Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-17T10:58:14Z"}, "message": "clean up retagging recursive traversal a bit", "tree": {"sha": "eb926fc50d183c2ad076d1a08e0b15c6a440f36e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb926fc50d183c2ad076d1a08e0b15c6a440f36e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1a87014820ba13b3c2fd47749e480cc545c4d45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1a87014820ba13b3c2fd47749e480cc545c4d45", "html_url": "https://github.com/rust-lang/rust/commit/f1a87014820ba13b3c2fd47749e480cc545c4d45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1a87014820ba13b3c2fd47749e480cc545c4d45/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afab05b931631185270c3a2890c85645a42594bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/afab05b931631185270c3a2890c85645a42594bb", "html_url": "https://github.com/rust-lang/rust/commit/afab05b931631185270c3a2890c85645a42594bb"}], "stats": {"total": 97, "additions": 49, "deletions": 48}, "files": [{"sha": "f2e2df5ad08004c1711256d94d7d5ebe09c4f6d0", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 49, "deletions": 48, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f1a87014820ba13b3c2fd47749e480cc545c4d45/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a87014820ba13b3c2fd47749e480cc545c4d45/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=f1a87014820ba13b3c2fd47749e480cc545c4d45", "patch": "@@ -14,7 +14,6 @@ use rustc_middle::mir::RetagKind;\n use rustc_middle::ty::{\n     self,\n     layout::{HasParamEnv, LayoutOf},\n-    Ty,\n };\n use rustc_target::abi::Abi;\n use rustc_target::abi::Size;\n@@ -983,28 +982,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let mut visitor = RetagVisitor { ecx: this, kind, retag_cause, retag_fields };\n         return visitor.visit_value(place);\n \n-        // Determine mutability and whether to add a protector.\n-        // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n-        // making it useless.\n-        fn qualify(ty: Ty<'_>, kind: RetagKind) -> Option<(RefKind, bool)> {\n-            match ty.kind() {\n-                // References are simple.\n-                ty::Ref(_, _, Mutability::Mut) =>\n-                    Some((\n-                        RefKind::Unique { two_phase: kind == RetagKind::TwoPhase },\n-                        kind == RetagKind::FnEntry,\n-                    )),\n-                ty::Ref(_, _, Mutability::Not) =>\n-                    Some((RefKind::Shared, kind == RetagKind::FnEntry)),\n-                // Raw pointers need to be enabled.\n-                ty::RawPtr(tym) if kind == RetagKind::Raw =>\n-                    Some((RefKind::Raw { mutable: tym.mutbl == Mutability::Mut }, false)),\n-                // Boxes are handled separately due to that allocator situation,\n-                // see the visitor below.\n-                _ => None,\n-            }\n-        }\n-\n         // The actual visitor.\n         struct RetagVisitor<'ecx, 'mir, 'tcx> {\n             ecx: &'ecx mut MiriInterpCx<'mir, 'tcx>,\n@@ -1057,34 +1034,58 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     return Ok(());\n                 }\n \n-                let recurse_for_fields = || {\n-                    match self.retag_fields {\n-                        RetagFields::No => false,\n-                        RetagFields::Yes => true,\n-                        RetagFields::OnlyScalar => {\n-                            // Matching `ArgAbi::new` at the time of writing, only fields of\n-                            // `Scalar` and `ScalarPair` ABI are considered.\n-                            matches!(place.layout.abi, Abi::Scalar(..) | Abi::ScalarPair(..))\n+                // Check the type of this value to see what to do with it (retag, or recurse).\n+                match place.layout.ty.kind() {\n+                    ty::Ref(_, _, mutbl) => {\n+                        let ref_kind = match mutbl {\n+                            Mutability::Mut =>\n+                                RefKind::Unique { two_phase: self.kind == RetagKind::TwoPhase },\n+                            Mutability::Not => RefKind::Shared,\n+                        };\n+                        self.retag_place(\n+                            place,\n+                            ref_kind,\n+                            self.retag_cause,\n+                            /*protector*/ self.kind == RetagKind::FnEntry,\n+                        )?;\n+                    }\n+                    ty::RawPtr(tym) => {\n+                        // We definitely do *not* want to recurse into raw pointers -- wide raw\n+                        // pointers have fields, and for dyn Trait pointees those can have reference\n+                        // type!\n+                        if self.kind == RetagKind::Raw {\n+                            // Raw pointers need to be enabled.\n+                            self.retag_place(\n+                                place,\n+                                RefKind::Raw { mutable: tym.mutbl == Mutability::Mut },\n+                                self.retag_cause,\n+                                /*protector*/ false,\n+                            )?;\n+                        }\n+                    }\n+                    _ if place.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_box()) => {\n+                        // Recurse for boxes, they require some tricky handling and will end up in `visit_box` above.\n+                        // (Yes this means we technically also recursively retag the allocator itself\n+                        // even if field retagging is not enabled. *shrug*)\n+                        self.walk_value(place)?;\n+                    }\n+                    _ => {\n+                        // Not a reference/pointer/box. Only recurse if configured appropriately.\n+                        let recurse = match self.retag_fields {\n+                            RetagFields::No => false,\n+                            RetagFields::Yes => true,\n+                            RetagFields::OnlyScalar => {\n+                                // Matching `ArgAbi::new` at the time of writing, only fields of\n+                                // `Scalar` and `ScalarPair` ABI are considered.\n+                                matches!(place.layout.abi, Abi::Scalar(..) | Abi::ScalarPair(..))\n+                            }\n+                        };\n+                        if recurse {\n+                            self.walk_value(place)?;\n                         }\n                     }\n-                };\n-\n-                if let Some((ref_kind, protector)) = qualify(place.layout.ty, self.kind) {\n-                    self.retag_place(place, ref_kind, self.retag_cause, protector)?;\n-                } else if matches!(place.layout.ty.kind(), ty::RawPtr(..)) {\n-                    // Wide raw pointers *do* have fields and their types are strange.\n-                    // vtables have a type like `&[*const (); 3]` or so!\n-                    // Do *not* recurse into them.\n-                    // (No need to worry about wide references, those always \"qualify\". And Boxes\n-                    // are handles specially by the visitor anyway.)\n-                } else if recurse_for_fields()\n-                    || place.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_box())\n-                {\n-                    // Recurse deeper. Need to always recurse for `Box` to even hit `visit_box`.\n-                    // (Yes this means we technically also recursively retag the allocator itself\n-                    // even if field retagging is not enabled. *shrug*)\n-                    self.walk_value(place)?;\n                 }\n+\n                 Ok(())\n             }\n         }"}]}