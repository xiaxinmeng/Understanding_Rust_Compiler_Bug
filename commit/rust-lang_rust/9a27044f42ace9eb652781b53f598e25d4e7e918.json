{"sha": "9a27044f42ace9eb652781b53f598e25d4e7e918", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMjcwNDRmNDJhY2U5ZWI2NTI3ODFiNTNmNTk4ZTI1ZDRlN2U5MTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-06T04:13:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-06T04:13:52Z"}, "message": "Auto merge of #86644 - Stupremee:replace-fakedefids-with-itemid, r=jyn514\n\nrustdoc: Replace `FakeDefId` with new `ItemId` type\n\nFollow up from #84707\n\n`@Manishearth` [suggested](https://github.com/rust-lang/rust/pull/84707#issuecomment-831994669) that there should be a new `ItemId` type that can distinguish between auto traits, normal ids, and blanket impls instead of using `FakeDefId`s.\n\nThis type is introduced by this PR.\n\nThere are still some `FIXME`s left, because I was unsure what the best solution for them would be.\n\nEspecially the naming in general now is a bit weird right now and needs to be cleaned up. Now there are no \"fake\" ids so the `is_fake` method on `Item` does not really make sense and maybe the methods on `ItemId` should be renamed too?\n\nAlso, we need to represent the new item ids in the JSON backend somehow.", "tree": {"sha": "4dee16475fbacbb691006f2c7306724ff8e3e280", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dee16475fbacbb691006f2c7306724ff8e3e280"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a27044f42ace9eb652781b53f598e25d4e7e918", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a27044f42ace9eb652781b53f598e25d4e7e918", "html_url": "https://github.com/rust-lang/rust/commit/9a27044f42ace9eb652781b53f598e25d4e7e918", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a27044f42ace9eb652781b53f598e25d4e7e918/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5a406bb665213a0ceb6980921a39617d35a2e2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5a406bb665213a0ceb6980921a39617d35a2e2d", "html_url": "https://github.com/rust-lang/rust/commit/d5a406bb665213a0ceb6980921a39617d35a2e2d"}, {"sha": "a89912c8c3a97e5d3b50833984d8dbe23a2fdf52", "url": "https://api.github.com/repos/rust-lang/rust/commits/a89912c8c3a97e5d3b50833984d8dbe23a2fdf52", "html_url": "https://github.com/rust-lang/rust/commit/a89912c8c3a97e5d3b50833984d8dbe23a2fdf52"}], "stats": {"total": 367, "additions": 188, "deletions": 179}, "files": [{"sha": "e479d162b8ffb85419057c7e8a562f4a1f28ad62", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             name: None,\n             attrs: Default::default(),\n             visibility: Inherited,\n-            def_id: FakeDefId::new_fake(item_def_id.krate),\n+            def_id: ItemId::Auto { trait_: trait_def_id, for_: item_def_id },\n             kind: box ImplItem(Impl {\n                 span: Span::dummy(),\n                 unsafety: hir::Unsafety::Normal,"}, {"sha": "c257d362694feffdb4d225a591fa0f7c1c5f702c", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     name: None,\n                     attrs: Default::default(),\n                     visibility: Inherited,\n-                    def_id: FakeDefId::new_fake(item_def_id.krate),\n+                    def_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n                     kind: box ImplItem(Impl {\n                         span: self.cx.tcx.def_span(impl_def_id).clean(self.cx),\n                         unsafety: hir::Unsafety::Normal,"}, {"sha": "175c7facfdbeb7c89430ba66504c8239fcb6c307", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -15,7 +15,7 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::clean::{\n-    self, utils, Attributes, AttributesExt, FakeDefId, GetDefId, NestedAttributesExt, Type,\n+    self, utils, Attributes, AttributesExt, GetDefId, ItemId, NestedAttributesExt, Type,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -483,10 +483,11 @@ fn build_module(\n             }\n             if let Res::PrimTy(p) = item.res {\n                 // Primitive types can't be inlined so generate an import instead.\n+                let prim_ty = clean::PrimitiveType::from(p);\n                 items.push(clean::Item {\n                     name: None,\n                     attrs: box clean::Attributes::default(),\n-                    def_id: FakeDefId::new_fake(did.krate),\n+                    def_id: ItemId::Primitive(prim_ty, did.krate),\n                     visibility: clean::Public,\n                     kind: box clean::ImportItem(clean::Import::new_simple(\n                         item.ident.name,\n@@ -495,7 +496,7 @@ fn build_module(\n                                 global: false,\n                                 res: item.res,\n                                 segments: vec![clean::PathSegment {\n-                                    name: clean::PrimitiveType::from(p).as_sym(),\n+                                    name: prim_ty.as_sym(),\n                                     args: clean::GenericArgs::AngleBracketed {\n                                         args: Vec::new(),\n                                         bindings: Vec::new(),"}, {"sha": "e716e09b8b3f0280985c57e4436a9fe231595b71", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 39, "deletions": 50, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -1,4 +1,4 @@\n-use std::cell::{Cell, RefCell};\n+use std::cell::RefCell;\n use std::default::Default;\n use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n@@ -48,73 +48,68 @@ use self::ItemKind::*;\n use self::SelfTy::*;\n use self::Type::*;\n \n-crate type FakeDefIdSet = FxHashSet<FakeDefId>;\n+crate type ItemIdSet = FxHashSet<ItemId>;\n \n-#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n-crate enum FakeDefId {\n-    Real(DefId),\n-    Fake(DefIndex, CrateNum),\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, Copy)]\n+crate enum ItemId {\n+    /// A \"normal\" item that uses a [`DefId`] for identification.\n+    DefId(DefId),\n+    /// Identifier that is used for auto traits.\n+    Auto { trait_: DefId, for_: DefId },\n+    /// Identifier that is used for blanket implementations.\n+    Blanket { impl_id: DefId, for_: DefId },\n+    /// Identifier for primitive types.\n+    Primitive(PrimitiveType, CrateNum),\n }\n \n-impl FakeDefId {\n-    #[cfg(parallel_compiler)]\n-    crate fn new_fake(crate: CrateNum) -> Self {\n-        unimplemented!(\"\")\n-    }\n-\n-    #[cfg(not(parallel_compiler))]\n-    crate fn new_fake(krate: CrateNum) -> Self {\n-        thread_local!(static FAKE_DEF_ID_COUNTER: Cell<usize> = Cell::new(0));\n-        let id = FAKE_DEF_ID_COUNTER.with(|id| {\n-            let tmp = id.get();\n-            id.set(tmp + 1);\n-            tmp\n-        });\n-        Self::Fake(DefIndex::from(id), krate)\n-    }\n-\n+impl ItemId {\n     #[inline]\n     crate fn is_local(self) -> bool {\n         match self {\n-            FakeDefId::Real(id) => id.is_local(),\n-            FakeDefId::Fake(_, krate) => krate == LOCAL_CRATE,\n+            ItemId::Auto { for_: id, .. }\n+            | ItemId::Blanket { for_: id, .. }\n+            | ItemId::DefId(id) => id.is_local(),\n+            ItemId::Primitive(_, krate) => krate == LOCAL_CRATE,\n         }\n     }\n \n     #[inline]\n     #[track_caller]\n-    crate fn expect_real(self) -> rustc_hir::def_id::DefId {\n-        self.as_real().unwrap_or_else(|| panic!(\"FakeDefId::expect_real: `{:?}` isn't real\", self))\n+    crate fn expect_def_id(self) -> DefId {\n+        self.as_def_id()\n+            .unwrap_or_else(|| panic!(\"ItemId::expect_def_id: `{:?}` isn't a DefId\", self))\n     }\n \n     #[inline]\n-    crate fn as_real(self) -> Option<DefId> {\n+    crate fn as_def_id(self) -> Option<DefId> {\n         match self {\n-            FakeDefId::Real(id) => Some(id),\n-            FakeDefId::Fake(_, _) => None,\n+            ItemId::DefId(id) => Some(id),\n+            _ => None,\n         }\n     }\n \n     #[inline]\n     crate fn krate(self) -> CrateNum {\n         match self {\n-            FakeDefId::Real(id) => id.krate,\n-            FakeDefId::Fake(_, krate) => krate,\n+            ItemId::Auto { for_: id, .. }\n+            | ItemId::Blanket { for_: id, .. }\n+            | ItemId::DefId(id) => id.krate,\n+            ItemId::Primitive(_, krate) => krate,\n         }\n     }\n \n     #[inline]\n     crate fn index(self) -> Option<DefIndex> {\n         match self {\n-            FakeDefId::Real(id) => Some(id.index),\n-            FakeDefId::Fake(_, _) => None,\n+            ItemId::DefId(id) => Some(id.index),\n+            _ => None,\n         }\n     }\n }\n \n-impl From<DefId> for FakeDefId {\n+impl From<DefId> for ItemId {\n     fn from(id: DefId) -> Self {\n-        Self::Real(id)\n+        Self::DefId(id)\n     }\n }\n \n@@ -338,14 +333,14 @@ crate struct Item {\n     /// Information about this item that is specific to what kind of item it is.\n     /// E.g., struct vs enum vs function.\n     crate kind: Box<ItemKind>,\n-    crate def_id: FakeDefId,\n+    crate def_id: ItemId,\n \n     crate cfg: Option<Arc<Cfg>>,\n }\n \n // `Item` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Item, 48);\n+rustc_data_structures::static_assert_size!(Item, 56);\n \n crate fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n     Span::from_rustc_span(def_id.as_local().map_or_else(\n@@ -359,19 +354,19 @@ crate fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n \n impl Item {\n     crate fn stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<&'tcx Stability> {\n-        if self.is_fake() { None } else { tcx.lookup_stability(self.def_id.expect_real()) }\n+        self.def_id.as_def_id().and_then(|did| tcx.lookup_stability(did))\n     }\n \n     crate fn const_stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<&'tcx ConstStability> {\n-        if self.is_fake() { None } else { tcx.lookup_const_stability(self.def_id.expect_real()) }\n+        self.def_id.as_def_id().and_then(|did| tcx.lookup_const_stability(did))\n     }\n \n     crate fn deprecation(&self, tcx: TyCtxt<'_>) -> Option<Deprecation> {\n-        if self.is_fake() { None } else { tcx.lookup_deprecation(self.def_id.expect_real()) }\n+        self.def_id.as_def_id().and_then(|did| tcx.lookup_deprecation(did))\n     }\n \n     crate fn inner_docs(&self, tcx: TyCtxt<'_>) -> bool {\n-        if self.is_fake() { false } else { tcx.get_attrs(self.def_id.expect_real()).inner_docs() }\n+        self.def_id.as_def_id().map(|did| tcx.get_attrs(did).inner_docs()).unwrap_or(false)\n     }\n \n     crate fn span(&self, tcx: TyCtxt<'_>) -> Span {\n@@ -383,10 +378,8 @@ impl Item {\n             kind\n         {\n             *span\n-        } else if self.is_fake() {\n-            Span::dummy()\n         } else {\n-            rustc_span(self.def_id.expect_real(), tcx)\n+            self.def_id.as_def_id().map(|did| rustc_span(did, tcx)).unwrap_or_else(|| Span::dummy())\n         }\n     }\n \n@@ -551,7 +544,7 @@ impl Item {\n     }\n \n     crate fn is_crate(&self) -> bool {\n-        self.is_mod() && self.def_id.as_real().map_or(false, |did| did.index == CRATE_DEF_INDEX)\n+        self.is_mod() && self.def_id.as_def_id().map_or(false, |did| did.index == CRATE_DEF_INDEX)\n     }\n     crate fn is_mod(&self) -> bool {\n         self.type_() == ItemType::Module\n@@ -662,10 +655,6 @@ impl Item {\n             _ => false,\n         }\n     }\n-\n-    crate fn is_fake(&self) -> bool {\n-        matches!(self.def_id, FakeDefId::Fake(_, _))\n-    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "0689d72e4e0cf7187f19059995b839bd5071f541", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -30,7 +30,7 @@ use std::mem;\n use std::rc::Rc;\n \n use crate::clean::inline::build_external_trait;\n-use crate::clean::{self, FakeDefId, TraitWithExtraInfo};\n+use crate::clean::{self, ItemId, TraitWithExtraInfo};\n use crate::config::{Options as RustdocOptions, OutputFormat, RenderOptions};\n use crate::formats::cache::Cache;\n use crate::passes::{self, Condition::*, ConditionalPass};\n@@ -78,7 +78,7 @@ crate struct DocContext<'tcx> {\n     /// This same cache is used throughout rustdoc, including in [`crate::html::render`].\n     crate cache: Cache,\n     /// Used by [`clean::inline`] to tell if an item has already been inlined.\n-    crate inlined: FxHashSet<FakeDefId>,\n+    crate inlined: FxHashSet<ItemId>,\n     /// Used by `calculate_doc_coverage`.\n     crate output_format: OutputFormat,\n }\n@@ -128,12 +128,13 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Like `hir().local_def_id_to_hir_id()`, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    crate fn as_local_hir_id(tcx: TyCtxt<'_>, def_id: FakeDefId) -> Option<HirId> {\n+    crate fn as_local_hir_id(tcx: TyCtxt<'_>, def_id: ItemId) -> Option<HirId> {\n         match def_id {\n-            FakeDefId::Real(real_id) => {\n+            ItemId::DefId(real_id) => {\n                 real_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n             }\n-            FakeDefId::Fake(_, _) => None,\n+            // FIXME: Can this be `Some` for `Auto` or `Blanket`?\n+            _ => None,\n         }\n     }\n }"}, {"sha": "e7d6e5ac2c24be1f3d635c04165d29b02fc358cc", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n-use crate::clean::{self, FakeDefId, GetDefId};\n+use crate::clean::{self, GetDefId, ItemId};\n use crate::fold::DocFolder;\n use crate::formats::item_type::ItemType;\n use crate::formats::Impl;\n@@ -122,7 +122,7 @@ crate struct Cache {\n     /// All intra-doc links resolved so far.\n     ///\n     /// Links are indexed by the DefId of the item they document.\n-    crate intra_doc_links: BTreeMap<FakeDefId, Vec<clean::ItemLink>>,\n+    crate intra_doc_links: FxHashMap<ItemId, Vec<clean::ItemLink>>,\n }\n \n /// This struct is used to wrap the `cache` and `tcx` in order to run `DocFolder`.\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         // Propagate a trait method's documentation to all implementors of the\n         // trait.\n         if let clean::TraitItem(ref t) = *item.kind {\n-            self.cache.traits.entry(item.def_id.expect_real()).or_insert_with(|| {\n+            self.cache.traits.entry(item.def_id.expect_def_id()).or_insert_with(|| {\n                 clean::TraitWithExtraInfo {\n                     trait_: t.clone(),\n                     is_notable: item.attrs.has_doc_flag(sym::notable_trait),\n@@ -348,11 +348,11 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     // `public_items` map, so we can skip inserting into the\n                     // paths map if there was already an entry present and we're\n                     // not a public item.\n-                    if !self.cache.paths.contains_key(&item.def_id.expect_real())\n-                        || self.cache.access_levels.is_public(item.def_id.expect_real())\n+                    if !self.cache.paths.contains_key(&item.def_id.expect_def_id())\n+                        || self.cache.access_levels.is_public(item.def_id.expect_def_id())\n                     {\n                         self.cache.paths.insert(\n-                            item.def_id.expect_real(),\n+                            item.def_id.expect_def_id(),\n                             (self.cache.stack.clone(), item.type_()),\n                         );\n                     }\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             clean::PrimitiveItem(..) => {\n                 self.cache\n                     .paths\n-                    .insert(item.def_id.expect_real(), (self.cache.stack.clone(), item.type_()));\n+                    .insert(item.def_id.expect_def_id(), (self.cache.stack.clone(), item.type_()));\n             }\n \n             clean::ExternCrateItem { .. }\n@@ -391,7 +391,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             | clean::StructItem(..)\n             | clean::UnionItem(..)\n             | clean::VariantItem(..) => {\n-                self.cache.parent_stack.push(item.def_id.expect_real());\n+                self.cache.parent_stack.push(item.def_id.expect_def_id());\n                 self.cache.parent_is_trait_impl = false;\n                 true\n             }"}, {"sha": "c08fe47696bf1b85115949e7938a5afe1b0cfb7a", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -19,7 +19,7 @@ use rustc_span::def_id::CRATE_DEF_INDEX;\n use rustc_target::spec::abi::Abi;\n \n use crate::clean::{\n-    self, utils::find_nearest_parent_module, ExternalCrate, FakeDefId, GetDefId, PrimitiveType,\n+    self, utils::find_nearest_parent_module, ExternalCrate, GetDefId, ItemId, PrimitiveType,\n };\n use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n@@ -1181,7 +1181,7 @@ impl clean::FnDecl {\n impl clean::Visibility {\n     crate fn print_with_space<'a, 'tcx: 'a>(\n         self,\n-        item_did: FakeDefId,\n+        item_did: ItemId,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         let to_print = match self {\n@@ -1191,7 +1191,7 @@ impl clean::Visibility {\n                 // FIXME(camelid): This may not work correctly if `item_did` is a module.\n                 //                 However, rustdoc currently never displays a module's\n                 //                 visibility, so it shouldn't matter.\n-                let parent_module = find_nearest_parent_module(cx.tcx(), item_did.expect_real());\n+                let parent_module = find_nearest_parent_module(cx.tcx(), item_did.expect_def_id());\n \n                 if vis_did.index == CRATE_DEF_INDEX {\n                     \"pub(crate) \".to_owned()"}, {"sha": "61057ff515b169aecd40f9411389021c369ada21", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -230,7 +230,7 @@ impl<'tcx> Context<'tcx> {\n                 &self.shared.style_files,\n             )\n         } else {\n-            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id.expect_real()) {\n+            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id.expect_def_id()) {\n                 let mut path = String::new();\n                 for name in &names[..names.len() - 1] {\n                     path.push_str(name);"}, {"sha": "97ee682c11c4d6a5eb5d6f77a4516a9dcc82313c", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -53,7 +53,7 @@ use rustc_span::symbol::{kw, sym, Symbol};\n use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n \n-use crate::clean::{self, FakeDefId, GetDefId, RenderedLink, SelfTy};\n+use crate::clean::{self, GetDefId, ItemId, RenderedLink, SelfTy};\n use crate::docfs::PathError;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n@@ -735,7 +735,7 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cx: &Context<'_>)\n         AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n         AssocItemLink::Anchor(None) => anchor,\n         AssocItemLink::GotoSource(did, _) => {\n-            href(did.expect_real(), cx).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n+            href(did.expect_def_id(), cx).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n         }\n     }\n }\n@@ -867,7 +867,7 @@ fn render_assoc_item(\n                     ItemType::TyMethod\n                 };\n \n-                href(did.expect_real(), cx)\n+                href(did.expect_def_id(), cx)\n                     .map(|p| format!(\"{}#{}.{}\", p.0, ty, name))\n                     .unwrap_or_else(|| format!(\"#{}.{}\", ty, name))\n             }\n@@ -987,7 +987,7 @@ fn render_attributes_in_code(w: &mut Buffer, it: &clean::Item) {\n #[derive(Copy, Clone)]\n enum AssocItemLink<'a> {\n     Anchor(Option<&'a str>),\n-    GotoSource(FakeDefId, &'a FxHashSet<Symbol>),\n+    GotoSource(ItemId, &'a FxHashSet<Symbol>),\n }\n \n impl<'a> AssocItemLink<'a> {\n@@ -1819,7 +1819,7 @@ fn small_url_encode(s: String) -> String {\n }\n \n fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n-    let did = it.def_id.expect_real();\n+    let did = it.def_id.expect_def_id();\n     if let Some(v) = cx.cache.impls.get(&did) {\n         let mut used_links = FxHashSet::default();\n         let cache = cx.cache();\n@@ -2109,7 +2109,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n         \"</div>\",\n     );\n \n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_real()) {\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_def_id()) {\n         let cache = cx.cache();\n         let mut res = implementors\n             .iter()"}, {"sha": "eeac9d1a9db76365d87d810ba56b0c5962825ee1", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -289,15 +289,15 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {} as {};\",\n                         myitem.visibility.print_with_space(myitem.def_id, cx),\n-                        anchor(myitem.def_id.expect_real(), &*src.as_str(), cx),\n+                        anchor(myitem.def_id.expect_def_id(), &*src.as_str(), cx),\n                         myitem.name.as_ref().unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {};\",\n                         myitem.visibility.print_with_space(myitem.def_id, cx),\n                         anchor(\n-                            myitem.def_id.expect_real(),\n+                            myitem.def_id.expect_def_id(),\n                             &*myitem.name.as_ref().unwrap().as_str(),\n                             cx\n                         ),\n@@ -669,9 +669,9 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All);\n+    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All);\n \n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_real()) {\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_def_id()) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n@@ -787,7 +787,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         path = if it.def_id.is_local() {\n             cx.current.join(\"/\")\n         } else {\n-            let (ref path, _) = cx.cache.external_paths[&it.def_id.expect_real()];\n+            let (ref path, _) = cx.cache.external_paths[&it.def_id.expect_def_id()];\n             path[..path.len() - 1].join(\"/\")\n         },\n         ty = it.type_(),\n@@ -813,7 +813,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n@@ -834,7 +834,7 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n@@ -851,7 +851,7 @@ fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::T\n \n     document(w, cx, it, None);\n \n-    let def_id = it.def_id.expect_real();\n+    let def_id = it.def_id.expect_def_id();\n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n@@ -903,7 +903,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n             document(w, cx, field, Some(it));\n         }\n     }\n-    let def_id = it.def_id.expect_real();\n+    let def_id = it.def_id.expect_def_id();\n     render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n     document_type_layout(w, cx, def_id);\n }\n@@ -1041,7 +1041,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             }\n         }\n     }\n-    let def_id = it.def_id.expect_real();\n+    let def_id = it.def_id.expect_def_id();\n     render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n     document_type_layout(w, cx, def_id);\n }\n@@ -1093,7 +1093,7 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean\n \n fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n     document(w, cx, it, None);\n-    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n@@ -1182,7 +1182,7 @@ fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n             }\n         }\n     }\n-    let def_id = it.def_id.expect_real();\n+    let def_id = it.def_id.expect_def_id();\n     render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n     document_type_layout(w, cx, def_id);\n }\n@@ -1213,7 +1213,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n \n     document(w, cx, it, None);\n \n-    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n }\n \n fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {"}, {"sha": "bf8db79416b342d92fb6e1108a7c06b0f456ab5c", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -5,17 +5,18 @@\n #![allow(rustc::default_hash_types)]\n \n use std::convert::From;\n+use std::fmt;\n \n use rustc_ast::ast;\n-use rustc_hir::def::CtorKind;\n+use rustc_hir::{def::CtorKind, def_id::DefId};\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::CRATE_DEF_INDEX;\n use rustc_span::Pos;\n \n use rustdoc_json_types::*;\n \n use crate::clean::utils::print_const_expr;\n-use crate::clean::{self, FakeDefId};\n+use crate::clean::{self, ItemId};\n use crate::formats::item_type::ItemType;\n use crate::json::JsonRenderer;\n use std::collections::HashSet;\n@@ -30,7 +31,7 @@ impl JsonRenderer<'_> {\n             .into_iter()\n             .flatten()\n             .filter_map(|clean::ItemLink { link, did, .. }| {\n-                did.map(|did| (link.clone(), from_def_id(did.into())))\n+                did.map(|did| (link.clone(), from_item_id(did.into())))\n             })\n             .collect();\n         let docs = item.attrs.collapsed_doc_value();\n@@ -47,7 +48,7 @@ impl JsonRenderer<'_> {\n             _ => from_clean_item(item, self.tcx),\n         };\n         Some(Item {\n-            id: from_def_id(def_id),\n+            id: from_item_id(def_id),\n             crate_id: def_id.krate().as_u32(),\n             name: name.map(|sym| sym.to_string()),\n             span: self.convert_span(span),\n@@ -86,7 +87,7 @@ impl JsonRenderer<'_> {\n             Inherited => Visibility::Default,\n             Restricted(did) if did.index == CRATE_DEF_INDEX => Visibility::Crate,\n             Restricted(did) => Visibility::Restricted {\n-                parent: from_def_id(did.into()),\n+                parent: from_item_id(did.into()),\n                 path: self.tcx.def_path(did).to_string_no_crate_verbose(),\n             },\n         }\n@@ -170,12 +171,24 @@ impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n     }\n }\n \n-crate fn from_def_id(did: FakeDefId) -> Id {\n+crate fn from_item_id(did: ItemId) -> Id {\n+    struct DisplayDefId(DefId);\n+\n+    impl fmt::Display for DisplayDefId {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            write!(f, \"{}:{}\", self.0.krate.as_u32(), u32::from(self.0.index))\n+        }\n+    }\n+\n     match did {\n-        FakeDefId::Real(did) => Id(format!(\"{}:{}\", did.krate.as_u32(), u32::from(did.index))),\n-        // We need to differentiate real and fake ids, because the indices might overlap for fake\n-        // and real DefId's, which would cause two different Id's treated as they were the same.\n-        FakeDefId::Fake(idx, krate) => Id(format!(\"F{}:{}\", krate.as_u32(), u32::from(idx))),\n+        ItemId::DefId(did) => Id(format!(\"{}\", DisplayDefId(did))),\n+        ItemId::Blanket { for_, impl_id } => {\n+            Id(format!(\"b:{}-{}\", DisplayDefId(impl_id), DisplayDefId(for_)))\n+        }\n+        ItemId::Auto { for_, trait_ } => {\n+            Id(format!(\"a:{}-{}\", DisplayDefId(trait_), DisplayDefId(for_)))\n+        }\n+        ItemId::Primitive(ty, krate) => Id(format!(\"p:{}:{}\", krate.as_u32(), ty.as_sym())),\n     }\n }\n \n@@ -375,7 +388,7 @@ impl FromWithTcx<clean::Type> for Type {\n         match ty {\n             ResolvedPath { path, did, is_generic: _ } => Type::ResolvedPath {\n                 name: path.whole_name(),\n-                id: from_def_id(did.into()),\n+                id: from_item_id(did.into()),\n                 args: path.segments.last().map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n                 param_names: Vec::new(),\n             },\n@@ -387,7 +400,7 @@ impl FromWithTcx<clean::Type> for Type {\n \n                 Type::ResolvedPath {\n                     name: path.whole_name(),\n-                    id: from_def_id(id.into()),\n+                    id: from_item_id(id.into()),\n                     args: path\n                         .segments\n                         .last()\n@@ -568,13 +581,13 @@ impl FromWithTcx<clean::Import> for Import {\n             Simple(s) => Import {\n                 source: import.source.path.whole_name(),\n                 name: s.to_string(),\n-                id: import.source.did.map(FakeDefId::from).map(from_def_id),\n+                id: import.source.did.map(ItemId::from).map(from_item_id),\n                 glob: false,\n             },\n             Glob => Import {\n                 source: import.source.path.whole_name(),\n                 name: import.source.path.last_name().to_string(),\n-                id: import.source.did.map(FakeDefId::from).map(from_def_id),\n+                id: import.source.did.map(ItemId::from).map(from_item_id),\n                 glob: true,\n             },\n         }\n@@ -668,5 +681,5 @@ impl FromWithTcx<ItemType> for ItemKind {\n }\n \n fn ids(items: impl IntoIterator<Item = clean::Item>) -> Vec<Id> {\n-    items.into_iter().filter(|x| !x.is_stripped()).map(|i| from_def_id(i.def_id)).collect()\n+    items.into_iter().filter(|x| !x.is_stripped()).map(|i| from_item_id(i.def_id)).collect()\n }"}, {"sha": "8bdf1a598123043e08f7595f818b7633b920b5d3", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -25,7 +25,7 @@ use crate::error::Error;\n use crate::formats::cache::Cache;\n use crate::formats::FormatRenderer;\n use crate::html::render::cache::ExternalLocation;\n-use crate::json::conversions::{from_def_id, IntoWithTcx};\n+use crate::json::conversions::{from_item_id, IntoWithTcx};\n \n #[derive(Clone)]\n crate struct JsonRenderer<'tcx> {\n@@ -53,7 +53,7 @@ impl JsonRenderer<'tcx> {\n                     .map(|i| {\n                         let item = &i.impl_item;\n                         self.item(item.clone()).unwrap();\n-                        from_def_id(item.def_id)\n+                        from_item_id(item.def_id)\n                     })\n                     .collect()\n             })\n@@ -71,7 +71,7 @@ impl JsonRenderer<'tcx> {\n                         let item = &i.impl_item;\n                         if item.def_id.is_local() {\n                             self.item(item.clone()).unwrap();\n-                            Some(from_def_id(item.def_id))\n+                            Some(from_item_id(item.def_id))\n                         } else {\n                             None\n                         }\n@@ -91,9 +91,9 @@ impl JsonRenderer<'tcx> {\n                     let trait_item = &trait_item.trait_;\n                     trait_item.items.clone().into_iter().for_each(|i| self.item(i).unwrap());\n                     Some((\n-                        from_def_id(id.into()),\n+                        from_item_id(id.into()),\n                         types::Item {\n-                            id: from_def_id(id.into()),\n+                            id: from_item_id(id.into()),\n                             crate_id: id.krate.as_u32(),\n                             name: self\n                                 .cache\n@@ -164,13 +164,13 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         let id = item.def_id;\n         if let Some(mut new_item) = self.convert_item(item) {\n             if let types::ItemEnum::Trait(ref mut t) = new_item.inner {\n-                t.implementors = self.get_trait_implementors(id.expect_real())\n+                t.implementors = self.get_trait_implementors(id.expect_def_id())\n             } else if let types::ItemEnum::Struct(ref mut s) = new_item.inner {\n-                s.impls = self.get_impls(id.expect_real())\n+                s.impls = self.get_impls(id.expect_def_id())\n             } else if let types::ItemEnum::Enum(ref mut e) = new_item.inner {\n-                e.impls = self.get_impls(id.expect_real())\n+                e.impls = self.get_impls(id.expect_def_id())\n             }\n-            let removed = self.index.borrow_mut().insert(from_def_id(id), new_item.clone());\n+            let removed = self.index.borrow_mut().insert(from_item_id(id), new_item.clone());\n \n             // FIXME(adotinthevoid): Currently, the index is duplicated. This is a sanity check\n             // to make sure the items are unique. The main place this happens is when an item, is\n@@ -207,7 +207,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 .chain(self.cache.external_paths.clone().into_iter())\n                 .map(|(k, (path, kind))| {\n                     (\n-                        from_def_id(k.into()),\n+                        from_item_id(k.into()),\n                         types::ItemSummary {\n                             crate_id: k.krate.as_u32(),\n                             path,"}, {"sha": "92e678e4c024ba9f3f67b8f2f3bba8aa35715570", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -213,13 +213,13 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n \n                 let filename = i.span(self.ctx.tcx).filename(self.ctx.sess());\n                 let has_doc_example = tests.found_tests != 0;\n-                // The `expect_real()` should be okay because `local_def_id_to_hir_id`\n+                // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n                 // would presumably panic if a fake `DefIndex` were passed.\n                 let hir_id = self\n                     .ctx\n                     .tcx\n                     .hir()\n-                    .local_def_id_to_hir_id(i.def_id.expect_real().expect_local());\n+                    .local_def_id_to_hir_id(i.def_id.expect_def_id().expect_local());\n                 let (level, source) = self.ctx.tcx.lint_level_at_node(MISSING_DOCS, hir_id);\n                 // `missing_docs` is allow-by-default, so don't treat this as ignoring the item\n                 // unless the user had an explicit `allow`"}, {"sha": "d961340f1f8d3993d0615d8b14d1fc095b430001", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n             return;\n         }\n \n-        let local_id = match item.def_id.as_real().and_then(|x| x.as_local()) {\n+        let local_id = match item.def_id.as_def_id().and_then(|x| x.as_local()) {\n             Some(id) => id,\n             // We don't need to check the syntax for other crates so returning\n             // without doing anything should not be a problem.\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> DocFolder for SyntaxChecker<'a, 'tcx> {\n             let sp = item.attr_span(self.cx.tcx);\n             let extra = crate::html::markdown::ExtraInfo::new_did(\n                 self.cx.tcx,\n-                item.def_id.expect_real(),\n+                item.def_id.expect_def_id(),\n                 sp,\n             );\n             for code_block in markdown::rust_code_blocks(&dox, &extra) {"}, {"sha": "44a3faf6f7be26317fdb6961d4f61ac14c942622", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -830,49 +830,48 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         use rustc_middle::ty::DefIdTree;\n \n-        let parent_node = if item.is_fake() {\n-            None\n-        } else {\n-            find_nearest_parent_module(self.cx.tcx, item.def_id.expect_real())\n-        };\n-\n+        let parent_node =\n+            item.def_id.as_def_id().and_then(|did| find_nearest_parent_module(self.cx.tcx, did));\n         if parent_node.is_some() {\n             trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n         }\n \n         // find item's parent to resolve `Self` in item's docs below\n         debug!(\"looking for the `Self` type\");\n-        let self_id = if item.is_fake() {\n-            None\n-        // Checking if the item is a field in an enum variant\n-        } else if (matches!(self.cx.tcx.def_kind(item.def_id.expect_real()), DefKind::Field)\n-            && matches!(\n-                self.cx.tcx.def_kind(self.cx.tcx.parent(item.def_id.expect_real()).unwrap()),\n-                DefKind::Variant\n-            ))\n-        {\n-            self.cx\n-                .tcx\n-                .parent(item.def_id.expect_real())\n-                .and_then(|item_id| self.cx.tcx.parent(item_id))\n-        } else if matches!(\n-            self.cx.tcx.def_kind(item.def_id.expect_real()),\n-            DefKind::AssocConst\n-                | DefKind::AssocFn\n-                | DefKind::AssocTy\n-                | DefKind::Variant\n-                | DefKind::Field\n-        ) {\n-            self.cx.tcx.parent(item.def_id.expect_real())\n-        // HACK(jynelson): `clean` marks associated types as `TypedefItem`, not as `AssocTypeItem`.\n-        // Fixing this breaks `fn render_deref_methods`.\n-        // As a workaround, see if the parent of the item is an `impl`; if so this must be an associated item,\n-        // regardless of what rustdoc wants to call it.\n-        } else if let Some(parent) = self.cx.tcx.parent(item.def_id.expect_real()) {\n-            let parent_kind = self.cx.tcx.def_kind(parent);\n-            Some(if parent_kind == DefKind::Impl { parent } else { item.def_id.expect_real() })\n-        } else {\n-            Some(item.def_id.expect_real())\n+        let self_id = match item.def_id.as_def_id() {\n+            None => None,\n+            Some(did)\n+                if (matches!(self.cx.tcx.def_kind(did), DefKind::Field)\n+                    && matches!(\n+                        self.cx.tcx.def_kind(self.cx.tcx.parent(did).unwrap()),\n+                        DefKind::Variant\n+                    )) =>\n+            {\n+                self.cx.tcx.parent(did).and_then(|item_id| self.cx.tcx.parent(item_id))\n+            }\n+            Some(did)\n+                if matches!(\n+                    self.cx.tcx.def_kind(did),\n+                    DefKind::AssocConst\n+                        | DefKind::AssocFn\n+                        | DefKind::AssocTy\n+                        | DefKind::Variant\n+                        | DefKind::Field\n+                ) =>\n+            {\n+                self.cx.tcx.parent(did)\n+            }\n+            Some(did) => match self.cx.tcx.parent(did) {\n+                // HACK(jynelson): `clean` marks associated types as `TypedefItem`, not as `AssocTypeItem`.\n+                // Fixing this breaks `fn render_deref_methods`.\n+                // As a workaround, see if the parent of the item is an `impl`; if so this must be an associated item,\n+                // regardless of what rustdoc wants to call it.\n+                Some(parent) => {\n+                    let parent_kind = self.cx.tcx.def_kind(parent);\n+                    Some(if parent_kind == DefKind::Impl { parent } else { did })\n+                }\n+                None => Some(did),\n+            },\n         };\n \n         // FIXME(jynelson): this shouldn't go through stringification, rustdoc should just use the DefId directly\n@@ -897,7 +896,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         let inner_docs = item.inner_docs(self.cx.tcx);\n \n         if item.is_mod() && inner_docs {\n-            self.mod_ids.push(item.def_id.expect_real());\n+            self.mod_ids.push(item.def_id.expect_def_id());\n         }\n \n         // We want to resolve in the lexical scope of the documentation.\n@@ -924,7 +923,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n         Some(if item.is_mod() {\n             if !inner_docs {\n-                self.mod_ids.push(item.def_id.expect_real());\n+                self.mod_ids.push(item.def_id.expect_def_id());\n             }\n \n             let ret = self.fold_item_recur(item);\n@@ -1235,10 +1234,10 @@ impl LinkCollector<'_, '_> {\n             // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n             if let Some((src_id, dst_id)) = id\n                 .as_local()\n-                // The `expect_real()` should be okay because `local_def_id_to_hir_id`\n+                // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n                 // would presumably panic if a fake `DefIndex` were passed.\n                 .and_then(|dst_id| {\n-                    item.def_id.expect_real().as_local().map(|src_id| (src_id, dst_id))\n+                    item.def_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n                 })\n             {\n                 let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);"}, {"sha": "91c495a2bbc069d95cb1c898657bcc3dcdfd7cb1", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -136,10 +136,15 @@ impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n-            if !self.cx.tcx.get_attrs(i.def_id.expect_real()).lists(sym::doc).has_word(sym::hidden)\n+            if !self\n+                .cx\n+                .tcx\n+                .get_attrs(i.def_id.expect_def_id())\n+                .lists(sym::doc)\n+                .has_word(sym::hidden)\n             {\n                 self.impls\n-                    .extend(get_auto_trait_and_blanket_impls(self.cx, i.def_id.expect_real()));\n+                    .extend(get_auto_trait_and_blanket_impls(self.cx, i.def_id.expect_def_id()));\n             }\n         }\n \n@@ -149,7 +154,7 @@ impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n \n #[derive(Default)]\n struct ItemCollector {\n-    items: FxHashSet<FakeDefId>,\n+    items: FxHashSet<ItemId>,\n }\n \n impl ItemCollector {\n@@ -168,7 +173,7 @@ impl DocFolder for ItemCollector {\n \n struct BadImplStripper {\n     prims: FxHashSet<PrimitiveType>,\n-    items: FxHashSet<FakeDefId>,\n+    items: FxHashSet<ItemId>,\n }\n \n impl BadImplStripper {\n@@ -185,7 +190,7 @@ impl BadImplStripper {\n         }\n     }\n \n-    fn keep_impl_with_def_id(&self, did: FakeDefId) -> bool {\n+    fn keep_impl_with_def_id(&self, did: ItemId) -> bool {\n         self.items.contains(&did)\n     }\n }"}, {"sha": "03bc2b52f178f5336d9047485688691d91d4bb70", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -53,7 +53,7 @@ impl crate::doctest::Tester for Tests {\n }\n \n crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n-    if !cx.cache.access_levels.is_public(item.def_id.expect_real())\n+    if !cx.cache.access_levels.is_public(item.def_id.expect_def_id())\n         || matches!(\n             *item.kind,\n             clean::StructFieldItem(_)\n@@ -71,9 +71,9 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n     {\n         return false;\n     }\n-    // The `expect_real()` should be okay because `local_def_id_to_hir_id`\n+    // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n     // would presumably panic if a fake `DefIndex` were passed.\n-    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(item.def_id.expect_real().expect_local());\n+    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(item.def_id.expect_def_id().expect_local());\n     if cx.tcx.hir().attrs(hir_id).lists(sym::doc).has_word(sym::hidden)\n         || inherits_doc_hidden(cx.tcx, hir_id)\n     {\n@@ -107,7 +107,8 @@ crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n                 |lint| lint.build(\"missing code example in this documentation\").emit(),\n             );\n         }\n-    } else if tests.found_tests > 0 && !cx.cache.access_levels.is_public(item.def_id.expect_real())\n+    } else if tests.found_tests > 0\n+        && !cx.cache.access_levels.is_public(item.def_id.expect_def_id())\n     {\n         cx.tcx.struct_span_lint_hir(\n             crate::lint::PRIVATE_DOC_TESTS,"}, {"sha": "0aedbda35e9a8ce26512c8d93056108d811ab4c9", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -2,7 +2,7 @@ use rustc_span::symbol::sym;\n use std::mem;\n \n use crate::clean;\n-use crate::clean::{FakeDefIdSet, Item, NestedAttributesExt};\n+use crate::clean::{Item, ItemIdSet, NestedAttributesExt};\n use crate::core::DocContext;\n use crate::fold::{strip_item, DocFolder};\n use crate::passes::{ImplStripper, Pass};\n@@ -15,7 +15,7 @@ crate const STRIP_HIDDEN: Pass = Pass {\n \n /// Strip items marked `#[doc(hidden)]`\n crate fn strip_hidden(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n-    let mut retained = FakeDefIdSet::default();\n+    let mut retained = ItemIdSet::default();\n \n     // strip all #[doc(hidden)] items\n     let krate = {\n@@ -29,7 +29,7 @@ crate fn strip_hidden(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Cra\n }\n \n struct Stripper<'a> {\n-    retained: &'a mut FakeDefIdSet,\n+    retained: &'a mut ItemIdSet,\n     update_retained: bool,\n }\n "}, {"sha": "dfdba2a4b36664712b11e9b9815e1b00c3c02f6f", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -1,4 +1,4 @@\n-use crate::clean::{self, FakeDefIdSet};\n+use crate::clean::{self, ItemIdSet};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::{ImplStripper, ImportStripper, Pass, Stripper};\n@@ -14,7 +14,7 @@ crate const STRIP_PRIVATE: Pass = Pass {\n /// crate, specified by the `xcrate` flag.\n crate fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n-    let mut retained = FakeDefIdSet::default();\n+    let mut retained = ItemIdSet::default();\n \n     // strip all private items\n     {"}, {"sha": "4305268c9aab051991d6cff42ebff6ee46abf507", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a27044f42ace9eb652781b53f598e25d4e7e918/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=9a27044f42ace9eb652781b53f598e25d4e7e918", "patch": "@@ -2,11 +2,11 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::middle::privacy::AccessLevels;\n use std::mem;\n \n-use crate::clean::{self, FakeDefIdSet, GetDefId, Item};\n+use crate::clean::{self, GetDefId, Item, ItemIdSet};\n use crate::fold::{strip_item, DocFolder};\n \n crate struct Stripper<'a> {\n-    crate retained: &'a mut FakeDefIdSet,\n+    crate retained: &'a mut ItemIdSet,\n     crate access_levels: &'a AccessLevels<DefId>,\n     crate update_retained: bool,\n }\n@@ -42,7 +42,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::TraitAliasItem(..)\n             | clean::ForeignTypeItem => {\n                 if i.def_id.is_local() {\n-                    if !self.access_levels.is_exported(i.def_id.expect_real()) {\n+                    if !self.access_levels.is_exported(i.def_id.expect_def_id()) {\n                         debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                         return None;\n                     }\n@@ -116,7 +116,7 @@ impl<'a> DocFolder for Stripper<'a> {\n \n /// This stripper discards all impls which reference stripped items\n crate struct ImplStripper<'a> {\n-    crate retained: &'a FakeDefIdSet,\n+    crate retained: &'a ItemIdSet,\n }\n \n impl<'a> DocFolder for ImplStripper<'a> {"}]}