{"sha": "de82bde00dbf1d293eaac9f86e3e7c7967888263", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlODJiZGUwMGRiZjFkMjkzZWFhYzlmODZlM2U3Yzc5Njc4ODgyNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-05T11:22:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-05T11:22:34Z"}, "message": "auto merge of #6944 : pcwalton/rust/multiple-patterns-in-let, r=nikomatsakis\n\nr? @nikomatsakis", "tree": {"sha": "1e738ee1a533e43733225d9a66b065fb550b6dc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e738ee1a533e43733225d9a66b065fb550b6dc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de82bde00dbf1d293eaac9f86e3e7c7967888263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de82bde00dbf1d293eaac9f86e3e7c7967888263", "html_url": "https://github.com/rust-lang/rust/commit/de82bde00dbf1d293eaac9f86e3e7c7967888263", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de82bde00dbf1d293eaac9f86e3e7c7967888263/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9873f67e944f2f9237caa3c670cbaa0ca988c9d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9873f67e944f2f9237caa3c670cbaa0ca988c9d0", "html_url": "https://github.com/rust-lang/rust/commit/9873f67e944f2f9237caa3c670cbaa0ca988c9d0"}, {"sha": "8114d0e9505b44856b822dd587293fd7895320e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8114d0e9505b44856b822dd587293fd7895320e4", "html_url": "https://github.com/rust-lang/rust/commit/8114d0e9505b44856b822dd587293fd7895320e4"}], "stats": {"total": 740, "additions": 450, "deletions": 290}, "files": [{"sha": "787d0191b09303c1dd4b8bf05b0d2581e01f67a7", "filename": "doc/rust.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -2325,7 +2325,9 @@ An example of a for loop over the contents of a vector:\n ~~~~\n # type foo = int;\n # fn bar(f: foo) { }\n-# let a = 0, b = 0, c = 0;\n+# let a = 0;\n+# let b = 0;\n+# let c = 0;\n \n let v: &[foo] = &[a, b, c];\n \n@@ -3000,7 +3002,7 @@ allocated within the stack's memory. The value is a part of the stack frame.\n \n Local variables are immutable unless declared with `let mut`.  The\n `mut` keyword applies to all local variables declared within that\n-declaration (so `let mut x, y` declares two mutable variables, `x` and\n+declaration (so `let mut (x, y) = ...` declares two mutable variables, `x` and\n `y`).\n \n Function parameters are immutable unless declared with `mut`. The"}, {"sha": "d3c682ce1adcd293dbc82d720ab52a8815dddf66", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -159,8 +159,8 @@ pub struct Unique<T> {\n     priv ptr: *mut T\n }\n \n-pub impl<T: Owned> Unique<T> {\n-    fn new(value: T) -> Unique<T> {\n+impl<T: Owned> Unique<T> {\n+    pub fn new(value: T) -> Unique<T> {\n         unsafe {\n             let ptr = malloc(std::sys::size_of::<T>() as size_t) as *mut T;\n             assert!(!ptr::is_null(ptr));\n@@ -171,12 +171,12 @@ pub impl<T: Owned> Unique<T> {\n     }\n \n     // the 'r lifetime results in the same semantics as `&*x` with ~T\n-    fn borrow<'r>(&'r self) -> &'r T {\n+    pub fn borrow<'r>(&'r self) -> &'r T {\n         unsafe { cast::copy_lifetime(self, &*self.ptr) }\n     }\n \n     // the 'r lifetime results in the same semantics as `&mut *x` with ~T\n-    fn borrow_mut<'r>(&'r mut self) -> &'r mut T {\n+    pub fn borrow_mut<'r>(&'r mut self) -> &'r mut T {\n         unsafe { cast::copy_mut_lifetime(self, &mut *self.ptr) }\n     }\n }"}, {"sha": "f1f4ade0542d5068672ec76fa3486b2de02f3c52", "filename": "doc/tutorial-macros.md", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/doc%2Ftutorial-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/doc%2Ftutorial-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-macros.md?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -13,7 +13,8 @@ doing nothing otherwise:\n ~~~~\n # enum t { special_a(uint), special_b(uint) };\n # fn f() -> uint {\n-# let input_1 = special_a(0), input_2 = special_a(0);\n+# let input_1 = special_a(0);\n+# let input_2 = special_a(0);\n match input_1 {\n     special_a(x) => { return x; }\n     _ => {}\n@@ -38,7 +39,8 @@ the pattern in the above code:\n ~~~~\n # enum t { special_a(uint), special_b(uint) };\n # fn f() -> uint {\n-# let input_1 = special_a(0), input_2 = special_a(0);\n+# let input_1 = special_a(0);\n+# let input_2 = special_a(0);\n macro_rules! early_return(\n     ($inp:expr $sp:ident) => ( // invoke it like `(input_5 special_e)`\n         match $inp {\n@@ -155,7 +157,8 @@ instead of `*` to mean \"at least one\".\n ~~~~\n # enum t { special_a(uint),special_b(uint),special_c(uint),special_d(uint)};\n # fn f() -> uint {\n-# let input_1 = special_a(0), input_2 = special_a(0);\n+# let input_1 = special_a(0);\n+# let input_2 = special_a(0);\n macro_rules! early_return(\n     ($inp:expr, [ $($sp:ident)|+ ]) => (\n         match $inp {"}, {"sha": "2926d5958f16cac065c40944ae730a63df4d640f", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -134,7 +134,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n     while idx < fill {\n         let tydesc_data: *uint = transmute(ptr::offset(buf, idx));\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n-        let size = (*tydesc).size, align = (*tydesc).align;\n+        let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n         let after_tydesc = idx + sys::size_of::<*TypeDesc>();\n "}, {"sha": "3afa9b51c59a5f5f4d03922e6a9d6830ff33f215", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -194,8 +194,8 @@ impl FileInput {\n     arguments. `\"-\"` represents `stdin`.\n     */\n     pub fn from_args() -> FileInput {\n-        let args = os::args(),\n-            pathed = pathify(args.tail(), true);\n+        let args = os::args();\n+        let pathed = pathify(args.tail(), true);\n         FileInput::from_vec(pathed)\n     }\n \n@@ -222,11 +222,11 @@ impl FileInput {\n             return false;\n         }\n \n-        let path_option = self.fi.files.shift(),\n-            file = match path_option {\n-                None => io::stdin(),\n-                Some(ref path) => io::file_reader(path).get()\n-            };\n+        let path_option = self.fi.files.shift();\n+        let file = match path_option {\n+            None => io::stdin(),\n+            Some(ref path) => io::file_reader(path).get()\n+        };\n \n         self.fi.current_reader = Some(file);\n         self.fi.state.current_path = path_option;\n@@ -431,8 +431,8 @@ mod test {\n     #[test]\n     fn test_pathify() {\n         let strs = [~\"some/path\",\n-                    ~\"some/other/path\"],\n-            paths = ~[Some(Path(\"some/path\")),\n+                    ~\"some/other/path\"];\n+        let paths = ~[Some(Path(\"some/path\")),\n                       Some(Path(\"some/other/path\"))];\n \n         assert_eq!(pathify(strs, true), copy paths);\n@@ -561,8 +561,10 @@ mod test {\n \n     #[test]\n     fn test_no_trailing_newline() {\n-        let f1 = Some(Path(\"tmp/lib-fileinput-test-no-trailing-newline-1.tmp\")),\n-            f2 = Some(Path(\"tmp/lib-fileinput-test-no-trailing-newline-2.tmp\"));\n+        let f1 =\n+            Some(Path(\"tmp/lib-fileinput-test-no-trailing-newline-1.tmp\"));\n+        let f2 =\n+            Some(Path(\"tmp/lib-fileinput-test-no-trailing-newline-2.tmp\"));\n \n         let wr = io::file_writer(f1.get_ref(), [io::Create, io::Truncate]).get();\n         wr.write_str(\"1\\n2\");"}, {"sha": "f12c9d6573e9064633f5f304795370d3f5bc0c56", "filename": "src/libextra/md4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fmd4.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -58,9 +58,9 @@ pub fn md4(msg: &[u8]) -> Quad {\n     let e = msg.len();\n     let mut x = vec::from_elem(16u, 0u32);\n     while i < e {\n-        let aa = a, bb = b, cc = c, dd = d;\n+        let (aa, bb, cc, dd) = (a, b, c, d);\n \n-        let mut j = 0u, base = i;\n+        let mut (j, base) = (0u, i);\n         while j < 16u {\n             x[j] = (msg[base] as u32) + (msg[base + 1u] as u32 << 8u32) +\n                 (msg[base + 2u] as u32 << 16u32) +"}, {"sha": "085407758645fc8a7c58a7ce4b576273eb20f80e", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -416,7 +416,7 @@ fn get_authority(rawurl: &str) ->\n     let mut port = None;\n \n     let mut colon_count = 0;\n-    let mut pos = 0, begin = 2, end = len;\n+    let mut (pos, begin, end) = (0, 2, len);\n \n     for str::each_chari(rawurl) |i,c| {\n         if i < 2 { loop; } // ignore the leading //"}, {"sha": "77eef1d67efb65524a46a108318802d370a1acaf", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -125,7 +125,7 @@ impl Ord for BigUint {\n impl TotalOrd for BigUint {\n \n     fn cmp(&self, other: &BigUint) -> Ordering {\n-        let s_len = self.data.len(), o_len = other.data.len();\n+        let (s_len, o_len) = (self.data.len(), other.data.len());\n         if s_len < o_len { return Less; }\n         if s_len > o_len { return Greater;  }\n \n@@ -255,7 +255,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n     fn mul(&self, other: &BigUint) -> BigUint {\n         if self.is_zero() || other.is_zero() { return Zero::zero(); }\n \n-        let s_len = self.data.len(), o_len = other.data.len();\n+        let (s_len, o_len) = (self.data.len(), other.data.len());\n         if s_len == 1 { return mul_digit(other, self.data[0]);  }\n         if o_len == 1 { return mul_digit(self,  other.data[0]); }\n \n@@ -447,7 +447,7 @@ impl Integer for BigUint {\n \n     fn gcd(&self, other: &BigUint) -> BigUint {\n         // Use Euclid's algorithm\n-        let mut m = copy *self, n = copy *other;\n+        let mut (m, n) = (copy *self, copy *other);\n         while !m.is_zero() {\n             let temp = m;\n             m = n % temp;\n@@ -1002,8 +1002,8 @@ impl Integer for BigInt {\n     fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // m.sign == other.sign\n         let (d_ui, m_ui) = self.data.div_rem(&other.data);\n-        let d = BigInt::from_biguint(Plus, d_ui),\n-            m = BigInt::from_biguint(Plus, m_ui);\n+        let d = BigInt::from_biguint(Plus, d_ui);\n+        let m = BigInt::from_biguint(Plus, m_ui);\n         match (self.sign, other.sign) {\n             (_,    Zero)   => fail!(),\n             (Plus, Plus)  | (Zero, Plus)  => (d, m),"}, {"sha": "455cc0b74507e02c36acac4ed24acc6d120b474e", "filename": "src/libextra/term.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -57,7 +57,7 @@ pub struct Terminal {\n }\n \n #[cfg(not(target_os = \"win32\"))]\n-pub impl Terminal {\n+impl Terminal {\n     pub fn new(out: @io::Writer) -> Result<Terminal, ~str> {\n         let term = os::getenv(\"TERM\");\n         if term.is_none() {\n@@ -81,7 +81,7 @@ pub impl Terminal {\n \n         return Ok(Terminal {out: out, ti: inf, color_supported: cs});\n     }\n-    fn fg(&self, color: u8) {\n+    pub fn fg(&self, color: u8) {\n         if self.color_supported {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setaf\")).unwrap(),\n                            [Number(color as int)], [], []);\n@@ -92,7 +92,7 @@ pub impl Terminal {\n             }\n         }\n     }\n-    fn bg(&self, color: u8) {\n+    pub fn bg(&self, color: u8) {\n         if self.color_supported {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setab\")).unwrap(),\n                            [Number(color as int)], [], []);\n@@ -103,7 +103,7 @@ pub impl Terminal {\n             }\n         }\n     }\n-    fn reset(&self) {\n+    pub fn reset(&self) {\n         if self.color_supported {\n             let s = expand(*self.ti.strings.find_equiv(&(\"op\")).unwrap(), [], [], []);\n             if s.is_ok() {\n@@ -116,17 +116,17 @@ pub impl Terminal {\n }\n \n #[cfg(target_os = \"win32\")]\n-pub impl Terminal {\n+impl Terminal {\n     pub fn new(out: @io::Writer) -> Result<Terminal, ~str> {\n         return Ok(Terminal {out: out, color_supported: false});\n     }\n \n-    fn fg(&self, color: u8) {\n+    pub fn fg(&self, color: u8) {\n     }\n \n-    fn bg(&self, color: u8) {\n+    pub fn bg(&self, color: u8) {\n     }\n \n-    fn reset(&self) {\n+    pub fn reset(&self) {\n     }\n }"}, {"sha": "61c68c27fe5dc3dddecdb1783f5ba9b950a7b596", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -160,7 +160,9 @@ pub static stringnames: &'static[&'static str] = &'static[ \"cbt\", \"_\", \"cr\", \"cs\n \n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n-    let bnames, snames, nnames;\n+    let bnames;\n+    let snames;\n+    let nnames;\n \n     if longnames {\n         bnames = boolfnames;"}, {"sha": "b942bcf4b952cf01ea73219a095dbff2f491b637", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -140,9 +140,18 @@ fn fold_block(\n         b.stmts.filter_mapped(|a| filter_stmt(cx, *a));\n     let filtered_view_items =\n         b.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n+    let filtered_view_items =\n+        filtered_view_items.map(|x| fld.fold_view_item(*x));\n+    let mut resulting_stmts = ~[];\n+    for filtered_stmts.each |stmt| {\n+        match fld.fold_stmt(*stmt) {\n+            None => {}\n+            Some(stmt) => resulting_stmts.push(stmt),\n+        }\n+    }\n     ast::blk_ {\n-        view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(*x)),\n-        stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n+        view_items: filtered_view_items,\n+        stmts: resulting_stmts,\n         expr: b.expr.map(|x| fld.fold_expr(*x)),\n         id: b.id,\n         rules: b.rules,"}, {"sha": "b50c158f37a1c58994871f9c9d73bee879a3c0d6", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -380,7 +380,8 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n       }\n       ty::ty_nil => None,\n       ty::ty_bool => {\n-        let mut true_found = false, false_found = false;\n+        let mut true_found = false;\n+        let mut false_found = false;\n         for m.each |r| {\n             match pat_ctor_id(cx, r[0]) {\n               None => (),\n@@ -513,10 +514,12 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                 }\n                             },\n                             range(ref c_lo, ref c_hi) => {\n-                                let m1 = compare_const_vals(c_lo, &e_v),\n-                                    m2 = compare_const_vals(c_hi, &e_v);\n+                                let m1 = compare_const_vals(c_lo, &e_v);\n+                                let m2 = compare_const_vals(c_hi, &e_v);\n                                 match (m1, m2) {\n-                                    (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n+                                    (Some(val1), Some(val2)) => {\n+                                        (val1 >= 0 && val2 <= 0)\n+                                    }\n                                     _ => {\n                                         cx.tcx.sess.span_err(pat_span,\n                                             \"mismatched types between ranges\");\n@@ -560,8 +563,8 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                     }\n                                 },\n                             range(ref c_lo, ref c_hi) => {\n-                                let m1 = compare_const_vals(c_lo, &e_v),\n-                                    m2 = compare_const_vals(c_hi, &e_v);\n+                                let m1 = compare_const_vals(c_lo, &e_v);\n+                                let m2 = compare_const_vals(c_hi, &e_v);\n                                 match (m1, m2) {\n                                     (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n                                     _ => {\n@@ -622,7 +625,8 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     }\n                     _ => {\n                         // Grab the class data that we care about.\n-                        let class_fields, class_id;\n+                        let class_fields;\n+                        let class_id;\n                         match ty::get(left_ty).sty {\n                             ty::ty_struct(cid, _) => {\n                                 class_id = cid;\n@@ -667,8 +671,8 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                         }\n                     },\n                     range(ref c_lo, ref c_hi) => {\n-                        let m1 = compare_const_vals(c_lo, &e_v),\n-                            m2 = compare_const_vals(c_hi, &e_v);\n+                        let m1 = compare_const_vals(c_lo, &e_v);\n+                        let m2 = compare_const_vals(c_hi, &e_v);\n                         match (m1, m2) {\n                             (Some(val1), Some(val2)) => (val1 >= 0 && val2 <= 0),\n                             _ => {\n@@ -691,11 +695,11 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     single => return Some(vec::to_owned(r.tail())),\n                     _ => fail!(\"type error\")\n                 };\n-                let v_lo = eval_const_expr(cx.tcx, lo),\n-                    v_hi = eval_const_expr(cx.tcx, hi);\n+                let v_lo = eval_const_expr(cx.tcx, lo);\n+                let v_hi = eval_const_expr(cx.tcx, hi);\n \n-                let m1 = compare_const_vals(&c_lo, &v_lo),\n-                    m2 = compare_const_vals(&c_hi, &v_hi);\n+                let m1 = compare_const_vals(&c_lo, &v_lo);\n+                let m2 = compare_const_vals(&c_hi, &v_hi);\n                 match (m1, m2) {\n                     (Some(val1), Some(val2)) if val1 >= 0 && val2 <= 0 => {\n                         Some(vec::to_owned(r.tail()))"}, {"sha": "349deef2998c606d90cbd24db0ae69570c65c546", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -372,11 +372,9 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n         match decl.node {\n-            ast::decl_local(ref locals) => {\n-                for locals.each |local| {\n-                    self.walk_pat(local.node.pat, in_out, loop_scopes);\n-                    self.walk_opt_expr(local.node.init, in_out, loop_scopes);\n-                }\n+            ast::decl_local(local) => {\n+                self.walk_pat(local.node.pat, in_out, loop_scopes);\n+                self.walk_opt_expr(local.node.init, in_out, loop_scopes);\n             }\n \n             ast::decl_item(_) => {}"}, {"sha": "d3a563ca31204404ac0c5823d16c728fd11c8ef1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -948,14 +948,10 @@ impl Liveness {\n     pub fn propagate_through_decl(&self, decl: @decl, succ: LiveNode)\n                                   -> LiveNode {\n         match decl.node {\n-          decl_local(ref locals) => {\n-            do locals.foldr(succ) |local, succ| {\n+            decl_local(ref local) => {\n                 self.propagate_through_local(*local, succ)\n             }\n-          }\n-          decl_item(_) => {\n-            succ\n-          }\n+            decl_item(_) => succ,\n         }\n     }\n "}, {"sha": "5478d0900f90b3c14416976629d89f74c55f258f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -325,15 +325,17 @@ pub fn parent_id(cx: Context, span: span) -> ast::node_id {\n }\n \n /// Records the current parent (if any) as the parent of `child_id`.\n-pub fn parent_to_expr(cx: Context, child_id: ast::node_id) {\n+pub fn parent_to_expr(cx: Context, child_id: ast::node_id, sp: span) {\n+    debug!(\"region::parent_to_expr(span=%?)\",\n+           cx.sess.codemap.span_to_str(sp));\n     for cx.parent.each |parent_id| {\n         cx.region_maps.record_parent(child_id, *parent_id);\n     }\n }\n \n pub fn resolve_block(blk: &ast::blk, cx: Context, visitor: visit::vt<Context>) {\n     // Record the parent of this block.\n-    parent_to_expr(cx, blk.node.id);\n+    parent_to_expr(cx, blk.node.id, blk.span);\n \n     // Descend.\n     let new_cx = Context {var_parent: Some(blk.node.id),\n@@ -348,7 +350,7 @@ pub fn resolve_arm(arm: &ast::arm, cx: Context, visitor: visit::vt<Context>) {\n \n pub fn resolve_pat(pat: @ast::pat, cx: Context, visitor: visit::vt<Context>) {\n     assert_eq!(cx.var_parent, cx.parent);\n-    parent_to_expr(cx, pat.id);\n+    parent_to_expr(cx, pat.id, pat.span);\n     visit::visit_pat(pat, cx, visitor);\n }\n \n@@ -359,7 +361,7 @@ pub fn resolve_stmt(stmt: @ast::stmt, cx: Context, visitor: visit::vt<Context>)\n         }\n         ast::stmt_expr(_, stmt_id) |\n         ast::stmt_semi(_, stmt_id) => {\n-            parent_to_expr(cx, stmt_id);\n+            parent_to_expr(cx, stmt_id, stmt.span);\n             let expr_cx = Context {parent: Some(stmt_id), ..cx};\n             visit::visit_stmt(stmt, expr_cx, visitor);\n         }\n@@ -368,7 +370,7 @@ pub fn resolve_stmt(stmt: @ast::stmt, cx: Context, visitor: visit::vt<Context>)\n }\n \n pub fn resolve_expr(expr: @ast::expr, cx: Context, visitor: visit::vt<Context>) {\n-    parent_to_expr(cx, expr.id);\n+    parent_to_expr(cx, expr.id, expr.span);\n \n     let mut new_cx = cx;\n     new_cx.parent = Some(expr.id);\n@@ -410,7 +412,7 @@ pub fn resolve_local(local: @ast::local,\n                      cx: Context,\n                      visitor: visit::vt<Context>) {\n     assert_eq!(cx.var_parent, cx.parent);\n-    parent_to_expr(cx, local.node.id);\n+    parent_to_expr(cx, local.node.id, local.span);\n     visit::visit_local(local, cx, visitor);\n }\n \n@@ -423,12 +425,18 @@ pub fn resolve_item(item: @ast::item, cx: Context, visitor: visit::vt<Context>)\n pub fn resolve_fn(fk: &visit::fn_kind,\n                   decl: &ast::fn_decl,\n                   body: &ast::blk,\n-                  _sp: span,\n+                  sp: span,\n                   id: ast::node_id,\n                   cx: Context,\n                   visitor: visit::vt<Context>) {\n-    debug!(\"region::resolve_fn(id=%?, body.node.id=%?, cx.parent=%?)\",\n-           id, body.node.id, cx.parent);\n+    debug!(\"region::resolve_fn(id=%?, \\\n+                               span=%?, \\\n+                               body.node.id=%?, \\\n+                               cx.parent=%?)\",\n+           id,\n+           cx.sess.codemap.span_to_str(sp),\n+           body.node.id,\n+           cx.parent);\n \n     // The arguments and `self` are parented to the body of the fn.\n     let decl_cx = Context {parent: Some(body.node.id),"}, {"sha": "a42e1cd0647926d711d0b3b22530c118b59a30c0", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -1282,7 +1282,8 @@ pub fn compile_submatch(bcx: block,\n     assert!((m.len() > 0u || chk.is_some()));\n     let _icx = bcx.insn_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n-    let tcx = bcx.tcx(), dm = tcx.def_map;\n+    let tcx = bcx.tcx();\n+    let dm = tcx.def_map;\n     if m.len() == 0u {\n         Br(bcx, chk.get()());\n         return;\n@@ -1638,7 +1639,8 @@ fn create_bindings_map(bcx: block, pat: @ast::pat) -> BindingsMap {\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n \n-        let llmatch, trmode;\n+        let llmatch;\n+        let trmode;\n         match bm {\n             ast::bind_infer => {\n                 // in this case, the final type of the variable will be T,\n@@ -1676,7 +1678,8 @@ pub fn trans_match_inner(scope_cx: block,\n         return bcx;\n     }\n \n-    let mut arm_datas = ~[], matches = ~[];\n+    let mut arm_datas = ~[];\n+    let mut matches = ~[];\n     for vec::each(arms) |arm| {\n         let body = scope_block(bcx, arm.body.info(), \"case_body\");\n         let bindings_map = create_bindings_map(bcx, arm.pats[0]);"}, {"sha": "c2dffa265adc31ad8d326110df8d12ac217e2af8", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -950,7 +950,8 @@ pub fn in_lpad_scope_cx(bcx: block, f: &fn(si: &mut scope_info)) {\n pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     let _icx = bcx.insn_ctxt(\"get_landing_pad\");\n \n-    let mut cached = None, pad_bcx = bcx; // Guaranteed to be set below\n+    let mut cached = None;\n+    let mut pad_bcx = bcx; // Guaranteed to be set below\n     do in_lpad_scope_cx(bcx) |inf| {\n         // If there is a valid landing pad still around, use it\n         match inf.landing_pad {\n@@ -1154,13 +1155,11 @@ pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n         }\n         ast::stmt_decl(d, _) => {\n             match d.node {\n-                ast::decl_local(ref locals) => {\n-                    for locals.each |local| {\n-                        bcx = init_local(bcx, *local);\n-                        if cx.sess().opts.extra_debuginfo\n-                            && fcx_has_nonzero_span(bcx.fcx) {\n-                            debuginfo::create_local_var(bcx, *local);\n-                        }\n+                ast::decl_local(ref local) => {\n+                    bcx = init_local(bcx, *local);\n+                    if cx.sess().opts.extra_debuginfo\n+                        && fcx_has_nonzero_span(bcx.fcx) {\n+                        debuginfo::create_local_var(bcx, *local);\n                     }\n                 }\n                 ast::decl_item(i) => trans_item(*cx.fcx.ccx, i)\n@@ -1296,7 +1295,8 @@ pub fn cleanup_and_leave(bcx: block,\n                          upto: Option<BasicBlockRef>,\n                          leave: Option<BasicBlockRef>) {\n     let _icx = bcx.insn_ctxt(\"cleanup_and_leave\");\n-    let mut cur = bcx, bcx = bcx;\n+    let mut cur = bcx;\n+    let mut bcx = bcx;\n     let is_lpad = leave == None;\n     loop {\n         debug!(\"cleanup_and_leave: leaving %s\", cur.to_str());\n@@ -1402,15 +1402,11 @@ pub fn block_locals(b: &ast::blk, it: &fn(@ast::local)) {\n         match s.node {\n           ast::stmt_decl(d, _) => {\n             match d.node {\n-              ast::decl_local(ref locals) => {\n-                for locals.each |local| {\n-                    it(*local);\n-                }\n-              }\n-              _ => {/* fall through */ }\n+              ast::decl_local(ref local) => it(*local),\n+              _ => {} /* fall through */\n             }\n           }\n-          _ => {/* fall through */ }\n+          _ => {} /* fall through */\n         }\n     }\n }\n@@ -1987,7 +1983,8 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n                                None);\n \n     let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n-    let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n+    let bcx = top_scope_block(fcx, None);\n+    let lltop = bcx.llbb;\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n     let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n "}, {"sha": "c8405c929cb584d5fc9add231d90bc9907780c74", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -161,7 +161,8 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n                   -> Result {\n     let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n-    let ccx = bcx.ccx(), tcx = ccx.tcx;\n+    let ccx = bcx.ccx();\n+    let tcx = ccx.tcx;\n \n     fn nuke_ref_count(bcx: block, llbox: ValueRef) {\n         let _icx = bcx.insn_ctxt(\"closure::nuke_ref_count\");\n@@ -204,7 +205,8 @@ pub fn store_environment(bcx: block,\n                          bound_values: ~[EnvValue],\n                          sigil: ast::Sigil) -> ClosureResult {\n     let _icx = bcx.insn_ctxt(\"closure::store_environment\");\n-    let ccx = bcx.ccx(), tcx = ccx.tcx;\n+    let ccx = bcx.ccx();\n+    let tcx = ccx.tcx;\n \n     // compute the shape of the closure\n     let cdata_ty = mk_closure_tys(tcx, bound_values);\n@@ -500,7 +502,8 @@ pub fn make_opaque_cbox_take_glue(\n     }\n \n     // ~fn requires a deep copy.\n-    let ccx = bcx.ccx(), tcx = ccx.tcx;\n+    let ccx = bcx.ccx();\n+    let tcx = ccx.tcx;\n     let llopaquecboxty = T_opaque_box_ptr(ccx);\n     let cbox_in = Load(bcx, cboxptr);\n     do with_cond(bcx, IsNotNull(bcx, cbox_in)) |bcx| {"}, {"sha": "a5e04832d69d05178d7807c27938c9802dab185e", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -1438,7 +1438,8 @@ pub fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n }\n \n pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n-    let mut r = ~\"\", first = true;\n+    let mut r = ~\"\";\n+    let mut first = true;\n     for p.each |e| {\n         match *e {\n             ast_map::path_name(s) | ast_map::path_mod(s) => {"}, {"sha": "8c6dbb009f5561361dd58cfedffb628f2e4c8233", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -332,7 +332,8 @@ pub fn trans_fail_expr(bcx: block,\n     let mut bcx = bcx;\n     match fail_expr {\n         Some(arg_expr) => {\n-            let ccx = bcx.ccx(), tcx = ccx.tcx;\n+            let ccx = bcx.ccx();\n+            let tcx = ccx.tcx;\n             let arg_datum = unpack_datum!(\n                 bcx, expr::trans_to_datum(bcx, arg_expr));\n "}, {"sha": "88b7f7e70de741a8fa7162635a7d7b8907f975ee", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -881,7 +881,8 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n \n pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     -> Option<@Metadata<ArgumentMetadata>> {\n-    let fcx = bcx.fcx, cx = *fcx.ccx;\n+    let fcx = bcx.fcx;\n+    let cx = *fcx.ccx;\n     let cache = get_cache(cx);\n     let tg = ArgVariableTag;\n     match cached_metadata::<@Metadata<ArgumentMetadata>>("}, {"sha": "81ce0dcdad453ec1aaea2d53678eedc8d631acfb", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -436,7 +436,8 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n         debug!(\"build_direct_fn(%s)\", *link_name(ccx, item));\n \n         let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n+        let bcx = top_scope_block(fcx, None);\n+        let lltop = bcx.llbb;\n         let llbasefn = base_fn(ccx, *link_name(ccx, item), tys, cc);\n         let ty = ty::lookup_item_type(ccx.tcx,\n                                       ast_util::local_def(item.id)).ty;\n@@ -462,7 +463,8 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n         debug!(\"build_fast_ffi_fn(%s)\", *link_name(ccx, item));\n \n         let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n+        let bcx = top_scope_block(fcx, None);\n+        let lltop = bcx.llbb;\n         let llbasefn = base_fn(ccx, *link_name(ccx, item), tys, cc);\n         set_no_inline(fcx.llfn);\n         set_fixed_stack_segment(fcx.llfn);"}, {"sha": "f05165fe256105a66b6d7321a2505bb5aa872c8e", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -566,7 +566,8 @@ pub fn combine_impl_and_methods_origins(bcx: block,\n     // Find the bounds for the method, which are the tail of the\n     // bounds found in the item type, as the item type combines the\n     // rcvr + method bounds.\n-    let ccx = bcx.ccx(), tcx = bcx.tcx();\n+    let ccx = bcx.ccx();\n+    let tcx = bcx.tcx();\n     let n_m_tps = method_ty_param_count(ccx, mth_did, impl_did);\n     let ty::ty_param_bounds_and_ty {\n         generics: r_m_generics,"}, {"sha": "c009b03e5c245da6babf84af5a7e05e47892b5b5", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -136,7 +136,8 @@ pub fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> Result {\n pub fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n    block {\n     let _icx = bcx.insn_ctxt(\"tvec::make_drop_glue_unboxed\");\n-    let tcx = bcx.tcx(), unit_ty = ty::sequence_element_type(tcx, vec_ty);\n+    let tcx = bcx.tcx();\n+    let unit_ty = ty::sequence_element_type(tcx, vec_ty);\n     if ty::type_needs_drop(tcx, unit_ty) {\n         iter_vec_unboxed(bcx, vptr, vec_ty, glue::drop_ty)\n     } else { bcx }"}, {"sha": "03803a64fc36e6a695764a8a5eb30d7b5b95f93c", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -106,7 +106,8 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let arg_types, kind_name;\n+    let arg_types;\n+    let kind_name;\n \n     // structure_of requires type variables to be resolved.\n     // So when we pass in <expected>, it's an error if it"}, {"sha": "dc8a47ca20914e307b6c8012be027bf92375e135", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -1896,7 +1896,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Look up the number of type parameters and the raw type, and\n         // determine whether the class is region-parameterized.\n-        let type_parameter_count, region_parameterized, raw_type;\n+        let type_parameter_count;\n+        let region_parameterized;\n+        let raw_type;\n         if class_id.crate == ast::local_crate {\n             region_parameterized =\n                 tcx.region_paramd_items.find(&class_id.node).\n@@ -1983,7 +1985,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Look up the number of type parameters and the raw type, and\n         // determine whether the enum is region-parameterized.\n-        let type_parameter_count, region_parameterized, raw_type;\n+        let type_parameter_count;\n+        let region_parameterized;\n+        let raw_type;\n         if enum_id.crate == ast::local_crate {\n             region_parameterized =\n                 tcx.region_paramd_items.find(&enum_id.node).map_consume(|x| *x);\n@@ -2876,12 +2880,12 @@ pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::stmt)  {\n       ast::stmt_decl(decl, id) => {\n         node_id = id;\n         match decl.node {\n-          ast::decl_local(ref ls) => for ls.each |l| {\n+          ast::decl_local(ref l) => {\n               check_decl_local(fcx, *l);\n               let l_t = fcx.node_ty(l.node.id);\n               saw_bot = saw_bot || ty::type_is_bot(l_t);\n               saw_err = saw_err || ty::type_is_error(l_t);\n-          },\n+          }\n           ast::decl_item(_) => {/* ignore for now */ }\n         }\n       }"}, {"sha": "4bf40d1c18eecbad9fc81b6f646c46238b569c6c", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -88,7 +88,8 @@ fn lookup_vtables(vcx: &VtableContext,\n     let _i = indenter();\n \n     let tcx = vcx.tcx();\n-    let mut result = ~[], i = 0u;\n+    let mut result = ~[];\n+    let mut i = 0u;\n     for substs.tps.each |ty| {\n         // ty is the value supplied for the type parameter A...\n "}, {"sha": "68f9a43d6e67b6c763cb358106b6dc95cfec0384", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -107,7 +107,8 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n \n fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::node_id)\n                            -> Option<ty::t> {\n-    let fcx = wbcx.fcx, tcx = fcx.ccx.tcx;\n+    let fcx = wbcx.fcx;\n+    let tcx = fcx.ccx.tcx;\n \n     // Resolve any borrowings for the node with id `id`\n     match fcx.inh.adjustments.find(&id) {"}, {"sha": "700a78699b1e27f622c99155de7b7e46760e724d", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -220,7 +220,9 @@ impl Combine for Glb {\n \n             let tainted = this.infcx.region_vars.tainted(snapshot, r0);\n \n-            let mut a_r = None, b_r = None, only_new_vars = true;\n+            let mut a_r = None;\n+            let mut b_r = None;\n+            let mut only_new_vars = true;\n             for tainted.each |r| {\n                 if is_var_in_set(a_vars, *r) {\n                     if a_r.is_some() {"}, {"sha": "820bb2f86b04cddefb85e5a8df760824abcb6dd4", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -422,7 +422,7 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n \n     // If both A and B have an UB type, then we can just compute the\n     // LUB of those types:\n-    let a_bnd = this.bnd(a_bounds), b_bnd = this.bnd(b_bounds);\n+    let (a_bnd, b_bnd) = (this.bnd(a_bounds), this.bnd(b_bounds));\n     match (a_bnd, b_bnd) {\n         (Some(ref a_ty), Some(ref b_ty)) => {\n             match this.infcx().try(|| lattice_dir_op(a_ty, b_ty) ) {"}, {"sha": "9d6176af0babad86bbfaee273526a992c8bc4a36", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -928,7 +928,8 @@ impl RegionVarBindings {\n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n         // is not a terribly efficient implementation.\n-        let mut result_set = ~[r0], result_index = 0;\n+        let mut result_set = ~[r0];\n+        let mut result_index = 0;\n         while result_index < result_set.len() {\n             // nb: can't use uint::range() here because result_set grows\n             let r = result_set[result_index];"}, {"sha": "dc561f413c7104257b5e7f70eadf6fd2a2508198", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -242,7 +242,8 @@ pub fn require_same_types(\n     t2: ty::t,\n     msg: &fn() -> ~str) -> bool {\n \n-    let l_tcx, l_infcx;\n+    let l_tcx;\n+    let l_infcx;\n     match maybe_infcx {\n       None => {\n         l_tcx = tcx;"}, {"sha": "85c82787f266e210574b6a64b4dfb7884c9a8e5e", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -35,8 +35,8 @@ pub struct PkgId {\n     version: Version\n }\n \n-pub impl PkgId {\n-    fn new(s: &str) -> PkgId {\n+impl PkgId {\n+    pub fn new(s: &str) -> PkgId {\n         use conditions::bad_pkg_id::cond;\n \n         let p = Path(s);\n@@ -57,13 +57,13 @@ pub impl PkgId {\n         }\n     }\n \n-    fn hash(&self) -> ~str {\n+    pub fn hash(&self) -> ~str {\n         fmt!(\"%s-%s-%s\", self.remote_path.to_str(),\n              hash(self.remote_path.to_str() + self.version.to_str()),\n              self.version.to_str())\n     }\n \n-    fn short_name_with_version(&self) -> ~str {\n+    pub fn short_name_with_version(&self) -> ~str {\n         fmt!(\"%s-%s\", self.short_name, self.version.to_str())\n     }\n }"}, {"sha": "e3977ca00674b60a437d5f8c68158fab2565bbbc", "filename": "src/libstd/io.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -771,7 +771,7 @@ impl<T:Reader> ReaderUtil for T {\n     fn read_le_uint_n(&self, nbytes: uint) -> u64 {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n-        let mut val = 0u64, pos = 0, i = nbytes;\n+        let mut (val, pos, i) = (0u64, 0, nbytes);\n         while i > 0 {\n             val += (self.read_u8() as u64) << pos;\n             pos += 8;\n@@ -787,7 +787,7 @@ impl<T:Reader> ReaderUtil for T {\n     fn read_be_uint_n(&self, nbytes: uint) -> u64 {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n-        let mut val = 0u64, i = nbytes;\n+        let mut (val, i) = (0u64, nbytes);\n         while i > 0 {\n             i -= 1;\n             val += (self.read_u8() as u64) << i * 8;\n@@ -1304,7 +1304,9 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n               (n >> 56) as u8]),\n       _ => {\n \n-        let mut bytes: ~[u8] = ~[], i = size, n = n;\n+        let mut bytes: ~[u8] = ~[];\n+        let mut i = size;\n+        let mut n = n;\n         while i > 0u {\n             bytes.push((n & 255_u64) as u8);\n             n >>= 8_u64;"}, {"sha": "7d0defea05ace5ab863a04908594b166507f0524", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -40,14 +40,14 @@ pub mod raw {\n /// Determine if two shared boxes point to the same object\n #[inline(always)]\n pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n-    let a_ptr: *T = to_unsafe_ptr(&*a), b_ptr: *T = to_unsafe_ptr(&*b);\n+    let (a_ptr, b_ptr): (*T, *T) = (to_unsafe_ptr(&*a), to_unsafe_ptr(&*b));\n     a_ptr == b_ptr\n }\n \n /// Determine if two mutable shared boxes point to the same object\n #[inline(always)]\n pub fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n-    let a_ptr: *T = to_unsafe_ptr(&*a), b_ptr: *T = to_unsafe_ptr(&*b);\n+    let (a_ptr, b_ptr): (*T, *T) = (to_unsafe_ptr(&*a), to_unsafe_ptr(&*b));\n     a_ptr == b_ptr\n }\n "}, {"sha": "3583e2f366ff3ef09453e8090bc989fa0c463223", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -400,7 +400,7 @@ impl Integer for $T {\n     #[inline(always)]\n     fn gcd(&self, other: &$T) -> $T {\n         // Use Euclid's algorithm\n-        let mut m = *self, n = *other;\n+        let mut (m, n) = (*self, *other);\n         while m != 0 {\n             let temp = m;\n             m = n % temp;"}, {"sha": "a7aebf1f176c231548948698f9b4ab65af78996d", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -237,7 +237,7 @@ impl Integer for $T {\n     #[inline(always)]\n     fn gcd(&self, other: &$T) -> $T {\n         // Use Euclid's algorithm\n-        let mut m = *self, n = *other;\n+        let mut (m, n) = (*self, *other);\n         while m != 0 {\n             let temp = m;\n             m = n % temp;"}, {"sha": "a6c1dca4342f48f8e86c804af05a8f836651403f", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -658,13 +658,14 @@ impl IsaacRng {\n     /// of `rsl` as a seed, otherwise construct one algorithmically (not\n     /// randomly).\n     fn init(&mut self, use_rsl: bool) {\n-        macro_rules! init_mut_many (\n-            ($( $var:ident ),* = $val:expr ) => {\n-                let mut $( $var = $val ),*;\n-            }\n-        );\n-        init_mut_many!(a, b, c, d, e, f, g, h = 0x9e3779b9);\n-\n+        let mut a = 0x9e3779b9;\n+        let mut b = a;\n+        let mut c = a;\n+        let mut d = a;\n+        let mut e = a;\n+        let mut f = a;\n+        let mut g = a;\n+        let mut h = a;\n \n         macro_rules! mix(\n             () => {{\n@@ -718,9 +719,9 @@ impl IsaacRng {\n     fn isaac(&mut self) {\n         self.c += 1;\n         // abbreviations\n-        let mut a = self.a, b = self.b + self.c;\n+        let mut (a, b) = (self.a, self.b + self.c);\n \n-        static midpoint: uint =  RAND_SIZE as uint / 2;\n+        static midpoint: uint = RAND_SIZE as uint / 2;\n \n         macro_rules! ind (($x:expr) => {\n             self.mem[($x >> 2) & (RAND_SIZE - 1)]"}, {"sha": "f08d967cbe0226aac37528d4f1d3de9b418bf41c", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -89,7 +89,7 @@ impl Rand for StandardNormal {\n             // do-while, so the condition should be true on the first\n             // run, they get overwritten anyway (0 < 1, so these are\n             // good).\n-            let mut x = 1.0, y = 0.0;\n+            let mut (x, y) = (1.0, 0.0);\n \n             // XXX infinities?\n             while -2.0*y < x * x {"}, {"sha": "727ab13a4f6f727c4c4af8316ffa16f351496ea9", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -342,7 +342,7 @@ impl<T: Reader> ReaderByteConversions for T {\n     fn read_le_uint_n(&mut self, nbytes: uint) -> u64 {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n-        let mut val = 0u64, pos = 0, i = nbytes;\n+        let mut (val, pos, i) = (0u64, 0, nbytes);\n         while i > 0 {\n             val += (self.read_u8() as u64) << pos;\n             pos += 8;\n@@ -358,7 +358,7 @@ impl<T: Reader> ReaderByteConversions for T {\n     fn read_be_uint_n(&mut self, nbytes: uint) -> u64 {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n-        let mut val = 0u64, i = nbytes;\n+        let mut (val, i) = (0u64, nbytes);\n         while i > 0 {\n             i -= 1;\n             val += (self.read_u8() as u64) << i * 8;"}, {"sha": "10c8b84bc512aadb197c5535c083f292dfeabde0", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -242,7 +242,7 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n     // XXX: Could go in str::raw\n     unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n         let s = s as *u8;\n-        let mut curr = s, len = 0u;\n+        let mut (curr, len) = (s, 0u);\n         while *curr != 0u8 {\n             len += 1u;\n             curr = ptr::offset(s, len);"}, {"sha": "da9ee21583dd91b6c19f811048cecb2c5c3a17ee", "filename": "src/libstd/str.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -661,9 +661,9 @@ fn each_split_char_inner<'a>(s: &'a str,\n                              allow_trailing_empty: bool,\n                              it: &fn(&'a str) -> bool) -> bool {\n     if sep < 128u as char {\n-        let b = sep as u8, l = len(s);\n+        let (b, l) = (sep as u8, len(s));\n         let mut done = 0u;\n-        let mut i = 0u, start = 0u;\n+        let mut (i, start) = (0u, 0u);\n         while i < l && done < count {\n             if s[i] == b {\n                 if allow_empty || start < i {\n@@ -725,7 +725,7 @@ fn each_split_inner<'a>(s: &'a str,\n                         allow_trailing_empty: bool,\n                         it: &fn(&'a str) -> bool) -> bool {\n     let l = len(s);\n-    let mut i = 0u, start = 0u, done = 0u;\n+    let mut (i, start, done) = (0u, 0u, 0u);\n     while i < l && done < count {\n         let CharRange {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n@@ -748,9 +748,9 @@ fn each_split_inner<'a>(s: &'a str,\n // See Issue #1932 for why this is a naive search\n fn iter_matches<'a,'b>(s: &'a str, sep: &'b str,\n                        f: &fn(uint, uint) -> bool) -> bool {\n-    let sep_len = len(sep), l = len(s);\n+    let (sep_len, l) = (len(sep), len(s));\n     assert!(sep_len > 0u);\n-    let mut i = 0u, match_start = 0u, match_i = 0u;\n+    let mut (i, match_start, match_i) = (0u, 0u, 0u);\n \n     while i < l {\n         if s[i] == sep[match_i] {\n@@ -977,7 +977,7 @@ pub fn each_split_within<'a>(ss: &'a str,\n  * The original string with all occurances of `from` replaced with `to`\n  */\n pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n-    let mut result = ~\"\", first = true;\n+    let mut (result, first) = (~\"\", true);\n     for iter_between_matches(s, from) |start, end| {\n         if first {\n             first = false;\n@@ -1761,7 +1761,7 @@ pub fn contains_char(haystack: &str, needle: char) -> bool {\n  * * needle - The string to look for\n  */\n pub fn starts_with<'a,'b>(haystack: &'a str, needle: &'b str) -> bool {\n-    let haystack_len = len(haystack), needle_len = len(needle);\n+    let (haystack_len, needle_len) = (len(haystack), len(needle));\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n     else { match_at(haystack, needle, 0u) }\n@@ -1776,7 +1776,7 @@ pub fn starts_with<'a,'b>(haystack: &'a str, needle: &'b str) -> bool {\n  * * needle - The string to look for\n  */\n pub fn ends_with<'a,'b>(haystack: &'a str, needle: &'b str) -> bool {\n-    let haystack_len = len(haystack), needle_len = len(needle);\n+    let (haystack_len, needle_len) = (len(haystack), len(needle));\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n     else { match_at(haystack, needle, haystack_len - needle_len) }\n@@ -1951,7 +1951,7 @@ pub fn with_capacity(capacity: uint) -> ~str {\n pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n     assert!(is_char_boundary(s, start));\n     assert!(is_char_boundary(s, end));\n-    let mut i = start, len = 0u;\n+    let mut (i, len) = (start, 0u);\n     while i < end {\n         let next = char_range_at(s, i).next;\n         len += 1u;\n@@ -1964,7 +1964,7 @@ pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n /// starting from `start`.\n pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n     assert!(is_char_boundary(s, start));\n-    let mut end = start, cnt = n;\n+    let mut (end, cnt) = (start, n);\n     let l = len(s);\n     while cnt > 0u {\n         assert!(end < l);\n@@ -2300,7 +2300,10 @@ pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n pub fn subslice_offset(outer: &str, inner: &str) -> uint {\n     do as_buf(outer) |a, a_len| {\n         do as_buf(inner) |b, b_len| {\n-            let a_start: uint, a_end: uint, b_start: uint, b_end: uint;\n+            let a_start: uint;\n+            let a_end: uint;\n+            let b_start: uint;\n+            let b_end: uint;\n             unsafe {\n                 a_start = cast::transmute(a); a_end = a_len + cast::transmute(a);\n                 b_start = cast::transmute(b); b_end = b_len + cast::transmute(b);\n@@ -2404,7 +2407,7 @@ pub mod raw {\n \n     /// Create a Rust string from a null-terminated *u8 buffer\n     pub unsafe fn from_buf(buf: *u8) -> ~str {\n-        let mut curr = buf, i = 0u;\n+        let mut (curr, i) = (buf, 0u);\n         while *curr != 0u8 {\n             i += 1u;\n             curr = ptr::offset(buf, i);"}, {"sha": "3cc64147964cbe9d13068060e1474884b58b2828", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -53,7 +53,7 @@ impl<A:ToStr> ToStr for (A,) {\n impl<A:ToStr+Hash+Eq, B:ToStr+Hash+Eq> ToStr for HashMap<A, B> {\n     #[inline(always)]\n     fn to_str(&self) -> ~str {\n-        let mut acc = ~\"{\", first = true;\n+        let mut (acc, first) = (~\"{\", true);\n         for self.each |key, value| {\n             if first {\n                 first = false;\n@@ -73,18 +73,18 @@ impl<A:ToStr+Hash+Eq, B:ToStr+Hash+Eq> ToStr for HashMap<A, B> {\n impl<A:ToStr+Hash+Eq> ToStr for HashSet<A> {\n     #[inline(always)]\n     fn to_str(&self) -> ~str {\n-    let mut acc = ~\"{\", first = true;\n-    for self.each |element| {\n-        if first {\n-            first = false;\n-        }\n-        else {\n-            acc.push_str(\", \");\n+        let mut (acc, first) = (~\"{\", true);\n+        for self.each |element| {\n+            if first {\n+                first = false;\n+            }\n+            else {\n+                acc.push_str(\", \");\n+            }\n+            acc.push_str(element.to_str());\n         }\n-        acc.push_str(element.to_str());\n-    }\n-    acc.push_char('}');\n-    acc\n+        acc.push_char('}');\n+        acc\n     }\n }\n \n@@ -121,7 +121,7 @@ impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n impl<'self,A:ToStr> ToStr for &'self [A] {\n     #[inline(always)]\n     fn to_str(&self) -> ~str {\n-        let mut acc = ~\"[\", first = true;\n+        let mut (acc, first) = (~\"[\", true);\n         for self.each |elt| {\n             if first {\n                 first = false;\n@@ -139,7 +139,7 @@ impl<'self,A:ToStr> ToStr for &'self [A] {\n impl<A:ToStr> ToStr for ~[A] {\n     #[inline(always)]\n     fn to_str(&self) -> ~str {\n-        let mut acc = ~\"[\", first = true;\n+        let mut (acc, first) = (~\"[\", true);\n         for self.each |elt| {\n             if first {\n                 first = false;\n@@ -157,7 +157,7 @@ impl<A:ToStr> ToStr for ~[A] {\n impl<A:ToStr> ToStr for @[A] {\n     #[inline(always)]\n     fn to_str(&self) -> ~str {\n-        let mut acc = ~\"[\", first = true;\n+        let mut (acc, first) = (~\"[\", true);\n         for self.each |elt| {\n             if first {\n                 first = false;"}, {"sha": "589c18de0abf594176d1796fdbcf30e594163234", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -412,7 +412,7 @@ mod tests {\n \n     #[test]\n     fn test_tuple_cmp() {\n-        let small = (1u, 2u, 3u), big = (3u, 2u, 1u);\n+        let (small, big) = ((1u, 2u, 3u), (3u, 2u, 1u));\n \n         // Eq\n         assert_eq!(small, small);"}, {"sha": "f078cd3bda350bd3166daeed0438edb6e3880a4d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -749,7 +749,7 @@ pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n pub fn dedup<T:Eq>(v: &mut ~[T]) {\n     unsafe {\n         if v.len() < 1 { return; }\n-        let mut last_written = 0, next_to_read = 1;\n+        let mut (last_written, next_to_read) = (0, 1);\n         do as_const_buf(*v) |p, ln| {\n             // We have a mutable reference to v, so we can make arbitrary\n             // changes. (cf. push and pop)\n@@ -1365,7 +1365,7 @@ pub fn bsearch_elem<T:TotalOrd>(v: &[T], x: &T) -> Option<uint> {\n  * Convert a vector of pairs into a pair of vectors, by reference. As unzip().\n  */\n pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n-    let mut ts = ~[], us = ~[];\n+    let mut (ts, us) = (~[], ~[]);\n     for each(v) |p| {\n         let (t, u) = *p;\n         ts.push(t);\n@@ -1383,7 +1383,7 @@ pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n  * of the i-th tuple of the input vector.\n  */\n pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n-    let mut ts = ~[], us = ~[];\n+    let mut (ts, us) = (~[], ~[]);\n     do consume(v) |_i, p| {\n         let (t, u) = p;\n         ts.push(t);"}, {"sha": "625bcd4ec9c3fdea3419b139b1cdc50e674efd73", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -413,7 +413,10 @@ pub type local = spanned<local_>;\n pub type decl = spanned<decl_>;\n \n #[deriving(Eq, Encodable, Decodable)]\n-pub enum decl_ { decl_local(~[@local]), decl_item(@item), }\n+pub enum decl_ {\n+    decl_local(@local),\n+    decl_item(@item),\n+}\n \n #[deriving(Eq, Encodable, Decodable)]\n pub struct arm {\n@@ -440,8 +443,8 @@ pub struct expr {\n     span: span,\n }\n \n-pub impl expr {\n-    fn get_callee_id(&self) -> Option<node_id> {\n+impl expr {\n+    pub fn get_callee_id(&self) -> Option<node_id> {\n         match self.node {\n             expr_method_call(callee_id, _, _, _, _, _) |\n             expr_index(callee_id, _, _) |"}, {"sha": "e2b8677d5a4e3e4092dbe011c65f70fdb64464a1", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -279,7 +279,8 @@ pub fn trait_method_to_ty_method(method: &trait_method) -> ty_method {\n \n pub fn split_trait_methods(trait_methods: &[trait_method])\n     -> (~[ty_method], ~[@method]) {\n-    let mut reqd = ~[], provd = ~[];\n+    let mut reqd = ~[];\n+    let mut provd = ~[];\n     for trait_methods.each |trt_method| {\n         match *trt_method {\n           required(ref tm) => reqd.push(copy *tm),"}, {"sha": "324b909fbb033775a6a8055ace637dcb7a4d35c6", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -385,7 +385,7 @@ impl AstBuilder for @ExtCtxt {\n                                 init: Some(ex),\n                                 id: self.next_id(),\n                             });\n-        let decl = respan(sp, ast::decl_local(~[local]));\n+        let decl = respan(sp, ast::decl_local(local));\n         @respan(sp, ast::stmt_decl(@decl, self.next_id()))\n     }\n "}, {"sha": "2e6cac1876bbbf0b4281095e92afcec68fdd262e", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -416,7 +416,9 @@ impl<'self> MethodDef<'self> {\n                              type_ident: ident, generics: &Generics)\n         -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(ident, @ast::Ty)]) {\n \n-        let mut self_args = ~[], nonself_args = ~[], arg_tys = ~[];\n+        let mut self_args = ~[];\n+        let mut nonself_args = ~[];\n+        let mut arg_tys = ~[];\n         let mut nonstatic = false;\n \n         let ast_explicit_self = match self.explicit_self {\n@@ -522,8 +524,9 @@ impl<'self> MethodDef<'self> {\n                                  nonself_args: &[@expr])\n         -> @expr {\n \n-        let mut raw_fields = ~[], // ~[[fields of self], [fields of next Self arg], [etc]]\n-                patterns = ~[];\n+        let mut raw_fields = ~[]; // ~[[fields of self],\n+                                 // [fields of next Self arg], [etc]]\n+        let mut patterns = ~[];\n         for uint::range(0, self_args.len()) |i| {\n             let (pat, ident_expr) = create_struct_pattern(cx, span,\n                                                           type_ident, struct_def,"}, {"sha": "13c552388e14e031bdbb3926c5541f5220d062a7", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -264,8 +264,8 @@ pub fn create_struct_pattern(cx: @ExtCtxt,\n \n     let matching_path = cx.path(span, ~[ struct_ident ]);\n \n-    let mut paths = ~[], ident_expr = ~[];\n-\n+    let mut paths = ~[];\n+    let mut ident_expr = ~[];\n     let mut struct_type = Unknown;\n \n     for struct_def.fields.eachi |i, struct_field| {\n@@ -326,7 +326,8 @@ pub fn create_enum_variant_pattern(cx: @ExtCtxt,\n \n             let matching_path = cx.path_ident(span, variant_ident);\n \n-            let mut paths = ~[], ident_expr = ~[];\n+            let mut paths = ~[];\n+            let mut ident_expr = ~[];\n             for uint::range(0, variant_args.len()) |i| {\n                 let path = cx.path_ident(span,\n                                          cx.ident_of(fmt!(\"%s_%u\", prefix, i)));"}, {"sha": "45b9be07a984ab1c9996080a4600adeb33f66d14", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -302,8 +302,9 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                    s: &stmt_,\n                    sp: span,\n                    fld: @ast_fold,\n-                   orig: @fn(&stmt_, span, @ast_fold) -> (stmt_, span))\n-                -> (stmt_, span) {\n+                   orig: @fn(&stmt_, span, @ast_fold)\n+                             -> (Option<stmt_>, span))\n+                -> (Option<stmt_>, span) {\n     let (mac, pth, tts, semi) = match *s {\n         stmt_mac(ref mac, semi) => {\n             match mac.node {\n@@ -342,8 +343,17 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             };\n \n             //keep going, outside-in\n-            let fully_expanded = copy fld.fold_stmt(expanded).node;\n-            cx.bt_pop();\n+            let fully_expanded = match fld.fold_stmt(expanded) {\n+                Some(stmt) => {\n+                    let fully_expanded = &stmt.node;\n+                    cx.bt_pop();\n+                    copy *fully_expanded\n+                }\n+                None => {\n+                    cx.span_fatal(pth.span,\n+                                  \"macro didn't expand to a statement\")\n+                }\n+            };\n \n             (fully_expanded, sp)\n         }\n@@ -355,8 +365,8 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n     };\n \n     (match fully_expanded {\n-        stmt_expr(e, stmt_id) if semi => stmt_semi(e, stmt_id),\n-        _ => { fully_expanded } /* might already have a semi */\n+        stmt_expr(e, stmt_id) if semi => Some(stmt_semi(e, stmt_id)),\n+        _ => { Some(fully_expanded) } /* might already have a semi */\n     }, sp)\n \n }"}, {"sha": "d419ce6f18857fc03009c1e953141cd8f3e0f5c8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -26,10 +26,10 @@ pub trait ast_fold {\n     fn fold_item_underscore(@self, &item_) -> item_;\n     fn fold_method(@self, @method) -> @method;\n     fn fold_block(@self, &blk) -> blk;\n-    fn fold_stmt(@self, &stmt) -> @stmt;\n+    fn fold_stmt(@self, &stmt) -> Option<@stmt>;\n     fn fold_arm(@self, &arm) -> arm;\n     fn fold_pat(@self, @pat) -> @pat;\n-    fn fold_decl(@self, @decl) -> @decl;\n+    fn fold_decl(@self, @decl) -> Option<@decl>;\n     fn fold_expr(@self, @expr) -> @expr;\n     fn fold_ty(@self, @Ty) -> @Ty;\n     fn fold_mod(@self, &_mod) -> _mod;\n@@ -55,10 +55,10 @@ pub struct AstFoldFns {\n     fold_item_underscore: @fn(&item_, @ast_fold) -> item_,\n     fold_method: @fn(@method, @ast_fold) -> @method,\n     fold_block: @fn(&blk_, span, @ast_fold) -> (blk_, span),\n-    fold_stmt: @fn(&stmt_, span, @ast_fold) -> (stmt_, span),\n+    fold_stmt: @fn(&stmt_, span, @ast_fold) -> (Option<stmt_>, span),\n     fold_arm: @fn(&arm, @ast_fold) -> arm,\n     fold_pat: @fn(&pat_, span, @ast_fold) -> (pat_, span),\n-    fold_decl: @fn(&decl_, span, @ast_fold) -> (decl_, span),\n+    fold_decl: @fn(&decl_, span, @ast_fold) -> (Option<decl_>, span),\n     fold_expr: @fn(&expr_, span, @ast_fold) -> (expr_, span),\n     fold_ty: @fn(&ty_, span, @ast_fold) -> (ty_, span),\n     fold_mod: @fn(&_mod, @ast_fold) -> _mod,\n@@ -340,22 +340,39 @@ fn noop_fold_method(m: @method, fld: @ast_fold) -> @method {\n \n \n pub fn noop_fold_block(b: &blk_, fld: @ast_fold) -> blk_ {\n+    let view_items = b.view_items.map(|x| fld.fold_view_item(*x));\n+    let mut stmts = ~[];\n+    for b.stmts.each |stmt| {\n+        match fld.fold_stmt(*stmt) {\n+            None => {}\n+            Some(stmt) => stmts.push(stmt)\n+        }\n+    }\n     ast::blk_ {\n-        view_items: b.view_items.map(|x| fld.fold_view_item(*x)),\n-        stmts: b.stmts.map(|x| fld.fold_stmt(*x)),\n+        view_items: view_items,\n+        stmts: stmts,\n         expr: b.expr.map(|x| fld.fold_expr(*x)),\n         id: fld.new_id(b.id),\n         rules: b.rules,\n     }\n }\n \n-fn noop_fold_stmt(s: &stmt_, fld: @ast_fold) -> stmt_ {\n+fn noop_fold_stmt(s: &stmt_, fld: @ast_fold) -> Option<stmt_> {\n     let fold_mac = |x| fold_mac_(x, fld);\n     match *s {\n-        stmt_decl(d, nid) => stmt_decl(fld.fold_decl(d), fld.new_id(nid)),\n-        stmt_expr(e, nid) => stmt_expr(fld.fold_expr(e), fld.new_id(nid)),\n-        stmt_semi(e, nid) => stmt_semi(fld.fold_expr(e), fld.new_id(nid)),\n-        stmt_mac(ref mac, semi) => stmt_mac(fold_mac(mac), semi)\n+        stmt_decl(d, nid) => {\n+            match fld.fold_decl(d) {\n+                Some(d) => Some(stmt_decl(d, fld.new_id(nid))),\n+                None => None,\n+            }\n+        }\n+        stmt_expr(e, nid) => {\n+            Some(stmt_expr(fld.fold_expr(e), fld.new_id(nid)))\n+        }\n+        stmt_semi(e, nid) => {\n+            Some(stmt_semi(fld.fold_expr(e), fld.new_id(nid)))\n+        }\n+        stmt_mac(ref mac, semi) => Some(stmt_mac(fold_mac(mac), semi))\n     }\n }\n \n@@ -411,13 +428,13 @@ pub fn noop_fold_pat(p: &pat_, fld: @ast_fold) -> pat_ {\n     }\n }\n \n-fn noop_fold_decl(d: &decl_, fld: @ast_fold) -> decl_ {\n+fn noop_fold_decl(d: &decl_, fld: @ast_fold) -> Option<decl_> {\n     match *d {\n-        decl_local(ref ls) => decl_local(ls.map(|x| fld.fold_local(*x))),\n+        decl_local(ref l) => Some(decl_local(fld.fold_local(*l))),\n         decl_item(it) => {\n             match fld.fold_item(it) {\n-                Some(it_folded) => decl_item(it_folded),\n-                None => decl_local(~[]),\n+                Some(it_folded) => Some(decl_item(it_folded)),\n+                None => None,\n             }\n         }\n     }\n@@ -738,10 +755,10 @@ pub fn default_ast_fold() -> ast_fold_fns {\n         fold_item_underscore: noop_fold_item_underscore,\n         fold_method: noop_fold_method,\n         fold_block: wrap(noop_fold_block),\n-        fold_stmt: wrap(noop_fold_stmt),\n+        fold_stmt: |x, s, fld| (noop_fold_stmt(x, fld), s),\n         fold_arm: noop_fold_arm,\n         fold_pat: wrap(noop_fold_pat),\n-        fold_decl: wrap(noop_fold_decl),\n+        fold_decl: |x, s, fld| (noop_fold_decl(x, fld), s),\n         fold_expr: wrap(noop_fold_expr),\n         fold_ty: wrap(noop_fold_ty),\n         fold_mod: noop_fold_mod,\n@@ -799,9 +816,12 @@ impl ast_fold for AstFoldFns {\n         let (n, s) = (self.fold_block)(&x.node, x.span, self as @ast_fold);\n         spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_stmt(@self, x: &stmt) -> @stmt {\n-        let (n, s) = (self.fold_stmt)(&x.node, x.span, self as @ast_fold);\n-        @spanned { node: n, span: (self.new_span)(s) }\n+    fn fold_stmt(@self, x: &stmt) -> Option<@stmt> {\n+        let (n_opt, s) = (self.fold_stmt)(&x.node, x.span, self as @ast_fold);\n+        match n_opt {\n+            Some(n) => Some(@spanned { node: n, span: (self.new_span)(s) }),\n+            None => None,\n+        }\n     }\n     fn fold_arm(@self, x: &arm) -> arm {\n         (self.fold_arm)(x, self as @ast_fold)\n@@ -814,9 +834,12 @@ impl ast_fold for AstFoldFns {\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_decl(@self, x: @decl) -> @decl {\n-        let (n, s) = (self.fold_decl)(&x.node, x.span, self as @ast_fold);\n-        @spanned { node: n, span: (self.new_span)(s) }\n+    fn fold_decl(@self, x: @decl) -> Option<@decl> {\n+        let (n_opt, s) = (self.fold_decl)(&x.node, x.span, self as @ast_fold);\n+        match n_opt {\n+            Some(n) => Some(@spanned { node: n, span: (self.new_span)(s) }),\n+            None => None,\n+        }\n     }\n     fn fold_expr(@self, x: @expr) -> @expr {\n         let (n, s) = (self.fold_expr)(&x.node, x.span, self as @ast_fold);"}, {"sha": "2f166ae89efa7b63d622a2b4963a965ee419232f", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -58,7 +58,8 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n \n     /// remove whitespace-only lines from the start/end of lines\n     fn vertical_trim(lines: ~[~str]) -> ~[~str] {\n-        let mut i = 0u, j = lines.len();\n+        let mut i = 0u;\n+        let mut j = lines.len();\n         while i < j && lines[i].trim().is_empty() {\n             i += 1u;\n         }"}, {"sha": "0eb933e6c3a842c90a1abb502c0cdee3c81be184", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -387,7 +387,10 @@ fn scan_digits(rdr: @mut StringReader, radix: uint) -> ~str {\n }\n \n fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n-    let mut num_str, base = 10u, c = c, n = nextch(rdr);\n+    let mut num_str;\n+    let mut base = 10u;\n+    let mut c = c;\n+    let mut n = nextch(rdr);\n     if c == '0' && n == 'x' {\n         bump(rdr);\n         bump(rdr);\n@@ -510,7 +513,8 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n }\n \n fn scan_numeric_escape(rdr: @mut StringReader, n_hex_digits: uint) -> char {\n-    let mut accum_int = 0, i = n_hex_digits;\n+    let mut accum_int = 0;\n+    let mut i = n_hex_digits;\n     while i != 0u {\n         let n = rdr.curr;\n         bump(rdr);"}, {"sha": "61b7f1403e64236e970c9c91f3a9d5582c5480f7", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -49,7 +49,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteTraitBoundSeparator,\n     ObsoleteMutOwnedPointer,\n     ObsoleteMutVector,\n-    ObsoleteTraitImplVisibility,\n+    ObsoleteImplVisibility,\n     ObsoleteRecordType,\n     ObsoleteRecordPattern,\n     ObsoletePostFnTySigil,\n@@ -64,6 +64,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteConstItem,\n     ObsoleteFixedLengthVectorType,\n     ObsoleteNamedExternModule,\n+    ObsoleteMultipleLocalDecl,\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n@@ -158,11 +159,10 @@ impl Parser {\n                  in a mutable location, like a mutable local variable or an \\\n                  `@mut` box\"\n             ),\n-            ObsoleteTraitImplVisibility => (\n-                \"visibility-qualified trait implementation\",\n-                \"`pub` or `priv` is meaningless for trait implementations, \\\n-                 because the `impl...for...` form defines overloads for \\\n-                 methods that already exist; remove the `pub` or `priv`\"\n+            ObsoleteImplVisibility => (\n+                \"visibility-qualified implementation\",\n+                \"`pub` or `priv` goes on individual functions; remove the \\\n+                 `pub` or `priv`\"\n             ),\n             ObsoleteRecordType => (\n                 \"structural record type\",\n@@ -225,6 +225,11 @@ impl Parser {\n                 \"instead of `extern mod foo { ... }`, write `mod foo { \\\n                  extern { ... } }`\"\n             ),\n+            ObsoleteMultipleLocalDecl => (\n+                \"declaration of multiple locals at once\",\n+                \"instead of e.g. `let a = 1, b = 2`, write \\\n+                 `let (a, b) = (1, 2)`.\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "23e3f14539815a2ae5ca4f31e7e5ee0b8208df31", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -76,15 +76,15 @@ use parse::obsolete::{ObsoleteMoveInit, ObsoleteBinaryMove, ObsoleteSwap};\n use parse::obsolete::{ObsoleteSyntax, ObsoleteLowerCaseKindBounds};\n use parse::obsolete::{ObsoleteUnsafeBlock, ObsoleteImplSyntax};\n use parse::obsolete::{ObsoleteTraitBoundSeparator, ObsoleteMutOwnedPointer};\n-use parse::obsolete::{ObsoleteMutVector, ObsoleteTraitImplVisibility};\n+use parse::obsolete::{ObsoleteMutVector, ObsoleteImplVisibility};\n use parse::obsolete::{ObsoleteRecordType, ObsoleteRecordPattern};\n use parse::obsolete::{ObsoletePostFnTySigil};\n use parse::obsolete::{ObsoleteBareFnType, ObsoleteNewtypeEnum};\n use parse::obsolete::ObsoleteMode;\n use parse::obsolete::{ObsoleteLifetimeNotation, ObsoleteConstManagedPointer};\n use parse::obsolete::{ObsoletePurity, ObsoleteStaticMethod};\n use parse::obsolete::{ObsoleteConstItem, ObsoleteFixedLengthVectorType};\n-use parse::obsolete::{ObsoleteNamedExternModule};\n+use parse::obsolete::{ObsoleteNamedExternModule, ObsoleteMultipleLocalDecl};\n use parse::token::{can_begin_expr, is_ident, is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, keywords, special_idents, token_to_binop};\n use parse::token;\n@@ -2573,11 +2573,12 @@ impl Parser {\n     fn parse_let(&self) -> @decl {\n         let is_mutbl = self.eat_keyword(keywords::Mut);\n         let lo = self.span.lo;\n-        let mut locals = ~[self.parse_local(is_mutbl)];\n+        let mut local = self.parse_local(is_mutbl);\n         while self.eat(&token::COMMA) {\n-            locals.push(self.parse_local(is_mutbl));\n+            let _ = self.parse_local(is_mutbl);\n+            self.obsolete(*self.span, ObsoleteMultipleLocalDecl);\n         }\n-        return @spanned(lo, self.last_span.hi, decl_local(locals));\n+        return @spanned(lo, self.last_span.hi, decl_local(local));\n     }\n \n     // parse a structure field\n@@ -3305,10 +3306,9 @@ impl Parser {\n             None\n         };\n \n-        // Do not allow visibility to be specified in `impl...for...`. It is\n-        // meaningless.\n-        if opt_trait.is_some() && visibility != ast::inherited {\n-            self.obsolete(*self.span, ObsoleteTraitImplVisibility);\n+        // Do not allow visibility to be specified.\n+        if visibility != ast::inherited {\n+            self.obsolete(*self.span, ObsoleteImplVisibility);\n         }\n \n         let mut meths = ~[];\n@@ -3841,15 +3841,18 @@ impl Parser {\n     // parse the part of an \"enum\" decl following the '{'\n     fn parse_enum_def(&self, _generics: &ast::Generics) -> enum_def {\n         let mut variants = ~[];\n-        let mut all_nullary = true, have_disr = false;\n+        let mut all_nullary = true;\n+        let mut have_disr = false;\n         while *self.token != token::RBRACE {\n             let variant_attrs = self.parse_outer_attributes();\n             let vlo = self.span.lo;\n \n             let vis = self.parse_visibility();\n \n-            let ident, kind;\n-            let mut args = ~[], disr_expr = None;\n+            let ident;\n+            let kind;\n+            let mut args = ~[];\n+            let mut disr_expr = None;\n             ident = self.parse_ident();\n             if self.eat(&token::LBRACE) {\n                 // Parse a struct variant.\n@@ -4353,7 +4356,8 @@ impl Parser {\n     }\n \n     fn is_view_item(&self) -> bool {\n-        let tok, next_tok;\n+        let tok;\n+        let next_tok;\n         if !self.is_keyword(keywords::Pub) && !self.is_keyword(keywords::Priv) {\n             tok = copy *self.token;\n             next_tok = self.look_ahead(1);"}, {"sha": "7a3eddbd5733d2c832a0898532effb92e02ead09", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -1444,14 +1444,12 @@ pub fn print_local_decl(s: @ps, loc: @ast::local) {\n pub fn print_decl(s: @ps, decl: @ast::decl) {\n     maybe_print_comment(s, decl.span.lo);\n     match decl.node {\n-      ast::decl_local(ref locs) => {\n+      ast::decl_local(ref loc) => {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n         word_nbsp(s, \"let\");\n \n-        // if any are mut, all are mut\n-        if locs.any(|l| l.node.is_mutbl) {\n-            assert!(locs.all(|l| l.node.is_mutbl));\n+        if loc.node.is_mutbl {\n             word_nbsp(s, \"mut\");\n         }\n \n@@ -1468,7 +1466,8 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n               _ => ()\n             }\n         }\n-        commasep(s, consistent, *locs, print_local);\n+\n+        print_local(s, *loc);\n         end(s);\n       }\n       ast::decl_item(item) => print_item(s, item)"}, {"sha": "bf75efb805f2492a5a2a12138a39e9650508372b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -430,11 +430,7 @@ pub fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n \n pub fn visit_decl<E: Copy>(d: @decl, e: E, v: vt<E>) {\n     match d.node {\n-        decl_local(ref locs) => {\n-            for locs.each |loc| {\n-                (v.visit_local)(*loc, e, v)\n-            }\n-        },\n+        decl_local(ref loc) => (v.visit_local)(*loc, e, v),\n         decl_item(it) => (v.visit_item)(it, e, v)\n     }\n }"}, {"sha": "811bf082ae8915ce3e5883770709c59f51e9ee17", "filename": "src/test/auxiliary/reexported_static_methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Freexported_static_methods.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -34,7 +34,7 @@ pub mod sub_foo {\n         unused_str: ~str\n     }\n \n-    pub impl Boz {\n+    impl Boz {\n         pub fn boz(i: int) -> bool {\n             i > 0\n         }\n@@ -45,7 +45,7 @@ pub mod sub_foo {\n         Bort2\n     }\n \n-    pub impl Bort {\n+    impl Bort {\n         pub fn bort() -> ~str {\n             ~\"bort()\"\n         }"}, {"sha": "b1db5843b7cdb854008475279d05dee6e976017a", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -17,7 +17,9 @@ fn fannkuch_redux(n: i32) -> i32 {\n     let mut perm = vec::from_elem(n as uint, 0i32);\n     let mut perm1 = vec::from_fn(n as uint, |i| i as i32);\n     let mut count = vec::from_elem(n as uint, 0i32);\n-    let mut max_flips_count = 0i32, perm_count = 0i32, checksum = 0i32;\n+    let mut max_flips_count = 0i32;\n+    let mut perm_count = 0i32;\n+    let mut checksum = 0i32;\n \n     let mut r = n;\n     loop {"}, {"sha": "cb9972a709fecea503a303f9f984d737d12ba38e", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -99,7 +99,9 @@ impl RepeatFasta {\n                         alu,\n                         LINE_LEN);\n \n-            let mut pos = 0, bytes, n = n;\n+            let mut pos = 0;\n+            let mut bytes;\n+            let mut n = n;\n             while n > 0 {\n                 bytes = min(LINE_LEN, n);\n                 fwrite(transmute(&buf[pos]), bytes as size_t, 1, stdout);\n@@ -158,7 +160,8 @@ impl RandomFasta {\n \n     fn make(&mut self, n: uint) {\n         unsafe {\n-            let lines = n / LINE_LEN, chars_left = n % LINE_LEN;\n+            let lines = n / LINE_LEN;\n+            let chars_left = n % LINE_LEN;\n             let mut buf = [0, ..LINE_LEN + 1];\n \n             for lines.times {"}, {"sha": "70f56f5c5a399711107d5e032de6487b49e90120", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -10,7 +10,8 @@ static LIMIT: f64 = 2.0;\n #[fixed_stack_segment]\n fn main() {\n     unsafe {\n-        let w: i32 = FromStr::from_str(os::args()[1]).get(), h = w;\n+        let w: i32 = FromStr::from_str(os::args()[1]).get();\n+        let h = w;\n         let mut byte_acc: i8 = 0;\n         let mut bit_num: i32 = 0;\n "}, {"sha": "242b3a3f7a4f6d19c575d73808ee01491c3780e6", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -92,7 +92,8 @@ fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: i32) {\n                 let d2 = d[0]*d[0] + d[1]*d[1] + d[2]*d[2];\n                 let mag = dt / (d2 * f64::sqrt(d2));\n \n-                let a_mass = bodies[i].mass, b_mass = bodies[j].mass;\n+                let a_mass = bodies[i].mass;\n+                let b_mass = bodies[j].mass;\n                 bodies[i].v[0] -= d[0] * b_mass * mag;\n                 bodies[i].v[1] -= d[1] * b_mass * mag;\n                 bodies[i].v[2] -= d[2] * b_mass * mag;"}, {"sha": "1623eaaa7d3c389c6f8e1631887ff15fd1689fa2", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -45,7 +45,9 @@ fn mult_AtAv(v: &mut [f64], out: &mut [f64], tmp: &mut [f64]) {\n #[fixed_stack_segment]\n fn main() {\n     let n: uint = FromStr::from_str(os::args()[1]).get();\n-    let mut u = vec::from_elem(n, 1f64), v = u.clone(), tmp = u.clone();\n+    let mut u = vec::from_elem(n, 1f64);\n+    let mut v = u.clone();\n+    let mut tmp = u.clone();\n     for 8.times {\n         mult_AtAv(u, v, tmp);\n         mult_AtAv(v, u, tmp);"}, {"sha": "e66acddd05e2b179bf72a0021702eca59a4c26cb", "filename": "src/test/compile-fail/borrowck-lend-flow-loop.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -49,7 +49,8 @@ fn block_overarching_alias_mut() {\n fn loop_aliased_mut() {\n     // In this instance, the borrow is carried through the loop.\n \n-    let mut v = ~3, w = ~4;\n+    let mut v = ~3;\n+    let mut w = ~4;\n     let mut _x = &w;\n     loop {\n         borrow_mut(v); //~ ERROR cannot borrow\n@@ -60,7 +61,8 @@ fn loop_aliased_mut() {\n fn while_aliased_mut() {\n     // In this instance, the borrow is carried through the loop.\n \n-    let mut v = ~3, w = ~4;\n+    let mut v = ~3;\n+    let mut w = ~4;\n     let mut _x = &w;\n     while cond() {\n         borrow_mut(v); //~ ERROR cannot borrow\n@@ -71,7 +73,8 @@ fn while_aliased_mut() {\n fn for_loop_aliased_mut() {\n     // In this instance, the borrow is carried through the loop.\n \n-    let mut v = ~3, w = ~4;\n+    let mut v = ~3;\n+    let mut w = ~4;\n     let mut _x = &w;\n     for for_func {\n         borrow_mut(v); //~ ERROR cannot borrow\n@@ -82,7 +85,8 @@ fn for_loop_aliased_mut() {\n fn loop_aliased_mut_break() {\n     // In this instance, the borrow is carried through the loop.\n \n-    let mut v = ~3, w = ~4;\n+    let mut v = ~3;\n+    let mut w = ~4;\n     let mut _x = &w;\n     loop {\n         borrow_mut(v);\n@@ -95,7 +99,8 @@ fn loop_aliased_mut_break() {\n fn while_aliased_mut_break() {\n     // In this instance, the borrow is carried through the loop.\n \n-    let mut v = ~3, w = ~4;\n+    let mut v = ~3;\n+    let mut w = ~4;\n     let mut _x = &w;\n     while cond() {\n         borrow_mut(v);\n@@ -108,7 +113,8 @@ fn while_aliased_mut_break() {\n fn for_aliased_mut_break() {\n     // In this instance, the borrow is carried through the loop.\n \n-    let mut v = ~3, w = ~4;\n+    let mut v = ~3;\n+    let mut w = ~4;\n     let mut _x = &w;\n     for for_func {\n         // here we cannot be sure that `for_func` respects the break below\n@@ -120,7 +126,8 @@ fn for_aliased_mut_break() {\n }\n \n fn while_aliased_mut_cond(cond: bool, cond2: bool) {\n-    let mut v = ~3, w = ~4;\n+    let mut v = ~3;\n+    let mut w = ~4;\n     let mut x = &mut w;\n     while cond {\n         **x += 1;"}, {"sha": "43459acaaf1850d6ee6d01c088fa319bafd86d14", "filename": "src/test/compile-fail/borrowck-uniq-via-lend.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -48,13 +48,15 @@ fn aliased_mut() {\n }\n \n fn aliased_other() {\n-    let mut v = ~3, w = ~4;\n+    let mut v = ~3;\n+    let mut w = ~4;\n     let _x = &mut w;\n     borrow(v);\n }\n \n fn aliased_other_reassign() {\n-    let mut v = ~3, w = ~4;\n+    let mut v = ~3;\n+    let mut w = ~4;\n     let mut _x = &mut w;\n     _x = &mut v;\n     borrow(v); //~ ERROR cannot borrow `*v`"}, {"sha": "c6b5d8c42d5952ca545d604d90773941fdb329f7", "filename": "src/test/compile-fail/issue-3021-d.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -23,8 +23,8 @@ fn siphash(k0 : u64, k1 : u64) -> siphash {\n \n     fn mk_result(st : SipState) -> u64 {\n \n-        let v0 = st.v0,\n-            v1 = st.v1;\n+        let v0 = st.v0;\n+        let v1 = st.v1;\n         return v0 ^ v1;\n     }\n "}, {"sha": "9b0249bdc2a59fa84ee9a05e2b72a2651eb97ad0", "filename": "src/test/compile-fail/lint-unused-mut-variables.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -17,8 +17,8 @@\n fn main() {\n     // negative cases\n     let mut a = 3; //~ ERROR: variable does not need to be mutable\n-    let mut a = 2, b = 3; //~ ERROR: variable does not need to be mutable\n-                          //~^ ERROR: variable does not need to be mutable\n+    let mut a = 2; //~ ERROR: variable does not need to be mutable\n+    let mut b = 3; //~ ERROR: variable does not need to be mutable\n     let mut a = ~[3]; //~ ERROR: variable does not need to be mutable\n \n     // positive cases"}, {"sha": "38718006d8b186d4330c53e512eb5990d3b1c8c6", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -26,7 +26,8 @@ fn f21() {\n }\n \n fn f30(cond: bool) {\n-    let x = ~\"hi\", y = ~\"ho\";\n+    let x = ~\"hi\";\n+    let y = ~\"ho\";\n     let _y = if cond {\n         x\n     } else {\n@@ -37,7 +38,8 @@ fn f30(cond: bool) {\n }\n \n fn f40(cond: bool) {\n-    let x = ~\"hi\", y = ~\"ho\";\n+    let x = ~\"hi\";\n+    let y = ~\"ho\";\n     let _y = match cond {\n         true => x,\n         false => y\n@@ -47,7 +49,8 @@ fn f40(cond: bool) {\n }\n \n fn f50(cond: bool) {\n-    let x = ~\"hi\", y = ~\"ho\";\n+    let x = ~\"hi\";\n+    let y = ~\"ho\";\n     let _y = match cond {\n         _ if guard(x) => 10,\n         true => 10,"}, {"sha": "6f4a3f5ab1d2e337883fbe208a424ceef74f95fb", "filename": "src/test/run-fail/issue-3029.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-3029.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -10,7 +10,8 @@\n \n // error-pattern:so long\n fn main() {\n-    let x = ~[], y = ~[3];\n+    let x = ~[];\n+    let y = ~[3];\n     fail!(\"so long\");\n     x += y;\n     ~\"good\" + ~\"bye\";"}, {"sha": "f31fea526391ce8177b57e311a1ee9a165734820", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -31,7 +31,10 @@ fn enum_uints(start: uint, end: uint) -> ~[uint] {\n }\n \n fn main() {\n-    let a = 'a' as u8, j = 'j' as u8, k = 1, l = 9;\n+    let a = 'a' as u8;\n+    let j = 'j' as u8;\n+    let k = 1;\n+    let l = 9;\n     let chars = enum_chars(a, j);\n     let ints = enum_uints(k, l);\n "}, {"sha": "90a17625195739eb4b16b07147b537a74e4522e6", "filename": "src/test/run-pass/argument-passing.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargument-passing.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -24,7 +24,9 @@ fn f1(a: &mut X, b: &mut int, c: int) -> int {\n fn f2(a: int, f: &fn(int)) -> int { f(1); return a; }\n \n pub fn main() {\n-    let mut a = X {x: 1}, b = 2, c = 3;\n+    let mut a = X {x: 1};\n+    let mut b = 2;\n+    let mut c = 3;\n     assert_eq!(f1(&mut a, &mut b, c), 6);\n     assert_eq!(a.x, 0);\n     assert_eq!(b, 10);"}, {"sha": "4483c7fa4e9c55af1ac5f6f1720472dc26660ff2", "filename": "src/test/run-pass/borrowck-preserve-cond-box.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -17,7 +17,8 @@ fn testfn(cond: bool) {\n     // borrow x and y\n     let mut r_x = &*x;\n     let mut r_y = &*y;\n-    let mut r = r_x, exp = 3;\n+    let mut r = r_x;\n+    let mut exp = 3;\n \n     if cond {\n         r = r_y;"}, {"sha": "e3cca832b75e4149c1b5322b6ef1d915b66b863f", "filename": "src/test/run-pass/deriving-cmp-generic-enum.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -16,7 +16,11 @@ enum E<T> {\n }\n \n pub fn main() {\n-    let e0 = E0, e11 = E1(1), e12 = E1(2), e21 = E2(1,1), e22 = E2(1, 2);\n+    let e0 = E0;\n+    let e11 = E1(1);\n+    let e12 = E1(2);\n+    let e21 = E2(1, 1);\n+    let e22 = E2(1, 2);\n \n     // in order for both Ord and TotalOrd\n     let es = [e0, e11, e12, e21, e22];\n@@ -26,8 +30,10 @@ pub fn main() {\n             let ord = i.cmp(&j);\n \n             let eq = i == j;\n-            let lt = i < j, le = i <= j;\n-            let gt = i > j, ge = i >= j;\n+            let lt = i < j;\n+            let le = i <= j;\n+            let gt = i > j;\n+            let ge = i >= j;\n \n             // Eq\n             assert_eq!(*e1 == *e2, eq);"}, {"sha": "4e49ecb8991f53a5a52cacab0132c234b79ad7d5", "filename": "src/test/run-pass/deriving-cmp-generic-struct.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -15,7 +15,8 @@ struct S<T> {\n }\n \n pub fn main() {\n-    let s1 = S {x: 1, y: 1}, s2 = S {x: 1, y: 2};\n+    let s1 = S {x: 1, y: 1};\n+    let s2 = S {x: 1, y: 2};\n \n     // in order for both Ord and TotalOrd\n     let ss = [s1, s2];\n@@ -25,8 +26,10 @@ pub fn main() {\n             let ord = i.cmp(&j);\n \n             let eq = i == j;\n-            let lt = i < j, le = i <= j;\n-            let gt = i > j, ge = i >= j;\n+            let lt = i < j;\n+            let le = i <= j;\n+            let gt = i > j;\n+            let ge = i >= j;\n \n             // Eq\n             assert_eq!(*s1 == *s2, eq);\n@@ -46,4 +49,4 @@ pub fn main() {\n             assert_eq!(s1.cmp(s2), ord);\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "f119b8b1c48e1472e15ef08cef4b565a28ffecdb", "filename": "src/test/run-pass/deriving-cmp-generic-tuple-struct.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -13,7 +13,8 @@ struct TS<T>(T,T);\n \n \n pub fn main() {\n-    let ts1 = TS(1, 1), ts2 = TS(1,2);\n+    let ts1 = TS(1, 1);\n+    let ts2 = TS(1, 2);\n \n     // in order for both Ord and TotalOrd\n     let tss = [ts1, ts2];\n@@ -23,8 +24,10 @@ pub fn main() {\n             let ord = i.cmp(&j);\n \n             let eq = i == j;\n-            let lt = i < j, le = i <= j;\n-            let gt = i > j, ge = i >= j;\n+            let lt = i < j;\n+            let le = i <= j;\n+            let gt = i > j;\n+            let ge = i >= j;\n \n             // Eq\n             assert_eq!(*ts1 == *ts2, eq);\n@@ -44,4 +47,4 @@ pub fn main() {\n             assert_eq!(ts1.cmp(ts2), ord);\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "e65e189ea93cf24b77f0d9f11f8d8f4e69b7bff8", "filename": "src/test/run-pass/deriving-self-lifetime.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fderiving-self-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fderiving-self-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-self-lifetime.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -14,7 +14,8 @@ struct A<'self> {\n }\n \n fn main() {\n-    let a = A { x: &1 }, b = A { x: &2 };\n+    let a = A { x: &1 };\n+    let b = A { x: &2 };\n \n     assert_eq!(a, a);\n     assert_eq!(b, b);"}, {"sha": "8e6865adce91820ebeac69c51323c0a04ac5d545", "filename": "src/test/run-pass/multi-let.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fmulti-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fmulti-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti-let.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -8,4 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn main() { let x = 10, y = x; assert!((y == 10)); }\n+pub fn main() {\n+    let x = 10;\n+    let y = x;\n+    assert!((y == 10));\n+}\n+"}, {"sha": "63196128ba5b664811805df16a9e3fbe17b38314", "filename": "src/test/run-pass/pass-by-copy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fpass-by-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fpass-by-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpass-by-copy.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -14,7 +14,8 @@ fn magic2(x: @int) { debug!(x); }\n struct A { a: @int }\n \n pub fn main() {\n-    let a = A {a: @10}, b = @10;\n+    let a = A {a: @10};\n+    let b = @10;\n     magic(a); magic(A {a: @20});\n     magic2(b); magic2(@20);\n }"}, {"sha": "17eab78f8208441438193c05f82672f5a1fe2c86", "filename": "src/test/run-pass/pure-sum.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fpure-sum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fpure-sum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpure-sum.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -11,7 +11,8 @@\n // Check that functions can modify local state.\n \n fn sums_to(v: ~[int], sum: int) -> bool {\n-    let mut i = 0u, sum0 = 0;\n+    let mut i = 0u;\n+    let mut sum0 = 0;\n     while i < v.len() {\n         sum0 += v[i];\n         i += 1u;\n@@ -20,7 +21,8 @@ fn sums_to(v: ~[int], sum: int) -> bool {\n }\n \n fn sums_to_using_uniq(v: ~[int], sum: int) -> bool {\n-    let mut i = 0u, sum0 = ~0;\n+    let mut i = 0u;\n+    let mut sum0 = ~0;\n     while i < v.len() {\n         *sum0 += v[i];\n         i += 1u;\n@@ -29,7 +31,8 @@ fn sums_to_using_uniq(v: ~[int], sum: int) -> bool {\n }\n \n fn sums_to_using_rec(v: ~[int], sum: int) -> bool {\n-    let mut i = 0u, sum0 = F {f: 0};\n+    let mut i = 0u;\n+    let mut sum0 = F {f: 0};\n     while i < v.len() {\n         sum0.f += v[i];\n         i += 1u;\n@@ -40,7 +43,8 @@ fn sums_to_using_rec(v: ~[int], sum: int) -> bool {\n struct F<T> { f: T }\n \n fn sums_to_using_uniq_rec(v: ~[int], sum: int) -> bool {\n-    let mut i = 0u, sum0 = F {f: ~0};\n+    let mut i = 0u;\n+    let mut sum0 = F {f: ~0};\n     while i < v.len() {\n         *sum0.f += v[i];\n         i += 1u;"}, {"sha": "80e6293bf50af6594e2111b1fca67529e950e0c1", "filename": "src/test/run-pass/ret-break-cont-in-block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -14,7 +14,8 @@ use std::cmp::Eq;\n use std::vec;\n \n fn iter<T>(v: ~[T], it: &fn(&T) -> bool) -> bool {\n-    let mut i = 0u, l = v.len();\n+    let mut i = 0u;\n+    let mut l = v.len();\n     while i < l {\n         if !it(&v[i]) { return false; }\n         i += 1u;"}, {"sha": "42910c47005811e95ad887cb2f4871534774db12", "filename": "src/test/run-pass/typestate-multi-decl.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Ftypestate-multi-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Ftypestate-multi-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypestate-multi-decl.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -8,4 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn main() { let x = 10, y = 20; let z = x + y; assert!((z == 30)); }\n+pub fn main() {\n+    let (x, y) = (10, 20);\n+    let z = x + y;\n+    assert!((z == 30));\n+}"}, {"sha": "d97148746d01b2342f4e007142c937cb49013d68", "filename": "src/test/run-pass/zip-same-length.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de82bde00dbf1d293eaac9f86e3e7c7967888263/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzip-same-length.rs?ref=de82bde00dbf1d293eaac9f86e3e7c7967888263", "patch": "@@ -30,7 +30,10 @@ fn enum_uints(start: uint, end: uint) -> ~[uint] {\n }\n \n pub fn main() {\n-    let a = 'a' as u8, j = 'j' as u8, k = 1u, l = 10u;\n+    let a = 'a' as u8;\n+    let j = 'j' as u8;\n+    let k = 1u;\n+    let l = 10u;\n     let chars = enum_chars(a, j);\n     let ints = enum_uints(k, l);\n "}]}