{"sha": "78884b765915c551e5f3fe71b185d91ec4c186de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ODg0Yjc2NTkxNWM1NTFlNWYzZmU3MWIxODVkOTFlYzRjMTg2ZGU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-07T16:14:28Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-07T16:14:28Z"}, "message": "mir: qualify and promote constants.", "tree": {"sha": "612cbfedc75026c314e630a3bc57fee6f4d76089", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/612cbfedc75026c314e630a3bc57fee6f4d76089"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78884b765915c551e5f3fe71b185d91ec4c186de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78884b765915c551e5f3fe71b185d91ec4c186de", "html_url": "https://github.com/rust-lang/rust/commit/78884b765915c551e5f3fe71b185d91ec4c186de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78884b765915c551e5f3fe71b185d91ec4c186de/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14efbf148109888f939f671fbd5b60650c5f4744", "url": "https://api.github.com/repos/rust-lang/rust/commits/14efbf148109888f939f671fbd5b60650c5f4744", "html_url": "https://github.com/rust-lang/rust/commit/14efbf148109888f939f671fbd5b60650c5f4744"}], "stats": {"total": 2679, "additions": 1895, "deletions": 784}, "files": [{"sha": "48c1e4ad59d5bbe752a7cdb20da2d6ae41a061ca", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -111,7 +111,7 @@ DEPS_rustc_lint := rustc log syntax rustc_const_eval\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_rustc_metadata := rustc syntax rbml rustc_const_math\n DEPS_rustc_passes := syntax rustc core rustc_const_eval\n-DEPS_rustc_mir := rustc syntax rustc_const_math rustc_const_eval\n+DEPS_rustc_mir := rustc syntax rustc_const_math rustc_const_eval rustc_bitflags\n DEPS_rustc_resolve := arena rustc log syntax\n DEPS_rustc_platform_intrinsics := std\n DEPS_rustc_plugin := rustc rustc_metadata syntax rustc_mir"}, {"sha": "1b570933beeccd495c4b3ad7476e4fe0ba3d58b0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -37,7 +37,7 @@ use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n use rustc::hir::lowering::{lower_crate, LoweringContext};\n-use rustc_passes::{no_asm, loops, consts, const_fn, rvalues, static_recursion};\n+use rustc_passes::{no_asm, loops, consts, rvalues, static_recursion};\n use rustc_const_eval::check_match;\n use super::Compilation;\n \n@@ -726,10 +726,6 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         })\n     })?;\n \n-    time(time_passes,\n-         \"const fn bodies and arguments\",\n-         || const_fn::check_crate(sess, &krate))?;\n-\n     if sess.opts.debugging_opts.input_stats {\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }\n@@ -903,6 +899,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n             let mut passes = sess.mir_passes.borrow_mut();\n             // Push all the built-in passes.\n             passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n+            passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n             passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg);\n             passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);"}, {"sha": "77dccb7e0d48347b96500dfb62bd408563aa7d16", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -16,4 +16,5 @@ rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_bitflags = { path = \"../librustc_bitflags\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "c6765f95d33caf9e68715d51625948aded39bf0d", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -84,7 +84,7 @@ pub struct ScopeAuxiliary {\n     pub postdoms: Vec<Location>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Location {\n     /// the location is within this block\n     pub block: BasicBlock,"}, {"sha": "30d3a39e473dfefa0cf96998ad3f6f0dc8973e6b", "filename": "src/librustc_mir/diagnostics.rs", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -0,0 +1,387 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+register_long_diagnostics! {\n+\n+E0010: r##\"\n+The value of statics and constants must be known at compile time, and they live\n+for the entire lifetime of a program. Creating a boxed value allocates memory on\n+the heap at runtime, and therefore cannot be done at compile time. Erroneous\n+code example:\n+\n+```compile_fail\n+#![feature(box_syntax)]\n+\n+const CON : Box<i32> = box 0;\n+```\n+\"##,\n+\n+E0013: r##\"\n+Static and const variables can refer to other const variables. But a const\n+variable cannot refer to a static variable. For example, `Y` cannot refer to\n+`X` here:\n+\n+```compile_fail\n+static X: i32 = 42;\n+const Y: i32 = X;\n+```\n+\n+To fix this, the value can be extracted as a const and then used:\n+\n+```\n+const A: i32 = 42;\n+static X: i32 = A;\n+const Y: i32 = A;\n+```\n+\"##,\n+\n+// FIXME(#24111) Change the language here when const fn stabilizes\n+E0015: r##\"\n+The only functions that can be called in static or constant expressions are\n+`const` functions, and struct/enum constructors. `const` functions are only\n+available on a nightly compiler. Rust currently does not support more general\n+compile-time function execution.\n+\n+```\n+const FOO: Option<u8> = Some(1); // enum constructor\n+struct Bar {x: u8}\n+const BAR: Bar = Bar {x: 1}; // struct constructor\n+```\n+\n+See [RFC 911] for more details on the design of `const fn`s.\n+\n+[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n+\"##,\n+\n+E0016: r##\"\n+Blocks in constants may only contain items (such as constant, function\n+definition, etc...) and a tail expression. Erroneous code example:\n+\n+```compile_fail\n+const FOO: i32 = { let x = 0; x }; // 'x' isn't an item!\n+```\n+\n+To avoid it, you have to replace the non-item object:\n+\n+```\n+const FOO: i32 = { const X : i32 = 0; X };\n+```\n+\"##,\n+\n+E0017: r##\"\n+References in statics and constants may only refer to immutable values.\n+Erroneous code example:\n+\n+```compile_fail\n+static X: i32 = 1;\n+const C: i32 = 2;\n+\n+// these three are not allowed:\n+const CR: &'static mut i32 = &mut C;\n+static STATIC_REF: &'static mut i32 = &mut X;\n+static CONST_REF: &'static mut i32 = &mut C;\n+```\n+\n+Statics are shared everywhere, and if they refer to mutable data one might\n+violate memory safety since holding multiple mutable references to shared data\n+is not allowed.\n+\n+If you really want global mutable state, try using `static mut` or a global\n+`UnsafeCell`.\n+\"##,\n+\n+E0018: r##\"\n+\n+The value of static and constant integers must be known at compile time. You\n+can't cast a pointer to an integer because the address of a pointer can\n+vary.\n+\n+For example, if you write:\n+\n+```compile_fail\n+static MY_STATIC: u32 = 42;\n+static MY_STATIC_ADDR: usize = &MY_STATIC as *const _ as usize;\n+static WHAT: usize = (MY_STATIC_ADDR^17) + MY_STATIC_ADDR;\n+```\n+\n+Then `MY_STATIC_ADDR` would contain the address of `MY_STATIC`. However,\n+the address can change when the program is linked, as well as change\n+between different executions due to ASLR, and many linkers would\n+not be able to calculate the value of `WHAT`.\n+\n+On the other hand, static and constant pointers can point either to\n+a known numeric address or to the address of a symbol.\n+\n+```\n+static MY_STATIC_ADDR: &'static u32 = &MY_STATIC;\n+// ... and also\n+static MY_STATIC_ADDR2: *const u32 = &MY_STATIC;\n+\n+const CONST_ADDR: *const u8 = 0x5f3759df as *const u8;\n+```\n+\n+This does not pose a problem by itself because they can't be\n+accessed directly.\n+\"##,\n+\n+E0019: r##\"\n+A function call isn't allowed in the const's initialization expression\n+because the expression's value must be known at compile-time. Erroneous code\n+example:\n+\n+```compile_fail\n+enum Test {\n+    V1\n+}\n+\n+impl Test {\n+    fn test(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+fn main() {\n+    const FOO: Test = Test::V1;\n+\n+    const A: i32 = FOO.test(); // You can't call Test::func() here !\n+}\n+```\n+\n+Remember: you can't use a function call inside a const's initialization\n+expression! However, you can totally use it anywhere else:\n+\n+```\n+fn main() {\n+    const FOO: Test = Test::V1;\n+\n+    FOO.func(); // here is good\n+    let x = FOO.func(); // or even here!\n+}\n+```\n+\"##,\n+\n+E0022: r##\"\n+Constant functions are not allowed to mutate anything. Thus, binding to an\n+argument with a mutable pattern is not allowed. For example,\n+\n+```compile_fail\n+const fn foo(mut x: u8) {\n+    // do stuff\n+}\n+```\n+\n+Is incorrect because the function body may not mutate `x`.\n+\n+Remove any mutable bindings from the argument list to fix this error. In case\n+you need to mutate the argument, try lazily initializing a global variable\n+instead of using a `const fn`, or refactoring the code to a functional style to\n+avoid mutation if possible.\n+\"##,\n+\n+E0394: r##\"\n+From [RFC 246]:\n+\n+ > It is invalid for a static to reference another static by value. It is\n+ > required that all references be borrowed.\n+\n+[RFC 246]: https://github.com/rust-lang/rfcs/pull/246\n+\"##,\n+\n+\n+E0395: r##\"\n+The value assigned to a constant scalar must be known at compile time,\n+which is not the case when comparing raw pointers.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+static FOO: i32 = 42;\n+static BAR: i32 = 42;\n+\n+static BAZ: bool = { (&FOO as *const i32) == (&BAR as *const i32) };\n+// error: raw pointers cannot be compared in statics!\n+```\n+\n+The address assigned by the linker to `FOO` and `BAR` may or may not\n+be identical, so the value of `BAZ` can't be determined.\n+\n+If you want to do the comparison, please do it at run-time.\n+\n+For example:\n+\n+```\n+static FOO: i32 = 42;\n+static BAR: i32 = 42;\n+\n+let baz: bool = { (&FOO as *const i32) == (&BAR as *const i32) };\n+// baz isn't a constant expression so it's ok\n+```\n+\"##,\n+\n+E0396: r##\"\n+The value behind a raw pointer can't be determined at compile-time\n+(or even link-time), which means it can't be used in a constant\n+expression. Erroneous code example:\n+\n+```compile_fail\n+const REG_ADDR: *const u8 = 0x5f3759df as *const u8;\n+\n+const VALUE: u8 = unsafe { *REG_ADDR };\n+// error: raw pointers cannot be dereferenced in constants\n+```\n+\n+A possible fix is to dereference your pointer at some point in run-time.\n+\n+For example:\n+\n+```\n+const REG_ADDR: *const u8 = 0x5f3759df as *const u8;\n+\n+let reg_value = unsafe { *REG_ADDR };\n+```\n+\"##,\n+\n+E0492: r##\"\n+A borrow of a constant containing interior mutability was attempted. Erroneous\n+code example:\n+\n+```compile_fail\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n+\n+const A: AtomicUsize = ATOMIC_USIZE_INIT;\n+static B: &'static AtomicUsize = &A;\n+// error: cannot borrow a constant which contains interior mutability, create a\n+//        static instead\n+```\n+\n+A `const` represents a constant value that should never change. If one takes\n+a `&` reference to the constant, then one is taking a pointer to some memory\n+location containing the value. Normally this is perfectly fine: most values\n+can't be changed via a shared `&` pointer, but interior mutability would allow\n+it. That is, a constant value could be mutated. On the other hand, a `static` is\n+explicitly a single memory location, which can be mutated at will.\n+\n+So, in order to solve this error, either use statics which are `Sync`:\n+\n+```\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n+\n+static A: AtomicUsize = ATOMIC_USIZE_INIT;\n+static B: &'static AtomicUsize = &A; // ok!\n+```\n+\n+You can also have this error while using a cell type:\n+\n+```compile_fail\n+#![feature(const_fn)]\n+\n+use std::cell::Cell;\n+\n+const A: Cell<usize> = Cell::new(1);\n+const B: &'static Cell<usize> = &A;\n+// error: cannot borrow a constant which contains interior mutability, create\n+//        a static instead\n+\n+// or:\n+struct C { a: Cell<usize> }\n+\n+const D: C = C { a: Cell::new(1) };\n+const E: &'static Cell<usize> = &D.a; // error\n+\n+// or:\n+const F: &'static C = &D; // error\n+```\n+\n+This is because cell types do operations that are not thread-safe. Due to this,\n+they don't implement Sync and thus can't be placed in statics. In this\n+case, `StaticMutex` would work just fine, but it isn't stable yet:\n+https://doc.rust-lang.org/nightly/std/sync/struct.StaticMutex.html\n+\n+However, if you still wish to use these types, you can achieve this by an unsafe\n+wrapper:\n+\n+```\n+#![feature(const_fn)]\n+\n+use std::cell::Cell;\n+use std::marker::Sync;\n+\n+struct NotThreadSafe<T> {\n+    value: Cell<T>,\n+}\n+\n+unsafe impl<T> Sync for NotThreadSafe<T> {}\n+\n+static A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };\n+static B: &'static NotThreadSafe<usize> = &A; // ok!\n+```\n+\n+Remember this solution is unsafe! You will have to ensure that accesses to the\n+cell are synchronized.\n+\"##,\n+\n+E0493: r##\"\n+A type with a destructor was assigned to an invalid type of variable. Erroneous\n+code example:\n+\n+```compile_fail\n+struct Foo {\n+    a: u32\n+}\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {}\n+}\n+\n+const F : Foo = Foo { a : 0 };\n+// error: constants are not allowed to have destructors\n+static S : Foo = Foo { a : 0 };\n+// error: statics are not allowed to have destructors\n+```\n+\n+To solve this issue, please use a type which does allow the usage of type with\n+destructors.\n+\"##,\n+\n+E0494: r##\"\n+A reference of an interior static was assigned to another const/static.\n+Erroneous code example:\n+\n+```compile_fail\n+struct Foo {\n+    a: u32\n+}\n+\n+static S : Foo = Foo { a : 0 };\n+static A : &'static u32 = &S.a;\n+// error: cannot refer to the interior of another static, use a\n+//        constant instead\n+```\n+\n+The \"base\" variable has to be a const if you want another static/const variable\n+to refer to one of its fields. Example:\n+\n+```\n+struct Foo {\n+    a: u32\n+}\n+\n+const S : Foo = Foo { a : 0 };\n+static A : &'static u32 = &S.a; // ok!\n+```\n+\"##,\n+\n+}\n+\n+register_diagnostics! {\n+    E0526, // shuffle indices are not constant\n+}"}, {"sha": "049426db2f4d09f9e50683bdc7402c35836e0e71", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -351,21 +351,39 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr\n                                     pass_args, lhs.to_ref(), vec![rhs])\n             } else {\n                 // FIXME overflow\n-                match op.node {\n-                    hir::BinOp_::BiAnd => {\n+                match (op.node, cx.constness) {\n+                    // FIXME(eddyb) use logical ops in constants when\n+                    // they can handle that kind of control-flow.\n+                    (hir::BinOp_::BiAnd, hir::Constness::Const) => {\n+                        ExprKind::Binary {\n+                            op: BinOp::BitAnd,\n+                            lhs: lhs.to_ref(),\n+                            rhs: rhs.to_ref(),\n+                        }\n+                    }\n+                    (hir::BinOp_::BiOr, hir::Constness::Const) => {\n+                        ExprKind::Binary {\n+                            op: BinOp::BitOr,\n+                            lhs: lhs.to_ref(),\n+                            rhs: rhs.to_ref(),\n+                        }\n+                    }\n+\n+                    (hir::BinOp_::BiAnd, hir::Constness::NotConst) => {\n                         ExprKind::LogicalOp {\n                             op: LogicalOp::And,\n                             lhs: lhs.to_ref(),\n                             rhs: rhs.to_ref(),\n                         }\n                     }\n-                    hir::BinOp_::BiOr => {\n+                    (hir::BinOp_::BiOr, hir::Constness::NotConst) => {\n                         ExprKind::LogicalOp {\n                             op: LogicalOp::Or,\n                             lhs: lhs.to_ref(),\n                             rhs: rhs.to_ref(),\n                         }\n                     }\n+\n                     _ => {\n                         let op = bin_op(op.node);\n                         ExprKind::Binary {"}, {"sha": "5274b5e9abad8a82e52b16354370ca95ec1d7a75", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -32,13 +32,17 @@ use rustc_const_math::{ConstInt, ConstUsize};\n pub struct Cx<'a, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n     infcx: &'a InferCtxt<'a, 'tcx>,\n+    constness: hir::Constness\n }\n \n impl<'a,'tcx> Cx<'a,'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Cx<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>,\n+               constness: hir::Constness)\n+               -> Cx<'a, 'tcx> {\n         Cx {\n             tcx: infcx.tcx,\n             infcx: infcx,\n+            constness: constness,\n         }\n     }\n }"}, {"sha": "79d11e78bde5af65d08b7e4a1382dd665970e2c4", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -20,7 +20,9 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![cfg_attr(not(stage0), deny(warnings))]\n #![unstable(feature = \"rustc_private\", issue = \"27812\")]\n \n+#![feature(associated_consts)]\n #![feature(box_patterns)]\n+#![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(question_mark)]\n@@ -31,10 +33,16 @@ extern crate graphviz as dot;\n extern crate rustc;\n extern crate rustc_data_structures;\n extern crate rustc_back;\n+#[macro_use]\n+#[no_link]\n+extern crate rustc_bitflags;\n+#[macro_use]\n extern crate syntax;\n extern crate rustc_const_math;\n extern crate rustc_const_eval;\n \n+pub mod diagnostics;\n+\n pub mod build;\n pub mod graphviz;\n mod hair;"}, {"sha": "d771c80438921f7f4d13e4366338f1956082b984", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -29,7 +29,8 @@ use rustc::traits::ProjectionMode;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, FnKind, Visitor};\n+use rustc::hir::map::blocks::FnLikeNode;\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -59,13 +60,27 @@ impl<'a, 'tcx> BuildMir<'a, 'tcx> {\n     fn build<F>(&mut self, src: MirSource, f: F)\n         where F: for<'b> FnOnce(Cx<'b, 'tcx>) -> (Mir<'tcx>, build::ScopeAuxiliaryVec)\n     {\n+        let constness = match src {\n+            MirSource::Const(_) |\n+            MirSource::Static(..) => hir::Constness::Const,\n+            MirSource::Fn(id) => {\n+                let fn_like = FnLikeNode::from_node(self.tcx.map.get(id));\n+                match fn_like.map(|f| f.kind()) {\n+                    Some(FnKind::ItemFn(_, _, _, c, _, _, _)) => c,\n+                    Some(FnKind::Method(_, m, _, _)) => m.constness,\n+                    _ => hir::Constness::NotConst\n+                }\n+            }\n+            MirSource::Promoted(..) => bug!()\n+        };\n+\n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, src.item_id());\n         let infcx = infer::new_infer_ctxt(self.tcx,\n                                           &self.tcx.tables,\n                                           Some(param_env),\n                                           ProjectionMode::AnyFinal);\n \n-        let (mir, scope_auxiliary) = f(Cx::new(&infcx));\n+        let (mir, scope_auxiliary) = f(Cx::new(&infcx, constness));\n \n         pretty::dump_mir(self.tcx, \"mir_map\", &0, src, &mir, Some(&scope_auxiliary));\n \n@@ -151,7 +166,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self,\n-                fk: intravisit::FnKind<'tcx>,\n+                fk: FnKind<'tcx>,\n                 decl: &'tcx hir::FnDecl,\n                 body: &'tcx hir::Block,\n                 span: Span,\n@@ -165,7 +180,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n             }\n         };\n \n-        let implicit_argument = if let intravisit::FnKind::Closure(..) = fk {\n+        let implicit_argument = if let FnKind::Closure(..) = fk {\n             Some((closure_self_ty(&self.tcx, id, body.id), None))\n         } else {\n             None"}, {"sha": "51f5c3cd7f53d9c7000c717a1ec4f0d3b0a2ec66", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -14,3 +14,5 @@ pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;\n pub mod break_critical_edges;\n+pub mod promote_consts;\n+pub mod qualify_consts;"}, {"sha": "c5ebe708eb45694ea6d062780134751b3c11d3af", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -0,0 +1,412 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A pass that promotes borrows of constant rvalues.\n+//!\n+//! The rvalues considered constant are trees of temps,\n+//! each with exactly one initialization, and holding\n+//! a constant value with no interior mutability.\n+//! They are placed into a new MIR constant body in\n+//! `promoted` and the borrow rvalue is replaced with\n+//! a `Literal::Promoted` using the index into `promoted`\n+//! of that constant MIR.\n+//!\n+//! This pass assumes that every use is dominated by an\n+//! initialization and can otherwise silence errors, if\n+//! move analysis runs after promotion on broken MIR.\n+\n+use rustc::mir::repr::*;\n+use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n+use rustc::ty::{self, TyCtxt};\n+use syntax::codemap::Span;\n+\n+use build::Location;\n+use traversal::ReversePostorder;\n+\n+use std::mem;\n+\n+/// State of a temporary during collection and promotion.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum TempState {\n+    /// No references to this temp.\n+    Undefined,\n+    /// One direct assignment and any number of direct uses.\n+    /// A borrow of this temp is promotable if the assigned\n+    /// value is qualified as constant.\n+    Defined {\n+        location: Location,\n+        uses: usize\n+    },\n+    /// Any other combination of assignments/uses.\n+    Unpromotable,\n+    /// This temp was part of an rvalue which got extracted\n+    /// during promotion and needs cleanup.\n+    PromotedOut\n+}\n+\n+impl TempState {\n+    pub fn is_promotable(&self) -> bool {\n+        if let TempState::Defined { uses, .. } = *self {\n+            uses > 0\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// A \"root candidate\" for promotion, which will become the\n+/// returned value in a promoted MIR, unless it's a subset\n+/// of a larger candidate.\n+pub enum Candidate {\n+    /// Borrow of a constant temporary.\n+    Ref(Location),\n+\n+    /// Array of indices found in the third argument of\n+    /// a call to one of the simd_shuffleN intrinsics.\n+    ShuffleIndices(BasicBlock)\n+}\n+\n+struct TempCollector {\n+    temps: Vec<TempState>,\n+    location: Location,\n+    span: Span\n+}\n+\n+impl<'tcx> Visitor<'tcx> for TempCollector {\n+    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext) {\n+        self.super_lvalue(lvalue, context);\n+        if let Lvalue::Temp(index) = *lvalue {\n+            // Ignore drops, if the temp gets promoted,\n+            // then it's constant and thus drop is noop.\n+            if let LvalueContext::Drop = context {\n+                return;\n+            }\n+\n+            let temp = &mut self.temps[index as usize];\n+            if *temp == TempState::Undefined {\n+                match context {\n+                    LvalueContext::Store |\n+                    LvalueContext::Call => {\n+                        *temp = TempState::Defined {\n+                            location: self.location,\n+                            uses: 0\n+                        };\n+                        return;\n+                    }\n+                    _ => { /* mark as unpromotable below */ }\n+                }\n+            } else if let TempState::Defined { ref mut uses, .. } = *temp {\n+                match context {\n+                    LvalueContext::Borrow {..} |\n+                    LvalueContext::Consume |\n+                    LvalueContext::Inspect => {\n+                        *uses += 1;\n+                        return;\n+                    }\n+                    _ => { /* mark as unpromotable below */ }\n+                }\n+            }\n+            *temp = TempState::Unpromotable;\n+        }\n+    }\n+\n+    fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>) {\n+        assert_eq!(self.location.block, bb);\n+        self.span = statement.span;\n+        self.super_statement(bb, statement);\n+        self.location.statement_index += 1;\n+    }\n+\n+    fn visit_terminator(&mut self, bb: BasicBlock, terminator: &Terminator<'tcx>) {\n+        self.span = terminator.span;\n+        self.super_terminator(bb, terminator);\n+    }\n+\n+    fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n+        self.location.statement_index = 0;\n+        self.location.block = bb;\n+        self.super_basic_block_data(bb, data);\n+    }\n+}\n+\n+pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> Vec<TempState> {\n+    let mut collector = TempCollector {\n+        temps: vec![TempState::Undefined; mir.temp_decls.len()],\n+        location: Location {\n+            block: START_BLOCK,\n+            statement_index: 0\n+        },\n+        span: mir.span\n+    };\n+    for (bb, data) in rpo {\n+        collector.visit_basic_block_data(bb, data);\n+    }\n+    collector.temps\n+}\n+\n+struct Promoter<'a, 'tcx: 'a> {\n+    source: &'a mut Mir<'tcx>,\n+    promoted: Mir<'tcx>,\n+    temps: &'a mut Vec<TempState>,\n+\n+    /// If true, all nested temps are also kept in the\n+    /// source MIR, not moved to the promoted MIR.\n+    keep_original: bool\n+}\n+\n+impl<'a, 'tcx> Promoter<'a, 'tcx> {\n+    fn new_block(&mut self) -> BasicBlock {\n+        let index = self.promoted.basic_blocks.len();\n+        self.promoted.basic_blocks.push(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator {\n+                span: self.promoted.span,\n+                scope: ScopeId::new(0),\n+                kind: TerminatorKind::Return\n+            }),\n+            is_cleanup: false\n+        });\n+        BasicBlock::new(index)\n+    }\n+\n+    fn assign(&mut self, dest: Lvalue<'tcx>, rvalue: Rvalue<'tcx>, span: Span) {\n+        let data = self.promoted.basic_blocks.last_mut().unwrap();\n+        data.statements.push(Statement {\n+            span: span,\n+            scope: ScopeId::new(0),\n+            kind: StatementKind::Assign(dest, rvalue)\n+        });\n+    }\n+\n+    /// Copy the initialization of this temp to the\n+    /// promoted MIR, recursing through temps.\n+    fn promote_temp(&mut self, index: u32) -> u32 {\n+        let index = index as usize;\n+        let old_keep_original = self.keep_original;\n+        let (bb, stmt_idx) = match self.temps[index] {\n+            TempState::Defined {\n+                location: Location { block, statement_index },\n+                uses\n+            } if uses > 0 => {\n+                if uses > 1 {\n+                    self.keep_original = true;\n+                }\n+                (block, statement_index)\n+            }\n+            temp =>  {\n+                span_bug!(self.promoted.span, \"tmp{} not promotable: {:?}\",\n+                          index, temp);\n+            }\n+        };\n+        if !self.keep_original {\n+            self.temps[index] = TempState::PromotedOut;\n+        }\n+\n+        let no_stmts = self.source[bb].statements.len();\n+\n+        // First, take the Rvalue or Call out of the source MIR,\n+        // or duplicate it, depending on keep_original.\n+        let (mut rvalue, mut call) = (None, None);\n+        let span = if stmt_idx < no_stmts {\n+            let statement = &mut self.source[bb].statements[stmt_idx];\n+            let StatementKind::Assign(_, ref mut rhs) = statement.kind;\n+            if self.keep_original {\n+                rvalue = Some(rhs.clone());\n+            } else {\n+                let unit = Rvalue::Aggregate(AggregateKind::Tuple, vec![]);\n+                rvalue = Some(mem::replace(rhs, unit));\n+            }\n+            statement.span\n+        } else if self.keep_original {\n+            let terminator = self.source[bb].terminator().clone();\n+            call = Some(terminator.kind);\n+            terminator.span\n+        } else {\n+            let terminator = self.source[bb].terminator_mut();\n+            let target = match terminator.kind {\n+                TerminatorKind::Call {\n+                    destination: ref mut dest @ Some(_),\n+                    ref mut cleanup, ..\n+                } => {\n+                    // No cleanup necessary.\n+                    cleanup.take();\n+\n+                    // We'll put a new destination in later.\n+                    dest.take().unwrap().1\n+                }\n+                ref kind => {\n+                    span_bug!(terminator.span, \"{:?} not promotable\", kind);\n+                }\n+            };\n+            call = Some(mem::replace(&mut terminator.kind, TerminatorKind::Goto {\n+                target: target\n+            }));\n+            terminator.span\n+        };\n+\n+        // Then, recurse for components in the Rvalue or Call.\n+        if stmt_idx < no_stmts {\n+            self.visit_rvalue(rvalue.as_mut().unwrap());\n+        } else {\n+            self.visit_terminator_kind(bb, call.as_mut().unwrap());\n+        }\n+\n+        let new_index = self.promoted.temp_decls.len() as u32;\n+        let new_temp = Lvalue::Temp(new_index);\n+        self.promoted.temp_decls.push(TempDecl {\n+            ty: self.source.temp_decls[index].ty\n+        });\n+\n+        // Inject the Rvalue or Call into the promoted MIR.\n+        if stmt_idx < no_stmts {\n+            self.assign(new_temp, rvalue.unwrap(), span);\n+        } else {\n+            let last = self.promoted.basic_blocks.len() - 1;\n+            let new_target = self.new_block();\n+            let mut call = call.unwrap();\n+            match call {\n+                TerminatorKind::Call { ref mut destination, ..}  => {\n+                    *destination = Some((new_temp, new_target));\n+                }\n+                _ => bug!()\n+            }\n+            let terminator = &mut self.promoted.basic_blocks[last].terminator_mut();\n+            terminator.span = span;\n+            terminator.kind = call;\n+        }\n+\n+        // Restore the old duplication state.\n+        self.keep_original = old_keep_original;\n+\n+        new_index\n+    }\n+\n+    fn promote_candidate(mut self, candidate: Candidate) {\n+        let span = self.promoted.span;\n+        let new_operand = Operand::Constant(Constant {\n+            span: span,\n+            ty: self.promoted.return_ty.unwrap(),\n+            literal: Literal::Promoted {\n+                index: self.source.promoted.len()\n+            }\n+        });\n+        let mut rvalue = match candidate {\n+            Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n+                match self.source[bb].statements[stmt_idx].kind {\n+                    StatementKind::Assign(_, ref mut rvalue) => {\n+                        mem::replace(rvalue, Rvalue::Use(new_operand))\n+                    }\n+                }\n+            }\n+            Candidate::ShuffleIndices(bb) => {\n+                match self.source[bb].terminator_mut().kind {\n+                    TerminatorKind::Call { ref mut args, .. } => {\n+                        Rvalue::Use(mem::replace(&mut args[2], new_operand))\n+                    }\n+                    _ => bug!()\n+                }\n+            }\n+        };\n+        self.visit_rvalue(&mut rvalue);\n+        self.assign(Lvalue::ReturnPointer, rvalue, span);\n+        self.source.promoted.push(self.promoted);\n+    }\n+}\n+\n+/// Replaces all temporaries with their promoted counterparts.\n+impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n+    fn visit_lvalue(&mut self, lvalue: &mut Lvalue<'tcx>, context: LvalueContext) {\n+        if let Lvalue::Temp(ref mut index) = *lvalue {\n+            *index = self.promote_temp(*index);\n+        }\n+        self.super_lvalue(lvalue, context);\n+    }\n+}\n+\n+pub fn promote_candidates<'tcx>(mir: &mut Mir<'tcx>,\n+                                tcx: &TyCtxt<'tcx>,\n+                                mut temps: Vec<TempState>,\n+                                candidates: Vec<Candidate>) {\n+    // Visit candidates in reverse, in case they're nested.\n+    for candidate in candidates.into_iter().rev() {\n+        let (span, ty) = match candidate {\n+            Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n+                let statement = &mir[bb].statements[stmt_idx];\n+                let StatementKind::Assign(ref dest, _) = statement.kind;\n+                if let Lvalue::Temp(index) = *dest {\n+                    if temps[index as usize] == TempState::PromotedOut {\n+                        // Already promoted.\n+                        continue;\n+                    }\n+                }\n+                (statement.span, mir.lvalue_ty(tcx, dest).to_ty(tcx))\n+            }\n+            Candidate::ShuffleIndices(bb) => {\n+                let terminator = mir[bb].terminator();\n+                let ty = match terminator.kind {\n+                    TerminatorKind::Call { ref args, .. } => {\n+                        mir.operand_ty(tcx, &args[2])\n+                    }\n+                    _ => {\n+                        span_bug!(terminator.span,\n+                                  \"expected simd_shuffleN call to promote\");\n+                    }\n+                };\n+                (terminator.span, ty)\n+            }\n+        };\n+\n+        let mut promoter = Promoter {\n+            source: mir,\n+            promoted: Mir {\n+                basic_blocks: vec![],\n+                scopes: vec![ScopeData {\n+                    span: span,\n+                    parent_scope: None\n+                }],\n+                promoted: vec![],\n+                return_ty: ty::FnConverging(ty),\n+                var_decls: vec![],\n+                arg_decls: vec![],\n+                temp_decls: vec![],\n+                upvar_decls: vec![],\n+                span: span\n+            },\n+            temps: &mut temps,\n+            keep_original: false\n+        };\n+        assert_eq!(promoter.new_block(), START_BLOCK);\n+        promoter.promote_candidate(candidate);\n+    }\n+\n+    // Eliminate assignments to, and drops of promoted temps.\n+    let promoted = |index: u32| temps[index as usize] == TempState::PromotedOut;\n+    for block in &mut mir.basic_blocks {\n+        block.statements.retain(|statement| {\n+            match statement.kind {\n+                StatementKind::Assign(Lvalue::Temp(index), _) => {\n+                    !promoted(index)\n+                }\n+                _ => true\n+            }\n+        });\n+        let terminator = block.terminator_mut();\n+        match terminator.kind {\n+            TerminatorKind::Drop { value: Lvalue::Temp(index), target, .. } => {\n+                if promoted(index) {\n+                    terminator.kind = TerminatorKind::Goto {\n+                        target: target\n+                    };\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "7728d43774f74c32492854cb292454ceb2ba1c1e", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "added", "additions": 1010, "deletions": 0, "changes": 1010, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -0,0 +1,1010 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A pass that qualifies constness of temporaries in constants,\n+//! static initializers and functions and also drives promotion.\n+//!\n+//! The Qualif flags below can be used to also provide better\n+//! diagnostics as to why a constant rvalue wasn't promoted.\n+\n+use rustc_data_structures::bitvec::BitVector;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::intravisit::FnKind;\n+use rustc::hir::map::blocks::FnLikeNode;\n+use rustc::infer;\n+use rustc::traits::{self, ProjectionMode};\n+use rustc::ty::{self, TyCtxt, Ty};\n+use rustc::ty::cast::CastTy;\n+use rustc::mir::repr::*;\n+use rustc::mir::mir_map::MirMap;\n+use rustc::mir::transform::{Pass, MirMapPass, MirSource};\n+use rustc::mir::visit::{LvalueContext, Visitor};\n+use rustc::util::nodemap::DefIdMap;\n+use syntax::abi::Abi;\n+use syntax::codemap::Span;\n+use syntax::feature_gate::UnstableFeatures;\n+\n+use std::collections::hash_map::Entry;\n+use std::fmt;\n+\n+use build::Location;\n+use traversal::{self, ReversePostorder};\n+\n+use super::promote_consts::{self, Candidate, TempState};\n+\n+bitflags! {\n+    flags Qualif: u8 {\n+        // Const item's qualification while recursing.\n+        // Recursive consts are an error.\n+        const RECURSIVE         = 1 << 0,\n+\n+        // Constant containing interior mutability (UnsafeCell).\n+        const MUTABLE_INTERIOR  = 1 << 1,\n+\n+        // Constant containing an ADT that implements Drop.\n+        const NEEDS_DROP        = 1 << 2,\n+\n+        // Function argument.\n+        const FN_ARGUMENT       = 1 << 3,\n+\n+        // Static lvalue or move from a static.\n+        const STATIC            = 1 << 4,\n+\n+        // Reference to a static.\n+        const STATIC_REF        = 1 << 5,\n+\n+        // Not constant at all - non-`const fn` calls, asm!,\n+        // pointer comparisons, ptr-to-int casts, etc.\n+        const NOT_CONST         = 1 << 6,\n+\n+        // Borrows of temporaries can be promoted only\n+        // if they have none of the above qualifications.\n+        const UNPROMOTABLE      = !0,\n+\n+        // Const items can only have MUTABLE_INTERIOR\n+        // without producing an error.\n+        const CONST_ERROR       = !Qualif::MUTABLE_INTERIOR.bits\n+    }\n+}\n+\n+impl Qualif {\n+    /// Remove flags which are impossible for the given type.\n+    fn restrict<'a, 'tcx>(&mut self, ty: Ty<'tcx>,\n+                          param_env: &ty::ParameterEnvironment<'a, 'tcx>) {\n+        if !ty.type_contents(param_env.tcx).interior_unsafe() {\n+            *self = *self - Qualif::MUTABLE_INTERIOR;\n+        }\n+        if !param_env.tcx.type_needs_drop_given_env(ty, param_env) {\n+            *self = *self - Qualif::NEEDS_DROP;\n+        }\n+    }\n+}\n+\n+/// What kind of item we are in.\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum Mode {\n+    Const,\n+    Static,\n+    StaticMut,\n+    ConstFn,\n+    Fn\n+}\n+\n+impl fmt::Display for Mode {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Mode::Const => write!(f, \"constant\"),\n+            Mode::Static | Mode::StaticMut => write!(f, \"static\"),\n+            Mode::ConstFn => write!(f, \"constant function\"),\n+            Mode::Fn => write!(f, \"function\")\n+        }\n+    }\n+}\n+\n+fn is_const_fn(tcx: &TyCtxt, def_id: DefId) -> bool {\n+    if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+        let fn_like = FnLikeNode::from_node(tcx.map.get(node_id));\n+        match fn_like.map(|f| f.kind()) {\n+            Some(FnKind::ItemFn(_, _, _, c, _, _, _)) => {\n+                c == hir::Constness::Const\n+            }\n+            Some(FnKind::Method(_, m, _, _)) => {\n+                m.constness == hir::Constness::Const\n+            }\n+            _ => false\n+        }\n+    } else {\n+        tcx.sess.cstore.is_const_fn(def_id)\n+    }\n+}\n+\n+struct Qualifier<'a, 'tcx: 'a> {\n+    mode: Mode,\n+    span: Span,\n+    def_id: DefId,\n+    mir: &'a Mir<'tcx>,\n+    rpo: ReversePostorder<'a, 'tcx>,\n+    tcx: &'a TyCtxt<'tcx>,\n+    param_env: ty::ParameterEnvironment<'a, 'tcx>,\n+    qualif_map: &'a mut DefIdMap<Qualif>,\n+    mir_map: Option<&'a MirMap<'tcx>>,\n+    temp_qualif: Vec<Option<Qualif>>,\n+    return_qualif: Option<Qualif>,\n+    qualif: Qualif,\n+    const_fn_arg_vars: BitVector,\n+    location: Location,\n+    temp_promotion_state: Vec<TempState>,\n+    promotion_candidates: Vec<Candidate>\n+}\n+\n+impl<'a, 'tcx> Qualifier<'a, 'tcx> {\n+    fn new(param_env: ty::ParameterEnvironment<'a, 'tcx>,\n+           qualif_map: &'a mut DefIdMap<Qualif>,\n+           mir_map: Option<&'a MirMap<'tcx>>,\n+           def_id: DefId,\n+           mir: &'a Mir<'tcx>,\n+           mode: Mode)\n+           -> Qualifier<'a, 'tcx> {\n+        let mut rpo = traversal::reverse_postorder(mir);\n+        let temps = promote_consts::collect_temps(mir, &mut rpo);\n+        rpo.reset();\n+        Qualifier {\n+            mode: mode,\n+            span: mir.span,\n+            def_id: def_id,\n+            mir: mir,\n+            rpo: rpo,\n+            tcx: param_env.tcx,\n+            param_env: param_env,\n+            qualif_map: qualif_map,\n+            mir_map: mir_map,\n+            temp_qualif: vec![None; mir.temp_decls.len()],\n+            return_qualif: None,\n+            qualif: Qualif::empty(),\n+            const_fn_arg_vars: BitVector::new(mir.var_decls.len()),\n+            location: Location {\n+                block: START_BLOCK,\n+                statement_index: 0\n+            },\n+            temp_promotion_state: temps,\n+            promotion_candidates: vec![]\n+        }\n+    }\n+\n+    // FIXME(eddyb) we could split the errors into meaningful\n+    // categories, but enabling full miri would make that\n+    // slightly pointless (even with feature-gating).\n+    fn not_const(&mut self) {\n+        self.add(Qualif::NOT_CONST);\n+        if self.mode != Mode::Fn {\n+            span_err!(self.tcx.sess, self.span, E0019,\n+                      \"{} contains unimplemented expression type\", self.mode);\n+        }\n+    }\n+\n+    /// Error about extra statements in a constant.\n+    fn statement_like(&mut self) {\n+        self.add(Qualif::NOT_CONST);\n+        if self.mode != Mode::Fn {\n+            span_err!(self.tcx.sess, self.span, E0016,\n+                      \"blocks in {}s are limited to items and tail expressions\",\n+                      self.mode);\n+        }\n+    }\n+\n+    /// Add the given qualification to self.qualif.\n+    fn add(&mut self, qualif: Qualif) {\n+        self.qualif = self.qualif | qualif;\n+    }\n+\n+    /// Add the given type's qualification to self.qualif.\n+    fn add_type(&mut self, ty: Ty<'tcx>) {\n+        self.add(Qualif::MUTABLE_INTERIOR | Qualif::NEEDS_DROP);\n+        self.qualif.restrict(ty, &self.param_env);\n+    }\n+\n+    /// Within the provided closure, self.qualif will start\n+    /// out empty, and its value after the closure returns will\n+    /// be combined with the value before the call to nest.\n+    fn nest<F: FnOnce(&mut Self)>(&mut self, f: F) {\n+        let original = self.qualif;\n+        self.qualif = Qualif::empty();\n+        f(self);\n+        self.add(original);\n+    }\n+\n+    /// Check for NEEDS_DROP (from an ADT or const fn call) and\n+    /// error, unless we're in a function.\n+    fn deny_drop(&self) {\n+        if self.mode != Mode::Fn && self.qualif.intersects(Qualif::NEEDS_DROP) {\n+            span_err!(self.tcx.sess, self.span, E0493,\n+                      \"{}s are not allowed to have destructors\",\n+                      self.mode);\n+        }\n+    }\n+\n+    /// Check if an Lvalue with the current qualifications could\n+    /// be consumed, by either an operand or a Deref projection.\n+    fn try_consume(&mut self) -> bool {\n+        if self.qualif.intersects(Qualif::STATIC) && self.mode != Mode::Fn {\n+            let msg = if self.mode == Mode::Static ||\n+                         self.mode == Mode::StaticMut {\n+                \"cannot refer to other statics by value, use the \\\n+                 address-of operator or a constant instead\"\n+            } else {\n+                \"cannot refer to statics by value, use a constant instead\"\n+            };\n+            span_err!(self.tcx.sess, self.span, E0394, \"{}\", msg);\n+\n+            // Replace STATIC with NOT_CONST to avoid further errors.\n+            self.qualif = self.qualif - Qualif::STATIC;\n+            self.add(Qualif::NOT_CONST);\n+\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+\n+    /// Assign the current qualification to the given destination.\n+    fn assign(&mut self, dest: &Lvalue<'tcx>) {\n+        let qualif = self.qualif;\n+        let span = self.span;\n+        let store = |slot: &mut Option<Qualif>| {\n+            if slot.is_some() {\n+                span_bug!(span, \"multiple assignments to {:?}\", dest);\n+            }\n+            *slot = Some(qualif);\n+        };\n+\n+        // Only handle promotable temps in non-const functions.\n+        if self.mode == Mode::Fn {\n+            if let Lvalue::Temp(index) = *dest {\n+                if self.temp_promotion_state[index as usize].is_promotable() {\n+                    store(&mut self.temp_qualif[index as usize]);\n+                }\n+            }\n+            return;\n+        }\n+\n+        match *dest {\n+            Lvalue::Temp(index) => store(&mut self.temp_qualif[index as usize]),\n+            Lvalue::ReturnPointer => store(&mut self.return_qualif),\n+\n+            Lvalue::Projection(box Projection {\n+                base: Lvalue::Temp(index),\n+                elem: ProjectionElem::Deref\n+            }) if self.mir.temp_decls[index as usize].ty.is_unique()\n+               && self.temp_qualif[index as usize].map_or(false, |qualif| {\n+                    qualif.intersects(Qualif::NOT_CONST)\n+               }) => {\n+                // Part of `box expr`, we should've errored\n+                // already for the Box allocation Rvalue.\n+            }\n+\n+            // This must be an explicit assignment.\n+            _ => {\n+                // Catch more errors in the destination.\n+                self.visit_lvalue(dest, LvalueContext::Store);\n+                self.statement_like();\n+            }\n+        }\n+    }\n+\n+    /// Returns true if the block ends in a bounds check branch, i.e.:\n+    /// len = Len(array);\n+    /// cond = Lt(idx, len);\n+    /// if cond {\n+    ///     ...\n+    /// } else {\n+    ///     loc = (...);\n+    ///     loc_ref = &loc;\n+    ///     panic_bounds_check(loc_ref, idx, len);\n+    /// }\n+    fn is_bounds_check(&self, bb: BasicBlock,\n+                       cond_op: &Operand<'tcx>,\n+                       if_else: BasicBlock) -> bool {\n+        use rustc::mir::repr::Lvalue::*;\n+        use rustc::mir::repr::Operand::Consume;\n+        use rustc::mir::repr::Rvalue::*;\n+        use rustc::mir::repr::StatementKind::*;\n+        use rustc::mir::repr::TerminatorKind::*;\n+\n+        let stmts = &self.mir[bb].statements;\n+        let stmts_panic = &self.mir[if_else].statements;\n+        if stmts.len() < 2 || stmts_panic.len() != 2 {\n+            return false;\n+        }\n+\n+        let all = (&stmts[stmts.len() - 2].kind,\n+                   &stmts[stmts.len() - 1].kind,\n+                   cond_op,\n+                   &stmts_panic[0].kind,\n+                   &stmts_panic[1].kind,\n+                   &self.mir[if_else].terminator().kind);\n+        match all {\n+            (&Assign(Temp(len), Len(_)),\n+             &Assign(Temp(cond), BinaryOp(BinOp::Lt, ref idx, Consume(Temp(len2)))),\n+             /* if */ &Consume(Temp(cond2)), /* {...} else */\n+             &Assign(Temp(loc), Aggregate(..)),\n+             &Assign(Temp(loc_ref), Ref(_, _, Temp(loc2))),\n+             &Call {\n+                func: Operand::Constant(Constant {\n+                    literal: Literal::Item { def_id, .. }, ..\n+                }),\n+                ref args,\n+                destination: None,\n+                ..\n+            }) => {\n+                len == len2 && cond == cond2 && loc == loc2 &&\n+                args[0] == Consume(Temp(loc_ref)) &&\n+                args[1] == *idx &&\n+                args[2] == Consume(Temp(len)) &&\n+                Some(def_id) == self.tcx.lang_items.panic_bounds_check_fn()\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    /// Qualify a whole const, static initializer or const fn.\n+    fn qualify_const(&mut self) -> Qualif {\n+        let mir = self.mir;\n+\n+        let mut seen_blocks = BitVector::new(mir.basic_blocks.len());\n+        let mut bb = START_BLOCK;\n+        loop {\n+            seen_blocks.insert(bb.index());\n+\n+            self.visit_basic_block_data(bb, &mir[bb]);\n+\n+            let target = match mir[bb].terminator().kind {\n+                TerminatorKind::Goto { target } |\n+                // Drops are considered noops.\n+                TerminatorKind::Drop { target, .. } |\n+                TerminatorKind::Call { destination: Some((_, target)), .. } => {\n+                    Some(target)\n+                }\n+\n+                // Non-terminating calls cannot produce any value.\n+                TerminatorKind::Call { destination: None, .. } => {\n+                    return Qualif::empty();\n+                }\n+\n+                // Need to allow bounds checking branches.\n+                TerminatorKind::If { ref cond, targets: (if_true, if_else) } => {\n+                    if self.is_bounds_check(bb, cond, if_else) {\n+                        Some(if_true)\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                TerminatorKind::Switch {..} |\n+                TerminatorKind::SwitchInt {..} |\n+                TerminatorKind::Resume => None,\n+\n+                TerminatorKind::Return => {\n+                    // Check for unused values. This usually means\n+                    // there are extra statements in the AST.\n+                    for i in 0..mir.temp_decls.len() {\n+                        if self.temp_qualif[i].is_none() {\n+                            continue;\n+                        }\n+\n+                        let state = self.temp_promotion_state[i];\n+                        if let TempState::Defined { location, uses: 0 } = state {\n+                            let data = &mir[location.block];\n+                            let stmt_idx = location.statement_index;\n+\n+                            // Get the span for the initialization.\n+                            if stmt_idx < data.statements.len() {\n+                                self.span = data.statements[stmt_idx].span;\n+                            } else {\n+                                self.span = data.terminator().span;\n+                            }\n+\n+                            // Treat this as a statement in the AST.\n+                            self.statement_like();\n+                        }\n+                    }\n+\n+                    // Make sure there are no extra unassigned variables.\n+                    self.qualif = Qualif::NOT_CONST;\n+                    for index in 0..mir.var_decls.len() {\n+                        if !self.const_fn_arg_vars.contains(index) {\n+                            self.assign(&Lvalue::Var(index as u32));\n+                        }\n+                    }\n+\n+                    break;\n+                }\n+            };\n+\n+            match target {\n+                // No loops allowed.\n+                Some(target) if !seen_blocks.contains(target.index()) => {\n+                    bb = target;\n+                }\n+                _ => {\n+                    self.not_const();\n+                    break;\n+                }\n+            }\n+        }\n+\n+        let return_ty = mir.return_ty.unwrap();\n+        self.qualif = self.return_qualif.unwrap_or(Qualif::NOT_CONST);\n+\n+        match self.mode {\n+            Mode::StaticMut => {\n+                // Check for destructors in static mut.\n+                self.add_type(return_ty);\n+                self.deny_drop();\n+            }\n+            _ => {\n+                // Account for errors in consts by using the\n+                // conservative type qualification instead.\n+                if self.qualif.intersects(Qualif::CONST_ERROR) {\n+                    self.qualif = Qualif::empty();\n+                    self.add_type(return_ty);\n+                }\n+            }\n+        }\n+        self.qualif\n+    }\n+}\n+\n+/// Accumulates an Rvalue or Call's effects in self.qualif.\n+/// For functions (constant or not), it also records\n+/// candidates for promotion in promotion_candidates.\n+impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx> {\n+    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext) {\n+        match *lvalue {\n+            Lvalue::Arg(_) => {\n+                self.add(Qualif::FN_ARGUMENT);\n+            }\n+            Lvalue::Var(_) => {\n+                self.add(Qualif::NOT_CONST);\n+            }\n+            Lvalue::Temp(index) => {\n+                if let Some(qualif) = self.temp_qualif[index as usize] {\n+                    self.add(qualif);\n+                } else {\n+                    self.not_const();\n+                }\n+            }\n+            Lvalue::Static(_) => {\n+                self.add(Qualif::STATIC);\n+                if self.mode == Mode::Const || self.mode == Mode::ConstFn {\n+                    span_err!(self.tcx.sess, self.span, E0013,\n+                              \"{}s cannot refer to statics, use \\\n+                               a constant instead\", self.mode);\n+                }\n+            }\n+            Lvalue::ReturnPointer => {\n+                self.not_const();\n+            }\n+            Lvalue::Projection(ref proj) => {\n+                self.nest(|this| {\n+                    this.super_lvalue(lvalue, context);\n+                    match proj.elem {\n+                        ProjectionElem::Deref => {\n+                            if !this.try_consume() {\n+                                return;\n+                            }\n+\n+                            if this.qualif.intersects(Qualif::STATIC_REF) {\n+                                this.qualif = this.qualif - Qualif::STATIC_REF;\n+                                this.add(Qualif::STATIC);\n+                            }\n+\n+                            let base_ty = this.mir.lvalue_ty(this.tcx, &proj.base)\n+                                              .to_ty(this.tcx);\n+                            if let ty::TyRawPtr(_) = base_ty.sty {\n+                                this.add(Qualif::NOT_CONST);\n+                                if this.mode != Mode::Fn {\n+                                    span_err!(this.tcx.sess, this.span, E0396,\n+                                              \"raw pointers cannot be dereferenced in {}s\",\n+                                              this.mode);\n+                                }\n+                            }\n+                        }\n+\n+                        ProjectionElem::Field(..) |\n+                        ProjectionElem::Index(_) => {\n+                            if this.mode != Mode::Fn &&\n+                               this.qualif.intersects(Qualif::STATIC) {\n+                                span_err!(this.tcx.sess, this.span, E0494,\n+                                          \"cannot refer to the interior of another \\\n+                                           static, use a constant instead\");\n+                            }\n+                            let ty = this.mir.lvalue_ty(this.tcx, lvalue)\n+                                         .to_ty(this.tcx);\n+                            this.qualif.restrict(ty, &this.param_env);\n+                        }\n+\n+                        ProjectionElem::ConstantIndex {..} |\n+                        ProjectionElem::Downcast(..) => {\n+                            this.not_const()\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    fn visit_operand(&mut self, operand: &Operand<'tcx>) {\n+        match *operand {\n+            Operand::Consume(_) => {\n+                self.nest(|this| {\n+                    this.super_operand(operand);\n+                    this.try_consume();\n+                });\n+            }\n+            Operand::Constant(ref constant) => {\n+                // Only functions and methods can have these types.\n+                if let ty::TyFnDef(..) = constant.ty.sty {\n+                    return;\n+                }\n+\n+                if let Literal::Item { def_id, substs } = constant.literal {\n+                    // Don't peek inside generic (associated) constants.\n+                    if !substs.types.is_empty() {\n+                        self.add_type(constant.ty);\n+                    } else {\n+                        let qualif = qualify_const_item_cached(self.tcx,\n+                                                               self.qualif_map,\n+                                                               self.mir_map,\n+                                                               def_id);\n+                        self.add(qualif);\n+                    }\n+\n+                    // FIXME(eddyb) check recursive constants here,\n+                    // instead of rustc_passes::static_recursion.\n+                    if self.qualif.intersects(Qualif::RECURSIVE) {\n+                        span_bug!(constant.span,\n+                                  \"recursive constant wasn't caught earlier\");\n+                    }\n+\n+                    // Let `const fn` transitively have destructors,\n+                    // but they do get stopped in `const` or `static`.\n+                    if self.mode != Mode::ConstFn {\n+                        self.deny_drop();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n+        // Recurse through operands and lvalues.\n+        self.super_rvalue(rvalue);\n+\n+        match *rvalue {\n+            Rvalue::Use(_) |\n+            Rvalue::Repeat(..) |\n+            Rvalue::UnaryOp(..) |\n+            Rvalue::Cast(CastKind::ReifyFnPointer, _, _) |\n+            Rvalue::Cast(CastKind::UnsafeFnPointer, _, _) |\n+            Rvalue::Cast(CastKind::Unsize, _, _) => {}\n+\n+            Rvalue::Len(_) => {\n+                // Static lvalues in consts would have errored already,\n+                // don't treat length checks as reads from statics.\n+                self.qualif = self.qualif - Qualif::STATIC;\n+            }\n+\n+            Rvalue::Ref(_, kind, ref lvalue) => {\n+                // Static lvalues in consts would have errored already,\n+                // only keep track of references to them here.\n+                if self.qualif.intersects(Qualif::STATIC) {\n+                    self.qualif = self.qualif - Qualif::STATIC;\n+                    self.add(Qualif::STATIC_REF);\n+                }\n+\n+                let ty = self.mir.lvalue_ty(self.tcx, lvalue).to_ty(self.tcx);\n+                if kind == BorrowKind::Mut {\n+                    // In theory, any zero-sized value could be borrowed\n+                    // mutably without consequences. However, only &mut []\n+                    // is allowed right now, and only in functions.\n+                    let allow = if let ty::TyArray(_, 0) = ty.sty {\n+                        self.mode == Mode::Fn\n+                    } else if self.mode == Mode::StaticMut {\n+                        // Inside a `static mut`, &mut [...] is also allowed.\n+                        match ty.sty {\n+                            ty::TyArray(..) | ty::TySlice(_) => {\n+                                // Mutating can expose drops, be conservative.\n+                                self.add_type(ty);\n+                                self.deny_drop();\n+                                true\n+                            }\n+                            _ => false\n+                        }\n+                    } else {\n+                        false\n+                    };\n+\n+                    if !allow {\n+                        self.add(Qualif::NOT_CONST);\n+                        if self.mode != Mode::Fn {\n+                            span_err!(self.tcx.sess, self.span, E0017,\n+                                      \"references in {}s may only refer \\\n+                                       to immutable values\", self.mode);\n+                        }\n+                    }\n+                } else {\n+                    // Constants cannot be borrowed if they contain interior mutability as\n+                    // it means that our \"silent insertion of statics\" could change\n+                    // initializer values (very bad).\n+                    if self.qualif.intersects(Qualif::MUTABLE_INTERIOR) {\n+                        // Replace MUTABLE_INTERIOR with NOT_CONST to avoid\n+                        // duplicate errors (from reborrowing, for example).\n+                        self.qualif = self.qualif - Qualif::MUTABLE_INTERIOR;\n+                        self.add(Qualif::NOT_CONST);\n+                        if self.mode != Mode::Fn {\n+                            span_err!(self.tcx.sess, self.span, E0492,\n+                                      \"cannot borrow a constant which contains \\\n+                                       interior mutability, create a static instead\");\n+                        }\n+                    }\n+                }\n+\n+                // We might have a candidate for promotion.\n+                let candidate = Candidate::Ref(self.location);\n+                if self.mode == Mode::Fn || self.mode == Mode::ConstFn {\n+                    if !self.qualif.intersects(Qualif::UNPROMOTABLE) {\n+                        self.promotion_candidates.push(candidate);\n+                    }\n+                }\n+            }\n+\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n+                let operand_ty = self.mir.operand_ty(self.tcx, operand);\n+                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n+                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                match (cast_in, cast_out) {\n+                    (CastTy::Ptr(_), CastTy::Int(_)) |\n+                    (CastTy::FnPtr, CastTy::Int(_)) => {\n+                        self.add(Qualif::NOT_CONST);\n+                        if self.mode != Mode::Fn {\n+                            span_err!(self.tcx.sess, self.span, E0018,\n+                                      \"raw pointers cannot be cast to integers in {}s\",\n+                                      self.mode);\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            Rvalue::BinaryOp(op, ref lhs, _) => {\n+                if let ty::TyRawPtr(_) = self.mir.operand_ty(self.tcx, lhs).sty {\n+                    assert!(op == BinOp::Eq || op == BinOp::Ne ||\n+                            op == BinOp::Le || op == BinOp::Lt ||\n+                            op == BinOp::Ge || op == BinOp::Gt);\n+\n+                    self.add(Qualif::NOT_CONST);\n+                    if self.mode != Mode::Fn {\n+                        span_err!(self.tcx.sess, self.span, E0395,\n+                                  \"raw pointers cannot be compared in {}s\",\n+                                  self.mode);\n+                    }\n+                }\n+            }\n+\n+            Rvalue::Box(_) => {\n+                self.add(Qualif::NOT_CONST);\n+                if self.mode != Mode::Fn {\n+                    span_err!(self.tcx.sess, self.span, E0010,\n+                              \"allocations are not allowed in {}s\", self.mode);\n+                }\n+            }\n+\n+            Rvalue::Aggregate(ref kind, _) => {\n+                if let AggregateKind::Adt(def, _, _) = *kind {\n+                    if def.has_dtor() {\n+                        self.add(Qualif::NEEDS_DROP);\n+                        self.deny_drop();\n+                    }\n+\n+                    if Some(def.did) == self.tcx.lang_items.unsafe_cell_type() {\n+                        let ty = self.mir.rvalue_ty(self.tcx, rvalue).unwrap();\n+                        self.add_type(ty);\n+                        assert!(self.qualif.intersects(Qualif::MUTABLE_INTERIOR));\n+                        // Even if the value inside may not need dropping,\n+                        // mutating it would change that.\n+                        if !self.qualif.intersects(Qualif::NOT_CONST) {\n+                            self.deny_drop();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            Rvalue::Slice {..} |\n+            Rvalue::InlineAsm {..} => {\n+                self.not_const();\n+            }\n+        }\n+    }\n+\n+    fn visit_terminator_kind(&mut self, bb: BasicBlock, kind: &TerminatorKind<'tcx>) {\n+        if let TerminatorKind::Call { ref func, ref args, ref destination, .. } = *kind {\n+            self.visit_operand(func);\n+\n+            let fn_ty = self.mir.operand_ty(self.tcx, func);\n+            let (is_shuffle, is_const_fn) = match fn_ty.sty {\n+                ty::TyFnDef(def_id, _, f) => {\n+                    (f.abi == Abi::PlatformIntrinsic &&\n+                     self.tcx.item_name(def_id).as_str().starts_with(\"simd_shuffle\"),\n+                     is_const_fn(self.tcx, def_id))\n+                }\n+                _ => (false, false)\n+            };\n+\n+            for (i, arg) in args.iter().enumerate() {\n+                self.nest(|this| {\n+                    this.visit_operand(arg);\n+                    if is_shuffle && i == 2 && this.mode == Mode::Fn {\n+                        let candidate = Candidate::ShuffleIndices(bb);\n+                        if !this.qualif.intersects(Qualif::UNPROMOTABLE) {\n+                            this.promotion_candidates.push(candidate);\n+                        } else {\n+                            span_err!(this.tcx.sess, this.span, E0526,\n+                                      \"shuffle indices are not constant\");\n+                        }\n+                    }\n+                });\n+            }\n+\n+            // Const fn calls.\n+            if is_const_fn {\n+                // We are in a const or static initializer,\n+                if self.mode != Mode::Fn &&\n+\n+                    // feature-gate is not enabled,\n+                    !self.tcx.sess.features.borrow().const_fn &&\n+\n+                    // this doesn't come from a crate with the feature-gate enabled,\n+                    self.def_id.is_local() &&\n+\n+                    // this doesn't come from a macro that has #[allow_internal_unstable]\n+                    !self.tcx.sess.codemap().span_allows_unstable(self.span)\n+                {\n+                    let mut err = self.tcx.sess.struct_span_err(self.span,\n+                        \"const fns are an unstable feature\");\n+                    help!(&mut err,\n+                          \"in Nightly builds, add `#![feature(const_fn)]` \\\n+                           to the crate attributes to enable\");\n+                    err.emit();\n+                }\n+            } else {\n+                self.qualif = Qualif::NOT_CONST;\n+                if self.mode != Mode::Fn {\n+                    // FIXME(#24111) Remove this check when const fn stabilizes\n+                    let (msg, note) = if let UnstableFeatures::Disallow =\n+                            self.tcx.sess.opts.unstable_features {\n+                        (format!(\"calls in {}s are limited to \\\n+                                  struct and enum constructors\",\n+                                 self.mode),\n+                         Some(\"a limited form of compile-time function \\\n+                               evaluation is available on a nightly \\\n+                               compiler via `const fn`\"))\n+                    } else {\n+                        (format!(\"calls in {}s are limited \\\n+                                  to constant functions, \\\n+                                  struct and enum constructors\",\n+                                 self.mode),\n+                         None)\n+                    };\n+                    let mut err = struct_span_err!(self.tcx.sess, self.span, E0015, \"{}\", msg);\n+                    if let Some(note) = note {\n+                        err.span_note(self.span, note);\n+                    }\n+                    err.emit();\n+                }\n+            }\n+\n+            if let Some((ref dest, _)) = *destination {\n+                // Avoid propagating irrelevant callee/argument qualifications.\n+                if self.qualif.intersects(Qualif::CONST_ERROR) {\n+                    self.qualif = Qualif::NOT_CONST;\n+                } else {\n+                    // Be conservative about the returned value of a const fn.\n+                    let tcx = self.tcx;\n+                    let ty = self.mir.lvalue_ty(tcx, dest).to_ty(tcx);\n+                    self.qualif = Qualif::empty();\n+                    self.add_type(ty);\n+\n+                    // Let `const fn` transitively have destructors,\n+                    // but they do get stopped in `const` or `static`.\n+                    if self.mode != Mode::ConstFn {\n+                        self.deny_drop();\n+                    }\n+                }\n+                self.assign(dest);\n+            }\n+        } else {\n+            // Qualify any operands inside other terminators.\n+            self.super_terminator_kind(bb, kind);\n+        }\n+    }\n+\n+    fn visit_assign(&mut self, _: BasicBlock, dest: &Lvalue<'tcx>, rvalue: &Rvalue<'tcx>) {\n+        self.visit_rvalue(rvalue);\n+\n+        // Check the allowed const fn argument forms.\n+        if let (Mode::ConstFn, &Lvalue::Var(index)) = (self.mode, dest) {\n+            if self.const_fn_arg_vars.insert(index as usize) {\n+                // Direct use of an argument is permitted.\n+                if let Rvalue::Use(Operand::Consume(Lvalue::Arg(_))) = *rvalue {\n+                    return;\n+                }\n+\n+                // Avoid a generic error for other uses of arguments.\n+                if self.qualif.intersects(Qualif::FN_ARGUMENT) {\n+                    let decl = &self.mir.var_decls[index as usize];\n+                    span_err!(self.tcx.sess, decl.span, E0022,\n+                              \"arguments of constant functions can only \\\n+                               be immutable by-value bindings\");\n+                    return;\n+                }\n+            }\n+        }\n+\n+        self.assign(dest);\n+    }\n+\n+    fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>) {\n+        assert_eq!(self.location.block, bb);\n+        self.span = statement.span;\n+        self.nest(|this| this.super_statement(bb, statement));\n+        self.location.statement_index += 1;\n+    }\n+\n+    fn visit_terminator(&mut self, bb: BasicBlock, terminator: &Terminator<'tcx>) {\n+        assert_eq!(self.location.block, bb);\n+        self.span = terminator.span;\n+        self.nest(|this| this.super_terminator(bb, terminator));\n+    }\n+\n+    fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n+        self.location.statement_index = 0;\n+        self.location.block = bb;\n+        self.super_basic_block_data(bb, data);\n+    }\n+}\n+\n+fn qualify_const_item_cached<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                   qualif_map: &mut DefIdMap<Qualif>,\n+                                   mir_map: Option<&MirMap<'tcx>>,\n+                                   def_id: DefId)\n+                                   -> Qualif {\n+    match qualif_map.entry(def_id) {\n+        Entry::Occupied(entry) => return *entry.get(),\n+        Entry::Vacant(entry) => {\n+            // Guard against `const` recursion.\n+            entry.insert(Qualif::RECURSIVE);\n+        }\n+    }\n+\n+    let extern_mir;\n+    let param_env_and_mir = if def_id.is_local() {\n+        let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n+        mir_map.and_then(|map| map.map.get(&node_id)).map(|mir| {\n+            (ty::ParameterEnvironment::for_item(tcx, node_id), mir)\n+        })\n+    } else if let Some(mir) = tcx.sess.cstore.maybe_get_item_mir(tcx, def_id) {\n+        // These should only be monomorphic constants.\n+        extern_mir = mir;\n+        Some((tcx.empty_parameter_environment(), &extern_mir))\n+    } else {\n+        None\n+    };\n+\n+    let (param_env, mir) = param_env_and_mir.unwrap_or_else(|| {\n+        bug!(\"missing constant MIR for {}\", tcx.item_path_str(def_id))\n+    });\n+\n+    let mut qualifier = Qualifier::new(param_env, qualif_map, mir_map,\n+                                       def_id, mir, Mode::Const);\n+    let qualif = qualifier.qualify_const();\n+    qualifier.qualif_map.insert(def_id, qualif);\n+    qualif\n+}\n+\n+pub struct QualifyAndPromoteConstants;\n+\n+impl Pass for QualifyAndPromoteConstants {}\n+\n+impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>) {\n+        let mut qualif_map = DefIdMap();\n+\n+        // First, visit `const` items, potentially recursing, to get\n+        // accurate MUTABLE_INTERIOR and NEEDS_DROP qualifications.\n+        for &id in map.map.keys() {\n+            let def_id = tcx.map.local_def_id(id);\n+            let _task = tcx.dep_graph.in_task(self.dep_node(def_id));\n+            let src = MirSource::from_node(tcx, id);\n+            if let MirSource::Const(_) = src {\n+                qualify_const_item_cached(tcx, &mut qualif_map, Some(map), def_id);\n+            }\n+        }\n+\n+        // Then, handle everything else, without recursing,\n+        // as the MIR map is not shared, since promotion\n+        // in functions (including `const fn`) mutates it.\n+        for (&id, mir) in &mut map.map {\n+            let def_id = tcx.map.local_def_id(id);\n+            let _task = tcx.dep_graph.in_task(self.dep_node(def_id));\n+            let src = MirSource::from_node(tcx, id);\n+            let mode = match src {\n+                MirSource::Fn(_) => {\n+                    if is_const_fn(tcx, def_id) {\n+                        Mode::ConstFn\n+                    } else {\n+                        Mode::Fn\n+                    }\n+                }\n+                MirSource::Const(_) => continue,\n+                MirSource::Static(_, hir::MutImmutable) => Mode::Static,\n+                MirSource::Static(_, hir::MutMutable) => Mode::StaticMut,\n+                MirSource::Promoted(..) => bug!()\n+            };\n+            let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+\n+            if mode == Mode::Fn || mode == Mode::ConstFn {\n+                // This is ugly because Qualifier holds onto mir,\n+                // which can't be mutated until its scope ends.\n+                let (temps, candidates) = {\n+                    let mut qualifier = Qualifier::new(param_env, &mut qualif_map,\n+                                                       None, def_id, mir, mode);\n+                    if mode == Mode::ConstFn {\n+                        // Enforce a constant-like CFG for `const fn`.\n+                        qualifier.qualify_const();\n+                    } else {\n+                        while let Some((bb, data)) = qualifier.rpo.next() {\n+                            qualifier.visit_basic_block_data(bb, data);\n+                        }\n+                    }\n+\n+                    (qualifier.temp_promotion_state,\n+                     qualifier.promotion_candidates)\n+                };\n+\n+                // Do the actual promotion, now that we know what's viable.\n+                promote_consts::promote_candidates(mir, tcx, temps, candidates);\n+            } else {\n+                let mut qualifier = Qualifier::new(param_env, &mut qualif_map,\n+                                                   None, def_id, mir, mode);\n+                qualifier.qualify_const();\n+            }\n+\n+            // Statics must be Sync.\n+            if mode == Mode::Static {\n+                let ty = mir.return_ty.unwrap();\n+                let infcx = infer::new_infer_ctxt(tcx,\n+                                                  &tcx.tables,\n+                                                  None,\n+                                                  ProjectionMode::AnyFinal);\n+                let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n+                let mut fulfillment_cx = traits::FulfillmentContext::new();\n+                fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n+                if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n+                    traits::report_fulfillment_errors(&infcx, &err);\n+                }\n+\n+                if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n+                   traits::report_fulfillment_errors_as_warnings(&infcx, errors, id);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "97a4c14863d59c083b54ea56fce231dea707ede8", "filename": "src/librustc_passes/const_fn.rs", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_passes%2Fconst_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14efbf148109888f939f671fbd5b60650c5f4744/src%2Flibrustc_passes%2Fconst_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconst_fn.rs?ref=14efbf148109888f939f671fbd5b60650c5f4744", "patch": "@@ -1,118 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Verifies that const fn arguments are immutable by value bindings\n-//! and the const fn body doesn't contain any statements\n-\n-use rustc::session::{Session, CompileResult};\n-\n-use syntax::ast::{self, PatKind};\n-use syntax::visit::{self, Visitor, FnKind};\n-use syntax::codemap::Span;\n-\n-pub fn check_crate(sess: &Session, krate: &ast::Crate) -> CompileResult {\n-    sess.track_errors(|| {\n-        visit::walk_crate(&mut CheckConstFn{ sess: sess }, krate);\n-    })\n-}\n-\n-struct CheckConstFn<'a> {\n-    sess: &'a Session,\n-}\n-\n-struct CheckBlock<'a> {\n-    sess: &'a Session,\n-    kind: &'static str,\n-}\n-\n-impl<'a, 'v> Visitor<'v> for CheckBlock<'a> {\n-    fn visit_block(&mut self, block: &'v ast::Block) {\n-        check_block(&self.sess, block, self.kind);\n-        CheckConstFn{ sess: self.sess}.visit_block(block);\n-    }\n-    fn visit_expr(&mut self, e: &'v ast::Expr) {\n-        if let ast::ExprKind::Closure(..) = e.node {\n-            CheckConstFn{ sess: self.sess}.visit_expr(e);\n-        } else {\n-            visit::walk_expr(self, e);\n-        }\n-    }\n-    fn visit_item(&mut self, _i: &'v ast::Item) { bug!(\"should be handled in CheckConstFn\") }\n-    fn visit_fn(&mut self,\n-                _fk: FnKind<'v>,\n-                _fd: &'v ast::FnDecl,\n-                _b: &'v ast::Block,\n-                _s: Span,\n-                _fn_id: ast::NodeId) { bug!(\"should be handled in CheckConstFn\") }\n-}\n-\n-fn check_block(sess: &Session, b: &ast::Block, kind: &'static str) {\n-    // Check all statements in the block\n-    for stmt in &b.stmts {\n-        let span = match stmt.node {\n-            ast::StmtKind::Decl(ref decl, _) => {\n-                match decl.node {\n-                    ast::DeclKind::Local(_) => decl.span,\n-\n-                    // Item statements are allowed\n-                    ast::DeclKind::Item(_) => continue,\n-                }\n-            }\n-            ast::StmtKind::Expr(ref expr, _) => expr.span,\n-            ast::StmtKind::Semi(ref semi, _) => semi.span,\n-            ast::StmtKind::Mac(..) => bug!(),\n-        };\n-        span_err!(sess, span, E0016,\n-                  \"blocks in {}s are limited to items and tail expressions\", kind);\n-    }\n-}\n-\n-impl<'a, 'v> Visitor<'v> for CheckConstFn<'a> {\n-    fn visit_item(&mut self, i: &'v ast::Item) {\n-        visit::walk_item(self, i);\n-        match i.node {\n-            ast::ItemKind::Const(_, ref e) => {\n-                CheckBlock{ sess: self.sess, kind: \"constant\"}.visit_expr(e)\n-            },\n-            ast::ItemKind::Static(_, _, ref e) => {\n-                CheckBlock{ sess: self.sess, kind: \"static\"}.visit_expr(e)\n-            },\n-            _ => {},\n-        }\n-    }\n-\n-    fn visit_fn(&mut self,\n-                fk: FnKind<'v>,\n-                fd: &'v ast::FnDecl,\n-                b: &'v ast::Block,\n-                s: Span,\n-                _fn_id: ast::NodeId) {\n-        visit::walk_fn(self, fk, fd, b, s);\n-        match fk {\n-            FnKind::ItemFn(_, _, _, ast::Constness::Const, _, _) => {},\n-            FnKind::Method(_, m, _) if m.constness == ast::Constness::Const => {},\n-            _ => return,\n-        }\n-\n-        // Ensure the arguments are simple, not mutable/by-ref or patterns.\n-        for arg in &fd.inputs {\n-            match arg.pat.node {\n-                PatKind::Wild => {}\n-                PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Immutable), _, None) => {}\n-                _ => {\n-                    span_err!(self.sess, arg.pat.span, E0022,\n-                              \"arguments of constant functions can only \\\n-                               be immutable by-value bindings\");\n-                }\n-            }\n-        }\n-        check_block(&self.sess, b, \"const function\");\n-    }\n-}"}, {"sha": "c417ec79ff2a8d9cfe11e458236a596e163406f4", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 9, "deletions": 168, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -40,15 +40,14 @@ use rustc::infer;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{self, ProjectionMode};\n+use rustc::traits::ProjectionMode;\n use rustc::util::nodemap::NodeMap;\n use rustc::middle::const_qualif::ConstQualif;\n use rustc::lint::builtin::CONST_ERR;\n \n use rustc::hir::{self, PatKind};\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::feature_gate::UnstableFeatures;\n use rustc::hir::intravisit::{self, FnKind, Visitor};\n \n use std::collections::hash_map::Entry;\n@@ -180,31 +179,11 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     /// Returns true if the call is to a const fn or method.\n     fn handle_const_fn_call(&mut self,\n-                            expr: &hir::Expr,\n+                            _expr: &hir::Expr,\n                             def_id: DefId,\n                             ret_ty: Ty<'tcx>)\n                             -> bool {\n         if let Some(fn_like) = lookup_const_fn_by_id(self.tcx, def_id) {\n-            if\n-                // we are in a static/const initializer\n-                self.mode != Mode::Var &&\n-\n-                // feature-gate is not enabled\n-                !self.tcx.sess.features.borrow().const_fn &&\n-\n-                // this doesn't come from a macro that has #[allow_internal_unstable]\n-                !self.tcx.sess.codemap().span_allows_unstable(expr.span)\n-            {\n-                let mut err = self.tcx.sess.struct_span_err(\n-                    expr.span,\n-                    \"const fns are an unstable feature\");\n-                help!(\n-                    &mut err,\n-                    \"in Nightly builds, add `#![feature(const_fn)]` to the crate \\\n-                     attributes to enable\");\n-                err.emit();\n-            }\n-\n             let qualif = self.fn_like(fn_like.kind(),\n                                       fn_like.decl(),\n                                       fn_like.body(),\n@@ -245,42 +224,6 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n             Mode::Var => bug!(),\n         }\n     }\n-\n-    fn check_static_mut_type(&self, e: &hir::Expr) {\n-        let node_ty = self.tcx.node_id_to_type(e.id);\n-        let tcontents = node_ty.type_contents(self.tcx);\n-\n-        let suffix = if tcontents.has_dtor() {\n-            \"destructors\"\n-        } else if tcontents.owns_owned() {\n-            \"boxes\"\n-        } else {\n-            return\n-        };\n-\n-        span_err!(self.tcx.sess, e.span, E0397,\n-                 \"mutable statics are not allowed to have {}\", suffix);\n-    }\n-\n-    fn check_static_type(&self, e: &hir::Expr) {\n-        let ty = self.tcx.node_id_to_type(e.id);\n-        let infcx = infer::new_infer_ctxt(self.tcx,\n-                                          &self.tcx.tables,\n-                                          None,\n-                                          ProjectionMode::AnyFinal);\n-        let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n-        let mut fulfillment_cx = traits::FulfillmentContext::new();\n-        fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-        match fulfillment_cx.select_all_or_error(&infcx) {\n-            Ok(()) => { },\n-            Err(ref errors) => {\n-                traits::report_fulfillment_errors(&infcx, errors);\n-            }\n-        }\n-        if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n-            traits::report_fulfillment_errors_as_warnings(&infcx, errors, e.id);\n-        }\n-    }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n@@ -289,11 +232,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         assert_eq!(self.mode, Mode::Var);\n         match i.node {\n             hir::ItemStatic(_, hir::MutImmutable, ref expr) => {\n-                self.check_static_type(&expr);\n                 self.global_expr(Mode::Static, &expr);\n             }\n             hir::ItemStatic(_, hir::MutMutable, ref expr) => {\n-                self.check_static_mut_type(&expr);\n                 self.global_expr(Mode::StaticMut, &expr);\n             }\n             hir::ItemConst(_, ref expr) => {\n@@ -360,8 +301,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                             \"lower range bound must be less than or equal to upper\");\n                     }\n                     None => {\n-                        self.tcx.sess.delay_span_bug(start.span,\n-                                                     \"non-constant path in constant expr\");\n+                        span_err!(self.tcx.sess, p.span, E0014,\n+                                  \"paths in {}s may only refer to constants\",\n+                                  self.msg());\n                     }\n                 }\n             }\n@@ -384,8 +326,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 hir::StmtSemi(_, _) => {},\n             }\n             self.add_qualif(ConstQualif::NOT_CONST);\n-            // anything else should have been caught by check_const_fn\n-            assert_eq!(self.mode, Mode::Var);\n         }\n         intravisit::walk_block(self, block);\n     }\n@@ -455,11 +395,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 let tc = node_ty.type_contents(self.tcx);\n                 if self.qualif.intersects(ConstQualif::MUTABLE_MEM) && tc.interior_unsafe() {\n                     outer = outer | ConstQualif::NOT_CONST;\n-                    if self.mode != Mode::Var {\n-                        span_err!(self.tcx.sess, ex.span, E0492,\n-                                  \"cannot borrow a constant which contains \\\n-                                   interior mutability, create a static instead\");\n-                    }\n                 }\n                 // If the reference has to be 'static, avoid in-place initialization\n                 // as that will end up pointing to the stack instead.\n@@ -474,10 +409,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                     if self.mode == Mode::Var {\n                         outer = outer | ConstQualif::NOT_CONST;\n                         self.add_qualif(ConstQualif::MUTABLE_MEM);\n-                    } else {\n-                        span_err!(self.tcx.sess, ex.span, E0017,\n-                            \"references in {}s may only refer \\\n-                             to immutable values\", self.msg())\n                     }\n                 }\n                 if !self.qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n@@ -525,11 +456,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ty::TyStruct(def, _) |\n         ty::TyEnum(def, _) if def.has_dtor() => {\n             v.add_qualif(ConstQualif::NEEDS_DROP);\n-            if v.mode != Mode::Var {\n-                span_err!(v.tcx.sess, e.span, E0493,\n-                          \"{}s are not allowed to have destructors\",\n-                          v.msg());\n-            }\n         }\n         _ => {}\n     }\n@@ -540,28 +466,16 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         hir::ExprBinary(..) |\n         hir::ExprIndex(..) if v.tcx.tables.borrow().method_map.contains_key(&method_call) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n-            if v.mode != Mode::Var {\n-                span_err!(v.tcx.sess, e.span, E0011,\n-                            \"user-defined operators are not allowed in {}s\", v.msg());\n-            }\n         }\n         hir::ExprBox(_) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n-            if v.mode != Mode::Var {\n-                span_err!(v.tcx.sess, e.span, E0010,\n-                          \"allocations are not allowed in {}s\", v.msg());\n-            }\n         }\n         hir::ExprUnary(op, ref inner) => {\n             match v.tcx.node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == hir::UnDeref);\n \n                     v.add_qualif(ConstQualif::NOT_CONST);\n-                    if v.mode != Mode::Var {\n-                        span_err!(v.tcx.sess, e.span, E0396,\n-                                  \"raw pointers cannot be dereferenced in {}s\", v.msg());\n-                    }\n                 }\n                 _ => {}\n             }\n@@ -574,10 +488,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                             op.node == hir::BiGe || op.node == hir::BiGt);\n \n                     v.add_qualif(ConstQualif::NOT_CONST);\n-                    if v.mode != Mode::Var {\n-                        span_err!(v.tcx.sess, e.span, E0395,\n-                                  \"raw pointers cannot be compared in {}s\", v.msg());\n-                    }\n                 }\n                 _ => {}\n             }\n@@ -588,10 +498,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 None => span_bug!(e.span, \"no kind for cast\"),\n                 Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n                     v.add_qualif(ConstQualif::NOT_CONST);\n-                    if v.mode != Mode::Var {\n-                        span_err!(v.tcx.sess, e.span, E0018,\n-                                  \"raw pointers cannot be cast to integers in {}s\", v.msg());\n-                    }\n                 }\n                 _ => {}\n             }\n@@ -616,11 +522,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 Some(Def::Static(..)) => {\n                     match v.mode {\n                         Mode::Static | Mode::StaticMut => {}\n-                        Mode::Const | Mode::ConstFn => {\n-                            span_err!(v.tcx.sess, e.span, E0013,\n-                                \"{}s cannot refer to other statics, insert \\\n-                                 an intermediate constant instead\", v.msg());\n-                        }\n+                        Mode::Const | Mode::ConstFn => {}\n                         Mode::Var => v.add_qualif(ConstQualif::NOT_CONST)\n                     }\n                 }\n@@ -636,14 +538,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                     // Sadly, we can't determine whether the types are zero-sized.\n                     v.add_qualif(ConstQualif::NOT_CONST | ConstQualif::NON_ZERO_SIZED);\n                 }\n-                def => {\n+                _ => {\n                     v.add_qualif(ConstQualif::NOT_CONST);\n-                    if v.mode != Mode::Var {\n-                        debug!(\"(checking const) found bad def: {:?}\", def);\n-                        span_err!(v.tcx.sess, e.span, E0014,\n-                                  \"paths in {}s may only refer to constants \\\n-                                   or functions\", v.msg());\n-                    }\n                 }\n             }\n         }\n@@ -681,29 +577,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             };\n             if !is_const {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n-                if v.mode != Mode::Var {\n-                    // FIXME(#24111) Remove this check when const fn stabilizes\n-                    let (msg, note) =\n-                        if let UnstableFeatures::Disallow = v.tcx.sess.opts.unstable_features {\n-                        (format!(\"function calls in {}s are limited to \\\n-                                  struct and enum constructors\",\n-                                 v.msg()),\n-                         Some(\"a limited form of compile-time function \\\n-                               evaluation is available on a nightly \\\n-                               compiler via `const fn`\"))\n-                    } else {\n-                        (format!(\"function calls in {}s are limited \\\n-                                  to constant functions, \\\n-                                  struct and enum constructors\",\n-                                 v.msg()),\n-                         None)\n-                    };\n-                    let mut err = struct_span_err!(v.tcx.sess, e.span, E0015, \"{}\", msg);\n-                    if let Some(note) = note {\n-                        err.span_note(e.span, note);\n-                    }\n-                    err.emit();\n-                }\n             }\n         }\n         hir::ExprMethodCall(..) => {\n@@ -714,11 +587,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             };\n             if !is_const {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n-                if v.mode != Mode::Var {\n-                    span_err!(v.tcx.sess, e.span, E0378,\n-                              \"method calls in {}s are limited to \\\n-                               constant inherent methods\", v.msg());\n-                }\n             }\n         }\n         hir::ExprStruct(..) => {\n@@ -773,10 +641,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         hir::ExprAssignOp(..) |\n         hir::ExprInlineAsm(..) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n-            if v.mode != Mode::Var {\n-                span_err!(v.tcx.sess, e.span, E0019,\n-                          \"{} contains unimplemented expression type\", v.msg());\n-            }\n         }\n     }\n }\n@@ -796,11 +660,6 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n                     v.tcx.is_overloaded_autoderef(e.id, autoderef)\n             }) {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n-                if v.mode != Mode::Var {\n-                    span_err!(v.tcx.sess, e.span, E0400,\n-                              \"user-defined dereference operators are not allowed in {}s\",\n-                              v.msg());\n-                }\n             }\n         }\n     }\n@@ -819,21 +678,13 @@ pub fn check_crate(tcx: &TyCtxt) {\n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n-               consume_span: Span,\n+               _consume_span: Span,\n                cmt: mc::cmt,\n                _mode: euv::ConsumeMode) {\n         let mut cur = &cmt;\n         loop {\n             match cur.cat {\n                 Categorization::StaticItem => {\n-                    if self.mode != Mode::Var {\n-                        // statics cannot be consumed by value at any time, that would imply\n-                        // that they're an initializer (what a const is for) or kept in sync\n-                        // over time (not feasible), so deny it outright.\n-                        span_err!(self.tcx.sess, consume_span, E0394,\n-                                  \"cannot refer to other statics by value, use the \\\n-                                   address-of operator or a constant instead\");\n-                    }\n                     break;\n                 }\n                 Categorization::Deref(ref cmt, _, _) |\n@@ -848,7 +699,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n     }\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n-              borrow_span: Span,\n+              _borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n               _loan_region: ty::Region,\n               bk: ty::BorrowKind,\n@@ -866,7 +717,6 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         }\n \n         let mut cur = &cmt;\n-        let mut is_interior = false;\n         loop {\n             match cur.cat {\n                 Categorization::Rvalue(..) => {\n@@ -891,20 +741,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                     break;\n                 }\n                 Categorization::StaticItem => {\n-                    if is_interior && self.mode != Mode::Var {\n-                        // Borrowed statics can specifically *only* have their address taken,\n-                        // not any number of other borrows such as borrowing fields, reading\n-                        // elements of an array, etc.\n-                        span_err!(self.tcx.sess, borrow_span, E0494,\n-                                  \"cannot refer to the interior of another \\\n-                                   static, use a constant instead\");\n-                    }\n                     break;\n                 }\n                 Categorization::Deref(ref cmt, _, _) |\n                 Categorization::Downcast(ref cmt, _) |\n                 Categorization::Interior(ref cmt, _) => {\n-                    is_interior = true;\n                     cur = cmt;\n                 }\n "}, {"sha": "77f896e011b938b076ad84c1deb9230ceaa8bc33", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 482, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -12,70 +12,6 @@\n \n register_long_diagnostics! {\n \n-E0010: r##\"\n-The value of statics and constants must be known at compile time, and they live\n-for the entire lifetime of a program. Creating a boxed value allocates memory on\n-the heap at runtime, and therefore cannot be done at compile time. Erroneous\n-code example:\n-\n-```compile_fail\n-#![feature(box_syntax)]\n-\n-const CON : Box<i32> = box 0;\n-```\n-\"##,\n-\n-E0011: r##\"\n-Initializers for constants and statics are evaluated at compile time.\n-User-defined operators rely on user-defined functions, which cannot be evaluated\n-at compile time.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-use std::ops::Index;\n-\n-struct Foo { a: u8 }\n-\n-impl Index<u8> for Foo {\n-    type Output = u8;\n-\n-    fn index<'a>(&'a self, idx: u8) -> &'a u8 { &self.a }\n-}\n-\n-const a: Foo = Foo { a: 0u8 };\n-const b: u8 = a[0]; // Index trait is defined by the user, bad!\n-```\n-\n-Only operators on builtin types are allowed.\n-\n-Example:\n-\n-```\n-const a: &'static [i32] = &[1, 2, 3];\n-const b: i32 = a[0]; // Ok!\n-```\n-\"##,\n-\n-E0013: r##\"\n-Static and const variables can refer to other const variables. But a const\n-variable cannot refer to a static variable. For example, `Y` cannot refer to\n-`X` here:\n-\n-```compile_fail\n-static X: i32 = 42;\n-const Y: i32 = X;\n-```\n-\n-To fix this, the value can be extracted as a const and then used:\n-\n-```\n-const A: i32 = 42;\n-static X: i32 = A;\n-const Y: i32 = A;\n-```\n-\"##,\n-\n E0014: r##\"\n Constants can only be initialized by a constant value or, in a future\n version of Rust, a call to a const function. This error indicates the use\n@@ -95,149 +31,6 @@ const FOO2: i32 = { 0 }; // but brackets are useless here\n ```\n \"##,\n \n-// FIXME(#24111) Change the language here when const fn stabilizes\n-E0015: r##\"\n-The only functions that can be called in static or constant expressions are\n-`const` functions, and struct/enum constructors. `const` functions are only\n-available on a nightly compiler. Rust currently does not support more general\n-compile-time function execution.\n-\n-```\n-const FOO: Option<u8> = Some(1); // enum constructor\n-struct Bar {x: u8}\n-const BAR: Bar = Bar {x: 1}; // struct constructor\n-```\n-\n-See [RFC 911] for more details on the design of `const fn`s.\n-\n-[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n-\"##,\n-\n-E0016: r##\"\n-Blocks in constants may only contain items (such as constant, function\n-definition, etc...) and a tail expression. Erroneous code example:\n-\n-```compile_fail\n-const FOO: i32 = { let x = 0; x }; // 'x' isn't an item!\n-```\n-\n-To avoid it, you have to replace the non-item object:\n-\n-```\n-const FOO: i32 = { const X : i32 = 0; X };\n-```\n-\"##,\n-\n-E0017: r##\"\n-References in statics and constants may only refer to immutable values.\n-Erroneous code example:\n-\n-```compile_fail\n-static X: i32 = 1;\n-const C: i32 = 2;\n-\n-// these three are not allowed:\n-const CR: &'static mut i32 = &mut C;\n-static STATIC_REF: &'static mut i32 = &mut X;\n-static CONST_REF: &'static mut i32 = &mut C;\n-```\n-\n-Statics are shared everywhere, and if they refer to mutable data one might\n-violate memory safety since holding multiple mutable references to shared data\n-is not allowed.\n-\n-If you really want global mutable state, try using `static mut` or a global\n-`UnsafeCell`.\n-\"##,\n-\n-E0018: r##\"\n-\n-The value of static and constant integers must be known at compile time. You\n-can't cast a pointer to an integer because the address of a pointer can\n-vary.\n-\n-For example, if you write:\n-\n-```compile_fail\n-static MY_STATIC: u32 = 42;\n-static MY_STATIC_ADDR: usize = &MY_STATIC as *const _ as usize;\n-static WHAT: usize = (MY_STATIC_ADDR^17) + MY_STATIC_ADDR;\n-```\n-\n-Then `MY_STATIC_ADDR` would contain the address of `MY_STATIC`. However,\n-the address can change when the program is linked, as well as change\n-between different executions due to ASLR, and many linkers would\n-not be able to calculate the value of `WHAT`.\n-\n-On the other hand, static and constant pointers can point either to\n-a known numeric address or to the address of a symbol.\n-\n-```\n-static MY_STATIC_ADDR: &'static u32 = &MY_STATIC;\n-// ... and also\n-static MY_STATIC_ADDR2: *const u32 = &MY_STATIC;\n-\n-const CONST_ADDR: *const u8 = 0x5f3759df as *const u8;\n-```\n-\n-This does not pose a problem by itself because they can't be\n-accessed directly.\n-\"##,\n-\n-E0019: r##\"\n-A function call isn't allowed in the const's initialization expression\n-because the expression's value must be known at compile-time. Erroneous code\n-example:\n-\n-```compile_fail\n-enum Test {\n-    V1\n-}\n-\n-impl Test {\n-    fn test(&self) -> i32 {\n-        12\n-    }\n-}\n-\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    const A: i32 = FOO.test(); // You can't call Test::func() here !\n-}\n-```\n-\n-Remember: you can't use a function call inside a const's initialization\n-expression! However, you can totally use it anywhere else:\n-\n-```\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    FOO.func(); // here is good\n-    let x = FOO.func(); // or even here!\n-}\n-```\n-\"##,\n-\n-E0022: r##\"\n-Constant functions are not allowed to mutate anything. Thus, binding to an\n-argument with a mutable pattern is not allowed. For example,\n-\n-```compile_fail\n-const fn foo(mut x: u8) {\n-    // do stuff\n-}\n-```\n-\n-Is incorrect because the function body may not mutate `x`.\n-\n-Remove any mutable bindings from the argument list to fix this error. In case\n-you need to mutate the argument, try lazily initializing a global variable\n-instead of using a `const fn`, or refactoring the code to a functional style to\n-avoid mutation if possible.\n-\"##,\n-\n E0030: r##\"\n When matching against a range, the compiler verifies that the range is\n non-empty.  Range patterns include both end-points, so this is equivalent to\n@@ -325,281 +118,6 @@ fn some_func() {\n ```\n \"##,\n \n-E0378: r##\"\n-Method calls that aren't calls to inherent `const` methods are disallowed\n-in statics, constants, and constant functions.\n-\n-For example:\n-\n-```compile_fail\n-const BAZ: i32 = Foo(25).bar(); // error, `bar` isn't `const`\n-\n-struct Foo(i32);\n-\n-impl Foo {\n-    const fn foo(&self) -> i32 {\n-        self.bar() // error, `bar` isn't `const`\n-    }\n-\n-    fn bar(&self) -> i32 { self.0 }\n-}\n-```\n-\n-For more information about `const fn`'s, see [RFC 911].\n-\n-[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n-\"##,\n-\n-E0394: r##\"\n-From [RFC 246]:\n-\n- > It is invalid for a static to reference another static by value. It is\n- > required that all references be borrowed.\n-\n-[RFC 246]: https://github.com/rust-lang/rfcs/pull/246\n-\"##,\n-\n-\n-E0395: r##\"\n-The value assigned to a constant scalar must be known at compile time,\n-which is not the case when comparing raw pointers.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-static FOO: i32 = 42;\n-static BAR: i32 = 42;\n-\n-static BAZ: bool = { (&FOO as *const i32) == (&BAR as *const i32) };\n-// error: raw pointers cannot be compared in statics!\n-```\n-\n-The address assigned by the linker to `FOO` and `BAR` may or may not\n-be identical, so the value of `BAZ` can't be determined.\n-\n-If you want to do the comparison, please do it at run-time.\n-\n-For example:\n-\n-```\n-static FOO: i32 = 42;\n-static BAR: i32 = 42;\n-\n-let baz: bool = { (&FOO as *const i32) == (&BAR as *const i32) };\n-// baz isn't a constant expression so it's ok\n-```\n-\"##,\n-\n-E0396: r##\"\n-The value behind a raw pointer can't be determined at compile-time\n-(or even link-time), which means it can't be used in a constant\n-expression. Erroneous code example:\n-\n-```compile_fail\n-const REG_ADDR: *const u8 = 0x5f3759df as *const u8;\n-\n-const VALUE: u8 = unsafe { *REG_ADDR };\n-// error: raw pointers cannot be dereferenced in constants\n-```\n-\n-A possible fix is to dereference your pointer at some point in run-time.\n-\n-For example:\n-\n-```\n-const REG_ADDR: *const u8 = 0x5f3759df as *const u8;\n-\n-let reg_value = unsafe { *REG_ADDR };\n-```\n-\"##,\n-\n-E0397: r##\"\n-It is not allowed for a mutable static to allocate or have destructors. For\n-example:\n-\n-```compile_fail\n-// error: mutable statics are not allowed to have boxes\n-static mut FOO: Option<Box<usize>> = None;\n-\n-// error: mutable statics are not allowed to have destructors\n-static mut BAR: Option<Vec<i32>> = None;\n-```\n-\"##,\n-\n-E0400: r##\"\n-A user-defined dereference was attempted in an invalid context. Erroneous\n-code example:\n-\n-```compile_fail\n-use std::ops::Deref;\n-\n-struct A;\n-\n-impl Deref for A {\n-    type Target = str;\n-\n-    fn deref(&self)-> &str { \"foo\" }\n-}\n-\n-const S: &'static str = &A;\n-// error: user-defined dereference operators are not allowed in constants\n-\n-fn main() {\n-    let foo = S;\n-}\n-```\n-\n-You cannot directly use a dereference operation whilst initializing a constant\n-or a static. To fix this error, restructure your code to avoid this dereference,\n-perhaps moving it inline:\n-\n-```\n-use std::ops::Deref;\n-\n-struct A;\n-\n-impl Deref for A {\n-    type Target = str;\n-\n-    fn deref(&self)-> &str { \"foo\" }\n-}\n-\n-fn main() {\n-    let foo : &str = &A;\n-}\n-```\n-\"##,\n-\n-E0492: r##\"\n-A borrow of a constant containing interior mutability was attempted. Erroneous\n-code example:\n-\n-```compile_fail\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n-\n-const A: AtomicUsize = ATOMIC_USIZE_INIT;\n-static B: &'static AtomicUsize = &A;\n-// error: cannot borrow a constant which contains interior mutability, create a\n-//        static instead\n-```\n-\n-A `const` represents a constant value that should never change. If one takes\n-a `&` reference to the constant, then one is taking a pointer to some memory\n-location containing the value. Normally this is perfectly fine: most values\n-can't be changed via a shared `&` pointer, but interior mutability would allow\n-it. That is, a constant value could be mutated. On the other hand, a `static` is\n-explicitly a single memory location, which can be mutated at will.\n-\n-So, in order to solve this error, either use statics which are `Sync`:\n-\n-```\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n-\n-static A: AtomicUsize = ATOMIC_USIZE_INIT;\n-static B: &'static AtomicUsize = &A; // ok!\n-```\n-\n-You can also have this error while using a cell type:\n-\n-```compile_fail\n-#![feature(const_fn)]\n-\n-use std::cell::Cell;\n-\n-const A: Cell<usize> = Cell::new(1);\n-const B: &'static Cell<usize> = &A;\n-// error: cannot borrow a constant which contains interior mutability, create\n-//        a static instead\n-\n-// or:\n-struct C { a: Cell<usize> }\n-\n-const D: C = C { a: Cell::new(1) };\n-const E: &'static Cell<usize> = &D.a; // error\n-\n-// or:\n-const F: &'static C = &D; // error\n-```\n-\n-This is because cell types do operations that are not thread-safe. Due to this,\n-they don't implement Sync and thus can't be placed in statics. In this\n-case, `StaticMutex` would work just fine, but it isn't stable yet:\n-https://doc.rust-lang.org/nightly/std/sync/struct.StaticMutex.html\n-\n-However, if you still wish to use these types, you can achieve this by an unsafe\n-wrapper:\n-\n-```\n-#![feature(const_fn)]\n-\n-use std::cell::Cell;\n-use std::marker::Sync;\n-\n-struct NotThreadSafe<T> {\n-    value: Cell<T>,\n-}\n-\n-unsafe impl<T> Sync for NotThreadSafe<T> {}\n-\n-static A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };\n-static B: &'static NotThreadSafe<usize> = &A; // ok!\n-```\n-\n-Remember this solution is unsafe! You will have to ensure that accesses to the\n-cell are synchronized.\n-\"##,\n-\n-E0493: r##\"\n-A type with a destructor was assigned to an invalid type of variable. Erroneous\n-code example:\n-\n-```compile_fail\n-struct Foo {\n-    a: u32\n-}\n-\n-impl Drop for Foo {\n-    fn drop(&mut self) {}\n-}\n-\n-const F : Foo = Foo { a : 0 };\n-// error: constants are not allowed to have destructors\n-static S : Foo = Foo { a : 0 };\n-// error: statics are not allowed to have destructors\n-```\n-\n-To solve this issue, please use a type which does allow the usage of type with\n-destructors.\n-\"##,\n-\n-E0494: r##\"\n-A reference of an interior static was assigned to another const/static.\n-Erroneous code example:\n-\n-```compile_fail\n-struct Foo {\n-    a: u32\n-}\n-\n-static S : Foo = Foo { a : 0 };\n-static A : &'static u32 = &S.a;\n-// error: cannot refer to the interior of another static, use a\n-//        constant instead\n-```\n-\n-The \"base\" variable has to be a const if you want another static/const variable\n-to refer to one of its fields. Example:\n-\n-```\n-struct Foo {\n-    a: u32\n-}\n-\n-const S : Foo = Foo { a : 0 };\n-static A : &'static u32 = &S.a; // ok!\n-```\n-\"##,\n-\n }\n \n register_diagnostics! {"}, {"sha": "67a9c2fd17e9fcf6ffedecd9fe341698142df280", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -37,7 +37,6 @@ extern crate rustc_const_math;\n \n pub mod diagnostics;\n \n-pub mod const_fn;\n pub mod consts;\n pub mod loops;\n pub mod no_asm;"}, {"sha": "9dc1899e5a092015829e312424858997ced28002", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -220,6 +220,7 @@ dependencies = [\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n+ \"rustc_bitflags 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -233,6 +234,7 @@ dependencies = [\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n+ \"rustc_const_math 0.0.0\",\n  \"syntax 0.0.0\",\n ]\n \n@@ -278,6 +280,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n+ \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n ]\n "}, {"sha": "edb85023c9ba78ead594de762b59b4eeeda3ebb2", "filename": "src/test/compile-fail/const-block-non-item-statement.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78884b765915c551e5f3fe71b185d91ec4c186de/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs?ref=78884b765915c551e5f3fe71b185d91ec4c186de", "patch": "@@ -21,6 +21,20 @@ const C: usize = { foo!(); 2 };\n \n const D: usize = { let x = 4; 2 };\n //~^ ERROR: blocks in constants are limited to items and tail expressions\n+//~^^ ERROR: blocks in constants are limited to items and tail expressions\n+\n+enum Foo {\n+    Bar = { let x = 1; 3 }\n+    //~^ ERROR: blocks in constants are limited to items and tail expressions\n+    //~^^ ERROR: blocks in constants are limited to items and tail expressions\n+}\n+\n+type Array = [u32; {  let x = 2; 5 }];\n+//~^ ERROR: blocks in constants are limited to items and tail expressions\n+//~^^ ERROR: blocks in constants are limited to items and tail expressions\n \n pub fn main() {\n+    let _: Array = [0; { let x = 3; 5 }];\n+    //~^ ERROR: blocks in constants are limited to items and tail expressions\n+    //~^^ ERROR: blocks in constants are limited to items and tail expressions\n }"}]}