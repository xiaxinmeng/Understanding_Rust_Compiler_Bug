{"sha": "206ad61fd8e1eb6ff8a05406b70f46d1df766c01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNmFkNjFmZDhlMWViNmZmOGEwNTQwNmI3MGY0NmQxZGY3NjZjMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-31T02:20:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-31T02:20:36Z"}, "message": "auto merge of #8894 : alexcrichton/rust/faster, r=thestinger\n\nThe only changes to the default passes is that O1 now doesn't run the inline\r\npass, just always-inline with lifetime intrinsics. O2 also now has a threshold\r\nof 225 instead of 275. Otherwise the default passes being run is the same.\r\n\r\nI've also added a few more options for configuring the pass pipeline. Namely you\r\ncan now specify arguments to LLVM directly via the `--llvm-args` command line\r\noption which operates similarly to `--passes`. I also added the ability to turn\r\noff pre-population of the pass manager in case you want to run *only* your own\r\npasses.\r\n\r\nI would consider this as closing #8890. I don't think that we should change the default inlining threshold because LLVM/clang will probably have chosen those numbers more carefully than we would. Regardless, here's the performance numbers from this commit:\r\n\r\n```\r\n$ ./x86_64-apple-darwin/stage0/bin/rustc ./gistfile1.rs --test --opt-level=3 -o before\r\nwarning: no debug symbols in executable (-arch x86_64)\r\n$ ./before --bench\r\n\r\nrunning 1 test\r\ntest bench::aes_bench_x8 ... bench: 1602 ns/iter (+/- 66) = 7990 MB/s\r\n\r\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\r\n\r\n$ ./x86_64-apple-darwin/stage1/bin/rustc ./gistfile1.rs --test --opt-level=3 -o after\r\nwarning: no debug symbols in executable (-arch x86_64)\r\n$ ./after --bench\r\n\r\nrunning 1 test\r\ntest bench::aes_bench_x8 ... bench: 2103 ns/iter (+/- 175) = 6086 MB/s\r\n\r\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\r\n\r\n$ ./x86_64-apple-darwin/stage1/bin/rustc ./gistfile1.rs --test --opt-level=3 -o after --llvm-args '-inline-threshold=225'\r\nwarning: no debug symbols in executable (-arch x86_64)\r\n$ ./after --bench\r\n\r\nrunning 1 test\r\ntest bench::aes_bench_x8 ... bench: 1600 ns/iter (+/- 71) = 8000 MB/s\r\n\r\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\r\n\r\n```", "tree": {"sha": "de0cdd09a64ddac52895fcac8645c65ac5282cf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de0cdd09a64ddac52895fcac8645c65ac5282cf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/206ad61fd8e1eb6ff8a05406b70f46d1df766c01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/206ad61fd8e1eb6ff8a05406b70f46d1df766c01", "html_url": "https://github.com/rust-lang/rust/commit/206ad61fd8e1eb6ff8a05406b70f46d1df766c01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/206ad61fd8e1eb6ff8a05406b70f46d1df766c01/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29449e355a68d2b878af1cdb65b97454e645206f", "url": "https://api.github.com/repos/rust-lang/rust/commits/29449e355a68d2b878af1cdb65b97454e645206f", "html_url": "https://github.com/rust-lang/rust/commit/29449e355a68d2b878af1cdb65b97454e645206f"}, {"sha": "8d12673c825c2785e375e12295a7bdc24a625114", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d12673c825c2785e375e12295a7bdc24a625114", "html_url": "https://github.com/rust-lang/rust/commit/8d12673c825c2785e375e12295a7bdc24a625114"}], "stats": {"total": 168, "additions": 100, "deletions": 68}, "files": [{"sha": "7ebb47d5124ba337cf1ce0f39609a0e19a458134", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 75, "deletions": 41, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/206ad61fd8e1eb6ff8a05406b70f46d1df766c01/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/206ad61fd8e1eb6ff8a05406b70f46d1df766c01/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=206ad61fd8e1eb6ff8a05406b70f46d1df766c01", "patch": "@@ -216,7 +216,7 @@ pub mod write {\n     use lib;\n \n     use std::c_str::ToCStr;\n-    use std::libc::c_uint;\n+    use std::libc::{c_uint, c_int};\n     use std::path::Path;\n     use std::run;\n     use std::str;\n@@ -257,17 +257,7 @@ pub mod write {\n                 }\n             }\n \n-            // Copy what clan does by turning on loop vectorization at O2 and\n-            // slp vectorization at O3\n-            let vectorize_loop = !sess.no_vectorize_loops() &&\n-                                 (sess.opts.optimize == session::Default ||\n-                                  sess.opts.optimize == session::Aggressive);\n-            let vectorize_slp = !sess.no_vectorize_slp() &&\n-                                sess.opts.optimize == session::Aggressive;\n-            llvm::LLVMRustSetLLVMOptions(sess.print_llvm_passes(),\n-                                         vectorize_loop,\n-                                         vectorize_slp,\n-                                         sess.time_llvm_passes());\n+            configure_llvm(sess);\n \n             let OptLevel = match sess.opts.optimize {\n               session::No => lib::llvm::CodeGenLevelNone,\n@@ -293,12 +283,9 @@ pub mod write {\n             // Create the two optimizing pass managers. These mirror what clang\n             // does, and are by populated by LLVM's default PassManagerBuilder.\n             // Each manager has a different set of passes, but they also share\n-            // some common passes. Each one is initialized with the analyis\n-            // passes the target requires, and then further passes are added.\n+            // some common passes.\n             let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n             let mpm = llvm::LLVMCreatePassManager();\n-            llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n-            llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n \n             // If we're verifying or linting, add them to the function pass\n             // manager.\n@@ -308,32 +295,11 @@ pub mod write {\n             if !sess.no_verify() { assert!(addpass(\"verify\")); }\n             if sess.lint_llvm()  { assert!(addpass(\"lint\"));   }\n \n-            // Create the PassManagerBuilder for LLVM. We configure it with\n-            // reasonable defaults and prepare it to actually populate the pass\n-            // manager.\n-            let builder = llvm::LLVMPassManagerBuilderCreate();\n-            match sess.opts.optimize {\n-                session::No => {\n-                    // Don't add lifetime intrinsics add O0\n-                    llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n-                }\n-                // numeric values copied from clang\n-                session::Less => {\n-                    llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n-                                                                        225);\n-                }\n-                session::Default | session::Aggressive => {\n-                    llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n-                                                                        275);\n-                }\n+            if !sess.no_prepopulate_passes() {\n+                llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n+                llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n+                populate_llvm_passess(fpm, mpm, llmod, OptLevel);\n             }\n-            llvm::LLVMPassManagerBuilderSetOptLevel(builder, OptLevel as c_uint);\n-            llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod);\n-\n-            // Use the builder to populate the function/module pass managers.\n-            llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(builder, fpm);\n-            llvm::LLVMPassManagerBuilderPopulateModulePassManager(builder, mpm);\n-            llvm::LLVMPassManagerBuilderDispose(builder);\n \n             for pass in sess.opts.custom_passes.iter() {\n                 do pass.with_c_str |s| {\n@@ -424,6 +390,74 @@ pub mod write {\n             sess.abort_if_errors();\n         }\n     }\n+\n+    unsafe fn configure_llvm(sess: Session) {\n+        // Copy what clan does by turning on loop vectorization at O2 and\n+        // slp vectorization at O3\n+        let vectorize_loop = !sess.no_vectorize_loops() &&\n+                             (sess.opts.optimize == session::Default ||\n+                              sess.opts.optimize == session::Aggressive);\n+        let vectorize_slp = !sess.no_vectorize_slp() &&\n+                            sess.opts.optimize == session::Aggressive;\n+\n+        let mut llvm_c_strs = ~[];\n+        let mut llvm_args = ~[];\n+        let add = |arg: &str| {\n+            let s = arg.to_c_str();\n+            llvm_args.push(s.with_ref(|p| p));\n+            llvm_c_strs.push(s);\n+        };\n+        add(\"rustc\"); // fake program name\n+        add(\"-arm-enable-ehabi\");\n+        add(\"-arm-enable-ehabi-descriptors\");\n+        if vectorize_loop { add(\"-vectorize-loops\"); }\n+        if vectorize_slp  { add(\"-vectorize-slp\");   }\n+        if sess.time_llvm_passes() { add(\"-time-passes\"); }\n+        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n+\n+        for arg in sess.opts.llvm_args.iter() {\n+            add(*arg);\n+        }\n+\n+        do llvm_args.as_imm_buf |p, len| {\n+            llvm::LLVMRustSetLLVMOptions(len as c_int, p);\n+        }\n+    }\n+\n+    unsafe fn populate_llvm_passess(fpm: lib::llvm::PassManagerRef,\n+                                    mpm: lib::llvm::PassManagerRef,\n+                                    llmod: ModuleRef,\n+                                    opt: lib::llvm::CodeGenOptLevel) {\n+        // Create the PassManagerBuilder for LLVM. We configure it with\n+        // reasonable defaults and prepare it to actually populate the pass\n+        // manager.\n+        let builder = llvm::LLVMPassManagerBuilderCreate();\n+        match opt {\n+            lib::llvm::CodeGenLevelNone => {\n+                // Don't add lifetime intrinsics add O0\n+                llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n+            }\n+            lib::llvm::CodeGenLevelLess => {\n+                llvm::LLVMRustAddAlwaysInlinePass(builder, true);\n+            }\n+            // numeric values copied from clang\n+            lib::llvm::CodeGenLevelDefault => {\n+                llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n+                                                                    225);\n+            }\n+            lib::llvm::CodeGenLevelAggressive => {\n+                llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n+                                                                    275);\n+            }\n+        }\n+        llvm::LLVMPassManagerBuilderSetOptLevel(builder, opt as c_uint);\n+        llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod);\n+\n+        // Use the builder to populate the function/module pass managers.\n+        llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(builder, fpm);\n+        llvm::LLVMPassManagerBuilderPopulateModulePassManager(builder, mpm);\n+        llvm::LLVMPassManagerBuilderDispose(builder);\n+    }\n }\n \n "}, {"sha": "74452f195493916542bcb611442cda7e138f455f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/206ad61fd8e1eb6ff8a05406b70f46d1df766c01/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/206ad61fd8e1eb6ff8a05406b70f46d1df766c01/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=206ad61fd8e1eb6ff8a05406b70f46d1df766c01", "patch": "@@ -737,13 +737,22 @@ pub fn build_session_options(binary: @str,\n             }).collect()\n         }\n     };\n+    let llvm_args = match getopts::opt_maybe_str(matches, \"llvm-args\") {\n+        None => ~[],\n+        Some(s) => {\n+            s.split_iter(|c: char| c == ' ' || c == ',').map(|s| {\n+                s.trim().to_owned()\n+            }).collect()\n+        }\n+    };\n \n     let sopts = @session::options {\n         crate_type: crate_type,\n         is_static: statik,\n         gc: gc,\n         optimize: opt_level,\n         custom_passes: custom_passes,\n+        llvm_args: llvm_args,\n         debuginfo: debuginfo,\n         extra_debuginfo: extra_debuginfo,\n         lint_opts: lint_opts,\n@@ -851,6 +860,8 @@ pub fn optgroups() -> ~[getopts::groups::OptGroup] {\n                         Appends to the default list of passes to run for the \\\n                         specified current optimization level. A value of \\\n                         \\\"list\\\" will list all of the available passes\", \"NAMES\"),\n+  optopt(\"\", \"llvm-args\", \"A list of arguments to pass to llvm, comma \\\n+                           separated\", \"ARGS\"),\n   optopt( \"\",  \"out-dir\",\n                         \"Write output to compiler-chosen filename\n                           in <dir>\", \"DIR\"),"}, {"sha": "90a23c78d3050deb05a9d0b1aca2854d1f07c849", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/206ad61fd8e1eb6ff8a05406b70f46d1df766c01/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/206ad61fd8e1eb6ff8a05406b70f46d1df766c01/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=206ad61fd8e1eb6ff8a05406b70f46d1df766c01", "patch": "@@ -79,6 +79,7 @@ pub static once_fns:                uint = 1 << 26;\n pub static print_llvm_passes:       uint = 1 << 27;\n pub static no_vectorize_loops:      uint = 1 << 28;\n pub static no_vectorize_slp:        uint = 1 << 29;\n+pub static no_prepopulate_passes:   uint = 1 << 30;\n \n pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n     ~[(~\"verbose\", ~\"in general, enable more debug printouts\", verbose),\n@@ -126,6 +127,10 @@ pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n      (~\"print-llvm-passes\",\n       ~\"Prints the llvm optimization passes being run\",\n       print_llvm_passes),\n+     (~\"no-prepopulate-passes\",\n+      ~\"Don't pre-populate the pass managers with a list of passes, only use \\\n+        the passes from --passes\",\n+      no_prepopulate_passes),\n      (~\"no-vectorize-loops\",\n       ~\"Don't run the loop vectorization optimization passes\",\n       no_vectorize_loops),\n@@ -152,6 +157,7 @@ pub struct options {\n     gc: bool,\n     optimize: OptLevel,\n     custom_passes: ~[~str],\n+    llvm_args: ~[~str],\n     debuginfo: bool,\n     extra_debuginfo: bool,\n     lint_opts: ~[(lint::lint, lint::level)],\n@@ -320,6 +326,9 @@ impl Session_ {\n     pub fn print_llvm_passes(@self) -> bool {\n         self.debugging_opt(print_llvm_passes)\n     }\n+    pub fn no_prepopulate_passes(@self) -> bool {\n+        self.debugging_opt(no_prepopulate_passes)\n+    }\n     pub fn no_vectorize_loops(@self) -> bool {\n         self.debugging_opt(no_vectorize_loops)\n     }\n@@ -351,6 +360,7 @@ pub fn basic_options() -> @options {\n         gc: false,\n         optimize: No,\n         custom_passes: ~[],\n+        llvm_args: ~[],\n         debuginfo: false,\n         extra_debuginfo: false,\n         lint_opts: ~[],"}, {"sha": "c9253026488e269493487592e2c00270be922e3e", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/206ad61fd8e1eb6ff8a05406b70f46d1df766c01/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/206ad61fd8e1eb6ff8a05406b70f46d1df766c01/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=206ad61fd8e1eb6ff8a05406b70f46d1df766c01", "patch": "@@ -191,6 +191,7 @@ pub enum AsmDialect {\n     AD_Intel = 1\n }\n \n+#[deriving(Eq)]\n pub enum CodeGenOptLevel {\n     CodeGenLevelNone = 0,\n     CodeGenLevelLess = 1,\n@@ -2123,10 +2124,7 @@ pub mod llvm {\n         pub fn LLVMRustPrintModule(PM: PassManagerRef,\n                                    M: ModuleRef,\n                                    Output: *c_char);\n-        pub fn LLVMRustSetLLVMOptions(PrintPasses: bool,\n-                                      VectorizeLoops: bool,\n-                                      VectorizeSLP: bool,\n-                                      TimePasses: bool);\n+        pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: **c_char);\n         pub fn LLVMRustPrintPasses();\n         pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *c_char);\n         pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,"}, {"sha": "615c2cc61cbee738e77fc3429337b524109dac26", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/206ad61fd8e1eb6ff8a05406b70f46d1df766c01/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/206ad61fd8e1eb6ff8a05406b70f46d1df766c01/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=206ad61fd8e1eb6ff8a05406b70f46d1df766c01", "patch": "@@ -143,36 +143,15 @@ LLVMRustRunFunctionPassManager(LLVMPassManagerRef PM, LLVMModuleRef M) {\n }\n \n extern \"C\" void\n-LLVMRustSetLLVMOptions(bool PrintPasses,\n-                       bool VectorizeLoops,\n-                       bool VectorizeSLP,\n-                       bool TimePasses) {\n+LLVMRustSetLLVMOptions(int Argc, char **Argv) {\n     // Initializing the command-line options more than once is not allowed. So,\n     // check if they've already been initialized.  (This could happen if we're\n     // being called from rustpkg, for example). If the arguments change, then\n     // that's just kinda unfortunate.\n     static bool initialized = false;\n     if (initialized) return;\n-\n-    int argc = 3;\n-    const char *argv[20] = {\"rustc\",\n-                            \"-arm-enable-ehabi\",\n-                            \"-arm-enable-ehabi-descriptors\"};\n-    if (PrintPasses) {\n-        argv[argc++] = \"-debug-pass\";\n-        argv[argc++] = \"Structure\";\n-    }\n-    if (VectorizeLoops) {\n-        argv[argc++] = \"-vectorize-loops\";\n-    }\n-    if (VectorizeSLP) {\n-        argv[argc++] = \"-vectorize-slp\";\n-    }\n-    if (TimePasses) {\n-        argv[argc++] = \"-time-passes\";\n-    }\n-    cl::ParseCommandLineOptions(argc, argv);\n     initialized = true;\n+    cl::ParseCommandLineOptions(Argc, Argv);\n }\n \n extern \"C\" bool"}]}