{"sha": "9358eecc042d8b551f58d2d5ddb9c88d258880c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNThlZWNjMDQyZDhiNTUxZjU4ZDJkNWRkYjljODhkMjU4ODgwYzE=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-01-28T15:33:02Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-01-28T17:04:14Z"}, "message": "Async Loading outdir and proc-macro", "tree": {"sha": "7188b0e27d9d00640b5c76319ee59b2d5cab1b05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7188b0e27d9d00640b5c76319ee59b2d5cab1b05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9358eecc042d8b551f58d2d5ddb9c88d258880c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9358eecc042d8b551f58d2d5ddb9c88d258880c1", "html_url": "https://github.com/rust-lang/rust/commit/9358eecc042d8b551f58d2d5ddb9c88d258880c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9358eecc042d8b551f58d2d5ddb9c88d258880c1/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f421ee672253499b8ca8d1badf98db42525a5216", "url": "https://api.github.com/repos/rust-lang/rust/commits/f421ee672253499b8ca8d1badf98db42525a5216", "html_url": "https://github.com/rust-lang/rust/commit/f421ee672253499b8ca8d1badf98db42525a5216"}], "stats": {"total": 596, "additions": 397, "deletions": 199}, "files": [{"sha": "a5c564e0a5f580427208deb3f2a09e3ecaef8e6a", "filename": "crates/project_model/src/build_data.rs", "status": "modified", "additions": 168, "deletions": 120, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs?ref=9358eecc042d8b551f58d2d5ddb9c88d258880c1", "patch": "@@ -5,161 +5,207 @@ use std::{\n     io::BufReader,\n     path::{Path, PathBuf},\n     process::{Command, Stdio},\n+    sync::Arc,\n };\n \n use anyhow::Result;\n-use cargo_metadata::{BuildScript, Message, Package, PackageId};\n+use cargo_metadata::{BuildScript, Message};\n use itertools::Itertools;\n use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::FxHashMap;\n use stdx::JodChild;\n \n use crate::{cfg_flag::CfgFlag, CargoConfig};\n \n-#[derive(Debug, Clone, Default)]\n-pub(crate) struct BuildDataMap {\n-    data: FxHashMap<PackageId, BuildData>,\n-}\n #[derive(Debug, Clone, Default, PartialEq, Eq)]\n-pub struct BuildData {\n+pub(crate) struct BuildData {\n     /// List of config flags defined by this package's build script\n-    pub cfgs: Vec<CfgFlag>,\n+    pub(crate) cfgs: Vec<CfgFlag>,\n     /// List of cargo-related environment variables with their value\n     ///\n     /// If the package has a build script which defines environment variables,\n     /// they can also be found here.\n-    pub envs: Vec<(String, String)>,\n+    pub(crate) envs: Vec<(String, String)>,\n     /// Directory where a build script might place its output\n-    pub out_dir: Option<AbsPathBuf>,\n+    pub(crate) out_dir: Option<AbsPathBuf>,\n     /// Path to the proc-macro library file if this package exposes proc-macros\n-    pub proc_macro_dylib_path: Option<AbsPathBuf>,\n+    pub(crate) proc_macro_dylib_path: Option<AbsPathBuf>,\n }\n \n-impl BuildDataMap {\n-    pub(crate) fn new(\n-        cargo_toml: &AbsPath,\n-        cargo_features: &CargoConfig,\n-        packages: &Vec<Package>,\n-        progress: &dyn Fn(String),\n-    ) -> Result<BuildDataMap> {\n-        let mut cmd = Command::new(toolchain::cargo());\n-        cmd.args(&[\"check\", \"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n-            .arg(cargo_toml.as_ref());\n-\n-        // --all-targets includes tests, benches and examples in addition to the\n-        // default lib and bins. This is an independent concept from the --targets\n-        // flag below.\n-        cmd.arg(\"--all-targets\");\n-\n-        if let Some(target) = &cargo_features.target {\n-            cmd.args(&[\"--target\", target]);\n-        }\n+#[derive(Clone, Debug)]\n+pub(crate) struct BuildDataConfig {\n+    cargo_toml: AbsPathBuf,\n+    cargo_features: CargoConfig,\n+    packages: Arc<Vec<cargo_metadata::Package>>,\n+}\n \n-        if cargo_features.all_features {\n-            cmd.arg(\"--all-features\");\n-        } else {\n-            if cargo_features.no_default_features {\n-                // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n-                // https://github.com/oli-obk/cargo_metadata/issues/79\n-                cmd.arg(\"--no-default-features\");\n-            }\n-            if !cargo_features.features.is_empty() {\n-                cmd.arg(\"--features\");\n-                cmd.arg(cargo_features.features.join(\" \"));\n-            }\n-        }\n+impl PartialEq for BuildDataConfig {\n+    fn eq(&self, other: &Self) -> bool {\n+        Arc::ptr_eq(&self.packages, &other.packages)\n+    }\n+}\n \n-        cmd.stdout(Stdio::piped()).stderr(Stdio::null()).stdin(Stdio::null());\n-\n-        let mut child = cmd.spawn().map(JodChild)?;\n-        let child_stdout = child.stdout.take().unwrap();\n-        let stdout = BufReader::new(child_stdout);\n-\n-        let mut res = BuildDataMap::default();\n-        for message in cargo_metadata::Message::parse_stream(stdout) {\n-            if let Ok(message) = message {\n-                match message {\n-                    Message::BuildScriptExecuted(BuildScript {\n-                        package_id,\n-                        out_dir,\n-                        cfgs,\n-                        env,\n-                        ..\n-                    }) => {\n-                        let cfgs = {\n-                            let mut acc = Vec::new();\n-                            for cfg in cfgs {\n-                                match cfg.parse::<CfgFlag>() {\n-                                    Ok(it) => acc.push(it),\n-                                    Err(err) => {\n-                                        anyhow::bail!(\"invalid cfg from cargo-metadata: {}\", err)\n-                                    }\n-                                };\n-                            }\n-                            acc\n-                        };\n-                        let res = res.data.entry(package_id.clone()).or_default();\n-                        // cargo_metadata crate returns default (empty) path for\n-                        // older cargos, which is not absolute, so work around that.\n-                        if out_dir != PathBuf::default() {\n-                            let out_dir = AbsPathBuf::assert(out_dir);\n-                            res.out_dir = Some(out_dir);\n-                            res.cfgs = cfgs;\n-                        }\n+impl Eq for BuildDataConfig {}\n \n-                        res.envs = env;\n-                    }\n-                    Message::CompilerArtifact(message) => {\n-                        progress(format!(\"metadata {}\", message.target.name));\n-\n-                        if message.target.kind.contains(&\"proc-macro\".to_string()) {\n-                            let package_id = message.package_id;\n-                            // Skip rmeta file\n-                            if let Some(filename) =\n-                                message.filenames.iter().find(|name| is_dylib(name))\n-                            {\n-                                let filename = AbsPathBuf::assert(filename.clone());\n-                                let res = res.data.entry(package_id.clone()).or_default();\n-                                res.proc_macro_dylib_path = Some(filename);\n-                            }\n-                        }\n-                    }\n-                    Message::CompilerMessage(message) => {\n-                        progress(message.target.name.clone());\n-                    }\n-                    Message::Unknown => (),\n-                    Message::BuildFinished(_) => {}\n-                    Message::TextLine(_) => {}\n-                }\n-            }\n+#[derive(Debug, Default)]\n+pub struct BuildDataCollector {\n+    configs: FxHashMap<AbsPathBuf, BuildDataConfig>,\n+}\n+\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct BuildDataResult {\n+    data: FxHashMap<AbsPathBuf, BuildDataMap>,\n+}\n+\n+pub(crate) type BuildDataMap = FxHashMap<String, BuildData>;\n+\n+impl BuildDataCollector {\n+    pub(crate) fn add_config(&mut self, workspace_root: &AbsPath, config: BuildDataConfig) {\n+        self.configs.insert(workspace_root.to_path_buf().clone(), config);\n+    }\n+\n+    pub fn collect(&mut self, progress: &dyn Fn(String)) -> Result<BuildDataResult> {\n+        let mut res = BuildDataResult::default();\n+        for (path, config) in self.configs.iter() {\n+            res.data.insert(\n+                path.clone(),\n+                collect_from_workspace(\n+                    &config.cargo_toml,\n+                    &config.cargo_features,\n+                    &config.packages,\n+                    progress,\n+                )?,\n+            );\n         }\n-        res.inject_cargo_env(packages);\n         Ok(res)\n     }\n+}\n+\n+impl BuildDataResult {\n+    pub(crate) fn get(&self, root: &AbsPath) -> Option<&BuildDataMap> {\n+        self.data.get(&root.to_path_buf())\n+    }\n+}\n \n-    pub(crate) fn with_cargo_env(packages: &Vec<Package>) -> Self {\n-        let mut res = Self::default();\n-        res.inject_cargo_env(packages);\n-        res\n+impl BuildDataConfig {\n+    pub(crate) fn new(\n+        cargo_toml: AbsPathBuf,\n+        cargo_features: CargoConfig,\n+        packages: Arc<Vec<cargo_metadata::Package>>,\n+    ) -> Self {\n+        Self { cargo_toml, cargo_features, packages }\n     }\n+}\n \n-    pub(crate) fn get(&self, id: &PackageId) -> Option<&BuildData> {\n-        self.data.get(id)\n+fn collect_from_workspace(\n+    cargo_toml: &AbsPath,\n+    cargo_features: &CargoConfig,\n+    packages: &Vec<cargo_metadata::Package>,\n+    progress: &dyn Fn(String),\n+) -> Result<BuildDataMap> {\n+    let mut cmd = Command::new(toolchain::cargo());\n+    cmd.args(&[\"check\", \"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n+        .arg(cargo_toml.as_ref());\n+\n+    // --all-targets includes tests, benches and examples in addition to the\n+    // default lib and bins. This is an independent concept from the --targets\n+    // flag below.\n+    cmd.arg(\"--all-targets\");\n+\n+    if let Some(target) = &cargo_features.target {\n+        cmd.args(&[\"--target\", target]);\n     }\n \n-    fn inject_cargo_env(&mut self, packages: &Vec<Package>) {\n-        for meta_pkg in packages {\n-            let resource = self.data.entry(meta_pkg.id.clone()).or_default();\n-            inject_cargo_env(meta_pkg, &mut resource.envs);\n+    if cargo_features.all_features {\n+        cmd.arg(\"--all-features\");\n+    } else {\n+        if cargo_features.no_default_features {\n+            // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n+            // https://github.com/oli-obk/cargo_metadata/issues/79\n+            cmd.arg(\"--no-default-features\");\n+        }\n+        if !cargo_features.features.is_empty() {\n+            cmd.arg(\"--features\");\n+            cmd.arg(cargo_features.features.join(\" \"));\n+        }\n+    }\n+\n+    cmd.stdout(Stdio::piped()).stderr(Stdio::null()).stdin(Stdio::null());\n \n-            if let Some(out_dir) = &resource.out_dir {\n-                // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n-                if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n-                    resource.envs.push((\"OUT_DIR\".to_string(), out_dir));\n+    let mut child = cmd.spawn().map(JodChild)?;\n+    let child_stdout = child.stdout.take().unwrap();\n+    let stdout = BufReader::new(child_stdout);\n+\n+    let mut res = BuildDataMap::default();\n+    for message in cargo_metadata::Message::parse_stream(stdout) {\n+        if let Ok(message) = message {\n+            match message {\n+                Message::BuildScriptExecuted(BuildScript {\n+                    package_id,\n+                    out_dir,\n+                    cfgs,\n+                    env,\n+                    ..\n+                }) => {\n+                    let cfgs = {\n+                        let mut acc = Vec::new();\n+                        for cfg in cfgs {\n+                            match cfg.parse::<CfgFlag>() {\n+                                Ok(it) => acc.push(it),\n+                                Err(err) => {\n+                                    anyhow::bail!(\"invalid cfg from cargo-metadata: {}\", err)\n+                                }\n+                            };\n+                        }\n+                        acc\n+                    };\n+                    let res = res.entry(package_id.repr.clone()).or_default();\n+                    // cargo_metadata crate returns default (empty) path for\n+                    // older cargos, which is not absolute, so work around that.\n+                    if out_dir != PathBuf::default() {\n+                        let out_dir = AbsPathBuf::assert(out_dir);\n+                        res.out_dir = Some(out_dir);\n+                        res.cfgs = cfgs;\n+                    }\n+\n+                    res.envs = env;\n+                }\n+                Message::CompilerArtifact(message) => {\n+                    progress(format!(\"metadata {}\", message.target.name));\n+\n+                    if message.target.kind.contains(&\"proc-macro\".to_string()) {\n+                        let package_id = message.package_id;\n+                        // Skip rmeta file\n+                        if let Some(filename) = message.filenames.iter().find(|name| is_dylib(name))\n+                        {\n+                            let filename = AbsPathBuf::assert(filename.clone());\n+                            let res = res.entry(package_id.repr.clone()).or_default();\n+                            res.proc_macro_dylib_path = Some(filename);\n+                        }\n+                    }\n+                }\n+                Message::CompilerMessage(message) => {\n+                    progress(message.target.name.clone());\n                 }\n+                Message::Unknown => (),\n+                Message::BuildFinished(_) => {}\n+                Message::TextLine(_) => {}\n             }\n         }\n     }\n+\n+    for package in packages {\n+        let build_data = res.entry(package.id.repr.clone()).or_default();\n+        inject_cargo_env(package, build_data);\n+        if let Some(out_dir) = &build_data.out_dir {\n+            // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n+            if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n+                build_data.envs.push((\"OUT_DIR\".to_string(), out_dir));\n+            }\n+        }\n+    }\n+\n+    Ok(res)\n }\n \n // FIXME: File a better way to know if it is a dylib\n@@ -173,7 +219,9 @@ fn is_dylib(path: &Path) -> bool {\n /// Recreates the compile-time environment variables that Cargo sets.\n ///\n /// Should be synced with <https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates>\n-fn inject_cargo_env(package: &cargo_metadata::Package, env: &mut Vec<(String, String)>) {\n+fn inject_cargo_env(package: &cargo_metadata::Package, build_data: &mut BuildData) {\n+    let env = &mut build_data.envs;\n+\n     // FIXME: Missing variables:\n     // CARGO_PKG_HOMEPAGE, CARGO_CRATE_NAME, CARGO_BIN_NAME, CARGO_BIN_EXE_<name>\n "}, {"sha": "f47898b9b2bc8ce1ce09da8c8d64c5773e2e3570", "filename": "crates/project_model/src/cargo_workspace.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs?ref=9358eecc042d8b551f58d2d5ddb9c88d258880c1", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use std::{convert::TryInto, ops, process::Command};\n+use std::{convert::TryInto, ops, process::Command, sync::Arc};\n \n use anyhow::{Context, Result};\n use base_db::Edition;\n@@ -9,7 +9,7 @@ use la_arena::{Arena, Idx};\n use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::FxHashMap;\n \n-use crate::build_data::{BuildData, BuildDataMap};\n+use crate::build_data::BuildDataConfig;\n use crate::utf8_stdout;\n \n /// `CargoWorkspace` represents the logical structure of, well, a Cargo\n@@ -27,6 +27,7 @@ pub struct CargoWorkspace {\n     packages: Arena<PackageData>,\n     targets: Arena<TargetData>,\n     workspace_root: AbsPathBuf,\n+    build_data_config: BuildDataConfig,\n }\n \n impl ops::Index<Package> for CargoWorkspace {\n@@ -55,9 +56,6 @@ pub struct CargoConfig {\n     /// This will be ignored if `cargo_all_features` is true.\n     pub features: Vec<String>,\n \n-    /// Runs cargo check on launch to figure out the correct values of OUT_DIR\n-    pub load_out_dirs_from_check: bool,\n-\n     /// rustc target\n     pub target: Option<String>,\n \n@@ -94,8 +92,8 @@ pub struct PackageData {\n     pub features: FxHashMap<String, Vec<String>>,\n     /// List of features enabled on this package\n     pub active_features: Vec<String>,\n-    /// Build script related data for this package\n-    pub build_data: BuildData,\n+    // String representation of package id\n+    pub id: String,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -228,48 +226,39 @@ impl CargoWorkspace {\n             )\n         })?;\n \n-        let resources = if config.load_out_dirs_from_check {\n-            BuildDataMap::new(cargo_toml, config, &meta.packages, progress)?\n-        } else {\n-            BuildDataMap::with_cargo_env(&meta.packages)\n-        };\n-\n         let mut pkg_by_id = FxHashMap::default();\n         let mut packages = Arena::default();\n         let mut targets = Arena::default();\n \n         let ws_members = &meta.workspace_members;\n \n         meta.packages.sort_by(|a, b| a.id.cmp(&b.id));\n-        for meta_pkg in meta.packages {\n-            let id = meta_pkg.id.clone();\n-            let build_data = resources.get(&id).cloned().unwrap_or_default();\n-\n+        for meta_pkg in &meta.packages {\n             let cargo_metadata::Package { id, edition, name, manifest_path, version, .. } =\n                 meta_pkg;\n             let is_member = ws_members.contains(&id);\n             let edition = edition\n                 .parse::<Edition>()\n                 .with_context(|| format!(\"Failed to parse edition {}\", edition))?;\n             let pkg = packages.alloc(PackageData {\n-                name,\n+                id: id.repr.clone(),\n+                name: name.clone(),\n                 version: version.to_string(),\n-                manifest: AbsPathBuf::assert(manifest_path),\n+                manifest: AbsPathBuf::assert(manifest_path.clone()),\n                 targets: Vec::new(),\n                 is_member,\n                 edition,\n                 dependencies: Vec::new(),\n-                features: meta_pkg.features.into_iter().collect(),\n+                features: meta_pkg.features.clone().into_iter().collect(),\n                 active_features: Vec::new(),\n-                build_data,\n             });\n             let pkg_data = &mut packages[pkg];\n             pkg_by_id.insert(id, pkg);\n-            for meta_tgt in meta_pkg.targets {\n+            for meta_tgt in &meta_pkg.targets {\n                 let is_proc_macro = meta_tgt.kind.as_slice() == [\"proc-macro\"];\n                 let tgt = targets.alloc(TargetData {\n                     package: pkg,\n-                    name: meta_tgt.name,\n+                    name: meta_tgt.name.clone(),\n                     root: AbsPathBuf::assert(meta_tgt.src_path.clone()),\n                     kind: TargetKind::new(meta_tgt.kind.as_slice()),\n                     is_proc_macro,\n@@ -308,7 +297,13 @@ impl CargoWorkspace {\n         }\n \n         let workspace_root = AbsPathBuf::assert(meta.workspace_root);\n-        Ok(CargoWorkspace { packages, targets, workspace_root: workspace_root })\n+        let build_data_config = BuildDataConfig::new(\n+            cargo_toml.to_path_buf(),\n+            config.clone(),\n+            Arc::new(meta.packages.clone()),\n+        );\n+\n+        Ok(CargoWorkspace { packages, targets, workspace_root, build_data_config })\n     }\n \n     pub fn packages<'a>(&'a self) -> impl Iterator<Item = Package> + ExactSizeIterator + 'a {\n@@ -334,6 +329,10 @@ impl CargoWorkspace {\n         }\n     }\n \n+    pub(crate) fn build_data_config(&self) -> &BuildDataConfig {\n+        &self.build_data_config\n+    }\n+\n     fn is_unique(&self, name: &str) -> bool {\n         self.packages.iter().filter(|(_, v)| v.name == name).count() == 1\n     }"}, {"sha": "d712095a6917d8a930fd4612abdd3cb7f512959f", "filename": "crates/project_model/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Fproject_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Fproject_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Flib.rs?ref=9358eecc042d8b551f58d2d5ddb9c88d258880c1", "patch": "@@ -19,6 +19,7 @@ use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::FxHashSet;\n \n pub use crate::{\n+    build_data::{BuildDataCollector, BuildDataResult},\n     cargo_workspace::{\n         CargoConfig, CargoWorkspace, Package, PackageData, PackageDependency, Target, TargetData,\n         TargetKind,"}, {"sha": "c3086197678de5bc116c0728d991f03f89be4240", "filename": "crates/project_model/src/workspace.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=9358eecc042d8b551f58d2d5ddb9c88d258880c1", "patch": "@@ -16,8 +16,13 @@ use proc_macro_api::ProcMacroClient;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n-    cargo_workspace, cfg_flag::CfgFlag, rustc_cfg, sysroot::SysrootCrate, utf8_stdout, CargoConfig,\n-    CargoWorkspace, ProjectJson, ProjectManifest, Sysroot, TargetKind,\n+    build_data::{BuildData, BuildDataMap, BuildDataResult},\n+    cargo_workspace,\n+    cfg_flag::CfgFlag,\n+    rustc_cfg,\n+    sysroot::SysrootCrate,\n+    utf8_stdout, BuildDataCollector, CargoConfig, CargoWorkspace, ProjectJson, ProjectManifest,\n+    Sysroot, TargetKind,\n };\n \n /// `PackageRoot` describes a package root folder.\n@@ -153,7 +158,7 @@ impl ProjectWorkspace {\n     /// Returns the roots for the current `ProjectWorkspace`\n     /// The return type contains the path and whether or not\n     /// the root is a member of the current workspace\n-    pub fn to_roots(&self) -> Vec<PackageRoot> {\n+    pub fn to_roots(&self, build_data: Option<&BuildDataResult>) -> Vec<PackageRoot> {\n         match self {\n             ProjectWorkspace::Json { project, sysroot, rustc_cfg: _ } => project\n                 .crates()\n@@ -179,7 +184,12 @@ impl ProjectWorkspace {\n                     let pkg_root = cargo[pkg].root().to_path_buf();\n \n                     let mut include = vec![pkg_root.clone()];\n-                    include.extend(cargo[pkg].build_data.out_dir.clone());\n+                    include.extend(\n+                        build_data\n+                            .and_then(|it| it.get(cargo.workspace_root()))\n+                            .and_then(|map| map.get(&cargo[pkg].id))\n+                            .and_then(|it| it.out_dir.clone()),\n+                    );\n \n                     let mut exclude = vec![pkg_root.join(\".git\")];\n                     if is_member {\n@@ -219,6 +229,7 @@ impl ProjectWorkspace {\n \n     pub fn to_crate_graph(\n         &self,\n+        build_data: Option<&BuildDataResult>,\n         proc_macro_client: Option<&ProcMacroClient>,\n         load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     ) -> CrateGraph {\n@@ -241,8 +252,10 @@ impl ProjectWorkspace {\n                 &proc_macro_loader,\n                 load,\n                 cargo,\n+                build_data.and_then(|it| it.get(cargo.workspace_root())),\n                 sysroot,\n                 rustc,\n+                rustc.as_ref().zip(build_data).and_then(|(it, map)| map.get(it.workspace_root())),\n             ),\n         };\n         if crate_graph.patch_cfg_if() {\n@@ -252,6 +265,18 @@ impl ProjectWorkspace {\n         }\n         crate_graph\n     }\n+\n+    pub fn collect_build_data_configs(&self, collector: &mut BuildDataCollector) {\n+        match self {\n+            ProjectWorkspace::Cargo { cargo, rustc, .. } => {\n+                collector.add_config(&cargo.workspace_root(), cargo.build_data_config().clone());\n+                if let Some(rustc) = rustc {\n+                    collector.add_config(rustc.workspace_root(), rustc.build_data_config().clone());\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n }\n \n fn project_json_to_crate_graph(\n@@ -324,8 +349,10 @@ fn cargo_to_crate_graph(\n     proc_macro_loader: &dyn Fn(&Path) -> Vec<ProcMacro>,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     cargo: &CargoWorkspace,\n+    build_data_map: Option<&BuildDataMap>,\n     sysroot: &Sysroot,\n     rustc: &Option<CargoWorkspace>,\n+    rustc_build_data_map: Option<&BuildDataMap>,\n ) -> CrateGraph {\n     let _p = profile::span(\"cargo_to_crate_graph\");\n     let mut crate_graph = CrateGraph::default();\n@@ -351,6 +378,7 @@ fn cargo_to_crate_graph(\n                 let crate_id = add_target_crate_root(\n                     &mut crate_graph,\n                     &cargo[pkg],\n+                    build_data_map.and_then(|it| it.get(&cargo[pkg].id)),\n                     &cfg_options,\n                     proc_macro_loader,\n                     file_id,\n@@ -427,6 +455,7 @@ fn cargo_to_crate_graph(\n                     let crate_id = add_target_crate_root(\n                         &mut crate_graph,\n                         &rustc_workspace[pkg],\n+                        rustc_build_data_map.and_then(|it| it.get(&rustc_workspace[pkg].id)),\n                         &cfg_options,\n                         proc_macro_loader,\n                         file_id,\n@@ -475,6 +504,7 @@ fn cargo_to_crate_graph(\n fn add_target_crate_root(\n     crate_graph: &mut CrateGraph,\n     pkg: &cargo_workspace::PackageData,\n+    build_data: Option<&BuildData>,\n     cfg_options: &CfgOptions,\n     proc_macro_loader: &dyn Fn(&Path) -> Vec<ProcMacro>,\n     file_id: FileId,\n@@ -485,19 +515,22 @@ fn add_target_crate_root(\n         for feature in pkg.active_features.iter() {\n             opts.insert_key_value(\"feature\".into(), feature.into());\n         }\n-        opts.extend(pkg.build_data.cfgs.iter().cloned());\n+        if let Some(cfgs) = build_data.as_ref().map(|it| &it.cfgs) {\n+            opts.extend(cfgs.iter().cloned());\n+        }\n         opts\n     };\n \n     let mut env = Env::default();\n-    for (k, v) in &pkg.build_data.envs {\n-        env.set(k, v.clone());\n+    if let Some(envs) = build_data.map(|it| &it.envs) {\n+        for (k, v) in envs {\n+            env.set(k, v.clone());\n+        }\n     }\n \n-    let proc_macro = pkg\n-        .build_data\n-        .proc_macro_dylib_path\n+    let proc_macro = build_data\n         .as_ref()\n+        .and_then(|it| it.proc_macro_dylib_path.as_ref())\n         .map(|it| proc_macro_loader(&it))\n         .unwrap_or_default();\n "}, {"sha": "e12e871806b2a1576d85872127f5b3a45ee894df", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=9358eecc042d8b551f58d2d5ddb9c88d258880c1", "patch": "@@ -6,7 +6,9 @@ use anyhow::Result;\n use crossbeam_channel::{unbounded, Receiver};\n use ide::{AnalysisHost, Change};\n use ide_db::base_db::CrateGraph;\n-use project_model::{CargoConfig, ProcMacroClient, ProjectManifest, ProjectWorkspace};\n+use project_model::{\n+    BuildDataCollector, CargoConfig, ProcMacroClient, ProjectManifest, ProjectWorkspace,\n+};\n use vfs::{loader::Handle, AbsPath, AbsPathBuf};\n \n use crate::reload::{ProjectFolders, SourceRootConfig};\n@@ -18,11 +20,7 @@ pub fn load_cargo(\n ) -> Result<(AnalysisHost, vfs::Vfs)> {\n     let root = AbsPathBuf::assert(std::env::current_dir()?.join(root));\n     let root = ProjectManifest::discover_single(&root)?;\n-    let ws = ProjectWorkspace::load(\n-        root,\n-        &CargoConfig { load_out_dirs_from_check, ..Default::default() },\n-        &|_| {},\n-    )?;\n+    let ws = ProjectWorkspace::load(root, &CargoConfig::default(), &|_| {})?;\n \n     let (sender, receiver) = unbounded();\n     let mut vfs = vfs::Vfs::default();\n@@ -39,14 +37,26 @@ pub fn load_cargo(\n         None\n     };\n \n-    let crate_graph = ws.to_crate_graph(proc_macro_client.as_ref(), &mut |path: &AbsPath| {\n-        let contents = loader.load_sync(path);\n-        let path = vfs::VfsPath::from(path.to_path_buf());\n-        vfs.set_file_contents(path.clone(), contents);\n-        vfs.file_id(&path)\n-    });\n+    let build_data = if load_out_dirs_from_check {\n+        let mut collector = BuildDataCollector::default();\n+        ws.collect_build_data_configs(&mut collector);\n+        Some(collector.collect(&|_| {})?)\n+    } else {\n+        None\n+    };\n+\n+    let crate_graph = ws.to_crate_graph(\n+        build_data.as_ref(),\n+        proc_macro_client.as_ref(),\n+        &mut |path: &AbsPath| {\n+            let contents = loader.load_sync(path);\n+            let path = vfs::VfsPath::from(path.to_path_buf());\n+            vfs.set_file_contents(path.clone(), contents);\n+            vfs.file_id(&path)\n+        },\n+    );\n \n-    let project_folders = ProjectFolders::new(&[ws], &[]);\n+    let project_folders = ProjectFolders::new(&[ws], &[], build_data.as_ref());\n     loader.set_config(vfs::loader::Config { load: project_folders.load, watch: vec![] });\n \n     log::debug!(\"crate graph: {:?}\", crate_graph);"}, {"sha": "cc0b22bffb1658f87e630b2fea945a29c85a1a8f", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=9358eecc042d8b551f58d2d5ddb9c88d258880c1", "patch": "@@ -469,14 +469,16 @@ impl Config {\n     pub fn cargo_autoreload(&self) -> bool {\n         self.data.cargo_autoreload\n     }\n+    pub fn load_out_dirs_from_check(&self) -> bool {\n+        self.data.cargo_loadOutDirsFromCheck\n+    }\n     pub fn cargo(&self) -> CargoConfig {\n         let rustc_source = self.data.rustcSource.as_ref().map(|it| self.root_path.join(&it));\n \n         CargoConfig {\n             no_default_features: self.data.cargo_noDefaultFeatures,\n             all_features: self.data.cargo_allFeatures,\n             features: self.data.cargo_features.clone(),\n-            load_out_dirs_from_check: self.data.cargo_loadOutDirsFromCheck,\n             target: self.data.cargo_target.clone(),\n             rustc_source,\n             no_sysroot: self.data.cargo_noSysroot,"}, {"sha": "6374a9f3c92b75b336155b98e6b02f7aab2dc29f", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=9358eecc042d8b551f58d2d5ddb9c88d258880c1", "patch": "@@ -11,7 +11,9 @@ use ide::{Analysis, AnalysisHost, Change, FileId};\n use ide_db::base_db::{CrateId, VfsPath};\n use lsp_types::{SemanticTokens, Url};\n use parking_lot::{Mutex, RwLock};\n-use project_model::{CargoWorkspace, ProcMacroClient, ProjectWorkspace, Target};\n+use project_model::{\n+    BuildDataCollector, BuildDataResult, CargoWorkspace, ProcMacroClient, ProjectWorkspace, Target,\n+};\n use rustc_hash::FxHashMap;\n use vfs::AnchoredPathBuf;\n \n@@ -33,7 +35,7 @@ use crate::{\n #[derive(Eq, PartialEq, Copy, Clone)]\n pub(crate) enum Status {\n     Loading,\n-    Ready,\n+    Ready { partial: bool },\n     Invalid,\n     NeedsReload,\n }\n@@ -79,7 +81,9 @@ pub(crate) struct GlobalState {\n     pub(crate) source_root_config: SourceRootConfig,\n     pub(crate) proc_macro_client: Option<ProcMacroClient>,\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n-    pub(crate) fetch_workspaces_queue: OpQueue,\n+    pub(crate) fetch_workspaces_queue: OpQueue<()>,\n+    pub(crate) workspace_build_data: Option<BuildDataResult>,\n+    pub(crate) fetch_build_data_queue: OpQueue<BuildDataCollector>,\n     latest_requests: Arc<RwLock<LatestRequests>>,\n }\n \n@@ -133,6 +137,8 @@ impl GlobalState {\n             proc_macro_client: None,\n             workspaces: Arc::new(Vec::new()),\n             fetch_workspaces_queue: OpQueue::default(),\n+            workspace_build_data: None,\n+            fetch_build_data_queue: OpQueue::default(),\n             latest_requests: Default::default(),\n         }\n     }"}, {"sha": "670ca9a453348903c6a5a3e6d31ad1048d8dac8f", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=9358eecc042d8b551f58d2d5ddb9c88d258880c1", "patch": "@@ -234,6 +234,7 @@ pub enum StatusNotification {}\n #[derive(Serialize, Deserialize)]\n pub enum Status {\n     Loading,\n+    ReadyPartial,\n     Ready,\n     NeedsReload,\n     Invalid,"}, {"sha": "f4fd1ac133536b4ba4859221df849e7ef6ab4811", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=9358eecc042d8b551f58d2d5ddb9c88d258880c1", "patch": "@@ -21,7 +21,7 @@ use crate::{\n     global_state::{file_id_to_url, url_to_file_id, GlobalState, Status},\n     handlers, lsp_ext,\n     lsp_utils::{apply_document_changes, is_canceled, notification_is, Progress},\n-    reload::ProjectWorkspaceProgress,\n+    reload::{BuildDataProgress, ProjectWorkspaceProgress},\n     Result,\n };\n \n@@ -63,6 +63,7 @@ pub(crate) enum Task {\n     Diagnostics(Vec<(FileId, Vec<lsp_types::Diagnostic>)>),\n     PrimeCaches(PrimeCachesProgress),\n     FetchWorkspace(ProjectWorkspaceProgress),\n+    FetchBuildData(BuildDataProgress),\n }\n \n impl fmt::Debug for Event {\n@@ -226,12 +227,33 @@ impl GlobalState {\n                                 }\n                                 ProjectWorkspaceProgress::End(workspaces) => {\n                                     self.fetch_workspaces_completed();\n-                                    self.switch_workspaces(workspaces);\n+                                    self.switch_workspaces(workspaces, None);\n                                     (Progress::End, None)\n                                 }\n                             };\n                             self.report_progress(\"fetching\", state, msg, None);\n                         }\n+                        Task::FetchBuildData(progress) => {\n+                            let (state, msg) = match progress {\n+                                BuildDataProgress::Begin => (Some(Progress::Begin), None),\n+                                BuildDataProgress::Report(msg) => {\n+                                    (Some(Progress::Report), Some(msg))\n+                                }\n+                                BuildDataProgress::End(collector) => {\n+                                    self.fetch_build_data_completed();\n+                                    let workspaces = (*self.workspaces)\n+                                        .clone()\n+                                        .into_iter()\n+                                        .map(|it| Ok(it))\n+                                        .collect();\n+                                    self.switch_workspaces(workspaces, Some(collector));\n+                                    (Some(Progress::End), None)\n+                                }\n+                            };\n+                            if let Some(state) = state {\n+                                self.report_progress(\"loading\", state, msg, None);\n+                            }\n+                        }\n                     }\n                     // Coalesce multiple task events into one loop turn\n                     task = match self.task_pool.receiver.try_recv() {\n@@ -287,7 +309,11 @@ impl GlobalState {\n                                     Progress::Report\n                                 } else {\n                                     assert_eq!(n_done, n_total);\n-                                    self.transition(Status::Ready);\n+                                    let status = Status::Ready {\n+                                        partial: self.config.load_out_dirs_from_check()\n+                                            && self.workspace_build_data.is_none(),\n+                                    };\n+                                    self.transition(status);\n                                     Progress::End\n                                 };\n                                 self.report_progress(\n@@ -372,13 +398,14 @@ impl GlobalState {\n         }\n \n         let state_changed = self.process_changes();\n-        if prev_status == Status::Loading && self.status == Status::Ready {\n+        let is_ready = matches!(self.status, Status::Ready { .. } );\n+        if prev_status == Status::Loading && is_ready {\n             for flycheck in &self.flycheck {\n                 flycheck.update();\n             }\n         }\n \n-        if self.status == Status::Ready && (state_changed || prev_status == Status::Loading) {\n+        if is_ready && (state_changed || prev_status == Status::Loading) {\n             self.update_file_notifications_on_threadpool();\n \n             // Refresh semantic tokens if the client supports it.\n@@ -408,6 +435,7 @@ impl GlobalState {\n         }\n \n         self.fetch_workspaces_if_needed();\n+        self.fetch_build_data_if_needed();\n \n         let loop_duration = loop_start.elapsed();\n         if loop_duration > Duration::from_millis(100) {"}, {"sha": "761b9ad391d9f6399a075b371cf61cfd2089ac1d", "filename": "crates/rust-analyzer/src/op_queue.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Fop_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Fop_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fop_queue.rs?ref=9358eecc042d8b551f58d2d5ddb9c88d258880c1", "patch": "@@ -1,22 +1,26 @@\n //! Bookkeeping to make sure only one long-running operation is executed.\n \n-#[derive(Default)]\n-pub(crate) struct OpQueue {\n-    op_scheduled: bool,\n+pub(crate) struct OpQueue<D> {\n+    op_scheduled: Option<D>,\n     op_in_progress: bool,\n }\n \n-impl OpQueue {\n-    pub(crate) fn request_op(&mut self) {\n-        self.op_scheduled = true;\n+impl<D> Default for OpQueue<D> {\n+    fn default() -> Self {\n+        Self { op_scheduled: None, op_in_progress: false }\n     }\n-    pub(crate) fn should_start_op(&mut self) -> bool {\n-        if !self.op_in_progress && self.op_scheduled {\n-            self.op_in_progress = true;\n-            self.op_scheduled = false;\n-            return true;\n+}\n+\n+impl<D> OpQueue<D> {\n+    pub(crate) fn request_op(&mut self, data: D) {\n+        self.op_scheduled = Some(data);\n+    }\n+    pub(crate) fn should_start_op(&mut self) -> Option<D> {\n+        if self.op_in_progress {\n+            return None;\n         }\n-        false\n+        self.op_in_progress = self.op_scheduled.is_some();\n+        self.op_scheduled.take()\n     }\n     pub(crate) fn op_completed(&mut self) {\n         assert!(self.op_in_progress);"}, {"sha": "289bbc4435e411ebc0402f0fd8c7c4310eb9e625", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 77, "deletions": 11, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9358eecc042d8b551f58d2d5ddb9c88d258880c1/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=9358eecc042d8b551f58d2d5ddb9c88d258880c1", "patch": "@@ -4,7 +4,7 @@ use std::{mem, sync::Arc};\n use flycheck::{FlycheckConfig, FlycheckHandle};\n use ide::Change;\n use ide_db::base_db::{CrateGraph, SourceRoot, VfsPath};\n-use project_model::{ProcMacroClient, ProjectWorkspace};\n+use project_model::{BuildDataCollector, BuildDataResult, ProcMacroClient, ProjectWorkspace};\n use vfs::{file_set::FileSetConfig, AbsPath, AbsPathBuf, ChangeKind};\n \n use crate::{\n@@ -22,6 +22,13 @@ pub(crate) enum ProjectWorkspaceProgress {\n     End(Vec<anyhow::Result<ProjectWorkspace>>),\n }\n \n+#[derive(Debug)]\n+pub(crate) enum BuildDataProgress {\n+    Begin,\n+    Report(String),\n+    End(anyhow::Result<BuildDataResult>),\n+}\n+\n impl GlobalState {\n     pub(crate) fn update_configuration(&mut self, config: Config) {\n         let _p = profile::span(\"GlobalState::update_configuration\");\n@@ -41,7 +48,7 @@ impl GlobalState {\n         }\n         match self.status {\n             Status::Loading | Status::NeedsReload => return,\n-            Status::Ready | Status::Invalid => (),\n+            Status::Ready { .. } | Status::Invalid => (),\n         }\n         if self.config.cargo_autoreload() {\n             self.fetch_workspaces_request();\n@@ -89,7 +96,8 @@ impl GlobalState {\n         if self.config.status_notification() {\n             let lsp_status = match new_status {\n                 Status::Loading => lsp_ext::Status::Loading,\n-                Status::Ready => lsp_ext::Status::Ready,\n+                Status::Ready { partial: true } => lsp_ext::Status::ReadyPartial,\n+                Status::Ready { partial: false } => lsp_ext::Status::Ready,\n                 Status::Invalid => lsp_ext::Status::Invalid,\n                 Status::NeedsReload => lsp_ext::Status::NeedsReload,\n             };\n@@ -99,11 +107,37 @@ impl GlobalState {\n         }\n     }\n \n+    pub(crate) fn fetch_build_data_request(&mut self, build_data_collector: BuildDataCollector) {\n+        self.fetch_build_data_queue.request_op(build_data_collector);\n+    }\n+\n+    pub(crate) fn fetch_build_data_if_needed(&mut self) {\n+        let mut build_data_collector = match self.fetch_build_data_queue.should_start_op() {\n+            Some(it) => it,\n+            None => return,\n+        };\n+        self.task_pool.handle.spawn_with_sender(move |sender| {\n+            sender.send(Task::FetchBuildData(BuildDataProgress::Begin)).unwrap();\n+\n+            let progress = {\n+                let sender = sender.clone();\n+                move |msg| {\n+                    sender.send(Task::FetchBuildData(BuildDataProgress::Report(msg))).unwrap()\n+                }\n+            };\n+            let res = build_data_collector.collect(&progress);\n+            sender.send(Task::FetchBuildData(BuildDataProgress::End(res))).unwrap();\n+        });\n+    }\n+    pub(crate) fn fetch_build_data_completed(&mut self) {\n+        self.fetch_build_data_queue.op_completed()\n+    }\n+\n     pub(crate) fn fetch_workspaces_request(&mut self) {\n-        self.fetch_workspaces_queue.request_op()\n+        self.fetch_workspaces_queue.request_op(())\n     }\n     pub(crate) fn fetch_workspaces_if_needed(&mut self) {\n-        if !self.fetch_workspaces_queue.should_start_op() {\n+        if self.fetch_workspaces_queue.should_start_op().is_none() {\n             return;\n         }\n         log::info!(\"will fetch workspaces\");\n@@ -154,7 +188,11 @@ impl GlobalState {\n         self.fetch_workspaces_queue.op_completed()\n     }\n \n-    pub(crate) fn switch_workspaces(&mut self, workspaces: Vec<anyhow::Result<ProjectWorkspace>>) {\n+    pub(crate) fn switch_workspaces(\n+        &mut self,\n+        workspaces: Vec<anyhow::Result<ProjectWorkspace>>,\n+        workspace_build_data: Option<anyhow::Result<BuildDataResult>>,\n+    ) {\n         let _p = profile::span(\"GlobalState::switch_workspaces\");\n         log::info!(\"will switch workspaces: {:?}\", workspaces);\n \n@@ -176,7 +214,20 @@ impl GlobalState {\n             })\n             .collect::<Vec<_>>();\n \n-        if &*self.workspaces == &workspaces {\n+        let workspace_build_data = match workspace_build_data {\n+            Some(Ok(it)) => Some(it),\n+            Some(Err(err)) => {\n+                log::error!(\"failed to fetch build data: {:#}\", err);\n+                self.show_message(\n+                    lsp_types::MessageType::Error,\n+                    format!(\"rust-analyzer failed to fetch build data: {:#}\", err),\n+                );\n+                return;\n+            }\n+            None => None,\n+        };\n+\n+        if &*self.workspaces == &workspaces && self.workspace_build_data == workspace_build_data {\n             return;\n         }\n \n@@ -189,7 +240,7 @@ impl GlobalState {\n                 let registration_options = lsp_types::DidChangeWatchedFilesRegistrationOptions {\n                     watchers: workspaces\n                         .iter()\n-                        .flat_map(ProjectWorkspace::to_roots)\n+                        .flat_map(|it| it.to_roots(workspace_build_data.as_ref()))\n                         .filter(|it| it.is_member)\n                         .flat_map(|root| {\n                             root.include.into_iter().map(|it| format!(\"{}/**/*.rs\", it.display()))\n@@ -215,7 +266,8 @@ impl GlobalState {\n         let mut change = Change::new();\n \n         let files_config = self.config.files();\n-        let project_folders = ProjectFolders::new(&workspaces, &files_config.exclude);\n+        let project_folders =\n+            ProjectFolders::new(&workspaces, &files_config.exclude, workspace_build_data.as_ref());\n \n         self.proc_macro_client = match self.config.proc_macro_srv() {\n             None => None,\n@@ -257,15 +309,28 @@ impl GlobalState {\n                 res\n             };\n             for ws in workspaces.iter() {\n-                crate_graph.extend(ws.to_crate_graph(self.proc_macro_client.as_ref(), &mut load));\n+                crate_graph.extend(ws.to_crate_graph(\n+                    self.workspace_build_data.as_ref(),\n+                    self.proc_macro_client.as_ref(),\n+                    &mut load,\n+                ));\n             }\n \n             crate_graph\n         };\n         change.set_crate_graph(crate_graph);\n \n+        if self.config.load_out_dirs_from_check() && workspace_build_data.is_none() {\n+            let mut collector = BuildDataCollector::default();\n+            for ws in &workspaces {\n+                ws.collect_build_data_configs(&mut collector);\n+            }\n+            self.fetch_build_data_request(collector)\n+        }\n+\n         self.source_root_config = project_folders.source_root_config;\n         self.workspaces = Arc::new(workspaces);\n+        self.workspace_build_data = workspace_build_data;\n \n         self.analysis_host.apply_change(change);\n         self.process_changes();\n@@ -323,12 +388,13 @@ impl ProjectFolders {\n     pub(crate) fn new(\n         workspaces: &[ProjectWorkspace],\n         global_excludes: &[AbsPathBuf],\n+        build_data: Option<&BuildDataResult>,\n     ) -> ProjectFolders {\n         let mut res = ProjectFolders::default();\n         let mut fsc = FileSetConfig::builder();\n         let mut local_filesets = vec![];\n \n-        for root in workspaces.iter().flat_map(|it| it.to_roots()) {\n+        for root in workspaces.iter().flat_map(|it| it.to_roots(build_data)) {\n             let file_set_roots: Vec<VfsPath> =\n                 root.include.iter().cloned().map(VfsPath::from).collect();\n "}]}