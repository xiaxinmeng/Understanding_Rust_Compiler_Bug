{"sha": "ba26efb60c9e11ab058a1c31b9816147c55ab417", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMjZlZmI2MGM5ZTExYWIwNThhMWMzMWI5ODE2MTQ3YzU1YWI0MTc=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-02-04T17:40:28Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-02-24T19:05:21Z"}, "message": "Implement filling drop in MIR\n\nHopefully the author caught all the cases. For the mir_dynamic_drops_3 test case the ratio of\nmemsets to other instructions is 12%. On the other hand we actually do not double drop for at least\nthe test cases provided anymore in MIR.", "tree": {"sha": "37cfc6ce05c69908fe02a37515185c79a9248d1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37cfc6ce05c69908fe02a37515185c79a9248d1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba26efb60c9e11ab058a1c31b9816147c55ab417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba26efb60c9e11ab058a1c31b9816147c55ab417", "html_url": "https://github.com/rust-lang/rust/commit/ba26efb60c9e11ab058a1c31b9816147c55ab417", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba26efb60c9e11ab058a1c31b9816147c55ab417/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be7196a793a185355efb7ec8801102ddec95483d", "url": "https://api.github.com/repos/rust-lang/rust/commits/be7196a793a185355efb7ec8801102ddec95483d", "html_url": "https://github.com/rust-lang/rust/commit/be7196a793a185355efb7ec8801102ddec95483d"}], "stats": {"total": 230, "additions": 147, "deletions": 83}, "files": [{"sha": "bc54b1ebab79a7a9d1e1479ba707c1ae160cfdd9", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=ba26efb60c9e11ab058a1c31b9816147c55ab417", "patch": "@@ -2165,6 +2165,8 @@ extern {\n                                          NumInputs: c_uint)\n                                          -> OperandBundleDefRef;\n     pub fn LLVMRustFreeOperandBundleDef(Bundle: OperandBundleDefRef);\n+\n+    pub fn LLVMRustPositionBuilderAtStart(B: BuilderRef, BB: BasicBlockRef);\n }\n \n // LLVM requires symbols from this library, but apparently they're not printed"}, {"sha": "6599de3c33d432a3942439f557d5fd69a3323a4c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=ba26efb60c9e11ab058a1c31b9816147c55ab417", "patch": "@@ -1298,22 +1298,29 @@ pub fn init_zero_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'\n fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte: u8) {\n     let _icx = push_ctxt(\"memfill\");\n     let ccx = b.ccx;\n-\n     let llty = type_of::type_of(ccx, ty);\n-    let ptr_width = &ccx.sess().target.target.target_pointer_width[..];\n-    let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n-\n-    let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n     let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());\n     let llzeroval = C_u8(ccx, byte);\n     let size = machine::llsize_of(ccx, llty);\n     let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n-    let volatile = C_bool(ccx, false);\n-    b.call(llintrinsicfn,\n-           &[llptr, llzeroval, size, align, volatile],\n-           None, None);\n+    call_memset(b, llptr, llzeroval, size, align, false);\n }\n \n+pub fn call_memset<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n+                               ptr: ValueRef,\n+                               fill_byte: ValueRef,\n+                               size: ValueRef,\n+                               align: ValueRef,\n+                               volatile: bool) {\n+    let ccx = b.ccx;\n+    let ptr_width = &ccx.sess().target.target.target_pointer_width[..];\n+    let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n+    let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n+    let volatile = C_bool(ccx, volatile);\n+    b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None, None);\n+}\n+\n+\n /// In general, when we create an scratch value in an alloca, the\n /// creator may not know if the block (that initializes the scratch\n /// with the desired value) actually dominates the cleanup associated"}, {"sha": "3b4a67cb08979855d6a27df103e71301c983d4e6", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=ba26efb60c9e11ab058a1c31b9816147c55ab417", "patch": "@@ -104,6 +104,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn position_at_start(&self, llbb: BasicBlockRef) {\n+        unsafe {\n+            llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n+        }\n+    }\n+\n     pub fn ret_void(&self) {\n         self.count_insn(\"retvoid\");\n         unsafe {"}, {"sha": "0fdfd69eb078407154cbdf092a07f94f09a62e11", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=ba26efb60c9e11ab058a1c31b9816147c55ab417", "patch": "@@ -735,6 +735,15 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n         BlockAndBuilder::new(bcx, owned_builder)\n     }\n \n+    pub fn at_start<F, R>(&self, f: F) -> R\n+        where F: FnOnce(&BlockAndBuilder<'blk, 'tcx>) -> R\n+    {\n+        self.position_at_start(self.bcx.llbb);\n+        let r = f(self);\n+        self.position_at_end(self.bcx.llbb);\n+        r\n+    }\n+\n     // Methods delegated to bcx\n \n     pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {"}, {"sha": "29479b030c664a3df7b4bc0dafcf44014dc0f1d3", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=ba26efb60c9e11ab058a1c31b9816147c55ab417", "patch": "@@ -20,11 +20,11 @@ use trans::common::{self, Block, BlockAndBuilder};\n use trans::debuginfo::DebugLoc;\n use trans::Disr;\n use trans::foreign;\n-use trans::glue;\n use trans::type_of;\n+use trans::glue;\n use trans::type_::Type;\n \n-use super::MirContext;\n+use super::{MirContext, drop};\n use super::operand::OperandValue::{FatPtr, Immediate, Ref};\n use super::operand::OperandRef;\n \n@@ -188,8 +188,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                unwind.llbb(),\n                                cleanup_bundle.as_ref(),\n                                None);\n+                    self.bcx(target).at_start(|bcx| drop::drop_fill(bcx, lvalue.llval, ty));\n                 } else {\n                     bcx.call(drop_fn, &[llvalue], cleanup_bundle.as_ref(), None);\n+                    drop::drop_fill(&bcx, lvalue.llval, ty);\n                     funclet_br(bcx, self.llblock(target));\n                 }\n             }\n@@ -250,59 +252,41 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                    landingpad.llbb(),\n                                    cleanup_bundle.as_ref(),\n                                    Some(attrs));\n+                        landingpad.at_start(|bcx| for op in args {\n+                            self.set_operand_dropped(bcx, op);\n+                        });\n                     },\n                     (false, &Some(cleanup), &Some((_, success))) => {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n-                        let (target, postinvoke) = if must_copy_dest {\n-                            (self.fcx.new_block(\"\", None).build(), Some(self.bcx(success)))\n-                        } else {\n-                            (self.bcx(success), None)\n-                        };\n                         let invokeret = bcx.invoke(callee.immediate(),\n                                                    &llargs[..],\n-                                                   target.llbb(),\n+                                                   self.llblock(success),\n                                                    landingpad.llbb(),\n                                                    cleanup_bundle.as_ref(),\n                                                    Some(attrs));\n-                        if let Some(postinvoketarget) = postinvoke {\n-                            // We translate the copy into a temporary block. The temporary block is\n-                            // necessary because the current block has already been terminated (by\n-                            // `invoke`) and we cannot really translate into the target block\n-                            // because:\n-                            //  * The target block may have more than a single precedesor;\n-                            //  * Some LLVM insns cannot have a preceeding store insn (phi,\n-                            //    cleanuppad), and adding/prepending the store now may render\n-                            //    those other instructions invalid.\n-                            //\n-                            // NB: This approach still may break some LLVM code. For example if the\n-                            // target block starts with a `phi` (which may only match on immediate\n-                            // precedesors), it cannot know about this temporary block thus\n-                            // resulting in an invalid code:\n-                            //\n-                            // this:\n-                            //     \u2026\n-                            //     %0 = \u2026\n-                            //     %1 = invoke to label %temp \u2026\n-                            // temp:\n-                            //     store ty %1, ty* %dest\n-                            //     br label %actualtargetblock\n-                            // actualtargetblock:            ; preds: %temp, \u2026\n-                            //     phi \u2026 [%this, \u2026], [%0, \u2026] ; ERROR: phi requires to match only on\n-                            //                               ; immediate precedesors\n+                        if must_copy_dest {\n                             let (ret_dest, ret_ty) = ret_dest_ty\n                                 .expect(\"return destination and type not set\");\n-                            target.with_block(|target| {\n-                                base::store_ty(target, invokeret, ret_dest.llval, ret_ty);\n-                            });\n-                            target.br(postinvoketarget.llbb());\n+                            // We translate the copy straight into the beginning of the target\n+                            // block.\n+                            self.bcx(success).at_start(|bcx| bcx.with_block( |bcx| {\n+                                base::store_ty(bcx, invokeret, ret_dest.llval, ret_ty);\n+                            }));\n                         }\n+                        self.bcx(success).at_start(|bcx| for op in args {\n+                            self.set_operand_dropped(bcx, op);\n+                        });\n+                        landingpad.at_start(|bcx| for op in args {\n+                                self.set_operand_dropped(bcx, op);\n+                        });\n                     },\n                     (false, _, &None) => {\n                         bcx.call(callee.immediate(),\n                                  &llargs[..],\n                                  cleanup_bundle.as_ref(),\n                                  Some(attrs));\n+                        // no need to drop args, because the call never returns\n                         bcx.unreachable();\n                     }\n                     (false, _, &Some((_, target))) => {\n@@ -317,6 +301,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 base::store_ty(bcx, llret, ret_dest.llval, ret_ty);\n                             });\n                         }\n+                        for op in args {\n+                            self.set_operand_dropped(&bcx, op);\n+                        }\n                         funclet_br(bcx, self.llblock(target));\n                     }\n                     // Foreign functions\n@@ -333,6 +320,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                        debugloc)\n                         });\n                         if let Some((_, target)) = *destination {\n+                            for op in args {\n+                                self.set_operand_dropped(&bcx, op);\n+                            }\n                             funclet_br(bcx, self.llblock(target));\n                         }\n                     },\n@@ -388,7 +378,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let use_funclets = base::wants_msvc_seh(bcx.sess()) && data.is_cleanup;\n         let cleanup_pad = if use_funclets {\n             bcx.set_personality_fn(self.fcx.eh_personality());\n-            Some(bcx.cleanup_pad(None, &[]))\n+            bcx.at_start(|bcx| Some(bcx.cleanup_pad(None, &[])))\n         } else {\n             None\n         };\n@@ -416,7 +406,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         self.blocks[bb.index()].build()\n     }\n \n-    fn llblock(&self, bb: mir::BasicBlock) -> BasicBlockRef {\n+    pub fn llblock(&self, bb: mir::BasicBlock) -> BasicBlockRef {\n         self.blocks[bb.index()].llbb\n     }\n }"}, {"sha": "2e13abec5e36cca11e1705784a14e5b8b2245261", "filename": "src/librustc_trans/trans/mir/drop.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdrop.rs?ref=ba26efb60c9e11ab058a1c31b9816147c55ab417", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use llvm::ValueRef;\n+use rustc::middle::ty::Ty;\n+use trans::adt;\n+use trans::base;\n+use trans::common::{self, BlockAndBuilder};\n+use trans::machine;\n+use trans::type_of;\n+use trans::type_::Type;\n+\n+pub fn drop_fill<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>, value: ValueRef, ty: Ty<'tcx>) {\n+    let llty = type_of::type_of(bcx.ccx(), ty);\n+    let llptr = bcx.pointercast(value, Type::i8(bcx.ccx()).ptr_to());\n+    let filling = common::C_u8(bcx.ccx(), adt::DTOR_DONE);\n+    let size = machine::llsize_of(bcx.ccx(), llty);\n+    let align = common::C_u32(bcx.ccx(), machine::llalign_of_min(bcx.ccx(), llty));\n+    base::call_memset(&bcx, llptr, filling, size, align, false);\n+}"}, {"sha": "8d97708ca264919434c54069b5c1fc18e91ac5b0", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=ba26efb60c9e11ab058a1c31b9816147c55ab417", "patch": "@@ -17,6 +17,7 @@ use trans::base;\n use trans::common::{self, BlockAndBuilder};\n use trans::machine;\n use trans::type_of;\n+use trans::mir::drop;\n use llvm;\n use trans::Disr;\n \n@@ -48,6 +49,7 @@ impl<'tcx> LvalueRef<'tcx> {\n     {\n         assert!(!ty.has_erasable_regions());\n         let lltemp = bcx.with_block(|bcx| base::alloc_ty(bcx, ty, name));\n+        drop::drop_fill(bcx, lltemp, ty);\n         LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty))\n     }\n }"}, {"sha": "40dc22e31aa6c9a930fc005709156da7ccb5fb0e", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=ba26efb60c9e11ab058a1c31b9816147c55ab417", "patch": "@@ -197,6 +197,7 @@ mod analyze;\n mod block;\n mod constant;\n mod did;\n+mod drop;\n mod lvalue;\n mod operand;\n mod rvalue;"}, {"sha": "8343322d29da102d75b0592528610c6eb2044e3f", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=ba26efb60c9e11ab058a1c31b9816147c55ab417", "patch": "@@ -16,8 +16,9 @@ use trans::base;\n use trans::common::{self, Block, BlockAndBuilder};\n use trans::datum;\n use trans::Disr;\n+use trans::glue;\n \n-use super::{MirContext, TempRef};\n+use super::{MirContext, TempRef, drop};\n use super::lvalue::LvalueRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -158,31 +159,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n-    pub fn trans_operand_into(&mut self,\n-                              bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                              lldest: ValueRef,\n-                              operand: &mir::Operand<'tcx>)\n-    {\n-        debug!(\"trans_operand_into(lldest={}, operand={:?})\",\n-               bcx.val_to_string(lldest),\n-               operand);\n-\n-        // FIXME: consider not copying constants through the\n-        // stack.\n-\n-        let o = self.trans_operand(bcx, operand);\n-        self.store_operand(bcx, lldest, o);\n-    }\n-\n     pub fn store_operand(&mut self,\n                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                          lldest: ValueRef,\n                          operand: OperandRef<'tcx>)\n     {\n         debug!(\"store_operand: operand={}\", operand.repr(bcx));\n-        bcx.with_block(|bcx| {\n-            self.store_operand_direct(bcx, lldest, operand)\n-        })\n+        bcx.with_block(|bcx| self.store_operand_direct(bcx, lldest, operand))\n     }\n \n     pub fn store_operand_direct(&mut self,\n@@ -245,4 +228,30 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }), ty)\n         }).collect()\n     }\n+\n+    pub fn set_operand_dropped(&mut self,\n+                               bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                               operand: &mir::Operand<'tcx>) {\n+        match *operand {\n+            mir::Operand::Constant(_) => return,\n+            mir::Operand::Consume(ref lvalue) => {\n+                if let mir::Lvalue::Temp(idx) = *lvalue {\n+                    if let TempRef::Operand(..) = self.temps[idx as usize] {\n+                        // All lvalues which have an associated drop are promoted to an alloca\n+                        // beforehand. If this is an operand, it is safe to say this is never\n+                        // dropped and there\u2019s no reason for us to zero this out at all.\n+                        return\n+                    }\n+                }\n+                let lvalue = self.trans_lvalue(bcx, lvalue);\n+                let ty = lvalue.ty.to_ty(bcx.tcx());\n+                if !glue::type_needs_drop(bcx.tcx(), ty) ||\n+                    common::type_is_fat_ptr(bcx.tcx(), ty) {\n+                    return\n+                } else {\n+                    drop::drop_fill(bcx, lvalue.llval, ty);\n+                }\n+            }\n+        }\n+    }\n }"}, {"sha": "3911a29f034d1a747b991ed9007ea476bf9a3bfb", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=ba26efb60c9e11ab058a1c31b9816147c55ab417", "patch": "@@ -42,10 +42,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                rvalue);\n \n         match *rvalue {\n-            mir::Rvalue::Use(ref operand) => {\n-                self.trans_operand_into(&bcx, dest.llval, operand);\n-                bcx\n-            }\n+           mir::Rvalue::Use(ref operand) => {\n+               // FIXME: consider not copying constants through stack. (fixable by translating\n+               // constants into OperandValue::Ref, why don\u2019t we do that yet if we don\u2019t?)\n+               let tr_operand = self.trans_operand(&bcx, operand);\n+               self.store_operand(&bcx, dest.llval, tr_operand);\n+               self.set_operand_dropped(&bcx, operand);\n+               bcx\n+           }\n \n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, cast_ty) => {\n                 if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n@@ -89,15 +93,17 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n-                let elem = self.trans_operand(&bcx, elem);\n+                let tr_elem = self.trans_operand(&bcx, elem);\n                 let size = self.trans_constval(&bcx, &count.value, count.ty).immediate();\n-                bcx.map_block(|block| {\n+                let bcx = bcx.map_block(|block| {\n                     let base = expr::get_dataptr(block, dest.llval);\n-                    tvec::iter_vec_raw(block, base, elem.ty, size, |block, llslot, _| {\n-                        self.store_operand_direct(block, llslot, elem);\n+                    tvec::iter_vec_raw(block, base, tr_elem.ty, size, |block, llslot, _| {\n+                        self.store_operand_direct(block, llslot, tr_elem);\n                         block\n                     })\n-                })\n+                });\n+                self.set_operand_dropped(&bcx, elem);\n+                bcx\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n@@ -117,6 +123,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                     adt::trans_field_ptr(bcx, &repr, val, disr, i)\n                                 });\n                                 self.store_operand(&bcx, lldest_i, op);\n+                                self.set_operand_dropped(&bcx, operand);\n                             }\n                         }\n                     },\n@@ -130,6 +137,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 // not be structs but arrays.\n                                 let dest = bcx.gepi(dest.llval, &[0, i]);\n                                 self.store_operand(&bcx, dest, op);\n+                                self.set_operand_dropped(&bcx, operand);\n                             }\n                         }\n                     }\n@@ -179,11 +187,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n \n         match *rvalue {\n-            mir::Rvalue::Use(ref operand) => {\n-                let operand = self.trans_operand(&bcx, operand);\n-                (bcx, operand)\n-            }\n-\n             mir::Rvalue::Cast(ref kind, ref operand, cast_ty) => {\n                 let operand = self.trans_operand(&bcx, operand);\n                 debug!(\"cast operand is {}\", operand.repr(&bcx));\n@@ -426,6 +429,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 (bcx, operand)\n             }\n \n+            mir::Rvalue::Use(..) |\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) |\n             mir::Rvalue::Slice { .. } |\n@@ -543,14 +547,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n     match *rvalue {\n-        mir::Rvalue::Use(..) | // (*)\n         mir::Rvalue::Ref(..) |\n         mir::Rvalue::Len(..) |\n         mir::Rvalue::Cast(..) | // (*)\n         mir::Rvalue::BinaryOp(..) |\n         mir::Rvalue::UnaryOp(..) |\n         mir::Rvalue::Box(..) =>\n             true,\n+        mir::Rvalue::Use(..) | // (**)\n         mir::Rvalue::Repeat(..) |\n         mir::Rvalue::Aggregate(..) |\n         mir::Rvalue::Slice { .. } |\n@@ -559,4 +563,6 @@ pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n     }\n \n     // (*) this is only true if the type is suitable\n+    // (**) we need to zero-out the old value before moving, so we are restricted to either\n+    // ensuring all users of `Use` set it themselves or not allowing to \u201ccreate\u201d operand for it.\n }"}, {"sha": "91cf4aa1da9b0fadc25438c723ec26a246908d8b", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ba26efb60c9e11ab058a1c31b9816147c55ab417/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=ba26efb60c9e11ab058a1c31b9816147c55ab417", "patch": "@@ -1167,3 +1167,8 @@ LLVMRustBuildInvoke(LLVMBuilderRef B,\n     return LLVMBuildInvoke(B, Fn, Args, NumArgs, Then, Catch, Name);\n }\n #endif\n+\n+extern \"C\" void LLVMRustPositionBuilderAtStart(LLVMBuilderRef B, LLVMBasicBlockRef BB) {\n+    auto point = unwrap(BB)->getFirstInsertionPt();\n+    unwrap(B)->SetInsertPoint(unwrap(BB), point);\n+}"}]}