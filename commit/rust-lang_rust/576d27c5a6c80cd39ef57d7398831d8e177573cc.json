{"sha": "576d27c5a6c80cd39ef57d7398831d8e177573cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NmQyN2M1YTZjODBjZDM5ZWY1N2Q3Mzk4ODMxZDhlMTc3NTczY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-12T20:44:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-12T20:44:19Z"}, "message": "Auto merge of #75396 - RalfJung:miri-spans, r=oli-obk\n\nMiri: improve spans of required_const failures\n\nIn https://github.com/rust-lang/rust/pull/75339 I added a loop evaluating all consts required by a function body. Unfortunately, if one of their evaluations fails, then the span used for that was that of the first statement in the function body, which happened to work form some existing test but is not sensible in general.\n\nThis PR changes it to point to the whole function instead, which is at least not wrong.\n\nr? @oli-obk", "tree": {"sha": "1f0e3dcc72af97506603e0f7af42cff55b2e42e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f0e3dcc72af97506603e0f7af42cff55b2e42e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/576d27c5a6c80cd39ef57d7398831d8e177573cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/576d27c5a6c80cd39ef57d7398831d8e177573cc", "html_url": "https://github.com/rust-lang/rust/commit/576d27c5a6c80cd39ef57d7398831d8e177573cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/576d27c5a6c80cd39ef57d7398831d8e177573cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef1d58e7c90aa9885c906a6eb7398a2b6256d075", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef1d58e7c90aa9885c906a6eb7398a2b6256d075", "html_url": "https://github.com/rust-lang/rust/commit/ef1d58e7c90aa9885c906a6eb7398a2b6256d075"}, {"sha": "fd32fe9bb9cc97a5a3d97ab0f6ab673d8c81fa88", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd32fe9bb9cc97a5a3d97ab0f6ab673d8c81fa88", "html_url": "https://github.com/rust-lang/rust/commit/fd32fe9bb9cc97a5a3d97ab0f6ab673d8c81fa88"}], "stats": {"total": 125, "additions": 69, "deletions": 56}, "files": [{"sha": "2d0e68d58943fe56ff4b09db84cf39615135508f", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=576d27c5a6c80cd39ef57d7398831d8e177573cc", "patch": "@@ -301,12 +301,16 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Ok(())\n     }\n \n-    fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        // Enforce stack size limit.\n-        if !ecx.tcx.sess.recursion_limit().value_within_limit(ecx.stack().len()) {\n+    #[inline(always)]\n+    fn init_frame_extra(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        frame: Frame<'mir, 'tcx>,\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx>> {\n+        // Enforce stack size limit. Add 1 because this is run before the new frame is pushed.\n+        if !ecx.tcx.sess.recursion_limit().value_within_limit(ecx.stack().len() + 1) {\n             throw_exhaust!(StackFrameLimitReached)\n         } else {\n-            Ok(())\n+            Ok(frame)\n         }\n     }\n "}, {"sha": "525da87463a0e996475c291461b8de4612643e35", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=576d27c5a6c80cd39ef57d7398831d8e177573cc", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::ty::layout::{self, TyAndLayout};\n use rustc_middle::ty::{\n     self, query::TyCtxtAt, subst::SubstsRef, ParamEnv, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_span::{source_map::DUMMY_SP, Pos, Span};\n+use rustc_span::{Pos, Span};\n use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n \n use super::{\n@@ -83,9 +83,11 @@ pub struct Frame<'mir, 'tcx, Tag = (), Extra = ()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n-    /// If this is `None`, we are unwinding and this function doesn't need any clean-up.\n-    /// Just continue the same as with `Resume`.\n-    pub loc: Option<mir::Location>,\n+    /// If this is `Err`, we are not currently executing any particular statement in\n+    /// this frame (can happen e.g. during frame initialization, and during unwinding on\n+    /// frames without cleanup code).\n+    /// We basically abuse `Result` as `Either`.\n+    pub(super) loc: Result<mir::Location, Span>,\n }\n \n /// What we store about a frame in an interpreter backtrace.\n@@ -189,7 +191,14 @@ impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n impl<'mir, 'tcx, Tag, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n     /// Return the `SourceInfo` of the current instruction.\n     pub fn current_source_info(&self) -> Option<&mir::SourceInfo> {\n-        self.loc.map(|loc| self.body.source_info(loc))\n+        self.loc.ok().map(|loc| self.body.source_info(loc))\n+    }\n+\n+    pub fn current_span(&self) -> Span {\n+        match self.loc {\n+            Ok(loc) => self.body.source_info(loc).span,\n+            Err(span) => span,\n+        }\n     }\n }\n \n@@ -324,11 +333,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     #[inline(always)]\n     pub fn cur_span(&self) -> Span {\n-        self.stack()\n-            .last()\n-            .and_then(|f| f.current_source_info())\n-            .map(|si| si.span)\n-            .unwrap_or(self.tcx.span)\n+        self.stack().last().map(|f| f.current_span()).unwrap_or(self.tcx.span)\n     }\n \n     #[inline(always)]\n@@ -640,7 +645,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // first push a stack frame so we have access to the local substs\n         let pre_frame = Frame {\n             body,\n-            loc: Some(mir::Location::START),\n+            loc: Err(body.span), // Span used for errors caused during preamble.\n             return_to_block,\n             return_place,\n             // empty local array, we fill it in below, after we are inside the stack frame and\n@@ -654,9 +659,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         // Make sure all the constants required by this frame evaluate successfully (post-monomorphization check).\n         for const_ in &body.required_consts {\n+            let span = const_.span;\n             let const_ =\n                 self.subst_from_current_frame_and_normalize_erasing_regions(const_.literal);\n-            self.const_to_op(const_, None)?;\n+            self.const_to_op(const_, None).map_err(|err| {\n+                // If there was an error, set the span of the current frame to this constant.\n+                // Avoiding doing this when evaluation succeeds.\n+                self.frame_mut().loc = Err(span);\n+                err\n+            })?;\n         }\n \n         // Locals are initially uninitialized.\n@@ -683,8 +694,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         // done\n         self.frame_mut().locals = locals;\n-\n         M::after_stack_push(self)?;\n+        self.frame_mut().loc = Ok(mir::Location::START);\n         info!(\"ENTERING({}) {}\", self.frame_idx(), self.frame().instance);\n \n         Ok(())\n@@ -693,7 +704,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Jump to the given block.\n     #[inline]\n     pub fn go_to_block(&mut self, target: mir::BasicBlock) {\n-        self.frame_mut().loc = Some(mir::Location { block: target, statement_index: 0 });\n+        self.frame_mut().loc = Ok(mir::Location { block: target, statement_index: 0 });\n     }\n \n     /// *Return* to the given `target` basic block.\n@@ -715,7 +726,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// If `target` is `None`, that indicates the function does not need cleanup during\n     /// unwinding, and we will just keep propagating that upwards.\n     pub fn unwind_to_block(&mut self, target: Option<mir::BasicBlock>) {\n-        self.frame_mut().loc = target.map(|block| mir::Location { block, statement_index: 0 });\n+        self.frame_mut().loc = match target {\n+            Some(block) => Ok(mir::Location { block, statement_index: 0 }),\n+            None => Err(self.frame_mut().body.span),\n+        };\n     }\n \n     /// Pops the current frame from the stack, deallocating the\n@@ -743,8 +757,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert_eq!(\n             unwinding,\n             match self.frame().loc {\n-                None => true,\n-                Some(loc) => self.body().basic_blocks()[loc.block].is_cleanup,\n+                Ok(loc) => self.body().basic_blocks()[loc.block].is_cleanup,\n+                Err(_) => true,\n             }\n         );\n \n@@ -920,14 +934,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn generate_stacktrace(&self) -> Vec<FrameInfo<'tcx>> {\n         let mut frames = Vec::new();\n         for frame in self.stack().iter().rev() {\n-            let source_info = frame.current_source_info();\n-            let lint_root = source_info.and_then(|source_info| {\n+            let lint_root = frame.current_source_info().and_then(|source_info| {\n                 match &frame.body.source_scopes[source_info.scope].local_data {\n                     mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n                     mir::ClearCrossCrate::Clear => None,\n                 }\n             });\n-            let span = source_info.map_or(DUMMY_SP, |source_info| source_info.span);\n+            let span = frame.current_span();\n \n             frames.push(FrameInfo { span, instance: frame.instance, lint_root });\n         }"}, {"sha": "fb3a670714b58ad0298612dc5261383d64f27b79", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=576d27c5a6c80cd39ef57d7398831d8e177573cc", "patch": "@@ -30,8 +30,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Assert that there is always such a frame.\n             .unwrap();\n         // Assert that the frame we look at is actually executing code currently\n-        // (`current_source_info` is None when we are unwinding and the frame does\n-        // not require cleanup).\n+        // (`loc` is `Err` when we are unwinding and the frame does not require cleanup).\n         let loc = frame.loc.unwrap();\n         // If this is a `Call` terminator, use the `fn_span` instead.\n         let block = &frame.body.basic_blocks()[loc.block];"}, {"sha": "5cab4ba37e3a5be0e4e016c15cc088cbf93acff8", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=576d27c5a6c80cd39ef57d7398831d8e177573cc", "patch": "@@ -409,12 +409,4 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     ) -> Self::PointerTag {\n         ()\n     }\n-\n-    #[inline(always)]\n-    fn init_frame_extra(\n-        _ecx: &mut InterpCx<$mir, $tcx, Self>,\n-        frame: Frame<$mir, $tcx>,\n-    ) -> InterpResult<$tcx, Frame<$mir, $tcx>> {\n-        Ok(frame)\n-    }\n }"}, {"sha": "adecee3f7cb570e63aa420c5fa7adfd129105be3", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=576d27c5a6c80cd39ef57d7398831d8e177573cc", "patch": "@@ -47,8 +47,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n \n         let loc = match self.frame().loc {\n-            Some(loc) => loc,\n-            None => {\n+            Ok(loc) => loc,\n+            Err(_) => {\n                 // We are unwinding and this fn has no cleanup code.\n                 // Just go on unwinding.\n                 trace!(\"unwinding: skipping frame\");\n@@ -283,7 +283,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         self.eval_terminator(terminator)?;\n         if !self.stack().is_empty() {\n-            if let Some(loc) = self.frame().loc {\n+            if let Ok(loc) = self.frame().loc {\n                 info!(\"// executing {:?}\", loc.block);\n             }\n         }"}, {"sha": "3b39d5f66b78fa81d4135acbe070e785bcc1384a", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=576d27c5a6c80cd39ef57d7398831d8e177573cc", "patch": "@@ -281,6 +281,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         Ok(())\n     }\n \n+    #[inline(always)]\n+    fn init_frame_extra(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        frame: Frame<'mir, 'tcx>,\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx>> {\n+        Ok(frame)\n+    }\n+\n     #[inline(always)]\n     fn stack(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,"}, {"sha": "a0c91ff6b54f2be51998052b655fdb5c5e3de303", "filename": "src/test/ui/consts/const-err-multi.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Ftest%2Fui%2Fconsts%2Fconst-err-multi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Ftest%2Fui%2Fconsts%2Fconst-err-multi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err-multi.stderr?ref=576d27c5a6c80cd39ef57d7398831d8e177573cc", "patch": "@@ -24,17 +24,17 @@ error: any use of this value will cause an error\n   --> $DIR/const-err-multi.rs:7:19\n    |\n LL | pub const C: u8 = A as u8;\n-   | ------------------^^^^^^^-\n+   | ------------------^-------\n    |                   |\n    |                   referenced constant has errors\n \n error: any use of this value will cause an error\n-  --> $DIR/const-err-multi.rs:9:19\n+  --> $DIR/const-err-multi.rs:9:24\n    |\n LL | pub const D: i8 = 50 - A;\n-   | ------------------^^^^^^-\n-   |                   |\n-   |                   referenced constant has errors\n+   | -----------------------^-\n+   |                        |\n+   |                        referenced constant has errors\n \n error: aborting due to 4 previous errors\n "}, {"sha": "3df491bf229ff32db5dd525d914a9743ec82f6b4", "filename": "src/test/ui/consts/const-eval/erroneous-const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.rs?ref=576d27c5a6c80cd39ef57d7398831d8e177573cc", "patch": "@@ -8,8 +8,8 @@ impl<T> PrintName<T> {\n }\n \n const fn no_codegen<T>() {\n-    if false { //~ERROR evaluation of constant value failed\n-        let _ = PrintName::<T>::VOID;\n+    if false {\n+        let _ = PrintName::<T>::VOID; //~ERROR evaluation of constant value failed\n     }\n }\n "}, {"sha": "f06e2c33fd0cc194194a88c4d8114c10df05049b", "filename": "src/test/ui/consts/const-eval/erroneous-const.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.stderr?ref=576d27c5a6c80cd39ef57d7398831d8e177573cc", "patch": "@@ -25,12 +25,10 @@ LL | #![warn(const_err, unconditional_panic)]\n    |         ^^^^^^^^^\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/erroneous-const.rs:11:5\n+  --> $DIR/erroneous-const.rs:12:17\n    |\n-LL | /     if false {\n-LL | |         let _ = PrintName::<T>::VOID;\n-LL | |     }\n-   | |_____^ referenced constant has errors\n+LL |         let _ = PrintName::<T>::VOID;\n+   |                 ^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n \n error[E0080]: could not evaluate static initializer\n   --> $DIR/erroneous-const.rs:16:22"}, {"sha": "15436f9c1b2cfa0cd8ecf1e308396658cb14b984", "filename": "src/test/ui/consts/uninhabited-const-issue-61744.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs?ref=576d27c5a6c80cd39ef57d7398831d8e177573cc", "patch": "@@ -1,11 +1,11 @@\n // build-fail\n \n pub const unsafe fn fake_type<T>() -> T {\n-    hint_unreachable() //~ ERROR evaluation of constant value failed\n+    hint_unreachable()\n }\n \n pub const unsafe fn hint_unreachable() -> ! {\n-    fake_type()\n+    fake_type() //~ ERROR evaluation of constant value failed\n }\n \n trait Const {"}, {"sha": "024f9782d4a67efc627777fe110e9d83dba174e7", "filename": "src/test/ui/consts/uninhabited-const-issue-61744.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576d27c5a6c80cd39ef57d7398831d8e177573cc/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr?ref=576d27c5a6c80cd39ef57d7398831d8e177573cc", "patch": "@@ -1,11 +1,9 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/uninhabited-const-issue-61744.rs:4:5\n+  --> $DIR/uninhabited-const-issue-61744.rs:8:5\n    |\n LL |     hint_unreachable()\n-   |     ^^^^^^^^^^^^^^^^^^\n+   |     ------------------\n    |     |\n-   |     reached the configured maximum number of stack frames\n-   |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n    |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n    |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n    |     inside `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n@@ -72,8 +70,9 @@ LL |     hint_unreachable()\n    |     inside `fake_type::<i32>` at $DIR/uninhabited-const-issue-61744.rs:4:5\n ...\n LL |     fake_type()\n-   |     -----------\n+   |     ^^^^^^^^^^^\n    |     |\n+   |     reached the configured maximum number of stack frames\n    |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n    |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5\n    |     inside `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:8:5"}]}