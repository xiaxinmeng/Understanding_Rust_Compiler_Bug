{"sha": "5e8ba7252a162fc6a3c5186904947f5969d732af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlOGJhNzI1MmExNjJmYzZhM2M1MTg2OTA0OTQ3ZjU5NjlkNzMyYWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-30T02:42:19Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-03T17:32:34Z"}, "message": "rustc: Remove io_error usage", "tree": {"sha": "ac0c301fa541f99f82d582a3a4c879fa8f93e4d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac0c301fa541f99f82d582a3a4c879fa8f93e4d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e8ba7252a162fc6a3c5186904947f5969d732af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8ba7252a162fc6a3c5186904947f5969d732af", "html_url": "https://github.com/rust-lang/rust/commit/5e8ba7252a162fc6a3c5186904947f5969d732af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e8ba7252a162fc6a3c5186904947f5969d732af/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b211b00d21fc7c03c3c378ad5eab60666a00fc08", "url": "https://api.github.com/repos/rust-lang/rust/commits/b211b00d21fc7c03c3c378ad5eab60666a00fc08", "html_url": "https://github.com/rust-lang/rust/commit/b211b00d21fc7c03c3c378ad5eab60666a00fc08"}], "stats": {"total": 353, "additions": 200, "deletions": 153}, "files": [{"sha": "18aef17b9eb77031b3ff9cdfe745b236c98b1643", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=5e8ba7252a162fc6a3c5186904947f5969d732af", "patch": "@@ -17,6 +17,7 @@ use lib::llvm::{ArchiveRef, llvm};\n \n use std::cast;\n use std::io::fs;\n+use std::io;\n use std::libc;\n use std::os;\n use std::run::{ProcessOptions, Process, ProcessOutput};\n@@ -50,9 +51,8 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n         Some(p) => { debug!(\"inside {}\", p.display()); }\n         None => {}\n     }\n-    let mut opt_prog = Process::new(ar, args.as_slice(), opts);\n-    match opt_prog {\n-        Some(ref mut prog) => {\n+    match Process::new(ar, args.as_slice(), opts) {\n+        Ok(mut prog) => {\n             let o = prog.finish_with_output();\n             if !o.status.success() {\n                 sess.err(format!(\"{} {} failed with: {}\", ar, args.connect(\" \"),\n@@ -63,8 +63,8 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n             }\n             o\n         },\n-        None => {\n-            sess.err(format!(\"could not exec `{}`\", ar));\n+        Err(e) => {\n+            sess.err(format!(\"could not exec `{}`: {}\", ar, e));\n             sess.abort_if_errors();\n             fail!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n@@ -94,32 +94,33 @@ impl Archive {\n             let archive = os::make_absolute(&self.dst);\n             run_ar(self.sess, \"x\", Some(loc.path()), [&archive,\n                                                       &Path::new(file)]);\n-            fs::File::open(&loc.path().join(file)).read_to_end()\n+            fs::File::open(&loc.path().join(file)).read_to_end().unwrap()\n         } else {\n             run_ar(self.sess, \"p\", None, [&self.dst, &Path::new(file)]).output\n         }\n     }\n \n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n-    pub fn add_native_library(&mut self, name: &str) {\n+    pub fn add_native_library(&mut self, name: &str) -> io::IoResult<()> {\n         let location = self.find_library(name);\n-        self.add_archive(&location, name, []);\n+        self.add_archive(&location, name, [])\n     }\n \n     /// Adds all of the contents of the rlib at the specified path to this\n     /// archive.\n     ///\n     /// This ignores adding the bytecode from the rlib, and if LTO is enabled\n     /// then the object file also isn't added.\n-    pub fn add_rlib(&mut self, rlib: &Path, name: &str, lto: bool) {\n+    pub fn add_rlib(&mut self, rlib: &Path, name: &str,\n+                    lto: bool) -> io::IoResult<()> {\n         let object = format!(\"{}.o\", name);\n         let bytecode = format!(\"{}.bc\", name);\n         let mut ignore = ~[METADATA_FILENAME, bytecode.as_slice()];\n         if lto {\n             ignore.push(object.as_slice());\n         }\n-        self.add_archive(rlib, name, ignore);\n+        self.add_archive(rlib, name, ignore)\n     }\n \n     /// Adds an arbitrary file to this archive\n@@ -144,7 +145,8 @@ impl Archive {\n         str::from_utf8(output.output).unwrap().lines().map(|s| s.to_owned()).collect()\n     }\n \n-    fn add_archive(&mut self, archive: &Path, name: &str, skip: &[&str]) {\n+    fn add_archive(&mut self, archive: &Path, name: &str,\n+                   skip: &[&str]) -> io::IoResult<()> {\n         let loc = TempDir::new(\"rsar\").unwrap();\n \n         // First, extract the contents of the archive to a temporary directory\n@@ -159,7 +161,7 @@ impl Archive {\n         // We skip any files explicitly desired for skipping, and we also skip\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n-        let files = fs::readdir(loc.path());\n+        let files = if_ok!(fs::readdir(loc.path()));\n         let mut inputs = ~[];\n         for file in files.iter() {\n             let filename = file.filename_str().unwrap();\n@@ -168,14 +170,15 @@ impl Archive {\n \n             let filename = format!(\"r-{}-{}\", name, filename);\n             let new_filename = file.with_filename(filename);\n-            fs::rename(file, &new_filename);\n+            if_ok!(fs::rename(file, &new_filename));\n             inputs.push(new_filename);\n         }\n \n         // Finally, add all the renamed files to this archive\n         let mut args = ~[&self.dst];\n         args.extend(&mut inputs.iter());\n         run_ar(self.sess, \"r\", None, args.as_slice());\n+        Ok(())\n     }\n \n     fn find_library(&self, name: &str) -> Path {"}, {"sha": "4d6576fed3462290ffb48d805706638239a7a1c2", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 53, "deletions": 33, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=5e8ba7252a162fc6a3c5186904947f5969d732af", "patch": "@@ -100,7 +100,6 @@ pub mod write {\n     use util::common::time;\n \n     use std::c_str::ToCStr;\n-    use std::io;\n     use std::libc::{c_uint, c_int};\n     use std::path::Path;\n     use std::run;\n@@ -297,21 +296,17 @@ pub mod write {\n             assembly.as_str().unwrap().to_owned()];\n \n         debug!(\"{} '{}'\", cc, args.connect(\"' '\"));\n-        let opt_prog = {\n-            let _guard = io::ignore_io_error();\n-            run::process_output(cc, args)\n-        };\n-        match opt_prog {\n-            Some(prog) => {\n+        match run::process_output(cc, args) {\n+            Ok(prog) => {\n                 if !prog.status.success() {\n                     sess.err(format!(\"linking with `{}` failed: {}\", cc, prog.status));\n                     sess.note(format!(\"{} arguments: '{}'\", cc, args.connect(\"' '\")));\n                     sess.note(str::from_utf8_owned(prog.error + prog.output).unwrap());\n                     sess.abort_if_errors();\n                 }\n             },\n-            None => {\n-                sess.err(format!(\"could not exec the linker `{}`\", cc));\n+            Err(e) => {\n+                sess.err(format!(\"could not exec the linker `{}`: {}\", cc, e));\n                 sess.abort_if_errors();\n             }\n         }\n@@ -768,6 +763,15 @@ fn get_system_tool(sess: Session, tool: &str) -> ~str {\n     }\n }\n \n+fn remove(sess: Session, path: &Path) {\n+    match fs::unlink(path) {\n+        Ok(..) => {}\n+        Err(e) => {\n+            sess.err(format!(\"failed to remove {}: {}\", path.display(), e));\n+        }\n+    }\n+}\n+\n /// Perform the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n pub fn link_binary(sess: Session,\n@@ -785,17 +789,15 @@ pub fn link_binary(sess: Session,\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.save_temps {\n-        fs::unlink(obj_filename);\n-        fs::unlink(&obj_filename.with_extension(\"metadata.o\"));\n+        remove(sess, obj_filename);\n+        remove(sess, &obj_filename.with_extension(\"metadata.o\"));\n     }\n \n     out_filenames\n }\n \n fn is_writeable(p: &Path) -> bool {\n-    use std::io;\n-\n-    match io::result(|| p.stat()) {\n+    match p.stat() {\n         Err(..) => true,\n         Ok(m) => m.perm & io::UserWrite == io::UserWrite\n     }\n@@ -884,7 +886,7 @@ fn link_rlib(sess: Session,\n     for &(ref l, kind) in used_libraries.get().iter() {\n         match kind {\n             cstore::NativeStatic => {\n-                a.add_native_library(l.as_slice());\n+                a.add_native_library(l.as_slice()).unwrap();\n             }\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n@@ -919,16 +921,23 @@ fn link_rlib(sess: Session,\n             // the same filename for metadata (stomping over one another)\n             let tmpdir = TempDir::new(\"rustc\").expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n-            fs::File::create(&metadata).write(trans.metadata);\n+            match fs::File::create(&metadata).write(trans.metadata) {\n+                Ok(..) => {}\n+                Err(e) => {\n+                    sess.err(format!(\"failed to write {}: {}\",\n+                                     metadata.display(), e));\n+                    sess.abort_if_errors();\n+                }\n+            }\n             a.add_file(&metadata, false);\n-            fs::unlink(&metadata);\n+            remove(sess, &metadata);\n \n             // For LTO purposes, the bytecode of this library is also inserted\n             // into the archive.\n             let bc = obj_filename.with_extension(\"bc\");\n             a.add_file(&bc, false);\n             if !sess.opts.save_temps {\n-                fs::unlink(&bc);\n+                remove(sess, &bc);\n             }\n \n             // After adding all files to the archive, we need to update the\n@@ -959,7 +968,7 @@ fn link_rlib(sess: Session,\n // metadata file).\n fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n     let mut a = link_rlib(sess, None, obj_filename, out_filename);\n-    a.add_native_library(\"morestack\");\n+    a.add_native_library(\"morestack\").unwrap();\n \n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     for &(cnum, ref path) in crates.iter() {\n@@ -970,7 +979,7 @@ fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n                 continue\n             }\n         };\n-        a.add_rlib(&p, name, sess.lto());\n+        a.add_rlib(&p, name, sess.lto()).unwrap();\n         let native_libs = csearch::get_native_libraries(sess.cstore, cnum);\n         for &(kind, ref lib) in native_libs.iter() {\n             let name = match kind {\n@@ -1004,23 +1013,19 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n \n     // Invoke the system linker\n     debug!(\"{} {}\", cc_prog, cc_args.connect(\" \"));\n-    let opt_prog = {\n-        let _guard = io::ignore_io_error();\n-        time(sess.time_passes(), \"running linker\", (), |()|\n-             run::process_output(cc_prog, cc_args))\n-    };\n-\n-    match opt_prog {\n-        Some(prog) => {\n+    let prog = time(sess.time_passes(), \"running linker\", (), |()|\n+                    run::process_output(cc_prog, cc_args));\n+    match prog {\n+        Ok(prog) => {\n             if !prog.status.success() {\n                 sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n                 sess.note(format!(\"{} arguments: '{}'\", cc_prog, cc_args.connect(\"' '\")));\n                 sess.note(str::from_utf8_owned(prog.error + prog.output).unwrap());\n                 sess.abort_if_errors();\n             }\n         },\n-        None => {\n-            sess.err(format!(\"could not exec the linker `{}`\", cc_prog));\n+        Err(e) => {\n+            sess.err(format!(\"could not exec the linker `{}`: {}\", cc_prog, e));\n             sess.abort_if_errors();\n         }\n     }\n@@ -1030,8 +1035,14 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n     // the symbols\n     if sess.targ_cfg.os == abi::OsMacos && sess.opts.debuginfo {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        run::process_status(\"dsymutil\",\n-                            [out_filename.as_str().unwrap().to_owned()]);\n+        match run::process_status(\"dsymutil\",\n+                                  [out_filename.as_str().unwrap().to_owned()]) {\n+            Ok(..) => {}\n+            Err(e) => {\n+                sess.err(format!(\"failed to run dsymutil: {}\", e));\n+                sess.abort_if_errors();\n+            }\n+        }\n     }\n }\n \n@@ -1225,7 +1236,16 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n                     time(sess.time_passes(), format!(\"altering {}.rlib\", name),\n                          (), |()| {\n                         let dst = tmpdir.join(cratepath.filename().unwrap());\n-                        fs::copy(&cratepath, &dst);\n+                        match fs::copy(&cratepath, &dst) {\n+                            Ok(..) => {}\n+                            Err(e) => {\n+                                sess.err(format!(\"failed to copy {} to {}: {}\",\n+                                                 cratepath.display(),\n+                                                 dst.display(),\n+                                                 e));\n+                                sess.abort_if_errors();\n+                            }\n+                        }\n                         let dst_str = dst.as_str().unwrap().to_owned();\n                         let mut archive = Archive::open(sess, dst);\n                         archive.remove_file(format!(\"{}.o\", name));"}, {"sha": "a61c297956d78aedaac0c01d468d0c96c6e5b923", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 50, "deletions": 39, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=5e8ba7252a162fc6a3c5186904947f5969d732af", "patch": "@@ -399,7 +399,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n \n         // Remove assembly source, unless --save-temps was specified\n         if !sess.opts.save_temps {\n-            fs::unlink(&asm_filename);\n+            fs::unlink(&asm_filename).unwrap();\n         }\n     } else {\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n@@ -455,33 +455,39 @@ pub fn stop_after_phase_5(sess: Session) -> bool {\n     return false;\n }\n \n-fn write_out_deps(sess: Session, input: &Input, outputs: &OutputFilenames, crate: &ast::Crate)\n+fn write_out_deps(sess: Session, input: &Input, outputs: &OutputFilenames,\n+                  crate: &ast::Crate) -> io::IoResult<()>\n {\n     let lm = link::build_link_meta(sess, crate.attrs, &outputs.obj_filename,\n-                                       &mut ::util::sha2::Sha256::new());\n+                                   &mut ::util::sha2::Sha256::new());\n \n     let sess_outputs = sess.outputs.borrow();\n     let out_filenames = sess_outputs.get().iter()\n-        .map(|&output| link::filename_for_input(&sess, output, &lm, &outputs.out_filename))\n+        .map(|&output| link::filename_for_input(&sess, output, &lm,\n+                                                &outputs.out_filename))\n         .to_owned_vec();\n \n-    // Write out dependency rules to the dep-info file if requested with --dep-info\n+    // Write out dependency rules to the dep-info file if requested with\n+    // --dep-info\n     let deps_filename = match sess.opts.write_dependency_info {\n         // Use filename from --dep-file argument if given\n         (true, Some(ref filename)) => filename.clone(),\n-        // Use default filename: crate source filename with extension replaced by \".d\"\n+        // Use default filename: crate source filename with extension replaced\n+        // by \".d\"\n         (true, None) => match *input {\n             FileInput(ref input_path) => {\n-                let filestem = input_path.filestem().expect(\"input file must have stem\");\n-                let filename = out_filenames[0].dir_path().join(filestem).with_extension(\"d\");\n-                filename\n+                let filestem = input_path.filestem().expect(\"input file must \\\n+                                                             have stem\");\n+                let filename = out_filenames[0].dir_path().join(filestem);\n+                filename.with_extension(\"d\")\n             },\n             StrInput(..) => {\n-                sess.warn(\"can not write --dep-info without a filename when compiling stdin.\");\n-                return;\n+                sess.warn(\"can not write --dep-info without a filename \\\n+                           when compiling stdin.\");\n+                return Ok(());\n             },\n         },\n-        _ => return,\n+        _ => return Ok(()),\n     };\n \n     // Build a list of files used to compile the output and\n@@ -499,11 +505,12 @@ fn write_out_deps(sess: Session, input: &Input, outputs: &OutputFilenames, crate\n              })\n              .collect()\n     };\n-    let mut file = io::File::create(&deps_filename);\n+    let mut file = if_ok!(io::File::create(&deps_filename));\n     for path in out_filenames.iter() {\n-        write!(&mut file as &mut Writer,\n-               \"{}: {}\\n\\n\", path.display(), files.connect(\" \"));\n+        if_ok!(write!(&mut file as &mut Writer,\n+                      \"{}: {}\\n\\n\", path.display(), files.connect(\" \")));\n     }\n+    Ok(())\n }\n \n pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &Input,\n@@ -521,7 +528,7 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &Input,\n         let outputs = build_output_filenames(input, outdir, output,\n                                              expanded_crate.attrs, sess);\n \n-        write_out_deps(sess, input, outputs, &expanded_crate);\n+        write_out_deps(sess, input, outputs, &expanded_crate).unwrap();\n \n         if stop_after_phase_2(sess) { return; }\n \n@@ -541,32 +548,33 @@ struct IdentifiedAnnotation {\n }\n \n impl pprust::PpAnn for IdentifiedAnnotation {\n-    fn pre(&self, node: pprust::AnnNode) {\n+    fn pre(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n         match node {\n             pprust::NodeExpr(s, _) => pprust::popen(s),\n-            _ => ()\n+            _ => Ok(())\n         }\n     }\n-    fn post(&self, node: pprust::AnnNode) {\n+    fn post(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n         match node {\n             pprust::NodeItem(s, item) => {\n-                pp::space(&mut s.s);\n-                pprust::synth_comment(s, item.id.to_str());\n+                if_ok!(pp::space(&mut s.s));\n+                if_ok!(pprust::synth_comment(s, item.id.to_str()));\n             }\n             pprust::NodeBlock(s, blk) => {\n-                pp::space(&mut s.s);\n-                pprust::synth_comment(s, ~\"block \" + blk.id.to_str());\n+                if_ok!(pp::space(&mut s.s));\n+                if_ok!(pprust::synth_comment(s, ~\"block \" + blk.id.to_str()));\n             }\n             pprust::NodeExpr(s, expr) => {\n-                pp::space(&mut s.s);\n-                pprust::synth_comment(s, expr.id.to_str());\n-                pprust::pclose(s);\n+                if_ok!(pp::space(&mut s.s));\n+                if_ok!(pprust::synth_comment(s, expr.id.to_str()));\n+                if_ok!(pprust::pclose(s));\n             }\n             pprust::NodePat(s, pat) => {\n-                pp::space(&mut s.s);\n-                pprust::synth_comment(s, ~\"pat \" + pat.id.to_str());\n+                if_ok!(pp::space(&mut s.s));\n+                if_ok!(pprust::synth_comment(s, ~\"pat \" + pat.id.to_str()));\n             }\n         }\n+        Ok(())\n     }\n }\n \n@@ -575,24 +583,26 @@ struct TypedAnnotation {\n }\n \n impl pprust::PpAnn for TypedAnnotation {\n-    fn pre(&self, node: pprust::AnnNode) {\n+    fn pre(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n         match node {\n             pprust::NodeExpr(s, _) => pprust::popen(s),\n-            _ => ()\n+            _ => Ok(())\n         }\n     }\n-    fn post(&self, node: pprust::AnnNode) {\n+    fn post(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n         let tcx = self.analysis.ty_cx;\n         match node {\n             pprust::NodeExpr(s, expr) => {\n-                pp::space(&mut s.s);\n-                pp::word(&mut s.s, \"as\");\n-                pp::space(&mut s.s);\n-                pp::word(&mut s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n-                pprust::pclose(s);\n+                if_ok!(pp::space(&mut s.s));\n+                if_ok!(pp::word(&mut s.s, \"as\"));\n+                if_ok!(pp::space(&mut s.s));\n+                if_ok!(pp::word(&mut s.s,\n+                                ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr))));\n+                if_ok!(pprust::pclose(s));\n             }\n             _ => ()\n         }\n+        Ok(())\n     }\n }\n \n@@ -638,7 +648,7 @@ pub fn pretty_print_input(sess: Session,\n                         &mut rdr,\n                         ~stdout as ~io::Writer,\n                         annotation,\n-                        is_expanded);\n+                        is_expanded).unwrap();\n }\n \n pub fn get_os(triple: &str) -> Option<abi::Os> {\n@@ -1167,10 +1177,11 @@ pub fn early_error(emitter: &diagnostic::Emitter, msg: &str) -> ! {\n     fail!(diagnostic::FatalError);\n }\n \n-pub fn list_metadata(sess: Session, path: &Path, out: &mut io::Writer) {\n+pub fn list_metadata(sess: Session, path: &Path,\n+                     out: &mut io::Writer) -> io::IoResult<()> {\n     metadata::loader::list_file_metadata(\n         token::get_ident_interner(),\n-        session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);\n+        session::sess_os_to_meta_os(sess.targ_cfg.os), path, out)\n }\n \n #[cfg(test)]"}, {"sha": "ef0464197897aabbb83fad2a9ab38b32f0c6ae7d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=5e8ba7252a162fc6a3c5186904947f5969d732af", "patch": "@@ -54,6 +54,11 @@ use syntax::diagnostic::Emitter;\n use syntax::diagnostic;\n use syntax::parse;\n \n+#[cfg(stage0)]\n+macro_rules! if_ok (\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+)\n+\n pub mod middle {\n     pub mod trans;\n     pub mod ty;\n@@ -267,7 +272,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n           d::FileInput(ref ifile) => {\n             let mut stdout = io::stdout();\n             d::list_metadata(sess, &(*ifile),\n-                                  &mut stdout as &mut io::Writer);\n+                             &mut stdout as &mut io::Writer).unwrap();\n           }\n           d::StrInput(_) => {\n             d::early_error(demitter, \"can not list metadata for stdin\");"}, {"sha": "824d0efff259fff9dbfd6e99a15f3190a2b0f461", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5e8ba7252a162fc6a3c5186904947f5969d732af", "patch": "@@ -1111,15 +1111,15 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n }\n \n fn list_crate_attributes(intr: @IdentInterner, md: ebml::Doc, hash: &str,\n-                         out: &mut io::Writer) {\n-    write!(out, \"=Crate Attributes ({})=\\n\", hash);\n+                         out: &mut io::Writer) -> io::IoResult<()> {\n+    if_ok!(write!(out, \"=Crate Attributes ({})=\\n\", hash));\n \n     let r = get_attributes(md);\n     for attr in r.iter() {\n-        write!(out, \"{}\\n\", pprust::attribute_to_str(attr, intr));\n+        if_ok!(write!(out, \"{}\\n\", pprust::attribute_to_str(attr, intr)));\n     }\n \n-    write!(out, \"\\n\\n\");\n+    write!(out, \"\\n\\n\")\n }\n \n pub fn get_crate_attributes(data: &[u8]) -> ~[ast::Attribute] {\n@@ -1154,8 +1154,8 @@ pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n     return deps;\n }\n \n-fn list_crate_deps(data: &[u8], out: &mut io::Writer) {\n-    write!(out, \"=External Dependencies=\\n\");\n+fn list_crate_deps(data: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n+    if_ok!(write!(out, \"=External Dependencies=\\n\"));\n \n     let r = get_crate_deps(data);\n     for dep in r.iter() {\n@@ -1168,7 +1168,8 @@ fn list_crate_deps(data: &[u8], out: &mut io::Writer) {\n                dep.vers);\n     }\n \n-    write!(out, \"\\n\");\n+    if_ok!(write!(out, \"\\n\"));\n+    Ok(())\n }\n \n pub fn get_crate_hash(data: &[u8]) -> ~str {\n@@ -1186,11 +1187,11 @@ pub fn get_crate_vers(data: &[u8]) -> ~str {\n }\n \n pub fn list_crate_metadata(intr: @IdentInterner, bytes: &[u8],\n-                           out: &mut io::Writer) {\n+                           out: &mut io::Writer) -> io::IoResult<()> {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n-    list_crate_attributes(intr, md, hash, out);\n-    list_crate_deps(bytes, out);\n+    if_ok!(list_crate_attributes(intr, md, hash, out));\n+    list_crate_deps(bytes, out)\n }\n \n // Translates a def_id from an external crate to a def_id for the current"}, {"sha": "d56d211b713ee9c3ce82acd392d3a591833cd1ae", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5e8ba7252a162fc6a3c5186904947f5969d732af", "patch": "@@ -10,6 +10,7 @@\n \n // Metadata encoding\n \n+#[allow(unused_must_use)]; // everything is just a MemWriter, can't fail\n \n use metadata::common::*;\n use metadata::cstore;\n@@ -350,7 +351,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n             let mut index = index.borrow_mut();\n             index.get().push(entry {\n                 val: variant.node.id as i64,\n-                pos: ebml_w.writer.tell(),\n+                pos: ebml_w.writer.tell().unwrap(),\n             });\n         }\n         ebml_w.start_tag(tag_items_data_item);\n@@ -668,10 +669,10 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::Explic\n \n     // Encode the base self type.\n     match explicit_self {\n-        SelfStatic => ebml_w.writer.write(&[ 's' as u8 ]),\n-        SelfValue  => ebml_w.writer.write(&[ 'v' as u8 ]),\n-        SelfBox    => ebml_w.writer.write(&[ '@' as u8 ]),\n-        SelfUniq   => ebml_w.writer.write(&[ '~' as u8 ]),\n+        SelfStatic => { ebml_w.writer.write(&[ 's' as u8 ]); }\n+        SelfValue  => { ebml_w.writer.write(&[ 'v' as u8 ]); }\n+        SelfBox    => { ebml_w.writer.write(&[ '@' as u8 ]); }\n+        SelfUniq   => { ebml_w.writer.write(&[ '~' as u8 ]); }\n         SelfRegion(_, m) => {\n             // FIXME(#4846) encode custom lifetime\n             ebml_w.writer.write(&['&' as u8]);\n@@ -684,8 +685,8 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::Explic\n     fn encode_mutability(ebml_w: &writer::Encoder,\n                          m: ast::Mutability) {\n         match m {\n-            MutImmutable => ebml_w.writer.write(&[ 'i' as u8 ]),\n-            MutMutable => ebml_w.writer.write(&[ 'm' as u8 ]),\n+            MutImmutable => { ebml_w.writer.write(&[ 'i' as u8 ]); }\n+            MutMutable => { ebml_w.writer.write(&[ 'm' as u8 ]); }\n         }\n     }\n }\n@@ -726,12 +727,12 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         };\n \n         let id = field.node.id;\n-        index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n+        index.push(entry {val: id as i64, pos: ebml_w.writer.tell().unwrap()});\n         {\n             let mut global_index = global_index.borrow_mut();\n             global_index.get().push(entry {\n                 val: id as i64,\n-                pos: ebml_w.writer.tell(),\n+                pos: ebml_w.writer.tell().unwrap(),\n             });\n         }\n         ebml_w.start_tag(tag_items_data_item);\n@@ -758,7 +759,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n         let mut index = index.borrow_mut();\n         index.get().push(entry {\n             val: ctor_id as i64,\n-            pos: ebml_w.writer.tell(),\n+            pos: ebml_w.writer.tell().unwrap(),\n         });\n     }\n \n@@ -921,7 +922,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let mut index = index.borrow_mut();\n         index.get().push(entry {\n             val: item.id as i64,\n-            pos: ebml_w.writer.tell(),\n+            pos: ebml_w.writer.tell().unwrap(),\n         });\n     }\n     let add_to_index: || = || add_to_index(item, ebml_w, index);\n@@ -1157,7 +1158,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 let mut index = index.borrow_mut();\n                 index.get().push(entry {\n                     val: m.def_id.node as i64,\n-                    pos: ebml_w.writer.tell(),\n+                    pos: ebml_w.writer.tell().unwrap(),\n                 });\n             }\n             encode_info_for_method(ecx,\n@@ -1219,7 +1220,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 let mut index = index.borrow_mut();\n                 index.get().push(entry {\n                     val: method_def_id.node as i64,\n-                    pos: ebml_w.writer.tell(),\n+                    pos: ebml_w.writer.tell().unwrap(),\n                 });\n             }\n \n@@ -1294,7 +1295,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         let mut index = index.borrow_mut();\n         index.get().push(entry {\n             val: nitem.id as i64,\n-            pos: ebml_w.writer.tell(),\n+            pos: ebml_w.writer.tell().unwrap(),\n         });\n     }\n \n@@ -1418,7 +1419,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n         let mut index = index.borrow_mut();\n         index.get().push(entry {\n             val: CRATE_NODE_ID as i64,\n-            pos: ebml_w.writer.tell(),\n+            pos: ebml_w.writer.tell().unwrap(),\n         });\n     }\n     encode_info_for_mod(ecx,\n@@ -1478,7 +1479,7 @@ fn encode_index<T:'static>(\n     let mut bucket_locs = ~[];\n     ebml_w.start_tag(tag_index_buckets);\n     for bucket in buckets.iter() {\n-        bucket_locs.push(ebml_w.writer.tell());\n+        bucket_locs.push(ebml_w.writer.tell().unwrap());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n         for elt in (**bucket).iter() {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n@@ -1895,58 +1896,58 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, crate: &Crate)\n \n     encode_hash(&mut ebml_w, ecx.link_meta.crate_hash);\n \n-    let mut i = ebml_w.writer.tell();\n+    let mut i = ebml_w.writer.tell().unwrap();\n     let crate_attrs = synthesize_crate_attrs(&ecx, crate);\n     encode_attributes(&mut ebml_w, crate_attrs);\n-    ecx.stats.attr_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.attr_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_crate_deps(&ecx, &mut ebml_w, ecx.cstore);\n-    ecx.stats.dep_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.dep_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode the language items.\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_lang_items(&ecx, &mut ebml_w);\n-    ecx.stats.lang_item_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.lang_item_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode the native libraries used\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_native_libraries(&ecx, &mut ebml_w);\n-    ecx.stats.native_lib_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.native_lib_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode the macro registrar function\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_macro_registrar_fn(&ecx, &mut ebml_w);\n-    ecx.stats.macro_registrar_fn_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.macro_registrar_fn_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode macro definitions\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_macro_defs(&ecx, crate, &mut ebml_w);\n-    ecx.stats.macro_defs_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.macro_defs_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode the def IDs of impls, for coherence checking.\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_impls(&ecx, crate, &mut ebml_w);\n-    ecx.stats.impl_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.impl_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode miscellaneous info.\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_misc_info(&ecx, crate, &mut ebml_w);\n-    ecx.stats.misc_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.misc_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     let items_index = encode_info_for_items(&ecx, &mut ebml_w, crate);\n-    ecx.stats.item_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.item_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     let items_buckets = create_index(items_index);\n     encode_index(&mut ebml_w, items_buckets, write_i64);\n-    ecx.stats.index_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.index_bytes.set(ebml_w.writer.tell().unwrap() - i);\n     ebml_w.end_tag();\n \n-    ecx.stats.total_bytes.set(ebml_w.writer.tell());\n+    ecx.stats.total_bytes.set(ebml_w.writer.tell().unwrap());\n \n     if tcx.sess.meta_stats() {\n         for e in ebml_w.writer.get_ref().iter() {"}, {"sha": "7e04a36ee2e0878854b1aac29d95394a1bea5e96", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=5e8ba7252a162fc6a3c5186904947f5969d732af", "patch": "@@ -11,7 +11,6 @@\n use std::cell::RefCell;\n use std::option;\n use std::os;\n-use std::io;\n use std::io::fs;\n use std::hashmap::HashSet;\n \n@@ -93,7 +92,7 @@ impl FileSearch {\n     pub fn search(&self, pick: pick) {\n         self.for_each_lib_search_path(|lib_search_path| {\n             debug!(\"searching {}\", lib_search_path.display());\n-            match io::result(|| fs::readdir(lib_search_path)) {\n+            match fs::readdir(lib_search_path) {\n                 Ok(files) => {\n                     let mut rslt = FileDoesntMatch;\n                     let is_rlib = |p: & &Path| {\n@@ -163,16 +162,16 @@ pub fn get_or_default_sysroot() -> Path {\n     // Follow symlinks.  If the resolved path is relative, make it absolute.\n     fn canonicalize(path: Option<Path>) -> Option<Path> {\n         path.and_then(|mut path|\n-            match io::io_error::cond.trap(|_| ()).inside(|| fs::readlink(&path)) {\n-                Some(canon) => {\n+            match fs::readlink(&path) {\n+                Ok(canon) => {\n                     if canon.is_absolute() {\n                         Some(canon)\n                     } else {\n                         path.pop();\n                         Some(path.join(canon))\n                     }\n                 },\n-                None => Some(path),\n+                Err(..) => Some(path),\n             })\n     }\n "}, {"sha": "abcd650ced13152712cbe2a1a2c73b675c1a619e", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=5e8ba7252a162fc6a3c5186904947f5969d732af", "patch": "@@ -381,13 +381,13 @@ pub fn read_meta_section_name(os: Os) -> &'static str {\n pub fn list_file_metadata(intr: @IdentInterner,\n                           os: Os,\n                           path: &Path,\n-                          out: &mut io::Writer) {\n+                          out: &mut io::Writer) -> io::IoResult<()> {\n     match get_metadata_section(os, path) {\n       option::Some(bytes) => decoder::list_crate_metadata(intr,\n                                                           bytes.as_slice(),\n                                                           out),\n       option::None => {\n-        write!(out, \"could not find metadata in {}.\\n\", path.display())\n+          write!(out, \"could not find metadata in {}.\\n\", path.display())\n       }\n     }\n }"}, {"sha": "913c5dac46039c687b80599a47f8a57f25f34769", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=5e8ba7252a162fc6a3c5186904947f5969d732af", "patch": "@@ -10,6 +10,8 @@\n \n // Type encoding\n \n+#[allow(unused_must_use)]; // as with encoding, everything is a no-fail MemWriter\n+\n use std::cell::RefCell;\n use std::hashmap::HashMap;\n use std::io;\n@@ -92,9 +94,9 @@ pub fn enc_ty(w: &mut MemWriter, cx: @ctxt, t: ty::t) {\n                   None => {}\n               }\n           }\n-          let pos = w.tell();\n+          let pos = w.tell().unwrap();\n           enc_sty(w, cx, &ty::get(t).sty);\n-          let end = w.tell();\n+          let end = w.tell().unwrap();\n           let len = end - pos;\n           fn estimate_sz(u: u64) -> u64 {\n               let mut n = u;"}, {"sha": "78221d2adb34191176b6228661d3e9d9e68cb6b9", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=5e8ba7252a162fc6a3c5186904947f5969d732af", "patch": "@@ -88,7 +88,7 @@ struct LoopScope<'a> {\n }\n \n impl<O:DataFlowOperator> pprust::PpAnn for DataFlowContext<O> {\n-    fn pre(&self, node: pprust::AnnNode) {\n+    fn pre(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n         let (ps, id) = match node {\n             pprust::NodeExpr(ps, expr) => (ps, expr.id),\n             pprust::NodeBlock(ps, blk) => (ps, blk.id),\n@@ -117,9 +117,10 @@ impl<O:DataFlowOperator> pprust::PpAnn for DataFlowContext<O> {\n \n             let comment_str = format!(\"id {}: {}{}{}\",\n                                       id, entry_str, gens_str, kills_str);\n-            pprust::synth_comment(ps, comment_str);\n-            pp::space(&mut ps.s);\n+            if_ok!(pprust::synth_comment(ps, comment_str));\n+            if_ok!(pp::space(&mut ps.s));\n         }\n+        Ok(())\n     }\n }\n \n@@ -347,18 +348,20 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n         debug!(\"Dataflow result:\");\n         debug!(\"{}\", {\n             let this = @(*self).clone();\n-            this.pretty_print_to(~io::stderr() as ~io::Writer, blk);\n+            this.pretty_print_to(~io::stderr() as ~io::Writer, blk).unwrap();\n             \"\"\n         });\n     }\n \n-    fn pretty_print_to(@self, wr: ~io::Writer, blk: &ast::Block) {\n+    fn pretty_print_to(@self, wr: ~io::Writer,\n+                       blk: &ast::Block) -> io::IoResult<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self.tcx.sess.intr(),\n                                                     self as @pprust::PpAnn);\n-        pprust::cbox(&mut ps, pprust::indent_unit);\n-        pprust::ibox(&mut ps, 0u);\n-        pprust::print_block(&mut ps, blk);\n-        pp::eof(&mut ps.s);\n+        if_ok!(pprust::cbox(&mut ps, pprust::indent_unit));\n+        if_ok!(pprust::ibox(&mut ps, 0u));\n+        if_ok!(pprust::print_block(&mut ps, blk));\n+        if_ok!(pp::eof(&mut ps.s));\n+        Ok(())\n     }\n }\n "}, {"sha": "26e4a11ae49a203844ee49d5ce2ee1c31394636e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8ba7252a162fc6a3c5186904947f5969d732af/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5e8ba7252a162fc6a3c5186904947f5969d732af", "patch": "@@ -736,14 +736,15 @@ impl Liveness {\n     pub fn write_vars(&self,\n                       wr: &mut io::Writer,\n                       ln: LiveNode,\n-                      test: |uint| -> LiveNode) {\n+                      test: |uint| -> LiveNode) -> io::IoResult<()> {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for var_idx in range(0u, self.ir.num_vars.get()) {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n-                write!(wr, \" {}\", Variable(var_idx).to_str());\n+                if_ok!(write!(wr, \" {}\", Variable(var_idx).to_str()));\n             }\n         }\n+        Ok(())\n     }\n \n     pub fn find_loop_scope(&self,\n@@ -781,6 +782,7 @@ impl Liveness {\n         *loop_scope.get().last().unwrap()\n     }\n \n+    #[allow(unused_must_use)]\n     pub fn ln_str(&self, ln: LiveNode) -> ~str {\n         let mut wr = io::MemWriter::new();\n         {"}]}