{"sha": "a193666361f6ea9725b927a35f5baf77da713c0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExOTM2NjYzNjFmNmVhOTcyNWI5MjdhMzVmNWJhZjc3ZGE3MTNjMGE=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-03-27T05:44:54Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-03-27T05:44:54Z"}, "message": "Basic Support Macro 2.0", "tree": {"sha": "fa916fcc7e5031df796f42521fb74d775ebdec59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa916fcc7e5031df796f42521fb74d775ebdec59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a193666361f6ea9725b927a35f5baf77da713c0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a193666361f6ea9725b927a35f5baf77da713c0a", "html_url": "https://github.com/rust-lang/rust/commit/a193666361f6ea9725b927a35f5baf77da713c0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a193666361f6ea9725b927a35f5baf77da713c0a/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8066ebd1781a6f6f536abe3494477bd69df795a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8066ebd1781a6f6f536abe3494477bd69df795a", "html_url": "https://github.com/rust-lang/rust/commit/c8066ebd1781a6f6f536abe3494477bd69df795a"}], "stats": {"total": 272, "additions": 209, "deletions": 63}, "files": [{"sha": "d58135ec98ced336c294c660776506f38d721946", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 63, "deletions": 39, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=a193666361f6ea9725b927a35f5baf77da713c0a", "patch": "@@ -25,8 +25,8 @@ use crate::{\n     derive_macro_as_call_id,\n     item_scope::{ImportType, PerNsGlobImports},\n     item_tree::{\n-        self, FileItemTreeId, ItemTree, ItemTreeId, MacroCall, MacroRules, Mod, ModItem, ModKind,\n-        StructDefKind,\n+        self, FileItemTreeId, ItemTree, ItemTreeId, MacroCall, MacroDef, MacroRules, Mod, ModItem,\n+        ModKind, StructDefKind,\n     },\n     macro_call_as_call_id,\n     nameres::{\n@@ -395,7 +395,7 @@ impl DefCollector<'_> {\n     /// macro_rules! foo { () => {} }\n     /// use foo as bar;\n     /// ```\n-    fn define_macro(\n+    fn define_macro_rules(\n         &mut self,\n         module_id: LocalModuleId,\n         name: Name,\n@@ -430,6 +430,21 @@ impl DefCollector<'_> {\n         self.def_map.modules[module_id].scope.define_legacy_macro(name, mac);\n     }\n \n+    /// Define a macro 2.0 macro\n+    ///\n+    /// The scoped of macro 2.0 macro is equal to normal function\n+    fn define_macro_def(\n+        &mut self,\n+        module_id: LocalModuleId,\n+        name: Name,\n+        macro_: MacroDefId,\n+        vis: &RawVisibility,\n+    ) {\n+        let vis =\n+            self.def_map.resolve_visibility(self.db, module_id, vis).unwrap_or(Visibility::Public);\n+        self.update(module_id, &[(Some(name), PerNs::macros(macro_, vis))], vis, ImportType::Named);\n+    }\n+\n     /// Define a proc macro\n     ///\n     /// A proc macro is similar to normal macro scope, but it would not visible in legacy textual scoped.\n@@ -1067,40 +1082,7 @@ impl ModCollector<'_, '_> {\n                 }\n                 ModItem::MacroCall(mac) => self.collect_macro_call(&self.item_tree[mac]),\n                 ModItem::MacroRules(id) => self.collect_macro_rules(id),\n-                ModItem::MacroDef(id) => {\n-                    let mac = &self.item_tree[id];\n-                    let ast_id = InFile::new(self.file_id, mac.ast_id.upcast());\n-\n-                    // \"Macro 2.0\" is not currently supported by rust-analyzer, but libcore uses it\n-                    // to define builtin macros, so we support at least that part.\n-                    let attrs = self.item_tree.attrs(\n-                        self.def_collector.db,\n-                        krate,\n-                        ModItem::from(id).into(),\n-                    );\n-                    if attrs.by_key(\"rustc_builtin_macro\").exists() {\n-                        let krate = self.def_collector.def_map.krate;\n-                        let macro_id = find_builtin_macro(&mac.name, krate, ast_id)\n-                            .or_else(|| find_builtin_derive(&mac.name, krate, ast_id));\n-                        if let Some(macro_id) = macro_id {\n-                            let vis = self\n-                                .def_collector\n-                                .def_map\n-                                .resolve_visibility(\n-                                    self.def_collector.db,\n-                                    self.module_id,\n-                                    &self.item_tree[mac.visibility],\n-                                )\n-                                .unwrap_or(Visibility::Public);\n-                            self.def_collector.update(\n-                                self.module_id,\n-                                &[(Some(mac.name.clone()), PerNs::macros(macro_id, vis))],\n-                                vis,\n-                                ImportType::Named,\n-                            );\n-                        }\n-                    }\n-                }\n+                ModItem::MacroDef(id) => self.collect_macro_def(id),\n                 ModItem::Impl(imp) => {\n                     let module = self.def_collector.def_map.module_id(self.module_id);\n                     let impl_id =\n@@ -1420,7 +1402,7 @@ impl ModCollector<'_, '_> {\n         if attrs.by_key(\"rustc_builtin_macro\").exists() {\n             let krate = self.def_collector.def_map.krate;\n             if let Some(macro_id) = find_builtin_macro(&mac.name, krate, ast_id) {\n-                self.def_collector.define_macro(\n+                self.def_collector.define_macro_rules(\n                     self.module_id,\n                     mac.name.clone(),\n                     macro_id,\n@@ -1436,7 +1418,49 @@ impl ModCollector<'_, '_> {\n             kind: MacroDefKind::Declarative(ast_id),\n             local_inner: is_local_inner,\n         };\n-        self.def_collector.define_macro(self.module_id, mac.name.clone(), macro_id, is_export);\n+        self.def_collector.define_macro_rules(\n+            self.module_id,\n+            mac.name.clone(),\n+            macro_id,\n+            is_export,\n+        );\n+    }\n+\n+    fn collect_macro_def(&mut self, id: FileItemTreeId<MacroDef>) {\n+        let krate = self.def_collector.def_map.krate;\n+        let mac = &self.item_tree[id];\n+        let ast_id = InFile::new(self.file_id, mac.ast_id.upcast());\n+\n+        // Case 1: bulitin macros\n+        let attrs = self.item_tree.attrs(self.def_collector.db, krate, ModItem::from(id).into());\n+        if attrs.by_key(\"rustc_builtin_macro\").exists() {\n+            let macro_id = find_builtin_macro(&mac.name, krate, ast_id)\n+                .or_else(|| find_builtin_derive(&mac.name, krate, ast_id));\n+\n+            if let Some(macro_id) = macro_id {\n+                self.def_collector.define_macro_def(\n+                    self.module_id,\n+                    mac.name.clone(),\n+                    macro_id,\n+                    &self.item_tree[mac.visibility],\n+                );\n+            }\n+            return;\n+        }\n+\n+        // Case 2: normal `macro`\n+        let macro_id = MacroDefId {\n+            krate: self.def_collector.def_map.krate,\n+            kind: MacroDefKind::Declarative(ast_id),\n+            local_inner: false,\n+        };\n+\n+        self.def_collector.define_macro_def(\n+            self.module_id,\n+            mac.name.clone(),\n+            macro_id,\n+            &self.item_tree[mac.visibility],\n+        );\n     }\n \n     fn collect_macro_call(&mut self, mac: &MacroCall) {"}, {"sha": "9986e99e411bbed157336c9fefd3015230870069", "filename": "crates/hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=a193666361f6ea9725b927a35f5baf77da713c0a", "patch": "@@ -837,3 +837,25 @@ fn collects_derive_helpers() {\n         _ => unreachable!(),\n     }\n }\n+\n+#[test]\n+fn resolve_macro_def() {\n+    check(\n+        r#\"\n+//- /lib.rs\n+pub macro structs($($i:ident),*) {\n+    $(struct $i { field: u32 } )*\n+}\n+\n+structs!(Foo);\n+\n+//- /nested.rs\n+structs!(Bar, Baz);\n+\"#,\n+        expect![[r#\"\n+            crate\n+            Foo: t\n+            structs: m\n+        \"#]],\n+    );\n+}"}, {"sha": "c0ab70b607ce2b96d19ab4ca2db452e321f41377", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=a193666361f6ea9725b927a35f5baf77da713c0a", "patch": "@@ -3,7 +3,7 @@\n use std::sync::Arc;\n \n use base_db::{salsa, SourceDatabase};\n-use mbe::{ExpandError, ExpandResult, MacroRules};\n+use mbe::{ExpandError, ExpandResult, MacroDef, MacroRules};\n use parser::FragmentKind;\n use syntax::{\n     algo::diff,\n@@ -28,6 +28,7 @@ const TOKEN_LIMIT: usize = 524288;\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum TokenExpander {\n     MacroRules(mbe::MacroRules),\n+    MacroDef(mbe::MacroDef),\n     Builtin(BuiltinFnLikeExpander),\n     BuiltinDerive(BuiltinDeriveExpander),\n     ProcMacro(ProcMacroExpander),\n@@ -42,6 +43,7 @@ impl TokenExpander {\n     ) -> mbe::ExpandResult<tt::Subtree> {\n         match self {\n             TokenExpander::MacroRules(it) => it.expand(tt),\n+            TokenExpander::MacroDef(it) => it.expand(tt),\n             TokenExpander::Builtin(it) => it.expand(db, id, tt),\n             // FIXME switch these to ExpandResult as well\n             TokenExpander::BuiltinDerive(it) => it.expand(db, id, tt).into(),\n@@ -57,6 +59,7 @@ impl TokenExpander {\n     pub fn map_id_down(&self, id: tt::TokenId) -> tt::TokenId {\n         match self {\n             TokenExpander::MacroRules(it) => it.map_id_down(id),\n+            TokenExpander::MacroDef(it) => it.map_id_down(id),\n             TokenExpander::Builtin(..) => id,\n             TokenExpander::BuiltinDerive(..) => id,\n             TokenExpander::ProcMacro(..) => id,\n@@ -66,6 +69,7 @@ impl TokenExpander {\n     pub fn map_id_up(&self, id: tt::TokenId) -> (tt::TokenId, mbe::Origin) {\n         match self {\n             TokenExpander::MacroRules(it) => it.map_id_up(id),\n+            TokenExpander::MacroDef(it) => it.map_id_up(id),\n             TokenExpander::Builtin(..) => (id, mbe::Origin::Call),\n             TokenExpander::BuiltinDerive(..) => (id, mbe::Origin::Call),\n             TokenExpander::ProcMacro(..) => (id, mbe::Origin::Call),\n@@ -136,26 +140,40 @@ fn ast_id_map(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n \n fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Option<Arc<(TokenExpander, mbe::TokenMap)>> {\n     match id.kind {\n-        MacroDefKind::Declarative(ast_id) => {\n-            let macro_rules = match ast_id.to_node(db) {\n-                syntax::ast::Macro::MacroRules(mac) => mac,\n-                syntax::ast::Macro::MacroDef(_) => return None,\n-            };\n-            let arg = macro_rules.token_tree()?;\n-            let (tt, tmap) = mbe::ast_to_token_tree(&arg).or_else(|| {\n-                log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n-                None\n-            })?;\n-            let rules = match MacroRules::parse(&tt) {\n-                Ok(it) => it,\n-                Err(err) => {\n-                    let name = macro_rules.name().map(|n| n.to_string()).unwrap_or_default();\n-                    log::warn!(\"fail on macro_def parse ({}): {:?} {:#?}\", name, err, tt);\n-                    return None;\n-                }\n-            };\n-            Some(Arc::new((TokenExpander::MacroRules(rules), tmap)))\n-        }\n+        MacroDefKind::Declarative(ast_id) => match ast_id.to_node(db) {\n+            syntax::ast::Macro::MacroRules(macro_rules) => {\n+                let arg = macro_rules.token_tree()?;\n+                let (tt, tmap) = mbe::ast_to_token_tree(&arg).or_else(|| {\n+                    log::warn!(\"fail on macro_rules to token tree: {:#?}\", arg);\n+                    None\n+                })?;\n+                let rules = match MacroRules::parse(&tt) {\n+                    Ok(it) => it,\n+                    Err(err) => {\n+                        let name = macro_rules.name().map(|n| n.to_string()).unwrap_or_default();\n+                        log::warn!(\"fail on macro_def parse ({}): {:?} {:#?}\", name, err, tt);\n+                        return None;\n+                    }\n+                };\n+                Some(Arc::new((TokenExpander::MacroRules(rules), tmap)))\n+            }\n+            syntax::ast::Macro::MacroDef(macro_def) => {\n+                let arg = macro_def.body()?;\n+                let (tt, tmap) = mbe::ast_to_token_tree(&arg).or_else(|| {\n+                    log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n+                    None\n+                })?;\n+                let rules = match MacroDef::parse(&tt) {\n+                    Ok(it) => it,\n+                    Err(err) => {\n+                        let name = macro_def.name().map(|n| n.to_string()).unwrap_or_default();\n+                        log::warn!(\"fail on macro_def parse ({}): {:?} {:#?}\", name, err, tt);\n+                        return None;\n+                    }\n+                };\n+                Some(Arc::new((TokenExpander::MacroDef(rules), tmap)))\n+            }\n+        },\n         MacroDefKind::BuiltIn(expander, _) => {\n             Some(Arc::new((TokenExpander::Builtin(expander), mbe::TokenMap::default())))\n         }"}, {"sha": "779725629a0003a47377ca709a292103229b743b", "filename": "crates/hir_expand/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs?ref=a193666361f6ea9725b927a35f5baf77da713c0a", "patch": "@@ -148,7 +148,7 @@ fn make_hygiene_info(\n     let def_offset = loc.def.ast_id().left().and_then(|id| {\n         let def_tt = match id.to_node(db) {\n             ast::Macro::MacroRules(mac) => mac.token_tree()?.syntax().text_range().start(),\n-            ast::Macro::MacroDef(_) => return None,\n+            ast::Macro::MacroDef(mac) => mac.body()?.syntax().text_range().start(),\n         };\n         Some(InFile::new(id.file_id, def_tt))\n     });"}, {"sha": "3e332ee47ea1c54fd4913f6e38154182c8b3ddc4", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=a193666361f6ea9725b927a35f5baf77da713c0a", "patch": "@@ -151,7 +151,7 @@ impl HirFileId {\n                 let def = loc.def.ast_id().left().and_then(|id| {\n                     let def_tt = match id.to_node(db) {\n                         ast::Macro::MacroRules(mac) => mac.token_tree()?,\n-                        ast::Macro::MacroDef(_) => return None,\n+                        ast::Macro::MacroDef(mac) => mac.body()?,\n                     };\n                     Some(InFile::new(id.file_id, def_tt))\n                 });"}, {"sha": "3eb01dbd0fa3b3be4868f78126aab9aeb40565b1", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=a193666361f6ea9725b927a35f5baf77da713c0a", "patch": "@@ -135,7 +135,88 @@ fn infer_path_qualified_macros_expanded() {\n }\n \n #[test]\n-fn expr_macro_expanded_in_various_places() {\n+fn expr_macro_def_expanded_in_various_places() {\n+    check_infer(\n+        r#\"\n+        macro spam() {\n+            1isize\n+        }\n+\n+        fn spam() {\n+            spam!();\n+            (spam!());\n+            spam!().spam(spam!());\n+            for _ in spam!() {}\n+            || spam!();\n+            while spam!() {}\n+            break spam!();\n+            return spam!();\n+            match spam!() {\n+                _ if spam!() => spam!(),\n+            }\n+            spam!()(spam!());\n+            Spam { spam: spam!() };\n+            spam!()[spam!()];\n+            await spam!();\n+            spam!() as usize;\n+            &spam!();\n+            -spam!();\n+            spam!()..spam!();\n+            spam!() + spam!();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            39..442 '{     ...!(); }': ()\n+            73..94 'spam!(...am!())': {unknown}\n+            100..119 'for _ ...!() {}': ()\n+            104..105 '_': {unknown}\n+            117..119 '{}': ()\n+            124..134 '|| spam!()': || -> isize\n+            140..156 'while ...!() {}': ()\n+            154..156 '{}': ()\n+            161..174 'break spam!()': !\n+            180..194 'return spam!()': !\n+            200..254 'match ...     }': isize\n+            224..225 '_': isize\n+            259..275 'spam!(...am!())': {unknown}\n+            281..303 'Spam {...m!() }': {unknown}\n+            309..325 'spam!(...am!()]': {unknown}\n+            350..366 'spam!(... usize': usize\n+            372..380 '&spam!()': &isize\n+            386..394 '-spam!()': isize\n+            400..416 'spam!(...pam!()': {unknown}\n+            422..439 'spam!(...pam!()': isize\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn expr_macro_rules_expanded_in_various_places() {\n     check_infer(\n         r#\"\n         macro_rules! spam {"}, {"sha": "ae98dbd268951076f425017c6603b0b74512407b", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a193666361f6ea9725b927a35f5baf77da713c0a/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=a193666361f6ea9725b927a35f5baf77da713c0a", "patch": "@@ -40,6 +40,7 @@ fn text_of_first_token(node: &SyntaxNode) -> TokenText {\n     TokenText(first_token)\n }\n \n+#[derive(Debug, PartialEq, Eq, Clone)]\n pub enum Macro {\n     MacroRules(ast::MacroRules),\n     MacroDef(ast::MacroDef),"}]}