{"sha": "a1fc284559aaee127c93a2d6179dcda4e034d229", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExZmMyODQ1NTlhYWVlMTI3YzkzYTJkNjE3OWRjZGE0ZTAzNGQyMjk=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-17T08:53:03Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-17T08:53:03Z"}, "message": "Simplify some Repr code.", "tree": {"sha": "a410de7437b4d653aa2ff7c87102bdb6919d549d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a410de7437b4d653aa2ff7c87102bdb6919d549d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1fc284559aaee127c93a2d6179dcda4e034d229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1fc284559aaee127c93a2d6179dcda4e034d229", "html_url": "https://github.com/rust-lang/rust/commit/a1fc284559aaee127c93a2d6179dcda4e034d229", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1fc284559aaee127c93a2d6179dcda4e034d229/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa791a4085dce76a6b9100e12a894a47745c3b2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa791a4085dce76a6b9100e12a894a47745c3b2a", "html_url": "https://github.com/rust-lang/rust/commit/aa791a4085dce76a6b9100e12a894a47745c3b2a"}], "stats": {"total": 129, "additions": 74, "deletions": 55}, "files": [{"sha": "2988bc38811ccf1e92ac5dee7cec4ffd1703c1de", "filename": "src/interpreter.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc284559aaee127c93a2d6179dcda4e034d229/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc284559aaee127c93a2d6179dcda4e034d229/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=a1fc284559aaee127c93a2d6179dcda4e034d229", "patch": "@@ -142,18 +142,18 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         let mut locals = Vec::with_capacity(num_args + num_vars + num_temps);\n \n         for (arg_decl, arg_operand) in mir.arg_decls.iter().zip(args) {\n-            let repr = self.ty_to_repr(arg_decl.ty);\n-            let dest = self.memory.allocate(repr.size());\n+            let size = self.ty_to_repr(arg_decl.ty).size();\n+            let dest = self.memory.allocate(size);\n             let src = try!(self.eval_operand(arg_operand));\n-            try!(self.memory.copy(src, dest, repr.size()));\n+            try!(self.memory.copy(src, dest, size));\n             locals.push(dest);\n         }\n \n         let var_tys = mir.var_decls.iter().map(|v| v.ty);\n         let temp_tys = mir.temp_decls.iter().map(|t| t.ty);\n         locals.extend(var_tys.chain(temp_tys).map(|ty| {\n-            let repr = self.ty_to_repr(ty).size();\n-            self.memory.allocate(repr)\n+            let size = self.ty_to_repr(ty).size();\n+            self.memory.allocate(size)\n         }));\n \n         self.stack.push(Frame {\n@@ -189,15 +189,15 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n                 let discr_ptr = try!(self.eval_lvalue(discr));\n-                let discr_repr = self.lvalue_repr(discr);\n-                let discr_val = try!(self.memory.read_primval(discr_ptr, &discr_repr));\n+                let discr_size = self.lvalue_repr(discr).size();\n+                let discr_val = try!(self.memory.read_uint(discr_ptr, discr_size));\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, val_const) in values.iter().enumerate() {\n                     let ptr = try!(self.const_to_ptr(val_const));\n-                    let val = try!(self.memory.read_primval(ptr, &discr_repr));\n+                    let val = try!(self.memory.read_uint(ptr, discr_size));\n                     if discr_val == val {\n                         target_block = targets[index];\n                         break;\n@@ -210,12 +210,12 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n             Switch { ref discr, ref targets, .. } => {\n                 let adt_ptr = try!(self.eval_lvalue(discr));\n                 let adt_repr = self.lvalue_repr(discr);\n-                let discr_repr = match adt_repr {\n-                    Repr::Sum { ref discr, .. } => discr,\n+                let discr_size = match adt_repr {\n+                    Repr::Sum { discr_size, .. } => discr_size,\n                     _ => panic!(\"attmpted to switch on non-sum type\"),\n                 };\n-                let discr_val = try!(self.memory.read_primval(adt_ptr, &discr_repr));\n-                TerminatorTarget::Block(targets[discr_val.to_usize()])\n+                let discr_val = try!(self.memory.read_uint(adt_ptr, discr_size));\n+                TerminatorTarget::Block(targets[discr_val as usize])\n             }\n \n             Call { ref func, ref args, ref destination, .. } => {\n@@ -332,16 +332,21 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n-                let (left_ptr, left_repr) = try!(self.eval_operand_and_repr(left));\n-                let (right_ptr, right_repr) = try!(self.eval_operand_and_repr(right));\n-                let left_val = try!(self.memory.read_primval(left_ptr, &left_repr));\n-                let right_val = try!(self.memory.read_primval(right_ptr, &right_repr));\n+                let left_ptr = try!(self.eval_operand(left));\n+                let left_ty = self.operand_ty(left);\n+                let left_val = try!(self.memory.read_primval(left_ptr, left_ty));\n+\n+                let right_ptr = try!(self.eval_operand(right));\n+                let right_ty = self.operand_ty(right);\n+                let right_val = try!(self.memory.read_primval(right_ptr, right_ty));\n+\n                 self.memory.write_primval(dest, primval::binary_op(bin_op, left_val, right_val))\n             }\n \n             UnaryOp(un_op, ref operand) => {\n-                let (ptr, repr) = try!(self.eval_operand_and_repr(operand));\n-                let val = try!(self.memory.read_primval(ptr, &repr));\n+                let ptr = try!(self.eval_operand(operand));\n+                let ty = self.operand_ty(operand);\n+                let val = try!(self.memory.read_primval(ptr, ty));\n                 self.memory.write_primval(dest, primval::unary_op(un_op, val))\n             }\n \n@@ -354,13 +359,13 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                         ty::AdtKind::Struct => self.assign_to_product(dest, &dest_repr, operands),\n \n                         ty::AdtKind::Enum => match dest_repr {\n-                            Repr::Sum { ref discr, ref variants, .. } => {\n-                                if discr.size() > 0 {\n-                                    let discr_val = PrimVal::from_usize(variant_idx, discr);\n-                                    try!(self.memory.write_primval(dest, discr_val));\n+                            Repr::Sum { discr_size, ref variants, .. } => {\n+                                if discr_size > 0 {\n+                                    let discr = variant_idx as u64;\n+                                    try!(self.memory.write_uint(dest, discr, discr_size));\n                                 }\n                                 self.assign_to_product(\n-                                    dest.offset(discr.size() as isize),\n+                                    dest.offset(discr_size as isize),\n                                     &variants[variant_idx],\n                                     operands\n                                 )\n@@ -450,6 +455,10 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         }\n     }\n \n+    fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> ty::Ty<'tcx> {\n+        self.current_frame().mir.operand_ty(self.tcx, operand)\n+    }\n+\n     fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<Pointer> {\n         self.eval_operand_and_repr(op).map(|(p, _)| p)\n     }\n@@ -503,7 +512,7 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                     },\n \n                     Downcast(..) => match base_repr {\n-                        Repr::Sum { ref discr, .. } => base_ptr.offset(discr.size() as isize),\n+                        Repr::Sum { discr_size, .. } => base_ptr.offset(discr_size as isize),\n                         _ => panic!(\"variant downcast on non-sum type\"),\n                     },\n \n@@ -585,24 +594,20 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n             ty::TyEnum(adt_def, substs) => {\n                 let num_variants = adt_def.variants.len();\n \n-                let discr = if num_variants <= 1 {\n-                    Repr::Product { size: 0, fields: vec![] }\n-                } else if num_variants <= 1 << 8 {\n-                    Repr::U8\n-                } else if num_variants <= 1 << 16 {\n-                    Repr::U16\n-                } else if num_variants <= 1 << 32 {\n-                    Repr::U32\n-                } else {\n-                    Repr::U64\n+                let discr_size = match num_variants {\n+                    n if n <= 1       => 0,\n+                    n if n <= 1 << 8  => 1,\n+                    n if n <= 1 << 16 => 2,\n+                    n if n <= 1 << 32 => 4,\n+                    _                 => 8,\n                 };\n \n                 let variants: Vec<Repr> = adt_def.variants.iter().map(|v| {\n                     self.make_variant_repr(v, substs)\n                 }).collect();\n \n                 Repr::Sum {\n-                    discr: Box::new(discr),\n+                    discr_size: discr_size,\n                     max_variant_size: variants.iter().map(Repr::size).max().unwrap_or(0),\n                     variants: variants,\n                 }\n@@ -710,10 +715,10 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 println!(\"{:?} {:?}\", mth.method.def_id, mth.substs);\n                 (mth.method.def_id, mth.substs)\n             }\n-            traits::VtableClosure(vtable_closure) => {\n+            traits::VtableClosure(_vtable_closure) => {\n                 // The substitutions should have no type parameters remaining after passing\n                 // through fulfill_obligation\n-                let trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+                let _trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n                 unimplemented!()\n                 // vtable_closure.closure_def_id\n                 // vtable_closure.substs\n@@ -727,8 +732,8 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 // };\n                 // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n             }\n-            traits::VtableFnPointer(fn_ty) => {\n-                let trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+            traits::VtableFnPointer(_fn_ty) => {\n+                let _trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n                 unimplemented!()\n                 // let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n \n@@ -740,7 +745,7 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 // };\n                 // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n             }\n-            traits::VtableObject(ref data) => {\n+            traits::VtableObject(ref _data) => {\n                 unimplemented!()\n                 // Callee {\n                 //     data: Virtual(traits::get_vtable_index_of_object_method("}, {"sha": "a135f267910b8aa01a4f43010d7ac68b74ccb870", "filename": "src/memory.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc284559aaee127c93a2d6179dcda4e034d229/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc284559aaee127c93a2d6179dcda4e034d229/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=a1fc284559aaee127c93a2d6179dcda4e034d229", "patch": "@@ -1,4 +1,5 @@\n-use byteorder::{self, ByteOrder};\n+use byteorder::{self, ByteOrder, NativeEndian, ReadBytesExt, WriteBytesExt};\n+use rustc::middle::ty;\n use std::collections::{BTreeMap, HashMap};\n use std::collections::Bound::{Included, Excluded};\n use std::mem;\n@@ -56,10 +57,14 @@ pub enum Repr {\n \n     /// The representation for a sum type, i.e. a Rust enum.\n     Sum {\n+        /// The size of the discriminant (an integer). Should be between 0 and 8.\n+        discr_size: usize,\n+\n         /// The size of the largest variant in bytes.\n         max_variant_size: usize,\n+\n+        /// The represenations of the contents of each variant.\n         variants: Vec<Repr>,\n-        discr: Box<Repr>,\n     },\n \n     Array {\n@@ -167,18 +172,19 @@ impl Memory {\n         Ok(())\n     }\n \n-    pub fn read_primval(&self, ptr: Pointer, repr: &Repr) -> EvalResult<PrimVal> {\n-        match *repr {\n-            Repr::Bool => self.read_bool(ptr).map(PrimVal::Bool),\n-            Repr::I8   => self.read_i8(ptr).map(PrimVal::I8),\n-            Repr::I16  => self.read_i16(ptr).map(PrimVal::I16),\n-            Repr::I32  => self.read_i32(ptr).map(PrimVal::I32),\n-            Repr::I64  => self.read_i64(ptr).map(PrimVal::I64),\n-            Repr::U8   => self.read_u8(ptr).map(PrimVal::U8),\n-            Repr::U16  => self.read_u16(ptr).map(PrimVal::U16),\n-            Repr::U32  => self.read_u32(ptr).map(PrimVal::U32),\n-            Repr::U64  => self.read_u64(ptr).map(PrimVal::U64),\n-            _ => panic!(\"primitive read of non-primitive: {:?}\", repr),\n+    pub fn read_primval(&self, ptr: Pointer, ty: ty::Ty) -> EvalResult<PrimVal> {\n+        use syntax::ast::{IntTy, UintTy};\n+        match ty.sty {\n+            ty::TyBool              => self.read_bool(ptr).map(PrimVal::Bool),\n+            ty::TyInt(IntTy::I8)    => self.read_i8(ptr).map(PrimVal::I8),\n+            ty::TyInt(IntTy::I16)   => self.read_i16(ptr).map(PrimVal::I16),\n+            ty::TyInt(IntTy::I32)   => self.read_i32(ptr).map(PrimVal::I32),\n+            ty::TyInt(IntTy::I64)   => self.read_i64(ptr).map(PrimVal::I64),\n+            ty::TyUint(UintTy::U8)  => self.read_u8(ptr).map(PrimVal::U8),\n+            ty::TyUint(UintTy::U16) => self.read_u16(ptr).map(PrimVal::U16),\n+            ty::TyUint(UintTy::U32) => self.read_u32(ptr).map(PrimVal::U32),\n+            ty::TyUint(UintTy::U64) => self.read_u64(ptr).map(PrimVal::U64),\n+            _ => panic!(\"primitive read of non-primitive type: {:?}\", ty),\n         }\n     }\n \n@@ -286,6 +292,14 @@ impl Memory {\n         byteorder::NativeEndian::write_u64(bytes, n);\n         Ok(())\n     }\n+\n+    pub fn read_uint(&self, ptr: Pointer, size: usize) -> EvalResult<u64> {\n+        self.get_bytes(ptr, size).map(|mut b| b.read_uint::<NativeEndian>(size).unwrap())\n+    }\n+\n+    pub fn write_uint(&mut self, ptr: Pointer, n: u64, size: usize) -> EvalResult<()> {\n+        self.get_bytes_mut(ptr, size).map(|mut b| b.write_uint::<NativeEndian>(n, size).unwrap())\n+    }\n }\n \n impl Allocation {\n@@ -359,7 +373,7 @@ impl Repr {\n             Repr::I32 | Repr::U32 => 4,\n             Repr::I64 | Repr::U64 => 8,\n             Repr::Product { size, .. } => size,\n-            Repr::Sum { ref discr, max_variant_size, .. } => discr.size() + max_variant_size,\n+            Repr::Sum { discr_size, max_variant_size, .. } => discr_size + max_variant_size,\n             Repr::Array { ref elem, length } => elem.size() * length,\n             Repr::Pointer => POINTER_SIZE,\n             Repr::FatPointer => POINTER_SIZE * 2,"}]}