{"sha": "45be6fc4d755b1376942196edc9efc7b62a43808", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1YmU2ZmM0ZDc1NWIxMzc2OTQyMTk2ZWRjOWVmYzdiNjJhNDM4MDg=", "commit": {"author": {"name": "Michael Layzell", "email": "michael@thelayzells.com", "date": "2015-08-07T02:03:14Z"}, "committer": {"name": "Michael Layzell", "email": "michael@thelayzells.com", "date": "2015-09-22T22:56:50Z"}, "message": "Implement drain over a range for VecDeque", "tree": {"sha": "2072ecf788d2a903dd34801c4169f727ea0cc732", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2072ecf788d2a903dd34801c4169f727ea0cc732"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45be6fc4d755b1376942196edc9efc7b62a43808", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45be6fc4d755b1376942196edc9efc7b62a43808", "html_url": "https://github.com/rust-lang/rust/commit/45be6fc4d755b1376942196edc9efc7b62a43808", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45be6fc4d755b1376942196edc9efc7b62a43808/comments", "author": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f002a4c6ed2bb694407842b5447dba34799b931", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f002a4c6ed2bb694407842b5447dba34799b931", "html_url": "https://github.com/rust-lang/rust/commit/3f002a4c6ed2bb694407842b5447dba34799b931"}], "stats": {"total": 285, "additions": 271, "deletions": 14}, "files": [{"sha": "27a996055f58ff349f70705d4540df326c3609f6", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 271, "deletions": 14, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/45be6fc4d755b1376942196edc9efc7b62a43808/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45be6fc4d755b1376942196edc9efc7b62a43808/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=45be6fc4d755b1376942196edc9efc7b62a43808", "patch": "@@ -30,6 +30,8 @@ use core::cmp;\n \n use alloc::raw_vec::RawVec;\n \n+use super::range::RangeArgument;\n+\n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n \n@@ -159,6 +161,117 @@ impl<T> VecDeque<T> {\n             len);\n     }\n \n+    /// Copies a potentially wrapping block of memory len long from src to dest.\n+    /// (abs(dst - src) + len) must be no larger than cap() (There must be at\n+    /// most one continuous overlapping region between src and dest).\n+    unsafe fn wrap_copy(&self, dst: usize, src: usize, len: usize) {\n+        debug_assert!(\n+            (if src <= dst { dst - src } else { src - dst }) + len <= self.cap(),\n+            \"dst={} src={} len={} cap={}\", dst, src, len, self.cap());\n+\n+        if src == dst || len == 0 { return }\n+\n+        let dst_after_src = self.wrap_sub(dst, src) < len;\n+\n+        let src_pre_wrap_len = self.cap() - src;\n+        let dst_pre_wrap_len = self.cap() - dst;\n+        let src_wraps = src_pre_wrap_len < len;\n+        let dst_wraps = dst_pre_wrap_len < len;\n+\n+        match (dst_after_src, src_wraps, dst_wraps) {\n+            (_, false, false) => {\n+                // src doesn't wrap, dst doesn't wrap\n+                //\n+                //        S . . .\n+                // 1 [_ _ A A B B C C _]\n+                // 2 [_ _ A A A A B B _]\n+                //            D . . .\n+                //\n+                self.copy(dst, src, len);\n+            }\n+            (false, false, true) => {\n+                // dst before src, src doesn't wrap, dst wraps\n+                //\n+                //    S . . .\n+                // 1 [A A B B _ _ _ C C]\n+                // 2 [A A B B _ _ _ A A]\n+                // 3 [B B B B _ _ _ A A]\n+                //    . .           D .\n+                //\n+                self.copy(dst, src, dst_pre_wrap_len);\n+                self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+            }\n+            (true, false, true) => {\n+                // src before dst, src doesn't wrap, dst wraps\n+                //\n+                //              S . . .\n+                // 1 [C C _ _ _ A A B B]\n+                // 2 [B B _ _ _ A A B B]\n+                // 3 [B B _ _ _ A A A A]\n+                //    . .           D .\n+                //\n+                self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+                self.copy(dst, src, dst_pre_wrap_len);\n+            }\n+            (false, true, false) => {\n+                // dst before src, src wraps, dst doesn't wrap\n+                //\n+                //    . .           S .\n+                // 1 [C C _ _ _ A A B B]\n+                // 2 [C C _ _ _ B B B B]\n+                // 3 [C C _ _ _ B B C C]\n+                //              D . . .\n+                //\n+                self.copy(dst, src, src_pre_wrap_len);\n+                self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+            }\n+            (true, true, false) => {\n+                // src before dst, src wraps, dst doesn't wrap\n+                //\n+                //    . .           S .\n+                // 1 [A A B B _ _ _ C C]\n+                // 2 [A A A A _ _ _ C C]\n+                // 3 [C C A A _ _ _ C C]\n+                //    D . . .\n+                //\n+                self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+                self.copy(dst, src, src_pre_wrap_len);\n+            }\n+            (false, true, true) => {\n+                // dst before src, src wraps, dst wraps\n+                //\n+                //    . . .         S .\n+                // 1 [A B C D _ E F G H]\n+                // 2 [A B C D _ E G H H]\n+                // 3 [A B C D _ E G H A]\n+                // 4 [B C C D _ E G H A]\n+                //    . .         D . .\n+                //\n+                debug_assert!(dst_pre_wrap_len > src_pre_wrap_len);\n+                let delta = dst_pre_wrap_len - src_pre_wrap_len;\n+                self.copy(dst, src, src_pre_wrap_len);\n+                self.copy(dst + src_pre_wrap_len, 0, delta);\n+                self.copy(0, delta, len - dst_pre_wrap_len);\n+            }\n+            (true, true, true) => {\n+                // src before dst, src wraps, dst wraps\n+                //\n+                //    . .         S . .\n+                // 1 [A B C D _ E F G H]\n+                // 2 [A A B D _ E F G H]\n+                // 3 [H A B D _ E F G H]\n+                // 4 [H A B D _ E F F G]\n+                //    . . .         D .\n+                //\n+                debug_assert!(src_pre_wrap_len > dst_pre_wrap_len);\n+                let delta = src_pre_wrap_len - dst_pre_wrap_len;\n+                self.copy(delta, 0, len - src_pre_wrap_len);\n+                self.copy(0, self.cap() - delta, delta);\n+                self.copy(dst, src, dst_pre_wrap_len);\n+            }\n+        }\n+    }\n+\n     /// Frobs the head and tail sections around to handle the fact that we\n     /// just reallocated. Unsafe because it trusts old_cap.\n     #[inline]\n@@ -601,8 +714,18 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n-    /// Creates a draining iterator that clears the `VecDeque` and iterates over\n-    /// the removed items from start to end.\n+    /// Create a draining iterator that removes the specified range in the\n+    /// `VecDeque` and yields the removed items from start to end. The element\n+    /// range is removed even if the iterator is not consumed until the end.\n+    ///\n+    /// Note: It is unspecified how many elements are removed from the deque,\n+    /// if the `Drain` value is not dropped, but the borrow it holds expires\n+    /// (eg. due to mem::forget).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the starting point is greater than the end point or if\n+    /// the end point is greater than the length of the vector.\n     ///\n     /// # Examples\n     ///\n@@ -611,18 +734,66 @@ impl<T> VecDeque<T> {\n     ///\n     /// use std::collections::VecDeque;\n     ///\n+    /// // draining using `..` clears the whole deque.\n     /// let mut v = VecDeque::new();\n     /// v.push_back(1);\n-    /// assert_eq!(v.drain().next(), Some(1));\n+    /// assert_eq!(v.drain(..).next(), Some(1));\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n     #[unstable(feature = \"drain\",\n                reason = \"matches collection reform specification, waiting for dust to settle\",\n                issue = \"27711\")]\n-    pub fn drain(&mut self) -> Drain<T> {\n+    pub fn drain<R>(&mut self, range: R) -> Drain<T> where R: RangeArgument<usize> {\n+        // Memory safety\n+        //\n+        // When the Drain is first created, the source deque is shortened to\n+        // make sure no uninitialized or moved-from elements are accessible at\n+        // all if the Drain's destructor never gets to run.\n+        //\n+        // Drain will ptr::read out the values to remove.\n+        // When finished, the remaining data will be copied back to cover the hole,\n+        // and the head/tail values will be restored correctly.\n+        //\n+        let len = self.len();\n+        let start = *range.start().unwrap_or(&0);\n+        let end = *range.end().unwrap_or(&len);\n+        assert!(start <= end, \"drain lower bound was too large\");\n+        assert!(end <= len, \"drain upper bound was too large\");\n+\n+        // The deque's elements are parted into three segments:\n+        // * self.tail  -> drain_tail\n+        // * drain_tail -> drain_head\n+        // * drain_head -> self.head\n+        //\n+        // T = self.tail; H = self.head; t = drain_tail; h = drain_head\n+        //\n+        // We store drain_tail as self.head, and drain_head and self.head as\n+        // after_tail and after_head respectively on the Drain. This also\n+        // truncates the effective array such that if the Drain is leaked, we\n+        // have forgotten about the potentially moved values after the start of\n+        // the drain.\n+        //\n+        //        T   t   h   H\n+        // [. . . o o x x o o . . .]\n+        //\n+        let drain_tail = self.wrap_add(self.tail, start);\n+        let drain_head = self.wrap_add(self.tail, end);\n+        let head = self.head;\n+\n+        // \"forget\" about the values after the start of the drain until after\n+        // the drain is complete and the Drain destructor is run.\n+        self.head = drain_tail;\n+\n         Drain {\n-            inner: self,\n+            deque: self as *mut _,\n+            after_tail: drain_head,\n+            after_head: head,\n+            iter: Iter {\n+                tail: drain_tail,\n+                head: drain_head,\n+                ring: unsafe { self.buffer_as_mut_slice() },\n+            },\n         }\n     }\n \n@@ -641,7 +812,7 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn clear(&mut self) {\n-        self.drain();\n+        self.drain(..);\n     }\n \n     /// Provides a reference to the front element, or `None` if the sequence is\n@@ -1386,7 +1557,7 @@ impl<T> VecDeque<T> {\n                issue = \"27765\")]\n     pub fn append(&mut self, other: &mut Self) {\n         // naive impl\n-        self.extend(other.drain());\n+        self.extend(other.drain(..));\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -1623,15 +1794,56 @@ impl<T> ExactSizeIterator for IntoIter<T> {}\n            reason = \"matches collection reform specification, waiting for dust to settle\",\n            issue = \"27711\")]\n pub struct Drain<'a, T: 'a> {\n-    inner: &'a mut VecDeque<T>,\n+    after_tail: usize,\n+    after_head: usize,\n+    iter: Iter<'a, T>,\n+    deque: *mut VecDeque<T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         for _ in self.by_ref() {}\n-        self.inner.head = 0;\n-        self.inner.tail = 0;\n+\n+        let source_deque = unsafe { &mut *self.deque };\n+\n+        // T = source_deque_tail; H = source_deque_head; t = drain_tail; h = drain_head\n+        //\n+        //        T   t   h   H\n+        // [. . . o o x x o o . . .]\n+        //\n+        let orig_tail = source_deque.tail;\n+        let drain_tail = source_deque.head;\n+        let drain_head = self.after_tail;\n+        let orig_head = self.after_head;\n+\n+        let tail_len = count(orig_tail, drain_tail, source_deque.cap());\n+        let head_len = count(drain_head, orig_head, source_deque.cap());\n+\n+        // Restore the original head value\n+        source_deque.head = orig_head;\n+\n+        match (tail_len, head_len) {\n+            (0, 0) => {\n+                source_deque.head = 0;\n+                source_deque.tail = 0;\n+            }\n+            (0, _) => {\n+                source_deque.tail = drain_head;\n+            }\n+            (_, 0) => {\n+                source_deque.head = drain_tail;\n+            }\n+            _ => unsafe {\n+                if tail_len <= head_len {\n+                    source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n+                    source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n+                } else {\n+                    source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n+                    source_deque.wrap_copy(drain_tail, drain_head, head_len);\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -1641,21 +1853,28 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        self.inner.pop_front()\n+        self.iter.next().map(|elt|\n+            unsafe {\n+                ptr::read(elt)\n+            }\n+        )\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.inner.len();\n-        (len, Some(len))\n+        self.iter.size_hint()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n-        self.inner.pop_back()\n+        self.iter.next_back().map(|elt|\n+            unsafe {\n+                ptr::read(elt)\n+            }\n+        )\n     }\n }\n \n@@ -1965,6 +2184,44 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_drain() {\n+        let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n+\n+        let cap = tester.capacity();\n+        for len in 0..cap + 1 {\n+            for tail in 0..cap + 1 {\n+                for drain_start in 0..len + 1 {\n+                    for drain_end in drain_start..len + 1 {\n+                        tester.tail = tail;\n+                        tester.head = tail;\n+                        for i in 0..len {\n+                            tester.push_back(i);\n+                        }\n+\n+                        // Check that we drain the correct values\n+                        let drained: VecDeque<_> =\n+                            tester.drain(drain_start..drain_end).collect();\n+                        let drained_expected: VecDeque<_> =\n+                            (drain_start..drain_end).collect();\n+                        assert_eq!(drained, drained_expected);\n+\n+                        // We shouldn't have changed the capacity or made the\n+                        // head or tail out of bounds\n+                        assert_eq!(tester.capacity(), cap);\n+                        assert!(tester.tail < tester.cap());\n+                        assert!(tester.head < tester.cap());\n+\n+                        // We should see the correct values in the VecDeque\n+                        let expected: VecDeque<_> =\n+                            (0..drain_start).chain(drain_end..len).collect();\n+                        assert_eq!(expected, tester);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn test_shrink_to_fit() {\n         // This test checks that every single combination of head and tail position,"}]}