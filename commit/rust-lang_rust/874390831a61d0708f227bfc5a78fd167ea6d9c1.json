{"sha": "874390831a61d0708f227bfc5a78fd167ea6d9c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NDM5MDgzMWE2MWQwNzA4ZjIyN2JmYzVhNzhmZDE2N2VhNmQ5YzE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-01-20T01:50:02Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-01-20T01:50:21Z"}, "message": "Fix a bunch of broken internal links in the docs. Add a hokey link checker.", "tree": {"sha": "2c65bb1241227c6026635b7d9bf71fe4dc360984", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c65bb1241227c6026635b7d9bf71fe4dc360984"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/874390831a61d0708f227bfc5a78fd167ea6d9c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/874390831a61d0708f227bfc5a78fd167ea6d9c1", "html_url": "https://github.com/rust-lang/rust/commit/874390831a61d0708f227bfc5a78fd167ea6d9c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/874390831a61d0708f227bfc5a78fd167ea6d9c1/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d4884d983fbf931740be064dfe5b9b01e6118c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d4884d983fbf931740be064dfe5b9b01e6118c3", "html_url": "https://github.com/rust-lang/rust/commit/6d4884d983fbf931740be064dfe5b9b01e6118c3"}], "stats": {"total": 139, "additions": 81, "deletions": 58}, "files": [{"sha": "23081768e884fd293af0ec48c934b510cbc83452", "filename": "doc/rust.md", "status": "modified", "additions": 55, "deletions": 58, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/874390831a61d0708f227bfc5a78fd167ea6d9c1/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/874390831a61d0708f227bfc5a78fd167ea6d9c1/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=874390831a61d0708f227bfc5a78fd167ea6d9c1", "patch": "@@ -132,7 +132,7 @@ The following productions in the Rust grammar are defined in terms of\n Unicode properties: `ident`, `non_null`, `non_star`, `non_eol`, `non_slash`,\n `non_single_quote` and `non_double_quote`.\n \n-### Identifier\n+### Identifiers\n \n The `ident` production is any nonempty Unicode string of the following form:\n \n@@ -254,8 +254,8 @@ are excluded from the `ident` rule.\n A literal is an expression consisting of a single token, rather than a\n sequence of tokens, that immediately and directly denotes the value it\n evaluates to, rather than referring to it by name or some other evaluation\n-rule. A literal is a form of [constant expression](#constant-expression), so\n-is evaluated (primarily) at compile time.\n+rule. A literal is a form of constant expression, so is evaluated (primarily)\n+at compile time.\n \n ~~~~~~~~ {.ebnf .gram}\n literal : string_lit | char_lit | num_lit ;\n@@ -439,14 +439,13 @@ type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n ~~~~~~~~\n \n A _path_ is a sequence of one or more path components _logically_ separated by\n-a namespace qualifier (`::`). If a path consists of only one component, it\n-may refer to either an [item](#items) or a [variable](#variables) in a local\n+a namespace qualifier (`::`). If a path consists of only one component, it may\n+refer to either an [item](#items) or a [slot](#slot-declarations) in a local\n control scope. If a path has multiple components, it refers to an item.\n \n-Every item has a _canonical path_ within its [crate](#crates), but the path\n-naming an item is only meaningful within a given crate. There is no global\n-namespace across crates; an item's canonical path merely identifies it within\n-the crate.\n+Every item has a _canonical path_ within its crate, but the path naming an\n+item is only meaningful within a given crate. There is no global namespace\n+across crates; an item's canonical path merely identifies it within the crate.\n \n Two examples of simple paths consisting of only identifier components:\n \n@@ -457,11 +456,10 @@ x::y::z;\n \n Path components are usually [identifiers](#identifiers), but the trailing\n component of a path may be an angle-bracket-enclosed list of type\n-arguments. In [expression](#expressions) context, the type\n-argument list is given after a final (`::`) namespace qualifier in order to\n-disambiguate it from a relational expression involving the less-than symbol\n-(`<`). In [type expression](#type-expressions) context, the final namespace\n-qualifier is omitted.\n+arguments. In [expression](#expressions) context, the type argument list is\n+given after a final (`::`) namespace qualifier in order to disambiguate it\n+from a relational expression involving the less-than symbol (`<`). In type\n+expression context, the final namespace qualifier is omitted.\n \n Two examples of paths with type arguments:\n \n@@ -569,7 +567,7 @@ implicitly by combining the module name with the file extension `.rs`.  The\n module contained in that source file is bound to the module path formed by\n the `dir_directive` modules containing the `source_directive`.\n \n-## Source file\n+## Source files\n \n A source file contains a `module`: that is, a sequence of zero or more\n `item` definitions. Each source file is an implicit module, the name and\n@@ -590,12 +588,11 @@ item : mod_item | fn_item | type_item | enum_item\n      | res_item | iface_item | impl_item ;\n ~~~~~~~~\n \n-An _item_ is a component of a crate; some module items can be defined in\n-[crate files](#crate-files), but most are defined in [source\n-files](#source-files). Items are organized within a crate by a nested set of\n-[modules](#modules). Every crate has a single \"outermost\" anonymous module;\n-all further items within the crate have [paths](#paths) within the module tree\n-of the crate.\n+An _item_ is a component of a crate; some module items can be defined in crate\n+files, but most are defined in source files. Items are organized within a\n+crate by a nested set of [modules](#modules). Every crate has a single\n+\"outermost\" anonymous module; all further items within the crate have\n+[paths](#paths) within the module tree of the crate.\n \n Items are entirely determined at compile-time, remain constant during\n execution, and may reside in read-only memory.\n@@ -821,9 +818,10 @@ mod foo {\n A _function item_ defines a sequence of [statements](#statements) and an\n optional final [expression](#expressions) associated with a name and a set of\n parameters. Functions are declared with the keyword `fn`. Functions declare a\n-set of *input [slots](#slots)* as parameters, through which the caller passes\n-arguments into the function, and an *output [slot](#slots)* through which the\n-function passes results back to the caller.\n+set of *input [slots](#slot-declarations)* as parameters, through which the\n+caller passes arguments into the function, and an *output\n+[slot](#slot-declarations)* through which the function passes results back to\n+the caller.\n \n A function may also be copied into a first class *value*, in which case the\n value has the corresponding [*function type*](#function-types), and can be\n@@ -1020,9 +1018,10 @@ accessed through the components `x` and `y`, and laid out in memory with the\n \n ### Enumerations\n \n-An _enumeration item_ simultaneously declares a new nominal [enumerated\n-type](#enumerated-type) as well as a set of *constructors* that can be used to\n-create or pattern-match values of the corresponding enumerated type.\n+An _enumeration item_ simultaneously declares a new nominal\n+[enumerated type](#enumerated-types) as well as a set of *constructors* that\n+can be used to create or pattern-match values of the corresponding enumerated\n+type.\n \n The constructors of an `enum` type may be recursive: that is, each constructor\n may take an argument that refers, directly or indirectly, to the enumerated\n@@ -1282,13 +1281,14 @@ sequence expression evaluation.\n ## Statements\n \n A _statement_ is a component of a block, which is in turn a component of an\n-outer [block-expression](#block-expressions) or [function](#functions). When a\n-function is spawned into a [task](#tasks), the task *executes* statements in\n-an order determined by the body of the enclosing function. Each statement\n-causes the task to perform certain actions.\n+outer [expression](#expressions) or [function](#functions). When a function is\n+spawned into a [task](#tasks), the task *executes* statements in an order\n+determined by the body of the enclosing function. Each statement causes the\n+task to perform certain actions.\n \n-Rust has two kinds of statement: [declarations](#declarations) and\n-[expressions](#expressions).\n+Rust has two kinds of statement:\n+[declaration statements](#declaration-statements) and\n+[expression statements](#expression-statements).\n \n A declaration serves to introduce a *name* that can be used in the block\n *scope* enclosing the statement: all statements before and after the\n@@ -1310,9 +1310,8 @@ arbitrary depth.\n \n ### Declaration statements\n \n-A _declaration statement_ is one that introduces a *name* into the\n-enclosing statement block. The declared name may denote a new slot or a new\n-item.\n+A _declaration statement_ is one that introduces a *name* into the enclosing\n+statement block. The declared name may denote a new slot or a new item.\n \n #### Item declarations\n \n@@ -1352,7 +1351,7 @@ scope.\n The former form, with no type annotation, causes the compiler to infer the\n static type of the slot through unification with the types of values assigned\n to the slot in the remaining code in the block scope. Inference only occurs on\n-frame-local slots, not argument slots. Function signatures must\n+frame-local variable, not argument slots. Function signatures must\n always declare types for all argument slots.\n \n \n@@ -1722,11 +1721,11 @@ Evaluating a copy expression first evaluates the argument expression, then\n copies the resulting value, allocating any memory necessary to hold the new\n copy.\n \n-[Shared boxes](#shared-box-types) (type `@`) are, as usual, shallow-copied, as\n-they may be cyclic. [Unique boxes](#unique-box-types),\n-[vectors](#vector-types) and similar unique types are deep-copied.\n+[Shared boxes](#box-types) (type `@`) are, as usual, shallow-copied, as they\n+may be cyclic. [Unique boxes](#box-types), [vectors](#vector-types) and\n+similar unique types are deep-copied.\n \n-Since the binary [assignment operator](#assignment-operator) `=` performs a\n+Since the binary [assignment operator](#assignment-expressions) `=` performs a\n copy implicitly, the unary copy operator is typically only used to cause an\n argument to a function to be copied and passed by value.\n \n@@ -1826,7 +1825,7 @@ bound slot in the bound function's signature, space is allocated in the hidden\n tuple and populated with a copy of the bound value.\n \n A `bind` expression is an alternative way of constructing a shared function\n-closure; the [`fn@` expression](#shared-function-expression) form is another\n+closure; the [`fn@` expression](#shared-function-expressions) form is another\n way.\n \n ### Shared function expressions\n@@ -1966,8 +1965,8 @@ patterns must equal the type of the head expression.\n To execute an `alt` expression, first the head expression is evaluated, then\n its value is sequentially compared to the patterns in the arms until a match\n is found. The first arm with a matching pattern is chosen as the branch target\n-of the `alt`, any variables bound by the pattern are assigned to local slots\n-in the arm's block, and control enters the block.\n+of the `alt`, any variables bound by the pattern are assigned to local\n+variables in the arm's block, and control enters the block.\n \n An example of an `alt` expression:\n \n@@ -2378,11 +2377,11 @@ Future versions of Rust will address these issues.\n \n # Types and typestates\n \n-## Type system\n+## Types\n \n Every slot and value in a Rust program has a type. The _type_ of a *value*\n defines the interpretation of the memory holding it. The type of a *slot* may\n-also include [constraints](#constrained-types).\n+also include [constraints](#constraints).\n \n Built-in types and type-constructors are tightly integrated into the language,\n in nontrivial ways that are not possible to emulate in user-defined\n@@ -2457,7 +2456,6 @@ A value of type `str` is a Unicode string, represented as a vector of 8-bit\n unsigned bytes holding a sequence of UTF-8 codepoints.\n \n \n-\n ### Record types\n \n The record type-constructor forms a new heterogeneous product of values.^[The\n@@ -2568,8 +2566,8 @@ Unsafe pointers (`*`)\n ### Function types\n \n The function type-constructor `fn` forms new function types. A function type\n-consists of a sequence of input slots, an optional set of [input\n-constraints](#input-constraints) and an output slot.\n+consists of a sequence of input slots, an optional set of\n+[input constraints](#constraints) and an output slot.\n \n An example of a `fn` type:\n \n@@ -2916,23 +2914,23 @@ references to any boxes; the remainder of its heap is immediately freed.\n \n A task's stack contains slots.\n \n-A _slot_ is a component of a stack frame. A slot is either *local* or\n-a *reference*.\n+A _slot_ is a component of a stack frame. A slot is either a *local variable*\n+or a *reference*.\n \n-A _local_ slot (or *stack-local* allocation) holds a value directly,\n+A _local variable_ (or *stack-local* allocation) holds a value directly,\n allocated within the stack's memory. The value is a part of the stack frame.\n \n A _reference_ references a value outside the frame. It may refer to a\n value allocated in another frame *or* a boxed value in the heap. The\n reference-formation rules ensure that the referent will outlive the reference.\n \n-Local slots are always implicitly mutable.\n+Local variables are always implicitly mutable.\n \n-Local slots are not initialized when allocated; the entire frame worth of\n-local slots are allocated at once, on frame-entry, in an uninitialized\n+Local variables are not initialized when allocated; the entire frame worth of\n+local variables are allocated at once, on frame-entry, in an uninitialized\n state. Subsequent statements within a function may or may not initialize the\n-local slots. Local slots can be used only after they have been initialized;\n-this condition is guaranteed by the typestate system.\n+local variables. Local variables can be used only after they have been\n+initialized; this condition is guaranteed by the typestate system.\n \n References are created for function arguments. If the compiler can not prove\n that the referred-to value will outlive the reference, it will try to set\n@@ -3198,7 +3196,6 @@ Receiving a value is done by a call to the `recv` method on a value of type\n `core::comm::port`. This call causes the receiving task to enter the *blocked\n reading* state until a value arrives in the port's receive queue, at which\n time the port deques a value to return, and un-blocks the receiving task.\n-See [communication system](#communication-system).\n \n An example of a *receive*:\n "}, {"sha": "a280ed55ba93f7699edf72d5cac9b5b9d2e806be", "filename": "src/etc/check-links.pl", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/874390831a61d0708f227bfc5a78fd167ea6d9c1/src%2Fetc%2Fcheck-links.pl", "raw_url": "https://github.com/rust-lang/rust/raw/874390831a61d0708f227bfc5a78fd167ea6d9c1/src%2Fetc%2Fcheck-links.pl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck-links.pl?ref=874390831a61d0708f227bfc5a78fd167ea6d9c1", "patch": "@@ -0,0 +1,26 @@\n+#!/usr/bin/perl -w\n+\n+my $file = $ARGV[0];\n+\n+my @lines = <>;\n+\n+my $anchors = {};\n+\n+my $i = 0;\n+foreach $line (@lines) {\n+    $i++;\n+    if ($line =~ m/id=\"([^\"]+)\"/) { \n+        $anchors->{$1} = $i;\n+    }\n+}\n+\n+$i = 0;\n+foreach $line (@lines) {\n+    $i++;\n+    while ($line =~ m/href=\"#([^\"]+)\"/g) { \n+        if (! exists($anchors->{$1})) {\n+            print \"$file:$i: $1 referenced\\n\";\n+        }\n+    }\n+}\n+"}]}