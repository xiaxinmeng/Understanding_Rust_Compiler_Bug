{"sha": "769c6c742a9fe956d4d988aac252d1be92a3cff4", "node_id": "C_kwDOAAsO6NoAKDc2OWM2Yzc0MmE5ZmU5NTZkNGQ5ODhhYWMyNTJkMWJlOTJhM2NmZjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-22T08:43:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-22T08:43:33Z"}, "message": "Auto merge of #2254 - dtolnay-contrib:rustfmt6, r=oli-obk\n\nFormat tests with rustfmt (276-287 of 299)\n\nExtracted from #2097.\n\nThis is one half of the last 24 files (left for last because they require more unique attention than the first 275 \"easy\" files).\n\nI'll comment below to call attention to cases where I exercised my own judgement in how to format the test.\n\nhttps://github.com/rust-lang/rustfmt/issues/3255 is especially annoying: rustfmt does not like `\u2026( //` and `\u2026{ //`.", "tree": {"sha": "610d1d5a72f327b7b4b62aaed854b5d1a715bcb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/610d1d5a72f327b7b4b62aaed854b5d1a715bcb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/769c6c742a9fe956d4d988aac252d1be92a3cff4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/769c6c742a9fe956d4d988aac252d1be92a3cff4", "html_url": "https://github.com/rust-lang/rust/commit/769c6c742a9fe956d4d988aac252d1be92a3cff4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/769c6c742a9fe956d4d988aac252d1be92a3cff4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a1b08e46eb106480cbb0bc0a70521f273f045aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a1b08e46eb106480cbb0bc0a70521f273f045aa", "html_url": "https://github.com/rust-lang/rust/commit/7a1b08e46eb106480cbb0bc0a70521f273f045aa"}, {"sha": "05893d90269c6cbea4428b570bcfd09c1cb7c063", "url": "https://api.github.com/repos/rust-lang/rust/commits/05893d90269c6cbea4428b570bcfd09c1cb7c063", "html_url": "https://github.com/rust-lang/rust/commit/05893d90269c6cbea4428b570bcfd09c1cb7c063"}], "stats": {"total": 522, "additions": 280, "deletions": 242}, "files": [{"sha": "7e1b969e02cf60badcb5d586bb459906e448dbd5", "filename": "tests/fail/branchless-select-i128-pointer.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fbranchless-select-i128-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fbranchless-select-i128-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbranchless-select-i128-pointer.rs?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -11,8 +11,10 @@ fn main() {\n         // This is branchless code to select one or the other pointer.\n         // However, it drops provenance when transmuting to TwoPtrs, so this is UB.\n         let val = unsafe {\n-            transmute::<_, &str>( //~ERROR type validation failed: encountered a dangling reference\n-                !mask & transmute::<_, TwoPtrs>(\"false !\") | mask & transmute::<_, TwoPtrs>(\"true !\"),\n+            transmute::<_, &str>(\n+                //~^ ERROR type validation failed: encountered a dangling reference\n+                !mask & transmute::<_, TwoPtrs>(\"false !\")\n+                    | mask & transmute::<_, TwoPtrs>(\"true !\"),\n             )\n         };\n         println!(\"{}\", val);"}, {"sha": "374d6ab06809109d59008badbfd2c82fa54e70e0", "filename": "tests/fail/branchless-select-i128-pointer.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fbranchless-select-i128-pointer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fbranchless-select-i128-pointer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fbranchless-select-i128-pointer.stderr?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -2,7 +2,9 @@ error: Undefined Behavior: type validation failed: encountered a dangling refere\n   --> $DIR/branchless-select-i128-pointer.rs:LL:CC\n    |\n LL | /             transmute::<_, &str>(\n-LL | |                 !mask & transmute::<_, TwoPtrs>(\"false !\") | mask & transmute::<_, TwoPtrs>(\"true !\"),\n+LL | |\n+LL | |                 !mask & transmute::<_, TwoPtrs>(\"false !\")\n+LL | |                     | mask & transmute::<_, TwoPtrs>(\"true !\"),\n LL | |             )\n    | |_____________^ type validation failed: encountered a dangling reference (address $HEX is unallocated)\n    |"}, {"sha": "555700a75d3aec5e71d31555ed1bf24a5bb285aa", "filename": "tests/fail/data_race/dealloc_read_race1.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -19,11 +19,16 @@ pub fn main() {\n \n     unsafe {\n         let j1 = spawn(move || {\n-            *ptr.0\n+            let _val = *ptr.0;\n         });\n \n         let j2 = spawn(move || {\n-            __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>());  //~ ERROR Data race detected between Deallocate on Thread(id = 2) and Read on Thread(id = 1)\n+            __rust_dealloc(\n+                //~^ ERROR Data race detected between Deallocate on Thread(id = 2) and Read on Thread(id = 1)\n+                ptr.0 as *mut _,\n+                std::mem::size_of::<usize>(),\n+                std::mem::align_of::<usize>(),\n+            );\n         });\n \n         j1.join().unwrap();"}, {"sha": "91a681e74450576c503f246a5dd9266142a12123", "filename": "tests/fail/data_race/dealloc_read_race1.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -1,8 +1,13 @@\n error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dealloc_read_race1.rs:LL:CC\n    |\n-LL |             __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>());\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Deallocate on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+LL | /             __rust_dealloc(\n+LL | |\n+LL | |                 ptr.0 as *mut _,\n+LL | |                 std::mem::size_of::<usize>(),\n+LL | |                 std::mem::align_of::<usize>(),\n+LL | |             );\n+   | |_____________^ Data race detected between Deallocate on Thread(id = 2) and Read on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "44078a044a7f8f67348379d580dd70c09fa0226f", "filename": "tests/fail/data_race/dealloc_write_race1.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -22,7 +22,12 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>());  //~ ERROR Data race detected between Deallocate on Thread(id = 2) and Write on Thread(id = 1)\n+            __rust_dealloc(\n+                //~^ ERROR Data race detected between Deallocate on Thread(id = 2) and Write on Thread(id = 1)\n+                ptr.0 as *mut _,\n+                std::mem::size_of::<usize>(),\n+                std::mem::align_of::<usize>(),\n+            );\n         });\n \n         j1.join().unwrap();"}, {"sha": "dc1a6ed267c6b1d0fefaa2398b52e9408497783a", "filename": "tests/fail/data_race/dealloc_write_race1.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -1,8 +1,13 @@\n error: Undefined Behavior: Data race detected between Deallocate on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n   --> $DIR/dealloc_write_race1.rs:LL:CC\n    |\n-LL |             __rust_dealloc(ptr.0 as *mut _, std::mem::size_of::<usize>(), std::mem::align_of::<usize>());\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Deallocate on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n+LL | /             __rust_dealloc(\n+LL | |\n+LL | |                 ptr.0 as *mut _,\n+LL | |                 std::mem::size_of::<usize>(),\n+LL | |                 std::mem::align_of::<usize>(),\n+LL | |             );\n+   | |_____________^ Data race detected between Deallocate on Thread(id = 2) and Write on Thread(id = 1) at ALLOC (current vector clock = VClock, conflicting timestamp = VClock)\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "0a5a2d48d2743ee68e9f9d7bcc0b0fac3fa3c6d8", "filename": "tests/fail/function_calls/check_callback_abi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ffunction_calls%2Fcheck_callback_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ffunction_calls%2Fcheck_callback_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ffunction_calls%2Fcheck_callback_abi.rs?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -8,7 +8,8 @@ fn main() {\n     unsafe {\n         // Make sure we check the ABI when Miri itself invokes a function\n         // as part of a shim implementation.\n-        std::intrinsics::r#try( //~ ERROR calling a function with ABI C using caller ABI Rust\n+        std::intrinsics::r#try(\n+            //~^ ERROR calling a function with ABI C using caller ABI Rust\n             std::mem::transmute::<extern \"C\" fn(*mut u8), _>(try_fn),\n             std::ptr::null_mut(),\n             |_, _| unreachable!(),"}, {"sha": "56314e6d285930dacfad6ddda8127102b6527a3d", "filename": "tests/fail/function_calls/check_callback_abi.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ffunction_calls%2Fcheck_callback_abi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ffunction_calls%2Fcheck_callback_abi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ffunction_calls%2Fcheck_callback_abi.stderr?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -2,6 +2,7 @@ error: Undefined Behavior: calling a function with ABI C using caller ABI Rust\n   --> $DIR/check_callback_abi.rs:LL:CC\n    |\n LL | /         std::intrinsics::r#try(\n+LL | |\n LL | |             std::mem::transmute::<extern \"C\" fn(*mut u8), _>(try_fn),\n LL | |             std::ptr::null_mut(),\n LL | |             |_, _| unreachable!(),"}, {"sha": "dee7f66e0ad9cd2d986a2ae6c3d2710718a357cc", "filename": "tests/fail/function_calls/exported_symbol_abi_mismatch.cache.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.cache.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.cache.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.cache.stderr?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: calling a function with calling convention Rust using calling convention C\n   --> $DIR/exported_symbol_abi_mismatch.rs:LL:CC\n    |\n-LL |         unsafe { foo() }\n-   |                  ^^^^^ calling a function with calling convention Rust using calling convention C\n+LL |             foo();\n+   |             ^^^^^ calling a function with calling convention Rust using calling convention C\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "ebe19796609cf66dd2cbff9c9431e293dd245818", "filename": "tests/fail/function_calls/exported_symbol_abi_mismatch.fn_ptr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.fn_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.fn_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.fn_ptr.stderr?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: calling a function with calling convention Rust using calling convention C\n   --> $DIR/exported_symbol_abi_mismatch.rs:LL:CC\n    |\n-LL |     unsafe { std::mem::transmute::<unsafe fn(), unsafe extern \"C\" fn()>(foo)() }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ calling a function with calling convention Rust using calling convention C\n+LL |         std::mem::transmute::<unsafe fn(), unsafe extern \"C\" fn()>(foo)();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ calling a function with calling convention Rust using calling convention C\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "dee7f66e0ad9cd2d986a2ae6c3d2710718a357cc", "filename": "tests/fail/function_calls/exported_symbol_abi_mismatch.no_cache.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.no_cache.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.no_cache.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.no_cache.stderr?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: calling a function with calling convention Rust using calling convention C\n   --> $DIR/exported_symbol_abi_mismatch.rs:LL:CC\n    |\n-LL |         unsafe { foo() }\n-   |                  ^^^^^ calling a function with calling convention Rust using calling convention C\n+LL |             foo();\n+   |             ^^^^^ calling a function with calling convention Rust using calling convention C\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "c337e1f29f16fe6ca77cc86089835ec0436bd32a", "filename": "tests/fail/function_calls/exported_symbol_abi_mismatch.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ffunction_calls%2Fexported_symbol_abi_mismatch.rs?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -10,20 +10,26 @@ fn main() {\n     }\n \n     #[cfg(fn_ptr)]\n-    unsafe { std::mem::transmute::<unsafe fn(), unsafe extern \"C\" fn()>(foo)() }\n-    //[fn_ptr]~^ ERROR calling a function with calling convention Rust using calling convention C\n+    unsafe {\n+        std::mem::transmute::<unsafe fn(), unsafe extern \"C\" fn()>(foo)();\n+        //[fn_ptr]~^ ERROR calling a function with calling convention Rust using calling convention C\n+    }\n \n     // `Instance` caching should not suppress ABI check.\n     #[cfg(cache)]\n-    unsafe { foo() }\n+    unsafe {\n+        foo();\n+    }\n \n     {\n         #[cfg_attr(any(cache, fn_ptr), allow(clashing_extern_declarations))]\n         extern \"C\" {\n             fn foo();\n         }\n-        unsafe { foo() }\n-        //[no_cache]~^ ERROR calling a function with calling convention Rust using calling convention C\n-        //[cache]~^^ ERROR calling a function with calling convention Rust using calling convention C\n+        unsafe {\n+            foo();\n+            //[no_cache]~^ ERROR calling a function with calling convention Rust using calling convention C\n+            //[cache]~| ERROR calling a function with calling convention Rust using calling convention C\n+        }\n     }\n }"}, {"sha": "08f7a49b0255cdb6fa49edd544b8d63b6b2ad59b", "filename": "tests/fail/type-too-large.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ftype-too-large.rs", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ftype-too-large.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ftype-too-large.rs?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -1,6 +1,6 @@\n // ignore-32bit\n \n fn main() {\n-    let _fat: [u8; (1<<61)+(1<<31)] =\n-        [0; (1u64<<61) as usize +(1u64<<31) as usize]; //~ ERROR post-monomorphization error\n+    let _fat: [u8; (1 << 61) + (1 << 31)];\n+    _fat = [0; (1u64 << 61) as usize + (1u64 << 31) as usize]; //~ ERROR post-monomorphization error\n }"}, {"sha": "cb1d725ec878c3a936b79386ab5698a072ca6838", "filename": "tests/fail/type-too-large.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ftype-too-large.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Ftype-too-large.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Ftype-too-large.stderr?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -1,8 +1,8 @@\n error: post-monomorphization error: values of the type `[u8; 2305843011361177600]` are too big for the current architecture\n   --> $DIR/type-too-large.rs:LL:CC\n    |\n-LL |         [0; (1u64<<61) as usize +(1u64<<31) as usize];\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ values of the type `[u8; 2305843011361177600]` are too big for the current architecture\n+LL |     _fat = [0; (1u64 << 61) as usize + (1u64 << 31) as usize];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ values of the type `[u8; 2305843011361177600]` are too big for the current architecture\n    |\n    = note: inside `main` at $DIR/type-too-large.rs:LL:CC\n "}, {"sha": "80749fd7c7916c2823acb97097364bbdc23e8227", "filename": "tests/fail/validity/invalid_char.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fvalidity%2Finvalid_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Ffail%2Fvalidity%2Finvalid_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fvalidity%2Finvalid_char.rs?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -1,8 +1,9 @@\n fn main() {\n     assert!(std::char::from_u32(-1_i32 as u32).is_none());\n-    let _val = match unsafe { std::mem::transmute::<i32, char>(-1) } { //~ ERROR encountered 0xffffffff, but expected a valid unicode scalar value\n-        'a' => {true},\n-        'b' => {false},\n-        _ => {true},\n+    let _val = match unsafe { std::mem::transmute::<i32, char>(-1) } {\n+        //~^ ERROR encountered 0xffffffff, but expected a valid unicode scalar value\n+        'a' => true,\n+        'b' => false,\n+        _ => true,\n     };\n }"}, {"sha": "0f798d2b575e08039d6243bfcaa21c69202998ca", "filename": "tests/pass/0weak_memory_consistency.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Fpass%2F0weak_memory_consistency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Fpass%2F0weak_memory_consistency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2F0weak_memory_consistency.rs?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -54,12 +54,13 @@ fn test_corr() {\n         x.store(2, Relaxed);\n     });\n \n+    #[rustfmt::skip]\n     let j2 = spawn(move || {\n         let r2 = x.load(Relaxed); // -------------------------------------+\n         y.store(1, Release); // ---------------------+                    |\n         r2 //                                        |                    |\n     }); //                                           |                    |\n-    //                                               |synchronizes-with   |happens-before\n+    #[rustfmt::skip] //                              |synchronizes-with   |happens-before\n     let j3 = spawn(move || { //                      |                    |\n         acquires_value(&y, 1); // <------------------+                    |\n         x.load(Relaxed) // <----------------------------------------------+\n@@ -80,15 +81,16 @@ fn test_wrc() {\n     let x = static_atomic(0);\n     let y = static_atomic(0);\n \n+    #[rustfmt::skip]\n     let j1 = spawn(move || {\n         x.store(1, Release); // ---------------------+---------------------+\n     }); //                                           |                     |\n-    //                                               |synchronizes-with    |\n+    #[rustfmt::skip] //                              |synchronizes-with    |\n     let j2 = spawn(move || { //                      |                     |\n         acquires_value(&x, 1); // <------------------+                     |\n         y.store(1, Release); // ---------------------+                     |happens-before\n     }); //                                           |                     |\n-    //                                               |synchronizes-with    |\n+    #[rustfmt::skip] //                              |synchronizes-with    |\n     let j3 = spawn(move || { //                      |                     |\n         acquires_value(&y, 1); // <------------------+                     |\n         x.load(Relaxed) // <-----------------------------------------------+\n@@ -107,11 +109,12 @@ fn test_message_passing() {\n     let x = EvilSend(ptr);\n     let y = static_atomic(0);\n \n+    #[rustfmt::skip]\n     let j1 = spawn(move || {\n         unsafe { *x.0 = 1 }; // -----------------------------------------+\n         y.store(1, Release); // ---------------------+                   |\n     }); //                                           |                   |\n-    //                                               |synchronizes-with  | happens-before\n+    #[rustfmt::skip] //                              |synchronizes-with  | happens-before\n     let j2 = spawn(move || { //                      |                   |\n         acquires_value(&y, 1); // <------------------+                   |\n         unsafe { *x.0 } // <---------------------------------------------+"}, {"sha": "2c60df1ee138a68163c96406334d9f573d0240c0", "filename": "tests/pass/concurrency/linux-futex.rs", "status": "modified", "additions": 99, "deletions": 90, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -16,25 +16,23 @@ fn wake_nobody() {\n \n     // Wake 1 waiter. Expect zero waiters woken up, as nobody is waiting.\n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &futex as *const i32,\n-            libc::FUTEX_WAKE,\n-            1,\n-        ), 0);\n+        assert_eq!(libc::syscall(libc::SYS_futex, &futex as *const i32, libc::FUTEX_WAKE, 1), 0);\n     }\n \n     // Same, but without omitting the unused arguments.\n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &futex as *const i32,\n-            libc::FUTEX_WAKE,\n-            1,\n-            ptr::null::<libc::timespec>(),\n-            0usize,\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &futex as *const i32,\n+                libc::FUTEX_WAKE,\n+                1,\n+                ptr::null::<libc::timespec>(),\n+                0usize,\n+                0,\n+            ),\n             0,\n-        ), 0);\n+        );\n     }\n }\n \n@@ -45,12 +43,7 @@ fn wake_dangling() {\n \n     // Wake 1 waiter. Expect zero waiters woken up, as nobody is waiting.\n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            ptr,\n-            libc::FUTEX_WAKE,\n-            1,\n-        ), 0);\n+        assert_eq!(libc::syscall(libc::SYS_futex, ptr, libc::FUTEX_WAKE, 1), 0);\n     }\n }\n \n@@ -59,13 +52,16 @@ fn wait_wrong_val() {\n \n     // Only wait if the futex value is 456.\n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &futex as *const i32,\n-            libc::FUTEX_WAIT,\n-            456,\n-            ptr::null::<libc::timespec>(),\n-        ), -1);\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &futex as *const i32,\n+                libc::FUTEX_WAIT,\n+                456,\n+                ptr::null::<libc::timespec>(),\n+            ),\n+            -1,\n+        );\n         assert_eq!(*libc::__errno_location(), libc::EAGAIN);\n     }\n }\n@@ -77,16 +73,16 @@ fn wait_timeout() {\n \n     // Wait for 200ms, with nobody waking us up early.\n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &futex as *const i32,\n-            libc::FUTEX_WAIT,\n-            123,\n-            &libc::timespec {\n-                tv_sec: 0,\n-                tv_nsec: 200_000_000,\n-            },\n-        ), -1);\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &futex as *const i32,\n+                libc::FUTEX_WAIT,\n+                123,\n+                &libc::timespec { tv_sec: 0, tv_nsec: 200_000_000 },\n+            ),\n+            -1,\n+        );\n         assert_eq!(*libc::__errno_location(), libc::ETIMEDOUT);\n     }\n \n@@ -114,15 +110,18 @@ fn wait_absolute_timeout() {\n \n     // Wait for 200ms from now, with nobody waking us up early.\n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &futex as *const i32,\n-            libc::FUTEX_WAIT_BITSET,\n-            123,\n-            &timeout,\n-            0usize,\n-            u32::MAX,\n-        ), -1);\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &futex as *const i32,\n+                libc::FUTEX_WAIT_BITSET,\n+                123,\n+                &timeout,\n+                0usize,\n+                u32::MAX,\n+            ),\n+            -1,\n+        );\n         assert_eq!(*libc::__errno_location(), libc::ETIMEDOUT);\n     }\n \n@@ -137,23 +136,29 @@ fn wait_wake() {\n     let t = thread::spawn(move || {\n         thread::sleep(Duration::from_millis(200));\n         unsafe {\n-            assert_eq!(libc::syscall(\n-                libc::SYS_futex,\n-                &FUTEX as *const i32,\n-                libc::FUTEX_WAKE,\n-                10, // Wake up at most 10 threads.\n-            ), 1); // Woken up one thread.\n+            assert_eq!(\n+                libc::syscall(\n+                    libc::SYS_futex,\n+                    &FUTEX as *const i32,\n+                    libc::FUTEX_WAKE,\n+                    10, // Wake up at most 10 threads.\n+                ),\n+                1, // Woken up one thread.\n+            );\n         }\n     });\n \n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &FUTEX as *const i32,\n-            libc::FUTEX_WAIT,\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &FUTEX as *const i32,\n+                libc::FUTEX_WAIT,\n+                0,\n+                ptr::null::<libc::timespec>(),\n+            ),\n             0,\n-            ptr::null::<libc::timespec>(),\n-        ), 0);\n+        );\n     }\n \n     assert!((200..1000).contains(&start.elapsed().as_millis()));\n@@ -168,40 +173,49 @@ fn wait_wake_bitset() {\n     let t = thread::spawn(move || {\n         thread::sleep(Duration::from_millis(200));\n         unsafe {\n-            assert_eq!(libc::syscall(\n-                libc::SYS_futex,\n-                &FUTEX as *const i32,\n-                libc::FUTEX_WAKE_BITSET,\n-                10, // Wake up at most 10 threads.\n-                ptr::null::<libc::timespec>(),\n-                0usize,\n-                0b1001, // bitset\n-            ), 0); // Didn't match any thread.\n+            assert_eq!(\n+                libc::syscall(\n+                    libc::SYS_futex,\n+                    &FUTEX as *const i32,\n+                    libc::FUTEX_WAKE_BITSET,\n+                    10, // Wake up at most 10 threads.\n+                    ptr::null::<libc::timespec>(),\n+                    0usize,\n+                    0b1001, // bitset\n+                ),\n+                0, // Didn't match any thread.\n+            );\n         }\n         thread::sleep(Duration::from_millis(200));\n         unsafe {\n-            assert_eq!(libc::syscall(\n-                libc::SYS_futex,\n-                &FUTEX as *const i32,\n-                libc::FUTEX_WAKE_BITSET,\n-                10, // Wake up at most 10 threads.\n-                ptr::null::<libc::timespec>(),\n-                0usize,\n-                0b0110, // bitset\n-            ), 1); // Woken up one thread.\n+            assert_eq!(\n+                libc::syscall(\n+                    libc::SYS_futex,\n+                    &FUTEX as *const i32,\n+                    libc::FUTEX_WAKE_BITSET,\n+                    10, // Wake up at most 10 threads.\n+                    ptr::null::<libc::timespec>(),\n+                    0usize,\n+                    0b0110, // bitset\n+                ),\n+                1, // Woken up one thread.\n+            );\n         }\n     });\n \n     unsafe {\n-        assert_eq!(libc::syscall(\n-            libc::SYS_futex,\n-            &FUTEX as *const i32,\n-            libc::FUTEX_WAIT_BITSET,\n+        assert_eq!(\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &FUTEX as *const i32,\n+                libc::FUTEX_WAIT_BITSET,\n+                0,\n+                ptr::null::<libc::timespec>(),\n+                0usize,\n+                0b0100, // bitset\n+            ),\n             0,\n-            ptr::null::<libc::timespec>(),\n-            0usize,\n-            0b0100, // bitset\n-        ), 0);\n+        );\n     }\n \n     assert!((400..1000).contains(&start.elapsed().as_millis()));\n@@ -237,12 +251,7 @@ fn concurrent_wait_wake() {\n \n         FUTEX.store(FREE, Ordering::Relaxed);\n         unsafe {\n-            libc::syscall(\n-                libc::SYS_futex,\n-                &FUTEX as *const AtomicI32,\n-                libc::FUTEX_WAKE,\n-                1,\n-            );\n+            libc::syscall(libc::SYS_futex, &FUTEX as *const AtomicI32, libc::FUTEX_WAKE, 1);\n         }\n \n         t.join().unwrap();"}, {"sha": "4803792a97ceea462741aa00475e07129f0d1426", "filename": "tests/pass/deriving-associated-types.rs", "status": "modified", "additions": 37, "deletions": 76, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Fpass%2Fderiving-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Fpass%2Fderiving-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fderiving-associated-types.rs?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -40,10 +40,15 @@ struct TupleStruct<A, B: DeclaredTrait, C>(\n     <C as WhereTrait>::Type,\n     Option<<C as WhereTrait>::Type>,\n     <i32 as DeclaredTrait>::Type,\n-) where C: WhereTrait;\n+)\n+where\n+    C: WhereTrait;\n \n #[derive(PartialEq, Debug)]\n-pub struct Struct<A, B: DeclaredTrait, C> where C: WhereTrait {\n+pub struct Struct<A, B: DeclaredTrait, C>\n+where\n+    C: WhereTrait,\n+{\n     m1: module::Type,\n     m2: Option<module::Type>,\n     a1: A,\n@@ -62,7 +67,10 @@ pub struct Struct<A, B: DeclaredTrait, C> where C: WhereTrait {\n }\n \n #[derive(PartialEq, Debug)]\n-enum Enum<A, B: DeclaredTrait, C> where C: WhereTrait {\n+enum Enum<A, B: DeclaredTrait, C>\n+where\n+    C: WhereTrait,\n+{\n     Unit,\n     Seq(\n         module::Type,\n@@ -101,35 +109,11 @@ enum Enum<A, B: DeclaredTrait, C> where C: WhereTrait {\n }\n \n fn main() {\n-\n-    let e: Enum<\n-        i32,\n-        i32,\n-        i32,\n-    > = Enum::Seq(\n-        0,\n-        None,\n-        0,\n-        PrivateStruct(0),\n-        0,\n-        0,\n-        None,\n-        0,\n-        None,\n-        0,\n-        0,\n-        None,\n-        0,\n-        None,\n-        0,\n-    );\n+    let e: Enum<i32, i32, i32> =\n+        Enum::Seq(0, None, 0, PrivateStruct(0), 0, 0, None, 0, None, 0, 0, None, 0, None, 0);\n     assert_eq!(e, e);\n \n-    let e: Enum<\n-        i32,\n-        i32,\n-        i32,\n-    > = Enum::Map {\n+    let e: Enum<i32, i32, i32> = Enum::Map {\n         m1: 0,\n         m2: None,\n         a1: 0,\n@@ -147,52 +131,29 @@ fn main() {\n         d: 0,\n     };\n     assert_eq!(e, e);\n-        let e: TupleStruct<\n-            i32,\n-            i32,\n-            i32,\n-        > = TupleStruct(\n-            0,\n-            None,\n-            0,\n-            PrivateStruct(0),\n-            0,\n-            0,\n-            None,\n-            0,\n-            None,\n-            0,\n-            0,\n-            None,\n-            0,\n-            None,\n-            0,\n-        );\n-        assert_eq!(e, e);\n+    let e: TupleStruct<i32, i32, i32> =\n+        TupleStruct(0, None, 0, PrivateStruct(0), 0, 0, None, 0, None, 0, 0, None, 0, None, 0);\n+    assert_eq!(e, e);\n \n-        let e: Struct<\n-            i32,\n-            i32,\n-            i32,\n-        > = Struct {\n-            m1: 0,\n-            m2: None,\n-            a1: 0,\n-            a2: PrivateStruct(0),\n-            b: 0,\n-            b1: 0,\n-            b2: None,\n-            b3: 0,\n-            b4: None,\n-            c: 0,\n-            c1: 0,\n-            c2: None,\n-            c3: 0,\n-            c4: None,\n-            d: 0,\n-        };\n-        assert_eq!(e, e);\n+    let e: Struct<i32, i32, i32> = Struct {\n+        m1: 0,\n+        m2: None,\n+        a1: 0,\n+        a2: PrivateStruct(0),\n+        b: 0,\n+        b1: 0,\n+        b2: None,\n+        b3: 0,\n+        b4: None,\n+        c: 0,\n+        c1: 0,\n+        c2: None,\n+        c3: 0,\n+        c4: None,\n+        d: 0,\n+    };\n+    assert_eq!(e, e);\n \n-        let e = Enum::Unit::<i32, i32, i32>;\n-        assert_eq!(e, e);\n+    let e = Enum::Unit::<i32, i32, i32>;\n+    assert_eq!(e, e);\n }"}, {"sha": "2c38dcb49f1cee993951ea62e4bcaed30bffdcff", "filename": "tests/pass/heap_allocator.rs", "status": "modified", "additions": 68, "deletions": 37, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Fpass%2Fheap_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Fpass%2Fheap_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fheap_allocator.rs?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -1,58 +1,89 @@\n #![feature(allocator_api, slice_ptr_get)]\n \n+use std::alloc::{Allocator, Global, Layout, System};\n use std::ptr::NonNull;\n-use std::alloc::{Global, Allocator, Layout, System};\n use std::slice;\n \n-fn check_alloc<T: Allocator>(allocator: T) { unsafe {\n-    for &align in &[4, 8, 16, 32] {\n-        let layout_20 = Layout::from_size_align(20, align).unwrap();\n-        let layout_40 = Layout::from_size_align(40, 4*align).unwrap();\n-        let layout_10 = Layout::from_size_align(10, align/2).unwrap();\n+fn check_alloc<T: Allocator>(allocator: T) {\n+    unsafe {\n+        for &align in &[4, 8, 16, 32] {\n+            let layout_20 = Layout::from_size_align(20, align).unwrap();\n+            let layout_40 = Layout::from_size_align(40, 4 * align).unwrap();\n+            let layout_10 = Layout::from_size_align(10, align / 2).unwrap();\n \n-        for _ in 0..32 {\n-            let a = allocator.allocate(layout_20).unwrap().as_non_null_ptr();\n-            assert_eq!(a.as_ptr() as usize % layout_20.align(), 0, \"pointer is incorrectly aligned\");\n-            allocator.deallocate(a, layout_20);\n-        }\n+            for _ in 0..32 {\n+                let a = allocator.allocate(layout_20).unwrap().as_non_null_ptr();\n+                assert_eq!(\n+                    a.as_ptr() as usize % layout_20.align(),\n+                    0,\n+                    \"pointer is incorrectly aligned\",\n+                );\n+                allocator.deallocate(a, layout_20);\n+            }\n \n-        let p1 = allocator.allocate_zeroed(layout_20).unwrap().as_non_null_ptr();\n-        assert_eq!(p1.as_ptr() as usize % layout_20.align(), 0, \"pointer is incorrectly aligned\");\n-        assert_eq!(*p1.as_ptr(), 0);\n+            let p1 = allocator.allocate_zeroed(layout_20).unwrap().as_non_null_ptr();\n+            assert_eq!(\n+                p1.as_ptr() as usize % layout_20.align(),\n+                0,\n+                \"pointer is incorrectly aligned\",\n+            );\n+            assert_eq!(*p1.as_ptr(), 0);\n \n-        // old size < new size\n-        let p2 = allocator.grow(p1, layout_20, layout_40).unwrap().as_non_null_ptr();\n-        assert_eq!(p2.as_ptr() as usize % layout_40.align(), 0, \"pointer is incorrectly aligned\");\n-        let slice = slice::from_raw_parts(p2.as_ptr(), 20);\n-        assert_eq!(&slice, &[0_u8; 20]);\n+            // old size < new size\n+            let p2 = allocator.grow(p1, layout_20, layout_40).unwrap().as_non_null_ptr();\n+            assert_eq!(\n+                p2.as_ptr() as usize % layout_40.align(),\n+                0,\n+                \"pointer is incorrectly aligned\",\n+            );\n+            let slice = slice::from_raw_parts(p2.as_ptr(), 20);\n+            assert_eq!(&slice, &[0_u8; 20]);\n \n-        // old size == new size\n-        let p3 = allocator.grow(p2, layout_40, layout_40).unwrap().as_non_null_ptr();\n-        assert_eq!(p3.as_ptr() as usize % layout_40.align(), 0, \"pointer is incorrectly aligned\");\n-        let slice = slice::from_raw_parts(p3.as_ptr(), 20);\n-        assert_eq!(&slice, &[0_u8; 20]);\n+            // old size == new size\n+            let p3 = allocator.grow(p2, layout_40, layout_40).unwrap().as_non_null_ptr();\n+            assert_eq!(\n+                p3.as_ptr() as usize % layout_40.align(),\n+                0,\n+                \"pointer is incorrectly aligned\",\n+            );\n+            let slice = slice::from_raw_parts(p3.as_ptr(), 20);\n+            assert_eq!(&slice, &[0_u8; 20]);\n \n-        // old size > new size\n-        let p4 = allocator.shrink(p3, layout_40, layout_10).unwrap().as_non_null_ptr();\n-        assert_eq!(p4.as_ptr() as usize % layout_10.align(), 0, \"pointer is incorrectly aligned\");\n-        let slice = slice::from_raw_parts(p4.as_ptr(), 10);\n-        assert_eq!(&slice, &[0_u8; 10]);\n+            // old size > new size\n+            let p4 = allocator.shrink(p3, layout_40, layout_10).unwrap().as_non_null_ptr();\n+            assert_eq!(\n+                p4.as_ptr() as usize % layout_10.align(),\n+                0,\n+                \"pointer is incorrectly aligned\",\n+            );\n+            let slice = slice::from_raw_parts(p4.as_ptr(), 10);\n+            assert_eq!(&slice, &[0_u8; 10]);\n \n-        allocator.deallocate(p4, layout_10);\n+            allocator.deallocate(p4, layout_10);\n+        }\n     }\n-} }\n+}\n \n fn check_align_requests<T: Allocator>(allocator: T) {\n+    #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/3255\n     for &size in &[2, 8, 64] { // size less than and bigger than alignment\n         for &align in &[4, 8, 16, 32] { // Be sure to cover less than and bigger than `MIN_ALIGN` for all architectures\n             let iterations = 32;\n             unsafe {\n-                let pointers: Vec<_> = (0..iterations).map(|_| {\n-                    allocator.allocate(Layout::from_size_align(size, align).unwrap()).unwrap().as_non_null_ptr()\n-                }).collect();\n+                let pointers: Vec<_> = (0..iterations)\n+                    .map(|_| {\n+                        allocator\n+                            .allocate(Layout::from_size_align(size, align).unwrap())\n+                            .unwrap()\n+                            .as_non_null_ptr()\n+                    })\n+                    .collect();\n                 for &ptr in &pointers {\n-                    assert_eq!((ptr.as_ptr() as usize) % align, 0,\n-                            \"Got a pointer less aligned than requested\")\n+                    assert_eq!(\n+                        (ptr.as_ptr() as usize) % align,\n+                        0,\n+                        \"Got a pointer less aligned than requested\",\n+                    )\n                 }\n \n                 // Clean up.\n@@ -61,7 +92,7 @@ fn check_align_requests<T: Allocator>(allocator: T) {\n                 }\n             }\n         }\n-    }\n+    };\n }\n \n fn global_to_box() {"}, {"sha": "31d0d7442d9d2f3c144e6e6a2c9a67928f0302d5", "filename": "tests/pass/iter.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Fpass%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/769c6c742a9fe956d4d988aac252d1be92a3cff4/tests%2Fpass%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fiter.rs?ref=769c6c742a9fe956d4d988aac252d1be92a3cff4", "patch": "@@ -1,5 +1,6 @@\n fn iter_empty_and_zst() {\n-    for _ in Vec::<u32>::new().iter() { // this iterates over a Unique::empty()\n+    // Iterate over a Unique::empty()\n+    for _ in Vec::<u32>::new().iter() {\n         panic!(\"We should never be here.\");\n     }\n \n@@ -21,13 +22,13 @@ fn test_iterator_step_by_nth() {\n }\n \n fn iter_any() {\n-    let f = |x: &u8| { 10u8 == *x };\n+    let f = |x: &u8| 10u8 == *x;\n     f(&1u8);\n \n-    let g = |(), x: &u8| { 10u8 == *x };\n+    let g = |(), x: &u8| 10u8 == *x;\n     g((), &1u8);\n \n-    let h = |(), (), x: &u8| { 10u8 == *x };\n+    let h = |(), (), x: &u8| 10u8 == *x;\n     h((), (), &1u8);\n \n     [1, 2, 3u8].iter().any(|elt| 10 == *elt);"}]}