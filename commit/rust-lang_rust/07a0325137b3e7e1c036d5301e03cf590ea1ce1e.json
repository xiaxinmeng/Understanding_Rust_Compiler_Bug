{"sha": "07a0325137b3e7e1c036d5301e03cf590ea1ce1e", "node_id": "C_kwDOAAsO6NoAKDA3YTAzMjUxMzdiM2U3ZTFjMDM2ZDUzMDFlMDNjZjU5MGVhMWNlMWU", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-01-15T04:59:54Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-01-18T20:39:20Z"}, "message": "Move item-related pretty printing functions to module", "tree": {"sha": "b67b668e1ee6aada6af4db4a169a47ecb42d475f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b67b668e1ee6aada6af4db4a169a47ecb42d475f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07a0325137b3e7e1c036d5301e03cf590ea1ce1e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmHnJXgACgkQ+boUO5X/\nbYIbyA/9FLjARw1qfQ8j53nUMI2B2hK16vJE7ImwSO2aTxPfgWGYimGgJGE4J3/5\n1y9FB3Vu7u8vJQWZuz2RgFk734Q7oqXNsIucWgrmwIfP9MMqbEB04OUaxC7VK0RW\nCBtVzwQbMC1Sw1nsbGfl0Q5Zli+DxMnYUwRaVqsJm8fuQ5D3QG8wqfxi+uPvF96h\n1OnAwpf2N+Uaeckjj52KjUQaRCKCa0Gfr1OtDE8xDWo3a9XCrjqXacmV0xn8JYPw\nvBD57F0t1xytdeKA+Qt05ZAmn0rZHTuDI977ByhTpHlCaysfuJ44DucR36zhHmbo\nGUiOBTOef1wj1zlL79dXcylVM9zBGhOWGhwxsmaxpQqEflA2nNpRuXwyji3XbmMQ\nwdaKxewoZu97yyKWta5qiTO/myUx1gTM9i8d+p/ofCtbQguCOGQRAXdnXXh/HOkS\napNZF2CV/hGdQZPE26RmHccWdBmKElbfhZbRB6pgQCv1A6Y2uyT1F8Be1wV9xFaL\nAOp01n2Ro5Bw7Ll4ZFRSNVLtemyRbDN9HD+JeE4/0UFE/m7ccU0vhr0rdPElvYIC\nhxjzmhi6lFmtjC81KSNyHQ4h1uzjQZAiswT3k+pzCglSDNU78O9eAv4/rJ4+31g4\n5Psoheju5Zy/2RUIFAOSvFpc9qZL8hpE0J7rSXwb8JJc72y3gVk=\n=JaKm\n-----END PGP SIGNATURE-----", "payload": "tree b67b668e1ee6aada6af4db4a169a47ecb42d475f\nparent b1605643e3a9f62bdbe97c4854745e2f28ccd456\nauthor David Tolnay <dtolnay@gmail.com> 1642222794 -0800\ncommitter David Tolnay <dtolnay@gmail.com> 1642538360 -0800\n\nMove item-related pretty printing functions to module\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07a0325137b3e7e1c036d5301e03cf590ea1ce1e", "html_url": "https://github.com/rust-lang/rust/commit/07a0325137b3e7e1c036d5301e03cf590ea1ce1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07a0325137b3e7e1c036d5301e03cf590ea1ce1e/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1605643e3a9f62bdbe97c4854745e2f28ccd456", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1605643e3a9f62bdbe97c4854745e2f28ccd456", "html_url": "https://github.com/rust-lang/rust/commit/b1605643e3a9f62bdbe97c4854745e2f28ccd456"}], "stats": {"total": 1282, "additions": 646, "deletions": 636}, "files": [{"sha": "487451466f1f0af80fbb27ac16cd710029ac3e2e", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 2, "deletions": 636, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/07a0325137b3e7e1c036d5301e03cf590ea1ce1e/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a0325137b3e7e1c036d5301e03cf590ea1ce1e/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=07a0325137b3e7e1c036d5301e03cf590ea1ce1e", "patch": "@@ -1,4 +1,5 @@\n mod expr;\n+mod item;\n \n use crate::pp::Breaks::{Consistent, Inconsistent};\n use crate::pp::{self, Breaks};\n@@ -11,7 +12,7 @@ use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser;\n use rustc_ast::{self as ast, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use rustc_ast::{attr, Term};\n-use rustc_ast::{GenericArg, MacArgs, ModKind};\n+use rustc_ast::{GenericArg, MacArgs};\n use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n@@ -212,10 +213,6 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n     out\n }\n \n-fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n-    format!(\"{}{}\", State::to_string(|s| s.print_visibility(vis)), s)\n-}\n-\n impl std::ops::Deref for State<'_> {\n     type Target = pp::Printer;\n     fn deref(&self) -> &Self::Target {\n@@ -940,13 +937,6 @@ impl<'a> State<'a> {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(e), |e| e.span)\n     }\n \n-    crate fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[ast::Attribute]) {\n-        self.print_inner_attributes(attrs);\n-        for item in &nmod.items {\n-            self.print_foreign_item(item);\n-        }\n-    }\n-\n     pub fn print_opt_lifetime(&mut self, lifetime: &Option<ast::Lifetime>) {\n         if let Some(lt) = *lifetime {\n             self.print_lifetime(lt);\n@@ -1059,343 +1049,6 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    crate fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n-        let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n-        self.ann.pre(self, AnnNode::SubItem(id));\n-        self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(span.lo());\n-        self.print_outer_attributes(attrs);\n-        match kind {\n-            ast::ForeignItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n-                self.print_fn_full(sig, ident, generics, vis, *defaultness, body.as_deref(), attrs);\n-            }\n-            ast::ForeignItemKind::Static(ty, mutbl, body) => {\n-                let def = ast::Defaultness::Final;\n-                self.print_item_const(ident, Some(*mutbl), ty, body.as_deref(), vis, def);\n-            }\n-            ast::ForeignItemKind::TyAlias(box ast::TyAlias {\n-                defaultness,\n-                generics,\n-                bounds,\n-                ty,\n-            }) => {\n-                self.print_associated_type(\n-                    ident,\n-                    generics,\n-                    bounds,\n-                    ty.as_deref(),\n-                    vis,\n-                    *defaultness,\n-                );\n-            }\n-            ast::ForeignItemKind::MacCall(m) => {\n-                self.print_mac(m);\n-                if m.args.need_semicolon() {\n-                    self.word(\";\");\n-                }\n-            }\n-        }\n-        self.ann.post(self, AnnNode::SubItem(id))\n-    }\n-\n-    fn print_item_const(\n-        &mut self,\n-        ident: Ident,\n-        mutbl: Option<ast::Mutability>,\n-        ty: &ast::Ty,\n-        body: Option<&ast::Expr>,\n-        vis: &ast::Visibility,\n-        defaultness: ast::Defaultness,\n-    ) {\n-        self.head(\"\");\n-        self.print_visibility(vis);\n-        self.print_defaultness(defaultness);\n-        let leading = match mutbl {\n-            None => \"const\",\n-            Some(ast::Mutability::Not) => \"static\",\n-            Some(ast::Mutability::Mut) => \"static mut\",\n-        };\n-        self.word_space(leading);\n-        self.print_ident(ident);\n-        self.word_space(\":\");\n-        self.print_type(ty);\n-        if body.is_some() {\n-            self.space();\n-        }\n-        self.end(); // end the head-ibox\n-        if let Some(body) = body {\n-            self.word_space(\"=\");\n-            self.print_expr(body);\n-        }\n-        self.word(\";\");\n-        self.end(); // end the outer cbox\n-    }\n-\n-    fn print_associated_type(\n-        &mut self,\n-        ident: Ident,\n-        generics: &ast::Generics,\n-        bounds: &ast::GenericBounds,\n-        ty: Option<&ast::Ty>,\n-        vis: &ast::Visibility,\n-        defaultness: ast::Defaultness,\n-    ) {\n-        self.head(\"\");\n-        self.print_visibility(vis);\n-        self.print_defaultness(defaultness);\n-        self.word_space(\"type\");\n-        self.print_ident(ident);\n-        self.print_generic_params(&generics.params);\n-        self.print_type_bounds(\":\", bounds);\n-        self.print_where_clause(&generics.where_clause);\n-        if let Some(ty) = ty {\n-            self.space();\n-            self.word_space(\"=\");\n-            self.print_type(ty);\n-        }\n-        self.word(\";\");\n-        self.end(); // end inner head-block\n-        self.end(); // end outer head-block\n-    }\n-\n-    /// Pretty-prints an item.\n-    crate fn print_item(&mut self, item: &ast::Item) {\n-        self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(item.span.lo());\n-        self.print_outer_attributes(&item.attrs);\n-        self.ann.pre(self, AnnNode::Item(item));\n-        match item.kind {\n-            ast::ItemKind::ExternCrate(orig_name) => {\n-                self.head(visibility_qualified(&item.vis, \"extern crate\"));\n-                if let Some(orig_name) = orig_name {\n-                    self.print_name(orig_name);\n-                    self.space();\n-                    self.word(\"as\");\n-                    self.space();\n-                }\n-                self.print_ident(item.ident);\n-                self.word(\";\");\n-                self.end(); // end inner head-block\n-                self.end(); // end outer head-block\n-            }\n-            ast::ItemKind::Use(ref tree) => {\n-                self.head(visibility_qualified(&item.vis, \"use\"));\n-                self.print_use_tree(tree);\n-                self.word(\";\");\n-                self.end(); // end inner head-block\n-                self.end(); // end outer head-block\n-            }\n-            ast::ItemKind::Static(ref ty, mutbl, ref body) => {\n-                let def = ast::Defaultness::Final;\n-                self.print_item_const(item.ident, Some(mutbl), ty, body.as_deref(), &item.vis, def);\n-            }\n-            ast::ItemKind::Const(def, ref ty, ref body) => {\n-                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis, def);\n-            }\n-            ast::ItemKind::Fn(box ast::Fn { defaultness, ref sig, ref generics, ref body }) => {\n-                let body = body.as_deref();\n-                self.print_fn_full(\n-                    sig,\n-                    item.ident,\n-                    generics,\n-                    &item.vis,\n-                    defaultness,\n-                    body,\n-                    &item.attrs,\n-                );\n-            }\n-            ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n-                self.head(Self::to_string(|s| {\n-                    s.print_visibility(&item.vis);\n-                    s.print_unsafety(unsafety);\n-                    s.word(\"mod\");\n-                }));\n-                self.print_ident(item.ident);\n-\n-                match mod_kind {\n-                    ModKind::Loaded(items, ..) => {\n-                        self.nbsp();\n-                        self.bopen();\n-                        self.print_inner_attributes(&item.attrs);\n-                        for item in items {\n-                            self.print_item(item);\n-                        }\n-                        let empty = item.attrs.is_empty() && items.is_empty();\n-                        self.bclose(item.span, empty);\n-                    }\n-                    ModKind::Unloaded => {\n-                        self.word(\";\");\n-                        self.end(); // end inner head-block\n-                        self.end(); // end outer head-block\n-                    }\n-                }\n-            }\n-            ast::ItemKind::ForeignMod(ref nmod) => {\n-                self.head(Self::to_string(|s| {\n-                    s.print_unsafety(nmod.unsafety);\n-                    s.word(\"extern\");\n-                }));\n-                if let Some(abi) = nmod.abi {\n-                    self.print_literal(&abi.as_lit());\n-                    self.nbsp();\n-                }\n-                self.bopen();\n-                self.print_foreign_mod(nmod, &item.attrs);\n-                let empty = item.attrs.is_empty() && nmod.items.is_empty();\n-                self.bclose(item.span, empty);\n-            }\n-            ast::ItemKind::GlobalAsm(ref asm) => {\n-                self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n-                self.print_inline_asm(asm);\n-                self.end();\n-            }\n-            ast::ItemKind::TyAlias(box ast::TyAlias {\n-                defaultness,\n-                ref generics,\n-                ref bounds,\n-                ref ty,\n-            }) => {\n-                let ty = ty.as_deref();\n-                self.print_associated_type(\n-                    item.ident,\n-                    generics,\n-                    bounds,\n-                    ty,\n-                    &item.vis,\n-                    defaultness,\n-                );\n-            }\n-            ast::ItemKind::Enum(ref enum_definition, ref params) => {\n-                self.print_enum_def(enum_definition, params, item.ident, item.span, &item.vis);\n-            }\n-            ast::ItemKind::Struct(ref struct_def, ref generics) => {\n-                self.head(visibility_qualified(&item.vis, \"struct\"));\n-                self.print_struct(struct_def, generics, item.ident, item.span, true);\n-            }\n-            ast::ItemKind::Union(ref struct_def, ref generics) => {\n-                self.head(visibility_qualified(&item.vis, \"union\"));\n-                self.print_struct(struct_def, generics, item.ident, item.span, true);\n-            }\n-            ast::ItemKind::Impl(box ast::Impl {\n-                unsafety,\n-                polarity,\n-                defaultness,\n-                constness,\n-                ref generics,\n-                ref of_trait,\n-                ref self_ty,\n-                ref items,\n-            }) => {\n-                self.head(\"\");\n-                self.print_visibility(&item.vis);\n-                self.print_defaultness(defaultness);\n-                self.print_unsafety(unsafety);\n-                self.word(\"impl\");\n-\n-                if generics.params.is_empty() {\n-                    self.nbsp();\n-                } else {\n-                    self.print_generic_params(&generics.params);\n-                    self.space();\n-                }\n-\n-                self.print_constness(constness);\n-\n-                if let ast::ImplPolarity::Negative(_) = polarity {\n-                    self.word(\"!\");\n-                }\n-\n-                if let Some(ref t) = *of_trait {\n-                    self.print_trait_ref(t);\n-                    self.space();\n-                    self.word_space(\"for\");\n-                }\n-\n-                self.print_type(self_ty);\n-                self.print_where_clause(&generics.where_clause);\n-\n-                self.space();\n-                self.bopen();\n-                self.print_inner_attributes(&item.attrs);\n-                for impl_item in items {\n-                    self.print_assoc_item(impl_item);\n-                }\n-                let empty = item.attrs.is_empty() && items.is_empty();\n-                self.bclose(item.span, empty);\n-            }\n-            ast::ItemKind::Trait(box ast::Trait {\n-                is_auto,\n-                unsafety,\n-                ref generics,\n-                ref bounds,\n-                ref items,\n-                ..\n-            }) => {\n-                self.head(\"\");\n-                self.print_visibility(&item.vis);\n-                self.print_unsafety(unsafety);\n-                self.print_is_auto(is_auto);\n-                self.word_nbsp(\"trait\");\n-                self.print_ident(item.ident);\n-                self.print_generic_params(&generics.params);\n-                let mut real_bounds = Vec::with_capacity(bounds.len());\n-                for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n-                        self.space();\n-                        self.word_space(\"for ?\");\n-                        self.print_trait_ref(&ptr.trait_ref);\n-                    } else {\n-                        real_bounds.push(b.clone());\n-                    }\n-                }\n-                self.print_type_bounds(\":\", &real_bounds);\n-                self.print_where_clause(&generics.where_clause);\n-                self.word(\" \");\n-                self.bopen();\n-                self.print_inner_attributes(&item.attrs);\n-                for trait_item in items {\n-                    self.print_assoc_item(trait_item);\n-                }\n-                let empty = item.attrs.is_empty() && items.is_empty();\n-                self.bclose(item.span, empty);\n-            }\n-            ast::ItemKind::TraitAlias(ref generics, ref bounds) => {\n-                self.head(visibility_qualified(&item.vis, \"trait\"));\n-                self.print_ident(item.ident);\n-                self.print_generic_params(&generics.params);\n-                let mut real_bounds = Vec::with_capacity(bounds.len());\n-                // FIXME(durka) this seems to be some quite outdated syntax\n-                for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n-                        self.space();\n-                        self.word_space(\"for ?\");\n-                        self.print_trait_ref(&ptr.trait_ref);\n-                    } else {\n-                        real_bounds.push(b.clone());\n-                    }\n-                }\n-                self.nbsp();\n-                self.print_type_bounds(\"=\", &real_bounds);\n-                self.print_where_clause(&generics.where_clause);\n-                self.word(\";\");\n-                self.end(); // end inner head-block\n-                self.end(); // end outer head-block\n-            }\n-            ast::ItemKind::MacCall(ref mac) => {\n-                self.print_mac(mac);\n-                if mac.args.need_semicolon() {\n-                    self.word(\";\");\n-                }\n-            }\n-            ast::ItemKind::MacroDef(ref macro_def) => {\n-                self.print_mac_def(macro_def, &item.ident, &item.span, |state| {\n-                    state.print_visibility(&item.vis)\n-                });\n-            }\n-        }\n-        self.ann.post(self, AnnNode::Item(item))\n-    }\n-\n     fn print_trait_ref(&mut self, t: &ast::TraitRef) {\n         self.print_path(&t.path, false, 0)\n     }\n@@ -1413,167 +1066,6 @@ impl<'a> State<'a> {\n         self.print_trait_ref(&t.trait_ref)\n     }\n \n-    crate fn print_enum_def(\n-        &mut self,\n-        enum_definition: &ast::EnumDef,\n-        generics: &ast::Generics,\n-        ident: Ident,\n-        span: rustc_span::Span,\n-        visibility: &ast::Visibility,\n-    ) {\n-        self.head(visibility_qualified(visibility, \"enum\"));\n-        self.print_ident(ident);\n-        self.print_generic_params(&generics.params);\n-        self.print_where_clause(&generics.where_clause);\n-        self.space();\n-        self.print_variants(&enum_definition.variants, span)\n-    }\n-\n-    crate fn print_variants(&mut self, variants: &[ast::Variant], span: rustc_span::Span) {\n-        self.bopen();\n-        for v in variants {\n-            self.space_if_not_bol();\n-            self.maybe_print_comment(v.span.lo());\n-            self.print_outer_attributes(&v.attrs);\n-            self.ibox(INDENT_UNIT);\n-            self.print_variant(v);\n-            self.word(\",\");\n-            self.end();\n-            self.maybe_print_trailing_comment(v.span, None);\n-        }\n-        let empty = variants.is_empty();\n-        self.bclose(span, empty)\n-    }\n-\n-    crate fn print_visibility(&mut self, vis: &ast::Visibility) {\n-        match vis.kind {\n-            ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n-            ast::VisibilityKind::Crate(sugar) => match sugar {\n-                ast::CrateSugar::PubCrate => self.word_nbsp(\"pub(crate)\"),\n-                ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\"),\n-            },\n-            ast::VisibilityKind::Restricted { ref path, .. } => {\n-                let path = Self::to_string(|s| s.print_path(path, false, 0));\n-                if path == \"self\" || path == \"super\" {\n-                    self.word_nbsp(format!(\"pub({})\", path))\n-                } else {\n-                    self.word_nbsp(format!(\"pub(in {})\", path))\n-                }\n-            }\n-            ast::VisibilityKind::Inherited => {}\n-        }\n-    }\n-\n-    crate fn print_defaultness(&mut self, defaultness: ast::Defaultness) {\n-        if let ast::Defaultness::Default(_) = defaultness {\n-            self.word_nbsp(\"default\");\n-        }\n-    }\n-\n-    crate fn print_record_struct_body(&mut self, fields: &[ast::FieldDef], span: rustc_span::Span) {\n-        self.nbsp();\n-        self.bopen();\n-\n-        let empty = fields.is_empty();\n-        if !empty {\n-            self.hardbreak_if_not_bol();\n-\n-            for field in fields {\n-                self.hardbreak_if_not_bol();\n-                self.maybe_print_comment(field.span.lo());\n-                self.print_outer_attributes(&field.attrs);\n-                self.print_visibility(&field.vis);\n-                self.print_ident(field.ident.unwrap());\n-                self.word_nbsp(\":\");\n-                self.print_type(&field.ty);\n-                self.word(\",\");\n-            }\n-        }\n-\n-        self.bclose(span, empty);\n-    }\n-\n-    crate fn print_struct(\n-        &mut self,\n-        struct_def: &ast::VariantData,\n-        generics: &ast::Generics,\n-        ident: Ident,\n-        span: rustc_span::Span,\n-        print_finalizer: bool,\n-    ) {\n-        self.print_ident(ident);\n-        self.print_generic_params(&generics.params);\n-        match struct_def {\n-            ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n-                if let ast::VariantData::Tuple(..) = struct_def {\n-                    self.popen();\n-                    self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n-                        s.maybe_print_comment(field.span.lo());\n-                        s.print_outer_attributes(&field.attrs);\n-                        s.print_visibility(&field.vis);\n-                        s.print_type(&field.ty)\n-                    });\n-                    self.pclose();\n-                }\n-                self.print_where_clause(&generics.where_clause);\n-                if print_finalizer {\n-                    self.word(\";\");\n-                }\n-                self.end();\n-                self.end(); // Close the outer-box.\n-            }\n-            ast::VariantData::Struct(ref fields, ..) => {\n-                self.print_where_clause(&generics.where_clause);\n-                self.print_record_struct_body(fields, span);\n-            }\n-        }\n-    }\n-\n-    crate fn print_variant(&mut self, v: &ast::Variant) {\n-        self.head(\"\");\n-        self.print_visibility(&v.vis);\n-        let generics = ast::Generics::default();\n-        self.print_struct(&v.data, &generics, v.ident, v.span, false);\n-        if let Some(ref d) = v.disr_expr {\n-            self.space();\n-            self.word_space(\"=\");\n-            self.print_expr(&d.value)\n-        }\n-    }\n-\n-    crate fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n-        let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n-        self.ann.pre(self, AnnNode::SubItem(id));\n-        self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(span.lo());\n-        self.print_outer_attributes(attrs);\n-        match kind {\n-            ast::AssocItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n-                self.print_fn_full(sig, ident, generics, vis, *defaultness, body.as_deref(), attrs);\n-            }\n-            ast::AssocItemKind::Const(def, ty, body) => {\n-                self.print_item_const(ident, None, ty, body.as_deref(), vis, *def);\n-            }\n-            ast::AssocItemKind::TyAlias(box ast::TyAlias { defaultness, generics, bounds, ty }) => {\n-                self.print_associated_type(\n-                    ident,\n-                    generics,\n-                    bounds,\n-                    ty.as_deref(),\n-                    vis,\n-                    *defaultness,\n-                );\n-            }\n-            ast::AssocItemKind::MacCall(m) => {\n-                self.print_mac(m);\n-                if m.args.need_semicolon() {\n-                    self.word(\";\");\n-                }\n-            }\n-        }\n-        self.ann.post(self, AnnNode::SubItem(id))\n-    }\n-\n     crate fn print_stmt(&mut self, st: &ast::Stmt) {\n         self.maybe_print_comment(st.span.lo());\n         match st.kind {\n@@ -2012,55 +1504,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_fn_full(\n-        &mut self,\n-        sig: &ast::FnSig,\n-        name: Ident,\n-        generics: &ast::Generics,\n-        vis: &ast::Visibility,\n-        defaultness: ast::Defaultness,\n-        body: Option<&ast::Block>,\n-        attrs: &[ast::Attribute],\n-    ) {\n-        if body.is_some() {\n-            self.head(\"\");\n-        }\n-        self.print_visibility(vis);\n-        self.print_defaultness(defaultness);\n-        self.print_fn(&sig.decl, sig.header, Some(name), generics);\n-        if let Some(body) = body {\n-            self.nbsp();\n-            self.print_block_with_attrs(body, attrs);\n-        } else {\n-            self.word(\";\");\n-        }\n-    }\n-\n-    crate fn print_fn(\n-        &mut self,\n-        decl: &ast::FnDecl,\n-        header: ast::FnHeader,\n-        name: Option<Ident>,\n-        generics: &ast::Generics,\n-    ) {\n-        self.print_fn_header_info(header);\n-        if let Some(name) = name {\n-            self.nbsp();\n-            self.print_ident(name);\n-        }\n-        self.print_generic_params(&generics.params);\n-        self.print_fn_params_and_ret(decl, false);\n-        self.print_where_clause(&generics.where_clause)\n-    }\n-\n-    crate fn print_fn_params_and_ret(&mut self, decl: &ast::FnDecl, is_closure: bool) {\n-        let (open, close) = if is_closure { (\"|\", \"|\") } else { (\"(\", \")\") };\n-        self.word(open);\n-        self.commasep(Inconsistent, &decl.inputs, |s, param| s.print_param(param, is_closure));\n-        self.word(close);\n-        self.print_fn_ret_ty(&decl.output)\n-    }\n-\n     crate fn print_asyncness(&mut self, asyncness: ast::Async) {\n         if asyncness.is_async() {\n             self.word_nbsp(\"async\");\n@@ -2161,83 +1604,6 @@ impl<'a> State<'a> {\n         self.word(\">\");\n     }\n \n-    crate fn print_where_clause(&mut self, where_clause: &ast::WhereClause) {\n-        if where_clause.predicates.is_empty() && !where_clause.has_where_token {\n-            return;\n-        }\n-\n-        self.space();\n-        self.word_space(\"where\");\n-\n-        for (i, predicate) in where_clause.predicates.iter().enumerate() {\n-            if i != 0 {\n-                self.word_space(\",\");\n-            }\n-\n-            self.print_where_predicate(predicate);\n-        }\n-    }\n-\n-    pub fn print_where_predicate(&mut self, predicate: &ast::WherePredicate) {\n-        match predicate {\n-            ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n-                bound_generic_params,\n-                bounded_ty,\n-                bounds,\n-                ..\n-            }) => {\n-                self.print_formal_generic_params(bound_generic_params);\n-                self.print_type(bounded_ty);\n-                self.print_type_bounds(\":\", bounds);\n-            }\n-            ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n-                lifetime,\n-                bounds,\n-                ..\n-            }) => {\n-                self.print_lifetime_bounds(*lifetime, bounds);\n-            }\n-            ast::WherePredicate::EqPredicate(ast::WhereEqPredicate { lhs_ty, rhs_ty, .. }) => {\n-                self.print_type(lhs_ty);\n-                self.space();\n-                self.word_space(\"=\");\n-                self.print_type(rhs_ty);\n-            }\n-        }\n-    }\n-\n-    crate fn print_use_tree(&mut self, tree: &ast::UseTree) {\n-        match tree.kind {\n-            ast::UseTreeKind::Simple(rename, ..) => {\n-                self.print_path(&tree.prefix, false, 0);\n-                if let Some(rename) = rename {\n-                    self.space();\n-                    self.word_space(\"as\");\n-                    self.print_ident(rename);\n-                }\n-            }\n-            ast::UseTreeKind::Glob => {\n-                if !tree.prefix.segments.is_empty() {\n-                    self.print_path(&tree.prefix, false, 0);\n-                    self.word(\"::\");\n-                }\n-                self.word(\"*\");\n-            }\n-            ast::UseTreeKind::Nested(ref items) => {\n-                if tree.prefix.segments.is_empty() {\n-                    self.word(\"{\");\n-                } else {\n-                    self.print_path(&tree.prefix, false, 0);\n-                    self.word(\"::{\");\n-                }\n-                self.commasep(Inconsistent, &items, |this, &(ref tree, _)| {\n-                    this.print_use_tree(tree)\n-                });\n-                self.word(\"}\");\n-            }\n-        }\n-    }\n-\n     pub fn print_mutability(&mut self, mutbl: ast::Mutability, print_const: bool) {\n         match mutbl {\n             ast::Mutability::Mut => self.word_nbsp(\"mut\"),"}, {"sha": "c756b946b1e4ae9acf7f311d8319c20bbf1355e6", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "added", "additions": 644, "deletions": 0, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/07a0325137b3e7e1c036d5301e03cf590ea1ce1e/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a0325137b3e7e1c036d5301e03cf590ea1ce1e/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=07a0325137b3e7e1c036d5301e03cf590ea1ce1e", "patch": "@@ -0,0 +1,644 @@\n+use crate::pp::Breaks::Inconsistent;\n+use crate::pprust::state::{AnnNode, PrintState, State, INDENT_UNIT};\n+\n+use rustc_ast as ast;\n+use rustc_ast::GenericBound;\n+use rustc_ast::ModKind;\n+use rustc_span::symbol::Ident;\n+\n+fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n+    format!(\"{}{}\", State::to_string(|s| s.print_visibility(vis)), s)\n+}\n+\n+impl<'a> State<'a> {\n+    fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[ast::Attribute]) {\n+        self.print_inner_attributes(attrs);\n+        for item in &nmod.items {\n+            self.print_foreign_item(item);\n+        }\n+    }\n+\n+    fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n+        let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n+        self.ann.pre(self, AnnNode::SubItem(id));\n+        self.hardbreak_if_not_bol();\n+        self.maybe_print_comment(span.lo());\n+        self.print_outer_attributes(attrs);\n+        match kind {\n+            ast::ForeignItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n+                self.print_fn_full(sig, ident, generics, vis, *defaultness, body.as_deref(), attrs);\n+            }\n+            ast::ForeignItemKind::Static(ty, mutbl, body) => {\n+                let def = ast::Defaultness::Final;\n+                self.print_item_const(ident, Some(*mutbl), ty, body.as_deref(), vis, def);\n+            }\n+            ast::ForeignItemKind::TyAlias(box ast::TyAlias {\n+                defaultness,\n+                generics,\n+                bounds,\n+                ty,\n+            }) => {\n+                self.print_associated_type(\n+                    ident,\n+                    generics,\n+                    bounds,\n+                    ty.as_deref(),\n+                    vis,\n+                    *defaultness,\n+                );\n+            }\n+            ast::ForeignItemKind::MacCall(m) => {\n+                self.print_mac(m);\n+                if m.args.need_semicolon() {\n+                    self.word(\";\");\n+                }\n+            }\n+        }\n+        self.ann.post(self, AnnNode::SubItem(id))\n+    }\n+\n+    fn print_item_const(\n+        &mut self,\n+        ident: Ident,\n+        mutbl: Option<ast::Mutability>,\n+        ty: &ast::Ty,\n+        body: Option<&ast::Expr>,\n+        vis: &ast::Visibility,\n+        defaultness: ast::Defaultness,\n+    ) {\n+        self.head(\"\");\n+        self.print_visibility(vis);\n+        self.print_defaultness(defaultness);\n+        let leading = match mutbl {\n+            None => \"const\",\n+            Some(ast::Mutability::Not) => \"static\",\n+            Some(ast::Mutability::Mut) => \"static mut\",\n+        };\n+        self.word_space(leading);\n+        self.print_ident(ident);\n+        self.word_space(\":\");\n+        self.print_type(ty);\n+        if body.is_some() {\n+            self.space();\n+        }\n+        self.end(); // end the head-ibox\n+        if let Some(body) = body {\n+            self.word_space(\"=\");\n+            self.print_expr(body);\n+        }\n+        self.word(\";\");\n+        self.end(); // end the outer cbox\n+    }\n+\n+    fn print_associated_type(\n+        &mut self,\n+        ident: Ident,\n+        generics: &ast::Generics,\n+        bounds: &ast::GenericBounds,\n+        ty: Option<&ast::Ty>,\n+        vis: &ast::Visibility,\n+        defaultness: ast::Defaultness,\n+    ) {\n+        self.head(\"\");\n+        self.print_visibility(vis);\n+        self.print_defaultness(defaultness);\n+        self.word_space(\"type\");\n+        self.print_ident(ident);\n+        self.print_generic_params(&generics.params);\n+        self.print_type_bounds(\":\", bounds);\n+        self.print_where_clause(&generics.where_clause);\n+        if let Some(ty) = ty {\n+            self.space();\n+            self.word_space(\"=\");\n+            self.print_type(ty);\n+        }\n+        self.word(\";\");\n+        self.end(); // end inner head-block\n+        self.end(); // end outer head-block\n+    }\n+\n+    /// Pretty-prints an item.\n+    crate fn print_item(&mut self, item: &ast::Item) {\n+        self.hardbreak_if_not_bol();\n+        self.maybe_print_comment(item.span.lo());\n+        self.print_outer_attributes(&item.attrs);\n+        self.ann.pre(self, AnnNode::Item(item));\n+        match item.kind {\n+            ast::ItemKind::ExternCrate(orig_name) => {\n+                self.head(visibility_qualified(&item.vis, \"extern crate\"));\n+                if let Some(orig_name) = orig_name {\n+                    self.print_name(orig_name);\n+                    self.space();\n+                    self.word(\"as\");\n+                    self.space();\n+                }\n+                self.print_ident(item.ident);\n+                self.word(\";\");\n+                self.end(); // end inner head-block\n+                self.end(); // end outer head-block\n+            }\n+            ast::ItemKind::Use(ref tree) => {\n+                self.head(visibility_qualified(&item.vis, \"use\"));\n+                self.print_use_tree(tree);\n+                self.word(\";\");\n+                self.end(); // end inner head-block\n+                self.end(); // end outer head-block\n+            }\n+            ast::ItemKind::Static(ref ty, mutbl, ref body) => {\n+                let def = ast::Defaultness::Final;\n+                self.print_item_const(item.ident, Some(mutbl), ty, body.as_deref(), &item.vis, def);\n+            }\n+            ast::ItemKind::Const(def, ref ty, ref body) => {\n+                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis, def);\n+            }\n+            ast::ItemKind::Fn(box ast::Fn { defaultness, ref sig, ref generics, ref body }) => {\n+                let body = body.as_deref();\n+                self.print_fn_full(\n+                    sig,\n+                    item.ident,\n+                    generics,\n+                    &item.vis,\n+                    defaultness,\n+                    body,\n+                    &item.attrs,\n+                );\n+            }\n+            ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n+                self.head(Self::to_string(|s| {\n+                    s.print_visibility(&item.vis);\n+                    s.print_unsafety(unsafety);\n+                    s.word(\"mod\");\n+                }));\n+                self.print_ident(item.ident);\n+\n+                match mod_kind {\n+                    ModKind::Loaded(items, ..) => {\n+                        self.nbsp();\n+                        self.bopen();\n+                        self.print_inner_attributes(&item.attrs);\n+                        for item in items {\n+                            self.print_item(item);\n+                        }\n+                        let empty = item.attrs.is_empty() && items.is_empty();\n+                        self.bclose(item.span, empty);\n+                    }\n+                    ModKind::Unloaded => {\n+                        self.word(\";\");\n+                        self.end(); // end inner head-block\n+                        self.end(); // end outer head-block\n+                    }\n+                }\n+            }\n+            ast::ItemKind::ForeignMod(ref nmod) => {\n+                self.head(Self::to_string(|s| {\n+                    s.print_unsafety(nmod.unsafety);\n+                    s.word(\"extern\");\n+                }));\n+                if let Some(abi) = nmod.abi {\n+                    self.print_literal(&abi.as_lit());\n+                    self.nbsp();\n+                }\n+                self.bopen();\n+                self.print_foreign_mod(nmod, &item.attrs);\n+                let empty = item.attrs.is_empty() && nmod.items.is_empty();\n+                self.bclose(item.span, empty);\n+            }\n+            ast::ItemKind::GlobalAsm(ref asm) => {\n+                self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n+                self.print_inline_asm(asm);\n+                self.end();\n+            }\n+            ast::ItemKind::TyAlias(box ast::TyAlias {\n+                defaultness,\n+                ref generics,\n+                ref bounds,\n+                ref ty,\n+            }) => {\n+                let ty = ty.as_deref();\n+                self.print_associated_type(\n+                    item.ident,\n+                    generics,\n+                    bounds,\n+                    ty,\n+                    &item.vis,\n+                    defaultness,\n+                );\n+            }\n+            ast::ItemKind::Enum(ref enum_definition, ref params) => {\n+                self.print_enum_def(enum_definition, params, item.ident, item.span, &item.vis);\n+            }\n+            ast::ItemKind::Struct(ref struct_def, ref generics) => {\n+                self.head(visibility_qualified(&item.vis, \"struct\"));\n+                self.print_struct(struct_def, generics, item.ident, item.span, true);\n+            }\n+            ast::ItemKind::Union(ref struct_def, ref generics) => {\n+                self.head(visibility_qualified(&item.vis, \"union\"));\n+                self.print_struct(struct_def, generics, item.ident, item.span, true);\n+            }\n+            ast::ItemKind::Impl(box ast::Impl {\n+                unsafety,\n+                polarity,\n+                defaultness,\n+                constness,\n+                ref generics,\n+                ref of_trait,\n+                ref self_ty,\n+                ref items,\n+            }) => {\n+                self.head(\"\");\n+                self.print_visibility(&item.vis);\n+                self.print_defaultness(defaultness);\n+                self.print_unsafety(unsafety);\n+                self.word(\"impl\");\n+\n+                if generics.params.is_empty() {\n+                    self.nbsp();\n+                } else {\n+                    self.print_generic_params(&generics.params);\n+                    self.space();\n+                }\n+\n+                self.print_constness(constness);\n+\n+                if let ast::ImplPolarity::Negative(_) = polarity {\n+                    self.word(\"!\");\n+                }\n+\n+                if let Some(ref t) = *of_trait {\n+                    self.print_trait_ref(t);\n+                    self.space();\n+                    self.word_space(\"for\");\n+                }\n+\n+                self.print_type(self_ty);\n+                self.print_where_clause(&generics.where_clause);\n+\n+                self.space();\n+                self.bopen();\n+                self.print_inner_attributes(&item.attrs);\n+                for impl_item in items {\n+                    self.print_assoc_item(impl_item);\n+                }\n+                let empty = item.attrs.is_empty() && items.is_empty();\n+                self.bclose(item.span, empty);\n+            }\n+            ast::ItemKind::Trait(box ast::Trait {\n+                is_auto,\n+                unsafety,\n+                ref generics,\n+                ref bounds,\n+                ref items,\n+                ..\n+            }) => {\n+                self.head(\"\");\n+                self.print_visibility(&item.vis);\n+                self.print_unsafety(unsafety);\n+                self.print_is_auto(is_auto);\n+                self.word_nbsp(\"trait\");\n+                self.print_ident(item.ident);\n+                self.print_generic_params(&generics.params);\n+                let mut real_bounds = Vec::with_capacity(bounds.len());\n+                for b in bounds.iter() {\n+                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                        self.space();\n+                        self.word_space(\"for ?\");\n+                        self.print_trait_ref(&ptr.trait_ref);\n+                    } else {\n+                        real_bounds.push(b.clone());\n+                    }\n+                }\n+                self.print_type_bounds(\":\", &real_bounds);\n+                self.print_where_clause(&generics.where_clause);\n+                self.word(\" \");\n+                self.bopen();\n+                self.print_inner_attributes(&item.attrs);\n+                for trait_item in items {\n+                    self.print_assoc_item(trait_item);\n+                }\n+                let empty = item.attrs.is_empty() && items.is_empty();\n+                self.bclose(item.span, empty);\n+            }\n+            ast::ItemKind::TraitAlias(ref generics, ref bounds) => {\n+                self.head(visibility_qualified(&item.vis, \"trait\"));\n+                self.print_ident(item.ident);\n+                self.print_generic_params(&generics.params);\n+                let mut real_bounds = Vec::with_capacity(bounds.len());\n+                // FIXME(durka) this seems to be some quite outdated syntax\n+                for b in bounds.iter() {\n+                    if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n+                        self.space();\n+                        self.word_space(\"for ?\");\n+                        self.print_trait_ref(&ptr.trait_ref);\n+                    } else {\n+                        real_bounds.push(b.clone());\n+                    }\n+                }\n+                self.nbsp();\n+                self.print_type_bounds(\"=\", &real_bounds);\n+                self.print_where_clause(&generics.where_clause);\n+                self.word(\";\");\n+                self.end(); // end inner head-block\n+                self.end(); // end outer head-block\n+            }\n+            ast::ItemKind::MacCall(ref mac) => {\n+                self.print_mac(mac);\n+                if mac.args.need_semicolon() {\n+                    self.word(\";\");\n+                }\n+            }\n+            ast::ItemKind::MacroDef(ref macro_def) => {\n+                self.print_mac_def(macro_def, &item.ident, &item.span, |state| {\n+                    state.print_visibility(&item.vis)\n+                });\n+            }\n+        }\n+        self.ann.post(self, AnnNode::Item(item))\n+    }\n+\n+    fn print_enum_def(\n+        &mut self,\n+        enum_definition: &ast::EnumDef,\n+        generics: &ast::Generics,\n+        ident: Ident,\n+        span: rustc_span::Span,\n+        visibility: &ast::Visibility,\n+    ) {\n+        self.head(visibility_qualified(visibility, \"enum\"));\n+        self.print_ident(ident);\n+        self.print_generic_params(&generics.params);\n+        self.print_where_clause(&generics.where_clause);\n+        self.space();\n+        self.print_variants(&enum_definition.variants, span)\n+    }\n+\n+    fn print_variants(&mut self, variants: &[ast::Variant], span: rustc_span::Span) {\n+        self.bopen();\n+        for v in variants {\n+            self.space_if_not_bol();\n+            self.maybe_print_comment(v.span.lo());\n+            self.print_outer_attributes(&v.attrs);\n+            self.ibox(INDENT_UNIT);\n+            self.print_variant(v);\n+            self.word(\",\");\n+            self.end();\n+            self.maybe_print_trailing_comment(v.span, None);\n+        }\n+        let empty = variants.is_empty();\n+        self.bclose(span, empty)\n+    }\n+\n+    crate fn print_visibility(&mut self, vis: &ast::Visibility) {\n+        match vis.kind {\n+            ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n+            ast::VisibilityKind::Crate(sugar) => match sugar {\n+                ast::CrateSugar::PubCrate => self.word_nbsp(\"pub(crate)\"),\n+                ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\"),\n+            },\n+            ast::VisibilityKind::Restricted { ref path, .. } => {\n+                let path = Self::to_string(|s| s.print_path(path, false, 0));\n+                if path == \"self\" || path == \"super\" {\n+                    self.word_nbsp(format!(\"pub({})\", path))\n+                } else {\n+                    self.word_nbsp(format!(\"pub(in {})\", path))\n+                }\n+            }\n+            ast::VisibilityKind::Inherited => {}\n+        }\n+    }\n+\n+    fn print_defaultness(&mut self, defaultness: ast::Defaultness) {\n+        if let ast::Defaultness::Default(_) = defaultness {\n+            self.word_nbsp(\"default\");\n+        }\n+    }\n+\n+    fn print_record_struct_body(&mut self, fields: &[ast::FieldDef], span: rustc_span::Span) {\n+        self.nbsp();\n+        self.bopen();\n+\n+        let empty = fields.is_empty();\n+        if !empty {\n+            self.hardbreak_if_not_bol();\n+\n+            for field in fields {\n+                self.hardbreak_if_not_bol();\n+                self.maybe_print_comment(field.span.lo());\n+                self.print_outer_attributes(&field.attrs);\n+                self.print_visibility(&field.vis);\n+                self.print_ident(field.ident.unwrap());\n+                self.word_nbsp(\":\");\n+                self.print_type(&field.ty);\n+                self.word(\",\");\n+            }\n+        }\n+\n+        self.bclose(span, empty);\n+    }\n+\n+    fn print_struct(\n+        &mut self,\n+        struct_def: &ast::VariantData,\n+        generics: &ast::Generics,\n+        ident: Ident,\n+        span: rustc_span::Span,\n+        print_finalizer: bool,\n+    ) {\n+        self.print_ident(ident);\n+        self.print_generic_params(&generics.params);\n+        match struct_def {\n+            ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n+                if let ast::VariantData::Tuple(..) = struct_def {\n+                    self.popen();\n+                    self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n+                        s.maybe_print_comment(field.span.lo());\n+                        s.print_outer_attributes(&field.attrs);\n+                        s.print_visibility(&field.vis);\n+                        s.print_type(&field.ty)\n+                    });\n+                    self.pclose();\n+                }\n+                self.print_where_clause(&generics.where_clause);\n+                if print_finalizer {\n+                    self.word(\";\");\n+                }\n+                self.end();\n+                self.end(); // Close the outer-box.\n+            }\n+            ast::VariantData::Struct(ref fields, ..) => {\n+                self.print_where_clause(&generics.where_clause);\n+                self.print_record_struct_body(fields, span);\n+            }\n+        }\n+    }\n+\n+    crate fn print_variant(&mut self, v: &ast::Variant) {\n+        self.head(\"\");\n+        self.print_visibility(&v.vis);\n+        let generics = ast::Generics::default();\n+        self.print_struct(&v.data, &generics, v.ident, v.span, false);\n+        if let Some(ref d) = v.disr_expr {\n+            self.space();\n+            self.word_space(\"=\");\n+            self.print_expr(&d.value)\n+        }\n+    }\n+\n+    fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n+        let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n+        self.ann.pre(self, AnnNode::SubItem(id));\n+        self.hardbreak_if_not_bol();\n+        self.maybe_print_comment(span.lo());\n+        self.print_outer_attributes(attrs);\n+        match kind {\n+            ast::AssocItemKind::Fn(box ast::Fn { defaultness, sig, generics, body }) => {\n+                self.print_fn_full(sig, ident, generics, vis, *defaultness, body.as_deref(), attrs);\n+            }\n+            ast::AssocItemKind::Const(def, ty, body) => {\n+                self.print_item_const(ident, None, ty, body.as_deref(), vis, *def);\n+            }\n+            ast::AssocItemKind::TyAlias(box ast::TyAlias { defaultness, generics, bounds, ty }) => {\n+                self.print_associated_type(\n+                    ident,\n+                    generics,\n+                    bounds,\n+                    ty.as_deref(),\n+                    vis,\n+                    *defaultness,\n+                );\n+            }\n+            ast::AssocItemKind::MacCall(m) => {\n+                self.print_mac(m);\n+                if m.args.need_semicolon() {\n+                    self.word(\";\");\n+                }\n+            }\n+        }\n+        self.ann.post(self, AnnNode::SubItem(id))\n+    }\n+\n+    fn print_fn_full(\n+        &mut self,\n+        sig: &ast::FnSig,\n+        name: Ident,\n+        generics: &ast::Generics,\n+        vis: &ast::Visibility,\n+        defaultness: ast::Defaultness,\n+        body: Option<&ast::Block>,\n+        attrs: &[ast::Attribute],\n+    ) {\n+        if body.is_some() {\n+            self.head(\"\");\n+        }\n+        self.print_visibility(vis);\n+        self.print_defaultness(defaultness);\n+        self.print_fn(&sig.decl, sig.header, Some(name), generics);\n+        if let Some(body) = body {\n+            self.nbsp();\n+            self.print_block_with_attrs(body, attrs);\n+        } else {\n+            self.word(\";\");\n+        }\n+    }\n+\n+    crate fn print_fn(\n+        &mut self,\n+        decl: &ast::FnDecl,\n+        header: ast::FnHeader,\n+        name: Option<Ident>,\n+        generics: &ast::Generics,\n+    ) {\n+        self.print_fn_header_info(header);\n+        if let Some(name) = name {\n+            self.nbsp();\n+            self.print_ident(name);\n+        }\n+        self.print_generic_params(&generics.params);\n+        self.print_fn_params_and_ret(decl, false);\n+        self.print_where_clause(&generics.where_clause)\n+    }\n+\n+    crate fn print_fn_params_and_ret(&mut self, decl: &ast::FnDecl, is_closure: bool) {\n+        let (open, close) = if is_closure { (\"|\", \"|\") } else { (\"(\", \")\") };\n+        self.word(open);\n+        self.commasep(Inconsistent, &decl.inputs, |s, param| s.print_param(param, is_closure));\n+        self.word(close);\n+        self.print_fn_ret_ty(&decl.output)\n+    }\n+\n+    fn print_where_clause(&mut self, where_clause: &ast::WhereClause) {\n+        if where_clause.predicates.is_empty() && !where_clause.has_where_token {\n+            return;\n+        }\n+\n+        self.space();\n+        self.word_space(\"where\");\n+\n+        for (i, predicate) in where_clause.predicates.iter().enumerate() {\n+            if i != 0 {\n+                self.word_space(\",\");\n+            }\n+\n+            self.print_where_predicate(predicate);\n+        }\n+    }\n+\n+    pub fn print_where_predicate(&mut self, predicate: &ast::WherePredicate) {\n+        match predicate {\n+            ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                bound_generic_params,\n+                bounded_ty,\n+                bounds,\n+                ..\n+            }) => {\n+                self.print_formal_generic_params(bound_generic_params);\n+                self.print_type(bounded_ty);\n+                self.print_type_bounds(\":\", bounds);\n+            }\n+            ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n+                lifetime,\n+                bounds,\n+                ..\n+            }) => {\n+                self.print_lifetime_bounds(*lifetime, bounds);\n+            }\n+            ast::WherePredicate::EqPredicate(ast::WhereEqPredicate { lhs_ty, rhs_ty, .. }) => {\n+                self.print_type(lhs_ty);\n+                self.space();\n+                self.word_space(\"=\");\n+                self.print_type(rhs_ty);\n+            }\n+        }\n+    }\n+\n+    fn print_use_tree(&mut self, tree: &ast::UseTree) {\n+        match tree.kind {\n+            ast::UseTreeKind::Simple(rename, ..) => {\n+                self.print_path(&tree.prefix, false, 0);\n+                if let Some(rename) = rename {\n+                    self.space();\n+                    self.word_space(\"as\");\n+                    self.print_ident(rename);\n+                }\n+            }\n+            ast::UseTreeKind::Glob => {\n+                if !tree.prefix.segments.is_empty() {\n+                    self.print_path(&tree.prefix, false, 0);\n+                    self.word(\"::\");\n+                }\n+                self.word(\"*\");\n+            }\n+            ast::UseTreeKind::Nested(ref items) => {\n+                if tree.prefix.segments.is_empty() {\n+                    self.word(\"{\");\n+                } else {\n+                    self.print_path(&tree.prefix, false, 0);\n+                    self.word(\"::{\");\n+                }\n+                self.commasep(Inconsistent, &items, |this, &(ref tree, _)| {\n+                    this.print_use_tree(tree)\n+                });\n+                self.word(\"}\");\n+            }\n+        }\n+    }\n+}"}]}