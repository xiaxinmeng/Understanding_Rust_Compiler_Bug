{"sha": "11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZjRkNjJhMDYyYTVjODBmYWQ0MTRjNDU3ZTJhN2RiYzlhMWQ2Y2M=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-15T03:27:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-22T00:16:21Z"}, "message": "Add a lint for library features\n\nDoes a sanity check of the version numbers.", "tree": {"sha": "e7b345d6fd0eeabb866c493f9403cebefe3c981c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7b345d6fd0eeabb866c493f9403cebefe3c981c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc", "html_url": "https://github.com/rust-lang/rust/commit/11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b73ec469878e428c789b77320b3f8dc8d974d22", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b73ec469878e428c789b77320b3f8dc8d974d22", "html_url": "https://github.com/rust-lang/rust/commit/7b73ec469878e428c789b77320b3f8dc8d974d22"}], "stats": {"total": 402, "additions": 335, "deletions": 67}, "files": [{"sha": "3389065212485f067313dfbcd0bfe822528216a4", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc", "patch": "@@ -300,6 +300,7 @@ tidy:\n \t\t| grep '^$(S)src/libbacktrace' -v \\\n \t\t| grep '^$(S)src/rust-installer' -v \\\n \t\t| xargs $(CFG_PYTHON) $(S)src/etc/check-binaries.py\n+\t\t$(CFG_PYTHON) $(S)src/etc/featureck.py $(S)src/\n \n \n endif"}, {"sha": "06ef2d7c60567bdc8e6361a6a09a8f8db8063f40", "filename": "src/etc/featureck.py", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc/src%2Fetc%2Ffeatureck.py", "raw_url": "https://github.com/rust-lang/rust/raw/11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc/src%2Fetc%2Ffeatureck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ffeatureck.py?ref=11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc", "patch": "@@ -0,0 +1,254 @@\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# This script does a tree-wide sanity checks against stability\n+# attributes, currently:\n+#   * For all feature_name/level pairs the 'since' field is the same\n+#   * That no features are both stable and unstable.\n+#   * That lib features don't have the same name as lang features\n+#     unless they are on the 'joint_features' whitelist\n+#   * That features that exist in both lang and lib and are stable\n+#     since the same version\n+#   * Prints information about features\n+\n+import sys, os, re\n+\n+src_dir = sys.argv[1]\n+\n+# Features that are allowed to exist in both the language and the library\n+joint_features = [ \"on_unimpleented\" ]\n+\n+# Grab the list of language features from the compiler\n+language_gate_statuses = [ \"Active\", \"Deprecated\", \"Removed\", \"Accepted\" ]\n+feature_gate_source = os.path.join(src_dir, \"libsyntax\", \"feature_gate.rs\")\n+language_features = []\n+language_feature_names = []\n+with open(feature_gate_source, 'r') as f:\n+    for line in f:\n+        original_line = line\n+        line = line.strip()\n+        is_feature_line = False\n+        for status in language_gate_statuses:\n+            if status in line and line.startswith(\"(\"):\n+                is_feature_line = True\n+\n+        if is_feature_line:\n+            line = line.replace(\"(\", \"\").replace(\"),\", \"\").replace(\")\", \"\")\n+            parts = line.split(\",\")\n+            if len(parts) != 3:\n+                print \"unexpected number of components in line: \" + original_line\n+                sys.exit(1)\n+            feature_name = parts[0].strip().replace('\"', \"\")\n+            since = parts[1].strip().replace('\"', \"\")\n+            status = parts[2].strip()\n+            assert len(feature_name) > 0\n+            assert len(since) > 0\n+            assert len(status) > 0\n+\n+            language_feature_names += [feature_name]\n+            language_features += [(feature_name, since, status)]\n+\n+assert len(language_features) > 0\n+\n+errors = False\n+\n+lib_features = { }\n+lib_features_and_level = { }\n+for (dirpath, dirnames, filenames) in os.walk(src_dir):\n+    # Don't look for feature names in tests\n+    if \"src/test\" in dirpath:\n+        continue\n+\n+    # Takes a long time to traverse LLVM\n+    if \"src/llvm\" in dirpath:\n+        continue\n+\n+    for filename in filenames:\n+        if not filename.endswith(\".rs\"):\n+            continue\n+\n+        path = os.path.join(dirpath, filename)\n+        with open(path, 'r') as f:\n+            line_num = 0\n+            for line in f:\n+                line_num += 1\n+                level = None\n+                if \"[unstable(\" in line:\n+                    level = \"unstable\"\n+                elif \"[stable(\" in line:\n+                    level = \"stable\"\n+                elif \"[deprecated(\" in line:\n+                    level = \"deprecated\"\n+                else:\n+                    continue\n+\n+                # This is a stability attribute. For the purposes of this\n+                # script we expect both the 'feature' and 'since' attributes on\n+                # the same line, e.g.\n+                # `#[unstable(feature = \"foo\", since = \"1.0.0\")]`\n+\n+                p = re.compile('feature *= *\"(\\w*)\".*since *= *\"([\\w\\.]*)\"')\n+                m = p.search(line)\n+                if not m is None:\n+                    feature_name = m.group(1)\n+                    since = m.group(2)\n+                    lib_features[feature_name] = feature_name\n+                    if lib_features_and_level.get((feature_name, level)) is None:\n+                        # Add it to the observed features\n+                        lib_features_and_level[(feature_name, level)] = (since, path, line_num, line)\n+                    else:\n+                        # Verify that for this combination of feature_name and level the 'since'\n+                        # attribute matches.\n+                        (expected_since, source_path, source_line_num, source_line) = \\\n+                            lib_features_and_level.get((feature_name, level))\n+                        if since != expected_since:\n+                            print \"mismatch in \" + level + \" feature '\" + feature_name + \"'\"\n+                            print \"line \" + str(source_line_num) + \" of \" + source_path + \":\"\n+                            print source_line\n+                            print \"line \" + str(line_num) + \" of \" + path + \":\"\n+                            print line\n+                            errors = True\n+\n+                    # Verify that this lib feature doesn't duplicate a lang feature\n+                    if feature_name in language_feature_names:\n+                        print \"lib feature '\" + feature_name + \"' duplicates a lang feature\"\n+                        print \"line \" + str(line_num) + \" of \" + path + \":\"\n+                        print line\n+                        errors = True\n+\n+                else:\n+                    print \"misformed stability attribute\"\n+                    print \"line \" + str(line_num) + \" of \" + path + \":\"\n+                    print line\n+                    errors = True\n+\n+# Merge data about both lists\n+# name, lang, lib, status, stable since, partially deprecated\n+\n+language_feature_stats = {}\n+\n+for f in language_features:\n+    name = f[0]\n+    lang = True\n+    lib = False\n+    status = \"unstable\"\n+    stable_since = None\n+    partially_deprecated = False\n+    \n+    if f[2] == \"Accepted\":\n+        status = \"stable\"\n+    if status == \"stable\":\n+        stable_since = f[1]\n+\n+    language_feature_stats[name] = (name, lang, lib, status, stable_since, \\\n+                                    partially_deprecated)\n+\n+lib_feature_stats = {}\n+\n+for f in lib_features:\n+    name = f\n+    lang = False\n+    lib = True\n+    status = \"unstable\"\n+    stable_since = None\n+    partially_deprecated = False\n+\n+    is_stable = lib_features_and_level.get((name, \"stable\")) is not None\n+    is_unstable = lib_features_and_level.get((name, \"unstable\")) is not None\n+    is_deprecated = lib_features_and_level.get((name, \"deprecated\")) is not None\n+\n+    if is_stable and is_unstable:\n+        print \"feature '\" + name + \"' is both stable and unstable\"\n+        errors = True\n+\n+    if is_stable:\n+        status = \"stable\"\n+        stable_since = lib_features_and_level[(name, \"stable\")][0]\n+    elif is_unstable:\n+        status = \"unstable\"\n+        stable_since = lib_features_and_level[(name, \"unstable\")][0]\n+    elif is_deprecated:\n+        status = \"deprecated\"\n+\n+    if (is_stable or is_unstable) and is_deprecated:\n+        partially_deprecated = True\n+\n+    lib_feature_stats[name] = (name, lang, lib, status, stable_since, \\\n+                               partially_deprecated)\n+\n+# Check for overlap in two sets\n+merged_stats = { }\n+\n+for name in lib_feature_stats:\n+    if language_feature_stats.get(name) is not None:\n+        if not name in joint_features:\n+            print \"feature '\" + name + \"' is both a lang and lib feature but not whitelisted\"\n+            errors = True\n+        lang_status = lang_feature_stats[name][3]\n+        lib_status = lib_feature_stats[name][3]\n+        lang_stable_since = lang_feature_stats[name][4]\n+        lib_stable_since = lib_feature_stats[name][4]\n+        lang_partially_deprecated = lang_feature_stats[name][5]\n+        lib_partially_deprecated = lib_feature_stats[name][5]\n+\n+        if lang_status != lib_status and lib_status != \"deprecated\":\n+            print \"feature '\" + name + \"' has lang status \" + lang_status + \\\n+                  \" but lib status \" + lib_status\n+            errors = True\n+\n+        partially_deprecated = lang_partially_deprecated or lib_partially_deprecated\n+        if lib_status == \"deprecated\" and lang_status != \"deprecated\":\n+            partially_deprecated = True\n+\n+        if lang_stable_since != lib_stable_since:\n+            print \"feature '\" + name + \"' has lang stable since \" + lang_stable_since + \\\n+                  \" but lib stable since \" + lib_stable_since\n+            errors = True\n+\n+        merged_stats[name] = (name, True, True, lang_status, lang_stable_since, \\\n+                              partially_deprecated)\n+\n+        del language_feature_stats[name]\n+        del lib_feature_stats[name]\n+\n+if errors:\n+    sys.exit(1)\n+\n+# Finally, display the stats\n+stats = {}\n+stats.update(language_feature_stats)\n+stats.update(lib_feature_stats)\n+stats.update(merged_stats)\n+lines = []\n+for s in stats:\n+    s = stats[s]\n+    type_ = \"lang\"\n+    if s[1] and s[2]:\n+        type_ = \"lang/lib\"\n+    elif s[2]:\n+        type_ = \"lib\"\n+    line = s[0] + \",\\t\\t\\t\" + type_ + \",\\t\" + s[3] + \",\\t\" + str(s[4])\n+    line = \"{: <32}\".format(s[0]) + \\\n+           \"{: <8}\".format(type_) + \\\n+           \"{: <12}\".format(s[3]) + \\\n+           \"{: <8}\".format(str(s[4]))\n+    if s[5]:\n+        line += \"(partially deprecated)\"\n+    lines += [line]\n+\n+lines.sort()\n+\n+print\n+print \"Rust feature summary:\"\n+print\n+for line in lines:\n+    print line\n+print\n+"}, {"sha": "0554533a4aaa45f11517683b43c7f454cff6d897", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc", "patch": "@@ -24,7 +24,7 @@ use syntax::ast::{TypeMethod, Method, Generics, StructField, TypeTraitItem};\n use syntax::ast_util::is_local;\n use syntax::attr::{Stability, AttrMetaMethods};\n use syntax::visit::{FnKind, FkMethod, Visitor};\n-use syntax::feature_gate::emit_feature_err;\n+use syntax::feature_gate::emit_feature_warn;\n use util::nodemap::{NodeMap, DefIdMap, FnvHashSet};\n use util::ppaux::Repr;\n \n@@ -221,8 +221,8 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                         None => format!(\"use of unstable library feature '{}'\", feature.get())\n                     };\n \n-                    emit_feature_err(&self.tcx.sess.parse_sess.span_diagnostic,\n-                                     feature.get(), span, &msg[]);\n+                    emit_feature_warn(&self.tcx.sess.parse_sess.span_diagnostic,\n+                                      feature.get(), span, &msg[]);\n                 }\n             }\n             Some(..) => {"}, {"sha": "43af53aa2d2e073068e842c1fd22e32c4f7ed511", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 77, "deletions": 64, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=11f4d62a062a5c80fad414c457e2a7dbc9a1d6cc", "patch": "@@ -17,6 +17,10 @@\n //!\n //! Features are enabled in programs via the crate-level attributes of\n //! `#![feature(...)]` with a comma-separated list of features.\n+//!\n+//! For the purpose of future feature-tracking, once code for detection of feature\n+//! gate usage is added, *do not remove it again* even once the feature\n+//! becomes stable.\n use self::Status::*;\n \n use abi::RustIntrinsic;\n@@ -33,77 +37,82 @@ use parse::token::{self, InternedString};\n use std::slice;\n use std::ascii::AsciiExt;\n \n-\n-// if you change this list without updating src/doc/reference.md, @cmr will be sad\n-static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n-    (\"globs\", Accepted),\n-    (\"macro_rules\", Accepted),\n-    (\"struct_variant\", Accepted),\n-    (\"asm\", Active),\n-    (\"managed_boxes\", Removed),\n-    (\"non_ascii_idents\", Active),\n-    (\"thread_local\", Active),\n-    (\"link_args\", Active),\n-    (\"phase\", Removed),\n-    (\"plugin_registrar\", Active),\n-    (\"log_syntax\", Active),\n-    (\"trace_macros\", Active),\n-    (\"concat_idents\", Active),\n-    (\"unsafe_destructor\", Active),\n-    (\"intrinsics\", Active),\n-    (\"lang_items\", Active),\n-\n-    (\"simd\", Active),\n-    (\"default_type_params\", Accepted),\n-    (\"quote\", Active),\n-    (\"link_llvm_intrinsics\", Active),\n-    (\"linkage\", Active),\n-    (\"struct_inherit\", Removed),\n-\n-    (\"quad_precision_float\", Removed),\n-\n-    (\"rustc_diagnostic_macros\", Active),\n-    (\"unboxed_closures\", Active),\n-    (\"import_shadowing\", Active),\n-    (\"advanced_slice_patterns\", Active),\n-    (\"tuple_indexing\", Accepted),\n-    (\"associated_types\", Accepted),\n-    (\"visible_private_types\", Active),\n-    (\"slicing_syntax\", Active),\n-    (\"box_syntax\", Active),\n-    (\"on_unimplemented\", Active),\n-    (\"simd_ffi\", Active),\n-\n-    (\"if_let\", Accepted),\n-    (\"while_let\", Accepted),\n-\n-    (\"plugin\", Active),\n-    (\"start\", Active),\n-    (\"main\", Active),\n+// If you change this list without updating src/doc/reference.md, @cmr will be sad\n+// Don't ever remove anything from this list; set them to 'Removed'.\n+// The version numbers here correspond to the version in which the current status\n+// was set. This is most important for knowing when a particular feature became\n+// stable (active).\n+// NB: The featureck.py script parses this information directly out of the source\n+// so take care when modifying it.\n+static KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n+    (\"globs\", \"1.0.0\", Accepted),\n+    (\"macro_rules\", \"1.0.0\", Accepted),\n+    (\"struct_variant\", \"1.0.0\", Accepted),\n+    (\"asm\", \"1.0.0\", Active),\n+    (\"managed_boxes\", \"1.0.0\", Removed),\n+    (\"non_ascii_idents\", \"1.0.0\", Active),\n+    (\"thread_local\", \"1.0.0\", Active),\n+    (\"link_args\", \"1.0.0\", Active),\n+    (\"phase\", \"1.0.0\", Removed),\n+    (\"plugin_registrar\", \"1.0.0\", Active),\n+    (\"log_syntax\", \"1.0.0\", Active),\n+    (\"trace_macros\", \"1.0.0\", Active),\n+    (\"concat_idents\", \"1.0.0\", Active),\n+    (\"unsafe_destructor\", \"1.0.0\", Active),\n+    (\"intrinsics\", \"1.0.0\", Active),\n+    (\"lang_items\", \"1.0.0\", Active),\n+\n+    (\"simd\", \"1.0.0\", Active),\n+    (\"default_type_params\", \"1.0.0\", Accepted),\n+    (\"quote\", \"1.0.0\", Active),\n+    (\"link_llvm_intrinsics\", \"1.0.0\", Active),\n+    (\"linkage\", \"1.0.0\", Active),\n+    (\"struct_inherit\", \"1.0.0\", Removed),\n+\n+    (\"quad_precision_float\", \"1.0.0\", Removed),\n+\n+    (\"rustc_diagnostic_macros\", \"1.0.0\", Active),\n+    (\"unboxed_closures\", \"1.0.0\", Active),\n+    (\"import_shadowing\", \"1.0.0\", Active),\n+    (\"advanced_slice_patterns\", \"1.0.0\", Active),\n+    (\"tuple_indexing\", \"1.0.0\", Accepted),\n+    (\"associated_types\", \"1.0.0\", Accepted),\n+    (\"visible_private_types\", \"1.0.0\", Active),\n+    (\"slicing_syntax\", \"1.0.0\", Active),\n+    (\"box_syntax\", \"1.0.0\", Active),\n+    (\"on_unimplemented\", \"1.0.0\", Active),\n+    (\"simd_ffi\", \"1.0.0\", Active),\n+\n+    (\"if_let\", \"1.0.0\", Accepted),\n+    (\"while_let\", \"1.0.0\", Accepted),\n+\n+    (\"plugin\", \"1.0.0\", Active),\n+    (\"start\", \"1.0.0\", Active),\n+    (\"main\", \"1.0.0\", Active),\n \n     // A temporary feature gate used to enable parser extensions needed\n     // to bootstrap fix for #5723.\n-    (\"issue_5723_bootstrap\", Accepted),\n+    (\"issue_5723_bootstrap\", \"1.0.0\", Accepted),\n \n     // A way to temporarily opt out of opt in copy. This will *never* be accepted.\n-    (\"opt_out_copy\", Removed),\n+    (\"opt_out_copy\", \"1.0.0\", Removed),\n \n     // A way to temporarily opt out of the new orphan rules. This will *never* be accepted.\n-    (\"old_orphan_check\", Deprecated),\n+    (\"old_orphan_check\", \"1.0.0\", Deprecated),\n \n     // A way to temporarily opt out of the new impl rules. This will *never* be accepted.\n-    (\"old_impl_check\", Deprecated),\n+    (\"old_impl_check\", \"1.0.0\", Deprecated),\n \n     // OIBIT specific features\n-    (\"optin_builtin_traits\", Active),\n+    (\"optin_builtin_traits\", \"1.0.0\", Active),\n \n     // int and uint are now deprecated\n-    (\"int_uint\", Active),\n+    (\"int_uint\", \"1.0.0\", Active),\n \n     // These are used to test this portion of the compiler, they don't actually\n     // mean anything\n-    (\"test_accepted_feature\", Accepted),\n-    (\"test_removed_feature\", Removed),\n+    (\"test_accepted_feature\", \"1.0.0\", Accepted),\n+    (\"test_removed_feature\", \"1.0.0\", Removed),\n ];\n \n enum Status {\n@@ -164,10 +173,7 @@ impl<'a> Context<'a> {\n \n     fn warn_feature(&self, feature: &str, span: Span, explain: &str) {\n         if !self.has_feature(feature) {\n-            self.span_handler.span_warn(span, explain);\n-            self.span_handler.span_help(span, &format!(\"add #![feature({})] to the \\\n-                                                       crate attributes to silence this warning\",\n-                                                      feature)[]);\n+            emit_feature_warn(self.span_handler, feature, span, explain);\n         }\n     }\n     fn has_feature(&self, feature: &str) -> bool {\n@@ -182,6 +188,13 @@ pub fn emit_feature_err(diag: &SpanHandler, feature: &str, span: Span, explain:\n                                   feature)[]);\n }\n \n+pub fn emit_feature_warn(diag: &SpanHandler, feature: &str, span: Span, explain: &str) {\n+    diag.span_warn(span, explain);\n+    diag.span_help(span, &format!(\"add #![feature({})] to the \\\n+                                   crate attributes to silence this warning\",\n+                                   feature)[]);\n+}\n+\n struct MacroVisitor<'a> {\n     context: &'a Context<'a>\n }\n@@ -510,21 +523,21 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n                         }\n                     };\n                     match KNOWN_FEATURES.iter()\n-                                        .find(|& &(n, _)| name == n) {\n-                        Some(&(name, Active)) => {\n+                                        .find(|& &(n, _, _)| name == n) {\n+                        Some(&(name, _, Active)) => {\n                             cx.features.push(name);\n                         }\n-                        Some(&(name, Deprecated)) => {\n+                        Some(&(name, _, Deprecated)) => {\n                             cx.features.push(name);\n                             span_handler.span_warn(\n                                 mi.span,\n                                 \"feature is deprecated and will only be available \\\n                                  for a limited time, please rewrite code that relies on it\");\n                         }\n-                        Some(&(_, Removed)) => {\n+                        Some(&(_, _, Removed)) => {\n                             span_handler.span_err(mi.span, \"feature has been removed\");\n                         }\n-                        Some(&(_, Accepted)) => {\n+                        Some(&(_, _, Accepted)) => {\n                             span_handler.span_warn(mi.span, \"feature has been added to Rust, \\\n                                                              directive not necessary\");\n                         }"}]}