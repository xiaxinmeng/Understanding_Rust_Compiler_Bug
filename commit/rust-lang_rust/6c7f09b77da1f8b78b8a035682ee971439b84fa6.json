{"sha": "6c7f09b77da1f8b78b8a035682ee971439b84fa6", "node_id": "C_kwDOAAsO6NoAKDZjN2YwOWI3N2RhMWY4Yjc4YjhhMDM1NjgyZWU5NzE0MzliODRmYTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-18T19:38:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-18T19:38:24Z"}, "message": "Auto merge of #2792 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "f69278760a89acf06afe01e551473fd080b4e406", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f69278760a89acf06afe01e551473fd080b4e406"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c7f09b77da1f8b78b8a035682ee971439b84fa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c7f09b77da1f8b78b8a035682ee971439b84fa6", "html_url": "https://github.com/rust-lang/rust/commit/6c7f09b77da1f8b78b8a035682ee971439b84fa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c7f09b77da1f8b78b8a035682ee971439b84fa6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73f83ffc0f1a2349d9b980e0168c8b606c2fb152", "url": "https://api.github.com/repos/rust-lang/rust/commits/73f83ffc0f1a2349d9b980e0168c8b606c2fb152", "html_url": "https://github.com/rust-lang/rust/commit/73f83ffc0f1a2349d9b980e0168c8b606c2fb152"}, {"sha": "b76b26ee1aff1cb1bf4ea5c66da3b938ddd3bdcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b76b26ee1aff1cb1bf4ea5c66da3b938ddd3bdcc", "html_url": "https://github.com/rust-lang/rust/commit/b76b26ee1aff1cb1bf4ea5c66da3b938ddd3bdcc"}], "stats": {"total": 5742, "additions": 3551, "deletions": 2191}, "files": [{"sha": "d02cab38ae8f33d87872bc8f39f153919335237a", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -782,7 +782,7 @@ dependencies = [\n  \"declare_clippy_lint\",\n  \"if_chain\",\n  \"itertools\",\n- \"pulldown-cmark 0.9.2\",\n+ \"pulldown-cmark\",\n  \"quine-mc_cluskey\",\n  \"regex-syntax\",\n  \"rustc-semver\",\n@@ -2555,7 +2555,7 @@ dependencies = [\n  \"memchr\",\n  \"once_cell\",\n  \"opener\",\n- \"pulldown-cmark 0.9.2\",\n+ \"pulldown-cmark\",\n  \"regex\",\n  \"serde\",\n  \"serde_json\",\n@@ -2572,7 +2572,7 @@ dependencies = [\n  \"anyhow\",\n  \"handlebars 3.5.5\",\n  \"pretty_assertions\",\n- \"pulldown-cmark 0.7.2\",\n+ \"pulldown-cmark\",\n  \"same-file\",\n  \"serde_json\",\n  \"url\",\n@@ -3269,17 +3269,6 @@ dependencies = [\n  \"cc\",\n ]\n \n-[[package]]\n-name = \"pulldown-cmark\"\n-version = \"0.7.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ca36dea94d187597e104a5c8e4b07576a8a45aa5db48a65e12940d3eb7461f55\"\n-dependencies = [\n- \"bitflags\",\n- \"memchr\",\n- \"unicase\",\n-]\n-\n [[package]]\n name = \"pulldown-cmark\"\n version = \"0.9.2\"\n@@ -4583,7 +4572,7 @@ name = \"rustc_resolve\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"pulldown-cmark 0.9.2\",\n+ \"pulldown-cmark\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\","}, {"sha": "aa3a666b0b29c596ade00ff46a4d1a5ab18e3146", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -171,7 +171,9 @@ pub struct TargetDataLayout {\n \n     pub instruction_address_space: AddressSpace,\n \n-    /// Minimum size of #[repr(C)] enums (default I32 bits)\n+    /// Minimum size of #[repr(C)] enums (default c_int::BITS, usually 32)\n+    /// Note: This isn't in LLVM's data layout string, it is `short_enum`\n+    /// so the only valid spec for LLVM is c_int::BITS or 8\n     pub c_enum_min_size: Integer,\n }\n "}, {"sha": "d1ae8c1fdbd9e246c987adcf9a9e9f6cd667271b", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -271,7 +271,7 @@ impl<'a> AstValidator<'a> {\n \n         self.session.emit_err(InvalidVisibility {\n             span: vis.span,\n-            implied: if vis.kind.is_pub() { Some(vis.span) } else { None },\n+            implied: vis.kind.is_pub().then_some(vis.span),\n             note,\n         });\n     }\n@@ -294,27 +294,6 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn check_late_bound_lifetime_defs(&self, params: &[GenericParam]) {\n-        // Check only lifetime parameters are present and that the lifetime\n-        // parameters that are present have no bounds.\n-        let non_lt_param_spans: Vec<_> = params\n-            .iter()\n-            .filter_map(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => {\n-                    if !param.bounds.is_empty() {\n-                        let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-                        self.session.emit_err(ForbiddenLifetimeBound { spans });\n-                    }\n-                    None\n-                }\n-                _ => Some(param.ident.span),\n-            })\n-            .collect();\n-        if !non_lt_param_spans.is_empty() {\n-            self.session.emit_err(ForbiddenNonLifetimeParam { spans: non_lt_param_spans });\n-        }\n-    }\n-\n     fn check_fn_decl(&self, fn_decl: &FnDecl, self_semantic: SelfSemantic) {\n         self.check_decl_num_args(fn_decl);\n         self.check_decl_cvaradic_pos(fn_decl);\n@@ -745,7 +724,6 @@ impl<'a> AstValidator<'a> {\n                     )\n                     .emit();\n                 });\n-                self.check_late_bound_lifetime_defs(&bfty.generic_params);\n                 if let Extern::Implicit(_) = bfty.ext {\n                     let sig_span = self.session.source_map().next_point(ty.span.shrink_to_lo());\n                     self.maybe_lint_missing_abi(sig_span, ty.id);\n@@ -1318,9 +1296,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 WherePredicate::BoundPredicate(bound_pred) => {\n-                    // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n-                    self.check_late_bound_lifetime_defs(&bound_pred.bound_generic_params);\n-\n                     // This is slightly complicated. Our representation for poly-trait-refs contains a single\n                     // binder and thus we only allow a single level of quantification. However,\n                     // the syntax of Rust permits quantification in two places in where clauses,\n@@ -1396,11 +1371,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_param_bound(self, bound)\n     }\n \n-    fn visit_poly_trait_ref(&mut self, t: &'a PolyTraitRef) {\n-        self.check_late_bound_lifetime_defs(&t.bound_generic_params);\n-        visit::walk_poly_trait_ref(self, t);\n-    }\n-\n     fn visit_variant_data(&mut self, s: &'a VariantData) {\n         self.with_banned_assoc_ty_bound(|this| visit::walk_struct_def(this, s))\n     }\n@@ -1437,10 +1407,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 .emit();\n         }\n \n-        if let FnKind::Closure(ClosureBinder::For { generic_params, .. }, ..) = fk {\n-            self.check_late_bound_lifetime_defs(generic_params);\n-        }\n-\n         if let FnKind::Fn(\n             _,\n             _,"}, {"sha": "3af2ef4e7271eae2db53c73473882d5f205e8750", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -11,6 +11,8 @@ use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi;\n \n+use crate::errors::ForbiddenLifetimeBound;\n+\n macro_rules! gate_feature_fn {\n     ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $help: expr) => {{\n         let (visitor, has_feature, span, name, explain, help) =\n@@ -136,6 +138,34 @@ impl<'a> PostExpansionVisitor<'a> {\n         }\n         ImplTraitVisitor { vis: self }.visit_ty(ty);\n     }\n+\n+    fn check_late_bound_lifetime_defs(&self, params: &[ast::GenericParam]) {\n+        // Check only lifetime parameters are present and that the lifetime\n+        // parameters that are present have no bounds.\n+        let non_lt_param_spans: Vec<_> = params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                ast::GenericParamKind::Lifetime { .. } => None,\n+                _ => Some(param.ident.span),\n+            })\n+            .collect();\n+        // FIXME: gate_feature_post doesn't really handle multispans...\n+        if !non_lt_param_spans.is_empty() && !self.features.non_lifetime_binders {\n+            feature_err(\n+                &self.sess.parse_sess,\n+                sym::non_lifetime_binders,\n+                non_lt_param_spans,\n+                rustc_errors::fluent::ast_passes_forbidden_non_lifetime_param,\n+            )\n+            .emit();\n+        }\n+        for param in params {\n+            if !param.bounds.is_empty() {\n+                let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n+                self.sess.emit_err(ForbiddenLifetimeBound { spans });\n+            }\n+        }\n+    }\n }\n \n impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n@@ -147,7 +177,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ..\n         }) = attr_info\n         {\n-            gate_feature_fn!(self, has_feature, attr.span, *name, descr);\n+            gate_feature_fn!(self, has_feature, attr.span, *name, *descr);\n         }\n         // Check unstable flavors of the `#[doc]` attribute.\n         if attr.has_name(sym::doc) {\n@@ -306,6 +336,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::TyKind::BareFn(bare_fn_ty) => {\n                 // Function pointers cannot be `const`\n                 self.check_extern(bare_fn_ty.ext, ast::Const::No);\n+                self.check_late_bound_lifetime_defs(&bare_fn_ty.generic_params);\n             }\n             ast::TyKind::Never => {\n                 gate_feature_post!(&self, never_type, ty.span, \"the `!` type is experimental\");\n@@ -318,6 +349,19 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_ty(self, ty)\n     }\n \n+    fn visit_generics(&mut self, g: &'a ast::Generics) {\n+        for predicate in &g.where_clause.predicates {\n+            match predicate {\n+                ast::WherePredicate::BoundPredicate(bound_pred) => {\n+                    // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n+                    self.check_late_bound_lifetime_defs(&bound_pred.bound_generic_params);\n+                }\n+                _ => {}\n+            }\n+        }\n+        visit::walk_generics(self, g);\n+    }\n+\n     fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FnRetTy) {\n         if let ast::FnRetTy::Ty(output_ty) = ret_ty {\n             if let ast::TyKind::Never = output_ty.kind {\n@@ -437,12 +481,21 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_pat(self, pattern)\n     }\n \n+    fn visit_poly_trait_ref(&mut self, t: &'a ast::PolyTraitRef) {\n+        self.check_late_bound_lifetime_defs(&t.bound_generic_params);\n+        visit::walk_poly_trait_ref(self, t);\n+    }\n+\n     fn visit_fn(&mut self, fn_kind: FnKind<'a>, span: Span, _: NodeId) {\n         if let Some(header) = fn_kind.header() {\n             // Stability of const fn methods are covered in `visit_assoc_item` below.\n             self.check_extern(header.ext, header.constness);\n         }\n \n+        if let FnKind::Closure(ast::ClosureBinder::For { generic_params, .. }, ..) = fn_kind {\n+            self.check_late_bound_lifetime_defs(generic_params);\n+        }\n+\n         if fn_kind.ctxt() != Some(FnCtxt::Foreign) && fn_kind.decl().c_variadic() {\n             gate_feature_post!(&self, c_variadic, span, \"C-variadic functions are unstable\");\n         }"}, {"sha": "3d240108b4ab103585579176758d4c8e330a2377", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -731,7 +731,7 @@ pub fn eval_condition(\n                             sess,\n                             sym::cfg_target_compact,\n                             cfg.span,\n-                            &\"compact `cfg(target(..))` is experimental and subject to change\"\n+                            \"compact `cfg(target(..))` is experimental and subject to change\"\n                         ).emit();\n                     }\n "}, {"sha": "d51cc652bfd4660ff6a9e981dd7ee2da245e8bdf", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -180,20 +180,20 @@ trait TypeOpInfo<'tcx> {\n             return;\n         };\n \n-        let placeholder_region = tcx.mk_region(ty::RePlaceholder(ty::Placeholder {\n+        let placeholder_region = tcx.mk_re_placeholder(ty::Placeholder {\n             name: placeholder.name,\n             universe: adjusted_universe.into(),\n-        }));\n+        });\n \n         let error_region =\n             if let RegionElement::PlaceholderRegion(error_placeholder) = error_element {\n                 let adjusted_universe =\n                     error_placeholder.universe.as_u32().checked_sub(base_universe.as_u32());\n                 adjusted_universe.map(|adjusted| {\n-                    tcx.mk_region(ty::RePlaceholder(ty::Placeholder {\n+                    tcx.mk_re_placeholder(ty::Placeholder {\n                         name: error_placeholder.name,\n                         universe: adjusted.into(),\n-                    }))\n+                    })\n                 })\n             } else {\n                 None\n@@ -390,7 +390,7 @@ fn try_extract_error_from_fulfill_cx<'tcx>(\n         error_region,\n         &region_constraints,\n         |vid| ocx.infcx.region_var_origin(vid),\n-        |vid| ocx.infcx.universe_of_region(ocx.infcx.tcx.mk_region(ty::ReVar(vid))),\n+        |vid| ocx.infcx.universe_of_region(ocx.infcx.tcx.mk_re_var(vid)),\n     )\n }\n \n@@ -411,7 +411,7 @@ fn try_extract_error_from_region_constraints<'tcx>(\n                 }\n                 // FIXME: Should this check the universe of the var?\n                 Constraint::VarSubReg(vid, sup) if sup == placeholder_region => {\n-                    Some((infcx.tcx.mk_region(ty::ReVar(vid)), cause.clone()))\n+                    Some((infcx.tcx.mk_re_var(vid), cause.clone()))\n                 }\n                 _ => None,\n             }"}, {"sha": "b2d72654a2ac9987d7a40ddc09e68af9463bc57e", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1186,11 +1186,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 return None;\n             };\n             debug!(\"checking call args for uses of inner_param: {:?}\", args);\n-            if args.contains(&Operand::Move(inner_param)) {\n-                Some((loc, term))\n-            } else {\n-                None\n-            }\n+            args.contains(&Operand::Move(inner_param)).then_some((loc, term))\n         }) else {\n             debug!(\"no uses of inner_param found as a by-move call arg\");\n             return;\n@@ -2596,7 +2592,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if is_closure {\n                 None\n             } else {\n-                let ty = self.infcx.tcx.type_of(self.mir_def_id());\n+                let ty = self.infcx.tcx.type_of(self.mir_def_id()).subst_identity();\n                 match ty.kind() {\n                     ty::FnDef(_, _) | ty::FnPtr(_) => self.annotate_fn_sig(\n                         self.mir_def_id(),"}, {"sha": "f5bd99f15ab903d79cd17dff7f356b97b10bba6b", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1185,7 +1185,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let parent_self_ty =\n                         matches!(tcx.def_kind(parent_did), rustc_hir::def::DefKind::Impl { .. })\n                             .then_some(parent_did)\n-                            .and_then(|did| match tcx.type_of(did).kind() {\n+                            .and_then(|did| match tcx.type_of(did).subst_identity().kind() {\n                                 ty::Adt(def, ..) => Some(def.did()),\n                                 _ => None,\n                             });"}, {"sha": "a2fa3018234c7b9432af75cc15fca30ee7012fd8", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -575,7 +575,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         let mut output_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n         if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *output_ty.kind() {\n-            output_ty = self.infcx.tcx.type_of(def_id)\n+            output_ty = self.infcx.tcx.type_of(def_id).subst_identity()\n         };\n \n         debug!(\"report_fnmut_error: output_ty={:?}\", output_ty);\n@@ -896,7 +896,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             debug!(?fn_did, ?substs);\n \n             // Only suggest this on function calls, not closures\n-            let ty = tcx.type_of(fn_did);\n+            let ty = tcx.type_of(fn_did).subst_identity();\n             debug!(\"ty: {:?}, ty.kind: {:?}\", ty, ty.kind());\n             if let ty::Closure(_, _) = ty.kind() {\n                 return;"}, {"sha": "f6881a2e5bc8761378f5779365c1de06f990833d", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -280,17 +280,10 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         debug!(\"give_region_a_name: error_region = {:?}\", error_region);\n         match *error_region {\n-            ty::ReEarlyBound(ebr) => {\n-                if ebr.has_name() {\n-                    let span = tcx.hir().span_if_local(ebr.def_id).unwrap_or(DUMMY_SP);\n-                    Some(RegionName {\n-                        name: ebr.name,\n-                        source: RegionNameSource::NamedEarlyBoundRegion(span),\n-                    })\n-                } else {\n-                    None\n-                }\n-            }\n+            ty::ReEarlyBound(ebr) => ebr.has_name().then(|| {\n+                let span = tcx.hir().span_if_local(ebr.def_id).unwrap_or(DUMMY_SP);\n+                RegionName { name: ebr.name, source: RegionNameSource::NamedEarlyBoundRegion(span) }\n+            }),\n \n             ty::ReStatic => {\n                 Some(RegionName { name: kw::StaticLifetime, source: RegionNameSource::Static })\n@@ -856,8 +849,9 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             return None;\n         };\n \n-        let found = tcx\n-            .any_free_region_meets(&tcx.type_of(region_parent), |r| *r == ty::ReEarlyBound(region));\n+        let found = tcx.any_free_region_meets(&tcx.type_of(region_parent).subst_identity(), |r| {\n+            *r == ty::ReEarlyBound(region)\n+        });\n \n         Some(RegionName {\n             name: self.synthesize_region_name(),"}, {"sha": "83fdb6066c6b4a0fb4038afa5175bac4402df549", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1297,7 +1297,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let vid = self.to_region_vid(r);\n             let scc = self.constraint_sccs.scc(vid);\n             let repr = self.scc_representatives[scc];\n-            tcx.mk_region(ty::ReVar(repr))\n+            tcx.mk_re_var(repr)\n         })\n     }\n \n@@ -1719,7 +1719,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             // If not, report an error.\n-            let member_region = infcx.tcx.mk_region(ty::ReVar(member_region_vid));\n+            let member_region = infcx.tcx.mk_re_var(member_region_vid);\n             errors_buffer.push(RegionErrorKind::UnexpectedHiddenRegion {\n                 span: m_c.definition_span,\n                 hidden_ty: m_c.hidden_ty,"}, {"sha": "bb42301828d2f48608ad1dbbe08e476eb5b9a984", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -91,7 +91,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     }\n                     None => {\n                         subst_regions.push(vid);\n-                        infcx.tcx.re_error_with_message(\n+                        infcx.tcx.mk_re_error_with_message(\n                             concrete_type.span,\n                             \"opaque type with non-universal region substs\",\n                         )"}, {"sha": "a411aec518e93cd832f381e99f1bd8e26642905c", "filename": "compiler/rustc_borrowck/src/type_check/liveness/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -50,13 +50,11 @@ pub(super) fn generate<'mir, 'tcx>(\n         compute_relevant_live_locals(typeck.tcx(), &free_regions, &body);\n     let facts_enabled = use_polonius || AllFacts::enabled(typeck.tcx());\n \n-    let polonius_drop_used = if facts_enabled {\n+    let polonius_drop_used = facts_enabled.then(|| {\n         let mut drop_used = Vec::new();\n         polonius::populate_access_facts(typeck, body, location_table, move_data, &mut drop_used);\n-        Some(drop_used)\n-    } else {\n-        None\n-    };\n+        drop_used\n+    });\n \n     trace::trace(\n         typeck,"}, {"sha": "004b945eada119de86bf3c72770ffe5da0db4a31", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -137,7 +137,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     upvars: &[Upvar<'tcx>],\n     use_polonius: bool,\n ) -> MirTypeckResults<'tcx> {\n-    let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n+    let implicit_region_bound = infcx.tcx.mk_re_var(universal_regions.fr_fn_body);\n     let mut constraints = MirTypeckRegionConstraints {\n         placeholder_indices: PlaceholderIndices::default(),\n         placeholder_index_to_region: IndexVec::default(),\n@@ -402,7 +402,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     );\n                 }\n             } else if let Some(static_def_id) = constant.check_static_ptr(tcx) {\n-                let unnormalized_ty = tcx.type_of(static_def_id);\n+                let unnormalized_ty = tcx.type_of(static_def_id).subst_identity();\n                 let normalized_ty = self.cx.normalize(unnormalized_ty, locations);\n                 let literal_ty = constant.literal.ty().builtin_deref(true).unwrap().ty;\n \n@@ -2589,7 +2589,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             DefKind::InlineConst => substs.as_inline_const().parent_substs(),\n             other => bug!(\"unexpected item {:?}\", other),\n         };\n-        let parent_substs = tcx.mk_substs(parent_substs.iter());\n+        let parent_substs = tcx.intern_substs(parent_substs);\n \n         assert_eq!(typeck_root_substs.len(), parent_substs.len());\n         if let Err(_) = self.eq_substs("}, {"sha": "efa5a29c5ddf1260da3b387a04f2ea008a368cda", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -480,15 +480,10 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     LangItem::VaList,\n                     Some(self.infcx.tcx.def_span(self.mir_def.did)),\n                 );\n-                let region = self\n-                    .infcx\n-                    .tcx\n-                    .mk_region(ty::ReVar(self.infcx.next_nll_region_var(FR).to_region_vid()));\n-                let va_list_ty = self\n-                    .infcx\n-                    .tcx\n-                    .bound_type_of(va_list_did)\n-                    .subst(self.infcx.tcx, &[region.into()]);\n+                let region =\n+                    self.infcx.tcx.mk_re_var(self.infcx.next_nll_region_var(FR).to_region_vid());\n+                let va_list_ty =\n+                    self.infcx.tcx.type_of(va_list_did).subst(self.infcx.tcx, &[region.into()]);\n \n                 unnormalized_input_tys = self.infcx.tcx.mk_type_list(\n                     unnormalized_input_tys.iter().copied().chain(iter::once(va_list_ty)),\n@@ -531,7 +526,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         match tcx.hir().body_owner_kind(self.mir_def.did) {\n             BodyOwnerKind::Closure | BodyOwnerKind::Fn => {\n                 let defining_ty = if self.mir_def.did.to_def_id() == typeck_root_def_id {\n-                    tcx.type_of(typeck_root_def_id)\n+                    tcx.type_of(typeck_root_def_id).subst_identity()\n                 } else {\n                     let tables = tcx.typeck(self.mir_def.did);\n                     tables.node_type(self.mir_hir_id)\n@@ -636,7 +631,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n                     kind: ty::BrEnv,\n                 };\n-                let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+                let env_region = tcx.mk_re_late_bound(ty::INNERMOST, br);\n                 let closure_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();\n \n                 // The \"inputs\" of the closure in the\n@@ -677,7 +672,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 // For a constant body, there are no inputs, and one\n                 // \"output\" (the type of the constant).\n                 assert_eq!(self.mir_def.did.to_def_id(), def_id);\n-                let ty = tcx.type_of(self.mir_def.def_id_for_type_of());\n+                let ty = tcx.type_of(self.mir_def.def_id_for_type_of()).subst_identity();\n                 let ty = indices.fold_to_region_vids(tcx, ty);\n                 ty::Binder::dummy(tcx.intern_type_list(&[ty]))\n             }\n@@ -748,10 +743,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     {\n         let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n             debug!(?br);\n-            let liberated_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: all_outlive_scope.to_def_id(),\n-                bound_region: br.kind,\n-            }));\n+            let liberated_region = self.tcx.mk_re_free(all_outlive_scope.to_def_id(), br.kind);\n             let region_vid = self.next_nll_region_var(origin);\n             indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n             debug!(?liberated_region, ?region_vid);\n@@ -843,7 +835,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        tcx.fold_regions(value, |region, _| tcx.mk_region(ty::ReVar(self.to_region_vid(region))))\n+        tcx.fold_regions(value, |region, _| tcx.mk_re_var(self.to_region_vid(region)))\n     }\n }\n \n@@ -883,8 +875,7 @@ fn for_each_late_bound_region_in_item<'tcx>(\n \n     for bound_var in tcx.late_bound_vars(tcx.hir().local_def_id_to_hir_id(mir_def_id)) {\n         let ty::BoundVariableKind::Region(bound_region) = bound_var else { continue; };\n-        let liberated_region = tcx\n-            .mk_region(ty::ReFree(ty::FreeRegion { scope: mir_def_id.to_def_id(), bound_region }));\n+        let liberated_region = tcx.mk_re_free(mir_def_id.to_def_id(), bound_region);\n         f(liberated_region);\n     }\n }"}, {"sha": "d30e8ba4b93d63fda025fd8043405458c5341d01", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -135,19 +135,17 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         }\n \n         // `let names: &'static _ = &[\"field1\", \"field2\"];`\n-        let names_let = if is_struct {\n+        let names_let = is_struct.then(|| {\n             let lt_static = Some(cx.lifetime_static(span));\n             let ty_static_ref = cx.ty_ref(span, cx.ty_infer(span), lt_static, ast::Mutability::Not);\n-            Some(cx.stmt_let_ty(\n+            cx.stmt_let_ty(\n                 span,\n                 false,\n                 Ident::new(sym::names, span),\n                 Some(ty_static_ref),\n                 cx.expr_array_ref(span, name_exprs),\n-            ))\n-        } else {\n-            None\n-        };\n+            )\n+        });\n \n         // `let values: &[&dyn Debug] = &[&&self.field1, &&self.field2];`\n         let path_debug = cx.path_global(span, cx.std_path(&[sym::fmt, sym::Debug]));"}, {"sha": "38878ba7012f441ea334b988b4522092ba69fdc0", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -941,13 +941,11 @@ impl<'a> MethodDef<'a> {\n         let mut nonself_arg_tys = Vec::new();\n         let span = trait_.span;\n \n-        let explicit_self = if self.explicit_self {\n+        let explicit_self = self.explicit_self.then(|| {\n             let (self_expr, explicit_self) = ty::get_explicit_self(cx, span);\n             selflike_args.push(self_expr);\n-            Some(explicit_self)\n-        } else {\n-            None\n-        };\n+            explicit_self\n+        });\n \n         for (ty, name) in self.nonself_args.iter() {\n             let ast_ty = ty.to_ty(cx, span, type_ident, generics);"}, {"sha": "e67c0dba68597087f4e2d6800646a6ebb61031be", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -62,7 +62,7 @@ pub fn inject(\n     // the one with the prelude.\n     let name = names[0];\n \n-    let root = (edition == Edition2015).then(|| kw::PathRoot);\n+    let root = (edition == Edition2015).then_some(kw::PathRoot);\n \n     let import_path = root\n         .iter()"}, {"sha": "b4a2537b5ea93bcee6e177177fb1160f4a48521f", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -56,7 +56,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n                     Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n                 }\n             } else {\n-                let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n+                let out_ty = fx.tcx.intern_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n                 let oflow = CPlace::new_stack_slot(fx, fx.layout_of(fx.tcx.types.i32));\n                 let lhs = lhs.load_scalar(fx);\n                 let rhs = rhs.load_scalar(fx);\n@@ -78,7 +78,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n         }\n         BinOp::Add | BinOp::Sub | BinOp::Mul => {\n             assert!(checked);\n-            let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n+            let out_ty = fx.tcx.intern_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n             let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n             let (param_types, args) = if fx.tcx.sess.target.is_like_windows {\n                 let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);"}, {"sha": "7c6fd9f6f1ec185de1ebdeb30ca238c14a6f6683", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -248,17 +248,13 @@ fn reuse_workproduct_for_cgu(\n             dwarf_object: None,\n             bytecode: None,\n         },\n-        module_global_asm: if has_global_asm {\n-            Some(CompiledModule {\n-                name: cgu.name().to_string(),\n-                kind: ModuleKind::Regular,\n-                object: Some(obj_out_global_asm),\n-                dwarf_object: None,\n-                bytecode: None,\n-            })\n-        } else {\n-            None\n-        },\n+        module_global_asm: has_global_asm.then(|| CompiledModule {\n+            name: cgu.name().to_string(),\n+            kind: ModuleKind::Regular,\n+            object: Some(obj_out_global_asm),\n+            dwarf_object: None,\n+            bytecode: None,\n+        }),\n         existing_work_product: Some((cgu.work_product_id(), work_product)),\n     })\n }"}, {"sha": "cbac2e667652b9a66f09735228be2bd253c5f695", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm_x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -191,7 +191,7 @@ fn llvm_add_sub<'tcx>(\n     // carry0 | carry1 -> carry or borrow respectively\n     let cb_out = fx.bcx.ins().bor(cb0, cb1);\n \n-    let layout = fx.layout_of(fx.tcx.mk_tup([fx.tcx.types.u8, fx.tcx.types.u64].iter()));\n+    let layout = fx.layout_of(fx.tcx.intern_tup(&[fx.tcx.types.u8, fx.tcx.types.u64]));\n     let val = CValue::by_val_pair(cb_out, c, layout);\n     ret.write_cvalue(fx, val);\n }"}, {"sha": "26327107df4c5069f3acffb50a17d3b930e84578", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -119,7 +119,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n                     tcx,\n                     ParamEnv::reveal_all(),\n                     report.def_id,\n-                    tcx.mk_substs([GenericArg::from(main_ret_ty)].iter()),\n+                    tcx.intern_substs(&[GenericArg::from(main_ret_ty)]),\n                 )\n                 .unwrap()\n                 .unwrap()"}, {"sha": "05905a7bcdf30bb2cfbbfb4542ad2c9bf87bd548", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -289,7 +289,7 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n         _ => bug!(\"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\", bin_op, in_lhs, in_rhs),\n     };\n \n-    let out_layout = fx.layout_of(fx.tcx.mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()));\n+    let out_layout = fx.layout_of(fx.tcx.intern_tup(&[in_lhs.layout().ty, fx.tcx.types.bool]));\n     CValue::by_val_pair(res, has_overflow, out_layout)\n }\n "}, {"sha": "651d644ebb63d85364fcce023dac184e363e7bc4", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -62,7 +62,7 @@ pub fn sanitize_attrs<'ll>(\n ) -> SmallVec<[&'ll Attribute; 4]> {\n     let mut attrs = SmallVec::new();\n     let enabled = cx.tcx.sess.opts.unstable_opts.sanitizer - no_sanitize;\n-    if enabled.contains(SanitizerSet::ADDRESS) {\n+    if enabled.contains(SanitizerSet::ADDRESS) || enabled.contains(SanitizerSet::KERNELADDRESS) {\n         attrs.push(llvm::AttributeKind::SanitizeAddress.create_attr(cx.llcx));\n     }\n     if enabled.contains(SanitizerSet::MEMORY) {"}, {"sha": "40f0594b40db3ab6b29eacfb51ceabd18f4722ea", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -412,11 +412,7 @@ fn get_pgo_sample_use_path(config: &ModuleConfig) -> Option<CString> {\n }\n \n fn get_instr_profile_output_path(config: &ModuleConfig) -> Option<CString> {\n-    if config.instrument_coverage {\n-        Some(CString::new(\"default_%m_%p.profraw\").unwrap())\n-    } else {\n-        None\n-    }\n+    config.instrument_coverage.then(|| CString::new(\"default_%m_%p.profraw\").unwrap())\n }\n \n pub(crate) unsafe fn llvm_optimize(\n@@ -446,16 +442,19 @@ pub(crate) unsafe fn llvm_optimize(\n             sanitize_thread: config.sanitizer.contains(SanitizerSet::THREAD),\n             sanitize_hwaddress: config.sanitizer.contains(SanitizerSet::HWADDRESS),\n             sanitize_hwaddress_recover: config.sanitizer_recover.contains(SanitizerSet::HWADDRESS),\n+            sanitize_kernel_address: config.sanitizer.contains(SanitizerSet::KERNELADDRESS),\n+            sanitize_kernel_address_recover: config\n+                .sanitizer_recover\n+                .contains(SanitizerSet::KERNELADDRESS),\n         })\n     } else {\n         None\n     };\n \n-    let mut llvm_profiler = if cgcx.prof.llvm_recording_enabled() {\n-        Some(LlvmSelfProfiler::new(cgcx.prof.get_self_profiler().unwrap()))\n-    } else {\n-        None\n-    };\n+    let mut llvm_profiler = cgcx\n+        .prof\n+        .llvm_recording_enabled()\n+        .then(|| LlvmSelfProfiler::new(cgcx.prof.get_self_profiler().unwrap()));\n \n     let llvm_selfprofiler =\n         llvm_profiler.as_mut().map(|s| s as *mut _ as *mut c_void).unwrap_or(std::ptr::null_mut());"}, {"sha": "9116e71beac83f0aa9b1ac94b1f21ee331f2ac02", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -521,7 +521,7 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n \n                 // The semantics of #[used] in Rust only require the symbol to make it into the\n                 // object file. It is explicitly allowed for the linker to strip the symbol if it\n-                // is dead, which means we are allowed use `llvm.compiler.used` instead of\n+                // is dead, which means we are allowed to use `llvm.compiler.used` instead of\n                 // `llvm.used` here.\n                 //\n                 // Additionally, https://reviews.llvm.org/D97448 in LLVM 13 started emitting unique\n@@ -532,7 +532,7 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n                 // That said, we only ever emit these when compiling for ELF targets, unless\n                 // `#[used(compiler)]` is explicitly requested. This is to avoid similar breakage\n                 // on other targets, in particular MachO targets have *their* static constructor\n-                // lists broken if `llvm.compiler.used` is emitted rather than llvm.used. However,\n+                // lists broken if `llvm.compiler.used` is emitted rather than `llvm.used`. However,\n                 // that check happens when assigning the `CodegenFnAttrFlags` in `rustc_hir_analysis`,\n                 // so we don't need to take care of it here.\n                 self.add_compiler_used_global(g);"}, {"sha": "37ee0e14020c3a3ad8878be0212b4c466531a2c0", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -145,8 +145,13 @@ pub unsafe fn create_module<'ll>(\n     let llvm_version = llvm_util::get_version();\n     if llvm_version < (16, 0, 0) {\n         if sess.target.arch == \"s390x\" {\n+            // LLVM 16 data layout changed to always set 64-bit vector alignment,\n+            // which is conditional in earlier LLVM versions.\n+            // https://reviews.llvm.org/D131158 for the discussion.\n             target_data_layout = target_data_layout.replace(\"-v128:64\", \"\");\n         } else if sess.target.arch == \"riscv64\" {\n+            // LLVM 16 introduced this change so as to produce more efficient code.\n+            // See https://reviews.llvm.org/D116735 for the discussion.\n             target_data_layout = target_data_layout.replace(\"-n32:64-\", \"-n64-\");\n         }\n     }\n@@ -402,12 +407,8 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n \n         let (llcx, llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n \n-        let coverage_cx = if tcx.sess.instrument_coverage() {\n-            let covctx = coverageinfo::CrateCoverageContext::new();\n-            Some(covctx)\n-        } else {\n-            None\n-        };\n+        let coverage_cx =\n+            tcx.sess.instrument_coverage().then(coverageinfo::CrateCoverageContext::new);\n \n         let dbg_cx = if tcx.sess.opts.debuginfo != DebugInfo::None {\n             let dctx = debuginfo::CodegenUnitDebugContext::new(llmod);"}, {"sha": "3dc0ac03312e9a4b365ecf0295a9d5c06a9b7562", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -27,8 +27,6 @@ use rustc_middle::ty::Instance;\n use std::cell::RefCell;\n use std::ffi::CString;\n \n-use std::iter;\n-\n pub mod mapgen;\n \n const UNUSED_FUNCTION_COUNTER_ID: CounterValueReference = CounterValueReference::START;\n@@ -201,7 +199,7 @@ fn declare_unused_fn<'tcx>(cx: &CodegenCx<'_, 'tcx>, def_id: DefId) -> Instance<\n         tcx.symbol_name(instance).name,\n         cx.fn_abi_of_fn_ptr(\n             ty::Binder::dummy(tcx.mk_fn_sig(\n-                iter::once(tcx.mk_unit()),\n+                [tcx.mk_unit()],\n                 tcx.mk_unit(),\n                 false,\n                 hir::Unsafety::Unsafe,"}, {"sha": "cef403b9f8b876d7aef0961365b78805ce2c5ef0", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -508,7 +508,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     let impl_self_ty = cx.tcx.subst_and_normalize_erasing_regions(\n                         instance.substs,\n                         ty::ParamEnv::reveal_all(),\n-                        cx.tcx.type_of(impl_def_id),\n+                        cx.tcx.type_of(impl_def_id).skip_binder(),\n                     );\n \n                     // Only \"class\" methods are generally understood by LLVM,"}, {"sha": "39afb4af6f68eba9c99e7186e33cc588089ad062", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -22,7 +22,6 @@ use rustc_target::abi::{self, Align, HasDataLayout, Primitive};\n use rustc_target::spec::{HasTargetSpec, PanicStrategy};\n \n use std::cmp::Ordering;\n-use std::iter;\n \n fn get_simple_intrinsic<'ll>(\n     cx: &CodegenCx<'ll, '_>,\n@@ -798,23 +797,23 @@ fn get_rust_try_fn<'ll, 'tcx>(\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n     // `unsafe fn(*mut i8) -> ()`\n     let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n-        iter::once(i8p),\n+        [i8p],\n         tcx.mk_unit(),\n         false,\n         hir::Unsafety::Unsafe,\n         Abi::Rust,\n     )));\n     // `unsafe fn(*mut i8, *mut i8) -> ()`\n     let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n-        [i8p, i8p].iter().cloned(),\n+        [i8p, i8p],\n         tcx.mk_unit(),\n         false,\n         hir::Unsafety::Unsafe,\n         Abi::Rust,\n     )));\n     // `unsafe fn(unsafe fn(*mut i8) -> (), *mut i8, unsafe fn(*mut i8, *mut i8) -> ()) -> i32`\n     let rust_fn_sig = ty::Binder::dummy(cx.tcx.mk_fn_sig(\n-        [try_fn_ty, i8p, catch_fn_ty].into_iter(),\n+        [try_fn_ty, i8p, catch_fn_ty],\n         tcx.types.i32,\n         false,\n         hir::Unsafety::Unsafe,"}, {"sha": "7aab666fc5e8c8ae09c6e5b19a9fb70eabb5bc96", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -482,6 +482,8 @@ pub struct SanitizerOptions {\n     pub sanitize_thread: bool,\n     pub sanitize_hwaddress: bool,\n     pub sanitize_hwaddress_recover: bool,\n+    pub sanitize_kernel_address: bool,\n+    pub sanitize_kernel_address_recover: bool,\n }\n \n /// LLVMRelocMode"}, {"sha": "cc8ff947fc31f9eb67fea52c3c57dce7aa63b0b4", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -154,7 +154,7 @@ fn struct_llfields<'a, 'tcx>(\n     } else {\n         debug!(\"struct_llfields: offset: {:?} stride: {:?}\", offset, layout.size);\n     }\n-    let field_remapping = if padding_used { Some(field_remapping) } else { None };\n+    let field_remapping = padding_used.then_some(field_remapping);\n     (result, packed, field_remapping)\n }\n "}, {"sha": "8aa744ce93531e4c578d4d88c4592b8c7a2c44c9", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -2024,7 +2024,7 @@ fn linker_with_args<'a>(\n         .native_libraries\n         .iter()\n         .filter_map(|(cnum, libraries)| {\n-            (dependency_linkage[cnum.as_usize() - 1] != Linkage::Static).then(|| libraries)\n+            (dependency_linkage[cnum.as_usize() - 1] != Linkage::Static).then_some(libraries)\n         })\n         .flatten();\n     for (raw_dylib_name, raw_dylib_imports) in"}, {"sha": "023d38e931284279a8531c548be883eb649879e1", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -579,7 +579,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         }\n     }\n \n-    let metadata_module = if need_metadata_module {\n+    let metadata_module = need_metadata_module.then(|| {\n         // Emit compressed metadata object.\n         let metadata_cgu_name =\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"metadata\")).to_string();\n@@ -594,17 +594,15 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             if let Err(error) = std::fs::write(&file_name, data) {\n                 tcx.sess.emit_fatal(errors::MetadataObjectFileWrite { error });\n             }\n-            Some(CompiledModule {\n+            CompiledModule {\n                 name: metadata_cgu_name,\n                 kind: ModuleKind::Metadata,\n                 object: Some(file_name),\n                 dwarf_object: None,\n                 bytecode: None,\n-            })\n+            }\n         })\n-    } else {\n-        None\n-    };\n+    });\n \n     let ongoing_codegen = start_async_codegen(\n         backend.clone(),"}, {"sha": "7d5c0048626c9dadc7308059409382c2813d79a5", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -295,7 +295,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n             if let Some(list) = attr.meta_item_list() {\n                 for item in list.iter() {\n                     if item.has_name(sym::address) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::ADDRESS;\n+                        codegen_fn_attrs.no_sanitize |=\n+                            SanitizerSet::ADDRESS | SanitizerSet::KERNELADDRESS;\n                     } else if item.has_name(sym::cfi) {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n                     } else if item.has_name(sym::kcfi) {"}, {"sha": "7d51cee307e9278eb773cb62407ea54bd1091e54", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -13,7 +13,7 @@\n \n //! This crate contains codegen code that is used by all codegen backends (LLVM and others).\n //! The backend-agnostic functions of this crate use functions defined in various traits that\n-//! have to be implemented by each backends.\n+//! have to be implemented by each backend.\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "eec91ffa44a0bb353f0908f0db69cab7da81f76c", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -167,8 +167,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         start_bx.set_personality_fn(cx.eh_personality());\n     }\n \n-    let cleanup_kinds =\n-        if base::wants_msvc_seh(cx.tcx().sess) { Some(analyze::cleanup_kinds(&mir)) } else { None };\n+    let cleanup_kinds = base::wants_msvc_seh(cx.tcx().sess).then(|| analyze::cleanup_kinds(&mir));\n \n     let cached_llbbs: IndexVec<mir::BasicBlock, CachedLlbb<Bx::BasicBlock>> =\n         mir.basic_blocks"}, {"sha": "0432a9c5a129c2088628835a3dc3e05c99e5c7d8", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -286,6 +286,7 @@ const WASM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"mutable-globals\", Some(sym::wasm_target_feature)),\n     (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n     (\"reference-types\", Some(sym::wasm_target_feature)),\n+    (\"relaxed-simd\", Some(sym::wasm_target_feature)),\n     (\"sign-ext\", Some(sym::wasm_target_feature)),\n     (\"simd128\", None),\n     // tidy-alphabetical-end"}, {"sha": "f6a3937870edd3b32cde617c922b6dc2e6fa1763", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -95,8 +95,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Allocate memory for `CallerLocation` struct.\n         let loc_ty = self\n             .tcx\n-            .bound_type_of(self.tcx.require_lang_item(LangItem::PanicLocation, None))\n-            .subst(*self.tcx, self.tcx.mk_substs([self.tcx.lifetimes.re_erased.into()].iter()));\n+            .type_of(self.tcx.require_lang_item(LangItem::PanicLocation, None))\n+            .subst(*self.tcx, self.tcx.intern_substs(&[self.tcx.lifetimes.re_erased.into()]));\n         let loc_layout = self.layout_of(loc_ty).unwrap();\n         let location = self.allocate(loc_layout, MemoryKind::CallerLocation).unwrap();\n "}, {"sha": "f4e03ad8c593d0d9916755d455d2ea25d2f570a0", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -690,7 +690,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert!(self.tcx.is_static(def_id));\n                 assert!(!self.tcx.is_thread_local_static(def_id));\n                 // Use size and align of the type.\n-                let ty = self.tcx.type_of(def_id);\n+                let ty = self\n+                    .tcx\n+                    .type_of(def_id)\n+                    .no_bound_vars()\n+                    .expect(\"statics should not have generic parameters\");\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n                 assert!(layout.is_sized());\n                 (layout.size, layout.align.abi, AllocKind::LiveData)"}, {"sha": "0e4501922f4165bdc538bc372cf2749317bcd6ff", "filename": "compiler/rustc_const_eval/src/transform/check_consts/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -68,7 +68,7 @@ impl<'mir, 'tcx> ConstCx<'mir, 'tcx> {\n     pub fn fn_sig(&self) -> PolyFnSig<'tcx> {\n         let did = self.def_id().to_def_id();\n         if self.tcx.is_closure(did) {\n-            let ty = self.tcx.type_of(did);\n+            let ty = self.tcx.type_of(did).subst_identity();\n             let ty::Closure(_, substs) = ty.kind() else { bug!(\"type_of closure not ty::Closure\") };\n             substs.as_closure().sig()\n         } else {"}, {"sha": "19367d708ee746f12364bc4c258cc216a6e91c59", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -898,7 +898,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         assert_eq!(self.new_block(), START_BLOCK);\n         self.visit_rvalue(\n             &mut rvalue,\n-            Location { block: BasicBlock::new(0), statement_index: usize::MAX },\n+            Location { block: START_BLOCK, statement_index: usize::MAX },\n         );\n \n         let span = self.promoted.span;"}, {"sha": "67dbf29da3b0ae71cad63d7678c3e3594a2f88f6", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -334,7 +334,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n \n                 let kind = match parent_ty.ty.kind() {\n                     &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                        self.tcx.bound_type_of(def_id).subst(self.tcx, substs).kind()\n+                        self.tcx.type_of(def_id).subst(self.tcx, substs).kind()\n                     }\n                     kind => kind,\n                 };"}, {"sha": "44331683694b06754643cdde30349089bf70367c", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -207,8 +207,7 @@ impl SelfProfilerRef {\n     /// a measureme event, \"verbose\" generic activities also print a timing entry to\n     /// stderr if the compiler is invoked with -Ztime-passes.\n     pub fn verbose_generic_activity(&self, event_label: &'static str) -> VerboseTimingGuard<'_> {\n-        let message =\n-            if self.print_verbose_generic_activities { Some(event_label.to_owned()) } else { None };\n+        let message = self.print_verbose_generic_activities.then(|| event_label.to_owned());\n \n         VerboseTimingGuard::start(message, self.generic_activity(event_label))\n     }\n@@ -222,11 +221,9 @@ impl SelfProfilerRef {\n     where\n         A: Borrow<str> + Into<String>,\n     {\n-        let message = if self.print_verbose_generic_activities {\n-            Some(format!(\"{}({})\", event_label, event_arg.borrow()))\n-        } else {\n-            None\n-        };\n+        let message = self\n+            .print_verbose_generic_activities\n+            .then(|| format!(\"{}({})\", event_label, event_arg.borrow()));\n \n         VerboseTimingGuard::start(message, self.generic_activity_with_arg(event_label, event_arg))\n     }"}, {"sha": "211bbf4f50e68ee18a35b23f0dd031359c438ec3", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1768,7 +1768,7 @@ impl EmitterWriter {\n \n         // Render the replacements for each suggestion\n         let suggestions = suggestion.splice_lines(sm);\n-        debug!(\"emit_suggestion_default: suggestions={:?}\", suggestions);\n+        debug!(?suggestions);\n \n         if suggestions.is_empty() {\n             // Suggestions coming from macros can have malformed spans. This is a heavy handed\n@@ -1797,6 +1797,7 @@ impl EmitterWriter {\n         for (complete, parts, highlights, only_capitalization) in\n             suggestions.iter().take(MAX_SUGGESTIONS)\n         {\n+            debug!(?complete, ?parts, ?highlights);\n             notice_capitalization |= only_capitalization;\n \n             let has_deletion = parts.iter().any(|p| p.is_deletion(sm));"}, {"sha": "8c39feca88a0e62f28e7c25e84c374a86fdcc549", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -471,6 +471,8 @@ pub enum StashKey {\n     /// When an invalid lifetime e.g. `'2` should be reinterpreted\n     /// as a char literal in the parser\n     LifetimeIsChar,\n+    /// When an invalid lifetime e.g. `'\ud83d\udc31` contains emoji.\n+    LifetimeContainsEmoji,\n     /// Maybe there was a typo where a comma was forgotten before\n     /// FRU syntax\n     MaybeFruTypo,\n@@ -1066,29 +1068,26 @@ impl Handler {\n     }\n \n     pub fn has_errors(&self) -> Option<ErrorGuaranteed> {\n-        if self.inner.borrow().has_errors() { Some(ErrorGuaranteed(())) } else { None }\n+        self.inner.borrow().has_errors().then(ErrorGuaranteed::unchecked_claim_error_was_emitted)\n     }\n \n     pub fn has_errors_or_lint_errors(&self) -> Option<ErrorGuaranteed> {\n-        if self.inner.borrow().has_errors_or_lint_errors() {\n-            Some(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n-        } else {\n-            None\n-        }\n+        self.inner\n+            .borrow()\n+            .has_errors_or_lint_errors()\n+            .then(ErrorGuaranteed::unchecked_claim_error_was_emitted)\n     }\n     pub fn has_errors_or_delayed_span_bugs(&self) -> Option<ErrorGuaranteed> {\n-        if self.inner.borrow().has_errors_or_delayed_span_bugs() {\n-            Some(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n-        } else {\n-            None\n-        }\n+        self.inner\n+            .borrow()\n+            .has_errors_or_delayed_span_bugs()\n+            .then(ErrorGuaranteed::unchecked_claim_error_was_emitted)\n     }\n     pub fn is_compilation_going_to_fail(&self) -> Option<ErrorGuaranteed> {\n-        if self.inner.borrow().is_compilation_going_to_fail() {\n-            Some(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n-        } else {\n-            None\n-        }\n+        self.inner\n+            .borrow()\n+            .is_compilation_going_to_fail()\n+            .then(ErrorGuaranteed::unchecked_claim_error_was_emitted)\n     }\n \n     pub fn print_error_count(&self, registry: &Registry) {"}, {"sha": "5c845ae6d0bef4e8977fa1d690dc2eea22f7493b", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -238,12 +238,10 @@ macro_rules! configure {\n impl<'a> StripUnconfigured<'a> {\n     pub fn configure<T: HasAttrs + HasTokens>(&self, mut node: T) -> Option<T> {\n         self.process_cfg_attrs(&mut node);\n-        if self.in_cfg(node.attrs()) {\n+        self.in_cfg(node.attrs()).then(|| {\n             self.try_configure_tokens(&mut node);\n-            Some(node)\n-        } else {\n-            None\n-        }\n+            node\n+        })\n     }\n \n     fn try_configure_tokens<T: HasTokens>(&self, node: &mut T) {\n@@ -257,7 +255,7 @@ impl<'a> StripUnconfigured<'a> {\n \n     fn configure_krate_attrs(&self, mut attrs: ast::AttrVec) -> Option<ast::AttrVec> {\n         attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n-        if self.in_cfg(&attrs) { Some(attrs) } else { None }\n+        self.in_cfg(&attrs).then_some(attrs)\n     }\n \n     /// Performs cfg-expansion on `stream`, producing a new `AttrTokenStream`."}, {"sha": "6d8f7e4a0f68161ffdadcceaf5e72fdab4e9c218", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -164,8 +164,6 @@ declare_features! (\n     (active, multiple_supertrait_upcastable, \"CURRENT_RUSTC_VERSION\", None, None),\n     /// Allows using `#[omit_gdb_pretty_printer_section]`.\n     (active, omit_gdb_pretty_printer_section, \"1.5.0\", None, None),\n-    /// Allows using `+bundled,+whole-archive` native libs.\n-    (active, packed_bundled_libs, \"1.67.0\", None, None),\n     /// Allows using `#[prelude_import]` on glob `use` items.\n     (active, prelude_import, \"1.2.0\", None, None),\n     /// Used to identify crates that contain the profiler runtime.\n@@ -217,6 +215,8 @@ declare_features! (\n     (active, linkage, \"1.0.0\", Some(29603), None),\n     /// Allows declaring with `#![needs_panic_runtime]` that a panic runtime is needed.\n     (active, needs_panic_runtime, \"1.10.0\", Some(32837), None),\n+    /// Allows using `+bundled,+whole-archive` native libs.\n+    (active, packed_bundled_libs, \"CURRENT_RUSTC_VERSION\", Some(108081), None),\n     /// Allows using the `#![panic_runtime]` attribute.\n     (active, panic_runtime, \"1.10.0\", Some(32837), None),\n     /// Allows using `#[rustc_allow_const_fn_unstable]`.\n@@ -473,6 +473,8 @@ declare_features! (\n     (active, no_sanitize, \"1.42.0\", Some(39699), None),\n     /// Allows using the `non_exhaustive_omitted_patterns` lint.\n     (active, non_exhaustive_omitted_patterns_lint, \"1.57.0\", Some(89554), None),\n+    /// Allows `for<T>` binders in where-clauses\n+    (incomplete, non_lifetime_binders, \"CURRENT_RUSTC_VERSION\", Some(108185), None),\n     /// Allows making `dyn Trait` well-formed even if `Trait` is not object safe.\n     /// In that case, `dyn Trait: Trait` does not hold. Moreover, coercions and\n     /// casts in safe Rust to `dyn Trait` for such a `Trait` is also forbidden."}, {"sha": "80ec1caf521e1d59cd2b613f0326a599199a2bc3", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -574,14 +574,11 @@ impl<'hir> Generics<'hir> {\n \n     /// If there are generic parameters, return where to introduce a new one.\n     pub fn span_for_param_suggestion(&self) -> Option<Span> {\n-        if self.params.iter().any(|p| self.span.contains(p.span)) {\n+        self.params.iter().any(|p| self.span.contains(p.span)).then(|| {\n             // `fn foo<A>(t: impl Trait)`\n             //          ^ suggest `, T: Trait` here\n-            let span = self.span.with_lo(self.span.hi() - BytePos(1)).shrink_to_lo();\n-            Some(span)\n-        } else {\n-            None\n-        }\n+            self.span.with_lo(self.span.hi() - BytePos(1)).shrink_to_lo()\n+        })\n     }\n \n     /// `Span` where further predicates would be suggested, accounting for trailing commas, like\n@@ -639,7 +636,7 @@ impl<'hir> Generics<'hir> {\n                 // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n                 // as we use this method to get a span appropriate for suggestions.\n                 let bs = bound.span();\n-                if bs.can_be_used_for_suggestions() { Some(bs.shrink_to_hi()) } else { None }\n+                bs.can_be_used_for_suggestions().then(|| bs.shrink_to_hi())\n             },\n         )\n     }"}, {"sha": "e5e20aa78d9a6a355632f6a58c04008c7f95fb6a", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -77,7 +77,7 @@ fn generic_arg_mismatch_err(\n             Res::Def(DefKind::TyParam, src_def_id) => {\n                 if let Some(param_local_id) = param.def_id.as_local() {\n                     let param_name = tcx.hir().ty_param_name(param_local_id);\n-                    let param_type = tcx.type_of(param.def_id);\n+                    let param_type = tcx.type_of(param.def_id).subst_identity();\n                     if param_type.is_suggestable(tcx, false) {\n                         err.span_suggestion(\n                             tcx.def_span(src_def_id),\n@@ -97,7 +97,7 @@ fn generic_arg_mismatch_err(\n         (\n             GenericArg::Type(hir::Ty { kind: hir::TyKind::Array(_, len), .. }),\n             GenericParamDefKind::Const { .. },\n-        ) if tcx.type_of(param.def_id) == tcx.types.usize => {\n+        ) if tcx.type_of(param.def_id).skip_binder() == tcx.types.usize => {\n             let snippet = sess.source_map().span_to_snippet(tcx.hir().span(len.hir_id()));\n             if let Ok(snippet) = snippet {\n                 err.span_suggestion("}, {"sha": "2ff47237b1bf437630700df9fc036dc14af48bbc", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 67, "deletions": 35, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -14,7 +14,7 @@ use crate::errors::{\n     AmbiguousLifetimeBound, MultipleRelaxedDefaultBounds, TraitObjectDeclaredWithNoTraits,\n     TypeofReservedKeywordUsed, ValueOfAssociatedStructAlreadySpecified,\n };\n-use crate::middle::resolve_lifetime as rl;\n+use crate::middle::resolve_bound_vars as rbv;\n use crate::require_c_abi_if_c_variadic;\n use rustc_ast::TraitObjectSyntax;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -30,9 +30,9 @@ use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n+use rustc_middle::ty::DynKind;\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, Const, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeVisitable};\n-use rustc_middle::ty::{DynKind, EarlyBinder};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n@@ -225,36 +225,37 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let tcx = self.tcx();\n         let lifetime_name = |def_id| tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id));\n \n-        match tcx.named_region(lifetime.hir_id) {\n-            Some(rl::Region::Static) => tcx.lifetimes.re_static,\n+        match tcx.named_bound_var(lifetime.hir_id) {\n+            Some(rbv::ResolvedArg::StaticLifetime) => tcx.lifetimes.re_static,\n \n-            Some(rl::Region::LateBound(debruijn, index, def_id)) => {\n+            Some(rbv::ResolvedArg::LateBound(debruijn, index, def_id)) => {\n                 let name = lifetime_name(def_id.expect_local());\n                 let br = ty::BoundRegion {\n                     var: ty::BoundVar::from_u32(index),\n                     kind: ty::BrNamed(def_id, name),\n                 };\n-                tcx.mk_region(ty::ReLateBound(debruijn, br))\n+                tcx.mk_re_late_bound(debruijn, br)\n             }\n \n-            Some(rl::Region::EarlyBound(def_id)) => {\n+            Some(rbv::ResolvedArg::EarlyBound(def_id)) => {\n                 let name = tcx.hir().ty_param_name(def_id.expect_local());\n                 let item_def_id = tcx.hir().ty_param_owner(def_id.expect_local());\n                 let generics = tcx.generics_of(item_def_id);\n                 let index = generics.param_def_id_to_index[&def_id];\n-                tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, index, name }))\n+                tcx.mk_re_early_bound(ty::EarlyBoundRegion { def_id, index, name })\n             }\n \n-            Some(rl::Region::Free(scope, id)) => {\n+            Some(rbv::ResolvedArg::Free(scope, id)) => {\n                 let name = lifetime_name(id.expect_local());\n-                tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                    scope,\n-                    bound_region: ty::BrNamed(id, name),\n-                }))\n+                tcx.mk_re_free(scope, ty::BrNamed(id, name))\n \n                 // (*) -- not late-bound, won't change\n             }\n \n+            Some(rbv::ResolvedArg::Error(_)) => {\n+                bug!(\"only ty/ct should resolve as ResolvedArg::Error\")\n+            }\n+\n             None => {\n                 self.re_infer(def, lifetime.ident.span).unwrap_or_else(|| {\n                     debug!(?lifetime, \"unelided lifetime in signature\");\n@@ -263,7 +264,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     // elision. `resolve_lifetime` should have\n                     // reported an error in this case -- but if\n                     // not, let's error out.\n-                    tcx.re_error_with_message(lifetime.ident.span, \"unelided lifetime in signature\")\n+                    tcx.mk_re_error_with_message(\n+                        lifetime.ident.span,\n+                        \"unelided lifetime in signature\",\n+                    )\n                 })\n             }\n         }\n@@ -450,7 +454,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         .into()\n                     }\n                     (&GenericParamDefKind::Const { .. }, hir::GenericArg::Infer(inf)) => {\n-                        let ty = tcx.at(self.span).type_of(param.def_id);\n+                        let ty = tcx\n+                            .at(self.span)\n+                            .type_of(param.def_id)\n+                            .no_bound_vars()\n+                            .expect(\"const parameter types cannot be generic\");\n                         if self.astconv.allow_ty_infer() {\n                             self.astconv.ct_infer(ty, Some(param), inf.span).into()\n                         } else {\n@@ -477,7 +485,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             debug!(?param, \"unelided lifetime in signature\");\n \n                             // This indicates an illegal lifetime in a non-assoc-trait position\n-                            tcx.re_error_with_message(self.span, \"unelided lifetime in signature\")\n+                            tcx.mk_re_error_with_message(\n+                                self.span,\n+                                \"unelided lifetime in signature\",\n+                            )\n                         })\n                         .into(),\n                     GenericParamDefKind::Type { has_default, .. } => {\n@@ -491,7 +502,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 // Avoid ICE #86756 when type error recovery goes awry.\n                                 return tcx.ty_error().into();\n                             }\n-                            tcx.at(self.span).bound_type_of(param.def_id).subst(tcx, substs).into()\n+                            tcx.at(self.span).type_of(param.def_id).subst(tcx, substs).into()\n                         } else if infer_args {\n                             self.astconv.ty_infer(Some(param), self.span).into()\n                         } else {\n@@ -500,7 +511,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         }\n                     }\n                     GenericParamDefKind::Const { has_default } => {\n-                        let ty = tcx.at(self.span).type_of(param.def_id);\n+                        let ty = tcx\n+                            .at(self.span)\n+                            .type_of(param.def_id)\n+                            .no_bound_vars()\n+                            .expect(\"const parameter types cannot be generic\");\n                         if ty.references_error() {\n                             return tcx.const_error(ty).into();\n                         }\n@@ -1227,7 +1242,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             }\n                             hir::def::DefKind::AssocConst => tcx\n                                 .const_error_with_guaranteed(\n-                                    tcx.bound_type_of(assoc_item_def_id)\n+                                    tcx.type_of(assoc_item_def_id)\n                                         .subst(tcx, projection_ty.skip_binder().substs),\n                                     reported,\n                                 )\n@@ -1264,7 +1279,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         item_segment: &hir::PathSegment<'_>,\n     ) -> Ty<'tcx> {\n         let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n-        self.tcx().at(span).bound_type_of(did).subst(self.tcx(), substs)\n+        self.tcx().at(span).type_of(did).subst(self.tcx(), substs)\n     }\n \n     fn conv_object_ty_poly_trait_ref(\n@@ -1317,7 +1332,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     ty::Clause::TypeOutlives(_) => {\n                         // Do nothing, we deal with regions separately\n                     }\n-                    ty::Clause::RegionOutlives(_) => bug!(),\n+                    ty::Clause::RegionOutlives(_) | ty::Clause::ConstArgHasType(..) => bug!(),\n                 },\n                 ty::PredicateKind::WellFormed(_)\n                 | ty::PredicateKind::AliasEq(..)\n@@ -1597,14 +1612,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .collect::<SmallVec<[_; 8]>>();\n         v.sort_by(|a, b| a.skip_binder().stable_cmp(tcx, &b.skip_binder()));\n         v.dedup();\n-        let existential_predicates = tcx.mk_poly_existential_predicates(v.into_iter());\n+        let existential_predicates = tcx.intern_poly_existential_predicates(&v);\n \n         // Use explicitly-specified region bound.\n         let region_bound = if !lifetime.is_elided() {\n             self.ast_region_to_region(lifetime, None)\n         } else {\n             self.compute_object_lifetime_bound(span, existential_predicates).unwrap_or_else(|| {\n-                if tcx.named_region(lifetime.hir_id).is_some() {\n+                if tcx.named_bound_var(lifetime.hir_id).is_some() {\n                     self.ast_region_to_region(lifetime, None)\n                 } else {\n                     self.re_infer(None, span).unwrap_or_else(|| {\n@@ -1622,7 +1637,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         } else {\n                             err.emit()\n                         };\n-                        tcx.re_error(e)\n+                        tcx.mk_re_error(e)\n                     })\n                 }\n             })\n@@ -2043,7 +2058,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     assoc_segment,\n                     adt_substs,\n                 );\n-                let ty = tcx.bound_type_of(assoc_ty_did).subst(tcx, item_substs);\n+                let ty = tcx.type_of(assoc_ty_did).subst(tcx, item_substs);\n                 return Ok((ty, DefKind::AssocTy, assoc_ty_did));\n             }\n         }\n@@ -2597,6 +2612,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         opt_self_ty: Option<Ty<'tcx>>,\n         path: &hir::Path<'_>,\n+        hir_id: hir::HirId,\n         permit_variants: bool,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n@@ -2660,11 +2676,26 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 });\n \n-                let def_id = def_id.expect_local();\n-                let item_def_id = tcx.hir().ty_param_owner(def_id);\n-                let generics = tcx.generics_of(item_def_id);\n-                let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n-                tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id))\n+                match tcx.named_bound_var(hir_id) {\n+                    Some(rbv::ResolvedArg::LateBound(debruijn, index, _)) => {\n+                        let name =\n+                            tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n+                        let br = ty::BoundTy {\n+                            var: ty::BoundVar::from_u32(index),\n+                            kind: ty::BoundTyKind::Param(def_id, name),\n+                        };\n+                        tcx.mk_ty(ty::Bound(debruijn, br))\n+                    }\n+                    Some(rbv::ResolvedArg::EarlyBound(_)) => {\n+                        let def_id = def_id.expect_local();\n+                        let item_def_id = tcx.hir().ty_param_owner(def_id);\n+                        let generics = tcx.generics_of(item_def_id);\n+                        let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n+                        tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id))\n+                    }\n+                    Some(rbv::ResolvedArg::Error(guar)) => tcx.ty_error_with_guaranteed(guar),\n+                    arg => bug!(\"unexpected bound var resolution for {hir_id:?}: {arg:?}\"),\n+                }\n             }\n             Res::SelfTyParam { .. } => {\n                 // `Self` in trait or type alias.\n@@ -2685,7 +2716,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // `Self` in impl (we know the concrete type).\n                 assert_eq!(opt_self_ty, None);\n                 // Try to evaluate any array length constants.\n-                let ty = tcx.at(span).type_of(def_id);\n+                let ty = tcx.at(span).type_of(def_id).subst_identity();\n                 let span_of_impl = tcx.span_of_impl(def_id);\n                 self.prohibit_generics(path.segments.iter(), |err| {\n                     let def_id = match *ty.kind() {\n@@ -2882,12 +2913,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     TraitObjectSyntax::Dyn | TraitObjectSyntax::None => ty::Dyn,\n                     TraitObjectSyntax::DynStar => ty::DynStar,\n                 };\n+\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime, borrowed, repr)\n             }\n             hir::TyKind::Path(hir::QPath::Resolved(maybe_qself, path)) => {\n                 debug!(?maybe_qself, ?path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.ast_ty_to_ty(qself));\n-                self.res_to_ty(opt_self_ty, path, false)\n+                self.res_to_ty(opt_self_ty, path, ast_ty.hir_id, false)\n             }\n             &hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n                 let opaque_ty = tcx.hir().item(item_id);\n@@ -2919,7 +2951,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     None,\n                     ty::BoundConstness::NotConst,\n                 );\n-                EarlyBinder(tcx.at(span).type_of(def_id)).subst(tcx, substs)\n+                tcx.at(span).type_of(def_id).subst(tcx, substs)\n             }\n             hir::TyKind::Array(ty, length) => {\n                 let length = match length {\n@@ -2932,7 +2964,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.mk_array_with_const_len(self.ast_ty_to_ty(ty), length)\n             }\n             hir::TyKind::Typeof(e) => {\n-                let ty_erased = tcx.type_of(e.def_id);\n+                let ty_erased = tcx.type_of(e.def_id).subst_identity();\n                 let ty = tcx.fold_regions(ty_erased, |r, _| {\n                     if r.is_erased() { tcx.lifetimes.re_static } else { r }\n                 });\n@@ -3060,7 +3092,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(?output_ty);\n \n-        let fn_ty = tcx.mk_fn_sig(input_tys.into_iter(), output_ty, decl.c_variadic, unsafety, abi);\n+        let fn_ty = tcx.mk_fn_sig(input_tys, output_ty, decl.c_variadic, unsafety, abi);\n         let bare_fn_ty = ty::Binder::bind_with_vars(fn_ty, bound_vars);\n \n         if !self.allow_ty_infer() && !(visitor.0.is_empty() && infer_replacements.is_empty()) {"}, {"sha": "04396c883d3abe3b0d976a69b04898781f026196", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -93,7 +93,7 @@ fn check_union(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n \n /// Check that the fields of the `union` do not need dropping.\n fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> bool {\n-    let item_type = tcx.type_of(item_def_id);\n+    let item_type = tcx.type_of(item_def_id).subst_identity();\n     if let ty::Adt(def, substs) = item_type.kind() {\n         assert!(def.is_union());\n \n@@ -170,7 +170,7 @@ fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     // would be enough to check this for `extern` statics, as statics with an initializer will\n     // have UB during initialization if they are uninhabited, but there also seems to be no good\n     // reason to allow any statics to be uninhabited.\n-    let ty = tcx.type_of(def_id);\n+    let ty = tcx.type_of(def_id).subst_identity();\n     let span = tcx.def_span(def_id);\n     let layout = match tcx.layout_of(ParamEnv::reveal_all().and(ty)) {\n         Ok(l) => l,\n@@ -227,7 +227,7 @@ fn check_opaque(tcx: TyCtxt<'_>, id: hir::ItemId) {\n     if !tcx.features().impl_trait_projections {\n         check_opaque_for_inheriting_lifetimes(tcx, item.owner_id.def_id, span);\n     }\n-    if tcx.type_of(item.owner_id.def_id).references_error() {\n+    if tcx.type_of(item.owner_id.def_id).subst_identity().references_error() {\n         return;\n     }\n     if check_opaque_for_cycles(tcx, item.owner_id.def_id, substs, span, &origin).is_err() {\n@@ -425,7 +425,7 @@ fn check_opaque_meets_bounds<'tcx>(\n     //\n     // FIXME: Consider wrapping the hidden type in an existential `Binder` and instantiating it\n     // here rather than using ReErased.\n-    let hidden_ty = tcx.bound_type_of(def_id.to_def_id()).subst(tcx, substs);\n+    let hidden_ty = tcx.type_of(def_id.to_def_id()).subst(tcx, substs);\n     let hidden_ty = tcx.fold_regions(hidden_ty, |re, _dbi| match re.kind() {\n         ty::ReErased => infcx.next_region_var(RegionVariableOrigin::MiscVariable(span)),\n         _ => re,\n@@ -492,7 +492,7 @@ fn is_enum_of_nonnullable_ptr<'tcx>(\n \n fn check_static_linkage(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     if tcx.codegen_fn_attrs(def_id).import_linkage.is_some() {\n-        if match tcx.type_of(def_id).kind() {\n+        if match tcx.type_of(def_id).subst_identity().kind() {\n             ty::RawPtr(_) => false,\n             ty::Adt(adt_def, substs) => !is_enum_of_nonnullable_ptr(tcx, *adt_def, *substs),\n             _ => true,\n@@ -537,7 +537,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n             let assoc_items = tcx.associated_items(id.owner_id);\n             check_on_unimplemented(tcx, id);\n \n-            for assoc_item in assoc_items.in_definition_order() {\n+            for &assoc_item in assoc_items.in_definition_order() {\n                 match assoc_item.kind {\n                     ty::AssocKind::Fn => {\n                         let abi = tcx.fn_sig(assoc_item.def_id).skip_binder().abi();\n@@ -578,7 +578,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n             }\n         }\n         DefKind::TyAlias => {\n-            let pty_ty = tcx.type_of(id.owner_id);\n+            let pty_ty = tcx.type_of(id.owner_id).subst_identity();\n             let generics = tcx.generics_of(id.owner_id);\n             check_type_params_are_used(tcx, &generics, pty_ty);\n         }\n@@ -670,7 +670,7 @@ pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: hir::ItemId) {\n pub(super) fn check_specialization_validity<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_def: &ty::TraitDef,\n-    trait_item: &ty::AssocItem,\n+    trait_item: ty::AssocItem,\n     impl_id: DefId,\n     impl_item: DefId,\n ) {\n@@ -767,17 +767,17 @@ fn check_impl_items_against_trait<'tcx>(\n                 ));\n             }\n             ty::AssocKind::Fn => {\n-                compare_impl_method(tcx, &ty_impl_item, &ty_trait_item, impl_trait_ref);\n+                compare_impl_method(tcx, ty_impl_item, ty_trait_item, impl_trait_ref);\n             }\n             ty::AssocKind::Type => {\n-                compare_impl_ty(tcx, &ty_impl_item, &ty_trait_item, impl_trait_ref);\n+                compare_impl_ty(tcx, ty_impl_item, ty_trait_item, impl_trait_ref);\n             }\n         }\n \n         check_specialization_validity(\n             tcx,\n             trait_def,\n-            &ty_trait_item,\n+            ty_trait_item,\n             impl_id.to_def_id(),\n             impl_item,\n         );\n@@ -854,7 +854,7 @@ fn check_impl_items_against_trait<'tcx>(\n }\n \n pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n-    let t = tcx.type_of(def_id);\n+    let t = tcx.type_of(def_id).subst_identity();\n     if let ty::Adt(def, substs) = t.kind()\n         && def.is_struct()\n     {\n@@ -974,7 +974,7 @@ pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: ty::AdtDef<'_>) {\n                             &if first {\n                                 format!(\n                                     \"`{}` contains a field of type `{}`\",\n-                                    tcx.type_of(def.did()),\n+                                    tcx.type_of(def.did()).subst_identity(),\n                                     ident\n                                 )\n                             } else {\n@@ -996,7 +996,7 @@ pub(super) fn check_packed_inner(\n     def_id: DefId,\n     stack: &mut Vec<DefId>,\n ) -> Option<Vec<(DefId, Span)>> {\n-    if let ty::Adt(def, substs) = tcx.type_of(def_id).kind() {\n+    if let ty::Adt(def, substs) = tcx.type_of(def_id).subst_identity().kind() {\n         if def.is_struct() || def.is_union() {\n             if def.repr().align.is_some() {\n                 return Some(vec![(def.did(), DUMMY_SP)]);"}, {"sha": "a9fcc8e62501b4950ee807c4b9b0b8cfa5f17bed", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -37,8 +37,8 @@ use std::iter;\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n pub(super) fn compare_impl_method<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\", impl_trait_ref);\n@@ -129,8 +129,8 @@ pub(super) fn compare_impl_method<'tcx>(\n #[instrument(level = \"debug\", skip(tcx, impl_trait_ref))]\n fn compare_method_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n     check_implied_wf: CheckImpliedWfMode,\n ) -> Result<(), ErrorGuaranteed> {\n@@ -381,8 +381,8 @@ fn compare_method_predicate_entailment<'tcx>(\n fn extract_bad_args_for_implies_lint<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     errors: &[infer::RegionResolutionError<'tcx>],\n-    (trait_m, trait_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n-    (impl_m, impl_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n+    (trait_m, trait_sig): (ty::AssocItem, ty::FnSig<'tcx>),\n+    (impl_m, impl_sig): (ty::AssocItem, ty::FnSig<'tcx>),\n     hir_id: hir::HirId,\n ) -> Vec<(Span, Option<String>)> {\n     let mut blame_generics = vec![];\n@@ -464,14 +464,10 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for RemapLateBound<'_, 'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         if let ty::ReFree(fr) = *r {\n-            self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                bound_region: self\n-                    .mapping\n-                    .get(&fr.bound_region)\n-                    .copied()\n-                    .unwrap_or(fr.bound_region),\n-                ..fr\n-            }))\n+            self.tcx.mk_re_free(\n+                fr.scope,\n+                self.mapping.get(&fr.bound_region).copied().unwrap_or(fr.bound_region),\n+            )\n         } else {\n             r\n         }\n@@ -480,7 +476,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for RemapLateBound<'_, 'tcx> {\n \n fn emit_implied_wf_lint<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n     hir_id: hir::HirId,\n     bad_args: Vec<(Span, Option<String>)>,\n ) {\n@@ -527,8 +523,8 @@ enum CheckImpliedWfMode {\n \n fn compare_asyncness<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n ) -> Result<(), ErrorGuaranteed> {\n     if tcx.asyncness(trait_m.def_id) == hir::IsAsync::Async {\n         match tcx.fn_sig(impl_m.def_id).skip_binder().skip_binder().output().kind() {\n@@ -777,13 +773,13 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n                     }\n                     let Some(ty::ReEarlyBound(e)) = map.get(&region.into()).map(|r| r.expect_region().kind())\n                     else {\n-                        return tcx.re_error_with_message(return_span, \"expected ReFree to map to ReEarlyBound\")\n+                        return tcx.mk_re_error_with_message(return_span, \"expected ReFree to map to ReEarlyBound\")\n                     };\n-                    tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                    tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n                         def_id: e.def_id,\n                         name: e.name,\n                         index: (e.index as usize - num_trait_substs + num_impl_substs) as u32,\n-                    }))\n+                    })\n                 });\n                 debug!(%ty);\n                 collected_tys.insert(def_id, ty);\n@@ -873,8 +869,8 @@ fn report_trait_method_mismatch<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     mut cause: ObligationCause<'tcx>,\n     terr: TypeError<'tcx>,\n-    (trait_m, trait_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n-    (impl_m, impl_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n+    (trait_m, trait_sig): (ty::AssocItem, ty::FnSig<'tcx>),\n+    (impl_m, impl_sig): (ty::AssocItem, ty::FnSig<'tcx>),\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> ErrorGuaranteed {\n     let tcx = infcx.tcx;\n@@ -967,8 +963,8 @@ fn report_trait_method_mismatch<'tcx>(\n \n fn check_region_bounds_on_impl_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n     delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_generics = tcx.generics_of(impl_m.def_id);\n@@ -1042,7 +1038,7 @@ fn check_region_bounds_on_impl_item<'tcx>(\n             .sess\n             .create_err(LifetimesOrBoundsMismatchOnTrait {\n                 span,\n-                item_kind: assoc_item_kind_str(impl_m),\n+                item_kind: assoc_item_kind_str(&impl_m),\n                 ident: impl_m.ident(tcx),\n                 generics_span,\n                 bounds_span,\n@@ -1060,8 +1056,8 @@ fn extract_spans_for_error_reporting<'tcx>(\n     infcx: &infer::InferCtxt<'tcx>,\n     terr: TypeError<'_>,\n     cause: &ObligationCause<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n     let mut impl_args = {\n@@ -1084,8 +1080,8 @@ fn extract_spans_for_error_reporting<'tcx>(\n \n fn compare_self_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     // Try to give more informative error messages about self typing\n@@ -1096,7 +1092,7 @@ fn compare_self_type<'tcx>(\n     // inscrutable, particularly for cases where one method has no\n     // self.\n \n-    let self_string = |method: &ty::AssocItem| {\n+    let self_string = |method: ty::AssocItem| {\n         let untransformed_self_ty = match method.container {\n             ty::ImplContainer => impl_trait_ref.self_ty(),\n             ty::TraitContainer => tcx.types.self_param,\n@@ -1186,8 +1182,8 @@ fn compare_self_type<'tcx>(\n /// [`compare_generic_param_kinds`]. This function also does not handle lifetime parameters\n fn compare_number_of_generics<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_: &ty::AssocItem,\n-    trait_: &ty::AssocItem,\n+    impl_: ty::AssocItem,\n+    trait_: ty::AssocItem,\n     delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_own_counts = tcx.generics_of(trait_.def_id).own_counts();\n@@ -1207,7 +1203,7 @@ fn compare_number_of_generics<'tcx>(\n         (\"const\", trait_own_counts.consts, impl_own_counts.consts),\n     ];\n \n-    let item_kind = assoc_item_kind_str(impl_);\n+    let item_kind = assoc_item_kind_str(&impl_);\n \n     let mut err_occurred = None;\n     for (kind, trait_count, impl_count) in matchings {\n@@ -1329,8 +1325,8 @@ fn compare_number_of_generics<'tcx>(\n \n fn compare_number_of_method_arguments<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_m_fty = tcx.fn_sig(impl_m.def_id);\n     let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n@@ -1409,8 +1405,8 @@ fn compare_number_of_method_arguments<'tcx>(\n \n fn compare_synthetic_generics<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n ) -> Result<(), ErrorGuaranteed> {\n     // FIXME(chrisvittal) Clean up this function, list of FIXME items:\n     //     1. Better messages for the span labels\n@@ -1563,8 +1559,8 @@ fn compare_synthetic_generics<'tcx>(\n /// This function does not handle lifetime parameters\n fn compare_generic_param_kinds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_item: &ty::AssocItem,\n-    trait_item: &ty::AssocItem,\n+    impl_item: ty::AssocItem,\n+    trait_item: ty::AssocItem,\n     delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     assert_eq!(impl_item.kind, trait_item.kind);\n@@ -1609,7 +1605,11 @@ fn compare_generic_param_kinds<'tcx>(\n \n             let make_param_message = |prefix: &str, param: &ty::GenericParamDef| match param.kind {\n                 Const { .. } => {\n-                    format!(\"{} const parameter of type `{}`\", prefix, tcx.type_of(param.def_id))\n+                    format!(\n+                        \"{} const parameter of type `{}`\",\n+                        prefix,\n+                        tcx.type_of(param.def_id).subst_identity()\n+                    )\n                 }\n                 Type { .. } => format!(\"{} type parameter\", prefix),\n                 Lifetime { .. } => unreachable!(),\n@@ -1658,8 +1658,8 @@ pub(super) fn compare_impl_const_raw(\n     // Create a parameter environment that represents the implementation's\n     // method.\n     // Compute placeholder form of impl and trait const tys.\n-    let impl_ty = tcx.type_of(impl_const_item_def.to_def_id());\n-    let trait_ty = tcx.bound_type_of(trait_const_item_def).subst(tcx, trait_to_impl_substs);\n+    let impl_ty = tcx.type_of(impl_const_item_def.to_def_id()).subst_identity();\n+    let trait_ty = tcx.type_of(trait_const_item_def).subst(tcx, trait_to_impl_substs);\n     let mut cause = ObligationCause::new(\n         impl_c_span,\n         impl_const_item_def,\n@@ -1736,8 +1736,8 @@ pub(super) fn compare_impl_const_raw(\n \n pub(super) fn compare_impl_ty<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_ty: &ty::AssocItem,\n-    trait_ty: &ty::AssocItem,\n+    impl_ty: ty::AssocItem,\n+    trait_ty: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) {\n     debug!(\"compare_impl_type(impl_trait_ref={:?})\", impl_trait_ref);\n@@ -1754,8 +1754,8 @@ pub(super) fn compare_impl_ty<'tcx>(\n /// instead of associated functions.\n fn compare_type_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_ty: &ty::AssocItem,\n-    trait_ty: &ty::AssocItem,\n+    impl_ty: ty::AssocItem,\n+    trait_ty: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_substs = InternalSubsts::identity_for_item(tcx, impl_ty.def_id);\n@@ -1855,8 +1855,8 @@ fn compare_type_predicate_entailment<'tcx>(\n #[instrument(level = \"debug\", skip(tcx))]\n pub(super) fn check_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    trait_ty: &ty::AssocItem,\n-    impl_ty: &ty::AssocItem,\n+    trait_ty: ty::AssocItem,\n+    impl_ty: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     // Given\n@@ -1920,28 +1920,28 @@ pub(super) fn check_type_bounds<'tcx>(\n             let kind = ty::BoundRegionKind::BrNamed(param.def_id, param.name);\n             let bound_var = ty::BoundVariableKind::Region(kind);\n             bound_vars.push(bound_var);\n-            tcx.mk_region(ty::ReLateBound(\n+            tcx.mk_re_late_bound(\n                 ty::INNERMOST,\n                 ty::BoundRegion { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n-            ))\n+            )\n             .into()\n         }\n         GenericParamDefKind::Const { .. } => {\n             let bound_var = ty::BoundVariableKind::Const;\n             bound_vars.push(bound_var);\n             tcx.mk_const(\n                 ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(bound_vars.len() - 1)),\n-                tcx.type_of(param.def_id),\n+                tcx.type_of(param.def_id).subst_identity(),\n             )\n             .into()\n         }\n     });\n-    let bound_vars = tcx.mk_bound_variable_kinds(bound_vars.into_iter());\n+    let bound_vars = tcx.intern_bound_variable_kinds(&bound_vars);\n     let impl_ty_substs = tcx.intern_substs(&substs);\n     let container_id = impl_ty.container_id(tcx);\n \n     let rebased_substs = impl_ty_substs.rebase_onto(tcx, container_id, impl_trait_ref.substs);\n-    let impl_ty_value = tcx.type_of(impl_ty.def_id);\n+    let impl_ty_value = tcx.type_of(impl_ty.def_id).subst_identity();\n \n     let param_env = tcx.param_env(impl_ty.def_id);\n "}, {"sha": "c84e3461226dde73f5f0d4df9467b988e6e2f51d", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::ty::{self, Predicate, Ty, TyCtxt};\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), ErrorGuaranteed> {\n-    let dtor_self_type = tcx.type_of(drop_impl_did);\n+    let dtor_self_type = tcx.type_of(drop_impl_did).subst_identity();\n     let dtor_predicates = tcx.predicates_of(drop_impl_did);\n     match dtor_self_type.kind() {\n         ty::Adt(adt_def, self_to_impl_substs) => {"}, {"sha": "4720fea8ef4ab261f30de1e9d7cdb6541ee44d69", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 16, "deletions": 31, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -15,8 +15,6 @@ use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n-use std::iter;\n-\n fn equate_intrinsic_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     it: &hir::ForeignItem<'_>,\n@@ -139,25 +137,21 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let intrinsic_name = tcx.item_name(intrinsic_id);\n     let name_str = intrinsic_name.as_str();\n \n-    let bound_vars = tcx.mk_bound_variable_kinds(\n-        [\n-            ty::BoundVariableKind::Region(ty::BrAnon(0, None)),\n-            ty::BoundVariableKind::Region(ty::BrEnv),\n-        ]\n-        .iter()\n-        .copied(),\n-    );\n+    let bound_vars = tcx.intern_bound_variable_kinds(&[\n+        ty::BoundVariableKind::Region(ty::BrAnon(0, None)),\n+        ty::BoundVariableKind::Region(ty::BrEnv),\n+    ]);\n     let mk_va_list_ty = |mutbl| {\n         tcx.lang_items().va_list().map(|did| {\n-            let region = tcx.mk_region(ty::ReLateBound(\n+            let region = tcx.mk_re_late_bound(\n                 ty::INNERMOST,\n                 ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0, None) },\n-            ));\n-            let env_region = tcx.mk_region(ty::ReLateBound(\n+            );\n+            let env_region = tcx.mk_re_late_bound(\n                 ty::INNERMOST,\n                 ty::BoundRegion { var: ty::BoundVar::from_u32(1), kind: ty::BrEnv },\n-            ));\n-            let va_list_ty = tcx.bound_type_of(did).subst(tcx, &[region.into()]);\n+            );\n+            let va_list_ty = tcx.type_of(did).subst(tcx, &[region.into()]);\n             (tcx.mk_ref(env_region, ty::TypeAndMut { ty: va_list_ty, mutbl }), va_list_ty)\n         })\n     };\n@@ -377,24 +371,22 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                     ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0, None) };\n                 (\n                     1,\n-                    vec![\n-                        tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)), param(0)),\n-                    ],\n-                    tcx.mk_projection(discriminant_def_id, tcx.mk_substs([param(0).into()].iter())),\n+                    vec![tcx.mk_imm_ref(tcx.mk_re_late_bound(ty::INNERMOST, br), param(0))],\n+                    tcx.mk_projection(discriminant_def_id, tcx.intern_substs(&[param(0).into()])),\n                 )\n             }\n \n             kw::Try => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n                 let try_fn_ty = ty::Binder::dummy(tcx.mk_fn_sig(\n-                    iter::once(mut_u8),\n+                    [mut_u8],\n                     tcx.mk_unit(),\n                     false,\n                     hir::Unsafety::Normal,\n                     Abi::Rust,\n                 ));\n                 let catch_fn_ty = ty::Binder::dummy(tcx.mk_fn_sig(\n-                    [mut_u8, mut_u8].iter().cloned(),\n+                    [mut_u8, mut_u8],\n                     tcx.mk_unit(),\n                     false,\n                     hir::Unsafety::Normal,\n@@ -430,8 +422,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             sym::raw_eq => {\n                 let br =\n                     ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0, None) };\n-                let param_ty =\n-                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)), param(0));\n+                let param_ty = tcx.mk_imm_ref(tcx.mk_re_late_bound(ty::INNERMOST, br), param(0));\n                 (1, vec![param_ty; 2], tcx.types.bool)\n             }\n \n@@ -450,7 +441,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n         };\n         (n_tps, 0, inputs, output, unsafety)\n     };\n-    let sig = tcx.mk_fn_sig(inputs.into_iter(), output, false, unsafety, Abi::RustIntrinsic);\n+    let sig = tcx.mk_fn_sig(inputs, output, false, unsafety, Abi::RustIntrinsic);\n     let sig = ty::Binder::bind_with_vars(sig, bound_vars);\n     equate_intrinsic_type(tcx, it, n_tps, n_lts, sig)\n }\n@@ -548,13 +539,7 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n         }\n     };\n \n-    let sig = tcx.mk_fn_sig(\n-        inputs.into_iter(),\n-        output,\n-        false,\n-        hir::Unsafety::Unsafe,\n-        Abi::PlatformIntrinsic,\n-    );\n+    let sig = tcx.mk_fn_sig(inputs, output, false, hir::Unsafety::Unsafe, Abi::PlatformIntrinsic);\n     let sig = ty::Binder::dummy(sig);\n     equate_intrinsic_type(tcx, it, n_tps, 0, sig)\n }"}, {"sha": "b3e76010da34a00632bfb2a595b1a10413d1b210", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -414,7 +414,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n                 // Check that sym actually points to a function. Later passes\n                 // depend on this.\n                 hir::InlineAsmOperand::SymFn { anon_const } => {\n-                    let ty = self.tcx.type_of(anon_const.def_id);\n+                    let ty = self.tcx.type_of(anon_const.def_id).subst_identity();\n                     match ty.kind() {\n                         ty::Never | ty::Error(_) => {}\n                         ty::FnDef(..) => {}"}, {"sha": "9acfc1b3d2924a0ec73177566de58d0f8355bb78", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -199,7 +199,7 @@ fn report_forbidden_specialization(tcx: TyCtxt<'_>, impl_item: DefId, parent_imp\n fn missing_items_err(\n     tcx: TyCtxt<'_>,\n     impl_span: Span,\n-    missing_items: &[&ty::AssocItem],\n+    missing_items: &[ty::AssocItem],\n     full_impl_span: Span,\n ) {\n     let missing_items_msg = missing_items\n@@ -225,7 +225,7 @@ fn missing_items_err(\n     let padding =\n         tcx.sess.source_map().indentation_before(sugg_sp).unwrap_or_else(|| String::new());\n \n-    for trait_item in missing_items {\n+    for &trait_item in missing_items {\n         let snippet = suggestion_signature(trait_item, tcx);\n         let code = format!(\"{}{}\\n{}\", padding, snippet, padding);\n         let msg = format!(\"implement the missing item: `{snippet}`\");\n@@ -272,7 +272,7 @@ fn default_body_is_unstable(\n     reason: Option<Symbol>,\n     issue: Option<NonZeroU32>,\n ) {\n-    let missing_item_name = &tcx.associated_item(item_did).name;\n+    let missing_item_name = tcx.associated_item(item_did).name;\n     let use_of_unstable_library_feature_note = match reason {\n         Some(r) => format!(\"use of unstable library feature '{feature}': {r}\"),\n         None => format!(\"use of unstable library feature '{feature}'\"),\n@@ -365,7 +365,7 @@ fn fn_sig_suggestion<'tcx>(\n     sig: ty::FnSig<'tcx>,\n     ident: Ident,\n     predicates: ty::GenericPredicates<'tcx>,\n-    assoc: &ty::AssocItem,\n+    assoc: ty::AssocItem,\n ) -> String {\n     let args = sig\n         .inputs()\n@@ -433,7 +433,7 @@ pub fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n /// Return placeholder code for the given associated item.\n /// Similar to `ty::AssocItem::suggestion`, but appropriate for use as the code snippet of a\n /// structured suggestion.\n-fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n+fn suggestion_signature(assoc: ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n     match assoc.kind {\n         ty::AssocKind::Fn => {\n             // We skip the binder here because the binder would deanonymize all\n@@ -450,7 +450,7 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n         }\n         ty::AssocKind::Type => format!(\"type {} = Type;\", assoc.name),\n         ty::AssocKind::Const => {\n-            let ty = tcx.type_of(assoc.def_id);\n+            let ty = tcx.type_of(assoc.def_id).subst_identity();\n             let val = ty_kind_suggestion(ty).unwrap_or(\"value\");\n             format!(\"const {}: {} = {};\", assoc.name, ty, val)\n         }"}, {"sha": "66c3904af963b2a5085bcc1c3b014896d9822257", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -607,12 +607,11 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n                 // Same for the region. In our example, 'a corresponds\n                 // to the 'me parameter.\n                 let region_param = gat_generics.param_at(*region_a_idx, tcx);\n-                let region_param =\n-                    tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n-                        def_id: region_param.def_id,\n-                        index: region_param.index,\n-                        name: region_param.name,\n-                    }));\n+                let region_param = tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n+                    def_id: region_param.def_id,\n+                    index: region_param.index,\n+                    name: region_param.name,\n+                });\n                 // The predicate we expect to see. (In our example,\n                 // `Self: 'me`.)\n                 let clause = ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n@@ -645,20 +644,18 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n                 debug!(\"required clause: {region_a} must outlive {region_b}\");\n                 // Translate into the generic parameters of the GAT.\n                 let region_a_param = gat_generics.param_at(*region_a_idx, tcx);\n-                let region_a_param =\n-                    tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n-                        def_id: region_a_param.def_id,\n-                        index: region_a_param.index,\n-                        name: region_a_param.name,\n-                    }));\n+                let region_a_param = tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n+                    def_id: region_a_param.def_id,\n+                    index: region_a_param.index,\n+                    name: region_a_param.name,\n+                });\n                 // Same for the region.\n                 let region_b_param = gat_generics.param_at(*region_b_idx, tcx);\n-                let region_b_param =\n-                    tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n-                        def_id: region_b_param.def_id,\n-                        index: region_b_param.index,\n-                        name: region_b_param.name,\n-                    }));\n+                let region_b_param = tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n+                    def_id: region_b_param.def_id,\n+                    index: region_b_param.index,\n+                    name: region_b_param.name,\n+                });\n                 // The predicate we expect to see.\n                 let clause = ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n                     ty::OutlivesPredicate(region_a_param, region_b_param),\n@@ -877,7 +874,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n \n         // Const parameters are well formed if their type is structural match.\n         hir::GenericParamKind::Const { ty: hir_ty, default: _ } => {\n-            let ty = tcx.type_of(param.def_id);\n+            let ty = tcx.type_of(param.def_id).subst_identity();\n \n             if tcx.features().adt_const_params {\n                 if let Some(non_structural_match_ty) =\n@@ -1014,12 +1011,12 @@ fn check_associated_item(\n \n         let self_ty = match item.container {\n             ty::TraitContainer => tcx.types.self_param,\n-            ty::ImplContainer => tcx.type_of(item.container_id(tcx)),\n+            ty::ImplContainer => tcx.type_of(item.container_id(tcx)).subst_identity(),\n         };\n \n         match item.kind {\n             ty::AssocKind::Const => {\n-                let ty = tcx.type_of(item.def_id);\n+                let ty = tcx.type_of(item.def_id).subst_identity();\n                 let ty = wfcx.normalize(span, Some(WellFormedLoc::Ty(item_id)), ty);\n                 wfcx.register_wf_obligation(span, loc, ty.into());\n             }\n@@ -1040,7 +1037,7 @@ fn check_associated_item(\n                     check_associated_type_bounds(wfcx, item, span)\n                 }\n                 if item.defaultness(tcx).has_value() {\n-                    let ty = tcx.type_of(item.def_id);\n+                    let ty = tcx.type_of(item.def_id).subst_identity();\n                     let ty = wfcx.normalize(span, Some(WellFormedLoc::Ty(item_id)), ty);\n                     wfcx.register_wf_obligation(span, loc, ty.into());\n                 }\n@@ -1073,7 +1070,7 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n                 let field_id = field.did.expect_local();\n                 let hir::FieldDef { ty: hir_ty, .. } =\n                     tcx.hir().get_by_def_id(field_id).expect_field();\n-                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n+                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did).subst_identity());\n                 wfcx.register_wf_obligation(\n                     hir_ty.span,\n                     Some(WellFormedLoc::Ty(field_id)),\n@@ -1085,7 +1082,7 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n             // intermediate types must be sized.\n             let needs_drop_copy = || {\n                 packed && {\n-                    let ty = tcx.type_of(variant.fields.last().unwrap().did);\n+                    let ty = tcx.type_of(variant.fields.last().unwrap().did).subst_identity();\n                     let ty = tcx.erase_regions(ty);\n                     if ty.needs_infer() {\n                         tcx.sess\n@@ -1107,7 +1104,7 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n                 let field_id = field.did.expect_local();\n                 let hir::FieldDef { ty: hir_ty, .. } =\n                     tcx.hir().get_by_def_id(field_id).expect_field();\n-                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n+                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did).subst_identity());\n                 wfcx.register_bound(\n                     traits::ObligationCause::new(\n                         hir_ty.span,\n@@ -1183,7 +1180,7 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n ///\n /// Assuming the defaults are used, check that all predicates (bounds on the\n /// assoc type and where clauses on the trait) hold.\n-fn check_associated_type_bounds(wfcx: &WfCheckingCtxt<'_, '_>, item: &ty::AssocItem, span: Span) {\n+fn check_associated_type_bounds(wfcx: &WfCheckingCtxt<'_, '_>, item: ty::AssocItem, span: Span) {\n     let bounds = wfcx.tcx().explicit_item_bounds(item.def_id);\n \n     debug!(\"check_associated_type_bounds: bounds={:?}\", bounds);\n@@ -1218,7 +1215,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: LocalDefId, ty_span: Span, allow_fo\n     debug!(\"check_item_type: {:?}\", item_id);\n \n     enter_wf_checking_ctxt(tcx, ty_span, item_id, |wfcx| {\n-        let ty = tcx.type_of(item_id);\n+        let ty = tcx.type_of(item_id).subst_identity();\n         let item_ty = wfcx.normalize(ty_span, Some(WellFormedLoc::Ty(item_id)), ty);\n \n         let mut forbid_unsized = true;\n@@ -1303,7 +1300,7 @@ fn check_impl<'tcx>(\n                 wfcx.register_obligations(obligations);\n             }\n             None => {\n-                let self_ty = tcx.type_of(item.owner_id);\n+                let self_ty = tcx.type_of(item.owner_id).subst_identity();\n                 let self_ty = wfcx.normalize(\n                     item.span,\n                     Some(WellFormedLoc::Ty(item.hir_id().expect_owner().def_id)),\n@@ -1348,7 +1345,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n         match param.kind {\n             GenericParamDefKind::Type { .. } => {\n                 if is_our_default(param) {\n-                    let ty = tcx.type_of(param.def_id);\n+                    let ty = tcx.type_of(param.def_id).subst_identity();\n                     // Ignore dependent defaults -- that is, where the default of one type\n                     // parameter includes another (e.g., `<T, U = T>`). In those cases, we can't\n                     // be sure if it will error or not as user might always specify the other.\n@@ -1400,7 +1397,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             GenericParamDefKind::Type { .. } => {\n                 // If the param has a default, ...\n                 if is_our_default(param) {\n-                    let default_ty = tcx.type_of(param.def_id);\n+                    let default_ty = tcx.type_of(param.def_id).subst_identity();\n                     // ... and it's not a dependent default, ...\n                     if !default_ty.needs_subst() {\n                         // ... then substitute it with the default.\n@@ -1633,7 +1630,7 @@ const HELP_FOR_SELF_TYPE: &str = \"consider changing to `self`, `&self`, `&mut se\n fn check_method_receiver<'tcx>(\n     wfcx: &WfCheckingCtxt<'_, 'tcx>,\n     fn_sig: &hir::FnSig<'_>,\n-    method: &ty::AssocItem,\n+    method: ty::AssocItem,\n     self_ty: Ty<'tcx>,\n ) {\n     let tcx = wfcx.tcx();\n@@ -1816,7 +1813,7 @@ fn check_variances_for_type_defn<'tcx>(\n     item: &hir::Item<'tcx>,\n     hir_generics: &hir::Generics<'_>,\n ) {\n-    let ty = tcx.type_of(item.owner_id);\n+    let ty = tcx.type_of(item.owner_id).subst_identity();\n     if tcx.has_error_field(ty) {\n         return;\n     }"}, {"sha": "51c5f29705191853bd48060baccca09020fea8af", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> Checker<'tcx> {\n \n fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     // Destructors only work on local ADT types.\n-    match tcx.type_of(impl_did).kind() {\n+    match tcx.type_of(impl_did).subst_identity().kind() {\n         ty::Adt(def, _) if def.did().is_local() => return,\n         ty::Error(_) => return,\n         _ => {}\n@@ -64,7 +64,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n \n-    let self_type = tcx.type_of(impl_did);\n+    let self_type = tcx.type_of(impl_did).subst_identity();\n     debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\", self_type);\n \n     let param_env = tcx.param_env(impl_did);\n@@ -206,7 +206,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n \n     let dispatch_from_dyn_trait = tcx.require_lang_item(LangItem::DispatchFromDyn, Some(span));\n \n-    let source = tcx.type_of(impl_did);\n+    let source = tcx.type_of(impl_did).subst_identity();\n     assert!(!source.has_escaping_bound_vars());\n     let target = {\n         let trait_ref = tcx.impl_trait_ref(impl_did).unwrap().subst_identity();\n@@ -370,7 +370,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n         tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err.to_string()));\n     });\n \n-    let source = tcx.type_of(impl_did);\n+    let source = tcx.type_of(impl_did).subst_identity();\n     let trait_ref = tcx.impl_trait_ref(impl_did).unwrap().subst_identity();\n     assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n@@ -482,7 +482,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                 .filter_map(|(i, f)| {\n                     let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n \n-                    if tcx.type_of(f.did).is_phantom_data() {\n+                    if tcx.type_of(f.did).subst_identity().is_phantom_data() {\n                         // Ignore PhantomData fields\n                         return None;\n                     }"}, {"sha": "02f3eeee0e7e0edf6a495bf9d1a871d3553b09ce", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -173,7 +173,7 @@ impl<'tcx> InherentCollect<'tcx> {\n \n         let id = id.owner_id.def_id;\n         let item_span = self.tcx.def_span(id);\n-        let self_ty = self.tcx.type_of(id);\n+        let self_ty = self.tcx.type_of(id).subst_identity();\n         match *self_ty.kind() {\n             ty::Adt(def, _) => self.check_def_id(id, self_ty, def.did()),\n             ty::Foreign(did) => self.check_def_id(id, self_ty, did),"}, {"sha": "7bca4edcc8c966de563be77d65cdff5a4d690056", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -27,8 +27,8 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n     /// namespace.\n     fn impls_have_common_items(\n         &self,\n-        impl_items1: &ty::AssocItems<'_>,\n-        impl_items2: &ty::AssocItems<'_>,\n+        impl_items1: &ty::AssocItems,\n+        impl_items2: &ty::AssocItems,\n     ) -> bool {\n         let mut impl_items1 = &impl_items1;\n         let mut impl_items2 = &impl_items2;\n@@ -38,10 +38,10 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n             std::mem::swap(&mut impl_items1, &mut impl_items2);\n         }\n \n-        for item1 in impl_items1.in_definition_order() {\n+        for &item1 in impl_items1.in_definition_order() {\n             let collision = impl_items2\n                 .filter_by_name_unhygienic(item1.name)\n-                .any(|item2| self.compare_hygienically(item1, item2));\n+                .any(|&item2| self.compare_hygienically(item1, item2));\n \n             if collision {\n                 return true;\n@@ -51,7 +51,7 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n         false\n     }\n \n-    fn compare_hygienically(&self, item1: &ty::AssocItem, item2: &ty::AssocItem) -> bool {\n+    fn compare_hygienically(&self, item1: ty::AssocItem, item2: ty::AssocItem) -> bool {\n         // Symbols and namespace match, compare hygienically.\n         item1.kind.namespace() == item2.kind.namespace()\n             && item1.ident(self.tcx).normalize_to_macros_2_0()\n@@ -98,10 +98,10 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n         let impl_items1 = self.tcx.associated_items(impl1);\n         let impl_items2 = self.tcx.associated_items(impl2);\n \n-        for item1 in impl_items1.in_definition_order() {\n+        for &item1 in impl_items1.in_definition_order() {\n             let collision = impl_items2\n                 .filter_by_name_unhygienic(item1.name)\n-                .find(|item2| self.compare_hygienically(item1, item2));\n+                .find(|&&item2| self.compare_hygienically(item1, item2));\n \n             if let Some(item2) = collision {\n                 let name = item1.ident(self.tcx).normalize_to_macros_2_0();"}, {"sha": "ed3d50bfafa8fad7e5aef05bfcf091bdaa3f27f9", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -41,8 +41,8 @@ use std::iter;\n \n mod generics_of;\n mod item_bounds;\n-mod lifetimes;\n mod predicates_of;\n+mod resolve_bound_vars;\n mod type_of;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -53,7 +53,7 @@ fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n }\n \n pub fn provide(providers: &mut Providers) {\n-    lifetimes::provide(providers);\n+    resolve_bound_vars::provide(providers);\n     *providers = Providers {\n         opt_const_param_of: type_of::opt_const_param_of,\n         type_of: type_of::type_of,\n@@ -458,13 +458,11 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                                         self.tcx.replace_late_bound_regions_uncached(\n                                             poly_trait_ref,\n                                             |_| {\n-                                                self.tcx.mk_region(ty::ReEarlyBound(\n-                                                    ty::EarlyBoundRegion {\n-                                                        def_id: item_def_id,\n-                                                        index: 0,\n-                                                        name: Symbol::intern(&lt_name),\n-                                                    },\n-                                                ))\n+                                                self.tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n+                                                    def_id: item_def_id,\n+                                                    index: 0,\n+                                                    name: Symbol::intern(&lt_name),\n+                                                })\n                                             }\n                                         ),\n                                     ),\n@@ -1145,8 +1143,8 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<ty::PolyFnSig<'_>>\n         }\n \n         Ctor(data) | Variant(hir::Variant { data, .. }) if data.ctor().is_some() => {\n-            let ty = tcx.type_of(tcx.hir().get_parent_item(hir_id));\n-            let inputs = data.fields().iter().map(|f| tcx.type_of(f.def_id));\n+            let ty = tcx.type_of(tcx.hir().get_parent_item(hir_id)).subst_identity();\n+            let inputs = data.fields().iter().map(|f| tcx.type_of(f.def_id).subst_identity());\n             ty::Binder::dummy(tcx.mk_fn_sig(\n                 inputs,\n                 ty,\n@@ -1347,7 +1345,7 @@ fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::EarlyBinder<ty::\n         .of_trait\n         .as_ref()\n         .map(|ast_trait_ref| {\n-            let selfty = tcx.type_of(def_id);\n+            let selfty = tcx.type_of(def_id).subst_identity();\n             icx.astconv().instantiate_mono_trait_ref(\n                 ast_trait_ref,\n                 selfty,"}, {"sha": "127d4fa908bb959411d8bc4c8f72c773c9674358", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1,4 +1,4 @@\n-use crate::middle::resolve_lifetime as rl;\n+use crate::middle::resolve_bound_vars as rbv;\n use hir::{\n     intravisit::{self, Visitor},\n     GenericParamKind, HirId, Node,\n@@ -394,10 +394,16 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n                 return;\n             }\n \n-            match self.tcx.named_region(lt.hir_id) {\n-                Some(rl::Region::Static | rl::Region::EarlyBound(..)) => {}\n-                Some(rl::Region::LateBound(debruijn, _, _)) if debruijn < self.outer_index => {}\n-                Some(rl::Region::LateBound(..) | rl::Region::Free(..)) | None => {\n+            match self.tcx.named_bound_var(lt.hir_id) {\n+                Some(rbv::ResolvedArg::StaticLifetime | rbv::ResolvedArg::EarlyBound(..)) => {}\n+                Some(rbv::ResolvedArg::LateBound(debruijn, _, _))\n+                    if debruijn < self.outer_index => {}\n+                Some(\n+                    rbv::ResolvedArg::LateBound(..)\n+                    | rbv::ResolvedArg::Free(..)\n+                    | rbv::ResolvedArg::Error(_),\n+                )\n+                | None => {\n                     self.has_late_bound_regions = Some(lt.ident.span);\n                 }\n             }"}, {"sha": "2badd66e346f106e68b8eb46240c13d2ad2f9d59", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 55, "deletions": 8, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -9,8 +9,8 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{GenericPredicates, ToPredicate};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -151,7 +151,8 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     trace!(?generics);\n \n     // Collect the predicates that were written inline by the user on each\n-    // type parameter (e.g., `<T: Foo>`).\n+    // type parameter (e.g., `<T: Foo>`). Also add `ConstArgHasType` predicates\n+    // for each const parameter.\n     for param in ast_generics.params {\n         match param.kind {\n             // We already dealt with early bound lifetimes above.\n@@ -175,7 +176,19 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 trace!(?predicates);\n             }\n             GenericParamKind::Const { .. } => {\n-                // Bounds on const parameters are currently not possible.\n+                let name = param.name.ident().name;\n+                let param_const = ty::ParamConst::new(index, name);\n+\n+                let ct_ty = tcx.type_of(param.def_id.to_def_id()).subst_identity();\n+\n+                let ct = tcx.mk_const(param_const, ct_ty);\n+\n+                let predicate = ty::Binder::dummy(ty::PredicateKind::Clause(\n+                    ty::Clause::ConstArgHasType(ct, ct_ty),\n+                ))\n+                .to_predicate(tcx);\n+                predicates.insert((predicate, param.span));\n+\n                 index += 1;\n             }\n         }\n@@ -251,7 +264,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n     if let Node::Item(&Item { kind: ItemKind::Impl { .. }, .. }) = node {\n-        let self_ty = tcx.type_of(def_id);\n+        let self_ty = tcx.type_of(def_id).subst_identity();\n         let trait_ref = tcx.impl_trait_ref(def_id).map(ty::EarlyBinder::subst_identity);\n         cgp::setup_constraining_predicates(\n             tcx,\n@@ -284,11 +297,11 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n             let Some(dup_index) = generics.param_def_id_to_index(tcx, dup_def) else { bug!() };\n \n-            let dup_region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+            let dup_region = tcx.mk_re_early_bound(ty::EarlyBoundRegion {\n                 def_id: dup_def,\n                 index: dup_index,\n                 name: duplicate.name.ident().name,\n-            }));\n+            });\n             predicates.push((\n                 ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n                     ty::OutlivesPredicate(orig_region, dup_region),\n@@ -439,7 +452,9 @@ pub(super) fn explicit_predicates_of<'tcx>(\n             let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n             let parent_def_id = tcx.hir().get_parent_item(hir_id);\n \n-            if tcx.hir().opt_const_param_default_param_def_id(hir_id).is_some() {\n+            if let Some(defaulted_param_def_id) =\n+                tcx.hir().opt_const_param_default_param_def_id(hir_id)\n+            {\n                 // In `generics_of` we set the generics' parent to be our parent's parent which means that\n                 // we lose out on the predicates of our actual parent if we dont return those predicates here.\n                 // (See comment in `generics_of` for more information on why the parent shenanigans is necessary)\n@@ -452,7 +467,39 @@ pub(super) fn explicit_predicates_of<'tcx>(\n                 //\n                 // In the above code we want the anon const to have predicates in its param env for `T: Trait`\n                 // and we would be calling `explicit_predicates_of(Foo)` here\n-                return tcx.explicit_predicates_of(parent_def_id);\n+                let parent_preds = tcx.explicit_predicates_of(parent_def_id);\n+\n+                // If we dont filter out `ConstArgHasType` predicates then every single defaulted const parameter\n+                // will ICE because of #106994. FIXME(generic_const_exprs): remove this when a more general solution\n+                // to #106994 is implemented.\n+                let filtered_predicates = parent_preds\n+                    .predicates\n+                    .into_iter()\n+                    .filter(|(pred, _)| {\n+                        if let ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, _)) =\n+                            pred.kind().skip_binder()\n+                        {\n+                            match ct.kind() {\n+                                ty::ConstKind::Param(param_const) => {\n+                                    let defaulted_param_idx = tcx\n+                                        .generics_of(parent_def_id)\n+                                        .param_def_id_to_index[&defaulted_param_def_id.to_def_id()];\n+                                    param_const.index < defaulted_param_idx\n+                                }\n+                                _ => bug!(\n+                                    \"`ConstArgHasType` in `predicates_of`\\\n+                                 that isn't a `Param` const\"\n+                                ),\n+                            }\n+                        } else {\n+                            true\n+                        }\n+                    })\n+                    .cloned();\n+                return GenericPredicates {\n+                    parent: parent_preds.parent,\n+                    predicates: { tcx.arena.alloc_from_iter(filtered_predicates) },\n+                };\n             }\n \n             let parent_def_kind = tcx.def_kind(parent_def_id);"}, {"sha": "c0c90e47a7539bdc043e2accac5b30ffb4227f00", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "renamed", "additions": 313, "deletions": 208, "changes": 521, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -16,67 +16,69 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericArg, GenericParam, GenericParamKind, HirIdMap, LifetimeName, Node};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::resolve_lifetime::*;\n+use rustc_middle::middle::resolve_bound_vars::*;\n use rustc_middle::ty::{self, ir::TypeVisitor, DefIdTree, TyCtxt, TypeSuperVisitable};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use std::fmt;\n \n trait RegionExt {\n-    fn early(param: &GenericParam<'_>) -> (LocalDefId, Region);\n+    fn early(param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg);\n \n-    fn late(index: u32, param: &GenericParam<'_>) -> (LocalDefId, Region);\n+    fn late(index: u32, param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg);\n \n     fn id(&self) -> Option<DefId>;\n \n-    fn shifted(self, amount: u32) -> Region;\n+    fn shifted(self, amount: u32) -> ResolvedArg;\n }\n \n-impl RegionExt for Region {\n-    fn early(param: &GenericParam<'_>) -> (LocalDefId, Region) {\n-        debug!(\"Region::early: def_id={:?}\", param.def_id);\n-        (param.def_id, Region::EarlyBound(param.def_id.to_def_id()))\n+impl RegionExt for ResolvedArg {\n+    fn early(param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg) {\n+        debug!(\"ResolvedArg::early: def_id={:?}\", param.def_id);\n+        (param.def_id, ResolvedArg::EarlyBound(param.def_id.to_def_id()))\n     }\n \n-    fn late(idx: u32, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n+    fn late(idx: u32, param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg) {\n         let depth = ty::INNERMOST;\n         debug!(\n-            \"Region::late: idx={:?}, param={:?} depth={:?} def_id={:?}\",\n+            \"ResolvedArg::late: idx={:?}, param={:?} depth={:?} def_id={:?}\",\n             idx, param, depth, param.def_id,\n         );\n-        (param.def_id, Region::LateBound(depth, idx, param.def_id.to_def_id()))\n+        (param.def_id, ResolvedArg::LateBound(depth, idx, param.def_id.to_def_id()))\n     }\n \n     fn id(&self) -> Option<DefId> {\n         match *self {\n-            Region::Static => None,\n+            ResolvedArg::StaticLifetime | ResolvedArg::Error(_) => None,\n \n-            Region::EarlyBound(id) | Region::LateBound(_, _, id) | Region::Free(_, id) => Some(id),\n+            ResolvedArg::EarlyBound(id)\n+            | ResolvedArg::LateBound(_, _, id)\n+            | ResolvedArg::Free(_, id) => Some(id),\n         }\n     }\n \n-    fn shifted(self, amount: u32) -> Region {\n+    fn shifted(self, amount: u32) -> ResolvedArg {\n         match self {\n-            Region::LateBound(debruijn, idx, id) => {\n-                Region::LateBound(debruijn.shifted_in(amount), idx, id)\n+            ResolvedArg::LateBound(debruijn, idx, id) => {\n+                ResolvedArg::LateBound(debruijn.shifted_in(amount), idx, id)\n             }\n             _ => self,\n         }\n     }\n }\n \n-/// Maps the id of each lifetime reference to the lifetime decl\n+/// Maps the id of each bound variable reference to the variable decl\n /// that it corresponds to.\n ///\n-/// FIXME. This struct gets converted to a `ResolveLifetimes` for\n+/// FIXME. This struct gets converted to a `ResolveBoundVars` for\n /// actual use. It has the same data, but indexed by `LocalDefId`. This\n /// is silly.\n #[derive(Debug, Default)]\n-struct NamedRegionMap {\n-    // maps from every use of a named (not anonymous) lifetime to a\n-    // `Region` describing how that region is bound\n-    defs: HirIdMap<Region>,\n+struct NamedVarMap {\n+    // maps from every use of a named (not anonymous) bound var to a\n+    // `ResolvedArg` describing how that variable is bound\n+    defs: HirIdMap<ResolvedArg>,\n \n     // Maps relevant hir items to the bound vars on them. These include:\n     // - function defs\n@@ -87,9 +89,9 @@ struct NamedRegionMap {\n     late_bound_vars: HirIdMap<Vec<ty::BoundVariableKind>>,\n }\n \n-struct LifetimeContext<'a, 'tcx> {\n+struct BoundVarContext<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    map: &'a mut NamedRegionMap,\n+    map: &'a mut NamedVarMap,\n     scope: ScopeRef<'a>,\n }\n \n@@ -102,7 +104,7 @@ enum Scope<'a> {\n     Binder {\n         /// We use an IndexMap here because we want these lifetimes in order\n         /// for diagnostics.\n-        lifetimes: FxIndexMap<LocalDefId, Region>,\n+        bound_vars: FxIndexMap<LocalDefId, ResolvedArg>,\n \n         scope_type: BinderScopeType,\n \n@@ -141,7 +143,7 @@ enum Scope<'a> {\n     /// inferred in a function body or potentially error outside one),\n     /// for the default choice of lifetime in a trait object type.\n     ObjectLifetimeDefault {\n-        lifetime: Option<Region>,\n+        lifetime: Option<ResolvedArg>,\n         s: ScopeRef<'a>,\n     },\n \n@@ -150,7 +152,7 @@ enum Scope<'a> {\n     /// lifetimes encountered when identifying the trait that an associated type\n     /// is declared on.\n     Supertrait {\n-        lifetimes: Vec<ty::BoundVariableKind>,\n+        bound_vars: Vec<ty::BoundVariableKind>,\n         s: ScopeRef<'a>,\n     },\n \n@@ -185,9 +187,9 @@ struct TruncatedScopeDebug<'a>(&'a Scope<'a>);\n impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.0 {\n-            Scope::Binder { lifetimes, scope_type, hir_id, where_bound_origin, s: _ } => f\n+            Scope::Binder { bound_vars, scope_type, hir_id, where_bound_origin, s: _ } => f\n                 .debug_struct(\"Binder\")\n-                .field(\"lifetimes\", lifetimes)\n+                .field(\"bound_vars\", bound_vars)\n                 .field(\"scope_type\", scope_type)\n                 .field(\"hir_id\", hir_id)\n                 .field(\"where_bound_origin\", where_bound_origin)\n@@ -202,9 +204,9 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"lifetime\", lifetime)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n-            Scope::Supertrait { lifetimes, s: _ } => f\n+            Scope::Supertrait { bound_vars, s: _ } => f\n                 .debug_struct(\"Supertrait\")\n-                .field(\"lifetimes\", lifetimes)\n+                .field(\"bound_vars\", bound_vars)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::TraitRefBoundary { s: _ } => f.debug_struct(\"TraitRefBoundary\").finish(),\n@@ -219,27 +221,27 @@ type ScopeRef<'a> = &'a Scope<'a>;\n \n pub(crate) fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n-        resolve_lifetimes,\n+        resolve_bound_vars,\n \n-        named_region_map: |tcx, id| tcx.resolve_lifetimes(id).defs.get(&id),\n+        named_variable_map: |tcx, id| tcx.resolve_bound_vars(id).defs.get(&id),\n         is_late_bound_map,\n         object_lifetime_default,\n-        late_bound_vars_map: |tcx, id| tcx.resolve_lifetimes(id).late_bound_vars.get(&id),\n+        late_bound_vars_map: |tcx, id| tcx.resolve_bound_vars(id).late_bound_vars.get(&id),\n \n         ..*providers\n     };\n }\n \n-/// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n+/// Computes the `ResolveBoundVars` map that contains data for an entire `Item`.\n /// You should not read the result of this query directly, but rather use\n-/// `named_region_map`, `is_late_bound_map`, etc.\n+/// `named_variable_map`, `is_late_bound_map`, etc.\n #[instrument(level = \"debug\", skip(tcx))]\n-fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLifetimes {\n-    let mut named_region_map =\n-        NamedRegionMap { defs: Default::default(), late_bound_vars: Default::default() };\n-    let mut visitor = LifetimeContext {\n+fn resolve_bound_vars(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveBoundVars {\n+    let mut named_variable_map =\n+        NamedVarMap { defs: Default::default(), late_bound_vars: Default::default() };\n+    let mut visitor = BoundVarContext {\n         tcx,\n-        map: &mut named_region_map,\n+        map: &mut named_variable_map,\n         scope: &Scope::Root { opt_parent_item: None },\n     };\n     match tcx.hir().owner(local_def_id) {\n@@ -260,13 +262,13 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLife\n         hir::OwnerNode::Crate(_) => {}\n     }\n \n-    let mut rl = ResolveLifetimes::default();\n+    let mut rl = ResolveBoundVars::default();\n \n-    for (hir_id, v) in named_region_map.defs {\n+    for (hir_id, v) in named_variable_map.defs {\n         let map = rl.defs.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n-    for (hir_id, v) in named_region_map.late_bound_vars {\n+    for (hir_id, v) in named_variable_map.late_bound_vars {\n         let map = rl.late_bound_vars.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n@@ -276,21 +278,33 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLife\n     rl\n }\n \n-fn late_region_as_bound_region(tcx: TyCtxt<'_>, region: &Region) -> ty::BoundVariableKind {\n-    match region {\n-        Region::LateBound(_, _, def_id) => {\n+fn late_arg_as_bound_arg<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    arg: &ResolvedArg,\n+    param: &GenericParam<'tcx>,\n+) -> ty::BoundVariableKind {\n+    match arg {\n+        ResolvedArg::LateBound(_, _, def_id) => {\n             let name = tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n-            ty::BoundVariableKind::Region(ty::BrNamed(*def_id, name))\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => {\n+                    ty::BoundVariableKind::Region(ty::BrNamed(*def_id, name))\n+                }\n+                GenericParamKind::Type { .. } => {\n+                    ty::BoundVariableKind::Ty(ty::BoundTyKind::Param(*def_id, name))\n+                }\n+                GenericParamKind::Const { .. } => ty::BoundVariableKind::Const,\n+            }\n         }\n-        _ => bug!(\"{:?} is not a late region\", region),\n+        _ => bug!(\"{:?} is not a late argument\", arg),\n     }\n }\n \n-impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n+impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n     /// Returns the binders in scope and the type of `Binder` that should be created for a poly trait ref.\n     fn poly_trait_ref_binder_info(&mut self) -> (Vec<ty::BoundVariableKind>, BinderScopeType) {\n         let mut scope = self.scope;\n-        let mut supertrait_lifetimes = vec![];\n+        let mut supertrait_bound_vars = vec![];\n         loop {\n             match scope {\n                 Scope::Body { .. } | Scope::Root { .. } => {\n@@ -301,29 +315,79 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Supertrait { s, lifetimes } => {\n-                    supertrait_lifetimes = lifetimes.clone();\n+                Scope::Supertrait { s, bound_vars } => {\n+                    supertrait_bound_vars = bound_vars.clone();\n                     scope = s;\n                 }\n \n                 Scope::TraitRefBoundary { .. } => {\n                     // We should only see super trait lifetimes if there is a `Binder` above\n-                    assert!(supertrait_lifetimes.is_empty());\n+                    assert!(supertrait_bound_vars.is_empty());\n                     break (vec![], BinderScopeType::Normal);\n                 }\n \n                 Scope::Binder { hir_id, .. } => {\n                     // Nested poly trait refs have the binders concatenated\n                     let mut full_binders =\n                         self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                    full_binders.extend(supertrait_lifetimes.into_iter());\n+                    full_binders.extend(supertrait_bound_vars.into_iter());\n                     break (full_binders, BinderScopeType::Concatenating);\n                 }\n             }\n         }\n     }\n+\n+    fn visit_poly_trait_ref_inner(\n+        &mut self,\n+        trait_ref: &'tcx hir::PolyTraitRef<'tcx>,\n+        non_lifetime_binder_allowed: NonLifetimeBinderAllowed,\n+    ) {\n+        debug!(\"visit_poly_trait_ref(trait_ref={:?})\", trait_ref);\n+\n+        let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n+\n+        let initial_bound_vars = binders.len() as u32;\n+        let mut bound_vars: FxIndexMap<LocalDefId, ResolvedArg> = FxIndexMap::default();\n+        let binders_iter =\n+            trait_ref.bound_generic_params.iter().enumerate().map(|(late_bound_idx, param)| {\n+                let pair = ResolvedArg::late(initial_bound_vars + late_bound_idx as u32, param);\n+                let r = late_arg_as_bound_arg(self.tcx, &pair.1, param);\n+                bound_vars.insert(pair.0, pair.1);\n+                r\n+            });\n+        binders.extend(binders_iter);\n+\n+        if let NonLifetimeBinderAllowed::Deny(where_) = non_lifetime_binder_allowed {\n+            deny_non_region_late_bound(self.tcx, &mut bound_vars, where_);\n+        }\n+\n+        debug!(?binders);\n+        self.record_late_bound_vars(trait_ref.trait_ref.hir_ref_id, binders);\n+\n+        // Always introduce a scope here, even if this is in a where clause and\n+        // we introduced the binders around the bounded Ty. In that case, we\n+        // just reuse the concatenation functionality also present in nested trait\n+        // refs.\n+        let scope = Scope::Binder {\n+            hir_id: trait_ref.trait_ref.hir_ref_id,\n+            bound_vars,\n+            s: self.scope,\n+            scope_type,\n+            where_bound_origin: None,\n+        };\n+        self.with(scope, |this| {\n+            walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n+            this.visit_trait_ref(&trait_ref.trait_ref);\n+        });\n+    }\n }\n-impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n+\n+enum NonLifetimeBinderAllowed {\n+    Deny(&'static str),\n+    Allow,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n     type NestedFilter = nested_filter::OnlyBodies;\n \n     fn nested_visit_map(&mut self) -> Self::Map {\n@@ -386,22 +450,23 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) =\n+            let (mut bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) =\n                 bound_generic_params\n                     .iter()\n-                    .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n                     .enumerate()\n                     .map(|(late_bound_idx, param)| {\n-                        let pair = Region::late(late_bound_idx as u32, param);\n-                        let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                        let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                        let r = late_arg_as_bound_arg(self.tcx, &pair.1, param);\n                         (pair, r)\n                     })\n                     .unzip();\n \n+            deny_non_region_late_bound(self.tcx, &mut bound_vars, \"closures\");\n+\n             self.record_late_bound_vars(e.hir_id, binders);\n             let scope = Scope::Binder {\n                 hir_id: e.hir_id,\n-                lifetimes,\n+                bound_vars,\n                 s: self.scope,\n                 scope_type: BinderScopeType::Normal,\n                 where_bound_origin: None,\n@@ -461,7 +526,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // conservatively add all resolved lifetimes. Otherwise we run into problems in\n                 // cases like `type Foo<'a> = impl Bar<As = impl Baz + 'a>`.\n                 let parent_item = self.tcx.hir().get_parent_item(item.hir_id());\n-                let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(parent_item);\n+                let resolved_lifetimes: &ResolveBoundVars =\n+                    self.tcx.resolve_bound_vars(parent_item);\n                 // We need to add *all* deps, since opaque tys may want them from *us*\n                 for (&owner, defs) in resolved_lifetimes.defs.iter() {\n                     defs.iter().for_each(|(&local_id, region)| {\n@@ -478,35 +544,33 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                origin: hir::OpaqueTyOrigin::FnReturn(_) | hir::OpaqueTyOrigin::AsyncFn(_),\n+                origin: hir::OpaqueTyOrigin::FnReturn(parent) | hir::OpaqueTyOrigin::AsyncFn(parent),\n                 generics,\n                 ..\n             }) => {\n                 // We want to start our early-bound indices at the end of the parent scope,\n                 // not including any parent `impl Trait`s.\n-                let mut lifetimes = FxIndexMap::default();\n+                let mut bound_vars = FxIndexMap::default();\n                 debug!(?generics.params);\n                 for param in generics.params {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let (def_id, reg) = Region::early(&param);\n-                            lifetimes.insert(def_id, reg);\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n-                    }\n+                    let (def_id, reg) = ResolvedArg::early(&param);\n+                    bound_vars.insert(def_id, reg);\n                 }\n \n-                let scope = Scope::Binder {\n-                    hir_id: item.hir_id(),\n-                    lifetimes,\n-                    s: self.scope,\n-                    scope_type: BinderScopeType::Normal,\n-                    where_bound_origin: None,\n-                };\n+                let scope = Scope::Root { opt_parent_item: Some(parent) };\n                 self.with(scope, |this| {\n-                    let scope = Scope::TraitRefBoundary { s: this.scope };\n-                    this.with(scope, |this| intravisit::walk_item(this, item))\n-                });\n+                    let scope = Scope::Binder {\n+                        hir_id: item.hir_id(),\n+                        bound_vars,\n+                        s: this.scope,\n+                        scope_type: BinderScopeType::Normal,\n+                        where_bound_origin: None,\n+                    };\n+                    this.with(scope, |this| {\n+                        let scope = Scope::TraitRefBoundary { s: this.scope };\n+                        this.with(scope, |this| intravisit::walk_item(this, item))\n+                    });\n+                })\n             }\n             hir::ItemKind::TyAlias(_, generics)\n             | hir::ItemKind::Enum(_, generics)\n@@ -516,18 +580,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             | hir::ItemKind::TraitAlias(generics, ..)\n             | hir::ItemKind::Impl(&hir::Impl { generics, .. }) => {\n                 // These kinds of items have only early-bound lifetime parameters.\n-                let lifetimes = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(Region::early(param)),\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n-                    })\n-                    .collect();\n+                let bound_vars = generics.params.iter().map(ResolvedArg::early).collect();\n                 self.record_late_bound_vars(item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: item.hir_id(),\n-                    lifetimes,\n+                    bound_vars,\n                     scope_type: BinderScopeType::Normal,\n                     s: self.scope,\n                     where_bound_origin: None,\n@@ -562,21 +619,23 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         match ty.kind {\n             hir::TyKind::BareFn(c) => {\n-                let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n+                let (mut bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n-                    .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n                     .enumerate()\n                     .map(|(late_bound_idx, param)| {\n-                        let pair = Region::late(late_bound_idx as u32, param);\n-                        let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                        let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                        let r = late_arg_as_bound_arg(self.tcx, &pair.1, param);\n                         (pair, r)\n                     })\n                     .unzip();\n+\n+                deny_non_region_late_bound(self.tcx, &mut bound_vars, \"function pointer types\");\n+\n                 self.record_late_bound_vars(ty.hir_id, binders);\n                 let scope = Scope::Binder {\n                     hir_id: ty.hir_id,\n-                    lifetimes,\n+                    bound_vars,\n                     s: self.scope,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n@@ -592,7 +651,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let scope = Scope::TraitRefBoundary { s: self.scope };\n                 self.with(scope, |this| {\n                     for bound in bounds {\n-                        this.visit_poly_trait_ref(bound);\n+                        this.visit_poly_trait_ref_inner(\n+                            bound,\n+                            NonLifetimeBinderAllowed::Deny(\"trait object types\"),\n+                        );\n                     }\n                 });\n                 match lifetime.res {\n@@ -674,7 +736,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     // well-supported at the moment, so this doesn't work.\n                     // In the future, this should be fixed and this error should be removed.\n                     let def = self.map.defs.get(&lifetime.hir_id).cloned();\n-                    let Some(Region::LateBound(_, _, def_id)) = def else {\n+                    let Some(ResolvedArg::LateBound(_, _, def_id)) = def else {\n                         continue\n                     };\n                     let Some(def_id) = def_id.as_local() else {\n@@ -722,18 +784,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             Type(bounds, ty) => {\n                 let generics = &trait_item.generics;\n-                let lifetimes = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(Region::early(param)),\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n-                    })\n-                    .collect();\n+                let bound_vars = generics.params.iter().map(ResolvedArg::early).collect();\n                 self.record_late_bound_vars(trait_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: trait_item.hir_id(),\n-                    lifetimes,\n+                    bound_vars,\n                     s: self.scope,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n@@ -768,18 +823,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }),\n             Type(ty) => {\n                 let generics = &impl_item.generics;\n-                let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(Region::early(param)),\n-                        GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => None,\n-                    })\n-                    .collect();\n+                let bound_vars: FxIndexMap<LocalDefId, ResolvedArg> =\n+                    generics.params.iter().map(ResolvedArg::early).collect();\n                 self.record_late_bound_vars(impl_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: impl_item.hir_id(),\n-                    lifetimes,\n+                    bound_vars,\n                     s: self.scope,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n@@ -803,7 +852,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         match lifetime_ref.res {\n-            hir::LifetimeName::Static => self.insert_lifetime(lifetime_ref, Region::Static),\n+            hir::LifetimeName::Static => {\n+                self.insert_lifetime(lifetime_ref, ResolvedArg::StaticLifetime)\n+            }\n             hir::LifetimeName::Param(param_def_id) => {\n                 self.resolve_lifetime_ref(param_def_id, lifetime_ref)\n             }\n@@ -814,13 +865,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_path(&mut self, path: &hir::Path<'tcx>, _: hir::HirId) {\n+    fn visit_path(&mut self, path: &hir::Path<'tcx>, hir_id: hir::HirId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n             if let Some(args) = segment.args {\n                 self.visit_segment_args(path.res, depth, args);\n             }\n         }\n+        if let Res::Def(DefKind::TyParam | DefKind::ConstParam, param_def_id) = path.res {\n+            self.resolve_type_ref(param_def_id.expect_local(), hir_id);\n+        }\n     }\n \n     fn visit_fn(\n@@ -869,32 +923,25 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         origin,\n                         ..\n                     }) => {\n-                        let lifetimes: FxIndexMap<LocalDefId, Region> =\n+\n+                        let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) =\n                             bound_generic_params\n-                                .iter()\n-                                .filter(|param| {\n-                                    matches!(param.kind, GenericParamKind::Lifetime { .. })\n-                                })\n-                                .enumerate()\n-                                .map(|(late_bound_idx, param)| {\n-                                        Region::late(late_bound_idx as u32, param)\n-                                })\n-                                .collect();\n-                        let binders: Vec<_> =\n-                            lifetimes\n-                                .iter()\n-                                .map(|(_, region)| {\n-                                     late_region_as_bound_region(this.tcx, region)\n-                                })\n-                                .collect();\n+                            .iter()\n+                            .enumerate()\n+                            .map(|(late_bound_idx, param)| {\n+                                let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                                let r = late_arg_as_bound_arg(this.tcx, &pair.1, param);\n+                                (pair, r)\n+                            })\n+                            .unzip();\n                         this.record_late_bound_vars(hir_id, binders.clone());\n                         // Even if there are no lifetimes defined here, we still wrap it in a binder\n                         // scope. If there happens to be a nested poly trait ref (an error), that\n                         // will be `Concatenating` anyways, so we don't have to worry about the depth\n                         // being wrong.\n                         let scope = Scope::Binder {\n                             hir_id,\n-                            lifetimes,\n+                            bound_vars,\n                             s: this.scope,\n                             scope_type: BinderScopeType::Normal,\n                             where_bound_origin: Some(origin),\n@@ -920,7 +967,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 if lt.res != hir::LifetimeName::Static {\n                                     continue;\n                                 }\n-                                this.insert_lifetime(lt, Region::Static);\n+                                this.insert_lifetime(lt, ResolvedArg::StaticLifetime);\n                                 this.tcx\n                                     .sess\n                                     .struct_span_warn(\n@@ -964,7 +1011,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.record_late_bound_vars(*hir_id, binders);\n                 let scope = Scope::Binder {\n                     hir_id: *hir_id,\n-                    lifetimes: FxIndexMap::default(),\n+                    bound_vars: FxIndexMap::default(),\n                     s: self.scope,\n                     scope_type,\n                     where_bound_origin: None,\n@@ -978,43 +1025,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_poly_trait_ref(&mut self, trait_ref: &'tcx hir::PolyTraitRef<'tcx>) {\n-        debug!(\"visit_poly_trait_ref(trait_ref={:?})\", trait_ref);\n-\n-        let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n-\n-        let initial_bound_vars = binders.len() as u32;\n-        let mut lifetimes: FxIndexMap<LocalDefId, Region> = FxIndexMap::default();\n-        let binders_iter = trait_ref\n-            .bound_generic_params\n-            .iter()\n-            .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n-            .enumerate()\n-            .map(|(late_bound_idx, param)| {\n-                let pair = Region::late(initial_bound_vars + late_bound_idx as u32, param);\n-                let r = late_region_as_bound_region(self.tcx, &pair.1);\n-                lifetimes.insert(pair.0, pair.1);\n-                r\n-            });\n-        binders.extend(binders_iter);\n-\n-        debug!(?binders);\n-        self.record_late_bound_vars(trait_ref.trait_ref.hir_ref_id, binders);\n-\n-        // Always introduce a scope here, even if this is in a where clause and\n-        // we introduced the binders around the bounded Ty. In that case, we\n-        // just reuse the concatenation functionality also present in nested trait\n-        // refs.\n-        let scope = Scope::Binder {\n-            hir_id: trait_ref.trait_ref.hir_ref_id,\n-            lifetimes,\n-            s: self.scope,\n-            scope_type,\n-            where_bound_origin: None,\n-        };\n-        self.with(scope, |this| {\n-            walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n-            this.visit_trait_ref(&trait_ref.trait_ref);\n-        });\n+        self.visit_poly_trait_ref_inner(trait_ref, NonLifetimeBinderAllowed::Allow);\n     }\n }\n \n@@ -1063,13 +1074,13 @@ fn object_lifetime_default(tcx: TyCtxt<'_>, param_def_id: DefId) -> ObjectLifeti\n     }\n }\n \n-impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n+impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n     fn with<F>(&mut self, wrap_scope: Scope<'_>, f: F)\n     where\n-        F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n+        F: for<'b> FnOnce(&mut BoundVarContext<'b, 'tcx>),\n     {\n-        let LifetimeContext { tcx, map, .. } = self;\n-        let mut this = LifetimeContext { tcx: *tcx, map, scope: &wrap_scope };\n+        let BoundVarContext { tcx, map, .. } = self;\n+        let mut this = BoundVarContext { tcx: *tcx, map, scope: &wrap_scope };\n         let span = debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n         {\n             let _enter = span.enter();\n@@ -1110,23 +1121,25 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n     ) where\n-        F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n+        F: for<'b, 'c> FnOnce(&'b mut BoundVarContext<'c, 'tcx>),\n     {\n         let mut named_late_bound_vars = 0;\n-        let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n+        let bound_vars: FxIndexMap<LocalDefId, ResolvedArg> = generics\n             .params\n             .iter()\n-            .filter_map(|param| match param.kind {\n+            .map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n                     if self.tcx.is_late_bound(param.hir_id) {\n                         let late_bound_idx = named_late_bound_vars;\n                         named_late_bound_vars += 1;\n-                        Some(Region::late(late_bound_idx, param))\n+                        ResolvedArg::late(late_bound_idx, param)\n                     } else {\n-                        Some(Region::early(param))\n+                        ResolvedArg::early(param)\n                     }\n                 }\n-                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n+                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n+                    ResolvedArg::early(param)\n+                }\n             })\n             .collect();\n \n@@ -1139,14 +1152,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             })\n             .enumerate()\n             .map(|(late_bound_idx, param)| {\n-                let pair = Region::late(late_bound_idx as u32, param);\n-                late_region_as_bound_region(self.tcx, &pair.1)\n+                let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                late_arg_as_bound_arg(self.tcx, &pair.1, param)\n             })\n             .collect();\n         self.record_late_bound_vars(hir_id, binders);\n         let scope = Scope::Binder {\n             hir_id,\n-            lifetimes,\n+            bound_vars,\n             s: self.scope,\n             scope_type: BinderScopeType::Normal,\n             where_bound_origin: None,\n@@ -1177,15 +1190,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Root { opt_parent_item } => {\n                     if let Some(parent_item) = opt_parent_item\n                         && let parent_generics = self.tcx.generics_of(parent_item)\n-                        && parent_generics.param_def_id_to_index.contains_key(&region_def_id.to_def_id())\n+                        && parent_generics.param_def_id_to_index(self.tcx, region_def_id.to_def_id()).is_some()\n                     {\n-                        break Some(Region::EarlyBound(region_def_id.to_def_id()));\n+                        break Some(ResolvedArg::EarlyBound(region_def_id.to_def_id()));\n                     }\n                     break None;\n                 }\n \n-                Scope::Binder { ref lifetimes, scope_type, s, where_bound_origin, .. } => {\n-                    if let Some(&def) = lifetimes.get(&region_def_id) {\n+                Scope::Binder { ref bound_vars, scope_type, s, where_bound_origin, .. } => {\n+                    if let Some(&def) = bound_vars.get(&region_def_id) {\n                         break Some(def.shifted(late_depth));\n                     }\n                     match scope_type {\n@@ -1259,7 +1272,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         };\n \n         if let Some(mut def) = result {\n-            if let Region::EarlyBound(..) = def {\n+            if let ResolvedArg::EarlyBound(..) = def {\n                 // Do not free early-bound regions, only late-bound ones.\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n@@ -1275,10 +1288,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         kind: hir::ImplItemKind::Fn(..),\n                         ..\n                     }) => {\n-                        def = Region::Free(owner_id.to_def_id(), def.id().unwrap());\n+                        def = ResolvedArg::Free(owner_id.to_def_id(), def.id().unwrap());\n                     }\n                     Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(closure), .. }) => {\n-                        def = Region::Free(closure.def_id.to_def_id(), def.id().unwrap());\n+                        def = ResolvedArg::Free(closure.def_id.to_def_id(), def.id().unwrap());\n                     }\n                     _ => {}\n                 }\n@@ -1329,6 +1342,59 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         );\n     }\n \n+    fn resolve_type_ref(&mut self, param_def_id: LocalDefId, hir_id: hir::HirId) {\n+        // Walk up the scope chain, tracking the number of fn scopes\n+        // that we pass through, until we find a lifetime with the\n+        // given name or we run out of scopes.\n+        // search.\n+        let mut late_depth = 0;\n+        let mut scope = self.scope;\n+        let result = loop {\n+            match *scope {\n+                Scope::Body { s, .. } => {\n+                    scope = s;\n+                }\n+\n+                Scope::Root { opt_parent_item } => {\n+                    if let Some(parent_item) = opt_parent_item\n+                        && let parent_generics = self.tcx.generics_of(parent_item)\n+                        && parent_generics.param_def_id_to_index(self.tcx, param_def_id.to_def_id()).is_some()\n+                    {\n+                        break Some(ResolvedArg::EarlyBound(param_def_id.to_def_id()));\n+                    }\n+                    break None;\n+                }\n+\n+                Scope::Binder { ref bound_vars, scope_type, s, .. } => {\n+                    if let Some(&def) = bound_vars.get(&param_def_id) {\n+                        break Some(def.shifted(late_depth));\n+                    }\n+                    match scope_type {\n+                        BinderScopeType::Normal => late_depth += 1,\n+                        BinderScopeType::Concatenating => {}\n+                    }\n+                    scope = s;\n+                }\n+\n+                Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. } => {\n+                    scope = s;\n+                }\n+            }\n+        };\n+\n+        if let Some(def) = result {\n+            self.map.defs.insert(hir_id, def);\n+            return;\n+        }\n+\n+        self.tcx\n+            .sess\n+            .delay_span_bug(self.tcx.hir().span(hir_id), \"could not resolve {param_def_id:?}\");\n+    }\n+\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_segment_args(\n         &mut self,\n@@ -1415,10 +1481,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     if in_body {\n                         None\n                     } else {\n-                        Some(Region::Static)\n+                        Some(ResolvedArg::StaticLifetime)\n                     }\n                 }\n-                ObjectLifetimeDefault::Static => Some(Region::Static),\n+                ObjectLifetimeDefault::Static => Some(ResolvedArg::StaticLifetime),\n                 ObjectLifetimeDefault::Param(param_def_id) => {\n                     // This index can be used with `generic_args` since `parent_count == 0`.\n                     let index = generics.param_def_id_to_index[&param_def_id] as usize;\n@@ -1507,18 +1573,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // in the trait ref `YY<...>` in `Item: YY<...>`.\n         for binding in generic_args.bindings {\n             let scope = Scope::ObjectLifetimeDefault {\n-                lifetime: if has_lifetime_parameter { None } else { Some(Region::Static) },\n+                lifetime: if has_lifetime_parameter {\n+                    None\n+                } else {\n+                    Some(ResolvedArg::StaticLifetime)\n+                },\n                 s: self.scope,\n             };\n             if let Some(type_def_id) = type_def_id {\n-                let lifetimes = LifetimeContext::supertrait_hrtb_lifetimes(\n-                    self.tcx,\n-                    type_def_id,\n-                    binding.ident,\n-                );\n+                let bound_vars =\n+                    BoundVarContext::supertrait_hrtb_vars(self.tcx, type_def_id, binding.ident);\n                 self.with(scope, |this| {\n                     let scope = Scope::Supertrait {\n-                        lifetimes: lifetimes.unwrap_or_default(),\n+                        bound_vars: bound_vars.unwrap_or_default(),\n                         s: this.scope,\n                     };\n                     this.with(scope, |this| this.visit_assoc_type_binding(binding));\n@@ -1541,7 +1608,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ```\n     /// In this case, if we wanted to the supertrait HRTB lifetimes for `As` on\n     /// the starting trait `Bar`, we would return `Some(['b, 'a])`.\n-    fn supertrait_hrtb_lifetimes(\n+    fn supertrait_hrtb_vars(\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         assoc_name: Ident,\n@@ -1626,7 +1693,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root { .. } | Scope::Elision { .. } => break Region::Static,\n+                Scope::Root { .. } | Scope::Elision { .. } => break ResolvedArg::StaticLifetime,\n \n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n \n@@ -1641,15 +1708,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: Region) {\n+    fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: ResolvedArg) {\n         debug!(span = ?lifetime_ref.ident.span);\n         self.map.defs.insert(lifetime_ref.hir_id, def);\n     }\n \n     /// Sometimes we resolve a lifetime, but later find that it is an\n     /// error (esp. around impl trait). In that case, we remove the\n     /// entry into `map.defs` so as not to confuse later code.\n-    fn uninsert_lifetime_on_error(&mut self, lifetime_ref: &'tcx hir::Lifetime, bad_def: Region) {\n+    fn uninsert_lifetime_on_error(\n+        &mut self,\n+        lifetime_ref: &'tcx hir::Lifetime,\n+        bad_def: ResolvedArg,\n+    ) {\n         let old_value = self.map.defs.remove(&lifetime_ref.hir_id);\n         assert_eq!(old_value, Some(bad_def));\n     }\n@@ -1804,7 +1875,7 @@ fn is_late_bound_map(\n                     let mut walker = ConstrainedCollectorPostAstConv {\n                         arg_is_constrained: vec![false; generics.params.len()].into_boxed_slice(),\n                     };\n-                    walker.visit_ty(self.tcx.type_of(alias_def));\n+                    walker.visit_ty(self.tcx.type_of(alias_def).subst_identity());\n \n                     match segments.last() {\n                         Some(hir::PathSegment { args: Some(args), .. }) => {\n@@ -1872,3 +1943,37 @@ fn is_late_bound_map(\n         }\n     }\n }\n+\n+pub fn deny_non_region_late_bound(\n+    tcx: TyCtxt<'_>,\n+    bound_vars: &mut FxIndexMap<LocalDefId, ResolvedArg>,\n+    where_: &str,\n+) {\n+    let mut first = true;\n+\n+    for (var, arg) in bound_vars {\n+        let Node::GenericParam(param) = tcx.hir().get_by_def_id(*var) else {\n+            bug!();\n+        };\n+\n+        let what = match param.kind {\n+            hir::GenericParamKind::Type { .. } => \"type\",\n+            hir::GenericParamKind::Const { .. } => \"const\",\n+            hir::GenericParamKind::Lifetime { .. } => continue,\n+        };\n+\n+        let mut diag = tcx.sess.struct_span_err(\n+            param.span,\n+            format!(\"late-bound {what} parameter not allowed on {where_}\"),\n+        );\n+\n+        let guar = if tcx.features().non_lifetime_binders && first {\n+            diag.emit()\n+        } else {\n+            diag.delay_as_bug()\n+        };\n+\n+        first = false;\n+        *arg = ResolvedArg::Error(guar);\n+    }\n+}", "previous_filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs"}, {"sha": "a3bc0082ef20c315c92015b54cdca13c69922a10", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -243,29 +243,24 @@ fn get_path_containing_arg_in_pat<'hir>(\n     arg_path\n }\n \n-pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n+pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>> {\n     let def_id = def_id.expect_local();\n     use rustc_hir::*;\n \n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n     let icx = ItemCtxt::new(tcx, def_id.to_def_id());\n \n-    match tcx.hir().get(hir_id) {\n+    let output = match tcx.hir().get(hir_id) {\n         Node::TraitItem(item) => match item.kind {\n             TraitItemKind::Fn(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n                 tcx.mk_fn_def(def_id.to_def_id(), substs)\n             }\n             TraitItemKind::Const(ty, body_id) => body_id\n                 .and_then(|body_id| {\n-                    if is_suggestable_infer_ty(ty) {\n-                        Some(infer_placeholder_type(\n-                            tcx, def_id, body_id, ty.span, item.ident, \"constant\",\n-                        ))\n-                    } else {\n-                        None\n-                    }\n+                    is_suggestable_infer_ty(ty)\n+                        .then(|| infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident, \"constant\",))\n                 })\n                 .unwrap_or_else(|| icx.to_ty(ty)),\n             TraitItemKind::Type(_, Some(ty)) => icx.to_ty(ty),\n@@ -382,7 +377,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n         Node::Ctor(def) | Node::Variant(Variant { data: def, .. }) => match def {\n             VariantData::Unit(..) | VariantData::Struct(..) => {\n-                tcx.type_of(tcx.hir().get_parent_item(hir_id))\n+                tcx.type_of(tcx.hir().get_parent_item(hir_id)).subst_identity()\n             }\n             VariantData::Tuple(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n@@ -399,7 +394,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         Node::AnonConst(_) if let Some(param) = tcx.opt_const_param_of(def_id) => {\n             // We defer to `type_of` of the corresponding parameter\n             // for generic arguments.\n-            tcx.type_of(param)\n+            tcx.type_of(param).subst_identity()\n         }\n \n         Node::AnonConst(_) => {\n@@ -451,7 +446,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     && e.hir_id == hir_id =>\n                 {\n                     let Some(trait_def_id) = trait_ref.trait_def_id() else {\n-                        return tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\");\n+                        return ty::EarlyBinder(tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\"));\n                     };\n                     let assoc_items = tcx.associated_items(trait_def_id);\n                     let assoc_item = assoc_items.find_by_name_and_kind(\n@@ -461,7 +456,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         def_id.to_def_id(),\n                     );\n                     if let Some(assoc_item) = assoc_item {\n-                        tcx.type_of(assoc_item.def_id)\n+                        tcx.type_of(assoc_item.def_id).subst_identity()\n                     } else {\n                         // FIXME(associated_const_equality): add a useful error message here.\n                         tcx.ty_error_with_message(\n@@ -485,7 +480,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         }) =>\n                 {\n                     let Some(trait_def_id) = trait_ref.trait_def_id() else {\n-                        return tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\");\n+                        return ty::EarlyBinder(tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\"));\n                     };\n                     let assoc_items = tcx.associated_items(trait_def_id);\n                     let assoc_item = assoc_items.find_by_name_and_kind(\n@@ -506,7 +501,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     if let Some(param)\n                         = assoc_item.map(|item| &tcx.generics_of(item.def_id).params[idx]).filter(|param| param.kind.is_ty_or_const())\n                     {\n-                        tcx.type_of(param.def_id)\n+                        tcx.type_of(param.def_id).subst_identity()\n                     } else {\n                         // FIXME(associated_const_equality): add a useful error message here.\n                         tcx.ty_error_with_message(\n@@ -520,7 +515,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     def_id: param_def_id,\n                     kind: GenericParamKind::Const { default: Some(ct), .. },\n                     ..\n-                }) if ct.hir_id == hir_id => tcx.type_of(param_def_id),\n+                }) if ct.hir_id == hir_id => tcx.type_of(param_def_id).subst_identity(),\n \n                 x => tcx.ty_error_with_message(\n                     DUMMY_SP,\n@@ -538,7 +533,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         x => {\n             bug!(\"unexpected sort of node in type_of(): {:?}\", x);\n         }\n-    }\n+    };\n+    ty::EarlyBinder(output)\n }\n \n #[instrument(skip(tcx), level = \"debug\")]"}, {"sha": "8ab9964d810008979e35ea66e2b3e77b887c9976", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -70,7 +70,7 @@ pub fn provide(providers: &mut Providers) {\n \n fn enforce_impl_params_are_constrained(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) {\n     // Every lifetime used in an associated type must be constrained.\n-    let impl_self_ty = tcx.type_of(impl_def_id);\n+    let impl_self_ty = tcx.type_of(impl_def_id).subst_identity();\n     if impl_self_ty.references_error() {\n         // Don't complain about unconstrained type params when self ty isn't known due to errors.\n         // (#36836)\n@@ -104,7 +104,7 @@ fn enforce_impl_params_are_constrained(tcx: TyCtxt<'_>, impl_def_id: LocalDefId)\n             match item.kind {\n                 ty::AssocKind::Type => {\n                     if item.defaultness(tcx).has_value() {\n-                        cgp::parameters_for(&tcx.type_of(def_id), true)\n+                        cgp::parameters_for(&tcx.type_of(def_id).subst_identity(), true)\n                     } else {\n                         Vec::new()\n                     }"}, {"sha": "4741e4b095d22afc0bee5cee96d203719457da3e", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -496,6 +496,16 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n                 )\n                 .emit();\n         }\n+        ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => {\n+            // FIXME(min_specialization), FIXME(const_generics):\n+            // It probably isn't right to allow _every_ `ConstArgHasType` but I am somewhat unsure\n+            // about the actual rules that would be sound. Can't just always error here because otherwise\n+            // std/core doesn't even compile as they have `const N: usize` in some specializing impls.\n+            //\n+            // While we do not support constructs like `<T, const N: T>` there is probably no risk of\n+            // soundness bugs, but when we support generic const parameter types this will need to be\n+            // revisited.\n+        }\n         _ => {\n             tcx.sess\n                 .struct_span_err(span, &format!(\"cannot specialize on predicate `{}`\", predicate))\n@@ -517,6 +527,7 @@ fn trait_predicate_kind<'tcx>(\n         ty::PredicateKind::Clause(ty::Clause::RegionOutlives(_))\n         | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(_))\n         | ty::PredicateKind::Clause(ty::Clause::Projection(_))\n+        | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n         | ty::PredicateKind::AliasEq(..)\n         | ty::PredicateKind::WellFormed(_)\n         | ty::PredicateKind::Subtype(_)"}, {"sha": "11240cf22e4b1ba0eab36d0fd7e63af4f3c025aa", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -113,7 +113,6 @@ use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n-use std::iter;\n use std::ops::Not;\n \n use astconv::AstConv;\n@@ -187,7 +186,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n \n     fn main_fn_diagnostics_def_id(tcx: TyCtxt<'_>, def_id: DefId, sp: Span) -> LocalDefId {\n         if let Some(local_def_id) = def_id.as_local() {\n-            let hir_type = tcx.type_of(local_def_id);\n+            let hir_type = tcx.type_of(local_def_id).subst_identity();\n             if !matches!(hir_type.kind(), ty::FnDef(..)) {\n                 span_bug!(sp, \"main has a non-function type: found `{}`\", hir_type);\n             }\n@@ -204,7 +203,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n             Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, generics, _), .. })) => {\n-                generics.params.is_empty().not().then(|| generics.span)\n+                generics.params.is_empty().not().then_some(generics.span)\n             }\n             _ => {\n                 span_bug!(tcx.def_span(def_id), \"main has a non-function type\");\n@@ -348,7 +347,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     }\n \n     let se_ty = tcx.mk_fn_ptr(expected_return_type.map_bound(|expected_return_type| {\n-        tcx.mk_fn_sig(iter::empty(), expected_return_type, false, hir::Unsafety::Normal, Abi::Rust)\n+        tcx.mk_fn_sig([], expected_return_type, false, hir::Unsafety::Normal, Abi::Rust)\n     }));\n \n     require_same_types(\n@@ -366,7 +365,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n     let start_def_id = start_def_id.expect_local();\n     let start_id = tcx.hir().local_def_id_to_hir_id(start_def_id);\n     let start_span = tcx.def_span(start_def_id);\n-    let start_t = tcx.type_of(start_def_id);\n+    let start_t = tcx.type_of(start_def_id).subst_identity();\n     match start_t.kind() {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(start_id) {\n@@ -434,7 +433,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n             }\n \n             let se_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n-                [tcx.types.isize, tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))].iter().cloned(),\n+                [tcx.types.isize, tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))],\n                 tcx.types.isize,\n                 false,\n                 hir::Unsafety::Normal,"}, {"sha": "9ee6785970c46b562a5343fa73ff435c6ef337a2", "filename": "compiler/rustc_hir_analysis/src/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -54,6 +54,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n \n                     ty::PredicateKind::Clause(ty::Clause::Trait(..))\n                     | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                    | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n                     | ty::PredicateKind::WellFormed(..)\n                     | ty::PredicateKind::AliasEq(..)\n                     | ty::PredicateKind::ObjectSafe(..)"}, {"sha": "a8b33c74bc1ee8aaac01bfb1c4b002ffb4a0c9c5", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -46,7 +46,7 @@ pub(super) fn infer_predicates(\n                         // For field of type &'a T (reference) or Adt\n                         // (struct/enum/union) there will be outlive\n                         // requirements for adt_def.\n-                        let field_ty = tcx.type_of(field_def.did);\n+                        let field_ty = tcx.type_of(field_def.did).subst_identity();\n                         let field_span = tcx.def_span(field_def.did);\n                         insert_required_predicates_to_be_wf(\n                             tcx,"}, {"sha": "560ffc620e0ded46e4a26e49806cae39bd27efc0", "filename": "compiler/rustc_hir_analysis/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n \n     fn get_unbound_associated_types(&self) -> Vec<String> {\n         if self.tcx.is_trait(self.def_id) {\n-            let items: &AssocItems<'_> = self.tcx.associated_items(self.def_id);\n+            let items: &AssocItems = self.tcx.associated_items(self.def_id);\n             items\n                 .in_definition_order()\n                 .filter(|item| item.kind == AssocKind::Type)"}, {"sha": "408bec71ee015ae70a2ebcf5452636a1af625247", "filename": "compiler/rustc_hir_analysis/src/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         let inferred_start = self.terms_cx.inferred_starts[&def_id];\n         let current_item = &CurrentItem { inferred_start };\n-        match tcx.type_of(def_id).kind() {\n+        match tcx.type_of(def_id).subst_identity().kind() {\n             ty::Adt(def, _) => {\n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n@@ -112,7 +112,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 for field in def.all_fields() {\n                     self.add_constraints_from_ty(\n                         current_item,\n-                        tcx.type_of(field.did),\n+                        tcx.type_of(field.did).subst_identity(),\n                         self.covariant,\n                     );\n                 }"}, {"sha": "c27c176e35f58a86b0295a6633a0d4a1418d9053", "filename": "compiler/rustc_hir_analysis/src/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 self.enforce_const_invariance(generics, variances);\n \n                 // Functions are permitted to have unused generic parameters: make those invariant.\n-                if let ty::FnDef(..) = tcx.type_of(def_id).kind() {\n+                if let ty::FnDef(..) = tcx.type_of(def_id).subst_identity().kind() {\n                     for variance in variances.iter_mut() {\n                         if *variance == ty::Bivariant {\n                             *variance = ty::Invariant;"}, {"sha": "bf8259ff70fa91a71b934a3a3054af004eb544a8", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -74,15 +74,13 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n     // (as it's created inside the body itself, not passed in from outside).\n-    let maybe_va_list = if fn_sig.c_variadic {\n+    let maybe_va_list = fn_sig.c_variadic.then(|| {\n         let span = body.params.last().unwrap().span;\n         let va_list_did = tcx.require_lang_item(LangItem::VaList, Some(span));\n         let region = fcx.next_region_var(RegionVariableOrigin::MiscVariable(span));\n \n-        Some(tcx.bound_type_of(va_list_did).subst(tcx, &[region.into()]))\n-    } else {\n-        None\n-    };\n+        tcx.type_of(va_list_did).subst(tcx, &[region.into()])\n+    });\n \n     // Add formal parameters.\n     let inputs_hir = hir.fn_decl_by_hir_id(fn_id).map(|decl| &decl.inputs);\n@@ -266,7 +264,7 @@ fn check_lang_start_fn<'tcx>(\n         let fn_generic = generics.param_at(0, tcx);\n         let generic_ty = tcx.mk_ty_param(fn_generic.index, fn_generic.name);\n         let expected_fn_sig =\n-            tcx.mk_fn_sig([].iter(), &generic_ty, false, hir::Unsafety::Normal, Abi::Rust);\n+            tcx.mk_fn_sig([], generic_ty, false, hir::Unsafety::Normal, Abi::Rust);\n         let expected_ty = tcx.mk_fn_ptr(Binder::dummy(expected_fn_sig));\n \n         // we emit the same error to suggest changing the arg no matter what's wrong with the arg"}, {"sha": "cf296a7bf6530daa8d0666102c9b4f14811694aa", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // the `closures` table.\n         let sig = bound_sig.map_bound(|sig| {\n             self.tcx.mk_fn_sig(\n-                iter::once(self.tcx.intern_tup(sig.inputs())),\n+                [self.tcx.intern_tup(sig.inputs())],\n                 sig.output(),\n                 sig.c_variadic,\n                 sig.unsafety,\n@@ -326,7 +326,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(?ret_param_ty);\n \n         let sig = projection.rebind(self.tcx.mk_fn_sig(\n-            input_tys.iter(),\n+            input_tys,\n             ret_param_ty,\n             false,\n             hir::Unsafety::Normal,"}, {"sha": "ba503bf47e70eb63b26cd95f7cf4d8cc0855ad0e", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1046,7 +1046,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.param_env,\n                 )\n                 .may_apply()\n-                .then(|| deref_ty)\n+                .then_some(deref_ty)\n         })\n     }\n "}, {"sha": "879a64fc0fb9fb54a6bd50657ca85c34a4641fed", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1269,10 +1269,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // ```\n                 let ref_ty = match mutability {\n                     hir::Mutability::Mut => {\n-                        self.tcx.mk_mut_ref(self.tcx.mk_region(ty::ReStatic), checked_ty)\n+                        self.tcx.mk_mut_ref(self.tcx.lifetimes.re_static, checked_ty)\n                     }\n                     hir::Mutability::Not => {\n-                        self.tcx.mk_imm_ref(self.tcx.mk_region(ty::ReStatic), checked_ty)\n+                        self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, checked_ty)\n                     }\n                 };\n                 if self.can_coerce(ref_ty, expected) {\n@@ -2037,7 +2037,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                    args: &[hir::Expr<'_>],\n                                    kind: CallableKind| {\n             let arg_idx = args.iter().position(|a| a.hir_id == expr.hir_id).unwrap();\n-            let fn_ty = self.tcx.bound_type_of(def_id).0;\n+            let fn_ty = self.tcx.type_of(def_id).skip_binder();\n             if !fn_ty.is_fn() {\n                 return;\n             }"}, {"sha": "5b641be062be6921f4fc27fbd7269c924733b137", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -663,6 +663,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 ty::PredicateKind::Clause(ty::Clause::Trait(..))\n                 | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n@@ -776,9 +777,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let def_kind = self.tcx.def_kind(def_id);\n \n         let item_ty = if let DefKind::Variant = def_kind {\n-            self.tcx.bound_type_of(self.tcx.parent(def_id))\n+            self.tcx.type_of(self.tcx.parent(def_id))\n         } else {\n-            self.tcx.bound_type_of(def_id)\n+            self.tcx.type_of(def_id)\n         };\n         let substs = self.fresh_substs_for_item(span, def_id);\n         let ty = item_ty.subst(self.tcx, substs);\n@@ -1130,7 +1131,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .unwrap_or(false);\n \n         let (res, self_ctor_substs) = if let Res::SelfCtor(impl_def_id) = res {\n-            let ty = self.handle_raw_ty(span, tcx.at(span).type_of(impl_def_id));\n+            let ty = self.handle_raw_ty(span, tcx.at(span).type_of(impl_def_id).subst_identity());\n             match ty.normalized.ty_adt_def() {\n                 Some(adt_def) if adt_def.has_ctor() => {\n                     let (ctor_kind, ctor_def_id) = adt_def.non_enum_variant().ctor.unwrap();\n@@ -1226,7 +1227,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     (GenericParamDefKind::Const { .. }, GenericArg::Infer(inf)) => {\n                         let tcx = self.fcx.tcx();\n-                        self.fcx.ct_infer(tcx.type_of(param.def_id), Some(param), inf.span).into()\n+                        self.fcx\n+                            .ct_infer(\n+                                tcx.type_of(param.def_id)\n+                                    .no_bound_vars()\n+                                    .expect(\"const parameter types cannot be generic\"),\n+                                Some(param),\n+                                inf.span,\n+                            )\n+                            .into()\n                     }\n                     _ => unreachable!(),\n                 }\n@@ -1248,7 +1257,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // If we have a default, then we it doesn't matter that we're not\n                             // inferring the type arguments: we provide the default where any\n                             // is missing.\n-                            tcx.bound_type_of(param.def_id).subst(tcx, substs.unwrap()).into()\n+                            tcx.type_of(param.def_id).subst(tcx, substs.unwrap()).into()\n                         } else {\n                             // If no type arguments were provided, we have to infer them.\n                             // This case also occurs as a result of some malformed input, e.g.\n@@ -1296,7 +1305,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Substitute the values for the type parameters into the type of\n         // the referenced item.\n-        let ty = tcx.bound_type_of(def_id);\n+        let ty = tcx.type_of(def_id);\n         assert!(!substs.has_escaping_bound_vars());\n         assert!(!ty.0.has_escaping_bound_vars());\n         let ty_substituted = self.normalize(span, ty.subst(tcx, substs));\n@@ -1307,7 +1316,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // type parameters, which we can infer by unifying the provided `Self`\n             // with the substituted impl type.\n             // This also occurs for an enum variant on a type alias.\n-            let impl_ty = self.normalize(span, tcx.bound_type_of(impl_def_id).subst(tcx, substs));\n+            let impl_ty = self.normalize(span, tcx.type_of(impl_def_id).subst(tcx, substs));\n             let self_ty = self.normalize(span, self_ty);\n             match self.at(&self.misc(span), self.param_env).eq(impl_ty, self_ty) {\n                 Ok(ok) => self.register_infer_ok_obligations(ok),"}, {"sha": "06d6a375697d1e7fb7edccc660a6b636ecd3c483", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // same rules that check_expr_struct uses for macro hygiene.\n                 if self.tcx.adjust_ident(expr_field.ident, variant_def_id) == field.ident(self.tcx)\n                 {\n-                    return Some((expr_field.expr, self.tcx.type_of(field.did)));\n+                    return Some((expr_field.expr, self.tcx.type_of(field.did).subst_identity()));\n                 }\n             }\n         }\n@@ -339,7 +339,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         receiver: Option<&'tcx hir::Expr<'tcx>>,\n         args: &'tcx [hir::Expr<'tcx>],\n     ) -> bool {\n-        let ty = self.tcx.type_of(def_id);\n+        let ty = self.tcx.type_of(def_id).subst_identity();\n         if !ty.is_fn() {\n             return false;\n         }\n@@ -477,19 +477,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // This is the \"trait\" (meaning, the predicate \"proved\" by this `impl`) which provides the `Self` type we care about.\n         // For the purposes of this function, we hope that it is a `struct` type, and that our current `expr` is a literal of\n         // that struct type.\n-        let impl_trait_self_ref: Option<ty::TraitRef<'tcx>> =\n-            self.tcx.impl_trait_ref(obligation.impl_def_id).map(|impl_def| impl_def.skip_binder());\n-\n-        let Some(impl_trait_self_ref) = impl_trait_self_ref else {\n-            // It is possible that this is absent. In this case, we make no progress.\n-            return Err(expr);\n+        let impl_trait_self_ref = if self.tcx.is_trait_alias(obligation.impl_or_alias_def_id) {\n+            self.tcx.mk_trait_ref(\n+                obligation.impl_or_alias_def_id,\n+                ty::InternalSubsts::identity_for_item(self.tcx, obligation.impl_or_alias_def_id),\n+            )\n+        } else {\n+            self.tcx\n+                .impl_trait_ref(obligation.impl_or_alias_def_id)\n+                .map(|impl_def| impl_def.skip_binder())\n+                // It is possible that this is absent. In this case, we make no progress.\n+                .ok_or(expr)?\n         };\n \n         // We only really care about the `Self` type itself, which we extract from the ref.\n         let impl_self_ty: Ty<'tcx> = impl_trait_self_ref.self_ty();\n \n         let impl_predicates: ty::GenericPredicates<'tcx> =\n-            self.tcx.predicates_of(obligation.impl_def_id);\n+            self.tcx.predicates_of(obligation.impl_or_alias_def_id);\n         let Some(impl_predicate_index) = obligation.impl_def_predicate_index else {\n             // We don't have the index, so we can only guess.\n             return Err(expr);"}, {"sha": "69a7235802bb3d29fcc177f85a43ca6e6fc4faba", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 97, "deletions": 26, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -755,15 +755,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         errors.drain_filter(|error| {\n-                let Error::Invalid(provided_idx, expected_idx, Compatibility::Incompatible(Some(e))) = error else { return false };\n-                let (provided_ty, provided_span) = provided_arg_tys[*provided_idx];\n-                let trace = mk_trace(provided_span, formal_and_expected_inputs[*expected_idx], provided_ty);\n-                if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308(_)) {\n-                    self.err_ctxt().report_and_explain_type_error(trace, *e).emit();\n-                    return true;\n-                }\n-                false\n-            });\n+            let Error::Invalid(\n+                provided_idx,\n+                expected_idx,\n+                Compatibility::Incompatible(Some(e)),\n+            ) = error else { return false };\n+            let (provided_ty, provided_span) = provided_arg_tys[*provided_idx];\n+            let trace =\n+                mk_trace(provided_span, formal_and_expected_inputs[*expected_idx], provided_ty);\n+            if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308(_)) {\n+                self.err_ctxt().report_and_explain_type_error(trace, *e).emit();\n+                return true;\n+            }\n+            false\n+        });\n \n         // We're done if we found errors, but we already emitted them.\n         if errors.is_empty() {\n@@ -864,7 +869,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         let mut suggestion_text = SuggestionText::None;\n \n+        let ty_to_snippet = |ty: Ty<'tcx>, expected_idx: ExpectedIdx| {\n+            if ty.is_unit() {\n+                \"()\".to_string()\n+            } else if ty.is_suggestable(tcx, false) {\n+                format!(\"/* {} */\", ty)\n+            } else if let Some(fn_def_id) = fn_def_id\n+                && self.tcx.def_kind(fn_def_id).is_fn_like()\n+                && let self_implicit =\n+                    matches!(call_expr.kind, hir::ExprKind::MethodCall(..)) as usize\n+                && let Some(arg) = self.tcx.fn_arg_names(fn_def_id)\n+                    .get(expected_idx.as_usize() + self_implicit)\n+                && arg.name != kw::SelfLower\n+            {\n+                format!(\"/* {} */\", arg.name)\n+            } else {\n+                \"/* value */\".to_string()\n+            }\n+        };\n+\n         let mut errors = errors.into_iter().peekable();\n+        let mut suggestions = vec![];\n         while let Some(error) = errors.next() {\n             match error {\n                 Error::Invalid(provided_idx, expected_idx, compatibility) => {\n@@ -905,7 +930,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \"\".to_string()\n                     };\n                     labels\n-                        .push((provided_span, format!(\"argument{} unexpected\", provided_ty_name)));\n+                        .push((provided_span, format!(\"unexpected argument{}\", provided_ty_name)));\n+                    let mut span = provided_span;\n+                    if arg_idx.index() > 0\n+                        && let Some((_, prev)) = provided_arg_tys\n+                            .get(ProvidedIdx::from_usize(arg_idx.index() - 1)\n+                    ) {\n+                        // Include previous comma\n+                        span = span.with_lo(prev.hi());\n+                    } else if let Some((_, next)) = provided_arg_tys.get(\n+                        ProvidedIdx::from_usize(arg_idx.index() + 1),\n+                    ) {\n+                        // Include next comma\n+                        span = span.until(*next);\n+                    }\n+                    suggestions.push((span, String::new()));\n+\n                     suggestion_text = match suggestion_text {\n                         SuggestionText::None => SuggestionText::Remove(false),\n                         SuggestionText::Remove(_) => SuggestionText::Remove(true),\n@@ -1095,6 +1135,45 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n+        // Incorporate the argument changes in the removal suggestion.\n+        // When a type is *missing*, and the rest are additional, we want to suggest these with a\n+        // multipart suggestion, but in order to do so we need to figure out *where* the arg that\n+        // was provided but had the wrong type should go, because when looking at `expected_idx`\n+        // that is the position in the argument list in the definition, while `provided_idx` will\n+        // not be present. So we have to look at what the *last* provided position was, and point\n+        // one after to suggest the replacement. FIXME(estebank): This is hacky, and there's\n+        // probably a better more involved change we can make to make this work.\n+        // For example, if we have\n+        // ```\n+        // fn foo(i32, &'static str) {}\n+        // foo((), (), ());\n+        // ```\n+        // what should be suggested is\n+        // ```\n+        // foo(/* i32 */, /* &str */);\n+        // ```\n+        // which includes the replacement of the first two `()` for the correct type, and the\n+        // removal of the last `()`.\n+        let mut prev = -1;\n+        for (expected_idx, provided_idx) in matched_inputs.iter_enumerated() {\n+            // We want to point not at the *current* argument expression index, but rather at the\n+            // index position where it *should have been*, which is *after* the previous one.\n+            if let Some(provided_idx) = provided_idx {\n+                prev = provided_idx.index() as i64;\n+            }\n+            let idx = ProvidedIdx::from_usize((prev + 1) as usize);\n+            if let None = provided_idx\n+                && let Some((_, arg_span)) = provided_arg_tys.get(idx)\n+            {\n+                // There is a type that was *not* found anywhere, so it isn't a move, but a\n+                // replacement and we look at what type it should have been. This will allow us\n+                // To suggest a multipart suggestion when encountering `foo(1, \"\")` where the def\n+                // was `fn foo(())`.\n+                let (_, expected_ty) = formal_and_expected_inputs[expected_idx];\n+                suggestions.push((*arg_span, ty_to_snippet(expected_ty, expected_idx)));\n+            }\n+        }\n+\n         // If we have less than 5 things to say, it would be useful to call out exactly what's wrong\n         if labels.len() <= 5 {\n             for (span, label) in labels {\n@@ -1112,7 +1191,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(format!(\"provide the argument{}\", if plural { \"s\" } else { \"\" }))\n             }\n             SuggestionText::Remove(plural) => {\n-                Some(format!(\"remove the extra argument{}\", if plural { \"s\" } else { \"\" }))\n+                err.multipart_suggestion(\n+                    &format!(\"remove the extra argument{}\", if plural { \"s\" } else { \"\" }),\n+                    suggestions,\n+                    Applicability::HasPlaceholders,\n+                );\n+                None\n             }\n             SuggestionText::Swap => Some(\"swap these arguments\".to_string()),\n             SuggestionText::Reorder => Some(\"reorder these arguments\".to_string()),\n@@ -1151,20 +1235,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else {\n                     // Propose a placeholder of the correct type\n                     let (_, expected_ty) = formal_and_expected_inputs[expected_idx];\n-                    if expected_ty.is_unit() {\n-                        \"()\".to_string()\n-                    } else if expected_ty.is_suggestable(tcx, false) {\n-                        format!(\"/* {} */\", expected_ty)\n-                    } else if let Some(fn_def_id) = fn_def_id\n-                        && self.tcx.def_kind(fn_def_id).is_fn_like()\n-                        && let self_implicit = matches!(call_expr.kind, hir::ExprKind::MethodCall(..)) as usize\n-                        && let Some(arg) = self.tcx.fn_arg_names(fn_def_id).get(expected_idx.as_usize() + self_implicit)\n-                        && arg.name != kw::SelfLower\n-                    {\n-                        format!(\"/* {} */\", arg.name)\n-                    } else {\n-                        \"/* value */\".to_string()\n-                    }\n+                    ty_to_snippet(expected_ty, expected_idx)\n                 };\n                 suggestion += &suggestion_text;\n             }\n@@ -1669,7 +1740,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match *qpath {\n             QPath::Resolved(ref maybe_qself, ref path) => {\n                 let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself).raw);\n-                let ty = self.astconv().res_to_ty(self_ty, path, true);\n+                let ty = self.astconv().res_to_ty(self_ty, path, hir_id, true);\n                 (path.res, self.handle_raw_ty(path_span, ty))\n             }\n             QPath::TypeRelative(ref qself, ref segment) => {"}, {"sha": "3539202d1ca6f7d2bf282ba0e3c52225d35b1d94", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1378,7 +1378,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Same item\n             return false;\n         }\n-        let item_ty = self.tcx.type_of(item.def_id);\n+        let item_ty = self.tcx.type_of(item.def_id).subst_identity();\n         // FIXME(compiler-errors): This check is *so* rudimentary\n         if item_ty.needs_subst() {\n             return false;"}, {"sha": "14e3ba83b103721e154df45424ae6c5836656db4", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -271,15 +271,13 @@ pub fn resolve_interior<'a, 'tcx>(\n                     },\n                     _ => mk_bound_region(None),\n                 };\n-                let r = fcx.tcx.mk_region(ty::ReLateBound(current_depth, br));\n+                let r = fcx.tcx.mk_re_late_bound(current_depth, br);\n                 r\n             });\n-            if captured_tys.insert(ty) {\n+            captured_tys.insert(ty).then(|| {\n                 cause.ty = ty;\n-                Some(cause)\n-            } else {\n-                None\n-            }\n+                cause\n+            })\n         })\n         .collect();\n \n@@ -302,7 +300,7 @@ pub fn resolve_interior<'a, 'tcx>(\n                     let var = ty::BoundVar::from_usize(bound_vars.len());\n                     bound_vars.push(ty::BoundVariableKind::Region(kind));\n                     counter += 1;\n-                    fcx.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { var, kind }))\n+                    fcx.tcx.mk_re_late_bound(ty::INNERMOST, ty::BoundRegion { var, kind })\n                 },\n                 types: &mut |b| bug!(\"unexpected bound ty in binder: {b:?}\"),\n                 consts: &mut |b, ty| bug!(\"unexpected bound ct in binder: {b:?} {ty}\"),\n@@ -314,7 +312,7 @@ pub fn resolve_interior<'a, 'tcx>(\n \n     // Extract type components to build the witness type.\n     let type_list = fcx.tcx.mk_type_list(type_causes.iter().map(|cause| cause.ty));\n-    let bound_vars = fcx.tcx.mk_bound_variable_kinds(bound_vars.iter());\n+    let bound_vars = fcx.tcx.intern_bound_variable_kinds(&bound_vars);\n     let witness =\n         fcx.tcx.mk_generator_witness(ty::Binder::bind_with_vars(type_list, bound_vars.clone()));\n \n@@ -364,7 +362,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                             let ty = tcx.mk_ref(\n                                 // Use `ReErased` as `resolve_interior` is going to replace all the\n                                 // regions anyway.\n-                                tcx.mk_region(ty::ReErased),\n+                                tcx.lifetimes.re_erased,\n                                 ty::TypeAndMut { ty, mutbl: hir::Mutability::Not },\n                             );\n                             self.interior_visitor.record("}, {"sha": "0204beb6fb84de79ac0272285f7acd7d69ac3048", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -154,15 +154,15 @@ fn typeck_const_arg<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (did, param_did): (LocalDefId, DefId),\n ) -> &ty::TypeckResults<'tcx> {\n-    let fallback = move || tcx.type_of(param_did);\n+    let fallback = move || tcx.type_of(param_did).subst_identity();\n     typeck_with_fallback(tcx, did, fallback)\n }\n \n fn typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tcx> {\n     if let Some(param_did) = tcx.opt_const_param_of(def_id) {\n         tcx.typeck_const_arg((def_id, param_did))\n     } else {\n-        let fallback = move || tcx.type_of(def_id.to_def_id());\n+        let fallback = move || tcx.type_of(def_id.to_def_id()).subst_identity();\n         typeck_with_fallback(tcx, def_id, fallback)\n     }\n }"}, {"sha": "f7de55c989fa3fe01407c054d726c98efb038dff", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -384,7 +384,15 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                     }\n                     (GenericParamDefKind::Const { .. }, GenericArg::Infer(inf)) => {\n                         let tcx = self.cfcx.tcx();\n-                        self.cfcx.ct_infer(tcx.type_of(param.def_id), Some(param), inf.span).into()\n+                        self.cfcx\n+                            .ct_infer(\n+                                tcx.type_of(param.def_id)\n+                                    .no_bound_vars()\n+                                    .expect(\"const parameter types cannot be generic\"),\n+                                Some(param),\n+                                inf.span,\n+                            )\n+                            .into()\n                     }\n                     _ => unreachable!(),\n                 }"}, {"sha": "0b9226802cf5ea97df342e09fbd00bb8ceca7e10", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -735,7 +735,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             debug!(\"impl_ty: {:?}\", impl_ty);\n \n             // Determine the receiver type that the method itself expects.\n-            let (xform_self_ty, xform_ret_ty) = self.xform_self_ty(&item, impl_ty, impl_substs);\n+            let (xform_self_ty, xform_ret_ty) = self.xform_self_ty(item, impl_ty, impl_substs);\n             debug!(\"xform_self_ty: {:?}, xform_ret_ty: {:?}\", xform_self_ty, xform_ret_ty);\n \n             // We can't use normalize_associated_types_in as it will pollute the\n@@ -796,7 +796,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             let new_trait_ref = this.erase_late_bound_regions(new_trait_ref);\n \n             let (xform_self_ty, xform_ret_ty) =\n-                this.xform_self_ty(&item, new_trait_ref.self_ty(), new_trait_ref.substs);\n+                this.xform_self_ty(item, new_trait_ref.self_ty(), new_trait_ref.substs);\n             this.push_candidate(\n                 Candidate {\n                     xform_self_ty,\n@@ -826,6 +826,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     }\n                 }\n                 ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n                 | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                 | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n@@ -845,7 +846,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             let trait_ref = this.erase_late_bound_regions(poly_trait_ref);\n \n             let (xform_self_ty, xform_ret_ty) =\n-                this.xform_self_ty(&item, trait_ref.self_ty(), trait_ref.substs);\n+                this.xform_self_ty(item, trait_ref.self_ty(), trait_ref.substs);\n \n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n@@ -916,7 +917,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     fn matches_return_type(\n         &self,\n-        method: &ty::AssocItem,\n+        method: ty::AssocItem,\n         self_ty: Option<Ty<'tcx>>,\n         expected: Ty<'tcx>,\n     ) -> bool {\n@@ -965,11 +966,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     } else {\n                         let new_trait_ref = self.erase_late_bound_regions(bound_trait_ref);\n \n-                        let (xform_self_ty, xform_ret_ty) = self.xform_self_ty(\n-                            &item,\n-                            new_trait_ref.self_ty(),\n-                            new_trait_ref.substs,\n-                        );\n+                        let (xform_self_ty, xform_ret_ty) =\n+                            self.xform_self_ty(item, new_trait_ref.self_ty(), new_trait_ref.substs);\n                         self.push_candidate(\n                             Candidate {\n                                 xform_self_ty,\n@@ -997,7 +995,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 }\n \n                 let (xform_self_ty, xform_ret_ty) =\n-                    self.xform_self_ty(&item, trait_ref.self_ty(), trait_substs);\n+                    self.xform_self_ty(item, trait_ref.self_ty(), trait_substs);\n                 self.push_candidate(\n                     Candidate {\n                         xform_self_ty,\n@@ -1024,7 +1022,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             .filter(|candidate| candidate_filter(&candidate.item))\n             .filter(|candidate| {\n                 if let Some(return_ty) = self.return_type {\n-                    self.matches_return_type(&candidate.item, None, return_ty)\n+                    self.matches_return_type(candidate.item, None, return_ty)\n                 } else {\n                     true\n                 }\n@@ -1576,7 +1574,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                                 traits::ImplDerivedObligation(Box::new(\n                                     traits::ImplDerivedObligationCause {\n                                         derived,\n-                                        impl_def_id,\n+                                        impl_or_alias_def_id: impl_def_id,\n                                         impl_def_predicate_index: None,\n                                         span,\n                                     },\n@@ -1883,7 +1881,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn xform_self_ty(\n         &self,\n-        item: &ty::AssocItem,\n+        item: ty::AssocItem,\n         impl_ty: Ty<'tcx>,\n         substs: SubstsRef<'tcx>,\n     ) -> (Ty<'tcx>, Option<Ty<'tcx>>) {\n@@ -1940,7 +1938,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         &self,\n         impl_def_id: DefId,\n     ) -> (ty::EarlyBinder<Ty<'tcx>>, SubstsRef<'tcx>) {\n-        (self.tcx.bound_type_of(impl_def_id), self.fresh_item_substs(impl_def_id))\n+        (self.tcx.type_of(impl_def_id), self.fresh_item_substs(impl_def_id))\n     }\n \n     fn fresh_item_substs(&self, def_id: DefId) -> SubstsRef<'tcx> {\n@@ -1958,7 +1956,14 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     kind: ConstVariableOriginKind::SubstitutionPlaceholder,\n                     span,\n                 };\n-                self.next_const_var(self.tcx.type_of(param.def_id), origin).into()\n+                self.next_const_var(\n+                    self.tcx\n+                        .type_of(param.def_id)\n+                        .no_bound_vars()\n+                        .expect(\"const parameter types cannot be generic\"),\n+                    origin,\n+                )\n+                .into()\n             }\n         })\n     }"}, {"sha": "6a7b1f6646abe1aa8594cb92817952069f7f0766", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -616,7 +616,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ObligationCauseCode::ImplDerivedObligation(data)\n                         if matches!(p.kind().skip_binder(), ty::PredicateKind::Clause(_)) =>\n                     {\n-                        Some((p, parent, data.impl_def_id, data))\n+                        Some((p, parent, data.impl_or_alias_def_id, data))\n                     }\n                     _ => None,\n                 })\n@@ -714,7 +714,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         );\n                     }\n                     Some(Node::Item(hir::Item {\n-                        ident, kind: hir::ItemKind::Trait(..), ..\n+                        ident,\n+                        kind: hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..),\n+                        ..\n                     })) => {\n                         skip_list.insert(p);\n                         let entry = spanned_predicates.entry(ident.span);\n@@ -906,8 +908,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         // different from the received one\n                                         // So we avoid suggestion method with Box<Self>\n                                         // for instance\n-                                        self.tcx.at(span).type_of(*def_id) != rcvr_ty\n-                                            && self.tcx.at(span).type_of(*def_id) != rcvr_ty\n+                                        self.tcx.at(span).type_of(*def_id).subst_identity()\n+                                            != rcvr_ty\n+                                            && self.tcx.at(span).type_of(*def_id).subst_identity()\n+                                                != rcvr_ty\n                                     }\n                                     (Mode::Path, false, _) => true,\n                                     _ => false,\n@@ -927,7 +931,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .iter()\n                             .take(limit)\n                             .map(|impl_item| {\n-                                format!(\"- `{}`\", self.tcx.at(span).type_of(*impl_item))\n+                                format!(\n+                                    \"- `{}`\",\n+                                    self.tcx.at(span).type_of(*impl_item).subst_identity()\n+                                )\n                             })\n                             .collect::<Vec<_>>()\n                             .join(\"\\n\");\n@@ -1104,7 +1111,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         None\n                     };\n \n-                    let impl_ty = self.tcx.at(span).type_of(impl_did);\n+                    let impl_ty = self.tcx.at(span).type_of(impl_did).subst_identity();\n \n                     let insertion = match self.tcx.impl_trait_ref(impl_did) {\n                         None => String::new(),\n@@ -1233,7 +1240,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // When the \"method\" is resolved through dereferencing, we really want the\n             // original type that has the associated function for accurate suggestions.\n             // (#61411)\n-            let impl_ty = self.tcx.type_of(*impl_did);\n+            let impl_ty = self.tcx.type_of(*impl_did).subst_identity();\n             let target_ty = self\n                 .autoderef(sugg_span, rcvr_ty)\n                 .find(|(rcvr_ty, _)| {\n@@ -1453,8 +1460,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n \n                     let range_def_id = self.tcx.require_lang_item(lang_item.unwrap(), None);\n-                    let range_ty =\n-                        self.tcx.bound_type_of(range_def_id).subst(self.tcx, &[actual.into()]);\n+                    let range_ty = self.tcx.type_of(range_def_id).subst(self.tcx, &[actual.into()]);\n \n                     let pick = self.lookup_probe_for_diagnostic(\n                         item_name,"}, {"sha": "7c8abb4186f116ea2d43c7aabc8351c2d66673a9", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -301,7 +301,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Build a tuple (U0..Un) of the final upvar types U0..Un\n         // and unify the upvar tuple type in the closure with it:\n-        let final_tupled_upvars_type = self.tcx.mk_tup(final_upvar_tys.iter());\n+        let final_tupled_upvars_type = self.tcx.intern_tup(&final_upvar_tys);\n         self.demand_suptype(span, substs.tupled_upvars_ty(), final_tupled_upvars_type);\n \n         let fake_reads = delegate\n@@ -315,8 +315,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.typeck_results.borrow_mut().closure_size_eval.insert(\n                 closure_def_id,\n                 ClosureSizeProfileData {\n-                    before_feature_tys: self.tcx.mk_tup(before_feature_tys.into_iter()),\n-                    after_feature_tys: self.tcx.mk_tup(after_feature_tys.into_iter()),\n+                    before_feature_tys: self.tcx.intern_tup(&before_feature_tys),\n+                    after_feature_tys: self.tcx.intern_tup(&after_feature_tys),\n                 },\n             );\n         }"}, {"sha": "2b33d31994f2fc9d5b326874cb9b6a6dac36ecb2", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -363,7 +363,7 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'cx, 'tcx> {\n                      opportunistically resolved to {:?}\",\n                     vid, resolved_vid\n                 );\n-                let r = self.tcx.reuse_or_mk_region(r, ty::ReVar(resolved_vid));\n+                let r = self.tcx.mk_re_var(resolved_vid);\n                 self.canonicalize_mode.canonicalize_free_region(self, r)\n             }\n \n@@ -737,8 +737,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n     ) -> ty::Region<'tcx> {\n         let var = self.canonical_var(info, r.into());\n         let br = ty::BoundRegion { var, kind: ty::BrAnon(var.as_u32(), None) };\n-        let region = ty::ReLateBound(self.binder_index, br);\n-        self.interner().mk_region(region)\n+        self.interner().mk_re_late_bound(self.binder_index, br)\n     }\n \n     /// Given a type variable `ty_var` of the given kind, first check"}, {"sha": "4552256545b4ba8d3551b2e1ca18f99eb9372880", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -137,7 +137,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             CanonicalVarKind::PlaceholderRegion(ty::PlaceholderRegion { universe, name }) => {\n                 let universe_mapped = universe_map(universe);\n                 let placeholder_mapped = ty::PlaceholderRegion { universe: universe_mapped, name };\n-                self.tcx.mk_region(ty::RePlaceholder(placeholder_mapped)).into()\n+                self.tcx.mk_re_placeholder(placeholder_mapped).into()\n             }\n \n             CanonicalVarKind::Const(ui, ty) => self"}, {"sha": "b9cb9732ca3edc4196ba883b5c66d1336aefd38a", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -642,15 +642,14 @@ pub fn make_query_region_constraints<'tcx>(\n             let constraint = match *k {\n                 // Swap regions because we are going from sub (<=) to outlives\n                 // (>=).\n-                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n-                    tcx.mk_region(ty::ReVar(v2)).into(),\n-                    tcx.mk_region(ty::ReVar(v1)),\n-                ),\n+                Constraint::VarSubVar(v1, v2) => {\n+                    ty::OutlivesPredicate(tcx.mk_re_var(v2).into(), tcx.mk_re_var(v1))\n+                }\n                 Constraint::VarSubReg(v1, r2) => {\n-                    ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n+                    ty::OutlivesPredicate(r2.into(), tcx.mk_re_var(v1))\n                 }\n                 Constraint::RegSubVar(r1, v2) => {\n-                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n+                    ty::OutlivesPredicate(tcx.mk_re_var(v2).into(), r1)\n                 }\n                 Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n             };\n@@ -690,7 +689,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n     }\n \n     fn next_placeholder_region(&mut self, placeholder: ty::PlaceholderRegion) -> ty::Region<'tcx> {\n-        self.infcx.tcx.mk_region(ty::RePlaceholder(placeholder))\n+        self.infcx.tcx.mk_re_placeholder(placeholder)\n     }\n \n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {"}, {"sha": "f5504b05dc4e38d18349699db352f878d5dd9355", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -125,11 +125,11 @@ impl<'tcx> InferCtxt<'tcx> {\n             }\n \n             (ty::Alias(AliasKind::Projection, _), _) if self.tcx.trait_solver_next() => {\n-                relation.register_type_equate_obligation(a.into(), b.into());\n+                relation.register_type_equate_obligation(a, b);\n                 Ok(b)\n             }\n             (_, ty::Alias(AliasKind::Projection, _)) if self.tcx.trait_solver_next() => {\n-                relation.register_type_equate_obligation(b.into(), a.into());\n+                relation.register_type_equate_obligation(b, a);\n                 Ok(a)\n             }\n "}, {"sha": "cf2f6ef33bebae1c39de756b565bfd619497c73c", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1062,7 +1062,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n \n                 let parent_def_id = generics.parent.unwrap();\n                 if let DefKind::Impl { .. } = tcx.def_kind(parent_def_id) {\n-                    let parent_ty = tcx.bound_type_of(parent_def_id).subst(tcx, substs);\n+                    let parent_ty = tcx.type_of(parent_def_id).subst(tcx, substs);\n                     match (parent_ty.kind(), &ty.kind) {\n                         (\n                             ty::Adt(def, substs),"}, {"sha": "fec04af231393bb84508ce9046ef7b26f034633d", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -2,7 +2,7 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::resolve_lifetime as rl;\n+use rustc_middle::middle::resolve_bound_vars as rbv;\n use rustc_middle::ty::{self, Region, TyCtxt};\n \n /// This function calls the `visit_ty` method for the parameters\n@@ -99,11 +99,11 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n             hir::TyKind::Ref(ref lifetime, _) => {\n                 // the lifetime of the Ref\n                 let hir_id = lifetime.hir_id;\n-                match (self.tcx.named_region(hir_id), self.bound_region) {\n+                match (self.tcx.named_bound_var(hir_id), self.bound_region) {\n                     // Find the index of the named region that was part of the\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n-                    (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n+                    (Some(rbv::ResolvedArg::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                         debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                         if id == def_id {\n                             self.found_type = Some(arg);\n@@ -115,7 +115,7 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n                     (\n-                        Some(rl::Region::LateBound(debruijn_index, _, id)),\n+                        Some(rbv::ResolvedArg::LateBound(debruijn_index, _, id)),\n                         ty::BrNamed(def_id, _),\n                     ) => {\n                         debug!(\n@@ -131,10 +131,11 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n \n                     (\n                         Some(\n-                            rl::Region::Static\n-                            | rl::Region::Free(_, _)\n-                            | rl::Region::EarlyBound(_)\n-                            | rl::Region::LateBound(_, _, _),\n+                            rbv::ResolvedArg::StaticLifetime\n+                            | rbv::ResolvedArg::Free(_, _)\n+                            | rbv::ResolvedArg::EarlyBound(_)\n+                            | rbv::ResolvedArg::LateBound(_, _, _)\n+                            | rbv::ResolvedArg::Error(_),\n                         )\n                         | None,\n                         _,\n@@ -186,17 +187,17 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n-        match (self.tcx.named_region(lifetime.hir_id), self.bound_region) {\n+        match (self.tcx.named_bound_var(lifetime.hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n-            (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n+            (Some(rbv::ResolvedArg::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                 if id == def_id {\n                     self.found_it = true;\n                     return; // we can stop visiting now\n                 }\n             }\n \n-            (Some(rl::Region::LateBound(debruijn_index, _, id)), ty::BrNamed(def_id, _)) => {\n+            (Some(rbv::ResolvedArg::LateBound(debruijn_index, _, id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\", debruijn_index,);\n                 debug!(\"id={:?}\", id);\n                 debug!(\"def_id={:?}\", def_id);\n@@ -208,10 +209,11 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n \n             (\n                 Some(\n-                    rl::Region::Static\n-                    | rl::Region::EarlyBound(_)\n-                    | rl::Region::LateBound(_, _, _)\n-                    | rl::Region::Free(_, _),\n+                    rbv::ResolvedArg::StaticLifetime\n+                    | rbv::ResolvedArg::EarlyBound(_)\n+                    | rbv::ResolvedArg::LateBound(_, _, _)\n+                    | rbv::ResolvedArg::Free(_, _)\n+                    | rbv::ResolvedArg::Error(_),\n                 )\n                 | None,\n                 _,"}, {"sha": "2c63a3904107283f749cc570d6560c87fef77154", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             };\n \n             // Next, let's figure out the set of trait objects with implicit static bounds\n-            let ty = self.tcx().type_of(*impl_def_id);\n+            let ty = self.tcx().type_of(*impl_def_id).subst_identity();\n             let mut v = super::static_impl_trait::TraitObjectVisitor(FxIndexSet::default());\n             v.visit_ty(ty);\n             let mut traits = vec![];"}, {"sha": "c1ea0a0d95e96a1d9dd7a106346e815e879461f2", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::print::{FmtPrinter, Print, RegionHighlightMode};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, RePlaceholder, ReVar, Region, TyCtxt};\n+use rustc_middle::ty::{self, RePlaceholder, Region, TyCtxt};\n \n use std::fmt;\n \n@@ -79,7 +79,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 sup_placeholder @ Region(Interned(RePlaceholder(_), _)),\n                 _,\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_region(ReVar(*vid))),\n+                Some(self.tcx().mk_re_var(*vid)),\n                 cause,\n                 Some(*sub_placeholder),\n                 Some(*sup_placeholder),\n@@ -95,7 +95,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 _,\n                 _,\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_region(ReVar(*vid))),\n+                Some(self.tcx().mk_re_var(*vid)),\n                 cause,\n                 Some(*sub_placeholder),\n                 None,\n@@ -111,7 +111,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 sup_placeholder @ Region(Interned(RePlaceholder(_), _)),\n                 _,\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_region(ReVar(*vid))),\n+                Some(self.tcx().mk_re_var(*vid)),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),\n@@ -127,7 +127,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 sup_placeholder @ Region(Interned(RePlaceholder(_), _)),\n                 _,\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_region(ReVar(*vid))),\n+                Some(self.tcx().mk_re_var(*vid)),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),\n@@ -141,7 +141,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sup_placeholder @ Region(Interned(RePlaceholder(_), _)),\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_region(ReVar(*vid))),\n+                Some(self.tcx().mk_re_var(*vid)),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),"}, {"sha": "ac4de2cc84266a3294b16cbdea8a513d0bfaea6b", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -90,20 +90,18 @@ pub fn find_param_with_region<'tcx>(\n                     r\n                 }\n             });\n-            if found_anon_region {\n+            found_anon_region.then(|| {\n                 let ty_hir_id = fn_decl.inputs[index].hir_id;\n                 let param_ty_span = hir.span(ty_hir_id);\n                 let is_first = index == 0;\n-                Some(AnonymousParamInfo {\n+                AnonymousParamInfo {\n                     param,\n                     param_ty: new_param_ty,\n                     param_ty_span,\n                     bound_region,\n                     is_first,\n-                })\n-            } else {\n-                None\n-            }\n+                }\n+            })\n         })\n }\n \n@@ -125,7 +123,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         br: ty::BoundRegionKind,\n         hir_sig: &hir::FnSig<'_>,\n     ) -> Option<Span> {\n-        let fn_ty = self.tcx().type_of(scope_def_id);\n+        let fn_ty = self.tcx().type_of(scope_def_id).subst_identity();\n         if let ty::FnDef(_, _) = fn_ty.kind() {\n             let ret_ty = fn_ty.fn_sig(self.tcx()).output();\n             let span = hir_sig.decl.output.span();"}, {"sha": "b33729d0be5c9a509020f7f4affe067675bb59ea", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -326,7 +326,7 @@ impl<T> Trait<T> for X {\n                         diag,\n                         &trait_ref,\n                         pred.bounds,\n-                        &assoc,\n+                        assoc,\n                         assoc_substs,\n                         ty,\n                         msg,\n@@ -577,7 +577,7 @@ fn foo(&self) -> Self::T { String::new() }\n                             if let hir::Defaultness::Default { has_value: true } =\n                                 tcx.impl_defaultness(item.id.owner_id)\n                             {\n-                                let assoc_ty = tcx.bound_type_of(item.id.owner_id).subst_identity();\n+                                let assoc_ty = tcx.type_of(item.id.owner_id).subst_identity();\n                                 if self.infcx.can_eq(param_env, assoc_ty, found) {\n                                     diag.span_label(\n                                         item.span,\n@@ -598,7 +598,7 @@ fn foo(&self) -> Self::T { String::new() }\n             })) => {\n                 for item in &items[..] {\n                     if let hir::AssocItemKind::Type = item.kind {\n-                        let assoc_ty = tcx.bound_type_of(item.id.owner_id).subst_identity();\n+                        let assoc_ty = tcx.type_of(item.id.owner_id).subst_identity();\n \n                         if self.infcx.can_eq(param_env, assoc_ty, found) {\n                             diag.span_label(item.span, \"expected this associated type\");\n@@ -624,7 +624,7 @@ fn foo(&self) -> Self::T { String::new() }\n         diag: &mut Diagnostic,\n         trait_ref: &ty::TraitRef<'tcx>,\n         bounds: hir::GenericBounds<'_>,\n-        assoc: &ty::AssocItem,\n+        assoc: ty::AssocItem,\n         assoc_substs: &[ty::GenericArg<'tcx>],\n         ty: Ty<'tcx>,\n         msg: &str,\n@@ -667,7 +667,7 @@ fn foo(&self) -> Self::T { String::new() }\n         &self,\n         diag: &mut Diagnostic,\n         span: Span,\n-        assoc: &ty::AssocItem,\n+        assoc: ty::AssocItem,\n         assoc_substs: &[ty::GenericArg<'tcx>],\n         ty: Ty<'tcx>,\n         msg: &str,"}, {"sha": "82a1bb1fd1615a9de220b2fae4c8b872cf69f665", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -82,10 +82,10 @@ impl<'tcx> InferCtxt<'tcx> {\n \n         let delegate = FnMutDelegate {\n             regions: &mut |br: ty::BoundRegion| {\n-                self.tcx.mk_region(ty::RePlaceholder(ty::PlaceholderRegion {\n+                self.tcx.mk_re_placeholder(ty::PlaceholderRegion {\n                     universe: next_universe,\n                     name: br.kind,\n-                }))\n+                })\n             },\n             types: &mut |bound_ty: ty::BoundTy| {\n                 self.tcx.mk_placeholder(ty::PlaceholderType {"}, {"sha": "ac203c4eb0b24d054df8636e86c37369192ff547", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -382,7 +382,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     // name the placeholder, then the placeholder is\n                     // larger; otherwise, the only ancestor is `'static`.\n                     Err(placeholder) if empty_ui.can_name(placeholder.universe) => {\n-                        self.tcx().mk_region(RePlaceholder(placeholder))\n+                        self.tcx().mk_re_placeholder(placeholder)\n                     }\n                     Err(_) => self.tcx().lifetimes.re_static,\n                 };\n@@ -1046,7 +1046,7 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n             ty::ReVar(rid) => match self.values[rid] {\n                 VarValue::Empty(_) => r,\n                 VarValue::Value(r) => r,\n-                VarValue::ErrorValue => tcx.re_error_misc(),\n+                VarValue::ErrorValue => tcx.mk_re_error_misc(),\n             },\n             _ => r,\n         };"}, {"sha": "aa316b2dadb0447ecde9f0710000fb3dc81c4ad0", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1093,7 +1093,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     ) -> ty::Region<'tcx> {\n         let region_var =\n             self.inner.borrow_mut().unwrap_region_constraints().new_region_var(universe, origin);\n-        self.tcx.mk_region(ty::ReVar(region_var))\n+        self.tcx.mk_re_var(region_var)\n     }\n \n     /// Return the universe that the region `r` was created in. For\n@@ -1166,7 +1166,15 @@ impl<'tcx> InferCtxt<'tcx> {\n                         origin,\n                         val: ConstVariableValue::Unknown { universe: self.universe() },\n                     });\n-                self.tcx.mk_const(const_var_id, self.tcx.type_of(param.def_id)).into()\n+                self.tcx\n+                    .mk_const(\n+                        const_var_id,\n+                        self.tcx\n+                            .type_of(param.def_id)\n+                            .no_bound_vars()\n+                            .expect(\"const parameter types cannot be generic\"),\n+                    )\n+                    .into()\n             }\n         }\n     }"}, {"sha": "83f3d5a74fb48d9a25e422758cc988172c963e8e", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -21,6 +21,7 @@ pub fn explicit_outlives_bounds<'tcx>(\n         .filter_map(move |kind| match kind {\n             ty::PredicateKind::Clause(ty::Clause::Projection(..))\n             | ty::PredicateKind::Clause(ty::Clause::Trait(..))\n+            | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n             | ty::PredicateKind::AliasEq(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::Subtype(..)"}, {"sha": "e413b2bb570d6b23d79a23c00bc121182c5d8b31", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -280,7 +280,7 @@ impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n         placeholder1: ty::PlaceholderRegion,\n         placeholder2: ty::PlaceholderRegion,\n     ) -> TypeError<'tcx> {\n-        self.error(placeholder1, self.tcx.mk_region(ty::RePlaceholder(placeholder2)))\n+        self.error(placeholder1, self.tcx.mk_re_placeholder(placeholder2))\n     }\n \n     fn error(\n@@ -413,19 +413,19 @@ impl<'tcx> MiniGraph<'tcx> {\n         for undo_entry in undo_log {\n             match undo_entry {\n                 &AddConstraint(Constraint::VarSubVar(a, b)) => {\n-                    each_edge(tcx.mk_region(ReVar(a)), tcx.mk_region(ReVar(b)));\n+                    each_edge(tcx.mk_re_var(a), tcx.mk_re_var(b));\n                 }\n                 &AddConstraint(Constraint::RegSubVar(a, b)) => {\n-                    each_edge(a, tcx.mk_region(ReVar(b)));\n+                    each_edge(a, tcx.mk_re_var(b));\n                 }\n                 &AddConstraint(Constraint::VarSubReg(a, b)) => {\n-                    each_edge(tcx.mk_region(ReVar(a)), b);\n+                    each_edge(tcx.mk_re_var(a), b);\n                 }\n                 &AddConstraint(Constraint::RegSubReg(a, b)) => {\n                     each_edge(a, b);\n                 }\n                 &AddGiven(a, b) => {\n-                    each_edge(a, tcx.mk_region(ReVar(b)));\n+                    each_edge(a, tcx.mk_re_var(b));\n                 }\n                 &AddVerify(i) => span_bug!(\n                     verifys[i].origin.span(),"}, {"sha": "33514eedfc3d009ed6cfe9b736e3d869830f139d", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -651,7 +651,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n                 let unified_region = self.unification_table().probe_value(rid);\n                 unified_region.0.unwrap_or_else(|| {\n                     let root = self.unification_table().find(rid).vid;\n-                    tcx.reuse_or_mk_region(region, ty::ReVar(root))\n+                    tcx.mk_re_var(root)\n                 })\n             }\n             _ => region,\n@@ -675,15 +675,15 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     ) -> Region<'tcx> {\n         let vars = TwoRegions { a, b };\n         if let Some(&c) = self.combine_map(t).get(&vars) {\n-            return tcx.mk_region(ReVar(c));\n+            return tcx.mk_re_var(c);\n         }\n         let a_universe = self.universe(a);\n         let b_universe = self.universe(b);\n         let c_universe = cmp::max(a_universe, b_universe);\n         let c = self.new_region_var(c_universe, MiscVariable(origin.span()));\n         self.combine_map(t).insert(vars, c);\n         self.undo_log.push(AddCombination(t, vars));\n-        let new_r = tcx.mk_region(ReVar(c));\n+        let new_r = tcx.mk_re_var(c);\n         for old_r in [a, b] {\n             match t {\n                 Glb => self.make_subregion(origin.clone(), new_r, old_r),"}, {"sha": "2c246a5787c7cf92e299ea6efd732efb3399cd09", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for OpportunisticRegionResolver<'a, 'tcx\n                     .borrow_mut()\n                     .unwrap_region_constraints()\n                     .opportunistic_resolve_var(rid);\n-                TypeFolder::interner(self).reuse_or_mk_region(r, ty::ReVar(resolved))\n+                TypeFolder::interner(self).mk_re_var(resolved)\n             }\n             _ => r,\n         }"}, {"sha": "c1f0a6e98340de4396e21fb4708bf74a5c0a73dd", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -158,7 +158,7 @@ impl<'tcx> Elaborator<'tcx> {\n                                 traits::ImplDerivedObligation(Box::new(\n                                     traits::ImplDerivedObligationCause {\n                                         derived,\n-                                        impl_def_id: data.def_id(),\n+                                        impl_or_alias_def_id: data.def_id(),\n                                         impl_def_predicate_index: Some(index),\n                                         span,\n                                     },\n@@ -297,6 +297,9 @@ impl<'tcx> Elaborator<'tcx> {\n             ty::PredicateKind::AliasEq(..) => {\n                 // No\n             }\n+            ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => {\n+                // Nothing to elaborate\n+            }\n         }\n     }\n }"}, {"sha": "e6f04fe0aaa634c8405aa8cad9330e70d892d561", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -95,7 +95,7 @@ pub enum TokenKind {\n     Literal { kind: LiteralKind, suffix_start: u32 },\n \n     /// \"'a\"\n-    Lifetime { starts_with_number: bool },\n+    Lifetime { starts_with_number: bool, contains_emoji: bool },\n \n     // One-char tokens:\n     /// \";\"\n@@ -630,7 +630,13 @@ impl Cursor<'_> {\n             // If the first symbol is valid for identifier, it can be a lifetime.\n             // Also check if it's a number for a better error reporting (so '0 will\n             // be reported as invalid lifetime and not as unterminated char literal).\n-            is_id_start(self.first()) || self.first().is_digit(10)\n+            // We also have to account for potential `'\ud83d\udc31` emojis to avoid reporting\n+            // it as an unterminated char literal.\n+            is_id_start(self.first())\n+                || self.first().is_digit(10)\n+                // FIXME(#108019): `unic-emoji-char` seems to have data tables only up to Unicode\n+                // 5.0, but Unicode is already newer than this.\n+                || unic_emoji_char::is_emoji(self.first())\n         };\n \n         if !can_be_a_lifetime {\n@@ -643,16 +649,33 @@ impl Cursor<'_> {\n             return Literal { kind, suffix_start };\n         }\n \n-        // Either a lifetime or a character literal with\n-        // length greater than 1.\n+        // Either a lifetime or a character literal.\n \n         let starts_with_number = self.first().is_digit(10);\n+        let mut contains_emoji = false;\n \n-        // Skip the literal contents.\n-        // First symbol can be a number (which isn't a valid identifier start),\n-        // so skip it without any checks.\n-        self.bump();\n-        self.eat_while(is_id_continue);\n+        // FIXME(#108019): `unic-emoji-char` seems to have data tables only up to Unicode\n+        // 5.0, but Unicode is already newer than this.\n+        if unic_emoji_char::is_emoji(self.first()) {\n+            contains_emoji = true;\n+        } else {\n+            // Skip the literal contents.\n+            // First symbol can be a number (which isn't a valid identifier start),\n+            // so skip it without any checks.\n+            self.bump();\n+        }\n+        self.eat_while(|c| {\n+            if is_id_continue(c) {\n+                true\n+            // FIXME(#108019): `unic-emoji-char` seems to have data tables only up to Unicode\n+            // 5.0, but Unicode is already newer than this.\n+            } else if unic_emoji_char::is_emoji(c) {\n+                contains_emoji = true;\n+                true\n+            } else {\n+                false\n+            }\n+        });\n \n         // Check if after skipping literal contents we've met a closing\n         // single quote (which means that user attempted to create a\n@@ -662,7 +685,7 @@ impl Cursor<'_> {\n             let kind = Char { terminated: true };\n             Literal { kind, suffix_start: self.pos_within_token() }\n         } else {\n-            Lifetime { starts_with_number }\n+            Lifetime { starts_with_number, contains_emoji }\n         }\n     }\n "}, {"sha": "670d64fb983f574932abcb5f515a61548c4215b5", "filename": "compiler/rustc_lexer/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lexer%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lexer%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Ftests.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -235,7 +235,7 @@ fn lifetime() {\n     check_lexing(\n         \"'abc\",\n         expect![[r#\"\n-            Token { kind: Lifetime { starts_with_number: false }, len: 4 }\n+            Token { kind: Lifetime { starts_with_number: false, contains_emoji: false }, len: 4 }\n         \"#]],\n     );\n }"}, {"sha": "11fb1f80a111d2741b60af075534eee3aba61ccd", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -183,7 +183,7 @@ impl<'tcx> LateLintPass<'tcx> for BoxPointers {\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..) => {\n-                self.check_heap_type(cx, it.span, cx.tcx.type_of(it.owner_id))\n+                self.check_heap_type(cx, it.span, cx.tcx.type_of(it.owner_id).subst_identity())\n             }\n             _ => (),\n         }\n@@ -192,7 +192,11 @@ impl<'tcx> LateLintPass<'tcx> for BoxPointers {\n         match it.kind {\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n                 for field in struct_def.fields() {\n-                    self.check_heap_type(cx, field.span, cx.tcx.type_of(field.def_id));\n+                    self.check_heap_type(\n+                        cx,\n+                        field.span,\n+                        cx.tcx.type_of(field.def_id).subst_identity(),\n+                    );\n                 }\n             }\n             _ => (),\n@@ -589,7 +593,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             // If the method is an impl for an item with docs_hidden, don't doc.\n             MethodLateContext::PlainImpl => {\n                 let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n-                let impl_ty = cx.tcx.type_of(parent);\n+                let impl_ty = cx.tcx.type_of(parent).subst_identity();\n                 let outerdef = match impl_ty.kind() {\n                     ty::Adt(def, _) => Some(def.did()),\n                     ty::Foreign(def_id) => Some(*def_id),\n@@ -698,7 +702,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n         // and recommending Copy might be a bad idea.\n         for field in def.all_fields() {\n             let did = field.did;\n-            if cx.tcx.type_of(did).is_unsafe_ptr() {\n+            if cx.tcx.type_of(did).subst_identity().is_unsafe_ptr() {\n                 return;\n             }\n         }\n@@ -798,7 +802,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n         if self.impling_types.is_none() {\n             let mut impls = LocalDefIdSet::default();\n             cx.tcx.for_each_impl(debug, |d| {\n-                if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n+                if let Some(ty_def) = cx.tcx.type_of(d).subst_identity().ty_adt_def() {\n                     if let Some(def_id) = ty_def.did().as_local() {\n                         impls.insert(def_id);\n                     }\n@@ -1591,6 +1595,8 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     Clause(Clause::TypeOutlives(..)) |\n                     Clause(Clause::RegionOutlives(..)) => \"lifetime\",\n \n+                    // `ConstArgHasType` is never global as `ct` is always a param\n+                    Clause(Clause::ConstArgHasType(..)) |\n                     // Ignore projections, as they can only be global\n                     // if the trait bound is global\n                     Clause(Clause::Projection(..)) |\n@@ -2007,7 +2013,7 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives: &[ty::Region<'tcx>],\n         predicate_span: Span,\n     ) -> Vec<(usize, Span)> {\n-        use rustc_middle::middle::resolve_lifetime::Region;\n+        use rustc_middle::middle::resolve_bound_vars::ResolvedArg;\n \n         bounds\n             .iter()\n@@ -2017,8 +2023,8 @@ impl ExplicitOutlivesRequirements {\n                     return None;\n                 };\n \n-                let is_inferred = match tcx.named_region(lifetime.hir_id) {\n-                    Some(Region::EarlyBound(def_id)) => inferred_outlives\n+                let is_inferred = match tcx.named_bound_var(lifetime.hir_id) {\n+                    Some(ResolvedArg::EarlyBound(def_id)) => inferred_outlives\n                         .iter()\n                         .any(|r| matches!(**r, ty::ReEarlyBound(ebr) if { ebr.def_id == def_id })),\n                     _ => false,\n@@ -2097,7 +2103,7 @@ impl ExplicitOutlivesRequirements {\n \n impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        use rustc_middle::middle::resolve_lifetime::Region;\n+        use rustc_middle::middle::resolve_bound_vars::ResolvedArg;\n \n         let def_id = item.owner_id.def_id;\n         if let hir::ItemKind::Struct(_, hir_generics)\n@@ -2120,8 +2126,8 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                 let (relevant_lifetimes, bounds, predicate_span, in_where_clause) =\n                     match where_predicate {\n                         hir::WherePredicate::RegionPredicate(predicate) => {\n-                            if let Some(Region::EarlyBound(region_def_id)) =\n-                                cx.tcx.named_region(predicate.lifetime.hir_id)\n+                            if let Some(ResolvedArg::EarlyBound(region_def_id)) =\n+                                cx.tcx.named_bound_var(predicate.lifetime.hir_id)\n                             {\n                                 (\n                                     Self::lifetimes_outliving_lifetime(\n@@ -2308,11 +2314,8 @@ impl EarlyLintPass for IncompleteFeatures {\n             .for_each(|(&name, &span)| {\n                 let note = rustc_feature::find_feature_issue(name, GateIssue::Language)\n                     .map(|n| BuiltinIncompleteFeaturesNote { n });\n-                let help = if HAS_MIN_FEATURES.contains(&name) {\n-                    Some(BuiltinIncompleteFeaturesHelp)\n-                } else {\n-                    None\n-                };\n+                let help =\n+                    HAS_MIN_FEATURES.contains(&name).then_some(BuiltinIncompleteFeaturesHelp);\n                 cx.emit_spanned_lint(\n                     INCOMPLETE_FEATURES,\n                     span,\n@@ -2855,8 +2858,8 @@ impl ClashingExternDeclarations {\n                                     structurally_same_type_impl(\n                                         seen_types,\n                                         cx,\n-                                        tcx.type_of(a_did),\n-                                        tcx.type_of(b_did),\n+                                        tcx.type_of(a_did).subst_identity(),\n+                                        tcx.type_of(b_did).subst_identity(),\n                                         ckind,\n                                     )\n                                 },\n@@ -2956,8 +2959,8 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n         if let ForeignItemKind::Fn(..) = this_fi.kind {\n             let tcx = cx.tcx;\n             if let Some(existing_did) = self.insert(tcx, this_fi) {\n-                let existing_decl_ty = tcx.type_of(existing_did);\n-                let this_decl_ty = tcx.type_of(this_fi.owner_id);\n+                let existing_decl_ty = tcx.type_of(existing_did).skip_binder();\n+                let this_decl_ty = tcx.type_of(this_fi.owner_id).subst_identity();\n                 debug!(\n                     \"ClashingExternDeclarations: Comparing existing {:?}: {:?} to this {:?}: {:?}\",\n                     existing_did, existing_decl_ty, this_fi.owner_id, this_decl_ty"}, {"sha": "9a9e2de7b5c7f561cfcf5890b0b19ba4a2e0dc76", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -487,7 +487,7 @@ impl LintStore {\n         let mut groups: Vec<_> = self\n             .lint_groups\n             .iter()\n-            .filter_map(|(k, LintGroup { depr, .. })| if depr.is_none() { Some(k) } else { None })\n+            .filter_map(|(k, LintGroup { depr, .. })| depr.is_none().then_some(k))\n             .collect();\n         groups.sort();\n         let groups = groups.iter().map(|k| Symbol::intern(k));\n@@ -1112,11 +1112,9 @@ impl<'tcx> LateContext<'tcx> {\n                 .maybe_typeck_results()\n                 .filter(|typeck_results| typeck_results.hir_owner == id.owner)\n                 .or_else(|| {\n-                    if self.tcx.has_typeck_results(id.owner.to_def_id()) {\n-                        Some(self.tcx.typeck(id.owner.def_id))\n-                    } else {\n-                        None\n-                    }\n+                    self.tcx\n+                        .has_typeck_results(id.owner.to_def_id())\n+                        .then(|| self.tcx.typeck(id.owner.def_id))\n                 })\n                 .and_then(|typeck_results| typeck_results.type_dependent_def(id))\n                 .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),"}, {"sha": "ccf95992a6e6e63c44345c44b3172d0a69e06bce", "filename": "compiler/rustc_lint/src/deref_into_dyn_supertrait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for DerefIntoDynSupertrait {\n         // `Deref` is being implemented for `t`\n         if let hir::ItemKind::Impl(impl_) = item.kind\n             && let Some(trait_) = &impl_.of_trait\n-            && let t = cx.tcx.type_of(item.owner_id)\n+            && let t = cx.tcx.type_of(item.owner_id).subst_identity()\n             && let opt_did @ Some(did) = trait_.trait_def_id()\n             && opt_did == cx.tcx.lang_items().deref_trait()\n             // `t` is `dyn t_principal`\n@@ -78,7 +78,7 @@ impl<'tcx> LateLintPass<'tcx> for DerefIntoDynSupertrait {\n             });\n             cx.emit_spanned_lint(DEREF_INTO_DYN_SUPERTRAIT, cx.tcx.def_span(item.owner_id.def_id), SupertraitAsDerefTarget {\n                 t,\n-                target_principal: target_principal.to_string(),\n+                target_principal,\n                 label,\n             });\n         }"}, {"sha": "a3367ae4a9f15061eaf6a95d14c497f0d506b19e", "filename": "compiler/rustc_lint/src/for_loops_over_fallibles.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -65,11 +65,8 @@ impl<'tcx> LateLintPass<'tcx> for ForLoopsOverFallibles {\n             } else {\n                 ForLoopsOverFalliblesLoopSub::UseWhileLet { start_span: expr.span.with_hi(pat.span.lo()), end_span: pat.span.between(arg.span), var }\n             } ;\n-        let question_mark = if suggest_question_mark(cx, adt, substs, expr.span) {\n-            Some(ForLoopsOverFalliblesQuestionMark { suggestion: arg.span.shrink_to_hi() })\n-        } else {\n-            None\n-        };\n+        let question_mark = suggest_question_mark(cx, adt, substs, expr.span)\n+            .then(|| ForLoopsOverFalliblesQuestionMark { suggestion: arg.span.shrink_to_hi() });\n         let suggestion = ForLoopsOverFalliblesSuggestion {\n             var,\n             start_span: expr.span.with_hi(pat.span.lo()),"}, {"sha": "2fd0ef3cda8b76bfab36cc67ab26b94f4a521f69", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -216,7 +216,7 @@ fn is_ty_or_ty_ctxt(cx: &LateContext<'_>, path: &Path<'_>) -> Option<String> {\n         }\n         // Only lint on `&Ty` and `&TyCtxt` if it is used outside of a trait.\n         Res::SelfTyAlias { alias_to: did, is_trait_impl: false, .. } => {\n-            if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n+            if let ty::Adt(adt, substs) = cx.tcx.type_of(did).subst_identity().kind() {\n                 if let Some(name @ (sym::Ty | sym::TyCtxt)) = cx.tcx.get_diagnostic_name(adt.did())\n                 {\n                     // NOTE: This path is currently unreachable as `Ty<'tcx>` is"}, {"sha": "94a43ab0c4674b11b510d2106a9cc2fcbb38c501", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::{\n };\n use rustc_hir::def_id::DefId;\n use rustc_macros::{LintDiagnostic, Subdiagnostic};\n-use rustc_middle::ty::{Predicate, Ty, TyCtxt};\n+use rustc_middle::ty::{PolyExistentialTraitRef, Predicate, Ty, TyCtxt};\n use rustc_session::parse::ParseSess;\n use rustc_span::{edition::Edition, sym, symbol::Ident, Span, Symbol};\n \n@@ -556,8 +556,7 @@ pub struct BuiltinUnexpectedCliConfigValue {\n #[diag(lint_supertrait_as_deref_target)]\n pub struct SupertraitAsDerefTarget<'a> {\n     pub t: Ty<'a>,\n-    pub target_principal: String,\n-    // pub target_principal: Binder<'a, ExistentialTraitRef<'b>>,\n+    pub target_principal: PolyExistentialTraitRef<'a>,\n     #[subdiagnostic]\n     pub label: Option<SupertraitAsDerefTargetLabel>,\n }"}, {"sha": "2bb2a3aab5527d51d70e179ded6c47c1c2025333", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -50,7 +50,7 @@ fn path_for_pass_by_value(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> Option<Stri\n                 return Some(format!(\"{}{}\", name, gen_args(cx, path_segment)));\n             }\n             Res::SelfTyAlias { alias_to: did, is_trait_impl: false, .. } => {\n-                if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n+                if let ty::Adt(adt, substs) = cx.tcx.type_of(did).subst_identity().kind() {\n                     if cx.tcx.has_attr(adt.did(), sym::rustc_pass_by_value) {\n                         return Some(cx.tcx.def_path_str_with_substs(adt.did(), substs));\n                     }"}, {"sha": "b7fd6a254d811300adf9e9eee64cf732d9653baf", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -651,7 +651,7 @@ pub fn transparent_newtype_field<'a, 'tcx>(\n ) -> Option<&'a ty::FieldDef> {\n     let param_env = tcx.param_env(variant.def_id);\n     variant.fields.iter().find(|field| {\n-        let field_ty = tcx.type_of(field.did);\n+        let field_ty = tcx.type_of(field.did).subst_identity();\n         let is_zst = tcx.layout_of(param_env.and(field_ty)).map_or(false, |layout| layout.is_zst());\n         !is_zst\n     })\n@@ -1240,7 +1240,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n \n     fn check_foreign_static(&mut self, id: hir::OwnerId, span: Span) {\n-        let ty = self.cx.tcx.type_of(id);\n+        let ty = self.cx.tcx.type_of(id).subst_identity();\n         self.check_type_for_ffi_and_report_errors(span, ty, true, false);\n     }\n \n@@ -1301,7 +1301,7 @@ declare_lint_pass!(VariantSizeDifferences => [VARIANT_SIZE_DIFFERENCES]);\n impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.kind {\n-            let t = cx.tcx.type_of(it.owner_id);\n+            let t = cx.tcx.type_of(it.owner_id).subst_identity();\n             let ty = cx.tcx.erase_regions(t);\n             let Ok(layout) = cx.layout_of(ty) else { return };\n             let Variants::Multiple {\n@@ -1421,7 +1421,7 @@ impl InvalidAtomicOrdering {\n             && recognized_names.contains(&method_path.ident.name)\n             && let Some(m_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id)\n             && let Some(impl_did) = cx.tcx.impl_of_method(m_def_id)\n-            && let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def()\n+            && let Some(adt) = cx.tcx.type_of(impl_did).subst_identity().ty_adt_def()\n             // skip extension traits, only lint functions from the standard library\n             && cx.tcx.trait_id_of_impl(impl_did).is_none()\n             && let parent = cx.tcx.parent(adt.did())"}, {"sha": "0a42265a6baafdaeed02d8d9c3e71ceb138964c1", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -594,6 +594,8 @@ struct LLVMRustSanitizerOptions {\n   bool SanitizeThread;\n   bool SanitizeHWAddress;\n   bool SanitizeHWAddressRecover;\n+  bool SanitizeKernelAddress;\n+  bool SanitizeKernelAddressRecover;\n };\n \n extern \"C\" LLVMRustResult\n@@ -765,15 +767,17 @@ LLVMRustOptimize(\n       );\n     }\n \n-    if (SanitizerOptions->SanitizeAddress) {\n+    if (SanitizerOptions->SanitizeAddress || SanitizerOptions->SanitizeKernelAddress) {\n       OptimizerLastEPCallbacks.push_back(\n         [SanitizerOptions](ModulePassManager &MPM, OptimizationLevel Level) {\n+          auto CompileKernel = SanitizerOptions->SanitizeKernelAddress;\n #if LLVM_VERSION_LT(15, 0)\n           MPM.addPass(RequireAnalysisPass<ASanGlobalsMetadataAnalysis, Module>());\n #endif\n           AddressSanitizerOptions opts = AddressSanitizerOptions{\n-            /*CompileKernel=*/false,\n-            SanitizerOptions->SanitizeAddressRecover,\n+            CompileKernel,\n+            SanitizerOptions->SanitizeAddressRecover\n+              || SanitizerOptions->SanitizeKernelAddressRecover,\n             /*UseAfterScope=*/true,\n             AsanDetectStackUseAfterReturnMode::Runtime,\n           };"}, {"sha": "d823989bb02b8c77b60a106d255eed727a51290b", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -499,9 +499,10 @@ impl<'tcx> Collector<'tcx> {\n         let argument_types: &List<Ty<'_>> = self.tcx.erase_late_bound_regions(\n             self.tcx\n                 .type_of(item.id.owner_id)\n+                .subst_identity()\n                 .fn_sig(self.tcx)\n                 .inputs()\n-                .map_bound(|slice| self.tcx.mk_type_list(slice.iter())),\n+                .map_bound(|slice| self.tcx.intern_type_list(slice)),\n         );\n \n         argument_types"}, {"sha": "0bacf51e9119a9daa449faeaf5a34146b7a591db", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -114,7 +114,7 @@ macro_rules! provide_one {\n         fn $name<'tcx>(\n             $tcx: TyCtxt<'tcx>,\n             def_id_arg: ty::query::query_keys::$name<'tcx>,\n-        ) -> ty::query::query_values::$name<'tcx> {\n+        ) -> ty::query::query_provided::$name<'tcx> {\n             let _prof_timer =\n                 $tcx.prof.generic_activity(concat!(\"metadata_decode_entry_\", stringify!($name)));\n "}, {"sha": "e941dd4568889b7ce7e7dbbe0eefc422707e4966", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1541,8 +1541,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 self.tables.impl_defaultness.set_some(def_id.index, *defaultness);\n                 self.tables.constness.set_some(def_id.index, *constness);\n \n-                let trait_ref = self.tcx.impl_trait_ref(def_id).map(ty::EarlyBinder::skip_binder);\n+                let trait_ref = self.tcx.impl_trait_ref(def_id);\n                 if let Some(trait_ref) = trait_ref {\n+                    let trait_ref = trait_ref.skip_binder();\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n                     if let Ok(mut an) = trait_def.ancestors(self.tcx, def_id) {\n                         if let Some(specialization_graph::Node::Impl(parent)) = an.nth(1) {"}, {"sha": "01691398ad089fcb91559af270f2bcfe0817d5ea", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -18,7 +18,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n-use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n+use rustc_middle::middle::resolve_bound_vars::ObjectLifetimeDefault;\n use rustc_middle::mir;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;\n@@ -369,7 +369,7 @@ define_tables! {\n     explicit_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     generics_of: Table<DefIndex, LazyValue<ty::Generics>>,\n     super_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n-    type_of: Table<DefIndex, LazyValue<Ty<'static>>>,\n+    type_of: Table<DefIndex, LazyValue<ty::EarlyBinder<Ty<'static>>>>,\n     variances_of: Table<DefIndex, LazyArray<ty::Variance>>,\n     fn_sig: Table<DefIndex, LazyValue<ty::EarlyBinder<ty::PolyFnSig<'static>>>>,\n     codegen_fn_attrs: Table<DefIndex, LazyValue<CodegenFnAttrs>>,"}, {"sha": "84510fe218cf5a4ba2171d28a55b9bfc29b35fcc", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -74,8 +74,8 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     type DepKind = DepKind;\n \n     #[inline]\n-    fn with_stable_hashing_context<R>(&self, f: impl FnOnce(StableHashingContext<'_>) -> R) -> R {\n-        TyCtxt::with_stable_hashing_context(*self, f)\n+    fn with_stable_hashing_context<R>(self, f: impl FnOnce(StableHashingContext<'_>) -> R) -> R {\n+        TyCtxt::with_stable_hashing_context(self, f)\n     }\n \n     #[inline]"}, {"sha": "2eafc356dc3fa75ecf0055aa620ed392bd10d3b8", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1062,7 +1062,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn span_if_local(self, id: DefId) -> Option<Span> {\n-        if id.is_local() { Some(self.tcx.def_span(id)) } else { None }\n+        id.is_local().then(|| self.tcx.def_span(id))\n     }\n \n     pub fn res_span(self, res: Res) -> Option<Span> {"}, {"sha": "dc89f762b764e4077aba272a2975d26d9e9de508", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -104,7 +104,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.impl_trait_ref(def_id)\n             .map(|t| t.subst_identity())\n             .map(ImplSubject::Trait)\n-            .unwrap_or_else(|| ImplSubject::Inherent(self.type_of(def_id)))\n+            .unwrap_or_else(|| ImplSubject::Inherent(self.type_of(def_id).subst_identity()))\n     }\n }\n "}, {"sha": "bb617e692cceaadc3c7395167c154a1f2245e449", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -353,7 +353,7 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                                 var: ty::BoundVar::from_usize(i),\n                                 kind: ty::BrAnon(i as u32, None),\n                             };\n-                            tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n+                            tcx.mk_re_late_bound(ty::INNERMOST, br).into()\n                         }\n                         CanonicalVarKind::Const(_, ty)\n                         | CanonicalVarKind::PlaceholderConst(_, ty) => tcx"}, {"sha": "c4601a1fb4189423219953d201a8ffa0a6058016", "filename": "compiler/rustc_middle/src/middle/codegen_fn_attrs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -91,7 +91,8 @@ bitflags! {\n         /// the MIR `InstrumentCoverage` pass and not added to the coverage map\n         /// during codegen.\n         const NO_COVERAGE               = 1 << 15;\n-        /// `#[used(linker)]`: indicates that LLVM nor the linker can eliminate this function.\n+        /// `#[used(linker)]`:\n+        /// indicates that neither LLVM nor the linker will eliminate this function.\n         const USED_LINKER               = 1 << 16;\n         /// `#[rustc_deallocator]`: a hint to LLVM that the function only deallocates memory.\n         const DEALLOCATOR               = 1 << 17;"}, {"sha": "0b6774f1b1fe1d0582314b50fa764028cb2a3467", "filename": "compiler/rustc_middle/src/middle/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -29,7 +29,7 @@ pub mod lib_features {\n pub mod limits;\n pub mod privacy;\n pub mod region;\n-pub mod resolve_lifetime;\n+pub mod resolve_bound_vars;\n pub mod stability;\n \n pub fn provide(providers: &mut crate::ty::query::Providers) {"}, {"sha": "c59704fc0238f4afacff8107306c6d59b08544e5", "filename": "compiler/rustc_middle/src/middle/resolve_bound_vars.rs", "status": "renamed", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1,18 +1,20 @@\n-//! Name resolution for lifetimes: type declarations.\n+//! Name resolution for lifetimes and late-bound type and const variables: type declarations.\n \n use crate::ty;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{ItemLocalId, OwnerId};\n use rustc_macros::HashStable;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n-pub enum Region {\n-    Static,\n-    EarlyBound(/* lifetime decl */ DefId),\n-    LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* lifetime decl */ DefId),\n+pub enum ResolvedArg {\n+    StaticLifetime,\n+    EarlyBound(/* decl */ DefId),\n+    LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* decl */ DefId),\n     Free(DefId, /* lifetime decl */ DefId),\n+    Error(ErrorGuaranteed),\n }\n \n /// A set containing, at most, one known element.\n@@ -46,10 +48,10 @@ pub enum ObjectLifetimeDefault {\n /// Maps the id of each lifetime reference to the lifetime decl\n /// that it corresponds to.\n #[derive(Default, HashStable, Debug)]\n-pub struct ResolveLifetimes {\n+pub struct ResolveBoundVars {\n     /// Maps from every use of a named (not anonymous) lifetime to a\n     /// `Region` describing how that region is bound\n-    pub defs: FxHashMap<OwnerId, FxHashMap<ItemLocalId, Region>>,\n+    pub defs: FxHashMap<OwnerId, FxHashMap<ItemLocalId, ResolvedArg>>,\n \n     pub late_bound_vars: FxHashMap<OwnerId, FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>>,\n }", "previous_filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs"}, {"sha": "46184cddd51f504c07528489a442287dd5f045ac", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -414,7 +414,7 @@ impl<'tcx> Body<'tcx> {\n         (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n             let decl = &self.local_decls[local];\n-            (decl.is_user_variable() && decl.mutability.is_mut()).then(|| local)\n+            (decl.is_user_variable() && decl.mutability.is_mut()).then_some(local)\n         })\n     }\n \n@@ -2497,7 +2497,7 @@ impl<'tcx> ConstantKind<'tcx> {\n         };\n         debug!(\"expr.kind: {:?}\", expr.kind);\n \n-        let ty = tcx.type_of(def.def_id_for_type_of());\n+        let ty = tcx.type_of(def.def_id_for_type_of()).subst_identity();\n         debug!(?ty);\n \n         // FIXME(const_generics): We currently have to special case parameters because `min_const_generics`\n@@ -2525,14 +2525,12 @@ impl<'tcx> ConstantKind<'tcx> {\n         }\n \n         let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n-        let parent_substs = if let Some(parent_hir_id) = tcx.hir().opt_parent_id(hir_id) {\n-            if let Some(parent_did) = parent_hir_id.as_owner() {\n-                InternalSubsts::identity_for_item(tcx, parent_did.to_def_id())\n-            } else {\n-                tcx.mk_substs(Vec::<GenericArg<'tcx>>::new().into_iter())\n-            }\n+        let parent_substs = if let Some(parent_hir_id) = tcx.hir().opt_parent_id(hir_id)\n+            && let Some(parent_did) = parent_hir_id.as_owner()\n+        {\n+            InternalSubsts::identity_for_item(tcx, parent_did.to_def_id())\n         } else {\n-            tcx.mk_substs(Vec::<GenericArg<'tcx>>::new().into_iter())\n+            tcx.intern_substs(&[])\n         };\n         debug!(?parent_substs);\n "}, {"sha": "aa9f170477bcb27e8b6a504cbc8fd45fa7720054", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -165,7 +165,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 tcx.mk_array_with_const_len(operand.ty(local_decls, tcx), count)\n             }\n             Rvalue::ThreadLocalRef(did) => {\n-                let static_ty = tcx.type_of(did);\n+                let static_ty = tcx.type_of(did).subst_identity();\n                 if tcx.is_mutable_static(did) {\n                     tcx.mk_mut_ptr(static_ty)\n                 } else if tcx.is_foreign_item(did) {\n@@ -202,9 +202,7 @@ impl<'tcx> Rvalue<'tcx> {\n             Rvalue::Aggregate(ref ak, ref ops) => match **ak {\n                 AggregateKind::Array(ty) => tcx.mk_array(ty, ops.len() as u64),\n                 AggregateKind::Tuple => tcx.mk_tup(ops.iter().map(|op| op.ty(local_decls, tcx))),\n-                AggregateKind::Adt(did, _, substs, _, _) => {\n-                    tcx.bound_type_of(did).subst(tcx, substs)\n-                }\n+                AggregateKind::Adt(did, _, substs, _, _) => tcx.type_of(did).subst(tcx, substs),\n                 AggregateKind::Closure(did, substs) => tcx.mk_closure(did, substs),\n                 AggregateKind::Generator(did, substs, movability) => {\n                     tcx.mk_generator(did, substs, movability)"}, {"sha": "443c1b2d261ef4af9df067145bf556955ea2536d", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -323,7 +323,7 @@ macro_rules! make_mir_visitor {\n                     self.visit_source_scope($(& $mutability)? *parent_scope);\n                 }\n                 if let Some((callee, callsite_span)) = inlined {\n-                    let location = START_BLOCK.start_location();\n+                    let location = Location::START;\n \n                     self.visit_span($(& $mutability)? *callsite_span);\n \n@@ -837,7 +837,7 @@ macro_rules! make_mir_visitor {\n                 } = var_debug_info;\n \n                 self.visit_source_info(source_info);\n-                let location = START_BLOCK.start_location();\n+                let location = Location::START;\n                 match value {\n                     VarDebugInfoContents::Const(c) => self.visit_constant(c, location),\n                     VarDebugInfoContents::Place(place) =>\n@@ -1026,7 +1026,7 @@ macro_rules! super_body {\n         $self.visit_span($(& $mutability)? $body.span);\n \n         for const_ in &$($mutability)? $body.required_consts {\n-            let location = START_BLOCK.start_location();\n+            let location = Location::START;\n             $self.visit_constant(const_, location);\n         }\n     }"}, {"sha": "cf4d9b4b005790191a57c8c98ae2a9acff9fdbbc", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -152,7 +152,7 @@ rustc_queries! {\n     /// to an alias, it will \"skip\" this alias to return the aliased type.\n     ///\n     /// [`DefId`]: rustc_hir::def_id::DefId\n-    query type_of(key: DefId) -> Ty<'tcx> {\n+    query type_of(key: DefId) -> ty::EarlyBinder<Ty<'tcx>> {\n         desc { |tcx|\n             \"{action} `{path}`\",\n             action = {\n@@ -729,15 +729,14 @@ rustc_queries! {\n     }\n \n     /// Maps from a trait item to the trait item \"descriptor\".\n-    query associated_item(key: DefId) -> &'tcx ty::AssocItem {\n+    query associated_item(key: DefId) -> ty::AssocItem {\n         desc { |tcx| \"computing associated item data for `{}`\", tcx.def_path_str(key) }\n-        arena_cache\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n \n     /// Collects the associated items defined on a trait or impl.\n-    query associated_items(key: DefId) -> &'tcx ty::AssocItems<'tcx> {\n+    query associated_items(key: DefId) -> &'tcx ty::AssocItems {\n         arena_cache\n         desc { |tcx| \"collecting associated items of `{}`\", tcx.def_path_str(key) }\n     }\n@@ -781,7 +780,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query issue33140_self_ty(key: DefId) -> Option<ty::Ty<'tcx>> {\n+    query issue33140_self_ty(key: DefId) -> Option<ty::EarlyBinder<ty::Ty<'tcx>>> {\n         desc { |tcx| \"computing Self type wrt issue #33140 `{}`\", tcx.def_path_str(key) }\n     }\n \n@@ -1641,12 +1640,12 @@ rustc_queries! {\n     /// Does lifetime resolution on items. Importantly, we can't resolve\n     /// lifetimes directly on things like trait methods, because of trait params.\n     /// See `rustc_resolve::late::lifetimes for details.\n-    query resolve_lifetimes(_: hir::OwnerId) -> &'tcx ResolveLifetimes {\n+    query resolve_bound_vars(_: hir::OwnerId) -> &'tcx ResolveBoundVars {\n         arena_cache\n         desc { \"resolving lifetimes\" }\n     }\n-    query named_region_map(_: hir::OwnerId) ->\n-        Option<&'tcx FxHashMap<ItemLocalId, Region>> {\n+    query named_variable_map(_: hir::OwnerId) ->\n+        Option<&'tcx FxHashMap<ItemLocalId, ResolvedArg>> {\n         desc { \"looking up a named region\" }\n     }\n     query is_late_bound_map(_: hir::OwnerId) -> Option<&'tcx FxIndexSet<ItemLocalId>> {"}, {"sha": "6231dd9b6f54a245e2b21f99805a23f0f806f204", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -474,7 +474,11 @@ pub enum WellFormedLoc {\n #[derive(TypeVisitable, TypeFoldable)]\n pub struct ImplDerivedObligationCause<'tcx> {\n     pub derived: DerivedObligationCause<'tcx>,\n-    pub impl_def_id: DefId,\n+    /// The `DefId` of the `impl` that gave rise to the `derived` obligation.\n+    /// If the `derived` obligation arose from a trait alias, which conceptually has a synthetic impl,\n+    /// then this will be the `DefId` of that trait alias. Care should therefore be taken to handle\n+    /// that exceptional case where appropriate.\n+    pub impl_or_alias_def_id: DefId,\n     /// The index of the derived predicate in the parent impl's predicates.\n     pub impl_def_predicate_index: Option<usize>,\n     pub span: Span,"}, {"sha": "4019cf8ceee646f79e7d0f528946c7aa900e0b8b", "filename": "compiler/rustc_middle/src/traits/specialization_graph.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -133,11 +133,7 @@ impl Node {\n     ///\n     /// If this returns `None`, the item can potentially still be found in\n     /// parents of this node.\n-    pub fn item<'tcx>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_item_def_id: DefId,\n-    ) -> Option<&'tcx ty::AssocItem> {\n+    pub fn item<'tcx>(&self, tcx: TyCtxt<'tcx>, trait_item_def_id: DefId) -> Option<ty::AssocItem> {\n         match *self {\n             Node::Trait(_) => Some(tcx.associated_item(trait_item_def_id)),\n             Node::Impl(impl_def_id) => {\n@@ -239,7 +235,7 @@ impl<'tcx> Ancestors<'tcx> {\n                     }\n                 }\n \n-                Some(LeafDef { item: *item, defining_node: node, finalizing_node })\n+                Some(LeafDef { item, defining_node: node, finalizing_node })\n             } else {\n                 // Item not mentioned. This \"finalizes\" any defaulted item provided by an ancestor.\n                 finalizing_node = Some(node);\n@@ -263,7 +259,7 @@ pub fn ancestors(\n \n     if let Some(reported) = specialization_graph.has_errored {\n         Err(reported)\n-    } else if let Err(reported) = tcx.type_of(start_from_impl).error_reported() {\n+    } else if let Err(reported) = tcx.type_of(start_from_impl).subst_identity().error_reported() {\n         Err(reported)\n     } else {\n         Ok(Ancestors {"}, {"sha": "f1a9e50a4f05fc98e11171ed82dc2e52c3c798d3", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -83,7 +83,7 @@ impl AssocItem {\n             }\n             ty::AssocKind::Type => format!(\"type {};\", self.name),\n             ty::AssocKind::Const => {\n-                format!(\"const {}: {:?};\", self.name, tcx.type_of(self.def_id))\n+                format!(\"const {}: {:?};\", self.name, tcx.type_of(self.def_id).subst_identity())\n             }\n         }\n     }\n@@ -129,13 +129,13 @@ impl std::fmt::Display for AssocKind {\n /// it is relatively expensive. Instead, items are indexed by `Symbol` and hygienic comparison is\n /// done only on items with the same name.\n #[derive(Debug, Clone, PartialEq, HashStable)]\n-pub struct AssocItems<'tcx> {\n-    items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n+pub struct AssocItems {\n+    items: SortedIndexMultiMap<u32, Symbol, ty::AssocItem>,\n }\n \n-impl<'tcx> AssocItems<'tcx> {\n+impl AssocItems {\n     /// Constructs an `AssociatedItems` map from a series of `ty::AssocItem`s in definition order.\n-    pub fn new(items_in_def_order: impl IntoIterator<Item = &'tcx ty::AssocItem>) -> Self {\n+    pub fn new(items_in_def_order: impl IntoIterator<Item = ty::AssocItem>) -> Self {\n         let items = items_in_def_order.into_iter().map(|item| (item.name, item)).collect();\n         AssocItems { items }\n     }\n@@ -145,7 +145,7 @@ impl<'tcx> AssocItems<'tcx> {\n     /// New code should avoid relying on definition order. If you need a particular associated item\n     /// for a known trait, make that trait a lang item instead of indexing this array.\n     pub fn in_definition_order(&self) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n-        self.items.iter().map(|(_, v)| *v)\n+        self.items.iter().map(|(_, v)| v)\n     }\n \n     pub fn len(&self) -> usize {\n@@ -157,7 +157,7 @@ impl<'tcx> AssocItems<'tcx> {\n         &self,\n         name: Symbol,\n     ) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n-        self.items.get_by_key(name).copied()\n+        self.items.get_by_key(name)\n     }\n \n     /// Returns the associated item with the given name and `AssocKind`, if one exists."}, {"sha": "884ae7f5da2841260cf931f7886f5e384c06a139", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1,7 +1,9 @@\n+use crate::middle::resolve_bound_vars as rbv;\n use crate::mir::interpret::LitToConstInput;\n use crate::ty::{self, DefIdTree, InternalSubsts, ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_macros::HashStable;\n use std::fmt;\n@@ -71,7 +73,10 @@ impl<'tcx> Const<'tcx> {\n         let expr = &tcx.hir().body(body_id).value;\n         debug!(?expr);\n \n-        let ty = tcx.type_of(def.def_id_for_type_of());\n+        let ty = tcx\n+            .type_of(def.def_id_for_type_of())\n+            .no_bound_vars()\n+            .expect(\"const parameter types cannot be generic\");\n \n         match Self::try_eval_lit_or_param(tcx, ty, expr) {\n             Some(v) => v,\n@@ -125,16 +130,30 @@ impl<'tcx> Const<'tcx> {\n             }\n         }\n \n-        use hir::{def::DefKind::ConstParam, def::Res, ExprKind, Path, QPath};\n         match expr.kind {\n-            ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n-                // Find the name and index of the const parameter by indexing the generics of\n-                // the parent item and construct a `ParamConst`.\n-                let item_def_id = tcx.parent(def_id);\n-                let generics = tcx.generics_of(item_def_id);\n-                let index = generics.param_def_id_to_index[&def_id];\n-                let name = tcx.item_name(def_id);\n-                Some(tcx.mk_const(ty::ParamConst::new(index, name), ty))\n+            hir::ExprKind::Path(hir::QPath::Resolved(\n+                _,\n+                &hir::Path { res: Res::Def(DefKind::ConstParam, def_id), .. },\n+            )) => {\n+                match tcx.named_bound_var(expr.hir_id) {\n+                    Some(rbv::ResolvedArg::EarlyBound(_)) => {\n+                        // Find the name and index of the const parameter by indexing the generics of\n+                        // the parent item and construct a `ParamConst`.\n+                        let item_def_id = tcx.parent(def_id);\n+                        let generics = tcx.generics_of(item_def_id);\n+                        let index = generics.param_def_id_to_index[&def_id];\n+                        let name = tcx.item_name(def_id);\n+                        Some(tcx.mk_const(ty::ParamConst::new(index, name), ty))\n+                    }\n+                    Some(rbv::ResolvedArg::LateBound(debruijn, index, _)) => Some(tcx.mk_const(\n+                        ty::ConstKind::Bound(debruijn, ty::BoundVar::from_u32(index)),\n+                        ty,\n+                    )),\n+                    Some(rbv::ResolvedArg::Error(guar)) => {\n+                        Some(tcx.const_error_with_guaranteed(ty, guar))\n+                    }\n+                    arg => bug!(\"unexpected bound var resolution for {:?}: {arg:?}\", expr.hir_id),\n+                }\n             }\n             _ => None,\n         }"}, {"sha": "e2f32cdca3ca3c90088d5a16343ef3911ffb1c47", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 207, "deletions": 96, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -9,7 +9,7 @@ use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::struct_lint_level;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n-use crate::middle::resolve_lifetime;\n+use crate::middle::resolve_bound_vars;\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstAllocation};\n use crate::mir::{\n@@ -67,7 +67,7 @@ use rustc_target::abi::{Layout, LayoutS, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n use rustc_type_ir::sty::TyKind::*;\n use rustc_type_ir::WithCachedTypeInfo;\n-use rustc_type_ir::{DynKind, InternAs, InternIteratorElement, Interner, TypeFlags};\n+use rustc_type_ir::{CollectAndApply, DynKind, Interner, TypeFlags};\n \n use std::any::Any;\n use std::borrow::Borrow;\n@@ -243,11 +243,20 @@ impl<'tcx> CtxtInterners<'tcx> {\n     }\n }\n \n+// For these preinterned values, an alternative would be to have\n+// variable-length vectors that grow as needed. But that turned out to be\n+// slightly more complex and no faster.\n+\n const NUM_PREINTERNED_TY_VARS: u32 = 100;\n const NUM_PREINTERNED_FRESH_TYS: u32 = 20;\n const NUM_PREINTERNED_FRESH_INT_TYS: u32 = 3;\n const NUM_PREINTERNED_FRESH_FLOAT_TYS: u32 = 3;\n \n+// This number may seem high, but it is reached in all but the smallest crates.\n+const NUM_PREINTERNED_RE_VARS: u32 = 500;\n+const NUM_PREINTERNED_RE_LATE_BOUNDS_I: u32 = 2;\n+const NUM_PREINTERNED_RE_LATE_BOUNDS_V: u32 = 20;\n+\n pub struct CommonTypes<'tcx> {\n     pub unit: Ty<'tcx>,\n     pub bool: Ty<'tcx>,\n@@ -295,6 +304,14 @@ pub struct CommonLifetimes<'tcx> {\n \n     /// Erased region, used outside of type inference.\n     pub re_erased: Region<'tcx>,\n+\n+    /// Pre-interned `ReVar(ty::RegionVar(n))` for small values of `n`.\n+    pub re_vars: Vec<Region<'tcx>>,\n+\n+    /// Pre-interned values of the form:\n+    /// `ReLateBound(DebruijnIndex(i), BoundRegion { var: v, kind: BrAnon(v, None) })\n+    /// for small values of `i` and `v`.\n+    pub re_late_bounds: Vec<Vec<Region<'tcx>>>,\n }\n \n pub struct CommonConsts<'tcx> {\n@@ -358,7 +375,31 @@ impl<'tcx> CommonLifetimes<'tcx> {\n             ))\n         };\n \n-        CommonLifetimes { re_static: mk(ty::ReStatic), re_erased: mk(ty::ReErased) }\n+        let re_vars =\n+            (0..NUM_PREINTERNED_RE_VARS).map(|n| mk(ty::ReVar(ty::RegionVid::from(n)))).collect();\n+\n+        let re_late_bounds = (0..NUM_PREINTERNED_RE_LATE_BOUNDS_I)\n+            .map(|i| {\n+                (0..NUM_PREINTERNED_RE_LATE_BOUNDS_V)\n+                    .map(|v| {\n+                        mk(ty::ReLateBound(\n+                            ty::DebruijnIndex::from(i),\n+                            ty::BoundRegion {\n+                                var: ty::BoundVar::from(v),\n+                                kind: ty::BrAnon(v, None),\n+                            },\n+                        ))\n+                    })\n+                    .collect()\n+            })\n+            .collect();\n+\n+        CommonLifetimes {\n+            re_static: mk(ty::ReStatic),\n+            re_erased: mk(ty::ReErased),\n+            re_vars,\n+            re_late_bounds,\n+        }\n     }\n }\n \n@@ -479,7 +520,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n \n     pub queries: &'tcx dyn query::QueryEngine<'tcx>,\n-    pub query_caches: query::QueryCaches<'tcx>,\n+    pub query_system: query::QuerySystem<'tcx>,\n     pub(crate) query_kinds: &'tcx [DepKindStruct<'tcx>],\n \n     // Internal caches for metadata decoding. No need to track deps on this.\n@@ -664,7 +705,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             untracked,\n             on_disk_cache,\n             queries,\n-            query_caches: query::QueryCaches::default(),\n+            query_system: Default::default(),\n             query_kinds,\n             ty_rcache: Default::default(),\n             pred_rcache: Default::default(),\n@@ -697,15 +738,15 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Constructs a `RegionKind::ReError` lifetime.\n     #[track_caller]\n-    pub fn re_error(self, reported: ErrorGuaranteed) -> Region<'tcx> {\n-        self.mk_region(ty::ReError(reported))\n+    pub fn mk_re_error(self, reported: ErrorGuaranteed) -> Region<'tcx> {\n+        self.intern_region(ty::ReError(reported))\n     }\n \n     /// Constructs a `RegionKind::ReError` lifetime and registers a `delay_span_bug` to ensure it\n     /// gets used.\n     #[track_caller]\n-    pub fn re_error_misc(self) -> Region<'tcx> {\n-        self.re_error_with_message(\n+    pub fn mk_re_error_misc(self) -> Region<'tcx> {\n+        self.mk_re_error_with_message(\n             DUMMY_SP,\n             \"RegionKind::ReError constructed but no error reported\",\n         )\n@@ -714,9 +755,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Constructs a `RegionKind::ReError` lifetime and registers a `delay_span_bug` with the given\n     /// `msg` to ensure it gets used.\n     #[track_caller]\n-    pub fn re_error_with_message<S: Into<MultiSpan>>(self, span: S, msg: &str) -> Region<'tcx> {\n+    pub fn mk_re_error_with_message<S: Into<MultiSpan>>(self, span: S, msg: &str) -> Region<'tcx> {\n         let reported = self.sess.delay_span_bug(span, msg);\n-        self.re_error(reported)\n+        self.mk_re_error(reported)\n     }\n \n     /// Like [TyCtxt::ty_error] but for constants, with current `ErrorGuaranteed`\n@@ -1108,18 +1149,16 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => return None,\n         }\n \n-        let ret_ty = self.type_of(scope_def_id);\n+        let ret_ty = self.type_of(scope_def_id).subst_identity();\n         match ret_ty.kind() {\n             ty::FnDef(_, _) => {\n                 let sig = ret_ty.fn_sig(self);\n                 let output = self.erase_late_bound_regions(sig.output());\n-                if output.is_impl_trait() {\n+                output.is_impl_trait().then(|| {\n                     let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n                     let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n-                    Some((output, fn_decl.output.span()))\n-                } else {\n-                    None\n-                }\n+                    (output, fn_decl.output.span())\n+                })\n             }\n             _ => None,\n         }\n@@ -1150,8 +1189,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn caller_location_ty(self) -> Ty<'tcx> {\n         self.mk_imm_ref(\n             self.lifetimes.re_static,\n-            self.bound_type_of(self.require_lang_item(LangItem::PanicLocation, None))\n-                .subst(self, self.mk_substs([self.lifetimes.re_static.into()].iter())),\n+            self.type_of(self.require_lang_item(LangItem::PanicLocation, None))\n+                .subst(self, self.intern_substs(&[self.lifetimes.re_static.into()])),\n         )\n     }\n \n@@ -1225,13 +1264,12 @@ macro_rules! nop_lift {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n             type Lifted = $lifted;\n             fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-                if tcx.interners.$set.contains_pointer_to(&InternedInSet(&*self.0.0)) {\n+                tcx.interners\n+                    .$set\n+                    .contains_pointer_to(&InternedInSet(&*self.0.0))\n                     // SAFETY: `self` is interned and therefore valid\n                     // for the entire lifetime of the `TyCtxt`.\n-                    Some(unsafe { mem::transmute(self) })\n-                } else {\n-                    None\n-                }\n+                    .then(|| unsafe { mem::transmute(self) })\n             }\n         }\n     };\n@@ -1246,13 +1284,13 @@ impl<'a, 'tcx> Lift<'tcx> for &'a List<Ty<'a>> {\n         if self.is_empty() {\n             return Some(List::empty());\n         }\n-        if tcx.interners.substs.contains_pointer_to(&InternedInSet(self.as_substs())) {\n+\n+        tcx.interners\n+            .substs\n+            .contains_pointer_to(&InternedInSet(self.as_substs()))\n             // SAFETY: `self` is interned and therefore valid\n             // for the entire lifetime of the `TyCtxt`.\n-            Some(unsafe { mem::transmute::<&'a List<Ty<'a>>, &'tcx List<Ty<'tcx>>>(self) })\n-        } else {\n-            None\n-        }\n+            .then(|| unsafe { mem::transmute::<&'a List<Ty<'a>>, &'tcx List<Ty<'tcx>>>(self) })\n     }\n }\n \n@@ -1264,11 +1302,10 @@ macro_rules! nop_list_lift {\n                 if self.is_empty() {\n                     return Some(List::empty());\n                 }\n-                if tcx.interners.$set.contains_pointer_to(&InternedInSet(self)) {\n-                    Some(unsafe { mem::transmute(self) })\n-                } else {\n-                    None\n-                }\n+                tcx.interners\n+                    .$set\n+                    .contains_pointer_to(&InternedInSet(self))\n+                    .then(|| unsafe { mem::transmute(self) })\n             }\n         }\n     };\n@@ -1517,7 +1554,7 @@ macro_rules! direct_interners {\n }\n \n direct_interners! {\n-    region: mk_region(RegionKind<'tcx>): Region -> Region<'tcx>,\n+    region: intern_region(RegionKind<'tcx>): Region -> Region<'tcx>,\n     const_: mk_const_internal(ConstData<'tcx>): Const -> Const<'tcx>,\n     const_allocation: intern_const_alloc(Allocation): ConstAllocation -> ConstAllocation<'tcx>,\n     layout: intern_layout(LayoutS): Layout -> Layout<'tcx>,\n@@ -1623,21 +1660,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         unsafety: hir::Unsafety,\n     ) -> PolyFnSig<'tcx> {\n         sig.map_bound(|s| {\n-            let params_iter = match s.inputs()[0].kind() {\n-                ty::Tuple(params) => params.into_iter(),\n+            let params = match s.inputs()[0].kind() {\n+                ty::Tuple(params) => *params,\n                 _ => bug!(),\n             };\n-            self.mk_fn_sig(params_iter, s.output(), s.c_variadic, unsafety, abi::Abi::Rust)\n+            self.mk_fn_sig(params, s.output(), s.c_variadic, unsafety, abi::Abi::Rust)\n         })\n     }\n \n-    /// Same a `self.mk_region(kind)`, but avoids accessing the interners if\n-    /// `*r == kind`.\n-    #[inline]\n-    pub fn reuse_or_mk_region(self, r: Region<'tcx>, kind: RegionKind<'tcx>) -> Region<'tcx> {\n-        if *r == kind { r } else { self.mk_region(kind) }\n-    }\n-\n     // Avoid this in favour of more specific `mk_*` methods, where possible.\n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline]\n@@ -1724,7 +1754,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         ty_param.into()\n                     } else {\n                         assert!(has_default);\n-                        self.bound_type_of(param.def_id).subst(self, substs).into()\n+                        self.type_of(param.def_id).subst(self, substs).into()\n                     }\n                 }\n             });\n@@ -1805,8 +1835,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         if ts.is_empty() { self.types.unit } else { self.mk_ty(Tuple(self.intern_type_list(&ts))) }\n     }\n \n-    pub fn mk_tup<I: InternAs<Ty<'tcx>, Ty<'tcx>>>(self, iter: I) -> I::Output {\n-        iter.intern_with(|ts| self.intern_tup(ts))\n+    pub fn mk_tup<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<Ty<'tcx>, Ty<'tcx>>,\n+    {\n+        T::collect_and_apply(iter, |ts| self.intern_tup(ts))\n     }\n \n     #[inline]\n@@ -1966,13 +2000,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> GenericArg<'tcx> {\n         match param.kind {\n             GenericParamDefKind::Lifetime => {\n-                self.mk_region(ty::ReEarlyBound(param.to_early_bound_region_data())).into()\n+                self.mk_re_early_bound(param.to_early_bound_region_data()).into()\n             }\n             GenericParamDefKind::Type { .. } => self.mk_ty_param(param.index, param.name).into(),\n             GenericParamDefKind::Const { .. } => self\n                 .mk_const(\n                     ParamConst { index: param.index, name: param.name },\n-                    self.type_of(param.def_id),\n+                    self.type_of(param.def_id)\n+                        .no_bound_vars()\n+                        .expect(\"const parameter types cannot be generic\"),\n                 )\n                 .into(),\n         }\n@@ -1998,6 +2034,66 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_alias(ty::Opaque, self.mk_alias_ty(def_id, substs))\n     }\n \n+    #[inline]\n+    pub fn mk_re_early_bound(self, early_bound_region: ty::EarlyBoundRegion) -> Region<'tcx> {\n+        self.intern_region(ty::ReEarlyBound(early_bound_region))\n+    }\n+\n+    #[inline]\n+    pub fn mk_re_late_bound(\n+        self,\n+        debruijn: ty::DebruijnIndex,\n+        bound_region: ty::BoundRegion,\n+    ) -> Region<'tcx> {\n+        // Use a pre-interned one when possible.\n+        if let ty::BoundRegion { var, kind: ty::BrAnon(v, None) } = bound_region\n+            && var.as_u32() == v\n+            && let Some(inner) = self.lifetimes.re_late_bounds.get(debruijn.as_usize())\n+            && let Some(re) = inner.get(v as usize).copied()\n+        {\n+            re\n+        } else {\n+            self.intern_region(ty::ReLateBound(debruijn, bound_region))\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn mk_re_free(self, scope: DefId, bound_region: ty::BoundRegionKind) -> Region<'tcx> {\n+        self.intern_region(ty::ReFree(ty::FreeRegion { scope, bound_region }))\n+    }\n+\n+    #[inline]\n+    pub fn mk_re_var(self, v: ty::RegionVid) -> Region<'tcx> {\n+        // Use a pre-interned one when possible.\n+        self.lifetimes\n+            .re_vars\n+            .get(v.as_usize())\n+            .copied()\n+            .unwrap_or_else(|| self.intern_region(ty::ReVar(v)))\n+    }\n+\n+    #[inline]\n+    pub fn mk_re_placeholder(self, placeholder: ty::PlaceholderRegion) -> Region<'tcx> {\n+        self.intern_region(ty::RePlaceholder(placeholder))\n+    }\n+\n+    // Avoid this in favour of more specific `mk_re_*` methods, where possible,\n+    // to avoid the cost of the `match`.\n+    pub fn mk_region(self, kind: ty::RegionKind<'tcx>) -> Region<'tcx> {\n+        match kind {\n+            ty::ReEarlyBound(region) => self.mk_re_early_bound(region),\n+            ty::ReLateBound(debruijn, region) => self.mk_re_late_bound(debruijn, region),\n+            ty::ReFree(ty::FreeRegion { scope, bound_region }) => {\n+                self.mk_re_free(scope, bound_region)\n+            }\n+            ty::ReStatic => self.lifetimes.re_static,\n+            ty::ReVar(vid) => self.mk_re_var(vid),\n+            ty::RePlaceholder(region) => self.mk_re_placeholder(region),\n+            ty::ReErased => self.lifetimes.re_erased,\n+            ty::ReError(reported) => self.mk_re_error(reported),\n+        }\n+    }\n+\n     pub fn mk_place_field(self, place: Place<'tcx>, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n         self.mk_place_elem(place, PlaceElem::Field(f, ty))\n     }\n@@ -2065,11 +2161,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn mk_const_list<I: InternAs<ty::Const<'tcx>, &'tcx List<ty::Const<'tcx>>>>(\n-        self,\n-        iter: I,\n-    ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_const_list(xs))\n+    pub fn mk_const_list<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<ty::Const<'tcx>, &'tcx List<ty::Const<'tcx>>>,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_const_list(xs))\n     }\n \n     pub fn intern_const_list(self, cs: &[ty::Const<'tcx>]) -> &'tcx List<ty::Const<'tcx>> {\n@@ -2118,57 +2215,72 @@ impl<'tcx> TyCtxt<'tcx> {\n         if ts.is_empty() { List::empty() } else { self._intern_bound_variable_kinds(ts) }\n     }\n \n-    pub fn mk_fn_sig<I>(\n+    // Unlike various other `mk_*` functions, this one uses `I: IntoIterator`\n+    // instead of `I: Iterator`. Unlike those other functions, this one doesn't\n+    // have a `intern_fn_sig` variant that can be used for cases where `I` is\n+    // something like a `Vec`. That's because of the need to combine `inputs`\n+    // and `output`.\n+    pub fn mk_fn_sig<I, T>(\n         self,\n         inputs: I,\n         output: I::Item,\n         c_variadic: bool,\n         unsafety: hir::Unsafety,\n         abi: abi::Abi,\n-    ) -> <I::Item as InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>>::Output\n+    ) -> T::Output\n     where\n-        I: Iterator<Item: InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>>,\n+        I: IntoIterator<Item = T>,\n+        T: CollectAndApply<Ty<'tcx>, ty::FnSig<'tcx>>,\n     {\n-        inputs.chain(iter::once(output)).intern_with(|xs| ty::FnSig {\n+        T::collect_and_apply(inputs.into_iter().chain(iter::once(output)), |xs| ty::FnSig {\n             inputs_and_output: self.intern_type_list(xs),\n             c_variadic,\n             unsafety,\n             abi,\n         })\n     }\n \n-    pub fn mk_poly_existential_predicates<\n-        I: InternAs<PolyExistentialPredicate<'tcx>, &'tcx List<PolyExistentialPredicate<'tcx>>>,\n-    >(\n-        self,\n-        iter: I,\n-    ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_poly_existential_predicates(xs))\n+    pub fn mk_poly_existential_predicates<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<\n+                PolyExistentialPredicate<'tcx>,\n+                &'tcx List<PolyExistentialPredicate<'tcx>>,\n+            >,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_poly_existential_predicates(xs))\n     }\n \n-    pub fn mk_predicates<I: InternAs<Predicate<'tcx>, &'tcx List<Predicate<'tcx>>>>(\n-        self,\n-        iter: I,\n-    ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_predicates(xs))\n+    pub fn mk_predicates<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<Predicate<'tcx>, &'tcx List<Predicate<'tcx>>>,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_predicates(xs))\n     }\n \n-    pub fn mk_type_list<I: InternAs<Ty<'tcx>, &'tcx List<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n-        iter.intern_with(|xs| self.intern_type_list(xs))\n+    pub fn mk_type_list<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<Ty<'tcx>, &'tcx List<Ty<'tcx>>>,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_type_list(xs))\n     }\n \n-    pub fn mk_substs<I: InternAs<GenericArg<'tcx>, &'tcx List<GenericArg<'tcx>>>>(\n-        self,\n-        iter: I,\n-    ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_substs(xs))\n+    pub fn mk_substs<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<GenericArg<'tcx>, &'tcx List<GenericArg<'tcx>>>,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_substs(xs))\n     }\n \n-    pub fn mk_place_elems<I: InternAs<PlaceElem<'tcx>, &'tcx List<PlaceElem<'tcx>>>>(\n-        self,\n-        iter: I,\n-    ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_place_elems(xs))\n+    pub fn mk_place_elems<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<PlaceElem<'tcx>, &'tcx List<PlaceElem<'tcx>>>,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_place_elems(xs))\n     }\n \n     pub fn mk_substs_trait(\n@@ -2197,13 +2309,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty::AliasTy { def_id, substs, _use_mk_alias_ty_instead: () }\n     }\n \n-    pub fn mk_bound_variable_kinds<\n-        I: InternAs<ty::BoundVariableKind, &'tcx List<ty::BoundVariableKind>>,\n-    >(\n-        self,\n-        iter: I,\n-    ) -> I::Output {\n-        iter.intern_with(|xs| self.intern_bound_variable_kinds(xs))\n+    pub fn mk_bound_variable_kinds<I, T>(self, iter: I) -> T::Output\n+    where\n+        I: Iterator<Item = T>,\n+        T: CollectAndApply<ty::BoundVariableKind, &'tcx List<ty::BoundVariableKind>>,\n+    {\n+        T::collect_and_apply(iter, |xs| self.intern_bound_variable_kinds(xs))\n     }\n \n     /// Emit a lint at `span` from a lint struct (some type that implements `DecorateLint`,\n@@ -2278,23 +2389,23 @@ impl<'tcx> TyCtxt<'tcx> {\n         Some(&*candidates)\n     }\n \n-    pub fn named_region(self, id: HirId) -> Option<resolve_lifetime::Region> {\n+    pub fn named_bound_var(self, id: HirId) -> Option<resolve_bound_vars::ResolvedArg> {\n         debug!(?id, \"named_region\");\n-        self.named_region_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())\n+        self.named_variable_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())\n     }\n \n     pub fn is_late_bound(self, id: HirId) -> bool {\n         self.is_late_bound_map(id.owner).map_or(false, |set| set.contains(&id.local_id))\n     }\n \n     pub fn late_bound_vars(self, id: HirId) -> &'tcx List<ty::BoundVariableKind> {\n-        self.mk_bound_variable_kinds(\n-            self.late_bound_vars_map(id.owner)\n+        self.intern_bound_variable_kinds(\n+            &self\n+                .late_bound_vars_map(id.owner)\n                 .and_then(|map| map.get(&id.local_id).cloned())\n                 .unwrap_or_else(|| {\n                     bug!(\"No bound vars found for {}\", self.hir().node_to_string(id))\n-                })\n-                .iter(),\n+                }),\n         )\n     }\n "}, {"sha": "a029c1b209df4adcf5493a96cbd62f1496a1e68b", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -481,8 +481,9 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for IsSuggestableVisitor<'tcx> {\n \n             Alias(Opaque, AliasTy { def_id, .. }) => {\n                 let parent = self.tcx.parent(def_id);\n+                let parent_ty = self.tcx.type_of(parent).subst_identity();\n                 if let DefKind::TyAlias | DefKind::AssocTy = self.tcx.def_kind(parent)\n-                    && let Alias(Opaque, AliasTy { def_id: parent_opaque_def_id, .. }) = *self.tcx.type_of(parent).kind()\n+                    && let Alias(Opaque, AliasTy { def_id: parent_opaque_def_id, .. }) = *parent_ty.kind()\n                     && parent_opaque_def_id == def_id\n                 {\n                     // Okay\n@@ -564,8 +565,9 @@ impl<'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for MakeSuggestableFolder<'tcx> {\n \n             Alias(Opaque, AliasTy { def_id, .. }) => {\n                 let parent = self.tcx.parent(def_id);\n+                let parent_ty = self.tcx.type_of(parent).subst_identity();\n                 if let hir::def::DefKind::TyAlias | hir::def::DefKind::AssocTy = self.tcx.def_kind(parent)\n-                    && let Alias(Opaque, AliasTy { def_id: parent_opaque_def_id, .. }) = *self.tcx.type_of(parent).kind()\n+                    && let Alias(Opaque, AliasTy { def_id: parent_opaque_def_id, .. }) = *parent_ty.kind()\n                     && parent_opaque_def_id == def_id\n                 {\n                     t"}, {"sha": "106ce9990e1ed1c79f973ccafb43b5e507f6b268", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -290,7 +290,7 @@ impl DeepRejectCtxt {\n             // Impls cannot contain these types as these cannot be named directly.\n             ty::FnDef(..) | ty::Closure(..) | ty::Generator(..) => false,\n \n-            ty::Placeholder(..) => false,\n+            ty::Placeholder(..) | ty::Bound(..) => false,\n \n             // Depending on the value of `treat_obligation_params`, we either\n             // treat generic parameters like placeholders or like inference variables.\n@@ -310,7 +310,7 @@ impl DeepRejectCtxt {\n \n             ty::Error(_) => true,\n \n-            ty::GeneratorWitness(..) | ty::GeneratorWitnessMIR(..) | ty::Bound(..) => {\n+            ty::GeneratorWitness(..) | ty::GeneratorWitnessMIR(..) => {\n                 bug!(\"unexpected obligation type: {:?}\", obligation_ty)\n             }\n         }"}, {"sha": "91241ff404f4cbd485a50fa6b0f8b84ca27ef81e", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -251,6 +251,10 @@ impl FlagComputation {\n                 self.add_ty(ty);\n                 self.add_region(region);\n             }\n+            ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                self.add_const(ct);\n+                self.add_ty(ty);\n+            }\n             ty::PredicateKind::Subtype(ty::SubtypePredicate { a_is_expected: _, a, b }) => {\n                 self.add_ty(a);\n                 self.add_ty(b);"}, {"sha": "ee36e60bff15edf8991d9eace3c36341677cdbad", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -234,7 +234,7 @@ where\n                     // debruijn index. Then we adjust it to the\n                     // correct depth.\n                     assert_eq!(debruijn1, ty::INNERMOST);\n-                    self.tcx.reuse_or_mk_region(region, ty::ReLateBound(debruijn, br))\n+                    self.tcx.mk_re_late_bound(debruijn, br)\n                 } else {\n                     region\n                 }\n@@ -349,10 +349,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         self.replace_late_bound_regions_uncached(value, |br| {\n-            self.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: all_outlive_scope,\n-                bound_region: br.kind,\n-            }))\n+            self.mk_re_free(all_outlive_scope, br.kind)\n         })\n     }\n \n@@ -365,10 +362,10 @@ impl<'tcx> TyCtxt<'tcx> {\n             value,\n             FnMutDelegate {\n                 regions: &mut |r: ty::BoundRegion| {\n-                    self.mk_region(ty::ReLateBound(\n+                    self.mk_re_late_bound(\n                         ty::INNERMOST,\n                         ty::BoundRegion { var: shift_bv(r.var), kind: r.kind },\n-                    ))\n+                    )\n                 },\n                 types: &mut |t: ty::BoundTy| {\n                     self.mk_bound(ty::INNERMOST, ty::BoundTy { var: shift_bv(t.var), kind: t.kind })\n@@ -409,7 +406,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     })\n                     .expect_region();\n                 let br = ty::BoundRegion { var, kind };\n-                self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n+                self.tcx.mk_re_late_bound(ty::INNERMOST, br)\n             }\n             fn replace_ty(&mut self, bt: ty::BoundTy) -> Ty<'tcx> {\n                 let entry = self.map.entry(bt.var);\n@@ -479,8 +476,7 @@ impl<'tcx> ir::TypeFolder<TyCtxt<'tcx>> for Shifter<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, br) if debruijn >= self.current_index => {\n                 let debruijn = debruijn.shifted_in(self.amount);\n-                let shifted = ty::ReLateBound(debruijn, br);\n-                self.tcx.mk_region(shifted)\n+                self.tcx.mk_re_late_bound(debruijn, br)\n             }\n             _ => r,\n         }\n@@ -521,7 +517,7 @@ pub fn shift_region<'tcx>(\n ) -> ty::Region<'tcx> {\n     match *region {\n         ty::ReLateBound(debruijn, br) if amount > 0 => {\n-            tcx.mk_region(ty::ReLateBound(debruijn.shifted_in(amount), br))\n+            tcx.mk_re_late_bound(debruijn.shifted_in(amount), br)\n         }\n         _ => region,\n     }"}, {"sha": "35c036fef2ddc2d263d1d19c87f7f27ba18c1ac8", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -85,7 +85,7 @@ impl GenericParamDef {\n     ) -> Option<EarlyBinder<ty::GenericArg<'tcx>>> {\n         match self.kind {\n             GenericParamDefKind::Type { has_default, .. } if has_default => {\n-                Some(tcx.bound_type_of(self.def_id).map_bound(|t| t.into()))\n+                Some(tcx.type_of(self.def_id).map_bound(|t| t.into()))\n             }\n             GenericParamDefKind::Const { has_default } if has_default => {\n                 Some(tcx.const_param_default(self.def_id).map_bound(|c| c.into()))\n@@ -100,10 +100,10 @@ impl GenericParamDef {\n         preceding_substs: &[ty::GenericArg<'tcx>],\n     ) -> ty::GenericArg<'tcx> {\n         match &self.kind {\n-            ty::GenericParamDefKind::Lifetime => tcx.re_error_misc().into(),\n+            ty::GenericParamDefKind::Lifetime => tcx.mk_re_error_misc().into(),\n             ty::GenericParamDefKind::Type { .. } => tcx.ty_error().into(),\n             ty::GenericParamDefKind::Const { .. } => {\n-                tcx.const_error(tcx.bound_type_of(self.def_id).subst(tcx, preceding_substs)).into()\n+                tcx.const_error(tcx.type_of(self.def_id).subst(tcx, preceding_substs)).into()\n             }\n         }\n     }"}, {"sha": "355b8d8b43131a6c54d0ccc3e730efe1a52b9272", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> VariantDef {\n         InhabitedPredicate::all(\n             tcx,\n             self.fields.iter().map(|field| {\n-                let pred = tcx.type_of(field.did).inhabited_predicate(tcx);\n+                let pred = tcx.type_of(field.did).subst_identity().inhabited_predicate(tcx);\n                 if adt.is_enum() {\n                     return pred;\n                 }"}, {"sha": "c68a344e92c8a0d149225d6cd51bba81062d6872", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> Instance<'tcx> {\n     /// lifetimes erased, allowing a `ParamEnv` to be specified for use during normalization.\n     pub fn ty(&self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Ty<'tcx> {\n         let ty = tcx.type_of(self.def.def_id());\n-        tcx.subst_and_normalize_erasing_regions(self.substs, param_env, ty)\n+        tcx.subst_and_normalize_erasing_regions(self.substs, param_env, ty.skip_binder())\n     }\n \n     /// Finds a crate that contains a monomorphization of this instance that\n@@ -584,7 +584,7 @@ impl<'tcx> Instance<'tcx> {\n     /// this function returns `None`, then the MIR body does not require substitution during\n     /// codegen.\n     fn substs_for_mir_body(&self) -> Option<SubstsRef<'tcx>> {\n-        if self.def.has_polymorphic_mir_body() { Some(self.substs) } else { None }\n+        self.def.has_polymorphic_mir_body().then_some(self.substs)\n     }\n \n     pub fn subst_mir<T>(&self, tcx: TyCtxt<'tcx>, v: &T) -> T\n@@ -662,7 +662,7 @@ fn polymorphize<'tcx>(\n     let def_id = instance.def_id();\n     let upvars_ty = if tcx.is_closure(def_id) {\n         Some(substs.as_closure().tupled_upvars_ty())\n-    } else if tcx.type_of(def_id).is_generator() {\n+    } else if tcx.type_of(def_id).skip_binder().is_generator() {\n         Some(substs.as_generator().tupled_upvars_ty())\n     } else {\n         None"}, {"sha": "3d0f9a5053cb31fea3796d3feabc202315025f31", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -686,7 +686,7 @@ where\n                         Increase this counter if you tried to implement this but\n                         failed to do it without duplicating a lot of code from\n                         other places in the compiler: 2\n-                        tcx.mk_tup(&[\n+                        tcx.intern_tup(&[\n                             tcx.mk_array(tcx.types.usize, 3),\n                             tcx.mk_array(Option<fn()>),\n                         ])"}, {"sha": "1dc27ce8dae09518365c76f6e8a81c526d90bd66", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -552,6 +552,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::Clause(Clause::RegionOutlives(_))\n             | PredicateKind::Clause(Clause::TypeOutlives(_))\n             | PredicateKind::Clause(Clause::Projection(_))\n+            | PredicateKind::Clause(Clause::ConstArgHasType(..))\n             | PredicateKind::AliasEq(..)\n             | PredicateKind::ObjectSafe(_)\n             | PredicateKind::ClosureKind(_, _, _)\n@@ -590,6 +591,10 @@ pub enum Clause<'tcx> {\n     /// `where <T as TraitRef>::Name == X`, approximately.\n     /// See the `ProjectionPredicate` struct for details.\n     Projection(ProjectionPredicate<'tcx>),\n+\n+    /// Ensures that a const generic argument to a parameter `const N: u8`\n+    /// is of type `u8`.\n+    ConstArgHasType(Const<'tcx>, Ty<'tcx>),\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n@@ -1193,6 +1198,7 @@ impl<'tcx> Predicate<'tcx> {\n         match predicate.skip_binder() {\n             PredicateKind::Clause(Clause::Trait(t)) => Some(predicate.rebind(t)),\n             PredicateKind::Clause(Clause::Projection(..))\n+            | PredicateKind::Clause(Clause::ConstArgHasType(..))\n             | PredicateKind::AliasEq(..)\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n@@ -1213,6 +1219,7 @@ impl<'tcx> Predicate<'tcx> {\n         match predicate.skip_binder() {\n             PredicateKind::Clause(Clause::Projection(t)) => Some(predicate.rebind(t)),\n             PredicateKind::Clause(Clause::Trait(..))\n+            | PredicateKind::Clause(Clause::ConstArgHasType(..))\n             | PredicateKind::AliasEq(..)\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n@@ -1233,6 +1240,7 @@ impl<'tcx> Predicate<'tcx> {\n         match predicate.skip_binder() {\n             PredicateKind::Clause(Clause::TypeOutlives(data)) => Some(predicate.rebind(data)),\n             PredicateKind::Clause(Clause::Trait(..))\n+            | PredicateKind::Clause(Clause::ConstArgHasType(..))\n             | PredicateKind::Clause(Clause::Projection(..))\n             | PredicateKind::AliasEq(..)\n             | PredicateKind::Subtype(..)\n@@ -2017,7 +2025,7 @@ impl<'tcx> FieldDef {\n     /// Returns the type of this field. The resulting type is not normalized. The `subst` is\n     /// typically obtained via the second field of [`TyKind::Adt`].\n     pub fn ty(&self, tcx: TyCtxt<'tcx>, subst: SubstsRef<'tcx>) -> Ty<'tcx> {\n-        tcx.bound_type_of(self.did).subst(tcx, subst)\n+        tcx.type_of(self.did).subst(tcx, subst)\n     }\n \n     /// Computes the `Ident` of this variant by looking up the `Span`\n@@ -2198,7 +2206,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         Some(Ident::new(def, span))\n     }\n \n-    pub fn opt_associated_item(self, def_id: DefId) -> Option<&'tcx AssocItem> {\n+    pub fn opt_associated_item(self, def_id: DefId) -> Option<AssocItem> {\n         if let DefKind::AssocConst | DefKind::AssocFn | DefKind::AssocTy = self.def_kind(def_id) {\n             Some(self.associated_item(def_id))\n         } else {"}, {"sha": "8aeef4684b38e1f0838bc8acca0af86036363ea1", "filename": "compiler/rustc_middle/src/ty/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -143,7 +143,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ReverseMapper<'tcx> {\n                     )\n                     .emit();\n \n-                self.interner().re_error(e)\n+                self.interner().mk_re_error(e)\n             }\n         }\n     }"}, {"sha": "8849e7eab335c6b100068acc0d7aaf5c6e30bae1", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -57,7 +57,7 @@ trivially_parameterized_over_tcx! {\n     crate::metadata::ModChild,\n     crate::middle::codegen_fn_attrs::CodegenFnAttrs,\n     crate::middle::exported_symbols::SymbolExportInfo,\n-    crate::middle::resolve_lifetime::ObjectLifetimeDefault,\n+    crate::middle::resolve_bound_vars::ObjectLifetimeDefault,\n     crate::mir::ConstQualifs,\n     ty::AssocItemContainer,\n     ty::DeducedParamAttrs,"}, {"sha": "021c20b5854d2a5adff14d61105cbf0beb71c72b", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -115,7 +115,7 @@ pub trait Printer<'tcx>: Sized {\n \n             DefPathData::Impl => {\n                 let generics = self.tcx().generics_of(def_id);\n-                let self_ty = self.tcx().bound_type_of(def_id);\n+                let self_ty = self.tcx().type_of(def_id);\n                 let impl_trait_ref = self.tcx().impl_trait_ref(def_id);\n                 let (self_ty, impl_trait_ref) = if substs.len() >= generics.count() {\n                     ("}, {"sha": "1e59983583b14c5d3a2fa81f9e27fbee66468935", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -182,7 +182,7 @@ impl<'tcx> RegionHighlightMode<'tcx> {\n \n     /// Convenience wrapper for `highlighting_region`.\n     pub fn highlighting_region_vid(&mut self, vid: ty::RegionVid, number: usize) {\n-        self.highlighting_region(self.tcx.mk_region(ty::ReVar(vid)), number)\n+        self.highlighting_region(self.tcx.mk_re_var(vid), number)\n     }\n \n     /// Returns `Some(n)` with the number to use for the given region, if any.\n@@ -754,7 +754,7 @@ pub trait PrettyPrinter<'tcx>:\n                         // NOTE: I know we should check for NO_QUERIES here, but it's alright.\n                         // `type_of` on a type alias or assoc type should never cause a cycle.\n                         if let ty::Alias(ty::Opaque, ty::AliasTy { def_id: d, .. }) =\n-                            *self.tcx().type_of(parent).kind()\n+                            *self.tcx().type_of(parent).subst_identity().kind()\n                         {\n                             if d == def_id {\n                                 // If the type alias directly starts with the `impl` of the\n@@ -2271,7 +2271,7 @@ impl<'a, 'tcx> ty::ir::TypeFolder<TyCtxt<'tcx>> for RegionFolder<'a, 'tcx> {\n         };\n         if let ty::ReLateBound(debruijn1, br) = *region {\n             assert_eq!(debruijn1, ty::INNERMOST);\n-            self.tcx.mk_region(ty::ReLateBound(self.current_index, br))\n+            self.tcx.mk_re_late_bound(self.current_index, br)\n         } else {\n             region\n         }\n@@ -2383,10 +2383,10 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n                         if let Some(lt_idx) = lifetime_idx {\n                             if lt_idx > binder_level_idx {\n                                 let kind = ty::BrNamed(CRATE_DEF_ID.to_def_id(), name);\n-                                return tcx.mk_region(ty::ReLateBound(\n+                                return tcx.mk_re_late_bound(\n                                     ty::INNERMOST,\n                                     ty::BoundRegion { var: br.var, kind },\n-                                ));\n+                                );\n                             }\n                         }\n \n@@ -2398,10 +2398,10 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n                         if let Some(lt_idx) = lifetime_idx {\n                             if lt_idx > binder_level_idx {\n                                 let kind = ty::BrNamed(def_id, name);\n-                                return tcx.mk_region(ty::ReLateBound(\n+                                return tcx.mk_re_late_bound(\n                                     ty::INNERMOST,\n                                     ty::BoundRegion { var: br.var, kind },\n-                                ));\n+                                );\n                             }\n                         }\n \n@@ -2411,10 +2411,10 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n                         if let Some(lt_idx) = lifetime_idx {\n                             if lt_idx > binder_level_idx {\n                                 let kind = br.kind;\n-                                return tcx.mk_region(ty::ReLateBound(\n+                                return tcx.mk_re_late_bound(\n                                     ty::INNERMOST,\n                                     ty::BoundRegion { var: br.var, kind },\n-                                ));\n+                                );\n                             }\n                         }\n \n@@ -2426,7 +2426,7 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n                     start_or_continue(&mut self, \"for<\", \", \");\n                     do_continue(&mut self, name);\n                 }\n-                tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { var: br.var, kind }))\n+                tcx.mk_re_late_bound(ty::INNERMOST, ty::BoundRegion { var: br.var, kind })\n             };\n             let mut folder = RegionFolder {\n                 tcx,\n@@ -2822,15 +2822,18 @@ define_print_and_forward_display! {\n             ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => p!(print(predicate)),\n             ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => p!(print(predicate)),\n             ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => p!(print(predicate)),\n+            ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                p!(\"the constant `\", print(ct), \"` has type `\", print(ty), \"`\")\n+            },\n             ty::PredicateKind::WellFormed(arg) => p!(print(arg), \" well-formed\"),\n             ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 p!(\"the trait `\", print_def_path(trait_def_id, &[]), \"` is object-safe\")\n             }\n-            ty::PredicateKind::ClosureKind(closure_def_id, _closure_substs, kind) => {\n-                p!(\"the closure `\",\n+            ty::PredicateKind::ClosureKind(closure_def_id, _closure_substs, kind) => p!(\n+                \"the closure `\",\n                 print_value_path(closure_def_id, &[]),\n-                write(\"` implements the trait `{}`\", kind))\n-            }\n+                write(\"` implements the trait `{}`\", kind)\n+            ),\n             ty::PredicateKind::ConstEvaluatable(ct) => {\n                 p!(\"the constant `\", print(ct), \"` can be evaluated\")\n             }"}, {"sha": "5b3f38704299b2b9dc742793fcebc8288aca6bdc", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 81, "deletions": 29, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1,3 +1,5 @@\n+#![allow(unused_parens)]\n+\n use crate::dep_graph;\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintExpectation;\n@@ -6,7 +8,7 @@ use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use crate::middle::lib_features::LibFeatures;\n use crate::middle::privacy::EffectiveVisibilities;\n-use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLifetimes};\n+use crate::middle::resolve_bound_vars::{ObjectLifetimeDefault, ResolveBoundVars, ResolvedArg};\n use crate::middle::stability::{self, DeprecationEntry};\n use crate::mir;\n use crate::mir::interpret::GlobalId;\n@@ -34,13 +36,15 @@ use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::GeneratorDiagnosticData;\n use crate::ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt, UnusedGenericParams};\n+use rustc_arena::TypedArena;\n use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::WorkerLocal;\n use rustc_data_structures::unord::UnordSet;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n@@ -59,13 +63,20 @@ use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi;\n use rustc_target::spec::PanicStrategy;\n+use std::mem;\n use std::ops::Deref;\n use std::path::PathBuf;\n use std::sync::Arc;\n \n pub(crate) use rustc_query_system::query::QueryJobId;\n use rustc_query_system::query::*;\n \n+#[derive(Default)]\n+pub struct QuerySystem<'tcx> {\n+    pub arenas: QueryArenas<'tcx>,\n+    pub caches: QueryCaches<'tcx>,\n+}\n+\n #[derive(Copy, Clone)]\n pub struct TyCtxtAt<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n@@ -112,10 +123,10 @@ macro_rules! query_helper_param_ty {\n }\n \n macro_rules! query_if_arena {\n-    ([] $arena:ty, $no_arena:ty) => {\n+    ([] $arena:tt $no_arena:tt) => {\n         $no_arena\n     };\n-    ([(arena_cache) $($rest:tt)*] $arena:ty, $no_arena:ty) => {\n+    ([(arena_cache) $($rest:tt)*] $arena:tt $no_arena:tt) => {\n         $arena\n     };\n     ([$other:tt $($modifiers:tt)*]$($args:tt)*) => {\n@@ -131,7 +142,7 @@ macro_rules! separate_provide_extern_decl {\n         for<'tcx> fn(\n             TyCtxt<'tcx>,\n             query_keys::$name<'tcx>,\n-        ) -> query_values::$name<'tcx>\n+        ) -> query_provided::$name<'tcx>\n     };\n     ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n         separate_provide_extern_decl!([$($modifiers)*][$($args)*])\n@@ -183,30 +194,77 @@ macro_rules! define_callbacks {\n \n             $(pub type $name<'tcx> = $($K)*;)*\n         }\n-        #[allow(nonstandard_style, unused_lifetimes, unused_parens)]\n+        #[allow(nonstandard_style, unused_lifetimes)]\n         pub mod query_values {\n             use super::*;\n \n-            $(pub type $name<'tcx> = query_if_arena!([$($modifiers)*] <$V as Deref>::Target, $V);)*\n+            $(pub type $name<'tcx> = $V;)*\n         }\n-        #[allow(nonstandard_style, unused_lifetimes, unused_parens)]\n-        pub mod query_storage {\n+\n+        /// This module specifies the type returned from query providers and the type used for\n+        /// decoding. For regular queries this is the declared returned type `V`, but\n+        /// `arena_cache` will use `<V as Deref>::Target` instead.\n+        #[allow(nonstandard_style, unused_lifetimes)]\n+        pub mod query_provided {\n             use super::*;\n \n             $(\n-                pub type $name<'tcx> = query_if_arena!([$($modifiers)*]\n-                    <<$($K)* as Key>::CacheSelector\n-                        as CacheSelector<'tcx, <$V as Deref>::Target>>::ArenaCache,\n-                    <<$($K)* as Key>::CacheSelector as CacheSelector<'tcx, $V>>::Cache\n-                );\n+                pub type $name<'tcx> = query_if_arena!([$($modifiers)*] (<$V as Deref>::Target) ($V));\n             )*\n         }\n \n+        /// This module has a function per query which takes a `query_provided` value and coverts\n+        /// it to a regular `V` value by allocating it on an arena if the query has the\n+        /// `arena_cache` modifier. This will happen when computing the query using a provider or\n+        /// decoding a stored result.\n         #[allow(nonstandard_style, unused_lifetimes)]\n-        pub mod query_stored {\n+        pub mod query_provided_to_value {\n             use super::*;\n \n-            $(pub type $name<'tcx> = $V;)*\n+            $(\n+                #[inline(always)]\n+                pub fn $name<'tcx>(\n+                    _tcx: TyCtxt<'tcx>,\n+                    value: query_provided::$name<'tcx>,\n+                ) -> query_values::$name<'tcx> {\n+                    query_if_arena!([$($modifiers)*]\n+                        {\n+                            if mem::needs_drop::<query_provided::$name<'tcx>>() {\n+                                &*_tcx.query_system.arenas.$name.alloc(value)\n+                            } else {\n+                                &*_tcx.arena.dropless.alloc(value)\n+                            }\n+                        }\n+                        (value)\n+                    )\n+                }\n+            )*\n+        }\n+        #[allow(nonstandard_style, unused_lifetimes)]\n+        pub mod query_storage {\n+            use super::*;\n+\n+            $(\n+                pub type $name<'tcx> = <<$($K)* as Key>::CacheSelector as CacheSelector<'tcx, $V>>::Cache;\n+            )*\n+        }\n+\n+        pub struct QueryArenas<'tcx> {\n+            $($(#[$attr])* pub $name: query_if_arena!([$($modifiers)*]\n+                (WorkerLocal<TypedArena<<$V as Deref>::Target>>)\n+                ()\n+            ),)*\n+        }\n+\n+        impl Default for QueryArenas<'_> {\n+            fn default() -> Self {\n+                Self {\n+                    $($name: query_if_arena!([$($modifiers)*]\n+                        (WorkerLocal::new(|_| Default::default()))\n+                        ()\n+                    ),)*\n+                }\n+            }\n         }\n \n         #[derive(Default)]\n@@ -221,7 +279,7 @@ macro_rules! define_callbacks {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n-                match try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key) {\n+                match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n                     Some(_) => return,\n                     None => self.tcx.queries.$name(self.tcx, DUMMY_SP, key, QueryMode::Ensure),\n                 };\n@@ -246,7 +304,7 @@ macro_rules! define_callbacks {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n-                match try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key) {\n+                match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n                     Some(value) => value,\n                     None => self.tcx.queries.$name(self.tcx, self.span, key, QueryMode::Get).unwrap(),\n                 }\n@@ -257,7 +315,7 @@ macro_rules! define_callbacks {\n             $(pub $name: for<'tcx> fn(\n                 TyCtxt<'tcx>,\n                 query_keys::$name<'tcx>,\n-            ) -> query_values::$name<'tcx>,)*\n+            ) -> query_provided::$name<'tcx>,)*\n         }\n \n         pub struct ExternProviders {\n@@ -334,12 +392,13 @@ macro_rules! define_feedable {\n         $(impl<'tcx, K: IntoQueryParam<$($K)*> + Copy> TyCtxtFeed<'tcx, K> {\n             $(#[$attr])*\n             #[inline(always)]\n-            pub fn $name(self, value: query_values::$name<'tcx>) -> $V {\n+            pub fn $name(self, value: query_provided::$name<'tcx>) -> $V {\n                 let key = self.key().into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n                 let tcx = self.tcx;\n-                let cache = &tcx.query_caches.$name;\n+                let value = query_provided_to_value::$name(tcx, value);\n+                let cache = &tcx.query_system.caches.$name;\n \n                 match try_get_cached(tcx, cache, &key) {\n                     Some(old) => {\n@@ -357,7 +416,8 @@ macro_rules! define_feedable {\n                             &value,\n                             hash_result!([$($modifiers)*]),\n                         );\n-                        cache.complete(key, value, dep_node_index)\n+                        cache.complete(key, value, dep_node_index);\n+                        value\n                     }\n                 }\n             }\n@@ -435,10 +495,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.opt_def_kind(def_id)\n             .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", def_id))\n     }\n-\n-    pub fn bound_type_of(self, def_id: impl IntoQueryParam<DefId>) -> ty::EarlyBinder<Ty<'tcx>> {\n-        ty::EarlyBinder(self.type_of(def_id))\n-    }\n }\n \n impl<'tcx> TyCtxtAt<'tcx> {\n@@ -447,8 +503,4 @@ impl<'tcx> TyCtxtAt<'tcx> {\n         self.opt_def_kind(def_id)\n             .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", def_id))\n     }\n-\n-    pub fn bound_type_of(self, def_id: impl IntoQueryParam<DefId>) -> ty::EarlyBinder<Ty<'tcx>> {\n-        ty::EarlyBinder(self.type_of(def_id))\n-    }\n }"}, {"sha": "2ba25e8bfadc9223a3db780e2efc33ef798601ad", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -163,8 +163,7 @@ pub fn relate_substs_with_variances<'tcx, R: TypeRelation<'tcx>>(\n     let params = iter::zip(a_subst, b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances[i];\n         let variance_info = if variance == ty::Invariant && fetch_ty_for_diag {\n-            let ty =\n-                *cached_ty.get_or_insert_with(|| tcx.bound_type_of(ty_def_id).subst(tcx, a_subst));\n+            let ty = *cached_ty.get_or_insert_with(|| tcx.type_of(ty_def_id).subst(tcx, a_subst));\n             ty::VarianceDiagInfo::Invariant { ty, param_index: i.try_into().unwrap() }\n         } else {\n             ty::VarianceDiagInfo::default()\n@@ -674,7 +673,7 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n                     for (a_arg, b_arg) in aa.iter().zip(ba.iter()) {\n                         related_args.push(r.consts(a_arg, b_arg)?);\n                     }\n-                    let related_args = tcx.mk_const_list(related_args.iter());\n+                    let related_args = tcx.intern_const_list(&related_args);\n                     Expr::FunctionCall(func, related_args)\n                 }\n                 _ => return Err(TypeError::ConstMismatch(expected_found(r, a, b))),"}, {"sha": "573105fd8c007e4444b0169c66dbdbb7bdf7a6e3", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -147,6 +147,7 @@ impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n impl<'tcx> fmt::Debug for ty::Clause<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n+            ty::Clause::ConstArgHasType(ct, ty) => write!(f, \"ConstArgHasType({ct:?}, {ty:?})\"),\n             ty::Clause::Trait(ref a) => a.fmt(f),\n             ty::Clause::RegionOutlives(ref pair) => pair.fmt(f),\n             ty::Clause::TypeOutlives(ref pair) => pair.fmt(f),\n@@ -418,7 +419,7 @@ impl<'tcx> ir::TypeFoldable<TyCtxt<'tcx>> for &'tcx ty::List<ty::PolyExistential\n \n impl<'tcx> ir::TypeFoldable<TyCtxt<'tcx>> for &'tcx ty::List<ty::Const<'tcx>> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        ty::util::fold_list(self, folder, |tcx, v| tcx.mk_const_list(v.iter()))\n+        ty::util::fold_list(self, folder, |tcx, v| tcx.intern_const_list(v))\n     }\n }\n "}, {"sha": "f8d17433cf7701e1f7da8c3bb736a9dac7cbf529", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -933,6 +933,12 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     }\n }\n \n+impl rustc_errors::IntoDiagnosticArg for PolyExistentialTraitRef<'_> {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        self.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum BoundVariableKind {\n@@ -1187,7 +1193,7 @@ impl<'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for SkipBindersAt<'tcx> {\n             if index == self.index {\n                 Err(())\n             } else {\n-                Ok(self.interner().mk_region(ty::ReLateBound(index.shifted_out(1), bv)))\n+                Ok(self.interner().mk_re_late_bound(index.shifted_out(1), bv))\n             }\n         } else {\n             r.try_super_fold_with(self)\n@@ -2268,7 +2274,7 @@ impl<'tcx> Ty<'tcx> {\n             ty::Str | ty::Slice(_) => (tcx.types.usize, false),\n             ty::Dynamic(..) => {\n                 let dyn_metadata = tcx.require_lang_item(LangItem::DynMetadata, None);\n-                (tcx.bound_type_of(dyn_metadata).subst(tcx, &[tail.into()]), false)\n+                (tcx.type_of(dyn_metadata).subst(tcx, &[tail.into()]), false)\n             },\n \n             // type parameters only have unit metadata if they're sized, so return true"}, {"sha": "6b4a6a17aef5fb356337b36bc23946019eda2398", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -267,13 +267,11 @@ pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;\n impl<'tcx> InternalSubsts<'tcx> {\n     /// Checks whether all elements of this list are types, if so, transmute.\n     pub fn try_as_type_list(&'tcx self) -> Option<&'tcx List<Ty<'tcx>>> {\n-        if self.iter().all(|arg| matches!(arg.unpack(), GenericArgKind::Type(_))) {\n+        self.iter().all(|arg| matches!(arg.unpack(), GenericArgKind::Type(_))).then(|| {\n             assert_eq!(TYPE_TAG, 0);\n             // SAFETY: All elements are types, see `List<Ty<'tcx>>::as_substs`.\n-            Some(unsafe { &*(self as *const List<GenericArg<'tcx>> as *const List<Ty<'tcx>>) })\n-        } else {\n-            None\n-        }\n+            unsafe { &*(self as *const List<GenericArg<'tcx>> as *const List<Ty<'tcx>>) }\n+        })\n     }\n \n     /// Interpret these substitutions as the substitutions of a closure type."}, {"sha": "a4a82bf247d03f8d41934f7a85365093967e6d0a", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -225,7 +225,7 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n     for &impl_def_id in tcx.hir().trait_impls(trait_id) {\n         let impl_def_id = impl_def_id.to_def_id();\n \n-        let impl_self_ty = tcx.type_of(impl_def_id);\n+        let impl_self_ty = tcx.type_of(impl_def_id).subst_identity();\n         if impl_self_ty.references_error() {\n             continue;\n         }"}, {"sha": "a34ee1a99a178e6eda16966ce1754b88d3d0419d", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -362,7 +362,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let drop_trait = self.lang_items().drop_trait()?;\n         self.ensure().coherent_trait(drop_trait);\n \n-        let ty = self.type_of(adt_did);\n+        let ty = self.type_of(adt_did).subst_identity();\n         let (did, constness) = self.find_map_relevant_impl(drop_trait, ty, |impl_did| {\n             if let Some(item_id) = self.associated_item_def_ids(impl_did).first() {\n                 if validate(self, impl_did).is_ok() {\n@@ -415,12 +415,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         // <P1, P2, P0>, and then look up which of the impl substs refer to\n         // parameters marked as pure.\n \n-        let impl_substs = match *self.type_of(impl_def_id).kind() {\n+        let impl_substs = match *self.type_of(impl_def_id).subst_identity().kind() {\n             ty::Adt(def_, substs) if def_ == def => substs,\n             _ => bug!(),\n         };\n \n-        let item_substs = match *self.type_of(def.did()).kind() {\n+        let item_substs = match *self.type_of(def.did()).subst_identity().kind() {\n             ty::Adt(def_, substs) if def_ == def => substs,\n             _ => bug!(),\n         };\n@@ -564,14 +564,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n-        env_region: ty::RegionKind<'tcx>,\n+        env_region: ty::Region<'tcx>,\n     ) -> Option<Ty<'tcx>> {\n         let closure_ty = self.mk_closure(closure_def_id, closure_substs);\n         let closure_kind_ty = closure_substs.as_closure().kind_ty();\n         let closure_kind = closure_kind_ty.to_opt_closure_kind()?;\n         let env_ty = match closure_kind {\n-            ty::ClosureKind::Fn => self.mk_imm_ref(self.mk_region(env_region), closure_ty),\n-            ty::ClosureKind::FnMut => self.mk_mut_ref(self.mk_region(env_region), closure_ty),\n+            ty::ClosureKind::Fn => self.mk_imm_ref(env_region, closure_ty),\n+            ty::ClosureKind::FnMut => self.mk_mut_ref(env_region, closure_ty),\n             ty::ClosureKind::FnOnce => closure_ty,\n         };\n         Some(env_ty)\n@@ -602,7 +602,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Get the type of the pointer to the static that we use in MIR.\n     pub fn static_ptr_ty(self, def_id: DefId) -> Ty<'tcx> {\n         // Make sure that any constants in the static's type are evaluated.\n-        let static_ty = self.normalize_erasing_regions(ty::ParamEnv::empty(), self.type_of(def_id));\n+        let static_ty = self.normalize_erasing_regions(\n+            ty::ParamEnv::empty(),\n+            self.type_of(def_id).subst_identity(),\n+        );\n \n         // Make sure that accesses to unsafe statics end up using raw pointers.\n         // For thread-locals, this needs to be kept in sync with `Rvalue::ty`.\n@@ -790,7 +793,7 @@ impl<'tcx> OpaqueTypeExpander<'tcx> {\n             let expanded_ty = match self.expanded_cache.get(&(def_id, substs)) {\n                 Some(expanded_ty) => *expanded_ty,\n                 None => {\n-                    let generic_ty = self.tcx.bound_type_of(def_id);\n+                    let generic_ty = self.tcx.type_of(def_id);\n                     let concrete_ty = generic_ty.subst(self.tcx, substs);\n                     let expanded_ty = self.fold_ty(concrete_ty);\n                     self.expanded_cache.insert((def_id, substs), expanded_ty);"}, {"sha": "dac9bf0a88350e5505af0c5137ca8ac64eb39c6a", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -319,7 +319,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // See the notes for `ExprKind::Array` in `as_rvalue` and for\n                 // `ExprKind::Borrow` above.\n                 let is_union = adt_def.is_union();\n-                let active_field_index = if is_union { Some(fields[0].name.index()) } else { None };\n+                let active_field_index = is_union.then(|| fields[0].name.index());\n \n                 let scope = this.local_scope();\n "}, {"sha": "8859f5002e465c4adcf7d9d1b547997195c2e3d6", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -563,14 +563,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let not_contained =\n                     self.values_not_contained_in_range(&*range, options).unwrap_or(false);\n \n-                if not_contained {\n+                not_contained.then(|| {\n                     // No switch values are contained in the pattern range,\n                     // so the pattern can be matched only if this test fails.\n-                    let otherwise = options.len();\n-                    Some(otherwise)\n-                } else {\n-                    None\n-                }\n+                    options.len()\n+                })\n             }\n \n             (&TestKind::SwitchInt { .. }, _) => None,"}, {"sha": "933b1158fa6ea1523bf10f1395f1932e3eef175f", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -643,7 +643,7 @@ fn construct_error(\n     let num_params = match body_owner_kind {\n         hir::BodyOwnerKind::Fn => tcx.fn_sig(def).skip_binder().inputs().skip_binder().len(),\n         hir::BodyOwnerKind::Closure => {\n-            let ty = tcx.type_of(def);\n+            let ty = tcx.type_of(def).subst_identity();\n             match ty.kind() {\n                 ty::Closure(_, substs) => {\n                     1 + substs.as_closure().sig().inputs().skip_binder().len()"}, {"sha": "74c35ef0fc241059e273a2e53ff0260fc1e91dc1", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -133,14 +133,14 @@ impl<'tcx> Cx<'tcx> {\n                     bug!(\"closure expr does not have closure type: {:?}\", closure_ty);\n                 };\n \n-                let bound_vars = self.tcx.mk_bound_variable_kinds(std::iter::once(\n-                    ty::BoundVariableKind::Region(ty::BrEnv),\n-                ));\n+                let bound_vars = self\n+                    .tcx\n+                    .intern_bound_variable_kinds(&[ty::BoundVariableKind::Region(ty::BrEnv)]);\n                 let br = ty::BoundRegion {\n                     var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n                     kind: ty::BrEnv,\n                 };\n-                let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+                let env_region = self.tcx.mk_re_late_bound(ty::INNERMOST, br);\n                 let closure_env_ty =\n                     self.tcx.closure_env_ty(closure_def_id, closure_substs, env_region).unwrap();\n                 let liberated_closure_env_ty = self.tcx.erase_late_bound_regions(\n@@ -193,7 +193,7 @@ impl<'tcx> Cx<'tcx> {\n                 let va_list_did = self.tcx.require_lang_item(LangItem::VaList, Some(param.span));\n \n                 self.tcx\n-                    .bound_type_of(va_list_did)\n+                    .type_of(va_list_did)\n                     .subst(self.tcx, &[self.tcx.lifetimes.re_erased.into()])\n             } else {\n                 fn_sig.inputs()[index]"}, {"sha": "e5b7d685c499b72b16c8dfa23a8691774120edb6", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -172,7 +172,7 @@ impl IntRange {\n         ty: Ty<'tcx>,\n         end: &RangeEnd,\n     ) -> Option<IntRange> {\n-        if Self::is_integral(ty) {\n+        Self::is_integral(ty).then(|| {\n             // Perform a shift if the underlying types are signed,\n             // which makes the interval arithmetic simpler.\n             let bias = IntRange::signed_bias(tcx, ty);\n@@ -182,10 +182,8 @@ impl IntRange {\n                 // This should have been caught earlier by E0030.\n                 bug!(\"malformed range pattern: {}..={}\", lo, (hi - offset));\n             }\n-            Some(IntRange { range: lo..=(hi - offset), bias })\n-        } else {\n-            None\n-        }\n+            IntRange { range: lo..=(hi - offset), bias }\n+        })\n     }\n \n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it."}, {"sha": "41306dd80fbdd4b83d8833f00adcf35a310f22b6", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -203,11 +203,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 if !lower_overflow && !higher_overflow {\n                     self.tcx.sess.emit_err(LowerRangeBoundMustBeLessThanOrEqualToUpper {\n                         span,\n-                        teach: if self.tcx.sess.teach(&error_code!(E0030)) {\n-                            Some(())\n-                        } else {\n-                            None\n-                        },\n+                        teach: self.tcx.sess.teach(&error_code!(E0030)).then_some(()),\n                     });\n                 }\n                 PatKind::Wild"}, {"sha": "633a5674f1f96da223c3fe6527fd805d2b445e17", "filename": "compiler/rustc_mir_dataflow/src/impls/liveness.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -254,13 +254,7 @@ impl<'a, 'tcx> Analysis<'tcx> for MaybeTransitiveLiveLocals<'a> {\n     ) {\n         // Compute the place that we are storing to, if any\n         let destination = match &statement.kind {\n-            StatementKind::Assign(assign) => {\n-                if assign.1.is_safe_to_remove() {\n-                    Some(assign.0)\n-                } else {\n-                    None\n-                }\n-            }\n+            StatementKind::Assign(assign) => assign.1.is_safe_to_remove().then_some(assign.0),\n             StatementKind::SetDiscriminant { place, .. } | StatementKind::Deinit(place) => {\n                 Some(**place)\n             }"}, {"sha": "9b4b720702b6f76818989eba76cc26ea6b3c332e", "filename": "compiler/rustc_mir_transform/src/abort_unwinding_calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -41,7 +41,7 @@ impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n         //\n         // Here we test for this function itself whether its ABI allows\n         // unwinding or not.\n-        let body_ty = tcx.type_of(def_id);\n+        let body_ty = tcx.type_of(def_id).skip_binder();\n         let body_abi = match body_ty.kind() {\n             ty::FnDef(..) => body_ty.fn_sig(tcx).abi(),\n             ty::Closure(..) => Abi::RustCall,"}, {"sha": "13f064aa72e5edae3f847b1e6cffeddafad911cd", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -82,7 +82,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             return;\n         }\n \n-        let is_generator = tcx.type_of(def_id.to_def_id()).is_generator();\n+        let is_generator = tcx.type_of(def_id.to_def_id()).subst_identity().is_generator();\n         // FIXME(welseywiser) const prop doesn't work on generators because of query cycles\n         // computing their layout.\n         if is_generator {"}, {"sha": "be41d611fe485a5726f433eb37126949fd71206d", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> MirLint<'tcx> for ConstProp {\n             return;\n         }\n \n-        let is_generator = tcx.type_of(def_id.to_def_id()).is_generator();\n+        let is_generator = tcx.type_of(def_id.to_def_id()).subst_identity().is_generator();\n         // FIXME(welseywiser) const prop doesn't work on generators because of query cycles\n         // computing their layout.\n         if is_generator {"}, {"sha": "1b3ac78fbc664feca889e12b9527507ba7634b9b", "filename": "compiler/rustc_mir_transform/src/ctfe_limit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -47,8 +47,7 @@ fn has_back_edge(\n         return false;\n     }\n     // Check if any of the dominators of the node are also the node's successor.\n-    doms.dominators(node)\n-        .any(|dom| node_data.terminator().successors().into_iter().any(|succ| succ == dom))\n+    doms.dominators(node).any(|dom| node_data.terminator().successors().any(|succ| succ == dom))\n }\n \n fn insert_counter(basic_block_data: &mut BasicBlockData<'_>) {"}, {"sha": "89ca04a158270680eb49061f7a3054cb18fe4ff5", "filename": "compiler/rustc_mir_transform/src/deduce_param_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -163,7 +163,7 @@ pub fn deduced_param_attrs<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [Ded\n \n     // Codegen won't use this information for anything if all the function parameters are passed\n     // directly. Detect that and bail, for compilation speed.\n-    let fn_ty = tcx.type_of(def_id);\n+    let fn_ty = tcx.type_of(def_id).subst_identity();\n     if matches!(fn_ty.kind(), ty::FnDef(..)) {\n         if fn_ty\n             .fn_sig(tcx)"}, {"sha": "2e481b972781c349bdc361ee183e7930aa77626d", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -136,8 +136,8 @@ use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n use rustc_middle::mir::{dump_mir, PassWhere};\n use rustc_middle::mir::{\n-    traversal, BasicBlock, Body, InlineAsmOperand, Local, LocalKind, Location, Operand, Place,\n-    Rvalue, Statement, StatementKind, TerminatorKind,\n+    traversal, Body, InlineAsmOperand, Local, LocalKind, Location, Operand, Place, Rvalue,\n+    Statement, StatementKind, TerminatorKind,\n };\n use rustc_middle::ty::TyCtxt;\n use rustc_mir_dataflow::impls::MaybeLiveLocals;\n@@ -468,7 +468,7 @@ impl<'a, 'body, 'alloc, 'tcx> FilterInformation<'a, 'body, 'alloc, 'tcx> {\n             // to reuse the allocation.\n             write_info: write_info_alloc,\n             // Doesn't matter what we put here, will be overwritten before being used\n-            at: Location { block: BasicBlock::from_u32(0), statement_index: 0 },\n+            at: Location::START,\n         };\n         this.internal_filter_liveness();\n     }"}, {"sha": "dc583471c89d1e2d634171249bc8e0c52745dedd", "filename": "compiler/rustc_mir_transform/src/elaborate_box_derefs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -18,8 +18,8 @@ pub fn build_ptr_tys<'tcx>(\n     nonnull_did: DefId,\n ) -> (Ty<'tcx>, Ty<'tcx>, Ty<'tcx>) {\n     let substs = tcx.intern_substs(&[pointee.into()]);\n-    let unique_ty = tcx.bound_type_of(unique_did).subst(tcx, substs);\n-    let nonnull_ty = tcx.bound_type_of(nonnull_did).subst(tcx, substs);\n+    let unique_ty = tcx.type_of(unique_did).subst(tcx, substs);\n+    let nonnull_ty = tcx.type_of(nonnull_did).subst(tcx, substs);\n     let ptr_ty = tcx.mk_imm_ptr(pointee);\n \n     (unique_ty, nonnull_ty, ptr_ty)\n@@ -93,7 +93,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateBoxDerefs {\n         if let Some(def_id) = tcx.lang_items().owned_box() {\n             let unique_did = tcx.adt_def(def_id).non_enum_variant().fields[0].did;\n \n-            let Some(nonnull_def) = tcx.type_of(unique_did).ty_adt_def() else {\n+            let Some(nonnull_def) = tcx.type_of(unique_did).subst_identity().ty_adt_def() else {\n                 span_bug!(tcx.def_span(unique_did), \"expected Box to contain Unique\")\n             };\n "}, {"sha": "e6546911a2d0dcedf6bf61ad4ff1b902e1af58a8", "filename": "compiler/rustc_mir_transform/src/ffi_unwind_calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -49,7 +49,7 @@ fn has_ffi_unwind_calls(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> bool {\n \n     let body = &*tcx.mir_built(ty::WithOptConstParam::unknown(local_def_id)).borrow();\n \n-    let body_ty = tcx.type_of(def_id);\n+    let body_ty = tcx.type_of(def_id).skip_binder();\n     let body_abi = match body_ty.kind() {\n         ty::FnDef(..) => body_ty.fn_sig(tcx).abi(),\n         ty::Closure(..) => Abi::RustCall,"}, {"sha": "66d32b954e473d8eb774d39a80668197934b918e", "filename": "compiler/rustc_mir_transform/src/function_item_references.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -111,11 +111,9 @@ impl<'tcx> FunctionItemRefChecker<'_, 'tcx> {\n     /// If the given predicate is the trait `fmt::Pointer`, returns the bound parameter type.\n     fn is_pointer_trait(&self, bound: &PredicateKind<'tcx>) -> Option<Ty<'tcx>> {\n         if let ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) = bound {\n-            if self.tcx.is_diagnostic_item(sym::Pointer, predicate.def_id()) {\n-                Some(predicate.trait_ref.self_ty())\n-            } else {\n-                None\n-            }\n+            self.tcx\n+                .is_diagnostic_item(sym::Pointer, predicate.def_id())\n+                .then(|| predicate.trait_ref.self_ty())\n         } else {\n             None\n         }"}, {"sha": "dc5f88f24f801770849a2b62c06340156408682c", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -487,7 +487,7 @@ fn transform_async_context<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n \n     let get_context_def_id = tcx.require_lang_item(LangItem::GetContext, None);\n \n-    for bb in BasicBlock::new(0)..body.basic_blocks.next_index() {\n+    for bb in START_BLOCK..body.basic_blocks.next_index() {\n         let bb_data = &body[bb];\n         if bb_data.is_cleanup {\n             continue;\n@@ -1255,7 +1255,7 @@ fn create_generator_resume_function<'tcx>(\n     use rustc_middle::mir::AssertKind::{ResumedAfterPanic, ResumedAfterReturn};\n \n     // Jump to the entry point on the unresumed\n-    cases.insert(0, (UNRESUMED, BasicBlock::new(0)));\n+    cases.insert(0, (UNRESUMED, START_BLOCK));\n \n     // Panic when resumed on the returned or poisoned state\n     let generator_kind = body.generator_kind().unwrap();\n@@ -1481,7 +1481,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n \n         // When first entering the generator, move the resume argument into its new local.\n         let source_info = SourceInfo::outermost(body.span);\n-        let stmts = &mut body.basic_blocks_mut()[BasicBlock::new(0)].statements;\n+        let stmts = &mut body.basic_blocks_mut()[START_BLOCK].statements;\n         stmts.insert(\n             0,\n             Statement {"}, {"sha": "8c6b0463a739a04a0d2b9aa2fbb076948f15520a", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -96,7 +96,7 @@ fn inline<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) -> bool {\n         history: Vec::new(),\n         changed: false,\n     };\n-    let blocks = BasicBlock::new(0)..body.basic_blocks.next_index();\n+    let blocks = START_BLOCK..body.basic_blocks.next_index();\n     this.process_blocks(body, blocks);\n     this.changed\n }\n@@ -900,7 +900,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n \n             let kind = match parent_ty.ty.kind() {\n                 &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                    self.tcx.bound_type_of(def_id).subst(self.tcx, substs).kind()\n+                    self.tcx.type_of(def_id).subst(self.tcx, substs).kind()\n                 }\n                 kind => kind,\n             };"}, {"sha": "0534e688703e53bfe165f8a258c5b739d03b55c9", "filename": "compiler/rustc_mir_transform/src/instcombine.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -110,11 +110,7 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n     fn combine_ref_deref(&self, source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n         if let Rvalue::Ref(_, _, place) = rvalue {\n             if let Some((base, ProjectionElem::Deref)) = place.as_ref().last_projection() {\n-                if let ty::Ref(_, _, Mutability::Not) =\n-                    base.ty(self.local_decls, self.tcx).ty.kind()\n-                {\n-                    // The dereferenced place must have type `&_`, so that we don't copy `&mut _`.\n-                } else {\n+                if rvalue.ty(self.local_decls, self.tcx) != base.ty(self.local_decls, self.tcx).ty {\n                     return;\n                 }\n "}, {"sha": "2ca33a624e20661592a956e4d5c76ca70880ada3", "filename": "compiler/rustc_mir_transform/src/large_enums.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -3,7 +3,7 @@ use crate::MirPass;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::mir::interpret::AllocId;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, AdtDef, Const, ParamEnv, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtDef, ParamEnv, Ty, TyCtxt};\n use rustc_session::Session;\n use rustc_target::abi::{HasDataLayout, Size, TagEncoding, Variants};\n \n@@ -141,10 +141,7 @@ impl EnumSizeOpt {\n                         self.candidate(tcx, param_env, ty, &mut alloc_cache)?;\n                     let alloc = tcx.global_alloc(alloc_id).unwrap_memory();\n \n-                    let tmp_ty = tcx.mk_ty(ty::Array(\n-                        tcx.types.usize,\n-                        Const::from_target_usize(tcx, num_variants as u64),\n-                    ));\n+                    let tmp_ty = tcx.mk_array(tcx.types.usize, num_variants as u64);\n \n                     let size_array_local = local_decls.push(LocalDecl::new(tmp_ty, span));\n                     let store_live = Statement {"}, {"sha": "1becfddb23bd0bb432c8e801ba4b3d34bb6cdb9e", "filename": "compiler/rustc_mir_transform/src/remove_zsts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -13,7 +13,7 @@ impl<'tcx> MirPass<'tcx> for RemoveZsts {\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // Avoid query cycles (generators require optimized MIR for layout).\n-        if tcx.type_of(body.source.def_id()).is_generator() {\n+        if tcx.type_of(body.source.def_id()).subst_identity().is_generator() {\n             return;\n         }\n         let param_env = tcx.param_env(body.source.def_id());"}, {"sha": "682ad081f5cf3fd715a1016c2985d67980aa858c", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -597,7 +597,7 @@ fn build_call_shim<'tcx>(\n         let untuple_args = sig.inputs();\n \n         // Create substitutions for the `Self` and `Args` generic parameters of the shim body.\n-        let arg_tup = tcx.mk_tup(untuple_args.iter());\n+        let arg_tup = tcx.intern_tup(untuple_args);\n \n         (Some([ty.into(), arg_tup.into()]), Some(untuple_args))\n     } else {\n@@ -692,7 +692,7 @@ fn build_call_shim<'tcx>(\n \n         // `FnDef` call with optional receiver.\n         CallKind::Direct(def_id) => {\n-            let ty = tcx.type_of(def_id);\n+            let ty = tcx.type_of(def_id).subst_identity();\n             (\n                 Operand::Constant(Box::new(Constant {\n                     span,"}, {"sha": "9ef55c558c60b8f593024d473d7bd281680c6a39", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -496,7 +496,7 @@ impl UsedLocals {\n         self.increment = false;\n \n         // The location of the statement is irrelevant.\n-        let location = Location { block: START_BLOCK, statement_index: 0 };\n+        let location = Location::START;\n         self.visit_statement(statement, location);\n     }\n "}, {"sha": "c1e7f62dea5c82276ddf7298b16d5f8437bc04e0", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -2,7 +2,7 @@ use either::Either;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::middle::resolve_lifetime::Set1;\n+use rustc_middle::middle::resolve_bound_vars::Set1;\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{ParamEnv, TyCtxt};"}, {"sha": "55a9f912e085880d0b1b1c00ca514123719376cf", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1196,8 +1196,7 @@ impl<'v> RootCollector<'_, 'v> {\n                 {\n                     debug!(\"RootCollector: ADT drop-glue for `{id:?}`\",);\n \n-                    let ty =\n-                        self.tcx.bound_type_of(id.owner_id.to_def_id()).no_bound_vars().unwrap();\n+                    let ty = self.tcx.type_of(id.owner_id.to_def_id()).no_bound_vars().unwrap();\n                     visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n                 }\n             }"}, {"sha": "62bafb981e7782afdf946bb9335ab2c067704111", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -308,7 +308,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n                     let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n                         instance.substs,\n                         ty::ParamEnv::reveal_all(),\n-                        tcx.type_of(impl_def_id),\n+                        tcx.type_of(impl_def_id).skip_binder(),\n                     );\n                     if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n                         return Some(def_id);"}, {"sha": "37449aaabed8ba4e677ff09a12a62a2637ae2849", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -200,16 +200,21 @@ impl<'a> StringReader<'a> {\n                     };\n                     token::Literal(token::Lit { kind, symbol, suffix })\n                 }\n-                rustc_lexer::TokenKind::Lifetime { starts_with_number } => {\n+                rustc_lexer::TokenKind::Lifetime { starts_with_number, contains_emoji } => {\n                     // Include the leading `'` in the real identifier, for macro\n                     // expansion purposes. See #12512 for the gory details of why\n                     // this is necessary.\n                     let lifetime_name = self.str_from(start);\n                     if starts_with_number {\n                         let span = self.mk_sp(start, self.pos);\n-                        let mut diag = self.sess.struct_err(\"lifetimes cannot start with a number\");\n+                        let mut diag = self.sess.struct_err(\"lifetimes or labels cannot start with a number\");\n                         diag.set_span(span);\n                         diag.stash(span, StashKey::LifetimeIsChar);\n+                    } else if contains_emoji {\n+                        let span = self.mk_sp(start, self.pos);\n+                        let mut diag = self.sess.struct_err(\"lifetimes or labels cannot contain emojis\");\n+                        diag.set_span(span);\n+                        diag.stash(span, StashKey::LifetimeContainsEmoji);\n                     }\n                     let ident = Symbol::intern(lifetime_name);\n                     token::Lifetime(ident)"}, {"sha": "a74f408d774120734c8e81c2e99b29223d3d1961", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1283,22 +1283,16 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_delim_args_inner(&mut self) -> Option<DelimArgs> {\n-        if self.check(&token::OpenDelim(Delimiter::Parenthesis))\n+        let delimited = self.check(&token::OpenDelim(Delimiter::Parenthesis))\n             || self.check(&token::OpenDelim(Delimiter::Bracket))\n-            || self.check(&token::OpenDelim(Delimiter::Brace))\n-        {\n-            match self.parse_token_tree() {\n-                // We've confirmed above that there is a delimiter so unwrapping is OK.\n-                TokenTree::Delimited(dspan, delim, tokens) => Some(DelimArgs {\n-                    dspan,\n-                    delim: MacDelimiter::from_token(delim).unwrap(),\n-                    tokens,\n-                }),\n-                _ => unreachable!(),\n-            }\n-        } else {\n-            None\n-        }\n+            || self.check(&token::OpenDelim(Delimiter::Brace));\n+\n+        delimited.then(|| {\n+            // We've confirmed above that there is a delimiter so unwrapping is OK.\n+            let TokenTree::Delimited(dspan, delim, tokens) = self.parse_token_tree() else { unreachable!() };\n+\n+            DelimArgs { dspan, delim: MacDelimiter::from_token(delim).unwrap(), tokens }\n+        })\n     }\n \n     fn parse_or_use_outer_attributes("}, {"sha": "49959a8981c6530283a681920a897bb79fa452e0", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -404,7 +404,7 @@ impl<'a> Parser<'a> {\n \n         let is_first_invocation = style == PathStyle::Expr;\n         // Take a snapshot before attempting to parse - we can restore this later.\n-        let snapshot = if is_first_invocation { Some(self.clone()) } else { None };\n+        let snapshot = is_first_invocation.then(|| self.clone());\n \n         debug!(\"parse_generic_args_with_leading_angle_bracket_recovery: (snapshotting)\");\n         match self.parse_angle_args(ty_generics) {"}, {"sha": "4f4252b532edf7c07cb379755e2149d93f416cdb", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -450,8 +450,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n         let and_span = self.prev_token.span;\n-        let mut opt_lifetime =\n-            if self.check_lifetime() { Some(self.expect_lifetime()) } else { None };\n+        let mut opt_lifetime = self.check_lifetime().then(|| self.expect_lifetime());\n         let mut mutbl = self.parse_mutability();\n         if self.token.is_lifetime() && mutbl == Mutability::Mut && opt_lifetime.is_none() {\n             // A lifetime is invalid here: it would be part of a bare trait bound, which requires\n@@ -871,7 +870,7 @@ impl<'a> Parser<'a> {\n             None\n         };\n \n-        let maybe = if self.eat(&token::Question) { Some(self.prev_token.span) } else { None };\n+        let maybe = self.eat(&token::Question).then_some(self.prev_token.span);\n \n         Ok(BoundModifiers { maybe, maybe_const })\n     }"}, {"sha": "8a3cedfee7952997ec427ac1e748c39991213404", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -835,7 +835,7 @@ impl<'a> Parser<'a> {\n             );\n         }\n \n-        if found { Some(cur) } else { None }\n+        found.then_some(cur)\n     }\n \n     fn suggest_format(&mut self) {"}, {"sha": "8ad4a5ef95813355fb6e007da8f168cea9fceeb1", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -18,7 +18,7 @@ use rustc_hir::{\n };\n use rustc_hir::{MethodKind, Target, Unsafety};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n+use rustc_middle::middle::resolve_bound_vars::ObjectLifetimeDefault;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{ParamEnv, TyCtxt};\n@@ -2174,7 +2174,7 @@ impl CheckAttrVisitor<'_> {\n         let tcx = self.tcx;\n         if target == Target::Fn {\n             let Some(tokenstream) = tcx.get_diagnostic_item(sym::TokenStream) else {return};\n-            let tokenstream = tcx.type_of(tokenstream);\n+            let tokenstream = tcx.type_of(tokenstream).subst_identity();\n \n             let id = hir_id.expect_owner();\n             let hir_sig = tcx.hir().fn_sig_by_hir_id(hir_id).unwrap();"}, {"sha": "668c159f3cc5ba5ff0fd473e4955c4c550c59064", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -315,7 +315,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n                     //// This is done to handle the case where, for example, the static\n                     //// method of a private type is used, but the type itself is never\n                     //// called directly.\n-                    let self_ty = self.tcx.type_of(item);\n+                    let self_ty = self.tcx.type_of(item).subst_identity();\n                     match *self_ty.kind() {\n                         ty::Adt(def, _) => self.check_def_id(def.did()),\n                         ty::Foreign(did) => self.check_def_id(did),\n@@ -654,7 +654,7 @@ impl<'tcx> DeadVisitor<'tcx> {\n         if self.live_symbols.contains(&field.did.expect_local()) {\n             return ShouldWarnAboutField::No;\n         }\n-        let field_type = self.tcx.type_of(field.did);\n+        let field_type = self.tcx.type_of(field.did).subst_identity();\n         if field_type.is_phantom_data() {\n             return ShouldWarnAboutField::No;\n         }"}, {"sha": "0ae7096642cf164fcfa4e5d2907b496b96058290", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -32,11 +32,8 @@ fn collect_item(tcx: TyCtxt<'_>, items: &mut DiagnosticItems, name: Symbol, item\n     if let Some(original_def_id) = items.name_to_id.insert(name, item_def_id) {\n         if original_def_id != item_def_id {\n             let orig_span = tcx.hir().span_if_local(original_def_id);\n-            let orig_crate_name = if orig_span.is_some() {\n-                None\n-            } else {\n-                Some(tcx.crate_name(original_def_id.krate))\n-            };\n+            let orig_crate_name =\n+                orig_span.is_none().then(|| tcx.crate_name(original_def_id.krate));\n             match tcx.hir().span_if_local(item_def_id) {\n                 Some(span) => tcx.sess.emit_err(DuplicateDiagnosticItem { span, name }),\n                 None => tcx.sess.emit_err(DuplicateDiagnosticItemInCrate {"}, {"sha": "047b9b525e8540e3b85358ee9ffe1c2ed8393470", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -29,7 +29,7 @@ pub fn test_layout(tcx: TyCtxt<'_>) {\n fn dump_layout_of(tcx: TyCtxt<'_>, item_def_id: LocalDefId, attr: &Attribute) {\n     let tcx = tcx;\n     let param_env = tcx.param_env(item_def_id);\n-    let ty = tcx.type_of(item_def_id);\n+    let ty = tcx.type_of(item_def_id).subst_identity();\n     match tcx.layout_of(param_env.and(ty)) {\n         Ok(ty_layout) => {\n             // Check out the `#[rustc_layout(..)]` attribute to tell what to dump."}, {"sha": "2e736039fb597f1f7a054a96917dc3a8eca38e0b", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -281,7 +281,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         self.recurse_with_stability_attrs(\n             depr.map(|(d, _)| DeprecationEntry::local(d, def_id)),\n             stab,\n-            if inherit_const_stability.yes() { const_stab } else { None },\n+            inherit_const_stability.yes().then_some(const_stab).flatten(),\n             visit_children,\n         );\n     }"}, {"sha": "58dfca75c65f7188d6ae6be8a11847042101740b", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -159,9 +159,21 @@ where\n                 _region,\n             ))) => ty.visit_with(self),\n             ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..)) => ControlFlow::Continue(()),\n+            ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                ct.visit_with(self)?;\n+                ty.visit_with(self)\n+            }\n             ty::PredicateKind::ConstEvaluatable(ct) => ct.visit_with(self),\n             ty::PredicateKind::WellFormed(arg) => arg.visit_with(self),\n-            _ => bug!(\"unexpected predicate: {:?}\", predicate),\n+\n+            ty::PredicateKind::ObjectSafe(_)\n+            | ty::PredicateKind::ClosureKind(_, _, _)\n+            | ty::PredicateKind::Subtype(_)\n+            | ty::PredicateKind::Coerce(_)\n+            | ty::PredicateKind::ConstEquate(_, _)\n+            | ty::PredicateKind::TypeWellFormedFromEnv(_)\n+            | ty::PredicateKind::Ambiguous\n+            | ty::PredicateKind::AliasEq(_, _) => bug!(\"unexpected predicate: {:?}\", predicate),\n         }\n     }\n \n@@ -207,7 +219,7 @@ where\n                 // so we need to visit the self type additionally.\n                 if let Some(assoc_item) = tcx.opt_associated_item(def_id) {\n                     if let Some(impl_def_id) = assoc_item.impl_container(tcx) {\n-                        tcx.type_of(impl_def_id).visit_with(self)?;\n+                        tcx.type_of(impl_def_id).subst_identity().visit_with(self)?;\n                     }\n                 }\n             }\n@@ -270,10 +282,11 @@ where\n             | ty::Ref(..)\n             | ty::FnPtr(..)\n             | ty::Param(..)\n+            | ty::Bound(..)\n             | ty::Error(_)\n             | ty::GeneratorWitness(..)\n             | ty::GeneratorWitnessMIR(..) => {}\n-            ty::Bound(..) | ty::Placeholder(..) | ty::Infer(..) => {\n+            ty::Placeholder(..) | ty::Infer(..) => {\n                 bug!(\"unexpected type: {:?}\", ty)\n             }\n         }\n@@ -341,7 +354,7 @@ trait VisibilityLike: Sized {\n         effective_visibilities: &EffectiveVisibilities,\n     ) -> Self {\n         let mut find = FindMin { tcx, effective_visibilities, min: Self::MAX };\n-        find.visit(tcx.type_of(def_id));\n+        find.visit(tcx.type_of(def_id).subst_identity());\n         if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n             find.visit_trait(trait_ref.subst_identity());\n         }\n@@ -837,11 +850,11 @@ impl ReachEverythingInTheInterfaceVisitor<'_, '_> {\n                 GenericParamDefKind::Lifetime => {}\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     if has_default {\n-                        self.visit(self.ev.tcx.type_of(param.def_id));\n+                        self.visit(self.ev.tcx.type_of(param.def_id).subst_identity());\n                     }\n                 }\n                 GenericParamDefKind::Const { has_default } => {\n-                    self.visit(self.ev.tcx.type_of(param.def_id));\n+                    self.visit(self.ev.tcx.type_of(param.def_id).subst_identity());\n                     if has_default {\n                         self.visit(self.ev.tcx.const_param_default(param.def_id).subst_identity());\n                     }\n@@ -857,7 +870,7 @@ impl ReachEverythingInTheInterfaceVisitor<'_, '_> {\n     }\n \n     fn ty(&mut self) -> &mut Self {\n-        self.visit(self.ev.tcx.type_of(self.item_def_id));\n+        self.visit(self.ev.tcx.type_of(self.item_def_id).subst_identity());\n         self\n     }\n \n@@ -1268,7 +1281,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                 // Method calls have to be checked specially.\n                 self.span = segment.ident.span;\n                 if let Some(def_id) = self.typeck_results().type_dependent_def_id(expr.hir_id) {\n-                    if self.visit(self.tcx.type_of(def_id)).is_break() {\n+                    if self.visit(self.tcx.type_of(def_id).subst_identity()).is_break() {\n                         return;\n                     }\n                 } else {\n@@ -1742,12 +1755,12 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n                 GenericParamDefKind::Lifetime => {}\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     if has_default {\n-                        self.visit(self.tcx.type_of(param.def_id));\n+                        self.visit(self.tcx.type_of(param.def_id).subst_identity());\n                     }\n                 }\n                 // FIXME(generic_const_exprs): May want to look inside const here\n                 GenericParamDefKind::Const { .. } => {\n-                    self.visit(self.tcx.type_of(param.def_id));\n+                    self.visit(self.tcx.type_of(param.def_id).subst_identity());\n                 }\n             }\n         }\n@@ -1774,7 +1787,7 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n     }\n \n     fn ty(&mut self) -> &mut Self {\n-        self.visit(self.tcx.type_of(self.item_def_id));\n+        self.visit(self.tcx.type_of(self.item_def_id).subst_identity());\n         self\n     }\n "}, {"sha": "d7708a3bc3f42a59147006b024fbc0b7f56f5bb1", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -21,7 +21,9 @@ use rustc_data_structures::sync::AtomicU64;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::{self, DepKindStruct};\n use rustc_middle::query::Key;\n-use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_values};\n+use rustc_middle::ty::query::{\n+    query_keys, query_provided, query_provided_to_value, query_storage, query_values,\n+};\n use rustc_middle::ty::query::{ExternProviders, Providers, QueryEngine};\n use rustc_middle::ty::TyCtxt;\n use rustc_span::Span;"}, {"sha": "e2884f2026eb0c1fd36edd0c3cd5fa7521a867a9", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> HasDepContext for QueryCtxt<'tcx> {\n }\n \n impl QueryContext for QueryCtxt<'_> {\n-    fn next_job_id(&self) -> QueryJobId {\n+    fn next_job_id(self) -> QueryJobId {\n         QueryJobId(\n             NonZeroU64::new(\n                 self.queries.jobs.fetch_add(1, rustc_data_structures::sync::Ordering::Relaxed),\n@@ -62,31 +62,31 @@ impl QueryContext for QueryCtxt<'_> {\n         )\n     }\n \n-    fn current_query_job(&self) -> Option<QueryJobId> {\n-        tls::with_related_context(**self, |icx| icx.query)\n+    fn current_query_job(self) -> Option<QueryJobId> {\n+        tls::with_related_context(*self, |icx| icx.query)\n     }\n \n-    fn try_collect_active_jobs(&self) -> Option<QueryMap<DepKind>> {\n-        self.queries.try_collect_active_jobs(**self)\n+    fn try_collect_active_jobs(self) -> Option<QueryMap<DepKind>> {\n+        self.queries.try_collect_active_jobs(*self)\n     }\n \n     // Interactions with on_disk_cache\n-    fn load_side_effects(&self, prev_dep_node_index: SerializedDepNodeIndex) -> QuerySideEffects {\n+    fn load_side_effects(self, prev_dep_node_index: SerializedDepNodeIndex) -> QuerySideEffects {\n         self.queries\n             .on_disk_cache\n             .as_ref()\n-            .map(|c| c.load_side_effects(**self, prev_dep_node_index))\n+            .map(|c| c.load_side_effects(*self, prev_dep_node_index))\n             .unwrap_or_default()\n     }\n \n-    fn store_side_effects(&self, dep_node_index: DepNodeIndex, side_effects: QuerySideEffects) {\n+    fn store_side_effects(self, dep_node_index: DepNodeIndex, side_effects: QuerySideEffects) {\n         if let Some(c) = self.queries.on_disk_cache.as_ref() {\n             c.store_side_effects(dep_node_index, side_effects)\n         }\n     }\n \n     fn store_side_effects_for_anon_node(\n-        &self,\n+        self,\n         dep_node_index: DepNodeIndex,\n         side_effects: QuerySideEffects,\n     ) {\n@@ -100,7 +100,7 @@ impl QueryContext for QueryCtxt<'_> {\n     /// captured during execution and the actual result.\n     #[inline(always)]\n     fn start_query<R>(\n-        &self,\n+        self,\n         token: QueryJobId,\n         depth_limit: bool,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n@@ -109,14 +109,14 @@ impl QueryContext for QueryCtxt<'_> {\n         // The `TyCtxt` stored in TLS has the same global interner lifetime\n         // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes\n         // when accessing the `ImplicitCtxt`.\n-        tls::with_related_context(**self, move |current_icx| {\n+        tls::with_related_context(*self, move |current_icx| {\n             if depth_limit && !self.recursion_limit().value_within_limit(current_icx.query_depth) {\n                 self.depth_limit_error(token);\n             }\n \n             // Update the `ImplicitCtxt` to point to our new query job.\n             let new_icx = ImplicitCtxt {\n-                tcx: **self,\n+                tcx: *self,\n                 query: Some(token),\n                 diagnostics,\n                 query_depth: current_icx.query_depth + depth_limit as usize,\n@@ -130,7 +130,7 @@ impl QueryContext for QueryCtxt<'_> {\n         })\n     }\n \n-    fn depth_limit_error(&self, job: QueryJobId) {\n+    fn depth_limit_error(self, job: QueryJobId) {\n         let mut span = None;\n         let mut layout_of_depth = None;\n         if let Some(map) = self.try_collect_active_jobs() {\n@@ -293,14 +293,14 @@ macro_rules! get_provider {\n }\n \n macro_rules! should_ever_cache_on_disk {\n-    ([]) => {{\n-        None\n+    ([]$yes:tt $no:tt) => {{\n+        $no\n     }};\n-    ([(cache) $($rest:tt)*]) => {{\n-        Some($crate::plumbing::try_load_from_disk::<Self::Value>)\n+    ([(cache) $($rest:tt)*]$yes:tt $no:tt) => {{\n+        $yes\n     }};\n-    ([$other:tt $($modifiers:tt)*]) => {\n-        should_ever_cache_on_disk!([$($modifiers)*])\n+    ([$other:tt $($modifiers:tt)*]$yes:tt $no:tt) => {\n+        should_ever_cache_on_disk!([$($modifiers)*]$yes $no)\n     };\n }\n \n@@ -472,7 +472,6 @@ macro_rules! define_queries {\n         $(impl<'tcx> QueryConfig<QueryCtxt<'tcx>> for queries::$name<'tcx> {\n             type Key = query_keys::$name<'tcx>;\n             type Value = query_values::$name<'tcx>;\n-            type Stored = query_stored::$name<'tcx>;\n             const NAME: &'static str = stringify!($name);\n \n             #[inline]\n@@ -493,24 +492,39 @@ macro_rules! define_queries {\n             fn query_cache<'a>(tcx: QueryCtxt<'tcx>) -> &'a Self::Cache\n                 where 'tcx:'a\n             {\n-                &tcx.query_caches.$name\n+                &tcx.query_system.caches.$name\n             }\n \n-            fn execute_query(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Stored {\n+            fn execute_query(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n                 tcx.$name(key)\n             }\n \n             #[inline]\n-            // key is only sometimes used\n             #[allow(unused_variables)]\n-            fn compute(qcx: QueryCtxt<'tcx>, key: &Self::Key) -> fn(TyCtxt<'tcx>, Self::Key) -> Self::Value {\n-                get_provider!([$($modifiers)*][qcx, $name, key])\n+            fn compute(qcx: QueryCtxt<'tcx>, key: Self::Key) -> Self::Value {\n+                query_provided_to_value::$name(\n+                    qcx.tcx,\n+                    get_provider!([$($modifiers)*][qcx, $name, key])(qcx.tcx, key)\n+                )\n             }\n \n             #[inline]\n-            fn try_load_from_disk(qcx: QueryCtxt<'tcx>, key: &Self::Key) -> rustc_query_system::query::TryLoadFromDisk<QueryCtxt<'tcx>, Self> {\n-                let cache_on_disk = Self::cache_on_disk(qcx.tcx, key);\n-                if cache_on_disk { should_ever_cache_on_disk!([$($modifiers)*]) } else { None }\n+            fn try_load_from_disk(_qcx: QueryCtxt<'tcx>, _key: &Self::Key) -> rustc_query_system::query::TryLoadFromDisk<QueryCtxt<'tcx>, Self> {\n+                should_ever_cache_on_disk!([$($modifiers)*] {\n+                    if Self::cache_on_disk(_qcx.tcx, _key) {\n+                        Some(|qcx: QueryCtxt<'tcx>, dep_node| {\n+                            let value = $crate::plumbing::try_load_from_disk::<query_provided::$name<'tcx>>(\n+                                qcx,\n+                                dep_node\n+                            );\n+                            value.map(|value| query_provided_to_value::$name(qcx.tcx, value))\n+                        })\n+                    } else {\n+                        None\n+                    }\n+                } {\n+                    None\n+                })\n             }\n \n             const ANON: bool = is_anon!([$($modifiers)*]);\n@@ -633,7 +647,7 @@ macro_rules! define_queries {\n                     $crate::profiling_support::alloc_self_profile_query_strings_for_query_cache(\n                         tcx,\n                         stringify!($name),\n-                        &tcx.query_caches.$name,\n+                        &tcx.query_system.caches.$name,\n                         string_cache,\n                     )\n                 },\n@@ -725,7 +739,7 @@ macro_rules! define_queries_struct {\n                 span: Span,\n                 key: <queries::$name<'tcx> as QueryConfig<QueryCtxt<'tcx>>>::Key,\n                 mode: QueryMode,\n-            ) -> Option<query_stored::$name<'tcx>> {\n+            ) -> Option<query_values::$name<'tcx>> {\n                 let qcx = QueryCtxt { tcx, queries: self };\n                 get_query::<queries::$name<'tcx>, _, rustc_middle::dep_graph::DepKind>(qcx, span, key, mode)\n             })*"}, {"sha": "6969f2dbef8b821a125c88fea022029d900a28b8", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -23,7 +23,7 @@ pub trait DepContext: Copy {\n     type DepKind: self::DepKind;\n \n     /// Create a hashing context for hashing new results.\n-    fn with_stable_hashing_context<R>(&self, f: impl FnOnce(StableHashingContext<'_>) -> R) -> R;\n+    fn with_stable_hashing_context<R>(self, f: impl FnOnce(StableHashingContext<'_>) -> R) -> R;\n \n     /// Access the DepGraph.\n     fn dep_graph(&self) -> &DepGraph<Self::DepKind>;\n@@ -37,7 +37,7 @@ pub trait DepContext: Copy {\n     fn dep_kind_info(&self, dep_node: Self::DepKind) -> &DepKindStruct<Self>;\n \n     #[inline(always)]\n-    fn fingerprint_style(&self, kind: Self::DepKind) -> FingerprintStyle {\n+    fn fingerprint_style(self, kind: Self::DepKind) -> FingerprintStyle {\n         let data = self.dep_kind_info(kind);\n         if data.is_anon {\n             return FingerprintStyle::Opaque;\n@@ -47,7 +47,7 @@ pub trait DepContext: Copy {\n \n     #[inline(always)]\n     /// Return whether this kind always require evaluation.\n-    fn is_eval_always(&self, kind: Self::DepKind) -> bool {\n+    fn is_eval_always(self, kind: Self::DepKind) -> bool {\n         self.dep_kind_info(kind).is_eval_always\n     }\n "}, {"sha": "29513df460fffe081624257ed65631265f607191", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -242,8 +242,7 @@ impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n         record_graph: bool,\n         record_stats: bool,\n     ) -> Self {\n-        let record_graph =\n-            if record_graph { Some(Lock::new(DepGraphQuery::new(prev_node_count))) } else { None };\n+        let record_graph = record_graph.then(|| Lock::new(DepGraphQuery::new(prev_node_count)));\n         let status = Lock::new(EncoderState::new(encoder, record_stats));\n         GraphEncoder { status, record_graph }\n     }"}, {"sha": "e840108bdd86925979115f3a2a11a098dd4a9ef4", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 6, "deletions": 165, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1,12 +1,10 @@\n use crate::dep_graph::DepNodeIndex;\n \n-use rustc_arena::TypedArena;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sharded;\n #[cfg(parallel_compiler)]\n use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::sync::WorkerLocal;\n use rustc_index::vec::{Idx, IndexVec};\n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -16,12 +14,10 @@ pub trait CacheSelector<'tcx, V> {\n     type Cache\n     where\n         V: Copy;\n-    type ArenaCache;\n }\n \n pub trait QueryStorage {\n-    type Value: Debug;\n-    type Stored: Copy;\n+    type Value: Copy;\n }\n \n pub trait QueryCache: QueryStorage + Sized {\n@@ -31,9 +27,9 @@ pub trait QueryCache: QueryStorage + Sized {\n     /// It returns the shard index and a lock guard to the shard,\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n-    fn lookup(&self, key: &Self::Key) -> Option<(Self::Stored, DepNodeIndex)>;\n+    fn lookup(&self, key: &Self::Key) -> Option<(Self::Value, DepNodeIndex)>;\n \n-    fn complete(&self, key: Self::Key, value: Self::Value, index: DepNodeIndex) -> Self::Stored;\n+    fn complete(&self, key: Self::Key, value: Self::Value, index: DepNodeIndex);\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex));\n }\n@@ -44,7 +40,6 @@ impl<'tcx, K: Eq + Hash, V: 'tcx> CacheSelector<'tcx, V> for DefaultCacheSelecto\n     type Cache = DefaultCache<K, V>\n     where\n         V: Copy;\n-    type ArenaCache = ArenaCache<'tcx, K, V>;\n }\n \n pub struct DefaultCache<K, V> {\n@@ -62,7 +57,6 @@ impl<K, V> Default for DefaultCache<K, V> {\n \n impl<K: Eq + Hash, V: Copy + Debug> QueryStorage for DefaultCache<K, V> {\n     type Value = V;\n-    type Stored = V;\n }\n \n impl<K, V> QueryCache for DefaultCache<K, V>\n@@ -85,15 +79,14 @@ where\n     }\n \n     #[inline]\n-    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n+    fn complete(&self, key: K, value: V, index: DepNodeIndex) {\n         #[cfg(parallel_compiler)]\n         let mut lock = self.cache.get_shard_by_value(&key).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n         // We may be overwriting another value. This is all right, since the dep-graph\n         // will check that the fingerprint matches.\n         lock.insert(key, (value, index));\n-        value\n     }\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n@@ -122,7 +115,6 @@ impl<'tcx, V: 'tcx> CacheSelector<'tcx, V> for SingleCacheSelector {\n     type Cache = SingleCache<V>\n     where\n         V: Copy;\n-    type ArenaCache = ArenaCache<'tcx, (), V>;\n }\n \n pub struct SingleCache<V> {\n@@ -137,7 +129,6 @@ impl<V> Default for SingleCache<V> {\n \n impl<V: Copy + Debug> QueryStorage for SingleCache<V> {\n     type Value = V;\n-    type Stored = V;\n }\n \n impl<V> QueryCache for SingleCache<V>\n@@ -152,95 +143,21 @@ where\n     }\n \n     #[inline]\n-    fn complete(&self, _key: (), value: V, index: DepNodeIndex) -> Self::Stored {\n+    fn complete(&self, _key: (), value: V, index: DepNodeIndex) {\n         *self.cache.lock() = Some((value, index));\n-        value\n     }\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n         self.cache.lock().as_ref().map(|value| f(&(), &value.0, value.1));\n     }\n }\n \n-pub struct ArenaCache<'tcx, K, V> {\n-    arena: WorkerLocal<TypedArena<(V, DepNodeIndex)>>,\n-    #[cfg(parallel_compiler)]\n-    cache: Sharded<FxHashMap<K, &'tcx (V, DepNodeIndex)>>,\n-    #[cfg(not(parallel_compiler))]\n-    cache: Lock<FxHashMap<K, &'tcx (V, DepNodeIndex)>>,\n-}\n-\n-impl<'tcx, K, V> Default for ArenaCache<'tcx, K, V> {\n-    fn default() -> Self {\n-        ArenaCache { arena: WorkerLocal::new(|_| TypedArena::default()), cache: Default::default() }\n-    }\n-}\n-\n-impl<'tcx, K: Eq + Hash, V: Debug + 'tcx> QueryStorage for ArenaCache<'tcx, K, V> {\n-    type Value = V;\n-    type Stored = &'tcx V;\n-}\n-\n-impl<'tcx, K, V: 'tcx> QueryCache for ArenaCache<'tcx, K, V>\n-where\n-    K: Eq + Hash + Clone + Debug,\n-    V: Debug,\n-{\n-    type Key = K;\n-\n-    #[inline(always)]\n-    fn lookup(&self, key: &K) -> Option<(&'tcx V, DepNodeIndex)> {\n-        let key_hash = sharded::make_hash(key);\n-        #[cfg(parallel_compiler)]\n-        let lock = self.cache.get_shard_by_hash(key_hash).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let lock = self.cache.lock();\n-        let result = lock.raw_entry().from_key_hashed_nocheck(key_hash, key);\n-\n-        if let Some((_, value)) = result { Some((&value.0, value.1)) } else { None }\n-    }\n-\n-    #[inline]\n-    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n-        let value = self.arena.alloc((value, index));\n-        let value = unsafe { &*(value as *const _) };\n-        #[cfg(parallel_compiler)]\n-        let mut lock = self.cache.get_shard_by_value(&key).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let mut lock = self.cache.lock();\n-        // We may be overwriting another value. This is all right, since the dep-graph\n-        // will check that the fingerprint matches.\n-        lock.insert(key, value);\n-        &value.0\n-    }\n-\n-    fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n-        #[cfg(parallel_compiler)]\n-        {\n-            let shards = self.cache.lock_shards();\n-            for shard in shards.iter() {\n-                for (k, v) in shard.iter() {\n-                    f(k, &v.0, v.1);\n-                }\n-            }\n-        }\n-        #[cfg(not(parallel_compiler))]\n-        {\n-            let map = self.cache.lock();\n-            for (k, v) in map.iter() {\n-                f(k, &v.0, v.1);\n-            }\n-        }\n-    }\n-}\n-\n pub struct VecCacheSelector<K>(PhantomData<K>);\n \n impl<'tcx, K: Idx, V: 'tcx> CacheSelector<'tcx, V> for VecCacheSelector<K> {\n     type Cache = VecCache<K, V>\n     where\n         V: Copy;\n-    type ArenaCache = VecArenaCache<'tcx, K, V>;\n }\n \n pub struct VecCache<K: Idx, V> {\n@@ -258,7 +175,6 @@ impl<K: Idx, V> Default for VecCache<K, V> {\n \n impl<K: Eq + Idx, V: Copy + Debug> QueryStorage for VecCache<K, V> {\n     type Value = V;\n-    type Stored = V;\n }\n \n impl<K, V> QueryCache for VecCache<K, V>\n@@ -278,87 +194,12 @@ where\n     }\n \n     #[inline]\n-    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n+    fn complete(&self, key: K, value: V, index: DepNodeIndex) {\n         #[cfg(parallel_compiler)]\n         let mut lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n         lock.insert(key, (value, index));\n-        value\n-    }\n-\n-    fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n-        #[cfg(parallel_compiler)]\n-        {\n-            let shards = self.cache.lock_shards();\n-            for shard in shards.iter() {\n-                for (k, v) in shard.iter_enumerated() {\n-                    if let Some(v) = v {\n-                        f(&k, &v.0, v.1);\n-                    }\n-                }\n-            }\n-        }\n-        #[cfg(not(parallel_compiler))]\n-        {\n-            let map = self.cache.lock();\n-            for (k, v) in map.iter_enumerated() {\n-                if let Some(v) = v {\n-                    f(&k, &v.0, v.1);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub struct VecArenaCache<'tcx, K: Idx, V> {\n-    arena: WorkerLocal<TypedArena<(V, DepNodeIndex)>>,\n-    #[cfg(parallel_compiler)]\n-    cache: Sharded<IndexVec<K, Option<&'tcx (V, DepNodeIndex)>>>,\n-    #[cfg(not(parallel_compiler))]\n-    cache: Lock<IndexVec<K, Option<&'tcx (V, DepNodeIndex)>>>,\n-}\n-\n-impl<'tcx, K: Idx, V> Default for VecArenaCache<'tcx, K, V> {\n-    fn default() -> Self {\n-        VecArenaCache {\n-            arena: WorkerLocal::new(|_| TypedArena::default()),\n-            cache: Default::default(),\n-        }\n-    }\n-}\n-\n-impl<'tcx, K: Eq + Idx, V: Debug + 'tcx> QueryStorage for VecArenaCache<'tcx, K, V> {\n-    type Value = V;\n-    type Stored = &'tcx V;\n-}\n-\n-impl<'tcx, K, V: 'tcx> QueryCache for VecArenaCache<'tcx, K, V>\n-where\n-    K: Eq + Idx + Clone + Debug,\n-    V: Debug,\n-{\n-    type Key = K;\n-\n-    #[inline(always)]\n-    fn lookup(&self, key: &K) -> Option<(&'tcx V, DepNodeIndex)> {\n-        #[cfg(parallel_compiler)]\n-        let lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let lock = self.cache.lock();\n-        if let Some(Some(value)) = lock.get(*key) { Some((&value.0, value.1)) } else { None }\n-    }\n-\n-    #[inline]\n-    fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n-        let value = self.arena.alloc((value, index));\n-        let value = unsafe { &*(value as *const _) };\n-        #[cfg(parallel_compiler)]\n-        let mut lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n-        #[cfg(not(parallel_compiler))]\n-        let mut lock = self.cache.lock();\n-        lock.insert(key, value);\n-        &value.0\n     }\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {"}, {"sha": "56247e827a2da25ae3ef8abcca70b54bb72f3bbc", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -20,10 +20,9 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     const NAME: &'static str;\n \n     type Key: DepNodeParams<Qcx::DepContext> + Eq + Hash + Clone + Debug;\n-    type Value: Debug;\n-    type Stored: Debug + Copy + std::borrow::Borrow<Self::Value>;\n+    type Value: Debug + Copy;\n \n-    type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n+    type Cache: QueryCache<Key = Self::Key, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n     fn query_state<'a>(tcx: Qcx) -> &'a QueryState<Self::Key, Qcx::DepKind>\n@@ -38,9 +37,9 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     fn cache_on_disk(tcx: Qcx::DepContext, key: &Self::Key) -> bool;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn execute_query(tcx: Qcx::DepContext, k: Self::Key) -> Self::Stored;\n+    fn execute_query(tcx: Qcx::DepContext, k: Self::Key) -> Self::Value;\n \n-    fn compute(tcx: Qcx, key: &Self::Key) -> fn(Qcx::DepContext, Self::Key) -> Self::Value;\n+    fn compute(tcx: Qcx, key: Self::Key) -> Self::Value;\n \n     fn try_load_from_disk(qcx: Qcx, idx: &Self::Key) -> TryLoadFromDisk<Qcx, Self>;\n "}, {"sha": "383c63cd2f8a75b500247eead1a9714524d4e52e", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -101,22 +101,22 @@ impl QuerySideEffects {\n }\n \n pub trait QueryContext: HasDepContext {\n-    fn next_job_id(&self) -> QueryJobId;\n+    fn next_job_id(self) -> QueryJobId;\n \n     /// Get the query information from the TLS context.\n-    fn current_query_job(&self) -> Option<QueryJobId>;\n+    fn current_query_job(self) -> Option<QueryJobId>;\n \n-    fn try_collect_active_jobs(&self) -> Option<QueryMap<Self::DepKind>>;\n+    fn try_collect_active_jobs(self) -> Option<QueryMap<Self::DepKind>>;\n \n     /// Load side effects associated to the node in the previous session.\n-    fn load_side_effects(&self, prev_dep_node_index: SerializedDepNodeIndex) -> QuerySideEffects;\n+    fn load_side_effects(self, prev_dep_node_index: SerializedDepNodeIndex) -> QuerySideEffects;\n \n     /// Register diagnostics for the given node, for use in next session.\n-    fn store_side_effects(&self, dep_node_index: DepNodeIndex, side_effects: QuerySideEffects);\n+    fn store_side_effects(self, dep_node_index: DepNodeIndex, side_effects: QuerySideEffects);\n \n     /// Register diagnostics for the given node, for use in next session.\n     fn store_side_effects_for_anon_node(\n-        &self,\n+        self,\n         dep_node_index: DepNodeIndex,\n         side_effects: QuerySideEffects,\n     );\n@@ -125,12 +125,12 @@ pub trait QueryContext: HasDepContext {\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result.\n     fn start_query<R>(\n-        &self,\n+        self,\n         token: QueryJobId,\n         depth_limit: bool,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n         compute: impl FnOnce() -> R,\n     ) -> R;\n \n-    fn depth_limit_error(&self, job: QueryJobId);\n+    fn depth_limit_error(self, job: QueryJobId);\n }"}, {"sha": "53e04bcc132a07214f2d5403a5199598c476571a", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 26, "deletions": 47, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -19,7 +19,6 @@ use rustc_data_structures::sync::Lock;\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, FatalError};\n use rustc_session::Session;\n use rustc_span::{Span, DUMMY_SP};\n-use std::borrow::Borrow;\n use std::cell::Cell;\n use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n@@ -246,7 +245,7 @@ where\n \n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n-    fn complete<C>(self, cache: &C, result: C::Value, dep_node_index: DepNodeIndex) -> C::Stored\n+    fn complete<C>(self, cache: &C, result: C::Value, dep_node_index: DepNodeIndex)\n     where\n         C: QueryCache<Key = K>,\n     {\n@@ -257,23 +256,19 @@ where\n         // Forget ourself so our destructor won't poison the query\n         mem::forget(self);\n \n-        let (job, result) = {\n-            let job = {\n-                #[cfg(parallel_compiler)]\n-                let mut lock = state.active.get_shard_by_value(&key).lock();\n-                #[cfg(not(parallel_compiler))]\n-                let mut lock = state.active.lock();\n-                match lock.remove(&key).unwrap() {\n-                    QueryResult::Started(job) => job,\n-                    QueryResult::Poisoned => panic!(),\n-                }\n-            };\n-            let result = cache.complete(key, result, dep_node_index);\n-            (job, result)\n+        let job = {\n+            #[cfg(parallel_compiler)]\n+            let mut lock = state.active.get_shard_by_value(&key).lock();\n+            #[cfg(not(parallel_compiler))]\n+            let mut lock = state.active.lock();\n+            match lock.remove(&key).unwrap() {\n+                QueryResult::Started(job) => job,\n+                QueryResult::Poisoned => panic!(),\n+            }\n         };\n+        cache.complete(key, result, dep_node_index);\n \n         job.signal_complete();\n-        result\n     }\n }\n \n@@ -336,7 +331,7 @@ where\n /// which will be used if the query is not in the cache and we need\n /// to compute it.\n #[inline]\n-pub fn try_get_cached<Tcx, C>(tcx: Tcx, cache: &C, key: &C::Key) -> Option<C::Stored>\n+pub fn try_get_cached<Tcx, C>(tcx: Tcx, cache: &C, key: &C::Key) -> Option<C::Value>\n where\n     C: QueryCache,\n     Tcx: DepContext,\n@@ -358,7 +353,7 @@ fn try_execute_query<Q, Qcx>(\n     span: Span,\n     key: Q::Key,\n     dep_node: Option<DepNode<Qcx::DepKind>>,\n-) -> (Q::Stored, Option<DepNodeIndex>)\n+) -> (Q::Value, Option<DepNodeIndex>)\n where\n     Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n@@ -368,29 +363,17 @@ where\n             let (result, dep_node_index) =\n                 execute_job::<Q, Qcx>(qcx, key.clone(), dep_node, job.id);\n             if Q::FEEDABLE {\n-                // We may have put a value inside the cache from inside the execution.\n-                // Verify that it has the same hash as what we have now, to ensure consistency.\n+                // We should not compute queries that also got a value via feeding.\n+                // This can't happen, as query feeding adds the very dependencies to the fed query\n+                // as its feeding query had. So if the fed query is red, so is its feeder, which will\n+                // get evaluated first, and re-feed the query.\n                 if let Some((cached_result, _)) = cache.lookup(&key) {\n-                    let hasher = Q::HASH_RESULT.expect(\"feedable forbids no_hash\");\n-\n-                    let old_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n-                        hasher(&mut hcx, cached_result.borrow())\n-                    });\n-                    let new_hash = qcx\n-                        .dep_context()\n-                        .with_stable_hashing_context(|mut hcx| hasher(&mut hcx, &result));\n-                    debug_assert_eq!(\n-                        old_hash,\n-                        new_hash,\n-                        \"Computed query value for {:?}({:?}) is inconsistent with fed value,\\ncomputed={:#?}\\nfed={:#?}\",\n-                        Q::DEP_KIND,\n-                        key,\n-                        result,\n-                        cached_result,\n+                    panic!(\n+                        \"fed query later has its value computed. The already cached value: {cached_result:?}\"\n                     );\n                 }\n             }\n-            let result = job.complete(cache, result, dep_node_index);\n+            job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n         }\n         TryGetJob::Cycle(error) => {\n@@ -426,9 +409,7 @@ where\n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n         let prof_timer = qcx.dep_context().profiler().query_provider();\n-        let result = qcx.start_query(job_id, Q::DEPTH_LIMIT, None, || {\n-            Q::compute(qcx, &key)(*qcx.dep_context(), key)\n-        });\n+        let result = qcx.start_query(job_id, Q::DEPTH_LIMIT, None, || Q::compute(qcx, key));\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n         return (result, dep_node_index);\n@@ -454,17 +435,15 @@ where\n     let (result, dep_node_index) =\n         qcx.start_query(job_id, Q::DEPTH_LIMIT, Some(&diagnostics), || {\n             if Q::ANON {\n-                return dep_graph.with_anon_task(*qcx.dep_context(), Q::DEP_KIND, || {\n-                    Q::compute(qcx, &key)(*qcx.dep_context(), key)\n-                });\n+                return dep_graph\n+                    .with_anon_task(*qcx.dep_context(), Q::DEP_KIND, || Q::compute(qcx, key));\n             }\n \n             // `to_dep_node` is expensive for some `DepKind`s.\n             let dep_node =\n                 dep_node_opt.unwrap_or_else(|| Q::construct_dep_node(*qcx.dep_context(), &key));\n \n-            let task = Q::compute(qcx, &key);\n-            dep_graph.with_task(dep_node, *qcx.dep_context(), key, task, Q::HASH_RESULT)\n+            dep_graph.with_task(dep_node, qcx, key, Q::compute, Q::HASH_RESULT)\n         });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -555,7 +534,7 @@ where\n     let prof_timer = qcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| Q::compute(qcx, key)(*qcx.dep_context(), key.clone()));\n+    let result = dep_graph.with_ignore(|| Q::compute(qcx, key.clone()));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -727,7 +706,7 @@ pub enum QueryMode {\n     Ensure,\n }\n \n-pub fn get_query<Q, Qcx, D>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n+pub fn get_query<Q, Qcx, D>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Value>\n where\n     D: DepKind,\n     Q: QueryConfig<Qcx>,"}, {"sha": "324de7461cd95431a0a2a6f1e92e4d831d929b55", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -21,7 +21,7 @@ use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::{BindingAnnotation, PrimTy, TraitCandidate};\n-use rustc_middle::middle::resolve_lifetime::Set1;\n+use rustc_middle::middle::resolve_bound_vars::Set1;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::{CrateType, ResolveDocLinks};\n@@ -2505,7 +2505,13 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n             let res = match kind {\n                 ItemRibKind(..) | AssocItemRibKind => Res::Def(def_kind, def_id.to_def_id()),\n-                NormalRibKind => Res::Err,\n+                NormalRibKind => {\n+                    if self.r.session.features_untracked().non_lifetime_binders {\n+                        Res::Def(def_kind, def_id.to_def_id())\n+                    } else {\n+                        Res::Err\n+                    }\n+                }\n                 _ => span_bug!(param.ident.span, \"Unexpected rib kind {:?}\", kind),\n             };\n             self.r.record_partial_res(param.id, PartialRes::new(res));"}, {"sha": "5205d055cf9ad7b871cfd7b4327641c8e2556425", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1700,11 +1700,9 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                                         let crate_mod =\n                                             Res::Def(DefKind::Mod, crate_id.as_def_id());\n \n-                                        if filter_fn(crate_mod) {\n-                                            Some(TypoSuggestion::typo_from_ident(*ident, crate_mod))\n-                                        } else {\n-                                            None\n-                                        }\n+                                        filter_fn(crate_mod).then(|| {\n+                                            TypoSuggestion::typo_from_ident(*ident, crate_mod)\n+                                        })\n                                     })\n                             }));\n "}, {"sha": "3425e24585cdd0ff51c4fdfcd35dc1224656a9af", "filename": "compiler/rustc_resolve/src/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -344,7 +344,7 @@ fn preprocess_link(link: &str) -> String {\n     let link = link.strip_suffix(\"()\").unwrap_or(link);\n     let link = link.strip_suffix(\"{}\").unwrap_or(link);\n     let link = link.strip_suffix(\"[]\").unwrap_or(link);\n-    let link = if link != \"!\" { link.strip_suffix(\"!\").unwrap_or(link) } else { link };\n+    let link = if link != \"!\" { link.strip_suffix('!').unwrap_or(link) } else { link };\n     strip_generics_from_path(link).unwrap_or_else(|_| link.to_string())\n }\n "}, {"sha": "295e93f610339c4c08607f3474d17ce46b9fd5ff", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1022,7 +1022,13 @@ fn default_configuration(sess: &Session) -> CrateConfig {\n     let panic_strategy = sess.panic_strategy();\n     ret.insert((sym::panic, Some(panic_strategy.desc_symbol())));\n \n-    for s in sess.opts.unstable_opts.sanitizer {\n+    for mut s in sess.opts.unstable_opts.sanitizer {\n+        // KASAN should use the same attribute name as ASAN, as it's still ASAN\n+        // under the hood\n+        if s == SanitizerSet::KERNELADDRESS {\n+            s = SanitizerSet::ADDRESS;\n+        }\n+\n         let symbol = Symbol::intern(&s.to_string());\n         ret.insert((sym::sanitize, Some(symbol)));\n     }\n@@ -2544,7 +2550,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         }\n \n         // Only use this directory if it has a file we can expect to always find.\n-        if candidate.join(\"library/std/src/lib.rs\").is_file() { Some(candidate) } else { None }\n+        candidate.join(\"library/std/src/lib.rs\").is_file().then_some(candidate)\n     };\n \n     let working_dir = std::env::current_dir().unwrap_or_else(|e| {"}, {"sha": "bd32adbbdbb54b21f0dff197c86d88ae73bead47", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -4,7 +4,7 @@ use crate::cgu_reuse_tracker::CguReuse;\n use crate::parse::ParseSess;\n use rustc_ast::token;\n use rustc_ast::util::literal::LitError;\n-use rustc_errors::MultiSpan;\n+use rustc_errors::{error_code, DiagnosticMessage, EmissionGuarantee, IntoDiagnostic, MultiSpan};\n use rustc_macros::Diagnostic;\n use rustc_span::{Span, Symbol};\n use rustc_target::spec::{SplitDebuginfo, StackProtector, TargetTriple};\n@@ -27,12 +27,22 @@ pub struct CguNotRecorded<'a> {\n     pub cgu_name: &'a str,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(session_feature_gate_error, code = \"E0658\")]\n-pub struct FeatureGateError<'a> {\n-    #[primary_span]\n+pub struct FeatureGateError {\n     pub span: MultiSpan,\n-    pub explain: &'a str,\n+    pub explain: DiagnosticMessage,\n+}\n+\n+impl<'a, T: EmissionGuarantee> IntoDiagnostic<'a, T> for FeatureGateError {\n+    #[track_caller]\n+    fn into_diagnostic(\n+        self,\n+        handler: &'a rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'a, T> {\n+        let mut diag = handler.struct_diagnostic(self.explain);\n+        diag.set_span(self.span);\n+        diag.code(error_code!(E0658));\n+        diag\n+    }\n }\n \n #[derive(Subdiagnostic)]\n@@ -322,11 +332,7 @@ pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span:\n                 .take_while(|c| *c != 'i' && *c != 'u')\n                 .all(|c| c.to_digit(base).is_some());\n \n-        if valid {\n-            Some(format!(\"0{}{}\", base_char.to_ascii_lowercase(), &suffix[1..]))\n-        } else {\n-            None\n-        }\n+        valid.then(|| format!(\"0{}{}\", base_char.to_ascii_lowercase(), &suffix[1..]))\n     }\n \n     let token::Lit { kind, symbol, suffix, .. } = lit;"}, {"sha": "2075ed57a94db4b73ac2d9b42a3e723f5acd51a8", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -217,7 +217,7 @@ pub fn get_or_default_sysroot() -> Result<PathBuf, String> {\n                 // Look for the target rustlib directory in the suspected sysroot.\n                 let mut rustlib_path = rustc_target::target_rustlib_path(&p, \"dummy\");\n                 rustlib_path.pop(); // pop off the dummy target.\n-                if rustlib_path.exists() { Some(p) } else { None }\n+                rustlib_path.exists().then_some(p)\n             }\n             None => None,\n         }"}, {"sha": "0d5818bd39cf94e5ea1c006047e6f3f13c10946b", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -370,7 +370,7 @@ mod desc {\n     pub const parse_opt_panic_strategy: &str = parse_panic_strategy;\n     pub const parse_oom_strategy: &str = \"either `panic` or `abort`\";\n     pub const parse_relro_level: &str = \"one of: `full`, `partial`, or `off`\";\n-    pub const parse_sanitizers: &str = \"comma separated list of sanitizers: `address`, `cfi`, `hwaddress`, `kcfi`, `leak`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\";\n+    pub const parse_sanitizers: &str = \"comma separated list of sanitizers: `address`, `cfi`, `hwaddress`, `kcfi`, `kernel-address`, `leak`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\";\n     pub const parse_sanitizer_memory_track_origins: &str = \"0, 1, or 2\";\n     pub const parse_cfguard: &str =\n         \"either a boolean (`yes`, `no`, `on`, `off`, etc), `checks`, or `nochecks`\";\n@@ -684,6 +684,7 @@ mod parse {\n                     \"address\" => SanitizerSet::ADDRESS,\n                     \"cfi\" => SanitizerSet::CFI,\n                     \"kcfi\" => SanitizerSet::KCFI,\n+                    \"kernel-address\" => SanitizerSet::KERNELADDRESS,\n                     \"leak\" => SanitizerSet::LEAK,\n                     \"memory\" => SanitizerSet::MEMORY,\n                     \"memtag\" => SanitizerSet::MEMTAG,\n@@ -809,7 +810,7 @@ mod parse {\n         if v.is_some() {\n             let mut bool_arg = None;\n             if parse_opt_bool(&mut bool_arg, v) {\n-                *slot = if bool_arg.unwrap() { Some(MirSpanview::Statement) } else { None };\n+                *slot = bool_arg.unwrap().then_some(MirSpanview::Statement);\n                 return true;\n             }\n         }\n@@ -850,7 +851,7 @@ mod parse {\n         if v.is_some() {\n             let mut bool_arg = None;\n             if parse_opt_bool(&mut bool_arg, v) {\n-                *slot = if bool_arg.unwrap() { Some(InstrumentCoverage::All) } else { None };\n+                *slot = bool_arg.unwrap().then_some(InstrumentCoverage::All);\n                 return true;\n             }\n         }"}, {"sha": "cbdcc5581e5eea3146980c55f926b278c95bf79b", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -88,7 +88,7 @@ pub fn feature_err<'a>(\n     sess: &'a ParseSess,\n     feature: Symbol,\n     span: impl Into<MultiSpan>,\n-    explain: &str,\n+    explain: impl Into<DiagnosticMessage>,\n ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     feature_err_issue(sess, feature, span, GateIssue::Language, explain)\n }\n@@ -103,7 +103,7 @@ pub fn feature_err_issue<'a>(\n     feature: Symbol,\n     span: impl Into<MultiSpan>,\n     issue: GateIssue,\n-    explain: &str,\n+    explain: impl Into<DiagnosticMessage>,\n ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     let span = span.into();\n \n@@ -114,7 +114,7 @@ pub fn feature_err_issue<'a>(\n             .map(|err| err.cancel());\n     }\n \n-    let mut err = sess.create_err(FeatureGateError { span, explain });\n+    let mut err = sess.create_err(FeatureGateError { span, explain: explain.into() });\n     add_feature_diagnostics_for_issue(&mut err, sess, feature, issue);\n     err\n }"}, {"sha": "3dc09854b3cbca5e8b995d536cd6f218385c866f", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -954,10 +954,10 @@ impl Session {\n     /// Checks if LLVM lifetime markers should be emitted.\n     pub fn emit_lifetime_markers(&self) -> bool {\n         self.opts.optimize != config::OptLevel::No\n-        // AddressSanitizer uses lifetimes to detect use after scope bugs.\n+        // AddressSanitizer and KernelAddressSanitizer uses lifetimes to detect use after scope bugs.\n         // MemorySanitizer uses lifetimes to detect use of uninitialized stack variables.\n         // HWAddressSanitizer will use lifetimes to detect use after scope bugs in the future.\n-        || self.opts.unstable_opts.sanitizer.intersects(SanitizerSet::ADDRESS | SanitizerSet::MEMORY | SanitizerSet::HWADDRESS)\n+        || self.opts.unstable_opts.sanitizer.intersects(SanitizerSet::ADDRESS | SanitizerSet::KERNELADDRESS | SanitizerSet::MEMORY | SanitizerSet::HWADDRESS)\n     }\n \n     pub fn is_proc_macro_attr(&self, attr: &Attribute) -> bool {"}, {"sha": "2340d501d5a6600c4343d171fbf45b0c33f1ed1c", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -299,7 +299,7 @@ impl DefId {\n \n     #[inline]\n     pub fn as_local(self) -> Option<LocalDefId> {\n-        if self.is_local() { Some(LocalDefId { local_def_index: self.index }) } else { None }\n+        self.is_local().then(|| LocalDefId { local_def_index: self.index })\n     }\n \n     #[inline]\n@@ -320,7 +320,7 @@ impl DefId {\n \n     #[inline]\n     pub fn as_crate_root(self) -> Option<CrateNum> {\n-        if self.is_crate_root() { Some(self.krate) } else { None }\n+        self.is_crate_root().then_some(self.krate)\n     }\n \n     #[inline]"}, {"sha": "37d2aea42ad8f40284609a8d118e61700373bf9c", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1016,6 +1016,7 @@ symbols! {\n         non_ascii_idents,\n         non_exhaustive,\n         non_exhaustive_omitted_patterns_lint,\n+        non_lifetime_binders,\n         non_modrs_mods,\n         nontemporal_store,\n         noop_method_borrow,"}, {"sha": "744e8a4320e30b9505ad42b934fe4ecaa7388185", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -26,7 +26,7 @@ pub(super) fn mangle<'tcx>(\n         let key = tcx.def_key(ty_def_id);\n         match key.disambiguated_data.data {\n             DefPathData::TypeNs(_) | DefPathData::ValueNs(_) => {\n-                instance_ty = tcx.type_of(ty_def_id);\n+                instance_ty = tcx.type_of(ty_def_id).subst_identity();\n                 debug!(?instance_ty);\n                 break;\n             }"}, {"sha": "d81722e59a66e18ea59f01e9287efaccf460f390", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -244,8 +244,7 @@ fn compute_symbol_name<'tcx>(\n     // project.\n     let avoid_cross_crate_conflicts = is_generic(substs) || is_globally_shared_function;\n \n-    let instantiating_crate =\n-        if avoid_cross_crate_conflicts { Some(compute_instantiating_crate()) } else { None };\n+    let instantiating_crate = avoid_cross_crate_conflicts.then(compute_instantiating_crate);\n \n     // Pick the crate responsible for the symbol mangling version, which has to:\n     // 1. be stable for each instance, whether it's being defined or imported"}, {"sha": "59a2227cd3646a1bc63d087dd2fda4268d507b78", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -696,13 +696,13 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n                 let variant = adt_def.non_enum_variant();\n                 let param_env = tcx.param_env(variant.def_id);\n                 let field = variant.fields.iter().find(|field| {\n-                    let ty = tcx.type_of(field.did);\n+                    let ty = tcx.type_of(field.did).subst_identity();\n                     let is_zst =\n                         tcx.layout_of(param_env.and(ty)).map_or(false, |layout| layout.is_zst());\n                     !is_zst\n                 });\n                 if let Some(field) = field {\n-                    let ty0 = tcx.bound_type_of(field.did).subst(tcx, substs);\n+                    let ty0 = tcx.type_of(field.did).subst(tcx, substs);\n                     // Generalize any repr(transparent) user-defined type that is either a pointer\n                     // or reference, and either references itself or any other type that contains or\n                     // references itself, to avoid a reference cycle.\n@@ -781,8 +781,8 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n                 let output = transform_ty(tcx, fn_sig.skip_binder().output(), options);\n                 ty = tcx.mk_fn_ptr(ty::Binder::bind_with_vars(\n                     tcx.mk_fn_sig(\n-                        parameters.iter(),\n-                        &output,\n+                        parameters,\n+                        output,\n                         fn_sig.c_variadic(),\n                         fn_sig.unsafety(),\n                         fn_sig.abi(),\n@@ -813,21 +813,18 @@ fn transform_substs<'tcx>(\n     substs: SubstsRef<'tcx>,\n     options: TransformTyOptions,\n ) -> SubstsRef<'tcx> {\n-    let substs: Vec<GenericArg<'tcx>> = substs\n-        .iter()\n-        .map(|subst| {\n-            if let GenericArgKind::Type(ty) = subst.unpack() {\n-                if is_c_void_ty(tcx, ty) {\n-                    tcx.mk_unit().into()\n-                } else {\n-                    transform_ty(tcx, ty, options).into()\n-                }\n+    let substs = substs.iter().map(|subst| {\n+        if let GenericArgKind::Type(ty) = subst.unpack() {\n+            if is_c_void_ty(tcx, ty) {\n+                tcx.mk_unit().into()\n             } else {\n-                subst\n+                transform_ty(tcx, ty, options).into()\n             }\n-        })\n-        .collect();\n-    tcx.mk_substs(substs.iter())\n+        } else {\n+            subst\n+        }\n+    });\n+    tcx.mk_substs(substs)\n }\n \n /// Returns a type metadata identifier for the specified FnAbi using the Itanium C++ ABI with vendor"}, {"sha": "e9edfd2877b866a19bba2b32623643ce8dc446ec", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1,8 +1,11 @@\n use super::apple_base::{ios_llvm_target, opts, Arch};\n-use crate::spec::{FramePointer, Target, TargetOptions};\n+use crate::spec::{FramePointer, SanitizerSet, Target, TargetOptions};\n \n pub fn target() -> Target {\n     let arch = Arch::Arm64;\n+    let mut base = opts(\"ios\", arch);\n+    base.supported_sanitizers = SanitizerSet::ADDRESS | SanitizerSet::THREAD;\n+\n     Target {\n         // Clang automatically chooses a more specific target based on\n         // IPHONEOS_DEPLOYMENT_TARGET.\n@@ -28,7 +31,7 @@ pub fn target() -> Target {\n                 darwinpcs\\0\\\n                 -Os\\0\"\n                 .into(),\n-            ..opts(\"ios\", arch)\n+            ..base\n         },\n     }\n }"}, {"sha": "6e2d62b6e085570415b20c19c236484122f1735a", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios_sim.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_sim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_sim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_sim.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1,8 +1,11 @@\n use super::apple_base::{ios_sim_llvm_target, opts, Arch};\n-use crate::spec::{FramePointer, Target, TargetOptions};\n+use crate::spec::{FramePointer, SanitizerSet, Target, TargetOptions};\n \n pub fn target() -> Target {\n     let arch = Arch::Arm64_sim;\n+    let mut base = opts(\"ios\", arch);\n+    base.supported_sanitizers = SanitizerSet::ADDRESS | SanitizerSet::THREAD;\n+\n     Target {\n         // Clang automatically chooses a more specific target based on\n         // IPHONEOS_DEPLOYMENT_TARGET.\n@@ -28,7 +31,7 @@ pub fn target() -> Target {\n                 darwinpcs\\0\\\n                 -Os\\0\"\n                 .into(),\n-            ..opts(\"ios\", arch)\n+            ..base\n         },\n     }\n }"}, {"sha": "be27302f7f52cc14e7f13ed82e92e33d58e83302", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -15,7 +15,7 @@ pub fn target() -> Target {\n         linker_flavor: LinkerFlavor::Gnu(Cc::No, Lld::Yes),\n         linker: Some(\"rust-lld\".into()),\n         features: \"+v8a,+strict-align,+neon,+fp-armv8\".into(),\n-        supported_sanitizers: SanitizerSet::KCFI,\n+        supported_sanitizers: SanitizerSet::KCFI | SanitizerSet::KERNELADDRESS,\n         relocation_model: RelocModel::Static,\n         disable_redzone: true,\n         max_atomic_width: Some(128),"}, {"sha": "f6f46aac4c391d698422cc73f50c6e66e4668b8f", "filename": "compiler/rustc_target/src/spec/armebv7r_none_eabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabi.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -19,7 +19,7 @@ pub fn target() -> Target {\n             max_atomic_width: Some(32),\n             emit_debug_gdb_scripts: false,\n             // GCC and Clang default to 8 for arm-none here\n-            c_enum_min_bits: 8,\n+            c_enum_min_bits: Some(8),\n             ..Default::default()\n         },\n     }"}, {"sha": "9608efe8bcf60ac5f49808f2587eac3d420c1a6c", "filename": "compiler/rustc_target/src/spec/armebv7r_none_eabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabihf.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -20,7 +20,7 @@ pub fn target() -> Target {\n             max_atomic_width: Some(32),\n             emit_debug_gdb_scripts: false,\n             // GCC and Clang default to 8 for arm-none here\n-            c_enum_min_bits: 8,\n+            c_enum_min_bits: Some(8),\n             ..Default::default()\n         },\n     }"}, {"sha": "28b109889e92807935c6428f93f4a2473be896fd", "filename": "compiler/rustc_target/src/spec/armv4t_none_eabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv4t_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv4t_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv4t_none_eabi.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -49,7 +49,7 @@ pub fn target() -> Target {\n             // from thumb_base, rust-lang/rust#44993.\n             emit_debug_gdb_scripts: false,\n             // from thumb_base, apparently gcc/clang give enums a minimum of 8 bits on no-os targets\n-            c_enum_min_bits: 8,\n+            c_enum_min_bits: Some(8),\n             ..Default::default()\n         },\n     }"}, {"sha": "d59de86a23012c8f4f4bf66c13904721cbba8c2f", "filename": "compiler/rustc_target/src/spec/armv7a_none_eabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_none_eabi.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -27,7 +27,7 @@ pub fn target() -> Target {\n         max_atomic_width: Some(64),\n         panic_strategy: PanicStrategy::Abort,\n         emit_debug_gdb_scripts: false,\n-        c_enum_min_bits: 8,\n+        c_enum_min_bits: Some(8),\n         ..Default::default()\n     };\n     Target {"}, {"sha": "8cdf3c36ba2ea2a4c4e25abcc6f67cb814b940f0", "filename": "compiler/rustc_target/src/spec/armv7a_none_eabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_none_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_none_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_none_eabihf.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -19,7 +19,7 @@ pub fn target() -> Target {\n         panic_strategy: PanicStrategy::Abort,\n         emit_debug_gdb_scripts: false,\n         // GCC and Clang default to 8 for arm-none here\n-        c_enum_min_bits: 8,\n+        c_enum_min_bits: Some(8),\n         ..Default::default()\n     };\n     Target {"}, {"sha": "5225abf44fca494fecb5b581248fa17788e3fde5", "filename": "compiler/rustc_target/src/spec/armv7r_none_eabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabi.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -18,7 +18,7 @@ pub fn target() -> Target {\n             max_atomic_width: Some(32),\n             emit_debug_gdb_scripts: false,\n             // GCC and Clang default to 8 for arm-none here\n-            c_enum_min_bits: 8,\n+            c_enum_min_bits: Some(8),\n             ..Default::default()\n         },\n     }"}, {"sha": "9a35e04617f9c71d5759e6bacf8a4408ec4ed91d", "filename": "compiler/rustc_target/src/spec/armv7r_none_eabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabihf.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -19,7 +19,7 @@ pub fn target() -> Target {\n             max_atomic_width: Some(32),\n             emit_debug_gdb_scripts: false,\n             // GCC and Clang default to 8 for arm-none here\n-            c_enum_min_bits: 8,\n+            c_enum_min_bits: Some(8),\n             ..Default::default()\n         },\n     }"}, {"sha": "4c6ab5f5ae45433e60235e1cd5156d5eeb5d94d9", "filename": "compiler/rustc_target/src/spec/hexagon_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fhexagon_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fhexagon_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fhexagon_unknown_linux_musl.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -11,7 +11,7 @@ pub fn target() -> Target {\n     base.has_rpath = true;\n     base.linker_flavor = LinkerFlavor::Unix(Cc::Yes);\n \n-    base.c_enum_min_bits = 8;\n+    base.c_enum_min_bits = Some(8);\n \n     Target {\n         llvm_target: \"hexagon-unknown-linux-musl\".into(),"}, {"sha": "0d86a3032a65947cfcbb0ae9abdf3f0c9e41408f", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -812,6 +812,7 @@ bitflags::bitflags! {\n         const MEMTAG  = 1 << 6;\n         const SHADOWCALLSTACK = 1 << 7;\n         const KCFI    = 1 << 8;\n+        const KERNELADDRESS = 1 << 9;\n     }\n }\n \n@@ -824,6 +825,7 @@ impl SanitizerSet {\n             SanitizerSet::ADDRESS => \"address\",\n             SanitizerSet::CFI => \"cfi\",\n             SanitizerSet::KCFI => \"kcfi\",\n+            SanitizerSet::KERNELADDRESS => \"kernel-address\",\n             SanitizerSet::LEAK => \"leak\",\n             SanitizerSet::MEMORY => \"memory\",\n             SanitizerSet::MEMTAG => \"memtag\",\n@@ -866,6 +868,7 @@ impl IntoIterator for SanitizerSet {\n             SanitizerSet::SHADOWCALLSTACK,\n             SanitizerSet::THREAD,\n             SanitizerSet::HWADDRESS,\n+            SanitizerSet::KERNELADDRESS,\n         ]\n         .iter()\n         .copied()\n@@ -1344,10 +1347,18 @@ impl Target {\n             });\n         }\n \n-        dl.c_enum_min_size = match Integer::from_size(Size::from_bits(self.c_enum_min_bits)) {\n-            Ok(bits) => bits,\n-            Err(err) => return Err(TargetDataLayoutErrors::InvalidBitsSize { err }),\n-        };\n+        dl.c_enum_min_size = self\n+            .c_enum_min_bits\n+            .map_or_else(\n+                || {\n+                    self.c_int_width\n+                        .parse()\n+                        .map_err(|_| String::from(\"failed to parse c_int_width\"))\n+                },\n+                Ok,\n+            )\n+            .and_then(|i| Integer::from_size(Size::from_bits(i)))\n+            .map_err(|err| TargetDataLayoutErrors::InvalidBitsSize { err })?;\n \n         Ok(dl)\n     }\n@@ -1701,8 +1712,8 @@ pub struct TargetOptions {\n     /// If present it's a default value to use for adjusting the C ABI.\n     pub default_adjusted_cabi: Option<Abi>,\n \n-    /// Minimum number of bits in #[repr(C)] enum. Defaults to 32.\n-    pub c_enum_min_bits: u64,\n+    /// Minimum number of bits in #[repr(C)] enum. Defaults to the size of c_int\n+    pub c_enum_min_bits: Option<u64>,\n \n     /// Whether or not the DWARF `.debug_aranges` section should be generated.\n     pub generate_arange_section: bool,\n@@ -1935,7 +1946,7 @@ impl Default for TargetOptions {\n             supported_split_debuginfo: Cow::Borrowed(&[SplitDebuginfo::Off]),\n             supported_sanitizers: SanitizerSet::empty(),\n             default_adjusted_cabi: None,\n-            c_enum_min_bits: 32,\n+            c_enum_min_bits: None,\n             generate_arange_section: true,\n             supports_stack_protector: true,\n             entry_name: \"main\".into(),\n@@ -2122,12 +2133,6 @@ impl Target {\n                     base.$key_name = s;\n                 }\n             } );\n-            ($key_name:ident, u64) => ( {\n-                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                if let Some(s) = obj.remove(&name).and_then(|j| Json::as_u64(&j)) {\n-                    base.$key_name = s;\n-                }\n-            } );\n             ($key_name:ident, u32) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n                 if let Some(s) = obj.remove(&name).and_then(|b| b.as_u64()) {\n@@ -2339,6 +2344,7 @@ impl Target {\n                                 Some(\"address\") => SanitizerSet::ADDRESS,\n                                 Some(\"cfi\") => SanitizerSet::CFI,\n                                 Some(\"kcfi\") => SanitizerSet::KCFI,\n+                                Some(\"kernel-address\") => SanitizerSet::KERNELADDRESS,\n                                 Some(\"leak\") => SanitizerSet::LEAK,\n                                 Some(\"memory\") => SanitizerSet::MEMORY,\n                                 Some(\"memtag\") => SanitizerSet::MEMTAG,\n@@ -2496,6 +2502,7 @@ impl Target {\n \n         key!(is_builtin, bool);\n         key!(c_int_width = \"target-c-int-width\");\n+        key!(c_enum_min_bits, Option<u64>); // if None, matches c_int_width\n         key!(os);\n         key!(env);\n         key!(abi);\n@@ -2591,7 +2598,6 @@ impl Target {\n         key!(supported_split_debuginfo, falliable_list)?;\n         key!(supported_sanitizers, SanitizerSet)?;\n         key!(default_adjusted_cabi, Option<Abi>)?;\n-        key!(c_enum_min_bits, u64);\n         key!(generate_arange_section, bool);\n         key!(supports_stack_protector, bool);\n         key!(entry_name);"}, {"sha": "ab3c14e3fe73dbdee9d0616629bca38a7564dd7e", "filename": "compiler/rustc_target/src/spec/riscv64gc_unknown_none_elf.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_none_elf.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1,6 +1,8 @@\n use crate::spec::{Cc, CodeModel, LinkerFlavor, Lld, PanicStrategy};\n use crate::spec::{RelocModel, Target, TargetOptions};\n \n+use super::SanitizerSet;\n+\n pub fn target() -> Target {\n     Target {\n         data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\".into(),\n@@ -20,6 +22,7 @@ pub fn target() -> Target {\n             code_model: Some(CodeModel::Medium),\n             emit_debug_gdb_scripts: false,\n             eh_frame_header: false,\n+            supported_sanitizers: SanitizerSet::KERNELADDRESS,\n             ..Default::default()\n         },\n     }"}, {"sha": "0f1821c9985b0f32d1ce7496c7e5971f4ac87f99", "filename": "compiler/rustc_target/src/spec/riscv64imac_unknown_none_elf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64imac_unknown_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64imac_unknown_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64imac_unknown_none_elf.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1,5 +1,5 @@\n use crate::spec::{Cc, CodeModel, LinkerFlavor, Lld, PanicStrategy};\n-use crate::spec::{RelocModel, Target, TargetOptions};\n+use crate::spec::{RelocModel, SanitizerSet, Target, TargetOptions};\n \n pub fn target() -> Target {\n     Target {\n@@ -19,6 +19,7 @@ pub fn target() -> Target {\n             code_model: Some(CodeModel::Medium),\n             emit_debug_gdb_scripts: false,\n             eh_frame_header: false,\n+            supported_sanitizers: SanitizerSet::KERNELADDRESS,\n             ..Default::default()\n         },\n     }"}, {"sha": "4dcf47fe465c3144a206d7c0c95b93ba98a3fe4d", "filename": "compiler/rustc_target/src/spec/thumb_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumb_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumb_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumb_base.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -53,7 +53,7 @@ pub fn opts() -> TargetOptions {\n         frame_pointer: FramePointer::Always,\n         // ARM supports multiple ABIs for enums, the linux one matches the default of 32 here\n         // but any arm-none or thumb-none target will be defaulted to 8 on GCC and clang\n-        c_enum_min_bits: 8,\n+        c_enum_min_bits: Some(8),\n         ..Default::default()\n     }\n }"}, {"sha": "e3734932f88553346f0b2afc74aa78f17b176a7c", "filename": "compiler/rustc_target/src/spec/thumbv4t_none_eabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumbv4t_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumbv4t_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumbv4t_none_eabi.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -55,7 +55,7 @@ pub fn target() -> Target {\n             // suggested from thumb_base, rust-lang/rust#44993.\n             emit_debug_gdb_scripts: false,\n             // suggested from thumb_base, with no-os gcc/clang use 8-bit enums\n-            c_enum_min_bits: 8,\n+            c_enum_min_bits: Some(8),\n             frame_pointer: FramePointer::MayOmit,\n \n             main_needs_argc_argv: false,"}, {"sha": "1dcb47056a463b335010c81b56116102ecb06e04", "filename": "compiler/rustc_target/src/spec/x86_64_apple_ios.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1,8 +1,11 @@\n use super::apple_base::{ios_sim_llvm_target, opts, Arch};\n-use crate::spec::{StackProbeType, Target, TargetOptions};\n+use crate::spec::{SanitizerSet, StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n     let arch = Arch::X86_64_sim;\n+    let mut base = opts(\"ios\", arch);\n+    base.supported_sanitizers = SanitizerSet::ADDRESS | SanitizerSet::THREAD;\n+\n     Target {\n         llvm_target: ios_sim_llvm_target(arch).into(),\n         pointer_width: 64,\n@@ -12,7 +15,7 @@ pub fn target() -> Target {\n         options: TargetOptions {\n             max_atomic_width: Some(64),\n             stack_probes: StackProbeType::X86,\n-            ..opts(\"ios\", arch)\n+            ..base\n         },\n     }\n }"}, {"sha": "43c5ce78ce34e0c1982a9f30655c0105726e5273", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -20,7 +20,7 @@ pub fn target() -> Target {\n         features:\n             \"-mmx,-sse,-sse2,-sse3,-ssse3,-sse4.1,-sse4.2,-3dnow,-3dnowa,-avx,-avx2,+soft-float\"\n                 .into(),\n-        supported_sanitizers: SanitizerSet::KCFI,\n+        supported_sanitizers: SanitizerSet::KCFI | SanitizerSet::KERNELADDRESS,\n         disable_redzone: true,\n         panic_strategy: PanicStrategy::Abort,\n         code_model: Some(CodeModel::Kernel),"}, {"sha": "6890811fd046e581898138c7e2da3a19540087b4", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -25,7 +25,7 @@ use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::Obligation;\n use rustc_middle::infer::canonical::Certainty as OldCertainty;\n use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n     CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, ToPredicate, TypeOutlivesPredicate,\n };\n@@ -290,6 +290,9 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n                     self.compute_region_outlives_goal(Goal { param_env, predicate })\n                 }\n+                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                    self.compute_const_arg_has_type_goal(Goal { param_env, predicate: (ct, ty) })\n+                }\n                 ty::PredicateKind::Subtype(predicate) => {\n                     self.compute_subtype_goal(Goal { param_env, predicate })\n                 }\n@@ -471,6 +474,16 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn compute_const_arg_has_type_goal(\n+        &mut self,\n+        goal: Goal<'tcx, (ty::Const<'tcx>, Ty<'tcx>)>,\n+    ) -> QueryResult<'tcx> {\n+        let (ct, ty) = goal.predicate;\n+        let nested_goals = self.infcx.eq(goal.param_env, ct.ty(), ty)?;\n+        self.evaluate_all_and_make_canonical_response(nested_goals)\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "883342148f400733883c9a2265f742bd30357aca", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -244,7 +244,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n \n             // Finally we construct the actual value of the associated type.\n             let is_const = matches!(tcx.def_kind(assoc_def.item.def_id), DefKind::AssocConst);\n-            let ty = tcx.bound_type_of(assoc_def.item.def_id);\n+            let ty = tcx.type_of(assoc_def.item.def_id);\n             let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n                 let identity_substs =\n                     ty::InternalSubsts::identity_for_item(tcx, assoc_def.item.def_id);\n@@ -388,7 +388,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n \n                 ty::Dynamic(_, _, _) => {\n                     let dyn_metadata = tcx.require_lang_item(LangItem::DynMetadata, None);\n-                    tcx.bound_type_of(dyn_metadata)\n+                    tcx.type_of(dyn_metadata)\n                         .subst(tcx, &[ty::GenericArg::from(goal.predicate.self_ty())])\n                 }\n "}, {"sha": "d12e5f797fb9454930df53a65b7de63cf63610f6", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -326,7 +326,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                         .fields\n                         .last()\n                         .expect(\"expected unsized ADT to have a tail field\");\n-                    let tail_field_ty = tcx.bound_type_of(tail_field.did);\n+                    let tail_field_ty = tcx.type_of(tail_field.did);\n \n                     let a_tail_ty = tail_field_ty.subst(tcx, a_substs);\n                     let b_tail_ty = tail_field_ty.subst(tcx, b_substs);\n@@ -359,7 +359,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     let b_last_ty = b_tys.last().unwrap();\n \n                     // Substitute just the tail field of B., and require that they're equal.\n-                    let unsized_a_ty = tcx.mk_tup(a_rest_tys.iter().chain([b_last_ty]));\n+                    let unsized_a_ty = tcx.mk_tup(a_rest_tys.iter().chain([b_last_ty]).copied());\n                     let mut nested_goals = ecx.infcx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n \n                     // Similar to ADTs, require that the rest of the fields are equal."}, {"sha": "3662463178f8502049513902a1c6b12e274dc59e", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -68,7 +68,7 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n             // We can resolve the `impl Trait` to its concrete type,\n             // which enforces a DAG between the functions requiring\n             // the auto trait bounds in question.\n-            Ok(vec![tcx.bound_type_of(def_id).subst(tcx, substs)])\n+            Ok(vec![tcx.type_of(def_id).subst(tcx, substs)])\n         }\n     }\n }\n@@ -191,10 +191,10 @@ pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n         ty::FnDef(def_id, substs) => Ok(Some(\n             tcx.fn_sig(def_id)\n                 .subst(tcx, substs)\n-                .map_bound(|sig| (tcx.mk_tup(sig.inputs().iter()), sig.output())),\n+                .map_bound(|sig| (tcx.intern_tup(sig.inputs()), sig.output())),\n         )),\n         ty::FnPtr(sig) => {\n-            Ok(Some(sig.map_bound(|sig| (tcx.mk_tup(sig.inputs().iter()), sig.output()))))\n+            Ok(Some(sig.map_bound(|sig| (tcx.intern_tup(sig.inputs()), sig.output()))))\n         }\n         ty::Closure(_, substs) => {\n             let closure_substs = substs.as_closure();"}, {"sha": "9776cc57af8e8618e367501c2c6c41885db187a6", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -830,6 +830,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 // and these don't correspond to adding any new bounds to\n                 // the `ParamEnv`.\n                 ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n                 | ty::PredicateKind::AliasEq(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)"}, {"sha": "599238e405dea97a56c3eb3933da8fd6a4b633c0", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -82,8 +82,8 @@ pub fn overlapping_impls(\n         (Some(a), Some(b)) => iter::zip(a.skip_binder().substs, b.skip_binder().substs)\n             .all(|(arg1, arg2)| drcx.generic_args_may_unify(arg1, arg2)),\n         (None, None) => {\n-            let self_ty1 = tcx.type_of(impl1_def_id);\n-            let self_ty2 = tcx.type_of(impl2_def_id);\n+            let self_ty1 = tcx.type_of(impl1_def_id).skip_binder();\n+            let self_ty2 = tcx.type_of(impl2_def_id).skip_binder();\n             drcx.types_may_unify(self_ty1, self_ty2)\n         }\n         _ => bug!(\"unexpected impls: {impl1_def_id:?} {impl2_def_id:?}\"),\n@@ -124,7 +124,7 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n \n     let header = ty::ImplHeader {\n         impl_def_id,\n-        self_ty: tcx.bound_type_of(impl_def_id).subst(tcx, impl_substs),\n+        self_ty: tcx.type_of(impl_def_id).subst(tcx, impl_substs),\n         trait_ref: tcx.impl_trait_ref(impl_def_id).map(|i| i.subst(tcx, impl_substs)),\n         predicates: tcx.predicates_of(impl_def_id).instantiate(tcx, impl_substs).predicates,\n     };"}, {"sha": "a32ab16263a29ac319b135393a4255117a39c13a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1282,6 +1282,13 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         span,\n                         \"AliasEq predicate should never be the predicate cause of a SelectionError\"\n                     ),\n+\n+                    ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                        self.tcx.sess.struct_span_err(\n+                            span,\n+                            &format!(\"the constant `{}` is not of type `{}`\", ct, ty),\n+                        )\n+                    }\n                 }\n             }\n \n@@ -2432,7 +2439,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             };\n                             let mut suggestions = vec![(\n                                 path.span.shrink_to_lo(),\n-                                format!(\"<{} as \", self.tcx.type_of(impl_def_id))\n+                                format!(\"<{} as \", self.tcx.type_of(impl_def_id).subst_identity())\n                             )];\n                             if let Some(generic_arg) = trait_path_segment.args {\n                                 let between_span = trait_path_segment.ident.span.between(generic_arg.span_ext);"}, {"sha": "b3bf9ad599acc10c412701c383f3006b50120402", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -60,7 +60,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     ) -> Option<(DefId, SubstsRef<'tcx>)> {\n         let tcx = self.tcx;\n         let param_env = obligation.param_env;\n-        let trait_ref = tcx.erase_late_bound_regions(trait_ref);\n+        let trait_ref = self.instantiate_binder_with_placeholders(trait_ref);\n         let trait_self_ty = trait_ref.self_ty();\n \n         let mut self_match_impls = vec![];\n@@ -200,7 +200,10 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             if let Some(def) = self_ty.ty_adt_def() {\n                 // We also want to be able to select self's original\n                 // signature with no type arguments resolved\n-                flags.push((sym::_Self, Some(self.tcx.type_of(def.did()).to_string())));\n+                flags.push((\n+                    sym::_Self,\n+                    Some(self.tcx.type_of(def.did()).subst_identity().to_string()),\n+                ));\n             }\n \n             for param in generics.params.iter() {\n@@ -218,7 +221,10 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     if let Some(def) = param_ty.ty_adt_def() {\n                         // We also want to be able to select the parameter's\n                         // original signature with no type arguments resolved\n-                        flags.push((name, Some(self.tcx.type_of(def.did()).to_string())));\n+                        flags.push((\n+                            name,\n+                            Some(self.tcx.type_of(def.did()).subst_identity().to_string()),\n+                        ));\n                     }\n                 }\n             }\n@@ -251,7 +257,10 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 if let Some(def) = aty.ty_adt_def() {\n                     // We also want to be able to select the slice's type's original\n                     // signature with no type arguments resolved\n-                    flags.push((sym::_Self, Some(format!(\"[{}]\", self.tcx.type_of(def.did())))));\n+                    flags.push((\n+                        sym::_Self,\n+                        Some(format!(\"[{}]\", self.tcx.type_of(def.did()).subst_identity())),\n+                    ));\n                 }\n                 if aty.is_integral() {\n                     flags.push((sym::_Self, Some(\"[{integral}]\".to_string())));\n@@ -269,7 +278,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 if let Some(def) = aty.ty_adt_def() {\n                     // We also want to be able to select the array's type's original\n                     // signature with no type arguments resolved\n-                    let def_ty = self.tcx.type_of(def.did());\n+                    let def_ty = self.tcx.type_of(def.did()).subst_identity();\n                     flags.push((sym::_Self, Some(format!(\"[{def_ty}; _]\"))));\n                     if let Some(n) = len {\n                         flags.push((sym::_Self, Some(format!(\"[{def_ty}; {n}]\"))));"}, {"sha": "91b463800a8144dd6fb2d3dc0a55c614443849e4", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -82,11 +82,8 @@ impl<'tcx, 'a> GeneratorData<'tcx, 'a> {\n                     upvars.iter().find_map(|(upvar_id, upvar)| {\n                         let upvar_ty = typeck_results.node_type(*upvar_id);\n                         let upvar_ty = infer_context.resolve_vars_if_possible(upvar_ty);\n-                        if ty_matches(ty::Binder::dummy(upvar_ty)) {\n-                            Some(GeneratorInteriorOrUpvar::Upvar(upvar.span))\n-                        } else {\n-                            None\n-                        }\n+                        ty_matches(ty::Binder::dummy(upvar_ty))\n+                            .then(|| GeneratorInteriorOrUpvar::Upvar(upvar.span))\n                     })\n                 })\n             }\n@@ -770,15 +767,13 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             obligation.param_env,\n                             real_trait_pred_and_ty,\n                         );\n-                        if obligations\n+                        let may_hold = obligations\n                             .iter()\n                             .chain([&obligation])\n                             .all(|obligation| self.predicate_may_hold(obligation))\n-                        {\n-                            Some(steps)\n-                        } else {\n-                            None\n-                        }\n+                            .then_some(steps);\n+\n+                        may_hold\n                     })\n                 {\n                     if steps > 0 {\n@@ -1061,7 +1056,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n         let self_ty = self.resolve_vars_if_possible(trait_pred.self_ty());\n-        let ty = self.tcx.erase_late_bound_regions(self_ty);\n+        let ty = self.instantiate_binder_with_placeholders(self_ty);\n         let Some(generics) = self.tcx.hir().get_generics(obligation.cause.body_id) else { return false };\n         let ty::Ref(_, inner_ty, hir::Mutability::Not) = ty.kind() else { return false };\n         let ty::Param(param) = inner_ty.kind() else { return false };\n@@ -2017,7 +2012,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let sig = match inputs.kind() {\n                 ty::Tuple(inputs) if infcx.tcx.is_fn_trait(trait_ref.def_id()) => {\n                     infcx.tcx.mk_fn_sig(\n-                        inputs.iter(),\n+                        *inputs,\n                         infcx.next_ty_var(TypeVariableOrigin {\n                             span: DUMMY_SP,\n                             kind: TypeVariableOriginKind::MiscVariable,\n@@ -2028,7 +2023,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     )\n                 }\n                 _ => infcx.tcx.mk_fn_sig(\n-                    std::iter::once(inputs),\n+                    [inputs],\n                     infcx.next_ty_var(TypeVariableOrigin {\n                         span: DUMMY_SP,\n                         kind: TypeVariableOriginKind::MiscVariable,\n@@ -3148,7 +3143,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     parent_trait_pred.print_modifiers_and_trait_path()\n                 );\n                 let mut is_auto_trait = false;\n-                match self.tcx.hir().get_if_local(data.impl_def_id) {\n+                match self.tcx.hir().get_if_local(data.impl_or_alias_def_id) {\n                     Some(Node::Item(hir::Item {\n                         kind: hir::ItemKind::Trait(is_auto, ..),\n                         ident,"}, {"sha": "deeed930e50e240a88e7858a87fe74283c45902f", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -313,6 +313,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 }\n                 ty::PredicateKind::Clause(ty::Clause::RegionOutlives(_))\n                 | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(_))\n+                | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n                 | ty::PredicateKind::WellFormed(_)\n                 | ty::PredicateKind::ObjectSafe(_)\n                 | ty::PredicateKind::ClosureKind(..)\n@@ -600,6 +601,19 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 ty::PredicateKind::AliasEq(..) => {\n                     bug!(\"AliasEq is only used for new solver\")\n                 }\n+                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                    match self\n+                        .selcx\n+                        .infcx\n+                        .at(&obligation.cause, obligation.param_env)\n+                        .eq(ct.ty(), ty)\n+                    {\n+                        Ok(inf_ok) => ProcessResult::Changed(mk_pending(inf_ok.into_obligations())),\n+                        Err(_) => ProcessResult::Error(FulfillmentErrorCode::CodeSelectionError(\n+                            SelectionError::Unimplemented,\n+                        )),\n+                    }\n+                }\n             },\n         }\n     }"}, {"sha": "2d299486ee6858e5ee80587f3a32450610ffa238", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -523,16 +523,14 @@ fn is_impossible_method(tcx: TyCtxt<'_>, (impl_def_id, trait_item_def_id): (DefI\n \n     let mut visitor = ReferencesOnlyParentGenerics { tcx, generics, trait_item_def_id };\n     let predicates_for_trait = predicates.predicates.iter().filter_map(|(pred, span)| {\n-        if pred.visit_with(&mut visitor).is_continue() {\n-            Some(Obligation::new(\n+        pred.visit_with(&mut visitor).is_continue().then(|| {\n+            Obligation::new(\n                 tcx,\n                 ObligationCause::dummy_with_span(*span),\n                 param_env,\n                 ty::EarlyBinder(*pred).subst(tcx, impl_trait_ref.substs),\n-            ))\n-        } else {\n-            None\n-        }\n+            )\n+        })\n     });\n \n     let infcx = tcx.infer_ctxt().ignoring_regions().build();"}, {"sha": "df1aeed941d7c76f480a488ceaf8e369a54efb2d", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -97,7 +97,7 @@ fn check_is_object_safe(tcx: TyCtxt<'_>, trait_def_id: DefId) -> bool {\n /// object. Note that object-safe traits can have some\n /// non-vtable-safe methods, so long as they require `Self: Sized` or\n /// otherwise ensure that they cannot be used when `Self = Trait`.\n-pub fn is_vtable_safe_method(tcx: TyCtxt<'_>, trait_def_id: DefId, method: &ty::AssocItem) -> bool {\n+pub fn is_vtable_safe_method(tcx: TyCtxt<'_>, trait_def_id: DefId, method: ty::AssocItem) -> bool {\n     debug_assert!(tcx.generics_of(trait_def_id).has_self);\n     debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n     // Any method that has a `Self: Sized` bound cannot be called.\n@@ -120,8 +120,8 @@ fn object_safety_violations_for_trait(\n         .associated_items(trait_def_id)\n         .in_definition_order()\n         .filter(|item| item.kind == ty::AssocKind::Fn)\n-        .filter_map(|item| {\n-            object_safety_violation_for_method(tcx, trait_def_id, &item)\n+        .filter_map(|&item| {\n+            object_safety_violation_for_method(tcx, trait_def_id, item)\n                 .map(|(code, span)| ObjectSafetyViolation::Method(item.name, code, span))\n         })\n         .collect();\n@@ -307,7 +307,7 @@ fn predicate_references_self<'tcx>(\n     match predicate.kind().skip_binder() {\n         ty::PredicateKind::Clause(ty::Clause::Trait(ref data)) => {\n             // In the case of a trait predicate, we can skip the \"self\" type.\n-            if data.trait_ref.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n+            data.trait_ref.substs[1..].iter().any(has_self_ty).then_some(sp)\n         }\n         ty::PredicateKind::Clause(ty::Clause::Projection(ref data)) => {\n             // And similarly for projections. This should be redundant with\n@@ -325,8 +325,12 @@ fn predicate_references_self<'tcx>(\n             //\n             // This is ALT2 in issue #56288, see that for discussion of the\n             // possible alternatives.\n-            if data.projection_ty.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n+            data.projection_ty.substs[1..].iter().any(has_self_ty).then_some(sp)\n         }\n+        ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(_ct, ty)) => {\n+            has_self_ty(&ty.into()).then_some(sp)\n+        }\n+\n         ty::PredicateKind::AliasEq(..) => bug!(\"`AliasEq` not allowed as assumption\"),\n \n         ty::PredicateKind::WellFormed(..)\n@@ -362,6 +366,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n                 trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n             }\n             ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+            | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n@@ -382,7 +387,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n fn object_safety_violation_for_method(\n     tcx: TyCtxt<'_>,\n     trait_def_id: DefId,\n-    method: &ty::AssocItem,\n+    method: ty::AssocItem,\n ) -> Option<(MethodViolationCode, Span)> {\n     debug!(\"object_safety_violation_for_method({:?}, {:?})\", trait_def_id, method);\n     // Any method that has a `Self : Sized` requisite is otherwise\n@@ -415,7 +420,7 @@ fn object_safety_violation_for_method(\n fn virtual_call_violation_for_method<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_def_id: DefId,\n-    method: &ty::AssocItem,\n+    method: ty::AssocItem,\n ) -> Option<MethodViolationCode> {\n     let sig = tcx.fn_sig(method.def_id).subst_identity();\n \n@@ -527,8 +532,7 @@ fn virtual_call_violation_for_method<'tcx>(\n                 }\n             }\n \n-            let trait_object_ty =\n-                object_ty_for_trait(tcx, trait_def_id, tcx.mk_region(ty::ReStatic));\n+            let trait_object_ty = object_ty_for_trait(tcx, trait_def_id, tcx.lifetimes.re_static);\n \n             // e.g., `Rc<dyn Trait>`\n             let trait_object_receiver =\n@@ -718,7 +722,7 @@ fn object_ty_for_trait<'tcx>(\n #[allow(dead_code)]\n fn receiver_is_dispatchable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    method: &ty::AssocItem,\n+    method: ty::AssocItem,\n     receiver_ty: Ty<'tcx>,\n ) -> bool {\n     debug!(\"receiver_is_dispatchable: method = {:?}, receiver_ty = {:?}\", method, receiver_ty);"}, {"sha": "9b3249e58e8db433dea2feb3af8bbac8df2987ab", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -514,7 +514,7 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                         }\n \n                         let substs = substs.fold_with(self);\n-                        let generic_ty = self.interner().bound_type_of(def_id);\n+                        let generic_ty = self.interner().type_of(def_id);\n                         let concrete_ty = generic_ty.subst(self.interner(), substs);\n                         self.depth += 1;\n                         let folded_ty = self.fold_ty(concrete_ty);\n@@ -767,7 +767,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for BoundVarReplacer<'_, 'tcx> {\n                 let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderRegion { universe, name: br.kind };\n                 self.mapped_regions.insert(p, br);\n-                self.infcx.tcx.mk_region(ty::RePlaceholder(p))\n+                self.infcx.tcx.mk_re_placeholder(p)\n             }\n             _ => r,\n         }\n@@ -888,7 +888,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for PlaceholderReplacer<'_, 'tcx> {\n                         let db = ty::DebruijnIndex::from_usize(\n                             self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n                         );\n-                        self.interner().mk_region(ty::ReLateBound(db, *replace_var))\n+                        self.interner().mk_re_late_bound(db, *replace_var)\n                     }\n                     None => r1,\n                 }\n@@ -1923,7 +1923,7 @@ fn confirm_builtin_candidate<'cx, 'tcx>(\n ) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n     let self_ty = obligation.predicate.self_ty();\n-    let substs = tcx.mk_substs([self_ty.into()].iter());\n+    let substs = tcx.intern_substs(&[self_ty.into()]);\n     let lang_items = tcx.lang_items();\n     let item_def_id = obligation.predicate.def_id;\n     let trait_def_id = tcx.trait_of_item(item_def_id).unwrap();\n@@ -2138,7 +2138,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n     let substs =\n         translate_substs(selcx.infcx, param_env, impl_def_id, substs, assoc_ty.defining_node);\n-    let ty = tcx.bound_type_of(assoc_ty.item.def_id);\n+    let ty = tcx.type_of(assoc_ty.item.def_id);\n     let is_const = matches!(tcx.def_kind(assoc_ty.item.def_id), DefKind::AssocConst);\n     let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n         let identity_substs =\n@@ -2149,7 +2149,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     } else {\n         ty.map_bound(|ty| ty.into())\n     };\n-    if !check_substs_compatible(tcx, &assoc_ty.item, substs) {\n+    if !check_substs_compatible(tcx, assoc_ty.item, substs) {\n         let err = tcx.ty_error_with_message(\n             obligation.cause.span,\n             \"impl item and trait item have different parameters\",\n@@ -2164,7 +2164,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n // Verify that the trait item and its implementation have compatible substs lists\n fn check_substs_compatible<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    assoc_item: &ty::AssocItem,\n+    assoc_item: ty::AssocItem,\n     substs: ty::SubstsRef<'tcx>,\n ) -> bool {\n     fn check_substs_compatible_inner<'tcx>(\n@@ -2238,7 +2238,7 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n         leaf_def.defining_node,\n     );\n \n-    if !check_substs_compatible(tcx, &leaf_def.item, impl_fn_substs) {\n+    if !check_substs_compatible(tcx, leaf_def.item, impl_fn_substs) {\n         let err = tcx.ty_error_with_message(\n             obligation.cause.span,\n             \"impl method and trait method have different parameters\","}, {"sha": "a266013b8fd4fb9a0b7cb725a2d8f40d1bdfcc6d", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -228,7 +228,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                             return ty.try_super_fold_with(self);\n                         }\n \n-                        let generic_ty = self.interner().bound_type_of(def_id);\n+                        let generic_ty = self.interner().type_of(def_id);\n                         let concrete_ty = generic_ty.subst(self.interner(), substs);\n                         self.anon_depth += 1;\n                         if concrete_ty == ty {"}, {"sha": "21ef4e24fdb05c21b851782e0753fc58935a5dca", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/outlives.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -21,11 +21,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for DropckOutlives<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n-        if trivial_dropck_outlives(tcx, key.value.dropped_ty) {\n-            Some(DropckOutlivesResult::default())\n-        } else {\n-            None\n-        }\n+        trivial_dropck_outlives(tcx, key.value.dropped_ty).then(DropckOutlivesResult::default)\n     }\n \n     fn perform_query("}, {"sha": "dae602908a31f6edf7da836778e8e8055e1b81c6", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -396,7 +396,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // still be provided by a manual implementation for\n                     // this trait and type.\n                 }\n-                ty::Param(..) | ty::Alias(ty::Projection, ..) => {\n+                ty::Param(..)\n+                | ty::Alias(ty::Projection, ..)\n+                | ty::Placeholder(..)\n+                | ty::Bound(..) => {\n                     // In these cases, we don't know what the actual\n                     // type is. Therefore, we cannot break it down\n                     // into its constituent types. So we don't\n@@ -448,6 +451,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         );\n \n         self.infcx.probe(|_snapshot| {\n+            if obligation.has_non_region_late_bound() {\n+                return;\n+            }\n+\n             // The code below doesn't care about regions, and the\n             // self-ty here doesn't escape this probe, so just erase\n             // any LBR."}, {"sha": "e4a832e472813dbc520899972e4128750e6d108a", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -540,13 +540,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 let kind = ty::BoundRegionKind::BrNamed(param.def_id, param.name);\n                                 let bound_var = ty::BoundVariableKind::Region(kind);\n                                 bound_vars.push(bound_var);\n-                                tcx.mk_region(ty::ReLateBound(\n+                                tcx.mk_re_late_bound(\n                                     ty::INNERMOST,\n                                     ty::BoundRegion {\n                                         var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n                                         kind,\n                                     },\n-                                ))\n+                                )\n                                 .into()\n                             }\n                             GenericParamDefKind::Const { .. } => {\n@@ -557,15 +557,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                         ty::INNERMOST,\n                                         ty::BoundVar::from_usize(bound_vars.len() - 1),\n                                     ),\n-                                    tcx.type_of(param.def_id),\n+                                    tcx.type_of(param.def_id)\n+                                        .no_bound_vars()\n+                                        .expect(\"const parameter types cannot be generic\"),\n                                 )\n                                 .into()\n                             }\n                         });\n-                        let bound_vars = tcx.mk_bound_variable_kinds(bound_vars.into_iter());\n+                        let bound_vars = tcx.intern_bound_variable_kinds(&bound_vars);\n                         let assoc_ty_substs = tcx.intern_substs(&substs);\n-\n-                        let bound_vars = tcx.mk_bound_variable_kinds(bound_vars.into_iter());\n                         let bound =\n                             bound.map_bound(|b| b.kind().skip_binder()).subst(tcx, assoc_ty_substs);\n                         tcx.mk_predicate(ty::Binder::bind_with_vars(bound, bound_vars))\n@@ -1073,7 +1073,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     .fields\n                     .last()\n                     .expect(\"expected unsized ADT to have a tail field\");\n-                let tail_field_ty = tcx.bound_type_of(tail_field.did);\n+                let tail_field_ty = tcx.type_of(tail_field.did);\n \n                 // Extract `TailField<T>` and `TailField<U>` from `Struct<T>` and `Struct<U>`,\n                 // normalizing in the process, since `type_of` returns something directly from\n@@ -1189,7 +1189,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let cause = obligation.derived_cause(|derived| {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n-                    impl_def_id,\n+                    impl_or_alias_def_id: impl_def_id,\n                     impl_def_predicate_index: None,\n                     span: obligation.cause.span,\n                 }))"}, {"sha": "e6fc9bb92397941443689ac1dcf793ffdacf4445", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -378,11 +378,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             let self_ty = trait_ref.self_ty();\n                             let (trait_desc, self_desc) = with_no_trimmed_paths!({\n                                 let trait_desc = trait_ref.print_only_trait_path().to_string();\n-                                let self_desc = if self_ty.has_concrete_skeleton() {\n-                                    Some(self_ty.to_string())\n-                                } else {\n-                                    None\n-                                };\n+                                let self_desc =\n+                                    self_ty.has_concrete_skeleton().then(|| self_ty.to_string());\n                                 (trait_desc, self_desc)\n                             });\n                             let cause = if let Conflict::Upstream = conflict {\n@@ -996,6 +993,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     bug!(\"AliasEq is only used for new solver\")\n                 }\n                 ty::PredicateKind::Ambiguous => Ok(EvaluatedToAmbig),\n+                ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+                    match self.infcx.at(&obligation.cause, obligation.param_env).eq(ct.ty(), ty) {\n+                        Ok(inf_ok) => self.evaluate_predicates_recursively(\n+                            previous_stack,\n+                            inf_ok.into_obligations(),\n+                        ),\n+                        Err(_) => Ok(EvaluatedToErr),\n+                    }\n+                }\n             }\n         })\n     }\n@@ -2353,7 +2359,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // We can resolve the `impl Trait` to its concrete type,\n                 // which enforces a DAG between the functions requiring\n                 // the auto trait bounds in question.\n-                t.rebind(vec![self.tcx().bound_type_of(def_id).subst(self.tcx(), substs)])\n+                t.rebind(vec![self.tcx().type_of(def_id).subst(self.tcx(), substs)])\n             }\n         }\n     }\n@@ -2660,7 +2666,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let cause = cause.clone().derived_cause(parent_trait_pred, |derived| {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n-                    impl_def_id: def_id,\n+                    impl_or_alias_def_id: def_id,\n                     impl_def_predicate_index: Some(index),\n                     span,\n                 }))\n@@ -3023,7 +3029,7 @@ fn bind_generator_hidden_types_above<'tcx>(\n                             kind: ty::BrAnon(counter, None),\n                         };\n                         counter += 1;\n-                        r = tcx.mk_region(ty::ReLateBound(current_depth, br));\n+                        r = tcx.mk_re_late_bound(current_depth, br);\n                     }\n                     r\n                 })"}, {"sha": "d1d6a7a90cf74b29916e314b90daad76fa6fb492", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -455,7 +455,13 @@ pub(crate) fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Opti\n         w.push('>');\n     }\n \n-    write!(w, \" {} for {}\", trait_ref.print_only_trait_path(), tcx.type_of(impl_def_id)).unwrap();\n+    write!(\n+        w,\n+        \" {} for {}\",\n+        trait_ref.print_only_trait_path(),\n+        tcx.type_of(impl_def_id).subst_identity()\n+    )\n+    .unwrap();\n \n     // The predicates will contain default bounds like `T: Sized`. We need to\n     // remove these bounds, and add `T: ?Sized` to any untouched type parameters."}, {"sha": "2e4a5cfe4bcf94c691aa029f87ddacdf051fd006", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -113,7 +113,7 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n                     // Only report the `Self` type if it has at least\n                     // some outer concrete shell; otherwise, it's\n                     // not adding much information.\n-                    self_ty: if self_ty.has_concrete_skeleton() { Some(self_ty) } else { None },\n+                    self_ty: self_ty.has_concrete_skeleton().then_some(self_ty),\n                     intercrate_ambiguity_causes: overlap.intercrate_ambiguity_causes,\n                     involves_placeholder: overlap.involves_placeholder,\n                 }\n@@ -399,7 +399,7 @@ pub(crate) fn assoc_def(\n     // If there is no such item in that impl, this function will fail with a\n     // cycle error if the specialization graph is currently being built.\n     if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_def_id) {\n-        let &item = tcx.associated_item(impl_item_id);\n+        let item = tcx.associated_item(impl_item_id);\n         let impl_node = Node::Impl(impl_def_id);\n         return Ok(LeafDef {\n             item,"}, {"sha": "9f5c5bbeac8de2c3c89e29f75805e1ded65e8c87", "filename": "compiler/rustc_trait_selection/src/traits/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -197,12 +197,12 @@ fn own_existential_vtable_entries(tcx: TyCtxt<'_>, trait_def_id: DefId) -> &[Def\n         .in_definition_order()\n         .filter(|item| item.kind == ty::AssocKind::Fn);\n     // Now list each method's DefId (for within its trait).\n-    let own_entries = trait_methods.filter_map(move |trait_method| {\n+    let own_entries = trait_methods.filter_map(move |&trait_method| {\n         debug!(\"own_existential_vtable_entry: trait_method={:?}\", trait_method);\n         let def_id = trait_method.def_id;\n \n         // Some methods cannot be called on an object; skip those.\n-        if !is_vtable_safe_method(tcx, trait_def_id, &trait_method) {\n+        if !is_vtable_safe_method(tcx, trait_def_id, trait_method) {\n             debug!(\"own_existential_vtable_entry: not vtable safe\");\n             return None;\n         }"}, {"sha": "6a881c233db093eed446a5b0345d451068a371af", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -163,6 +163,10 @@ pub fn predicate_obligations<'tcx>(\n                 ty::TermKind::Const(c) => c.into(),\n             })\n         }\n+        ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n+            wf.compute(ct.into());\n+            wf.compute(ty.into());\n+        }\n         ty::PredicateKind::WellFormed(arg) => {\n             wf.compute(arg);\n         }\n@@ -922,6 +926,7 @@ pub(crate) fn required_region_bounds<'tcx>(\n             match obligation.predicate.kind().skip_binder() {\n                 ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                 | ty::PredicateKind::Clause(ty::Clause::Trait(..))\n+                | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::WellFormed(..)"}, {"sha": "e2b5d17e07300d90967de9a19535e93e2ee4f3ad", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -246,7 +246,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         // Grab the ADT and the param we might need to calculate its layout\n         let param_env = tcx.param_env(did);\n-        let adt_ty = tcx.type_of(did);\n+        let adt_ty = tcx.type_of(did).subst_identity();\n \n         // The ADT is a 1-zst if it's a ZST and its alignment is 1.\n         // Mark the ADT as _not_ a 1-zst if there was a layout error.\n@@ -468,7 +468,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let ty = self\n             .interner\n             .tcx\n-            .bound_type_of(def_id)\n+            .type_of(def_id)\n             .subst(self.interner.tcx, bound_vars)\n             .lower_into(self.interner);\n \n@@ -732,13 +732,13 @@ fn bound_vars_for_item(tcx: TyCtxt<'_>, def_id: DefId) -> SubstsRef<'_> {\n                 var: ty::BoundVar::from_usize(substs.len()),\n                 kind: ty::BrAnon(substs.len() as u32, None),\n             };\n-            tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n+            tcx.mk_re_late_bound(ty::INNERMOST, br).into()\n         }\n \n         ty::GenericParamDefKind::Const { .. } => tcx\n             .mk_const(\n                 ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from(param.index)),\n-                tcx.type_of(param.def_id),\n+                tcx.type_of(param.def_id).subst_identity(),\n             )\n             .into(),\n     })"}, {"sha": "7635f4bfec3bad4df60b59394f0b487426708549", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -117,6 +117,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                     )),\n                 },\n                 ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n                 | ty::PredicateKind::AliasEq(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n@@ -212,6 +213,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             // We can defer this, but ultimately we'll want to express\n             // some of these in terms of chalk operations.\n             ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n             | ty::PredicateKind::AliasEq(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n@@ -521,24 +523,24 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'t\n \n impl<'tcx> LowerInto<'tcx, Region<'tcx>> for &chalk_ir::Lifetime<RustInterner<'tcx>> {\n     fn lower_into(self, interner: RustInterner<'tcx>) -> Region<'tcx> {\n-        let kind = match self.data(interner) {\n-            chalk_ir::LifetimeData::BoundVar(var) => ty::ReLateBound(\n+        let tcx = interner.tcx;\n+        match self.data(interner) {\n+            chalk_ir::LifetimeData::BoundVar(var) => tcx.mk_re_late_bound(\n                 ty::DebruijnIndex::from_u32(var.debruijn.depth()),\n                 ty::BoundRegion {\n                     var: ty::BoundVar::from_usize(var.index),\n                     kind: ty::BrAnon(var.index as u32, None),\n                 },\n             ),\n             chalk_ir::LifetimeData::InferenceVar(_var) => unimplemented!(),\n-            chalk_ir::LifetimeData::Placeholder(p) => ty::RePlaceholder(ty::Placeholder {\n+            chalk_ir::LifetimeData::Placeholder(p) => tcx.mk_re_placeholder(ty::Placeholder {\n                 universe: ty::UniverseIndex::from_usize(p.ui.counter),\n                 name: ty::BoundRegionKind::BrAnon(p.idx as u32, None),\n             }),\n-            chalk_ir::LifetimeData::Static => return interner.tcx.lifetimes.re_static,\n-            chalk_ir::LifetimeData::Erased => return interner.tcx.lifetimes.re_erased,\n+            chalk_ir::LifetimeData::Static => tcx.lifetimes.re_static,\n+            chalk_ir::LifetimeData::Erased => tcx.lifetimes.re_erased,\n             chalk_ir::LifetimeData::Phantom(void, _) => match *void {},\n-        };\n-        interner.tcx.mk_region(kind)\n+        }\n     }\n }\n \n@@ -646,6 +648,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n                 Some(chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)))\n             }\n             ty::PredicateKind::WellFormed(_ty) => None,\n+            ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => None,\n \n             ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::AliasEq(..)\n@@ -780,6 +783,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n             }\n             ty::PredicateKind::Clause(ty::Clause::TypeOutlives(_predicate)) => None,\n             ty::PredicateKind::WellFormed(_ty) => None,\n+            ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => None,\n \n             ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n             | ty::PredicateKind::AliasEq(..)\n@@ -1025,7 +1029,7 @@ impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for NamedBoundVarSubstitutor<'a, 'tcx> {\n                 ty::BrNamed(def_id, _name) => match self.named_parameters.get(&def_id) {\n                     Some(idx) => {\n                         let new_br = ty::BoundRegion { var: br.var, kind: ty::BrAnon(*idx, None) };\n-                        return self.tcx.mk_region(ty::ReLateBound(index, new_br));\n+                        return self.tcx.mk_re_late_bound(index, new_br);\n                     }\n                     None => panic!(\"Missing `BrNamed`.\"),\n                 },\n@@ -1107,7 +1111,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ParamsSubstitutor<'tcx> {\n                         var: ty::BoundVar::from_u32(*idx),\n                         kind: ty::BrAnon(*idx, None),\n                     };\n-                    self.tcx.mk_region(ty::ReLateBound(self.binder_index, br))\n+                    self.tcx.mk_re_late_bound(self.binder_index, br)\n                 }\n                 None => {\n                     let idx = self.named_regions.len() as u32;\n@@ -1116,7 +1120,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ParamsSubstitutor<'tcx> {\n                         kind: ty::BrAnon(idx, None),\n                     };\n                     self.named_regions.insert(_re.def_id, idx);\n-                    self.tcx.mk_region(ty::ReLateBound(self.binder_index, br))\n+                    self.tcx.mk_re_late_bound(self.binder_index, br)\n                 }\n             },\n "}, {"sha": "b5924e949146bc6471a50d3d229e6a1a7e7132b5", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -308,7 +308,7 @@ pub(crate) fn adt_dtorck_constraint(\n \n     let mut result = DropckConstraint::empty();\n     for field in def.all_fields() {\n-        let fty = tcx.type_of(field.did);\n+        let fty = tcx.type_of(field.did).subst_identity();\n         dtorck_constraint_for_ty(tcx, span, fty, 0, fty, &mut result)?;\n     }\n     result.outlives.extend(tcx.destructor_constraints(def));"}, {"sha": "abf0c1c5f3e9ad55820d4fa35fa24aaf1df4923b", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -99,6 +99,9 @@ fn compute_implied_outlives_bounds<'tcx>(\n             };\n             match pred {\n                 ty::PredicateKind::Clause(ty::Clause::Trait(..))\n+                // FIXME(const_generics): Make sure that `<'a, 'b, const N: &'a &'b u32>` is sound\n+                // if we ever support that\n+                | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::Clause(ty::Clause::Projection(..))"}, {"sha": "2c18a034050742ea2a184d019245bfba4259fd89", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -60,6 +60,7 @@ fn not_outlives_predicate(p: ty::Predicate<'_>) -> bool {\n         | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..)) => false,\n         ty::PredicateKind::Clause(ty::Clause::Trait(..))\n         | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+        | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n         | ty::PredicateKind::AliasEq(..)\n         | ty::PredicateKind::WellFormed(..)\n         | ty::PredicateKind::ObjectSafe(..)"}, {"sha": "d34fce64dd7dc7115610bcfbf93edd4db21ecf49", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -93,7 +93,7 @@ fn relate_mir_and_user_substs<'tcx>(\n     let tcx = ocx.infcx.tcx;\n     let cause = ObligationCause::dummy_with_span(span);\n \n-    let ty = tcx.bound_type_of(def_id).subst(tcx, substs);\n+    let ty = tcx.type_of(def_id).subst(tcx, substs);\n     let ty = ocx.normalize(&cause, param_env, ty);\n     debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n \n@@ -122,7 +122,7 @@ fn relate_mir_and_user_substs<'tcx>(\n \n     if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n         let self_ty = ocx.normalize(&cause, param_env, self_ty);\n-        let impl_self_ty = tcx.bound_type_of(impl_def_id).subst(tcx, substs);\n+        let impl_self_ty = tcx.type_of(impl_def_id).subst(tcx, substs);\n         let impl_self_ty = ocx.normalize(&cause, param_env, impl_self_ty);\n \n         ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;"}, {"sha": "41924dc2a6d936056556d2fe9872c8750467cb05", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -70,7 +70,7 @@ fn fn_sig_for_fn_abi<'tcx>(\n                 var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n                 kind: ty::BoundRegionKind::BrEnv,\n             };\n-            let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+            let env_region = tcx.mk_re_late_bound(ty::INNERMOST, br);\n             let env_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();\n \n             let sig = sig.skip_binder();\n@@ -95,8 +95,7 @@ fn fn_sig_for_fn_abi<'tcx>(\n                 var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n                 kind: ty::BoundRegionKind::BrEnv,\n             };\n-            let env_region = ty::ReLateBound(ty::INNERMOST, br);\n-            let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n+            let env_ty = tcx.mk_mut_ref(tcx.mk_re_late_bound(ty::INNERMOST, br), ty);\n \n             let pin_did = tcx.require_lang_item(LangItem::Pin, None);\n             let pin_adt_ref = tcx.adt_def(pin_did);\n@@ -142,8 +141,8 @@ fn fn_sig_for_fn_abi<'tcx>(\n \n             ty::Binder::bind_with_vars(\n                 tcx.mk_fn_sig(\n-                    [env_ty, resume_ty].iter(),\n-                    &ret_ty,\n+                    [env_ty, resume_ty],\n+                    ret_ty,\n                     false,\n                     hir::Unsafety::Normal,\n                     rustc_target::spec::abi::Abi::Rust,\n@@ -207,11 +206,8 @@ fn fn_abi_of_instance<'tcx>(\n \n     let sig = fn_sig_for_fn_abi(tcx, instance, param_env);\n \n-    let caller_location = if instance.def.requires_caller_location(tcx) {\n-        Some(tcx.caller_location_ty())\n-    } else {\n-        None\n-    };\n+    let caller_location =\n+        instance.def.requires_caller_location(tcx).then(|| tcx.caller_location_ty());\n \n     fn_abi_new_uncached(\n         &LayoutCx { tcx, param_env },"}, {"sha": "164cac6a010facdb2933bd0468d1332be017606f", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -26,7 +26,7 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     }\n }\n \n-fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItems<'_> {\n+fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItems {\n     if tcx.is_trait_alias(def_id) {\n         ty::AssocItems::new(Vec::new())\n     } else {"}, {"sha": "852156c24f42ab249fa3b320242fa1e61c2e4442", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -144,7 +144,7 @@ fn recurse_build<'tcx>(\n             for &id in args.iter() {\n                 new_args.push(recurse_build(tcx, body, id, root_span)?);\n             }\n-            let new_args = tcx.mk_const_list(new_args.iter());\n+            let new_args = tcx.intern_const_list(&new_args);\n             tcx.mk_const(Expr::FunctionCall(fun, new_args), node.ty)\n         }\n         &ExprKind::Binary { op, lhs, rhs } if check_binop(op) => {"}, {"sha": "eb307e66e342d383e94f7f1bd95d89f31186b429", "filename": "compiler/rustc_ty_utils/src/implied_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -28,7 +28,7 @@ fn assumed_wf_types(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::List<Ty<'_>> {\n                     tcx.intern_type_list(&types)\n                 }\n                 // Only the impl self type\n-                None => tcx.intern_type_list(&[tcx.type_of(def_id)]),\n+                None => tcx.intern_type_list(&[tcx.type_of(def_id).subst_identity()]),\n             }\n         }\n         DefKind::AssocConst | DefKind::AssocTy => tcx.assumed_wf_types(tcx.parent(def_id)),"}, {"sha": "de7230b0cfaedb2bd79c24439f624ff754b8ca99", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -53,7 +53,8 @@ fn inner_resolve_instance<'tcx>(\n         )\n     } else {\n         let ty = tcx.type_of(def.def_id_for_type_of());\n-        let item_type = tcx.subst_and_normalize_erasing_regions(substs, param_env, ty);\n+        let item_type =\n+            tcx.subst_and_normalize_erasing_regions(substs, param_env, ty.skip_binder());\n \n         let def = match *item_type.kind() {\n             ty::FnDef(def_id, ..) if tcx.is_intrinsic(def_id) => {"}, {"sha": "b860fb6c9186b3b1bdf46dedd09d14a5cbe00338", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -453,9 +453,10 @@ fn layout_of_uncached<'tcx>(\n                         let param_env = tcx.param_env(def.did());\n                         def.is_struct()\n                             && match def.variants().iter().next().and_then(|x| x.fields.last()) {\n-                                Some(last_field) => {\n-                                    tcx.type_of(last_field.did).is_sized(tcx, param_env)\n-                                }\n+                                Some(last_field) => tcx\n+                                    .type_of(last_field.did)\n+                                    .subst_identity()\n+                                    .is_sized(tcx, param_env),\n                                 None => false,\n                             }\n                     },"}, {"sha": "c177d60bb5967dcc5ecff04dfc7d233f32872146", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -242,7 +242,7 @@ fn drop_tys_helper<'tcx>(\n             Ok(Vec::new())\n         } else {\n             let field_tys = adt_def.all_fields().map(|field| {\n-                let r = tcx.bound_type_of(field.did).subst(tcx, substs);\n+                let r = tcx.type_of(field.did).subst(tcx, substs);\n                 debug!(\"drop_tys_helper: Subst into {:?} with {:?} gettng {:?}\", field, substs, r);\n                 r\n             });\n@@ -295,9 +295,15 @@ fn adt_drop_tys<'tcx>(\n     let adt_has_dtor =\n         |adt_def: ty::AdtDef<'tcx>| adt_def.destructor(tcx).map(|_| DtorType::Significant);\n     // `tcx.type_of(def_id)` identical to `tcx.make_adt(def, identity_substs)`\n-    drop_tys_helper(tcx, tcx.type_of(def_id), tcx.param_env(def_id), adt_has_dtor, false)\n-        .collect::<Result<Vec<_>, _>>()\n-        .map(|components| tcx.intern_type_list(&components))\n+    drop_tys_helper(\n+        tcx,\n+        tcx.type_of(def_id).subst_identity(),\n+        tcx.param_env(def_id),\n+        adt_has_dtor,\n+        false,\n+    )\n+    .collect::<Result<Vec<_>, _>>()\n+    .map(|components| tcx.intern_type_list(&components))\n }\n // If `def_id` refers to a generic ADT, the queries above and below act as if they had been handed\n // a `tcx.make_ty(def, identity_substs)` and as such it is legal to substitute the generic parameters\n@@ -308,7 +314,7 @@ fn adt_significant_drop_tys(\n ) -> Result<&ty::List<Ty<'_>>, AlwaysRequiresDrop> {\n     drop_tys_helper(\n         tcx,\n-        tcx.type_of(def_id), // identical to `tcx.make_adt(def, identity_substs)`\n+        tcx.type_of(def_id).subst_identity(), // identical to `tcx.make_adt(def, identity_substs)`\n         tcx.param_env(def_id),\n         adt_consider_insignificant_dtor(tcx),\n         true,"}, {"sha": "591017eecd2e0ed541419e52a24d6fb48179567d", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -31,7 +31,7 @@ fn representability(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Representability {\n             }\n             Representability::Representable\n         }\n-        DefKind::Field => representability_ty(tcx, tcx.type_of(def_id)),\n+        DefKind::Field => representability_ty(tcx, tcx.type_of(def_id).subst_identity()),\n         def_kind => bug!(\"unexpected {def_kind:?}\"),\n     }\n }\n@@ -91,7 +91,7 @@ fn params_in_repr(tcx: TyCtxt<'_>, def_id: DefId) -> BitSet<u32> {\n     let mut params_in_repr = BitSet::new_empty(generics.params.len());\n     for variant in adt_def.variants() {\n         for field in variant.fields.iter() {\n-            params_in_repr_ty(tcx, tcx.type_of(field.did), &mut params_in_repr);\n+            params_in_repr_ty(tcx, tcx.type_of(field.did).subst_identity(), &mut params_in_repr);\n         }\n     }\n     params_in_repr"}, {"sha": "2c50b766d21f619ae57d77ddfcf22ec2ffb3e3a6", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1,7 +1,9 @@\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n-use rustc_middle::ty::{self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{\n+    self, Binder, EarlyBinder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt,\n+};\n use rustc_session::config::TraitSolver;\n use rustc_span::def_id::{DefId, CRATE_DEF_ID};\n use rustc_trait_selection::traits;\n@@ -103,7 +105,7 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> &[Ty<'_>] {\n         def.variants()\n             .iter()\n             .flat_map(|v| v.fields.last())\n-            .flat_map(|f| sized_constraint_for_ty(tcx, def, tcx.type_of(f.did))),\n+            .flat_map(|f| sized_constraint_for_ty(tcx, def, tcx.type_of(f.did).subst_identity())),\n     );\n \n     debug!(\"adt_sized_constraint: {:?} => {:?}\", def, result);\n@@ -299,7 +301,7 @@ fn well_formed_types_in_env(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::List<Predica\n         // In an inherent impl, we assume that the receiver type and all its\n         // constituents are well-formed.\n         NodeKind::InherentImpl => {\n-            let self_ty = tcx.type_of(def_id);\n+            let self_ty = tcx.type_of(def_id).subst_identity();\n             inputs.extend(self_ty.walk());\n         }\n \n@@ -355,7 +357,7 @@ fn instance_def_size_estimate<'tcx>(\n /// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n ///\n /// See [`ty::ImplOverlapKind::Issue33140`] for more details.\n-fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n+fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<EarlyBinder<Ty<'_>>> {\n     debug!(\"issue33140_self_ty({:?})\", def_id);\n \n     let trait_ref = tcx\n@@ -394,7 +396,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n \n     if self_ty_matches {\n         debug!(\"issue33140_self_ty - MATCHES!\");\n-        Some(self_ty)\n+        Some(EarlyBinder(self_ty))\n     } else {\n         debug!(\"issue33140_self_ty - non-matching self type\");\n         None\n@@ -434,7 +436,7 @@ fn unsizing_params_for_adt<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> BitSet<u32\n     };\n \n     let mut unsizing_params = BitSet::new_empty(num_params);\n-    for arg in tcx.bound_type_of(tail_field.did).subst_identity().walk() {\n+    for arg in tcx.type_of(tail_field.did).subst_identity().walk() {\n         if let Some(i) = maybe_unsizing_param_idx(arg) {\n             unsizing_params.insert(i);\n         }\n@@ -443,7 +445,7 @@ fn unsizing_params_for_adt<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> BitSet<u32\n     // Ensure none of the other fields mention the parameters used\n     // in unsizing.\n     for field in prefix_fields {\n-        for arg in tcx.bound_type_of(field.did).subst_identity().walk() {\n+        for arg in tcx.type_of(field.did).subst_identity().walk() {\n             if let Some(i) = maybe_unsizing_param_idx(arg) {\n                 unsizing_params.remove(i);\n             }"}, {"sha": "5a991e03dee52bcd42a0e6e72a9af0fba945fa7a", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -69,38 +69,37 @@ pub trait Interner: Sized {\n     type PlaceholderRegion: Clone + Debug + Hash + Ord;\n }\n \n-pub trait InternAs<T: ?Sized, R> {\n+/// Imagine you have a function `F: FnOnce(&[T]) -> R`, plus an iterator `iter`\n+/// that produces `T` items. You could combine them with\n+/// `f(&iter.collect::<Vec<_>>())`, but this requires allocating memory for the\n+/// `Vec`.\n+///\n+/// This trait allows for faster implementations, intended for cases where the\n+/// number of items produced by the iterator is small. There is a blanket impl\n+/// for `T` items, but there is also a fallible impl for `Result<T, E>` items.\n+pub trait CollectAndApply<T, R>: Sized {\n     type Output;\n-    fn intern_with<F>(self, f: F) -> Self::Output\n+\n+    /// Produce a result of type `Self::Output` from `iter`. The result will\n+    /// typically be produced by applying `f` on the elements produced by\n+    /// `iter`, though this may not happen in some impls, e.g. if an error\n+    /// occured during iteration.\n+    fn collect_and_apply<I, F>(iter: I, f: F) -> Self::Output\n     where\n+        I: Iterator<Item = Self>,\n         F: FnOnce(&[T]) -> R;\n }\n \n-impl<I, T, R, E> InternAs<T, R> for I\n-where\n-    E: InternIteratorElement<T, R>,\n-    I: Iterator<Item = E>,\n-{\n-    type Output = E::Output;\n-    fn intern_with<F>(self, f: F) -> Self::Output\n+/// The blanket impl that always collects all elements and applies `f`.\n+impl<T, R> CollectAndApply<T, R> for T {\n+    type Output = R;\n+\n+    /// Equivalent to `f(&iter.collect::<Vec<_>>())`.\n+    fn collect_and_apply<I, F>(mut iter: I, f: F) -> R\n     where\n+        I: Iterator<Item = T>,\n         F: FnOnce(&[T]) -> R,\n     {\n-        E::intern_with(self, f)\n-    }\n-}\n-\n-pub trait InternIteratorElement<T, R>: Sized {\n-    type Output;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output;\n-}\n-\n-impl<T, R> InternIteratorElement<T, R> for T {\n-    type Output = R;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n-        mut iter: I,\n-        f: F,\n-    ) -> Self::Output {\n         // This code is hot enough that it's worth specializing for the most\n         // common length lists, to avoid the overhead of `SmallVec` creation.\n         // Lengths 0, 1, and 2 typically account for ~95% of cases. If\n@@ -127,23 +126,17 @@ impl<T, R> InternIteratorElement<T, R> for T {\n     }\n }\n \n-impl<'a, T, R> InternIteratorElement<T, R> for &'a T\n-where\n-    T: Clone + 'a,\n-{\n-    type Output = R;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n-        // This code isn't hot.\n-        f(&iter.cloned().collect::<SmallVec<[_; 8]>>())\n-    }\n-}\n-\n-impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n+/// A fallible impl that will fail, without calling `f`, if there are any\n+/// errors during collection.\n+impl<T, R, E> CollectAndApply<T, R> for Result<T, E> {\n     type Output = Result<R, E>;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n-        mut iter: I,\n-        f: F,\n-    ) -> Self::Output {\n+\n+    /// Equivalent to `Ok(f(&iter.collect::<Result<Vec<_>>>()?))`.\n+    fn collect_and_apply<I, F>(mut iter: I, f: F) -> Result<R, E>\n+    where\n+        I: Iterator<Item = Result<T, E>>,\n+        F: FnOnce(&[T]) -> R,\n+    {\n         // This code is hot enough that it's worth specializing for the most\n         // common length lists, to avoid the overhead of `SmallVec` creation.\n         // Lengths 0, 1, and 2 typically account for ~95% of cases. If"}, {"sha": "9e3e13e70040e953c7c48298aeccc8d4d5b68368", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -3502,8 +3502,10 @@ pub trait Iterator {\n         }\n     }\n \n-    /// [Lexicographically](Ord#lexicographical-comparison) compares the elements of this [`Iterator`] with those\n-    /// of another.\n+    /// [Lexicographically](Ord#lexicographical-comparison) compares the [`PartialOrd`] elements of\n+    /// this [`Iterator`] with those of another. The comparison works like short-circuit\n+    /// evaluation, returning a result without comparing the remaining elements.\n+    /// As soon as an order can be determined, the evaluation stops and a result is returned.\n     ///\n     /// # Examples\n     ///\n@@ -3513,9 +3515,25 @@ pub trait Iterator {\n     /// assert_eq!([1.].iter().partial_cmp([1.].iter()), Some(Ordering::Equal));\n     /// assert_eq!([1.].iter().partial_cmp([1., 2.].iter()), Some(Ordering::Less));\n     /// assert_eq!([1., 2.].iter().partial_cmp([1.].iter()), Some(Ordering::Greater));\n+    /// ```\n     ///\n+    /// For floating-point numbers, NaN does not have a total order and will result\n+    /// in `None` when compared:\n+    ///\n+    /// ```\n     /// assert_eq!([f64::NAN].iter().partial_cmp([1.].iter()), None);\n     /// ```\n+    ///\n+    /// The results are determined by the order of evaluation.\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// assert_eq!([1.0, f64::NAN].iter().partial_cmp([2.0, f64::NAN].iter()), Some(Ordering::Less));\n+    /// assert_eq!([2.0, f64::NAN].iter().partial_cmp([1.0, f64::NAN].iter()), Some(Ordering::Greater));\n+    /// assert_eq!([f64::NAN, 1.0].iter().partial_cmp([f64::NAN, 2.0].iter()), None);\n+    /// ```\n+    ///\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn partial_cmp<I>(self, other: I) -> Option<Ordering>\n     where"}, {"sha": "ff7821fb9ff0851c19690a53f3ee1f052ecf4d77", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -58,9 +58,10 @@ fn args(builder: &Builder<'_>) -> Vec<String> {\n         clippy_lint_warn.iter().for_each(|v| clippy_lint_levels.push(format!(\"-W{}\", v)));\n         clippy_lint_forbid.iter().for_each(|v| clippy_lint_levels.push(format!(\"-F{}\", v)));\n         args.extend(clippy_lint_levels);\n+        args.extend(builder.config.free_args.clone());\n         args\n     } else {\n-        vec![]\n+        builder.config.free_args.clone()\n     }\n }\n "}, {"sha": "e7d7215166b42384dcb78be8231cf87984c2d0b8", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -445,6 +445,72 @@ impl Step for StdLink {\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n         let hostdir = builder.sysroot_libdir(target_compiler, compiler.host);\n         add_to_sysroot(builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n+\n+        if compiler.stage == 0 {\n+            // special handling for stage0, to make `rustup toolchain link` and `x dist --stage 0`\n+            // work for stage0-sysroot\n+            let sysroot = builder.out.join(&compiler.host.triple).join(\"stage0-sysroot\");\n+\n+            let host_lib_dir = builder.initial_rustc.ancestors().nth(2).unwrap().join(\"lib\");\n+            let host_bin_dir = builder.out.join(&builder.initial_rustc.parent().unwrap());\n+            let host_codegen_backends =\n+                host_lib_dir.join(\"rustlib\").join(&compiler.host.triple).join(\"codegen-backends\");\n+            let sysroot_bin_dir = sysroot.join(\"bin\");\n+            let sysroot_lib_dir = sysroot.join(\"lib\");\n+            let sysroot_codegen_backends = builder.sysroot_codegen_backends(compiler);\n+\n+            // Create the `bin` directory in stage0-sysroot\n+            t!(fs::create_dir_all(&sysroot_bin_dir));\n+\n+            // copy bin files from `builder.initial_rustc/./` to `stage0-sysroot/bin`\n+            if let Ok(files) = fs::read_dir(&host_bin_dir) {\n+                for file in files {\n+                    let file = t!(file);\n+                    if file.file_name() == \"rustfmt\" {\n+                        // This is when `rustc` and `cargo` are set in `config.toml`\n+                        if !file.path().starts_with(&builder.out) {\n+                            builder.copy(\n+                                &file.path().into_boxed_path(),\n+                                &sysroot_bin_dir.join(file.file_name()),\n+                            );\n+                        } else {\n+                            builder.copy(\n+                                &builder\n+                                    .out\n+                                    .join(&compiler.host.triple)\n+                                    .join(\"rustfmt/bin/rustfmt\"),\n+                                &sysroot_bin_dir.join(file.file_name()),\n+                            );\n+                        }\n+                    } else {\n+                        builder.copy(\n+                            &file.path().into_boxed_path(),\n+                            &sysroot_bin_dir.join(file.file_name()),\n+                        );\n+                    }\n+                }\n+            }\n+\n+            // copy dylib files from `builder.initial_rustc/../lib/*` while excluding the `rustlib` directory to `stage0-sysroot/lib`\n+            if let Ok(files) = fs::read_dir(&host_lib_dir) {\n+                for file in files {\n+                    let file = t!(file);\n+                    let path = file.path();\n+                    if path.is_file()\n+                        && is_dylib(&file.file_name().into_string().unwrap())\n+                        && !path.starts_with(sysroot_lib_dir.join(\"rustlib\").into_boxed_path())\n+                    {\n+                        builder.copy(&path, &sysroot_lib_dir.join(path.file_name().unwrap()));\n+                    }\n+                }\n+            }\n+\n+            t!(fs::create_dir_all(&sysroot_codegen_backends));\n+            // copy `codegen-backends` from `host_lib_dir/rustlib/codegen_backends` to `stage0-sysroot/lib/rustlib/host-triple/codegen-backends` if it exists.\n+            if host_codegen_backends.exists() {\n+                builder.cp_r(&host_codegen_backends, &sysroot_codegen_backends);\n+            }\n+        }\n     }\n }\n \n@@ -467,7 +533,12 @@ fn copy_sanitizers(\n         let dst = libdir.join(&runtime.name);\n         builder.copy(&runtime.path, &dst);\n \n-        if target == \"x86_64-apple-darwin\" || target == \"aarch64-apple-darwin\" {\n+        if target == \"x86_64-apple-darwin\"\n+            || target == \"aarch64-apple-darwin\"\n+            || target == \"aarch64-apple-ios\"\n+            || target == \"aarch64-apple-ios-sim\"\n+            || target == \"x86_64-apple-ios\"\n+        {\n             // Update the library\u2019s install name to reflect that it has been renamed.\n             apple_darwin_update_library_name(&dst, &format!(\"@rpath/{}\", &runtime.name));\n             // Upon renaming the install name, the code signature of the file will invalidate,"}, {"sha": "cd027a4abb7faec04f2628af9474c53e814e265e", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -97,6 +97,10 @@ pub struct Config {\n     pub cmd: Subcommand,\n     pub incremental: bool,\n     pub dry_run: DryRun,\n+    /// Arguments appearing after `--` to be forwarded to tools,\n+    /// e.g. `--fix-broken` or test arguments.\n+    pub free_args: Vec<String>,\n+\n     /// `None` if we shouldn't download CI compiler artifacts, or the commit to download if we should.\n     #[cfg(not(test))]\n     download_rustc_commit: Option<String>,\n@@ -866,6 +870,7 @@ impl Config {\n         config.keep_stage = flags.keep_stage;\n         config.keep_stage_std = flags.keep_stage_std;\n         config.color = flags.color;\n+        config.free_args = flags.free_args.clone().unwrap_or_default();\n         if let Some(value) = flags.deny_warnings {\n             config.deny_warnings = value;\n         }"}, {"sha": "04e798e3949d9a5a9316e0e55aa3bee743121e4c", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -379,8 +379,14 @@ def set(key, value):\n sections[None] = []\n section_order = [None]\n targets = {}\n+top_level_keys = []\n \n for line in open(rust_dir + '/config.toml.example').read().split(\"\\n\"):\n+    if cur_section == None:\n+        if line.count('=') == 1:\n+            top_level_key = line.split('=')[0]\n+            top_level_key = top_level_key.strip(' #')\n+            top_level_keys.append(top_level_key)\n     if line.startswith('['):\n         cur_section = line[1:-1]\n         if cur_section.startswith('target'):\n@@ -459,12 +465,22 @@ def configure_section(lines, config):\n                 raise RuntimeError(\"failed to find config line for {}\".format(key))\n \n \n-for section_key in config:\n-    section_config = config[section_key]\n-    if section_key not in sections:\n-        raise RuntimeError(\"config key {} not in sections\".format(section_key))\n+def configure_top_level_key(lines, top_level_key, value):\n+    for i, line in enumerate(lines):\n+        if line.startswith('#' + top_level_key + ' = ') or line.startswith(top_level_key + ' = '):\n+            lines[i] = \"{} = {}\".format(top_level_key, value)\n+            return\n \n-    if section_key == 'target':\n+    raise RuntimeError(\"failed to find config line for {}\".format(top_level_key))\n+\n+\n+for section_key, section_config in config.items():\n+    if section_key not in sections and section_key not in top_level_keys:\n+        raise RuntimeError(\"config key {} not in sections or top_level_keys\".format(section_key))\n+    if section_key in top_level_keys:\n+        configure_top_level_key(sections[None], section_key, section_config)\n+\n+    elif  section_key == 'target':\n         for target in section_config:\n             configure_section(targets[target], section_config[target])\n     else:"}, {"sha": "f07e710a9e6b76fe8bcd6563ecccb74bf60fe3dd", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -80,6 +80,10 @@ pub struct Flags {\n     pub llvm_profile_generate: bool,\n     pub llvm_bolt_profile_generate: bool,\n     pub llvm_bolt_profile_use: Option<String>,\n+\n+    /// Arguments appearing after `--` to be forwarded to tools,\n+    /// e.g. `--fix-broken` or test arguments.\n+    pub free_args: Option<Vec<String>>,\n }\n \n #[derive(Debug)]\n@@ -157,6 +161,12 @@ impl Default for Subcommand {\n \n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n+        let (args, free_args) = if let Some(pos) = args.iter().position(|s| s == \"--\") {\n+            let (args, free) = args.split_at(pos);\n+            (args, Some(free[1..].to_vec()))\n+        } else {\n+            (args, None)\n+        };\n         let mut subcommand_help = String::from(\n             \"\\\n Usage: x.py <subcommand> [options] [<paths>...]\n@@ -709,6 +719,7 @@ Arguments:\n             llvm_profile_generate: matches.opt_present(\"llvm-profile-generate\"),\n             llvm_bolt_profile_generate: matches.opt_present(\"llvm-bolt-profile-generate\"),\n             llvm_bolt_profile_use: matches.opt_str(\"llvm-bolt-profile-use\"),\n+            free_args,\n         }\n     }\n }"}, {"sha": "d6e63fb937ec37c80e9b02671ec2cba9bc01a691", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -483,7 +483,7 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n         }\n \n-        configure_cmake(builder, target, &mut cfg, true, ldflags);\n+        configure_cmake(builder, target, &mut cfg, true, ldflags, &[]);\n         configure_llvm(builder, target, &mut cfg);\n \n         for (key, val) in &builder.config.llvm_build_config {\n@@ -574,6 +574,7 @@ fn configure_cmake(\n     cfg: &mut cmake::Config,\n     use_compiler_launcher: bool,\n     mut ldflags: LdFlags,\n+    extra_compiler_flags: &[&str],\n ) {\n     // Do not print installation messages for up-to-date files.\n     // LLVM and LLD builds can produce a lot of those and hit CI limits on log size.\n@@ -714,6 +715,9 @@ fn configure_cmake(\n     if builder.config.llvm_clang_cl.is_some() {\n         cflags.push(&format!(\" --target={}\", target));\n     }\n+    for flag in extra_compiler_flags {\n+        cflags.push(&format!(\" {}\", flag));\n+    }\n     cfg.define(\"CMAKE_C_FLAGS\", cflags);\n     let mut cxxflags: OsString = builder.cflags(target, GitRepo::Llvm, CLang::Cxx).join(\" \").into();\n     if let Some(ref s) = builder.config.llvm_cxxflags {\n@@ -723,6 +727,9 @@ fn configure_cmake(\n     if builder.config.llvm_clang_cl.is_some() {\n         cxxflags.push(&format!(\" --target={}\", target));\n     }\n+    for flag in extra_compiler_flags {\n+        cxxflags.push(&format!(\" {}\", flag));\n+    }\n     cfg.define(\"CMAKE_CXX_FLAGS\", cxxflags);\n     if let Some(ar) = builder.ar(target) {\n         if ar.is_absolute() {\n@@ -864,7 +871,7 @@ impl Step for Lld {\n             }\n         }\n \n-        configure_cmake(builder, target, &mut cfg, true, ldflags);\n+        configure_cmake(builder, target, &mut cfg, true, ldflags, &[]);\n         configure_llvm(builder, target, &mut cfg);\n \n         // Re-use the same flags as llvm to control the level of debug information\n@@ -1028,7 +1035,16 @@ impl Step for Sanitizers {\n         // Unfortunately sccache currently lacks support to build them successfully.\n         // Disable compiler launcher on Darwin targets to avoid potential issues.\n         let use_compiler_launcher = !self.target.contains(\"apple-darwin\");\n-        configure_cmake(builder, self.target, &mut cfg, use_compiler_launcher, LdFlags::default());\n+        let extra_compiler_flags: &[&str] =\n+            if self.target.contains(\"apple\") { &[\"-fembed-bitcode=off\"] } else { &[] };\n+        configure_cmake(\n+            builder,\n+            self.target,\n+            &mut cfg,\n+            use_compiler_launcher,\n+            LdFlags::default(),\n+            extra_compiler_flags,\n+        );\n \n         t!(fs::create_dir_all(&out_dir));\n         cfg.out_dir(out_dir);\n@@ -1084,12 +1100,15 @@ fn supported_sanitizers(\n \n     match &*target.triple {\n         \"aarch64-apple-darwin\" => darwin_libs(\"osx\", &[\"asan\", \"lsan\", \"tsan\"]),\n+        \"aarch64-apple-ios\" => darwin_libs(\"ios\", &[\"asan\", \"tsan\"]),\n+        \"aarch64-apple-ios-sim\" => darwin_libs(\"iossim\", &[\"asan\", \"tsan\"]),\n         \"aarch64-unknown-fuchsia\" => common_libs(\"fuchsia\", \"aarch64\", &[\"asan\"]),\n         \"aarch64-unknown-linux-gnu\" => {\n             common_libs(\"linux\", \"aarch64\", &[\"asan\", \"lsan\", \"msan\", \"tsan\", \"hwasan\"])\n         }\n         \"x86_64-apple-darwin\" => darwin_libs(\"osx\", &[\"asan\", \"lsan\", \"tsan\"]),\n         \"x86_64-unknown-fuchsia\" => common_libs(\"fuchsia\", \"x86_64\", &[\"asan\"]),\n+        \"x86_64-apple-ios\" => darwin_libs(\"iossim\", &[\"asan\", \"tsan\"]),\n         \"x86_64-unknown-freebsd\" => common_libs(\"freebsd\", \"x86_64\", &[\"asan\", \"msan\", \"tsan\"]),\n         \"x86_64-unknown-netbsd\" => {\n             common_libs(\"netbsd\", \"x86_64\", &[\"asan\", \"lsan\", \"msan\", \"tsan\"])"}, {"sha": "e14440f57a8a6a3fa531d36f406e264529a7b8a7", "filename": "src/bootstrap/run.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frun.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -183,6 +183,7 @@ impl Step for Miri {\n         // Forward arguments.\n         miri.arg(\"--\").arg(\"--target\").arg(target.rustc_target_arg());\n         miri.args(builder.config.cmd.args());\n+        miri.args(&builder.config.free_args);\n \n         // miri tests need to know about the stage sysroot\n         miri.env(\"MIRI_SYSROOT\", &miri_sysroot);"}, {"sha": "9cd6107b43ac3a67aede2e05be0259e9943aed12", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1588,6 +1588,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             .collect();\n \n         test_args.append(&mut builder.config.cmd.test_args());\n+        test_args.extend(builder.config.free_args.iter().map(|s| s.as_str()));\n \n         // On Windows, replace forward slashes in test-args by backslashes\n         // so the correct filters are passed to libtest"}, {"sha": "262cef3454ad31fba475d5f55556d22caff7e01c", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -531,6 +531,24 @@ LLVM KCFI is supported on the following targets:\n See the [Clang KernelControlFlowIntegrity documentation][clang-kcfi] for more\n details.\n \n+# KernelAddressSanitizer\n+\n+KernelAddressSanitizer (KASAN) is a freestanding version of AddressSanitizer\n+which is suitable for detecting memory errors in programs which do not have a\n+runtime environment, such as operating system kernels. KernelAddressSanitizer\n+requires manual implementation of the underlying functions used for tracking\n+KernelAddressSanitizer state.\n+\n+KernelAddressSanitizer is supported on the following targets:\n+\n+* `aarch64-unknown-none`\n+* `riscv64gc-unknown-none-elf`\n+* `riscv64imac-unknown-none-elf`\n+* `x86_64-unknown-none`\n+\n+See the [Linux Kernel's KernelAddressSanitizer documentation][linux-kasan] for\n+more details.\n+\n # LeakSanitizer\n \n LeakSanitizer is run-time memory leak detector.\n@@ -714,6 +732,7 @@ Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PAT\n * [AddressSanitizer in Clang][clang-asan]\n * [ControlFlowIntegrity in Clang][clang-cfi]\n * [HWAddressSanitizer in Clang][clang-hwasan]\n+* [Linux Kernel's KernelAddressSanitizer documentation][linux-kasan]\n * [LeakSanitizer in Clang][clang-lsan]\n * [MemorySanitizer in Clang][clang-msan]\n * [MemTagSanitizer in LLVM][llvm-memtag]\n@@ -727,4 +746,5 @@ Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PAT\n [clang-msan]: https://clang.llvm.org/docs/MemorySanitizer.html\n [clang-scs]: https://clang.llvm.org/docs/ShadowCallStack.html\n [clang-tsan]: https://clang.llvm.org/docs/ThreadSanitizer.html\n+[linux-kasan]: https://www.kernel.org/doc/html/latest/dev-tools/kasan.html\n [llvm-memtag]: https://llvm.org/docs/MemTagSanitizer.html"}, {"sha": "9479b3ee0369ac816ca80e6339f8c00f79902d25", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -137,7 +137,7 @@ where\n     pub(crate) fn get_auto_trait_impls(&mut self, item_def_id: DefId) -> Vec<Item> {\n         let tcx = self.cx.tcx;\n         let param_env = tcx.param_env(item_def_id);\n-        let ty = tcx.type_of(item_def_id);\n+        let ty = tcx.type_of(item_def_id).subst_identity();\n         let f = auto_trait::AutoTraitFinder::new(tcx);\n \n         debug!(\"get_auto_trait_impls({:?})\", ty);"}, {"sha": "bcdbbcacc4bcdef5daeb6ea3be8a68e77cd09d9b", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -15,7 +15,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n     pub(crate) fn get_blanket_impls(&mut self, item_def_id: DefId) -> Vec<Item> {\n         let cx = &mut self.cx;\n         let param_env = cx.tcx.param_env(item_def_id);\n-        let ty = cx.tcx.bound_type_of(item_def_id);\n+        let ty = cx.tcx.type_of(item_def_id);\n \n         trace!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();"}, {"sha": "148243683cbbf1e9308e990527e6621a64e7b9a0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -303,7 +303,8 @@ fn build_union(cx: &mut DocContext<'_>, did: DefId) -> clean::Union {\n \n fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> Box<clean::Typedef> {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n-    let type_ = clean_middle_ty(ty::Binder::dummy(cx.tcx.type_of(did)), cx, Some(did));\n+    let type_ =\n+        clean_middle_ty(ty::Binder::dummy(cx.tcx.type_of(did).subst_identity()), cx, Some(did));\n \n     Box::new(clean::Typedef {\n         type_,\n@@ -414,7 +415,9 @@ pub(crate) fn build_impl(\n \n     let for_ = match &impl_item {\n         Some(impl_) => clean_ty(impl_.self_ty, cx),\n-        None => clean_middle_ty(ty::Binder::dummy(tcx.type_of(did)), cx, Some(did)),\n+        None => {\n+            clean_middle_ty(ty::Binder::dummy(tcx.type_of(did).subst_identity()), cx, Some(did))\n+        }\n     };\n \n     // Only inline impl if the implementing type is\n@@ -652,14 +655,22 @@ pub(crate) fn print_inlined_const(tcx: TyCtxt<'_>, did: DefId) -> String {\n \n fn build_const(cx: &mut DocContext<'_>, def_id: DefId) -> clean::Constant {\n     clean::Constant {\n-        type_: clean_middle_ty(ty::Binder::dummy(cx.tcx.type_of(def_id)), cx, Some(def_id)),\n+        type_: clean_middle_ty(\n+            ty::Binder::dummy(cx.tcx.type_of(def_id).subst_identity()),\n+            cx,\n+            Some(def_id),\n+        ),\n         kind: clean::ConstantKind::Extern { def_id },\n     }\n }\n \n fn build_static(cx: &mut DocContext<'_>, did: DefId, mutable: bool) -> clean::Static {\n     clean::Static {\n-        type_: clean_middle_ty(ty::Binder::dummy(cx.tcx.type_of(did)), cx, Some(did)),\n+        type_: clean_middle_ty(\n+            ty::Binder::dummy(cx.tcx.type_of(did).subst_identity()),\n+            cx,\n+            Some(did),\n+        ),\n         mutability: if mutable { Mutability::Mut } else { Mutability::Not },\n         expr: None,\n     }"}, {"sha": "0c70d31ed607e413c180f10e5009cd7a1fc89456", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 177, "deletions": 43, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -11,6 +11,8 @@ pub(crate) mod types;\n pub(crate) mod utils;\n \n use rustc_ast as ast;\n+use rustc_ast::token::{Token, TokenKind};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet, IndexEntry};\n use rustc_hir as hir;\n@@ -19,7 +21,7 @@ use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::PredicateOrigin;\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n-use rustc_middle::middle::resolve_lifetime as rl;\n+use rustc_middle::middle::resolve_bound_vars as rbv;\n use rustc_middle::ty::fold::ir::TypeFolder;\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::TypeVisitable;\n@@ -198,11 +200,11 @@ fn clean_poly_trait_ref_with_bindings<'tcx>(\n }\n \n fn clean_lifetime<'tcx>(lifetime: &hir::Lifetime, cx: &mut DocContext<'tcx>) -> Lifetime {\n-    let def = cx.tcx.named_region(lifetime.hir_id);\n+    let def = cx.tcx.named_bound_var(lifetime.hir_id);\n     if let Some(\n-        rl::Region::EarlyBound(node_id)\n-        | rl::Region::LateBound(_, _, node_id)\n-        | rl::Region::Free(_, node_id),\n+        rbv::ResolvedArg::EarlyBound(node_id)\n+        | rbv::ResolvedArg::LateBound(_, _, node_id)\n+        | rbv::ResolvedArg::Free(_, node_id),\n     ) = def\n     {\n         if let Some(lt) = cx.substs.get(&node_id).and_then(|p| p.as_lt()).cloned() {\n@@ -215,7 +217,11 @@ fn clean_lifetime<'tcx>(lifetime: &hir::Lifetime, cx: &mut DocContext<'tcx>) ->\n pub(crate) fn clean_const<'tcx>(constant: &hir::ConstArg, cx: &mut DocContext<'tcx>) -> Constant {\n     let def_id = cx.tcx.hir().body_owner_def_id(constant.value.body).to_def_id();\n     Constant {\n-        type_: clean_middle_ty(ty::Binder::dummy(cx.tcx.type_of(def_id)), cx, Some(def_id)),\n+        type_: clean_middle_ty(\n+            ty::Binder::dummy(cx.tcx.type_of(def_id).subst_identity()),\n+            cx,\n+            Some(def_id),\n+        ),\n         kind: ConstantKind::Anonymous { body: constant.value.body },\n     }\n }\n@@ -314,6 +320,7 @@ pub(crate) fn clean_predicate<'tcx>(\n         // FIXME(generic_const_exprs): should this do something?\n         ty::PredicateKind::ConstEvaluatable(..) => None,\n         ty::PredicateKind::WellFormed(..) => None,\n+        ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => None,\n \n         ty::PredicateKind::Subtype(..)\n         | ty::PredicateKind::AliasEq(..)\n@@ -480,7 +487,7 @@ fn clean_generic_param_def<'tcx>(\n         ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n             let default = if has_default {\n                 Some(clean_middle_ty(\n-                    ty::Binder::dummy(cx.tcx.type_of(def.def_id)),\n+                    ty::Binder::dummy(cx.tcx.type_of(def.def_id).subst_identity()),\n                     cx,\n                     Some(def.def_id),\n                 ))\n@@ -502,7 +509,12 @@ fn clean_generic_param_def<'tcx>(\n             GenericParamDefKind::Const {\n                 did: def.def_id,\n                 ty: Box::new(clean_middle_ty(\n-                    ty::Binder::dummy(cx.tcx.type_of(def.def_id)),\n+                    ty::Binder::dummy(\n+                        cx.tcx\n+                            .type_of(def.def_id)\n+                            .no_bound_vars()\n+                            .expect(\"const parameter types cannot be generic\"),\n+                    ),\n                     cx,\n                     Some(def.def_id),\n                 )),\n@@ -1212,7 +1224,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n     let kind = match assoc_item.kind {\n         ty::AssocKind::Const => {\n             let ty = clean_middle_ty(\n-                ty::Binder::dummy(tcx.type_of(assoc_item.def_id)),\n+                ty::Binder::dummy(tcx.type_of(assoc_item.def_id).subst_identity()),\n                 cx,\n                 Some(assoc_item.def_id),\n             );\n@@ -1251,7 +1263,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n \n             if assoc_item.fn_has_self_parameter {\n                 let self_ty = match assoc_item.container {\n-                    ty::ImplContainer => tcx.type_of(assoc_item.container_id(tcx)),\n+                    ty::ImplContainer => tcx.type_of(assoc_item.container_id(tcx)).subst_identity(),\n                     ty::TraitContainer => tcx.types.self_param,\n                 };\n                 let self_arg_ty = sig.input(0).skip_binder();\n@@ -1398,7 +1410,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                     AssocTypeItem(\n                         Box::new(Typedef {\n                             type_: clean_middle_ty(\n-                                ty::Binder::dummy(tcx.type_of(assoc_item.def_id)),\n+                                ty::Binder::dummy(tcx.type_of(assoc_item.def_id).subst_identity()),\n                                 cx,\n                                 Some(assoc_item.def_id),\n                             ),\n@@ -1416,7 +1428,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                 AssocTypeItem(\n                     Box::new(Typedef {\n                         type_: clean_middle_ty(\n-                            ty::Binder::dummy(tcx.type_of(assoc_item.def_id)),\n+                            ty::Binder::dummy(tcx.type_of(assoc_item.def_id).subst_identity()),\n                             cx,\n                             Some(assoc_item.def_id),\n                         ),\n@@ -1926,7 +1938,11 @@ pub(crate) fn clean_middle_field<'tcx>(field: &ty::FieldDef, cx: &mut DocContext\n     clean_field_with_def_id(\n         field.did,\n         field.name,\n-        clean_middle_ty(ty::Binder::dummy(cx.tcx.type_of(field.did)), cx, Some(field.did)),\n+        clean_middle_ty(\n+            ty::Binder::dummy(cx.tcx.type_of(field.did).subst_identity()),\n+            cx,\n+            Some(field.did),\n+        ),\n         cx,\n     )\n }\n@@ -2079,8 +2095,8 @@ impl<'hir> hir::intravisit::Visitor<'hir> for OneLevelVisitor<'hir> {\n     fn visit_item(&mut self, item: &'hir hir::Item<'hir>) {\n         if self.item.is_none()\n             && item.ident == self.looking_for\n-            && matches!(item.kind, hir::ItemKind::Use(_, _))\n-            || item.owner_id.def_id == self.target_def_id\n+            && (matches!(item.kind, hir::ItemKind::Use(_, _))\n+                || item.owner_id.def_id == self.target_def_id)\n         {\n             self.item = Some(item);\n         }\n@@ -2096,34 +2112,149 @@ fn get_all_import_attributes<'hir>(\n     tcx: TyCtxt<'hir>,\n     target_def_id: LocalDefId,\n     attributes: &mut Vec<ast::Attribute>,\n+    is_inline: bool,\n ) {\n     let hir_map = tcx.hir();\n     let mut visitor = OneLevelVisitor::new(hir_map, target_def_id);\n     let mut visited = FxHashSet::default();\n     // If the item is an import and has at least a path with two parts, we go into it.\n-    while let hir::ItemKind::Use(path, _) = item.kind &&\n-        path.segments.len() > 1 &&\n-        let hir::def::Res::Def(_, def_id) = path.segments[path.segments.len() - 2].res &&\n-        visited.insert(def_id)\n-    {\n-        if let Some(hir::Node::Item(parent_item)) = hir_map.get_if_local(def_id) {\n-            // We add the attributes from this import into the list.\n-            attributes.extend_from_slice(hir_map.attrs(item.hir_id()));\n-            // We get the `Ident` we will be looking for into `item`.\n-            let looking_for = path.segments[path.segments.len() - 1].ident;\n-            visitor.reset(looking_for);\n-            hir::intravisit::walk_item(&mut visitor, parent_item);\n-            if let Some(i) = visitor.item {\n-                item = i;\n-            } else {\n-                break;\n+    while let hir::ItemKind::Use(path, _) = item.kind && visited.insert(item.hir_id()) {\n+        // We add the attributes from this import into the list.\n+        add_without_unwanted_attributes(attributes, hir_map.attrs(item.hir_id()), is_inline);\n+\n+        let def_id = if path.segments.len() > 1 {\n+            match path.segments[path.segments.len() - 2].res {\n+                hir::def::Res::Def(_, def_id) => def_id,\n+                _ => break,\n+            }\n+        } else {\n+            // If the path doesn't have a parent, then the parent is the current module.\n+            tcx.parent(item.owner_id.def_id.to_def_id())\n+        };\n+\n+        let Some(parent) = hir_map.get_if_local(def_id) else { break };\n+\n+        // We get the `Ident` we will be looking for into `item`.\n+        let looking_for = path.segments[path.segments.len() - 1].ident;\n+        visitor.reset(looking_for);\n+\n+        match parent {\n+            hir::Node::Item(parent_item) => {\n+                hir::intravisit::walk_item(&mut visitor, parent_item);\n+            }\n+            hir::Node::Crate(m) => {\n+                hir::intravisit::walk_mod(\n+                    &mut visitor,\n+                    m,\n+                    tcx.local_def_id_to_hir_id(def_id.as_local().unwrap()),\n+                );\n             }\n+            _ => break,\n+        }\n+        if let Some(i) = visitor.item {\n+            item = i;\n         } else {\n             break;\n         }\n     }\n }\n \n+fn filter_tokens_from_list(\n+    args_tokens: TokenStream,\n+    should_retain: impl Fn(&TokenTree) -> bool,\n+) -> Vec<TokenTree> {\n+    let mut tokens = Vec::with_capacity(args_tokens.len());\n+    let mut skip_next_comma = false;\n+    for token in args_tokens.into_trees() {\n+        match token {\n+            TokenTree::Token(Token { kind: TokenKind::Comma, .. }, _) if skip_next_comma => {\n+                skip_next_comma = false;\n+            }\n+            token if should_retain(&token) => {\n+                skip_next_comma = false;\n+                tokens.push(token);\n+            }\n+            _ => {\n+                skip_next_comma = true;\n+            }\n+        }\n+    }\n+    tokens\n+}\n+\n+/// When inlining items, we merge its attributes (and all the reexports attributes too) with the\n+/// final reexport. For example:\n+///\n+/// ```ignore (just an example)\n+/// #[doc(hidden, cfg(feature = \"foo\"))]\n+/// pub struct Foo;\n+///\n+/// #[doc(cfg(feature = \"bar\"))]\n+/// #[doc(hidden, no_inline)]\n+/// pub use Foo as Foo1;\n+///\n+/// #[doc(inline)]\n+/// pub use Foo2 as Bar;\n+/// ```\n+///\n+/// So `Bar` at the end will have both `cfg(feature = \"...\")`. However, we don't want to merge all\n+/// attributes so we filter out the following ones:\n+/// * `doc(inline)`\n+/// * `doc(no_inline)`\n+/// * `doc(hidden)`\n+fn add_without_unwanted_attributes(\n+    attrs: &mut Vec<ast::Attribute>,\n+    new_attrs: &[ast::Attribute],\n+    is_inline: bool,\n+) {\n+    // If it's `#[doc(inline)]`, we don't want all attributes, otherwise we keep everything.\n+    if !is_inline {\n+        attrs.extend_from_slice(new_attrs);\n+        return;\n+    }\n+    for attr in new_attrs {\n+        let mut attr = attr.clone();\n+        match attr.kind {\n+            ast::AttrKind::Normal(ref mut normal) => {\n+                if let [ident] = &*normal.item.path.segments &&\n+                    let ident = ident.ident.name &&\n+                    ident == sym::doc\n+                {\n+                    match normal.item.args {\n+                        ast::AttrArgs::Delimited(ref mut args) => {\n+                            let tokens =\n+                                filter_tokens_from_list(args.tokens.clone(), |token| {\n+                                    !matches!(\n+                                        token,\n+                                        TokenTree::Token(\n+                                            Token {\n+                                                kind: TokenKind::Ident(\n+                                                    sym::hidden | sym::inline | sym::no_inline,\n+                                                    _,\n+                                                ),\n+                                                ..\n+                                            },\n+                                            _,\n+                                        ),\n+                                    )\n+                                });\n+                            args.tokens = TokenStream::new(tokens);\n+                            attrs.push(attr);\n+                        }\n+                        ast::AttrArgs::Empty | ast::AttrArgs::Eq(..) => {\n+                            attrs.push(attr);\n+                            continue;\n+                        }\n+                    }\n+                }\n+            }\n+            ast::AttrKind::DocComment(..) => {\n+                attrs.push(attr);\n+            }\n+        }\n+    }\n+}\n+\n fn clean_maybe_renamed_item<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     item: &hir::Item<'tcx>,\n@@ -2212,19 +2343,20 @@ fn clean_maybe_renamed_item<'tcx>(\n         {\n             // First, we add the attributes from the current import.\n             extra_attrs.extend_from_slice(inline::load_attrs(cx, import_id.to_def_id()));\n+            let is_inline = extra_attrs.lists(sym::doc).get_word_attr(sym::inline).is_some();\n             // Then we get all the various imports' attributes.\n-            get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut extra_attrs);\n+            get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut extra_attrs, is_inline);\n+            add_without_unwanted_attributes(&mut extra_attrs, inline::load_attrs(cx, def_id), is_inline);\n+        } else {\n+            // We only keep the item's attributes.\n+            extra_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n         }\n \n-        let mut item = if !extra_attrs.is_empty() {\n-            extra_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n-            let attrs = Attributes::from_ast(&extra_attrs);\n-            let cfg = extra_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n+        let attrs = Attributes::from_ast(&extra_attrs);\n+        let cfg = extra_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n \n-            Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg)\n-        } else {\n-            Item::from_def_id_and_parts(def_id, Some(name), kind, cx)\n-        };\n+        let mut item =\n+            Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);\n         item.inline_stmt_id = import_id.map(|def_id| def_id.to_def_id());\n         vec![item]\n     })\n@@ -2257,9 +2389,11 @@ fn clean_impl<'tcx>(\n \n     let for_ = clean_ty(impl_.self_ty, cx);\n     let type_alias = for_.def_id(&cx.cache).and_then(|did| match tcx.def_kind(did) {\n-        DefKind::TyAlias => {\n-            Some(clean_middle_ty(ty::Binder::dummy(tcx.type_of(did)), cx, Some(did)))\n-        }\n+        DefKind::TyAlias => Some(clean_middle_ty(\n+            ty::Binder::dummy(tcx.type_of(did).subst_identity()),\n+            cx,\n+            Some(did),\n+        )),\n         _ => None,\n     });\n     let mut make_item = |trait_: Option<Path>, for_: Type, items: Vec<Item>| {"}, {"sha": "5a564c2ac1c417778d3c22b9a353394c49c7416e", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -129,7 +129,7 @@ fn external_generic_args<'tcx>(\n         });\n         GenericArgs::Parenthesized { inputs, output }\n     } else {\n-        GenericArgs::AngleBracketed { args: args.into(), bindings: bindings.into() }\n+        GenericArgs::AngleBracketed { args: args.into(), bindings }\n     }\n }\n \n@@ -266,7 +266,7 @@ pub(crate) fn print_evaluated_const(\n     underscores_and_type: bool,\n ) -> Option<String> {\n     tcx.const_eval_poly(def_id).ok().and_then(|val| {\n-        let ty = tcx.type_of(def_id);\n+        let ty = tcx.type_of(def_id).subst_identity();\n         match (val, ty.kind()) {\n             (_, &ty::Ref(..)) => None,\n             (ConstValue::Scalar(_), &ty::Adt(_, _)) => None,"}, {"sha": "68bdd2bc531f2a4baa2884c277aaa50fecc5bad2", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -453,7 +453,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                 | clean::BorrowedRef { type_: box clean::Type::Path { ref path }, .. } => {\n                     dids.insert(path.def_id());\n                     if let Some(generics) = path.generics() &&\n-                        let ty::Adt(adt, _) = self.tcx.type_of(path.def_id()).kind() &&\n+                        let ty::Adt(adt, _) = self.tcx.type_of(path.def_id()).subst_identity().kind() &&\n                         adt.is_fundamental() {\n                         for ty in generics {\n                             if let Some(did) = ty.def_id(self.cache) {"}, {"sha": "aa406f30cbe63d16c11fd5596b6cedeb2c7d128f", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -361,7 +361,7 @@ pub(crate) fn print_where_clause<'a, 'tcx: 'a>(\n             for _ in 0..padding_amout {\n                 br_with_padding.push_str(\" \");\n             }\n-            let where_preds = where_preds.to_string().replace(\"\\n\", &br_with_padding);\n+            let where_preds = where_preds.to_string().replace('\\n', &br_with_padding);\n \n             if ending == Ending::Newline {\n                 let mut clause = \" \".repeat(indent.saturating_sub(1));\n@@ -1419,12 +1419,12 @@ impl clean::FnDecl {\n             format!(\n                 \"({pad}{args}{close}){arrow}\",\n                 pad = if self.inputs.values.is_empty() { \"\" } else { &full_pad },\n-                args = args.replace(\"\\n\", &full_pad),\n+                args = args.replace('\\n', &full_pad),\n                 close = close_pad,\n                 arrow = arrow\n             )\n         } else {\n-            format!(\"({args}){arrow}\", args = args.replace(\"\\n\", \" \"), arrow = arrow)\n+            format!(\"({args}){arrow}\", args = args.replace('\\n', \" \"), arrow = arrow)\n         };\n \n         write!(f, \"{}\", output)"}, {"sha": "387984a2b3bc836e59c891671b5e2f94694e674b", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1855,7 +1855,7 @@ fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n \n     let tcx = cx.tcx();\n     let param_env = tcx.param_env(ty_def_id);\n-    let ty = tcx.type_of(ty_def_id);\n+    let ty = tcx.type_of(ty_def_id).subst_identity();\n     match tcx.layout_of(param_env.and(ty)) {\n         Ok(ty_layout) => {\n             writeln!("}, {"sha": "d2c6e7ab024998169528a3cf19dbc624bb1cbaa7", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let ty_res = self.resolve_path(&path, TypeNS, item_id, module_id).ok_or_else(no_res)?;\n \n         match ty_res {\n-            Res::Def(DefKind::Enum, did) => match tcx.type_of(did).kind() {\n+            Res::Def(DefKind::Enum, did) => match tcx.type_of(did).subst_identity().kind() {\n                 ty::Adt(def, _) if def.is_enum() => {\n                     if let Some(variant) = def.variants().iter().find(|v| v.name == variant_name)\n                         && let Some(field) = variant.fields.iter().find(|f| f.name == variant_field_name) {\n@@ -471,7 +471,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     /// This is used for resolving type aliases.\n     fn def_id_to_res(&self, ty_id: DefId) -> Option<Res> {\n         use PrimitiveType::*;\n-        Some(match *self.cx.tcx.type_of(ty_id).kind() {\n+        Some(match *self.cx.tcx.type_of(ty_id).subst_identity().kind() {\n             ty::Bool => Res::Primitive(Bool),\n             ty::Char => Res::Primitive(Char),\n             ty::Int(ity) => Res::Primitive(ity.into()),\n@@ -572,7 +572,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n                 // Checks if item_name is a variant of the `SomeItem` enum\n                 if ns == TypeNS && def_kind == DefKind::Enum {\n-                    match tcx.type_of(did).kind() {\n+                    match tcx.type_of(did).subst_identity().kind() {\n                         ty::Adt(adt_def, _) => {\n                             for variant in adt_def.variants() {\n                                 if variant.name == item_name {\n@@ -606,7 +606,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n                     .or_else(|| {\n                         resolve_associated_trait_item(\n-                            tcx.type_of(did),\n+                            tcx.type_of(did).subst_identity(),\n                             module_id,\n                             item_name,\n                             ns,\n@@ -639,7 +639,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 // they also look like associated items (`module::Type::Variant`),\n                 // because they are real Rust syntax (unlike the intra-doc links\n                 // field syntax) and are handled by the compiler's resolver.\n-                let def = match tcx.type_of(did).kind() {\n+                let def = match tcx.type_of(did).subst_identity().kind() {\n                     ty::Adt(def, _) if !def.is_enum() => def,\n                     _ => return None,\n                 };\n@@ -689,12 +689,12 @@ fn resolve_associated_trait_item<'a>(\n             .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n             .map(|trait_assoc| {\n                 trait_assoc_to_impl_assoc_item(cx.tcx, impl_, trait_assoc.def_id)\n-                    .unwrap_or(trait_assoc)\n+                    .unwrap_or(*trait_assoc)\n             })\n     });\n     // FIXME(#74563): warn about ambiguity\n     debug!(\"the candidates were {:?}\", candidates.clone().collect::<Vec<_>>());\n-    candidates.next().copied()\n+    candidates.next()\n }\n \n /// Find the associated item in the impl `impl_id` that corresponds to the\n@@ -711,7 +711,7 @@ fn trait_assoc_to_impl_assoc_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_id: DefId,\n     trait_assoc_id: DefId,\n-) -> Option<&'tcx ty::AssocItem> {\n+) -> Option<ty::AssocItem> {\n     let trait_to_impl_assoc_map = tcx.impl_item_implementor_ids(impl_id);\n     debug!(?trait_to_impl_assoc_map);\n     let impl_assoc_id = *trait_to_impl_assoc_map.get(&trait_assoc_id)?;\n@@ -1710,7 +1710,7 @@ fn resolution_failure(\n                         Res::Primitive(_) => None,\n                     };\n                     let is_struct_variant = |did| {\n-                        if let ty::Adt(def, _) = tcx.type_of(did).kind()\n+                        if let ty::Adt(def, _) = tcx.type_of(did).subst_identity().kind()\n                         && def.is_enum()\n                         && let Some(variant) = def.variants().iter().find(|v| v.name == res.name(tcx)) {\n                             // ctor is `None` if variant is a struct"}, {"sha": "01ed4a60b3b89f4e742db38cb7b0533ea98d78d6", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -109,7 +109,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n                     // `Generics`. To avoid relying on the `impl` block, these\n                     // things would need to be created from wholecloth, in a\n                     // form that is valid for use in type inference.\n-                    let ty = tcx.type_of(def_id);\n+                    let ty = tcx.type_of(def_id).subst_identity();\n                     match ty.kind() {\n                         ty::Slice(ty)\n                         | ty::Ref(_, ty, _)"}, {"sha": "f28c164d61dad059e1407093790c14bfce53bfd9", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -169,7 +169,7 @@ where\n                 };\n \n                 let ident_span = path.ident.span;\n-                (tcx.type_of(def_id), call_span, ident_span)\n+                (tcx.type_of(def_id).subst_identity(), call_span, ident_span)\n             }\n             _ => {\n                 return;"}, {"sha": "17b3d0de0897e1c6b8ca347bd39f850bb0a5b9f6", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -1 +1 @@\n-Subproject commit 39c13e67a5962466cc7253d41bc1099bbcb224c3\n+Subproject commit 17b3d0de0897e1c6b8ca347bd39f850bb0a5b9f6"}, {"sha": "6c8ee296c75101fa56389d038a983c7cf2980f6b", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -66,7 +66,7 @@ fn is_used_as_unaligned(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n             if matches!(name.ident.as_str(), \"read_unaligned\" | \"write_unaligned\")\n                 && let Some(def_id) = cx.typeck_results().type_dependent_def_id(parent.hir_id)\n                 && let Some(def_id) = cx.tcx.impl_of_method(def_id)\n-                && cx.tcx.type_of(def_id).is_unsafe_ptr()\n+                && cx.tcx.type_of(def_id).subst_identity().is_unsafe_ptr()\n             {\n                 true\n             } else {"}, {"sha": "0fc11523298f177e6ac3166d6409b09485adc6c3", "filename": "src/tools/clippy/clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for CopyIterator {\n                 of_trait: Some(ref trait_ref),\n                 ..\n             }) = item.kind;\n-            let ty = cx.tcx.type_of(item.owner_id);\n+            let ty = cx.tcx.type_of(item.owner_id).subst_identity();\n             if is_copy(cx, ty);\n             if let Some(trait_id) = trait_ref.trait_def_id();\n             if cx.tcx.is_diagnostic_item(sym::Iterator, trait_id);"}, {"sha": "080d44e6398c1f754202e7e4f5e82582c5f31826", "filename": "src/tools/clippy/clippy_lints/src/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -150,7 +150,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n                     .fields\n                     .iter()\n                     .all(|field| {\n-                        is_copy(cx, cx.tcx.type_of(field.did))\n+                        is_copy(cx, cx.tcx.type_of(field.did).subst_identity())\n                     });\n                 if !has_drop(cx, binding_type) || all_fields_are_copy;\n                 then {"}, {"sha": "4e1a6cd4d7355b47358fa974e27bc23a483a02de", "filename": "src/tools/clippy/clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                                     .iter()\n                                     .find_map(|f_def| {\n                                         if f_def.ident(self.cx.tcx) == field.ident\n-                                            { Some(self.cx.tcx.type_of(f_def.did)) }\n+                                            { Some(self.cx.tcx.type_of(f_def.did).subst_identity()) }\n                                         else { None }\n                                     });\n                             self.ty_bounds.push(bound.into());"}, {"sha": "b4543aa2544f8dfa8bba70f70ec92b360927d8dd", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -735,7 +735,7 @@ fn walk_parents<'tcx>(\n                 span,\n                 ..\n             }) if span.ctxt() == ctxt => {\n-                let ty = cx.tcx.type_of(owner_id.def_id);\n+                let ty = cx.tcx.type_of(owner_id.def_id).subst_identity();\n                 Some(ty_auto_deref_stability(cx, ty, precedence).position_for_result(cx))\n             },\n \n@@ -771,7 +771,7 @@ fn walk_parents<'tcx>(\n                 }) => variant_of_res(cx, cx.qpath_res(path, *hir_id))\n                     .and_then(|variant| variant.fields.iter().find(|f| f.name == field.ident.name))\n                     .map(|field_def| {\n-                        ty_auto_deref_stability(cx, cx.tcx.type_of(field_def.did), precedence).position_for_arg()\n+                        ty_auto_deref_stability(cx, cx.tcx.type_of(field_def.did).subst_identity(), precedence).position_for_arg()\n                     }),\n                 _ => None,\n             },"}, {"sha": "f95b8ccf067b46f62d45cc41b37b352fbe00ff8e", "filename": "src/tools/clippy/clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c7f09b77da1f8b78b8a035682ee971439b84fa6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs?ref=6c7f09b77da1f8b78b8a035682ee971439b84fa6", "patch": "@@ -184,7 +184,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n             if let Some(Node::ImplItem(impl_item)) = cx.tcx.hir().find(impl_item_hir);\n             if let ImplItemKind::Fn(_, b) = &impl_item.kind;\n             if let Body { value: func_expr, .. } = cx.tcx.hir().body(*b);\n-            if let Some(adt_def) = cx.tcx.type_of(item.owner_id).ty_adt_def();\n+            if let Some(adt_def) = cx.tcx.type_of(item.owner_id).subst_identity().ty_adt_def();\n             if let attrs = cx.tcx.hir().attrs(item.hir_id());\n             if !attrs.iter().any(|attr| attr.doc_str().is_some());\n             if let child_attrs = cx.tcx.hir().attrs(impl_item_hir);"}]}