{"sha": "d84658e317ac5b881a46e27204a1cb9f4ac1b691", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NDY1OGUzMTdhYzViODgxYTQ2ZTI3MjA0YTFjYjlmNGFjMWI2OTE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-02-12T23:01:08Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-02-20T11:17:30Z"}, "message": "address review comments", "tree": {"sha": "41ae067131a3a89ad1e3f0be1a16b553ed4efa08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41ae067131a3a89ad1e3f0be1a16b553ed4efa08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d84658e317ac5b881a46e27204a1cb9f4ac1b691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d84658e317ac5b881a46e27204a1cb9f4ac1b691", "html_url": "https://github.com/rust-lang/rust/commit/d84658e317ac5b881a46e27204a1cb9f4ac1b691", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d84658e317ac5b881a46e27204a1cb9f4ac1b691/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "881249aa463db43e41e4d5f98d6f71f2970f8965", "url": "https://api.github.com/repos/rust-lang/rust/commits/881249aa463db43e41e4d5f98d6f71f2970f8965", "html_url": "https://github.com/rust-lang/rust/commit/881249aa463db43e41e4d5f98d6f71f2970f8965"}], "stats": {"total": 66, "additions": 50, "deletions": 16}, "files": [{"sha": "32e78b04676395428c936061eb45f5b5e6c17b1d", "filename": "src/librustc/mir/mir_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84658e317ac5b881a46e27204a1cb9f4ac1b691/src%2Flibrustc%2Fmir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84658e317ac5b881a46e27204a1cb9f4ac1b691/src%2Flibrustc%2Fmir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmir_map.rs?ref=d84658e317ac5b881a46e27204a1cb9f4ac1b691", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use dep_graph::DepNode;\n use util::nodemap::NodeMap;\n use mir::repr::Mir;\n use mir::transform::MirPass;\n@@ -23,6 +24,9 @@ impl<'tcx> MirMap<'tcx> {\n         if passes.is_empty() { return; }\n \n         for (&id, mir) in &mut self.map {\n+            let did = tcx.map.local_def_id(id);\n+            let _task = tcx.dep_graph.in_task(DepNode::MirMapConstruction(did));\n+\n             let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n             let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n "}, {"sha": "2338d7df01a854096460e830136be12b907d1249", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84658e317ac5b881a46e27204a1cb9f4ac1b691/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84658e317ac5b881a46e27204a1cb9f4ac1b691/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=d84658e317ac5b881a46e27204a1cb9f4ac1b691", "patch": "@@ -153,6 +153,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n                 let fields = if let Some(FruInfo { base, field_types }) = base {\n                     let base = unpack!(block = this.as_lvalue(block, base));\n+\n+                    // MIR does not natively support FRU, so for each\n+                    // base-supplied field, generate an operand that\n+                    // reads it from the base.\n                     field_names.into_iter()\n                         .zip(field_types.into_iter())\n                         .map(|(n, ty)| match fields_map.get(&n) {"}, {"sha": "b35d8c08f5dc1e5da95d6a8b16bc337164e40942", "filename": "src/librustc_mir/transform/clear_dead_blocks.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d84658e317ac5b881a46e27204a1cb9f4ac1b691/src%2Flibrustc_mir%2Ftransform%2Fclear_dead_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84658e317ac5b881a46e27204a1cb9f4ac1b691/src%2Flibrustc_mir%2Ftransform%2Fclear_dead_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fclear_dead_blocks.rs?ref=d84658e317ac5b881a46e27204a1cb9f4ac1b691", "patch": "@@ -8,12 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A pass that erases the contents of dead blocks. This is required\n-//! because rustc allows for ill-typed block terminators in dead\n-//! blocks.\n+//! A pass that erases the contents of dead blocks. This pass must\n+//! run before any analysis passes because some of the dead blocks\n+//! can be ill-typed.\n //!\n-//! This pass does not renumber or remove the blocks, to have the\n-//! MIR better match the source.\n+//! The main problem is that typeck lets most blocks whose end is not\n+//! reachable have an arbitrary return type, rather than having the\n+//! usual () return type (as a note, typeck's notion of reachability\n+//! is in fact slightly weaker than MIR CFG reachability - see #31617).\n+//!\n+//! A standard example of the situation is:\n+//! ```rust\n+//!   fn example() {\n+//!       let _a: char = { return; };\n+//!   }\n+//! ```\n+//!\n+//! Here the block (`{ return; }`) has the return type `char`,\n+//! rather than `()`, but the MIR we naively generate still contains\n+//! the `_a = ()` write in the unreachable block \"after\" the return.\n+//!\n+//! As we have to run this pass even when we want to debug the MIR,\n+//! this pass just replaces the blocks with empty \"return\" blocks\n+//! and does not renumber anything.\n \n use rustc::middle::infer;\n use rustc::mir::repr::*;\n@@ -43,8 +60,9 @@ impl ClearDeadBlocks {\n             }\n         }\n \n-        for (block, seen) in mir.basic_blocks.iter_mut().zip(seen) {\n+        for (n, (block, seen)) in mir.basic_blocks.iter_mut().zip(seen).enumerate() {\n             if !seen {\n+                info!(\"clearing block #{}: {:?}\", n, block);\n                 *block = BasicBlockData {\n                     statements: vec![],\n                     terminator: Some(Terminator::Return),"}, {"sha": "0e97e3629064be16abd9b6fe7a1b1fb98323554c", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d84658e317ac5b881a46e27204a1cb9f4ac1b691/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84658e317ac5b881a46e27204a1cb9f4ac1b691/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=d84658e317ac5b881a46e27204a1cb9f4ac1b691", "patch": "@@ -48,8 +48,11 @@ enum FieldAccessError {\n     OutOfRange { field_count: usize }\n }\n \n-/// Verifies that MIR types are sane to not crash further\n-/// checks.\n+/// Verifies that MIR types are sane to not crash further checks.\n+///\n+/// The sanitize_XYZ methods here take an MIR object and compute its\n+/// type, calling `span_mirbug` and returning an error type if there\n+/// is a problem.\n struct TypeVerifier<'a, 'b: 'a, 'tcx: 'b> {\n     cx: &'a mut TypeChecker<'b, 'tcx>,\n     mir: &'a Mir<'tcx>,\n@@ -119,11 +122,11 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     }\n \n     fn sanitize_type(&mut self, parent: &fmt::Debug, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if !(ty.needs_infer() || ty.has_escaping_regions() ||\n-             ty.references_error()) {\n-            return ty;\n+        if ty.needs_infer() || ty.has_escaping_regions() || ty.references_error() {\n+            span_mirbug_and_err!(self, parent, \"bad type {:?}\", ty)\n+        } else {\n+            ty\n         }\n-        span_mirbug_and_err!(self, parent, \"bad type {:?}\", ty)\n     }\n \n     fn sanitize_lvalue(&mut self, lvalue: &Lvalue<'tcx>) -> LvalueTy<'tcx> {\n@@ -225,7 +228,8 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     }\n                     _ => LvalueTy::Ty {\n                         ty: span_mirbug_and_err!(\n-                            self, lvalue, \"can't downcast {:?}\", base_ty)\n+                            self, lvalue, \"can't downcast {:?} as {:?}\",\n+                            base_ty, adt_def1)\n                     }\n                 },\n             ProjectionElem::Field(field, fty) => {\n@@ -467,8 +471,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                          args: &[Operand<'tcx>])\n     {\n         debug!(\"check_call_inputs({:?}, {:?})\", sig, args);\n-        if sig.inputs.len() > args.len() ||\n-           (sig.inputs.len() < args.len() && !sig.variadic) {\n+        if args.len() < sig.inputs.len() ||\n+           (args.len() > sig.inputs.len() && !sig.variadic) {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs.iter().zip(args).enumerate() {"}, {"sha": "c85ac458edd88ca0d79748d83446d422d62d8b29", "filename": "src/test/run-pass/mir_augmented_assignments.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d84658e317ac5b881a46e27204a1cb9f4ac1b691/src%2Ftest%2Frun-pass%2Fmir_augmented_assignments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84658e317ac5b881a46e27204a1cb9f4ac1b691/src%2Ftest%2Frun-pass%2Fmir_augmented_assignments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_augmented_assignments.rs?ref=d84658e317ac5b881a46e27204a1cb9f4ac1b691", "patch": "@@ -77,7 +77,10 @@ fn main_mir() {\n     assert_eq!(x, Int(0));\n \n     // indexed LHS\n-    let mut v = vec![Int(1), Int(2)];\n+    // FIXME(mir-drop): use the vec![..] macro\n+    let mut v = Vec::new();\n+    v.push(Int(1));\n+    v.push(Int(2));\n     v[0] += Int(2);\n     assert_eq!(v[0], Int(3));\n \n@@ -87,6 +90,7 @@ fn main_mir() {\n     assert_eq!(array[0], 1);\n     assert_eq!(array[1], 2);\n     assert_eq!(array[2], 3);\n+\n }\n \n impl AddAssign for Int {"}]}