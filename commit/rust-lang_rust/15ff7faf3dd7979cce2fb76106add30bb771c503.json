{"sha": "15ff7faf3dd7979cce2fb76106add30bb771c503", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZmY3ZmFmM2RkNzk3OWNjZTJmYjc2MTA2YWRkMzBiYjc3MWM1MDM=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-23T00:51:58Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-23T00:51:58Z"}, "message": "Render where clauses and more generic params", "tree": {"sha": "40647077f6cfbd6481b00c5b9f6ecc14e67bd749", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40647077f6cfbd6481b00c5b9f6ecc14e67bd749"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15ff7faf3dd7979cce2fb76106add30bb771c503", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15ff7faf3dd7979cce2fb76106add30bb771c503", "html_url": "https://github.com/rust-lang/rust/commit/15ff7faf3dd7979cce2fb76106add30bb771c503", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15ff7faf3dd7979cce2fb76106add30bb771c503/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "380293d6c2ead91a0988183ca634d9eb4f4fa9d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/380293d6c2ead91a0988183ca634d9eb4f4fa9d7", "html_url": "https://github.com/rust-lang/rust/commit/380293d6c2ead91a0988183ca634d9eb4f4fa9d7"}], "stats": {"total": 189, "additions": 155, "deletions": 34}, "files": [{"sha": "4bc87a0e20b5672869252586c6ed9366a7b7f86b", "filename": "crates/hir_def/src/item_tree/pretty.rs", "status": "modified", "additions": 108, "deletions": 28, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/15ff7faf3dd7979cce2fb76106add30bb771c503/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ff7faf3dd7979cce2fb76106add30bb771c503/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=15ff7faf3dd7979cce2fb76106add30bb771c503", "patch": "@@ -3,7 +3,10 @@\n use std::fmt::{self, Write};\n \n use crate::{\n-    attr::RawAttrs, generics::TypeParamProvenance, path::GenericArg, visibility::RawVisibility,\n+    attr::RawAttrs,\n+    generics::{WherePredicate, WherePredicateTypeTarget},\n+    path::GenericArg,\n+    visibility::RawVisibility,\n };\n \n use super::*;\n@@ -72,6 +75,13 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n+    fn whitespace(&mut self) {\n+        match self.buf.chars().next_back() {\n+            None | Some('\\n') | Some(' ') => {}\n+            _ => self.buf.push(' '),\n+        }\n+    }\n+\n     fn print_attrs(&mut self, attrs: &RawAttrs, inner: bool) {\n         let inner = if inner { \"!\" } else { \"\" };\n         for attr in &**attrs {\n@@ -102,7 +112,8 @@ impl<'a> Printer<'a> {\n     fn print_fields(&mut self, fields: &Fields) {\n         match fields {\n             Fields::Record(fields) => {\n-                w!(self, \" {{\");\n+                self.whitespace();\n+                w!(self, \"{{\");\n                 self.indented(|this| {\n                     for field in fields.clone() {\n                         let Field { visibility, name, type_ref } = &this.tree[field];\n@@ -133,6 +144,25 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n+    fn print_fields_and_where_clause(&mut self, fields: &Fields, params: &GenericParams) {\n+        match fields {\n+            Fields::Record(_) => {\n+                if self.print_where_clause(params) {\n+                    wln!(self);\n+                }\n+                self.print_fields(fields);\n+            }\n+            Fields::Unit => {\n+                self.print_where_clause(params);\n+                self.print_fields(fields);\n+            }\n+            Fields::Tuple(_) => {\n+                self.print_fields(fields);\n+                self.print_where_clause(params);\n+            }\n+        }\n+    }\n+\n     fn print_mod_item(&mut self, item: ModItem) {\n         self.print_attrs_of(item);\n \n@@ -212,14 +242,15 @@ impl<'a> Printer<'a> {\n                 }\n                 w!(self, \") -> \");\n                 self.print_type_ref(ret_type);\n+                self.print_where_clause(generic_params);\n                 wln!(self, \";\");\n             }\n             ModItem::Struct(it) => {\n                 let Struct { visibility, name, fields, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n                 w!(self, \"struct {}\", name);\n                 self.print_generic_params(generic_params);\n-                self.print_fields(fields);\n+                self.print_fields_and_where_clause(fields, generic_params);\n                 if matches!(fields, Fields::Record(_)) {\n                     wln!(self);\n                 } else {\n@@ -231,7 +262,7 @@ impl<'a> Printer<'a> {\n                 self.print_visibility(*visibility);\n                 w!(self, \"union {}\", name);\n                 self.print_generic_params(generic_params);\n-                self.print_fields(fields);\n+                self.print_fields_and_where_clause(fields, generic_params);\n                 if matches!(fields, Fields::Record(_)) {\n                     wln!(self);\n                 } else {\n@@ -243,7 +274,7 @@ impl<'a> Printer<'a> {\n                 self.print_visibility(*visibility);\n                 w!(self, \"enum {}\", name);\n                 self.print_generic_params(generic_params);\n-                w!(self, \" {{\");\n+                self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n                     for variant in variants.clone() {\n                         let Variant { name, fields } = &this.tree[variant];\n@@ -301,14 +332,13 @@ impl<'a> Printer<'a> {\n                 if *is_auto {\n                     w!(self, \"auto \");\n                 }\n-                w!(self, \"trait\");\n+                w!(self, \"trait {}\", name);\n                 self.print_generic_params(generic_params);\n-                w!(self, \" {}\", name);\n                 if !bounds.is_empty() {\n                     w!(self, \": \");\n                     self.print_type_bounds(bounds);\n                 }\n-                w!(self, \" {{\");\n+                self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n                     for item in &**items {\n                         this.print_mod_item((*item).into());\n@@ -330,7 +360,7 @@ impl<'a> Printer<'a> {\n                     w!(self, \" for \");\n                 }\n                 self.print_type_ref(self_ty);\n-                w!(self, \" {{\");\n+                self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n                     for item in &**items {\n                         this.print_mod_item((*item).into());\n@@ -359,6 +389,7 @@ impl<'a> Printer<'a> {\n                     w!(self, \" = \");\n                     self.print_type_ref(ty);\n                 }\n+                self.print_where_clause(generic_params);\n                 w!(self, \";\");\n                 if *is_extern {\n                     w!(self, \"  // extern\");\n@@ -572,44 +603,93 @@ impl<'a> Printer<'a> {\n     }\n \n     fn print_generic_params(&mut self, params: &GenericParams) {\n+        if params.types.is_empty() && params.lifetimes.is_empty() && params.consts.is_empty() {\n+            return;\n+        }\n+\n+        w!(self, \"<\");\n         let mut first = true;\n         for (_, lt) in params.lifetimes.iter() {\n-            if first {\n-                w!(self, \"<\");\n-            } else {\n+            if !first {\n                 w!(self, \", \");\n             }\n             first = false;\n             w!(self, \"{}\", lt.name);\n         }\n-        for (_, ty) in params.types.iter() {\n-            if ty.provenance != TypeParamProvenance::TypeParamList {\n-                continue;\n+        for (idx, ty) in params.types.iter() {\n+            if !first {\n+                w!(self, \", \");\n             }\n-            if let Some(name) = &ty.name {\n-                if first {\n-                    w!(self, \"<\");\n-                } else {\n-                    w!(self, \", \");\n-                }\n-                first = false;\n-                w!(self, \"{}\", name);\n+            first = false;\n+            match &ty.name {\n+                Some(name) => w!(self, \"{}\", name),\n+                None => w!(self, \"_anon_{}\", idx.into_raw()),\n             }\n         }\n         for (_, konst) in params.consts.iter() {\n-            if first {\n-                w!(self, \"<\");\n-            } else {\n+            if !first {\n                 w!(self, \", \");\n             }\n             first = false;\n             w!(self, \"const {}: \", konst.name);\n             self.print_type_ref(&konst.ty);\n         }\n-        if !first {\n-            w!(self, \">\");\n+        w!(self, \">\");\n+    }\n+\n+    fn print_where_clause_and_opening_brace(&mut self, params: &GenericParams) {\n+        if self.print_where_clause(params) {\n+            w!(self, \"\\n{{\");\n+        } else {\n+            self.whitespace();\n+            w!(self, \"{{\");\n         }\n     }\n+\n+    fn print_where_clause(&mut self, params: &GenericParams) -> bool {\n+        if params.where_predicates.is_empty() {\n+            return false;\n+        }\n+\n+        w!(self, \"\\nwhere\");\n+        self.indented(|this| {\n+            for (i, pred) in params.where_predicates.iter().enumerate() {\n+                if i != 0 {\n+                    wln!(this, \",\");\n+                }\n+\n+                let (target, bound) = match pred {\n+                    WherePredicate::TypeBound { target, bound } => (target, bound),\n+                    WherePredicate::Lifetime { target, bound } => {\n+                        wln!(this, \"{}: {},\", target.name, bound.name);\n+                        continue;\n+                    }\n+                    WherePredicate::ForLifetime { lifetimes, target, bound } => {\n+                        w!(this, \"for<\");\n+                        for (i, lt) in lifetimes.iter().enumerate() {\n+                            if i != 0 {\n+                                w!(this, \", \");\n+                            }\n+                            w!(this, \"{}\", lt);\n+                        }\n+                        w!(this, \"> \");\n+                        (target, bound)\n+                    }\n+                };\n+\n+                match target {\n+                    WherePredicateTypeTarget::TypeRef(ty) => this.print_type_ref(ty),\n+                    WherePredicateTypeTarget::TypeParam(id) => match &params.types[*id].name {\n+                        Some(name) => w!(this, \"{}\", name),\n+                        None => w!(this, \"_anon_{}\", id.into_raw()),\n+                    },\n+                }\n+                w!(this, \": \");\n+                this.print_type_bounds(std::slice::from_ref(bound));\n+            }\n+        });\n+        true\n+    }\n }\n \n impl<'a> Write for Printer<'a> {"}, {"sha": "6407871b504967d48dfb04c63fef98ab88f6a585", "filename": "crates/hir_def/src/item_tree/tests.rs", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/15ff7faf3dd7979cce2fb76106add30bb771c503/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ff7faf3dd7979cce2fb76106add30bb771c503/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=15ff7faf3dd7979cce2fb76106add30bb771c503", "patch": "@@ -183,7 +183,11 @@ trait Tr: SuperTrait + 'lifetime {\n                 _: (),\n             ) -> ();\n \n-            pub(self) trait Tr: SuperTrait + 'lifetime {\n+            pub(self) trait Tr<Self>: SuperTrait + 'lifetime\n+            where\n+                Self: SuperTrait,\n+                Self: 'lifetime\n+            {\n                 pub(self) type Assoc: AssocBound = Default;\n \n                 // flags = 0x1\n@@ -207,6 +211,8 @@ mod inline {\n \n     fn fn_in_module() {}\n }\n+\n+mod outline;\n         \"#,\n         expect![[r##\"\n             #[doc = \" outer\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n@@ -217,6 +223,8 @@ mod inline {\n                 // flags = 0x2\n                 pub(self) fn fn_in_module() -> ();\n             }\n+\n+            pub(self) mod outline;\n         \"##]],\n     );\n }\n@@ -293,31 +301,64 @@ struct S {\n fn generics() {\n     check(\n         r#\"\n-struct S<'a, 'b: 'a, T: Copy + 'a + 'b, const K: u8 = 0> {}\n+struct S<'a, 'b: 'a, T: Copy + 'a + 'b, const K: u8 = 0> {\n+    field: &'a &'b T,\n+}\n+\n+struct Tuple<T: Copy>(T);\n \n impl<'a, 'b: 'a, T: Copy + 'a + 'b, const K: u8 = 0> S<'a, 'b, T, K> {\n     fn f<G: 'a>(arg: impl Copy) -> impl Copy {}\n }\n \n enum Enum<'a, T, const U: u8> {}\n union Union<'a, T, const U: u8> {}\n+\n+trait Tr<'a, T: 'a>: Super {}\n         \"#,\n         expect![[r#\"\n-            pub(self) struct S<'a, 'b, T, const K: u8> {\n+            pub(self) struct S<'a, 'b, T, const K: u8>\n+            where\n+                T: Copy,\n+                T: 'a,\n+                T: 'b\n+            {\n+                pub(self) field: &'a &'b T,\n             }\n \n-            impl<'a, 'b, T, const K: u8> S<'a, 'b, T, K> {\n+            pub(self) struct Tuple<T>(\n+                pub(self) 0: T,\n+            )\n+            where\n+                T: Copy;\n+\n+            impl<'a, 'b, T, const K: u8> S<'a, 'b, T, K>\n+            where\n+                T: Copy,\n+                T: 'a,\n+                T: 'b\n+            {\n                 // flags = 0x2\n-                pub(self) fn f<G>(\n+                pub(self) fn f<G, _anon_1>(\n                     _: impl Copy,\n-                ) -> impl Copy;\n+                ) -> impl Copy\n+                where\n+                    G: 'a,\n+                    _anon_1: Copy;\n             }\n \n             pub(self) enum Enum<'a, T, const U: u8> {\n             }\n \n             pub(self) union Union<'a, T, const U: u8> {\n             }\n+\n+            pub(self) trait Tr<'a, Self, T>: Super\n+            where\n+                Self: Super,\n+                T: 'a\n+            {\n+            }\n         \"#]],\n     )\n }"}]}