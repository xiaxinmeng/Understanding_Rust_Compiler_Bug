{"sha": "ed935de08761ef3d463b7770f9c5d8b7422bed82", "node_id": "C_kwDOAAsO6NoAKGVkOTM1ZGUwODc2MWVmM2Q0NjNiNzc3MGY5YzVkOGI3NDIyYmVkODI", "commit": {"author": {"name": "Yuri Astrakhan", "email": "YuriAstrakhan@gmail.com", "date": "2023-05-23T03:00:28Z"}, "committer": {"name": "Yuri Astrakhan", "email": "YuriAstrakhan@gmail.com", "date": "2023-05-23T03:00:28Z"}, "message": "Run-rustfix", "tree": {"sha": "92959fdc79816c5045342978239e59be36039fff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92959fdc79816c5045342978239e59be36039fff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed935de08761ef3d463b7770f9c5d8b7422bed82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed935de08761ef3d463b7770f9c5d8b7422bed82", "html_url": "https://github.com/rust-lang/rust/commit/ed935de08761ef3d463b7770f9c5d8b7422bed82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed935de08761ef3d463b7770f9c5d8b7422bed82/comments", "author": {"login": "nyurik", "id": 1641515, "node_id": "MDQ6VXNlcjE2NDE1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1641515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nyurik", "html_url": "https://github.com/nyurik", "followers_url": "https://api.github.com/users/nyurik/followers", "following_url": "https://api.github.com/users/nyurik/following{/other_user}", "gists_url": "https://api.github.com/users/nyurik/gists{/gist_id}", "starred_url": "https://api.github.com/users/nyurik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nyurik/subscriptions", "organizations_url": "https://api.github.com/users/nyurik/orgs", "repos_url": "https://api.github.com/users/nyurik/repos", "events_url": "https://api.github.com/users/nyurik/events{/privacy}", "received_events_url": "https://api.github.com/users/nyurik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nyurik", "id": 1641515, "node_id": "MDQ6VXNlcjE2NDE1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1641515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nyurik", "html_url": "https://github.com/nyurik", "followers_url": "https://api.github.com/users/nyurik/followers", "following_url": "https://api.github.com/users/nyurik/following{/other_user}", "gists_url": "https://api.github.com/users/nyurik/gists{/gist_id}", "starred_url": "https://api.github.com/users/nyurik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nyurik/subscriptions", "organizations_url": "https://api.github.com/users/nyurik/orgs", "repos_url": "https://api.github.com/users/nyurik/repos", "events_url": "https://api.github.com/users/nyurik/events{/privacy}", "received_events_url": "https://api.github.com/users/nyurik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68df61ebd9e0e6b75299185e545bd608369c4883", "url": "https://api.github.com/repos/rust-lang/rust/commits/68df61ebd9e0e6b75299185e545bd608369c4883", "html_url": "https://github.com/rust-lang/rust/commit/68df61ebd9e0e6b75299185e545bd608369c4883"}], "stats": {"total": 388, "additions": 385, "deletions": 3}, "files": [{"sha": "77a2cf3b991f6064fd506b67ce10979144455dbd", "filename": "tests/ui/single_match.fixed", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/ed935de08761ef3d463b7770f9c5d8b7422bed82/tests%2Fui%2Fsingle_match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ed935de08761ef3d463b7770f9c5d8b7422bed82/tests%2Fui%2Fsingle_match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.fixed?ref=ed935de08761ef3d463b7770f9c5d8b7422bed82", "patch": "@@ -0,0 +1,209 @@\n+//@run-rustfix\n+#![warn(clippy::single_match)]\n+#![allow(unused, clippy::uninlined_format_args, clippy::redundant_pattern_matching)]\n+fn dummy() {}\n+\n+fn single_match() {\n+    let x = Some(1u8);\n+\n+    if let Some(y) = x {\n+        println!(\"{:?}\", y);\n+    };\n+\n+    let x = Some(1u8);\n+    if let Some(y) = x { println!(\"{:?}\", y) }\n+\n+    let z = (1u8, 1u8);\n+    if let (2..=3, 7..=9) = z { dummy() };\n+\n+    // Not linted (pattern guards used)\n+    match x {\n+        Some(y) if y == 0 => println!(\"{:?}\", y),\n+        _ => (),\n+    }\n+\n+    // Not linted (no block with statements in the single arm)\n+    match z {\n+        (2..=3, 7..=9) => println!(\"{:?}\", z),\n+        _ => println!(\"nope\"),\n+    }\n+}\n+\n+enum Foo {\n+    Bar,\n+    Baz(u8),\n+}\n+use std::borrow::Cow;\n+use Foo::*;\n+\n+fn single_match_know_enum() {\n+    let x = Some(1u8);\n+    let y: Result<_, i8> = Ok(1i8);\n+\n+    if let Some(y) = x { dummy() };\n+\n+    if let Ok(y) = y { dummy() };\n+\n+    let c = Cow::Borrowed(\"\");\n+\n+    if let Cow::Borrowed(..) = c { dummy() };\n+\n+    let z = Foo::Bar;\n+    // no warning\n+    match z {\n+        Bar => println!(\"42\"),\n+        Baz(_) => (),\n+    }\n+\n+    match z {\n+        Baz(_) => println!(\"42\"),\n+        Bar => (),\n+    }\n+}\n+\n+// issue #173\n+fn if_suggestion() {\n+    let x = \"test\";\n+    if x == \"test\" { println!() }\n+\n+    #[derive(PartialEq, Eq)]\n+    enum Foo {\n+        A,\n+        B,\n+        C(u32),\n+    }\n+\n+    let x = Foo::A;\n+    if x == Foo::A { println!() }\n+\n+    const FOO_C: Foo = Foo::C(0);\n+    if x == FOO_C { println!() }\n+\n+    if x == Foo::A { println!() }\n+\n+    let x = &x;\n+    if x == &Foo::A { println!() }\n+\n+    enum Bar {\n+        A,\n+        B,\n+    }\n+    impl PartialEq for Bar {\n+        fn eq(&self, rhs: &Self) -> bool {\n+            matches!((self, rhs), (Self::A, Self::A) | (Self::B, Self::B))\n+        }\n+    }\n+    impl Eq for Bar {}\n+\n+    let x = Bar::A;\n+    if let Bar::A = x { println!() }\n+\n+    // issue #7038\n+    struct X;\n+    let x = Some(X);\n+    if let None = x { println!() };\n+}\n+\n+// See: issue #8282\n+fn ranges() {\n+    enum E {\n+        V,\n+    }\n+    let x = (Some(E::V), Some(42));\n+\n+    // Don't lint, because the `E` enum can be extended with additional fields later. Thus, the\n+    // proposed replacement to `if let Some(E::V)` may hide non-exhaustive warnings that appeared\n+    // because of `match` construction.\n+    match x {\n+        (Some(E::V), _) => {},\n+        (None, _) => {},\n+    }\n+\n+    // lint\n+    if let (Some(_), _) = x {}\n+\n+    // lint\n+    if let (Some(E::V), _) = x { todo!() }\n+\n+    // lint\n+    if let (.., Some(E::V), _) = (Some(42), Some(E::V), Some(42)) {}\n+\n+    // Don't lint, see above.\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (.., Some(E::V), _) => {},\n+        (.., None, _) => {},\n+    }\n+\n+    // Don't lint, see above.\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (Some(E::V), ..) => {},\n+        (None, ..) => {},\n+    }\n+\n+    // Don't lint, see above.\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (_, Some(E::V), ..) => {},\n+        (_, None, ..) => {},\n+    }\n+}\n+\n+fn skip_type_aliases() {\n+    enum OptionEx {\n+        Some(i32),\n+        None,\n+    }\n+    enum ResultEx {\n+        Err(i32),\n+        Ok(i32),\n+    }\n+\n+    use OptionEx::{None, Some};\n+    use ResultEx::{Err, Ok};\n+\n+    // don't lint\n+    match Err(42) {\n+        Ok(_) => dummy(),\n+        Err(_) => (),\n+    };\n+\n+    // don't lint\n+    match Some(1i32) {\n+        Some(_) => dummy(),\n+        None => (),\n+    };\n+}\n+\n+macro_rules! single_match {\n+    ($num:literal) => {\n+        match $num {\n+            15 => println!(\"15\"),\n+            _ => (),\n+        }\n+    };\n+}\n+\n+fn main() {\n+    single_match!(5);\n+\n+    // Don't lint\n+    let _ = match Some(0) {\n+        #[cfg(feature = \"foo\")]\n+        Some(10) => 11,\n+        Some(x) => x,\n+        _ => 0,\n+    };\n+}\n+\n+fn issue_10808(bar: Option<i32>) {\n+    if let Some(v) = bar { unsafe {\n+        let r = &v as *const i32;\n+        println!(\"{}\", *r);\n+    } }\n+\n+    if let Some(v) = bar {\n+        unsafe {\n+            let r = &v as *const i32;\n+            println!(\"{}\", *r);\n+        }\n+    }\n+}"}, {"sha": "8d0ab5b99ad51e84e8b9066d277acf3cc12b3c9e", "filename": "tests/ui/single_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed935de08761ef3d463b7770f9c5d8b7422bed82/tests%2Fui%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed935de08761ef3d463b7770f9c5d8b7422bed82/tests%2Fui%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.rs?ref=ed935de08761ef3d463b7770f9c5d8b7422bed82", "patch": "@@ -1,6 +1,6 @@\n+//@run-rustfix\n #![warn(clippy::single_match)]\n-#![allow(unused, clippy::uninlined_format_args)]\n-\n+#![allow(unused, clippy::uninlined_format_args, clippy::redundant_pattern_matching)]\n fn dummy() {}\n \n fn single_match() {"}, {"sha": "f88498655a41850601deca91cf2fd026c7f2f278", "filename": "tests/ui/single_match_else.fixed", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/ed935de08761ef3d463b7770f9c5d8b7422bed82/tests%2Fui%2Fsingle_match_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ed935de08761ef3d463b7770f9c5d8b7422bed82/tests%2Fui%2Fsingle_match_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.fixed?ref=ed935de08761ef3d463b7770f9c5d8b7422bed82", "patch": "@@ -0,0 +1,173 @@\n+//@run-rustfix\n+//@aux-build: proc_macros.rs\n+#![warn(clippy::single_match_else)]\n+#![allow(unused, clippy::needless_return, clippy::no_effect, clippy::uninlined_format_args)]\n+extern crate proc_macros;\n+use proc_macros::with_span;\n+\n+enum ExprNode {\n+    ExprAddrOf,\n+    Butterflies,\n+    Unicorns,\n+}\n+\n+static NODE: ExprNode = ExprNode::Unicorns;\n+\n+fn unwrap_addr() -> Option<&'static ExprNode> {\n+    let _ = if let ExprNode::ExprAddrOf = ExprNode::Butterflies { Some(&NODE) } else {\n+        let x = 5;\n+        None\n+    };\n+\n+    // Don't lint\n+    with_span!(span match ExprNode::Butterflies {\n+        ExprNode::ExprAddrOf => Some(&NODE),\n+        _ => {\n+            let x = 5;\n+            None\n+        },\n+    })\n+}\n+\n+macro_rules! unwrap_addr {\n+    ($expression:expr) => {\n+        match $expression {\n+            ExprNode::ExprAddrOf => Some(&NODE),\n+            _ => {\n+                let x = 5;\n+                None\n+            },\n+        }\n+    };\n+}\n+\n+#[rustfmt::skip]\n+fn main() {\n+    unwrap_addr!(ExprNode::Unicorns);\n+\n+    //\n+    // don't lint single exprs/statements\n+    //\n+\n+    // don't lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => return,\n+    }\n+\n+    // don't lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => {\n+            return\n+        },\n+    }\n+\n+    // don't lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => {\n+            return;\n+        },\n+    }\n+\n+    //\n+    // lint multiple exprs/statements \"else\" blocks\n+    //\n+\n+    // lint here\n+    if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+        println!(\"else block\");\n+        return\n+    }\n+\n+    // lint here\n+    if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+        println!(\"else block\");\n+        return;\n+    }\n+\n+    // lint here\n+    use std::convert::Infallible;\n+    if let Ok(a) = Result::<i32, Infallible>::Ok(1) { println!(\"${:?}\", a) } else {\n+        println!(\"else block\");\n+        return;\n+    }\n+\n+    use std::borrow::Cow;\n+    if let Cow::Owned(a) = Cow::from(\"moo\") { println!(\"${:?}\", a) } else {\n+        println!(\"else block\");\n+        return;\n+    }\n+}\n+\n+fn issue_10808(bar: Option<i32>) {\n+    if let Some(v) = bar { unsafe {\n+        let r = &v as *const i32;\n+        println!(\"{}\", *r);\n+    } } else {\n+        println!(\"None1\");\n+        println!(\"None2\");\n+    }\n+\n+    if let Some(v) = bar {\n+        println!(\"Some\");\n+        println!(\"{v}\");\n+    } else { unsafe {\n+        let v = 0;\n+        let r = &v as *const i32;\n+        println!(\"{}\", *r);\n+    } }\n+\n+    if let Some(v) = bar { unsafe {\n+        let r = &v as *const i32;\n+        println!(\"{}\", *r);\n+    } } else { unsafe {\n+        let v = 0;\n+        let r = &v as *const i32;\n+        println!(\"{}\", *r);\n+    } }\n+\n+    if let Some(v) = bar {\n+        unsafe {\n+            let r = &v as *const i32;\n+            println!(\"{}\", *r);\n+        }\n+    } else {\n+        println!(\"None\");\n+        println!(\"None\");\n+    }\n+\n+    match bar {\n+        Some(v) => {\n+            println!(\"Some\");\n+            println!(\"{v}\");\n+        },\n+        #[rustfmt::skip]\n+        None => {\n+            unsafe {\n+                let v = 0;\n+                let r = &v as *const i32;\n+                println!(\"{}\", *r);\n+            }\n+        },\n+    }\n+\n+    match bar {\n+        #[rustfmt::skip]\n+        Some(v) => {\n+            unsafe {\n+                let r = &v as *const i32;\n+                println!(\"{}\", *r);\n+            }\n+        },\n+        #[rustfmt::skip]\n+        None => {\n+            unsafe {\n+                let v = 0;\n+                let r = &v as *const i32;\n+                println!(\"{}\", *r);\n+            }\n+        },\n+    }\n+}"}, {"sha": "b34b95539190cdbd4389364a6485e00afa3edc05", "filename": "tests/ui/single_match_else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed935de08761ef3d463b7770f9c5d8b7422bed82/tests%2Fui%2Fsingle_match_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed935de08761ef3d463b7770f9c5d8b7422bed82/tests%2Fui%2Fsingle_match_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.rs?ref=ed935de08761ef3d463b7770f9c5d8b7422bed82", "patch": "@@ -1,7 +1,7 @@\n+//@run-rustfix\n //@aux-build: proc_macros.rs\n #![warn(clippy::single_match_else)]\n #![allow(unused, clippy::needless_return, clippy::no_effect, clippy::uninlined_format_args)]\n-\n extern crate proc_macros;\n use proc_macros::with_span;\n "}]}