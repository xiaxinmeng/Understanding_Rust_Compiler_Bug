{"sha": "de2320e461719277cf2b86ea4315f8cc5d2bf96c", "node_id": "C_kwDOAAsO6NoAKGRlMjMyMGU0NjE3MTkyNzdjZjJiODZlYTQzMTVmOGNjNWQyYmY5NmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-04T07:10:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-04T07:10:45Z"}, "message": "Auto merge of #14965 - Veykril:panic-ctx, r=Veykril\n\nAdd mandatory panic contexts to all threadpool tasks\n\nthe diagnostics task is panicking I think, but without this you can't really tell because the stack trace ends in a generic iterator fold call instead of something specific.", "tree": {"sha": "2dd763df528aee7622c287d692ad396805d82562", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dd763df528aee7622c287d692ad396805d82562"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de2320e461719277cf2b86ea4315f8cc5d2bf96c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de2320e461719277cf2b86ea4315f8cc5d2bf96c", "html_url": "https://github.com/rust-lang/rust/commit/de2320e461719277cf2b86ea4315f8cc5d2bf96c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de2320e461719277cf2b86ea4315f8cc5d2bf96c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fb1df6b7a410ffbb2bfd7d5172d14435f059616", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fb1df6b7a410ffbb2bfd7d5172d14435f059616", "html_url": "https://github.com/rust-lang/rust/commit/4fb1df6b7a410ffbb2bfd7d5172d14435f059616"}, {"sha": "2d0510e226ea857bcd2f14845740b0b20d3048a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d0510e226ea857bcd2f14845740b0b20d3048a2", "html_url": "https://github.com/rust-lang/rust/commit/2d0510e226ea857bcd2f14845740b0b20d3048a2"}], "stats": {"total": 312, "additions": 174, "deletions": 138}, "files": [{"sha": "3527d92a4ec4e7d4f7a455e997df39adf3b8b97b", "filename": "crates/rust-analyzer/src/dispatch.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de2320e461719277cf2b86ea4315f8cc5d2bf96c/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2320e461719277cf2b86ea4315f8cc5d2bf96c/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs?ref=de2320e461719277cf2b86ea4315f8cc5d2bf96c", "patch": "@@ -104,13 +104,10 @@ impl<'a> RequestDispatcher<'a> {\n             None => return self,\n         };\n \n-        self.global_state.task_pool.handle.spawn(ThreadIntent::Worker, {\n+        self.global_state.task_pool.handle.spawn(ThreadIntent::Worker, panic_context, {\n             let world = self.global_state.snapshot();\n             move || {\n-                let result = panic::catch_unwind(move || {\n-                    let _pctx = stdx::panic_context::enter(panic_context);\n-                    f(world, params)\n-                });\n+                let result = panic::catch_unwind(move || f(world, params));\n                 match thread_result_to_response::<R>(req.id.clone(), result) {\n                     Ok(response) => Task::Response(response),\n                     Err(_) => Task::Response(lsp_server::Response::new_err(\n@@ -178,13 +175,10 @@ impl<'a> RequestDispatcher<'a> {\n             None => return self,\n         };\n \n-        self.global_state.task_pool.handle.spawn(intent, {\n+        self.global_state.task_pool.handle.spawn(intent, panic_context, {\n             let world = self.global_state.snapshot();\n             move || {\n-                let result = panic::catch_unwind(move || {\n-                    let _pctx = stdx::panic_context::enter(panic_context);\n-                    f(world, params)\n-                });\n+                let result = panic::catch_unwind(move || f(world, params));\n                 match thread_result_to_response::<R>(req.id.clone(), result) {\n                     Ok(response) => Task::Response(response),\n                     Err(_) => Task::Retry(req),"}, {"sha": "b3623669cc6b3e35cf73999e1f49d29624bc7c2a", "filename": "crates/rust-analyzer/src/handlers/notification.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de2320e461719277cf2b86ea4315f8cc5d2bf96c/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2320e461719277cf2b86ea4315f8cc5d2bf96c/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs?ref=de2320e461719277cf2b86ea4315f8cc5d2bf96c", "patch": "@@ -291,11 +291,15 @@ fn run_flycheck(state: &mut GlobalState, vfs_path: VfsPath) -> bool {\n             }\n             Ok(())\n         };\n-        state.task_pool.handle.spawn_with_sender(stdx::thread::ThreadIntent::Worker, move |_| {\n-            if let Err(e) = std::panic::catch_unwind(task) {\n-                tracing::error!(\"flycheck task panicked: {e:?}\")\n-            }\n-        });\n+        state.task_pool.handle.spawn_with_sender(\n+            stdx::thread::ThreadIntent::Worker,\n+            \"flycheck\",\n+            move |_| {\n+                if let Err(e) = std::panic::catch_unwind(task) {\n+                    tracing::error!(\"flycheck task panicked: {e:?}\")\n+                }\n+            },\n+        );\n         true\n     } else {\n         false"}, {"sha": "92d44eeee89417d180e6f0b0743c3fec30b21b5c", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 76, "deletions": 64, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/de2320e461719277cf2b86ea4315f8cc5d2bf96c/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2320e461719277cf2b86ea4315f8cc5d2bf96c/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=de2320e461719277cf2b86ea4315f8cc5d2bf96c", "patch": "@@ -397,19 +397,25 @@ impl GlobalState {\n         tracing::debug!(%cause, \"will prime caches\");\n         let num_worker_threads = self.config.prime_caches_num_threads();\n \n-        self.task_pool.handle.spawn_with_sender(stdx::thread::ThreadIntent::Worker, {\n-            let analysis = self.snapshot().analysis;\n-            move |sender| {\n-                sender.send(Task::PrimeCaches(PrimeCachesProgress::Begin)).unwrap();\n-                let res = analysis.parallel_prime_caches(num_worker_threads, |progress| {\n-                    let report = PrimeCachesProgress::Report(progress);\n-                    sender.send(Task::PrimeCaches(report)).unwrap();\n-                });\n-                sender\n-                    .send(Task::PrimeCaches(PrimeCachesProgress::End { cancelled: res.is_err() }))\n-                    .unwrap();\n-            }\n-        });\n+        self.task_pool.handle.spawn_with_sender(\n+            stdx::thread::ThreadIntent::Worker,\n+            \"prime_caches\",\n+            {\n+                let analysis = self.snapshot().analysis;\n+                move |sender| {\n+                    sender.send(Task::PrimeCaches(PrimeCachesProgress::Begin)).unwrap();\n+                    let res = analysis.parallel_prime_caches(num_worker_threads, |progress| {\n+                        let report = PrimeCachesProgress::Report(progress);\n+                        sender.send(Task::PrimeCaches(report)).unwrap();\n+                    });\n+                    sender\n+                        .send(Task::PrimeCaches(PrimeCachesProgress::End {\n+                            cancelled: res.is_err(),\n+                        }))\n+                        .unwrap();\n+                }\n+            },\n+        );\n     }\n \n     fn update_status_or_notify(&mut self) {\n@@ -796,56 +802,62 @@ impl GlobalState {\n \n         // Diagnostics are triggered by the user typing\n         // so we run them on a latency sensitive thread.\n-        self.task_pool.handle.spawn(stdx::thread::ThreadIntent::LatencySensitive, move || {\n-            let _p = profile::span(\"publish_diagnostics\");\n-            let diagnostics = subscriptions\n-                .into_iter()\n-                .filter_map(|file_id| {\n-                    let line_index = snapshot.file_line_index(file_id).ok()?;\n-                    Some((\n-                        file_id,\n-                        line_index,\n-                        snapshot\n-                            .analysis\n-                            .diagnostics(\n-                                &snapshot.config.diagnostics(),\n-                                ide::AssistResolveStrategy::None,\n-                                file_id,\n-                            )\n-                            .ok()?,\n-                    ))\n-                })\n-                .map(|(file_id, line_index, it)| {\n-                    (\n-                        file_id,\n-                        it.into_iter()\n-                            .map(move |d| lsp_types::Diagnostic {\n-                                range: crate::to_proto::range(&line_index, d.range),\n-                                severity: Some(crate::to_proto::diagnostic_severity(d.severity)),\n-                                code: Some(lsp_types::NumberOrString::String(\n-                                    d.code.as_str().to_string(),\n-                                )),\n-                                code_description: Some(lsp_types::CodeDescription {\n-                                    href: lsp_types::Url::parse(&format!(\n-                                        \"https://rust-analyzer.github.io/manual.html#{}\",\n-                                        d.code.as_str()\n-                                    ))\n-                                    .unwrap(),\n-                                }),\n-                                source: Some(\"rust-analyzer\".to_string()),\n-                                message: d.message,\n-                                related_information: None,\n-                                tags: if d.unused {\n-                                    Some(vec![lsp_types::DiagnosticTag::UNNECESSARY])\n-                                } else {\n-                                    None\n-                                },\n-                                data: None,\n-                            })\n-                            .collect::<Vec<_>>(),\n-                    )\n-                });\n-            Task::Diagnostics(diagnostics.collect())\n-        });\n+        self.task_pool.handle.spawn(\n+            stdx::thread::ThreadIntent::LatencySensitive,\n+            \"publish_diagnostics\",\n+            move || {\n+                let _p = profile::span(\"publish_diagnostics\");\n+                let diagnostics = subscriptions\n+                    .into_iter()\n+                    .filter_map(|file_id| {\n+                        let line_index = snapshot.file_line_index(file_id).ok()?;\n+                        Some((\n+                            file_id,\n+                            line_index,\n+                            snapshot\n+                                .analysis\n+                                .diagnostics(\n+                                    &snapshot.config.diagnostics(),\n+                                    ide::AssistResolveStrategy::None,\n+                                    file_id,\n+                                )\n+                                .ok()?,\n+                        ))\n+                    })\n+                    .map(|(file_id, line_index, it)| {\n+                        (\n+                            file_id,\n+                            it.into_iter()\n+                                .map(move |d| lsp_types::Diagnostic {\n+                                    range: crate::to_proto::range(&line_index, d.range),\n+                                    severity: Some(crate::to_proto::diagnostic_severity(\n+                                        d.severity,\n+                                    )),\n+                                    code: Some(lsp_types::NumberOrString::String(\n+                                        d.code.as_str().to_string(),\n+                                    )),\n+                                    code_description: Some(lsp_types::CodeDescription {\n+                                        href: lsp_types::Url::parse(&format!(\n+                                            \"https://rust-analyzer.github.io/manual.html#{}\",\n+                                            d.code.as_str()\n+                                        ))\n+                                        .unwrap(),\n+                                    }),\n+                                    source: Some(\"rust-analyzer\".to_string()),\n+                                    message: d.message,\n+                                    related_information: None,\n+                                    tags: if d.unused {\n+                                        Some(vec![lsp_types::DiagnosticTag::UNNECESSARY])\n+                                    } else {\n+                                        None\n+                                    },\n+                                    data: None,\n+                                })\n+                                .collect::<Vec<_>>(),\n+                        )\n+                    });\n+                Task::Diagnostics(diagnostics.collect())\n+            },\n+        );\n     }\n }"}, {"sha": "5911e24d999c28eb94f05bd79641334e652aed1a", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 63, "deletions": 53, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/de2320e461719277cf2b86ea4315f8cc5d2bf96c/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2320e461719277cf2b86ea4315f8cc5d2bf96c/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=de2320e461719277cf2b86ea4315f8cc5d2bf96c", "patch": "@@ -185,7 +185,7 @@ impl GlobalState {\n     pub(crate) fn fetch_workspaces(&mut self, cause: Cause) {\n         tracing::info!(%cause, \"will fetch workspaces\");\n \n-        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, {\n+        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, \"fetch_workspaces\", {\n             let linked_projects = self.config.linked_projects();\n             let detached_files = self.config.detached_files().to_vec();\n             let cargo_config = self.config.cargo();\n@@ -260,70 +260,80 @@ impl GlobalState {\n         tracing::info!(%cause, \"will fetch build data\");\n         let workspaces = Arc::clone(&self.workspaces);\n         let config = self.config.cargo();\n-        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, move |sender| {\n-            sender.send(Task::FetchBuildData(BuildDataProgress::Begin)).unwrap();\n+        self.task_pool.handle.spawn_with_sender(\n+            ThreadIntent::Worker,\n+            \"fetch_build_data\",\n+            move |sender| {\n+                sender.send(Task::FetchBuildData(BuildDataProgress::Begin)).unwrap();\n \n-            let progress = {\n-                let sender = sender.clone();\n-                move |msg| {\n-                    sender.send(Task::FetchBuildData(BuildDataProgress::Report(msg))).unwrap()\n-                }\n-            };\n-            let res = ProjectWorkspace::run_all_build_scripts(&workspaces, &config, &progress);\n+                let progress = {\n+                    let sender = sender.clone();\n+                    move |msg| {\n+                        sender.send(Task::FetchBuildData(BuildDataProgress::Report(msg))).unwrap()\n+                    }\n+                };\n+                let res = ProjectWorkspace::run_all_build_scripts(&workspaces, &config, &progress);\n \n-            sender.send(Task::FetchBuildData(BuildDataProgress::End((workspaces, res)))).unwrap();\n-        });\n+                sender\n+                    .send(Task::FetchBuildData(BuildDataProgress::End((workspaces, res))))\n+                    .unwrap();\n+            },\n+        );\n     }\n \n     pub(crate) fn fetch_proc_macros(&mut self, cause: Cause, paths: Vec<ProcMacroPaths>) {\n         tracing::info!(%cause, \"will load proc macros\");\n         let dummy_replacements = self.config.dummy_replacements().clone();\n         let proc_macro_clients = self.proc_macro_clients.clone();\n \n-        self.task_pool.handle.spawn_with_sender(ThreadIntent::Worker, move |sender| {\n-            sender.send(Task::LoadProcMacros(ProcMacroProgress::Begin)).unwrap();\n+        self.task_pool.handle.spawn_with_sender(\n+            ThreadIntent::Worker,\n+            \"fetch_proc_macros\",\n+            move |sender| {\n+                sender.send(Task::LoadProcMacros(ProcMacroProgress::Begin)).unwrap();\n+\n+                let dummy_replacements = &dummy_replacements;\n+                let progress = {\n+                    let sender = sender.clone();\n+                    &move |msg| {\n+                        sender.send(Task::LoadProcMacros(ProcMacroProgress::Report(msg))).unwrap()\n+                    }\n+                };\n \n-            let dummy_replacements = &dummy_replacements;\n-            let progress = {\n-                let sender = sender.clone();\n-                &move |msg| {\n-                    sender.send(Task::LoadProcMacros(ProcMacroProgress::Report(msg))).unwrap()\n+                let mut res = FxHashMap::default();\n+                let chain = proc_macro_clients\n+                    .iter()\n+                    .map(|res| res.as_ref().map_err(|e| e.to_string()))\n+                    .chain(iter::repeat_with(|| Err(\"Proc macros servers are not running\".into())));\n+                for (client, paths) in chain.zip(paths) {\n+                    res.extend(paths.into_iter().map(move |(crate_id, res)| {\n+                        (\n+                            crate_id,\n+                            res.map_or_else(\n+                                |_| Err(\"proc macro crate is missing dylib\".to_owned()),\n+                                |(crate_name, path)| {\n+                                    progress(path.display().to_string());\n+                                    client.as_ref().map_err(Clone::clone).and_then(|client| {\n+                                        load_proc_macro(\n+                                            client,\n+                                            &path,\n+                                            crate_name\n+                                                .as_deref()\n+                                                .and_then(|crate_name| {\n+                                                    dummy_replacements.get(crate_name).map(|v| &**v)\n+                                                })\n+                                                .unwrap_or_default(),\n+                                        )\n+                                    })\n+                                },\n+                            ),\n+                        )\n+                    }));\n                 }\n-            };\n-\n-            let mut res = FxHashMap::default();\n-            let chain = proc_macro_clients\n-                .iter()\n-                .map(|res| res.as_ref().map_err(|e| e.to_string()))\n-                .chain(iter::repeat_with(|| Err(\"Proc macros servers are not running\".into())));\n-            for (client, paths) in chain.zip(paths) {\n-                res.extend(paths.into_iter().map(move |(crate_id, res)| {\n-                    (\n-                        crate_id,\n-                        res.map_or_else(\n-                            |_| Err(\"proc macro crate is missing dylib\".to_owned()),\n-                            |(crate_name, path)| {\n-                                progress(path.display().to_string());\n-                                client.as_ref().map_err(Clone::clone).and_then(|client| {\n-                                    load_proc_macro(\n-                                        client,\n-                                        &path,\n-                                        crate_name\n-                                            .as_deref()\n-                                            .and_then(|crate_name| {\n-                                                dummy_replacements.get(crate_name).map(|v| &**v)\n-                                            })\n-                                            .unwrap_or_default(),\n-                                    )\n-                                })\n-                            },\n-                        ),\n-                    )\n-                }));\n-            }\n \n-            sender.send(Task::LoadProcMacros(ProcMacroProgress::End(res))).unwrap();\n-        });\n+                sender.send(Task::LoadProcMacros(ProcMacroProgress::End(res))).unwrap();\n+            },\n+        );\n     }\n \n     pub(crate) fn set_proc_macros(&mut self, proc_macros: ProcMacros) {"}, {"sha": "823210980f2c52cd6843f46704ef9f6bbb89d4d7", "filename": "crates/rust-analyzer/src/task_pool.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/de2320e461719277cf2b86ea4315f8cc5d2bf96c/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2320e461719277cf2b86ea4315f8cc5d2bf96c/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs?ref=de2320e461719277cf2b86ea4315f8cc5d2bf96c", "patch": "@@ -14,25 +14,41 @@ impl<T> TaskPool<T> {\n         TaskPool { sender, pool: Pool::new(threads) }\n     }\n \n-    pub(crate) fn spawn<F>(&mut self, intent: ThreadIntent, task: F)\n-    where\n+    pub(crate) fn spawn<F>(\n+        &mut self,\n+        intent: ThreadIntent,\n+        panic_context: impl Into<String>,\n+        task: F,\n+    ) where\n         F: FnOnce() -> T + Send + 'static,\n         T: Send + 'static,\n     {\n+        let panic_context = panic_context.into();\n         self.pool.spawn(intent, {\n             let sender = self.sender.clone();\n-            move || sender.send(task()).unwrap()\n+            move || {\n+                let _pctx = stdx::panic_context::enter(panic_context);\n+                sender.send(task()).unwrap()\n+            }\n         })\n     }\n \n-    pub(crate) fn spawn_with_sender<F>(&mut self, intent: ThreadIntent, task: F)\n-    where\n+    pub(crate) fn spawn_with_sender<F>(\n+        &mut self,\n+        intent: ThreadIntent,\n+        panic_context: impl Into<String>,\n+        task: F,\n+    ) where\n         F: FnOnce(Sender<T>) + Send + 'static,\n         T: Send + 'static,\n     {\n+        let panic_context = panic_context.into();\n         self.pool.spawn(intent, {\n             let sender = self.sender.clone();\n-            move || task(sender)\n+            move || {\n+                let _pctx = stdx::panic_context::enter(panic_context);\n+                task(sender)\n+            }\n         })\n     }\n "}]}