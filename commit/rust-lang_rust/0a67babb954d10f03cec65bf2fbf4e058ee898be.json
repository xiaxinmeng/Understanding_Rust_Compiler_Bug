{"sha": "0a67babb954d10f03cec65bf2fbf4e058ee898be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNjdiYWJiOTU0ZDEwZjAzY2VjNjViZjJmYmY0ZTA1OGVlODk4YmU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-14T09:52:12Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-14T09:52:12Z"}, "message": "Work across multiple files", "tree": {"sha": "0b212b15af05a2f5a685a2f71f34a19431790a34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b212b15af05a2f5a685a2f71f34a19431790a34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a67babb954d10f03cec65bf2fbf4e058ee898be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a67babb954d10f03cec65bf2fbf4e058ee898be", "html_url": "https://github.com/rust-lang/rust/commit/0a67babb954d10f03cec65bf2fbf4e058ee898be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a67babb954d10f03cec65bf2fbf4e058ee898be/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f5b899c8533046f0eed7a6148ce60ce591b4666", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5b899c8533046f0eed7a6148ce60ce591b4666", "html_url": "https://github.com/rust-lang/rust/commit/8f5b899c8533046f0eed7a6148ce60ce591b4666"}], "stats": {"total": 151, "additions": 101, "deletions": 50}, "files": [{"sha": "068b6b7736c207ba8c291e8cfaa32d18b26ef0f8", "filename": "src/changes.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0a67babb954d10f03cec65bf2fbf4e058ee898be/src%2Fchanges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a67babb954d10f03cec65bf2fbf4e058ee898be/src%2Fchanges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchanges.rs?ref=0a67babb954d10f03cec65bf2fbf4e058ee898be", "patch": "@@ -15,14 +15,15 @@\n \n use strings::string_buffer::StringBuffer;\n use std::collections::HashMap;\n-use syntax::codemap::{CodeMap, Span};\n+use syntax::codemap::{CodeMap, Span,BytePos};\n use std::fmt;\n \n // This is basically a wrapper around a bunch of Ropes which makes it convenient\n // to work with libsyntax. It is badly named.\n pub struct ChangeSet<'a> {\n     file_map: HashMap<String, StringBuffer>,\n     codemap: &'a CodeMap,\n+    file_spans: Vec<(u32, u32)>,\n }\n \n impl<'a> ChangeSet<'a> {\n@@ -31,6 +32,7 @@ impl<'a> ChangeSet<'a> {\n         let mut result = ChangeSet {\n             file_map: HashMap::new(),\n             codemap: codemap,\n+            file_spans: Vec::with_capacity(codemap.files.borrow().len()),\n         };\n \n         for f in codemap.files.borrow().iter() {\n@@ -39,11 +41,49 @@ impl<'a> ChangeSet<'a> {\n             // power of two. TODO check that or do it here.\n             result.file_map.insert(f.name.clone(),\n                                    StringBuffer::with_capacity(f.src.as_ref().unwrap().len()));\n+\n+            result.file_spans.push((f.start_pos.0, f.end_pos.0));\n         }\n \n+        result.file_spans.sort();\n+\n         result\n     }\n \n+    pub fn filespans_for_span(&self, start: BytePos, end: BytePos) -> Vec<(u32, u32)> {\n+        assert!(start.0 <= end.0);\n+\n+        if self.file_spans.len() == 0 {\n+            return Vec::new();\n+        }\n+\n+        let mut idx = match self.file_spans.binary_search(&(start.0, ::std::u32::MAX)) {\n+            Ok(i) => i,\n+            Err(0) => 0,\n+            Err(i) => i - 1,\n+        };\n+\n+        let mut result = Vec::new();\n+        let mut start = start.0;\n+        loop {\n+            let cur_file = &self.file_spans[idx];\n+            idx += 1;\n+\n+            if idx >= self.file_spans.len() || start >= end.0 {\n+                if start < end.0 {\n+                    result.push((start, end.0));\n+                }\n+                return result;\n+            }\n+\n+            let end = ::std::cmp::min(cur_file.1 - 1, end.0);\n+            if start < end {\n+                result.push((start, end));\n+            }\n+            start = self.file_spans[idx].0;\n+        }\n+    }\n+\n     pub fn push_str(&mut self, file_name: &str, text: &str) {\n         let buf = self.file_map.get_mut(&*file_name).unwrap();\n         buf.push_str(text)"}, {"sha": "65951638c1cfa47890073af23d7579f72ffb7e64", "filename": "src/mod.rs", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/0a67babb954d10f03cec65bf2fbf4e058ee898be/src%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a67babb954d10f03cec65bf2fbf4e058ee898be/src%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmod.rs?ref=0a67babb954d10f03cec65bf2fbf4e058ee898be", "patch": "@@ -22,8 +22,8 @@\n // TODO priorities\n // Fix fns and methods properly - need visibility in visit\n // Writing output\n-// Working on multiple files, inclding empty ones\n // Smoke testing till we can use it\n+// end of multi-line string has wspace\n \n #[macro_use]\n extern crate log;\n@@ -123,10 +123,9 @@ struct FmtVisitor<'a> {\n \n impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n     fn visit_expr(&mut self, ex: &'v ast::Expr) {\n-        // TODO uncomment\n-        // debug!(\"visit_expr: {:?} {:?}\",\n-        //        self.codemap.lookup_char_pos(ex.span.lo),\n-        //        self.codemap.lookup_char_pos(ex.span.hi));\n+        debug!(\"visit_expr: {:?} {:?}\",\n+               self.codemap.lookup_char_pos(ex.span.lo),\n+               self.codemap.lookup_char_pos(ex.span.hi));\n         self.format_missing(ex.span.lo);\n         let offset = self.changes.cur_offset_span(ex.span);\n         let new_str = self.rewrite_expr(ex, MAX_WIDTH - offset, offset);\n@@ -135,10 +134,9 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n     }\n \n     fn visit_block(&mut self, b: &'v ast::Block) {\n-        // TODO uncomment\n-        // debug!(\"visit_block: {:?} {:?}\",\n-        //        self.codemap.lookup_char_pos(b.span.lo),\n-        //        self.codemap.lookup_char_pos(b.span.hi));\n+        debug!(\"visit_block: {:?} {:?}\",\n+               self.codemap.lookup_char_pos(b.span.lo),\n+               self.codemap.lookup_char_pos(b.span.hi));\n         self.format_missing(b.span.lo);\n \n         self.changes.push_str_span(b.span, \"{\");\n@@ -241,6 +239,15 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n     fn visit_mac(&mut self, mac: &'v ast::Mac) {\n         visit::walk_mac(self, mac)\n     }\n+\n+    fn visit_mod(&mut self, m: &'v ast::Mod, s: Span, _: ast::NodeId) {\n+        // Only visit inline mods here.\n+        if self.codemap.lookup_char_pos(s.lo).file.name !=\n+           self.codemap.lookup_char_pos(m.inner.lo).file.name {\n+            return;\n+        }\n+        visit::walk_mod(self, m);\n+    }\n }\n \n fn make_indent(width: usize) -> String {\n@@ -413,63 +420,67 @@ impl<'a> FmtVisitor<'a> {\n                                                                       process_last_snippet: F)\n     {\n         let start = self.last_pos;\n-        // TODO uncomment\n-        // debug!(\"format_missing_inner: {:?} to {:?}\",\n-        //        self.codemap.lookup_char_pos(start),\n-        //        self.codemap.lookup_char_pos(end));\n-\n-        // TODO(#11) gets tricky if we're missing more than one file\n-        // assert!(self.codemap.lookup_char_pos(start).file.name == self.codemap.lookup_char_pos(end).file.name,\n-        //         \"not implemented: unformated span across files: {} and {}\",\n-        //         self.codemap.lookup_char_pos(start).file.name,\n-        //         self.codemap.lookup_char_pos(end).file.name);\n-        // assert!(start <= end,\n-        //         \"Request to format inverted span: {:?} to {:?}\",\n-        //         self.codemap.lookup_char_pos(start),\n-        //         self.codemap.lookup_char_pos(end));\n+        debug!(\"format_missing_inner: {:?} to {:?}\",\n+               self.codemap.lookup_char_pos(start),\n+               self.codemap.lookup_char_pos(end));\n \n         if start == end {\n             return;\n         }\n \n-        self.last_pos = end;\n-        let span = codemap::mk_sp(start, end);\n-        let snippet = self.snippet(span);\n-\n-        // Trim whitespace from the right hand side of each line.\n-        // Annoyingly, the library functions for splitting by lines etc. are not\n-        // quite right, so we must do it ourselves.\n-        let mut line_start = 0;\n-        let mut last_wspace = None;\n-        for (i, c) in snippet.char_indices() {\n-            if c == '\\n' {\n-                if let Some(lw) = last_wspace {\n-                    self.changes.push_str_span(span, &snippet[line_start..lw]);\n-                    self.changes.push_str_span(span, \"\\n\");\n-                } else {\n-                    self.changes.push_str_span(span, &snippet[line_start..i+1]);\n-                }\n+        assert!(start < end,\n+                \"Request to format inverted span: {:?} to {:?}\",\n+                self.codemap.lookup_char_pos(start),\n+                self.codemap.lookup_char_pos(end));\n \n-                line_start = i + 1;\n-                last_wspace = None;\n-            } else {\n-                if c.is_whitespace() {\n-                    if last_wspace.is_none() {\n-                        last_wspace = Some(i);\n+\n+        self.last_pos = end;\n+        let spans = self.changes.filespans_for_span(start, end);\n+        for (i, &(start, end)) in spans.iter().enumerate() {\n+            let span = codemap::mk_sp(BytePos(start), BytePos(end));\n+            let snippet = self.snippet(span);\n+\n+            // Trim whitespace from the right hand side of each line.\n+            // Annoyingly, the library functions for splitting by lines etc. are not\n+            // quite right, so we must do it ourselves.\n+            let mut line_start = 0;\n+            let mut last_wspace = None;\n+            for (i, c) in snippet.char_indices() {\n+                if c == '\\n' {\n+                    if let Some(lw) = last_wspace {\n+                        self.changes.push_str_span(span, &snippet[line_start..lw]);\n+                        self.changes.push_str_span(span, \"\\n\");\n+                    } else {\n+                        self.changes.push_str_span(span, &snippet[line_start..i+1]);\n                     }\n-                } else {\n+\n+                    line_start = i + 1;\n                     last_wspace = None;\n+                } else {\n+                    if c.is_whitespace() {\n+                        if last_wspace.is_none() {\n+                            last_wspace = Some(i);\n+                        }\n+                    } else {\n+                        last_wspace = None;\n+                    }\n                 }\n             }\n+            if i == spans.len() - 1 {\n+                process_last_snippet(self, &snippet[line_start..], span, &snippet);\n+            } else {\n+                self.changes.push_str_span(span, &snippet[line_start..]);\n+            }\n         }\n-        process_last_snippet(self, &snippet[line_start..], span, &snippet);\n     }\n \n     fn snippet(&self, span: Span) -> String {\n         match self.codemap.span_to_snippet(span) {\n             Ok(s) => s,\n             Err(_) => {\n-                println!(\"Couldn't make snippet for span {:?}\", span);\n+                println!(\"Couldn't make snippet for span {:?}->{:?}\",\n+                         self.codemap.lookup_char_pos(span.lo),\n+                         self.codemap.lookup_char_pos(span.hi));\n                 \"\".to_string()\n             }\n         }"}]}