{"sha": "91b39b5e65ac66f85bc6be749593690417d0373e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYjM5YjVlNjVhYzY2Zjg1YmM2YmU3NDk1OTM2OTA0MTdkMDM3M2U=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-08-18T13:09:21Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-09-05T04:19:07Z"}, "message": "Factor write_ty out of more checking functions", "tree": {"sha": "ad0411d0c555dbc31797574a8d740c649786b54f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad0411d0c555dbc31797574a8d740c649786b54f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91b39b5e65ac66f85bc6be749593690417d0373e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91b39b5e65ac66f85bc6be749593690417d0373e", "html_url": "https://github.com/rust-lang/rust/commit/91b39b5e65ac66f85bc6be749593690417d0373e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91b39b5e65ac66f85bc6be749593690417d0373e/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06ad8fe261aae7b58b70be58f6a3ac6d5d9d2328", "url": "https://api.github.com/repos/rust-lang/rust/commits/06ad8fe261aae7b58b70be58f6a3ac6d5d9d2328", "html_url": "https://github.com/rust-lang/rust/commit/06ad8fe261aae7b58b70be58f6a3ac6d5d9d2328"}], "stats": {"total": 33, "additions": 15, "deletions": 18}, "files": [{"sha": "b69afbf8ff03d8a527977aab67c431fe71bc2f70", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91b39b5e65ac66f85bc6be749593690417d0373e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b39b5e65ac66f85bc6be749593690417d0373e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=91b39b5e65ac66f85bc6be749593690417d0373e", "patch": "@@ -473,8 +473,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             };\n         }\n-\n-        self.write_ty(expr.id, result_ty)\n+        \n+        result_ty\n     }\n }\n \n@@ -545,6 +545,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Type check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n+        self.write_ty(pat.id, pat_ty);\n         self.demand_suptype(pat.span, expected, pat_ty);\n     }\n \n@@ -603,6 +604,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Type check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n+        self.write_ty(pat.id, pat_ty);\n \n         let pat_ty = if pat_ty.is_fn() {\n             // Replace constructor type with constructed type for tuple struct patterns."}, {"sha": "4d5160a4de6b3022116bcd9f9197a77c2a210475", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/91b39b5e65ac66f85bc6be749593690417d0373e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b39b5e65ac66f85bc6be749593690417d0373e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=91b39b5e65ac66f85bc6be749593690417d0373e", "patch": "@@ -2857,7 +2857,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        cond_expr: &'gcx hir::Expr,\n                        then_blk: &'gcx hir::Block,\n                        opt_else_expr: Option<&'gcx hir::Expr>,\n-                       id: ast::NodeId,\n                        sp: Span,\n                        expected: Expectation<'tcx>) -> Ty<'tcx> {\n         let cond_ty = self.check_expr_has_type(cond_expr, self.tcx.types.bool);\n@@ -2909,7 +2908,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                  }))\n         };\n \n-        let if_ty = match result {\n+        match result {\n             Ok(ty) => {\n                 if cond_ty.references_error() {\n                     self.tcx.types.err\n@@ -2921,9 +2920,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.report_mismatched_types(origin, expected, found, e);\n                 self.tcx.types.err\n             }\n-        };\n-\n-        self.write_ty(id, if_ty)\n+        }\n     }\n \n     // Check field access expressions\n@@ -3447,15 +3444,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   self.instantiate_value_path(segments, opt_ty, def, expr.span, id)\n               } else {\n                   self.set_tainted_by_errors();\n-                  self.write_error(id)\n+                  tcx.types.err\n               };\n \n               // We always require that the type provided as the value for\n               // a type parameter outlives the moment of instantiation.\n               self.opt_node_ty_substs(expr.id, |item_substs| {\n                   self.add_wf_bounds(&item_substs.substs, expr);\n               });\n-              ty\n+\n+              self.write_ty(id, ty)\n           }\n           hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n               for output in outputs {\n@@ -3512,8 +3510,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n           }\n           hir::ExprIf(ref cond, ref then_blk, ref opt_else_expr) => {\n-            self.check_then_else(&cond, &then_blk, opt_else_expr.as_ref().map(|e| &**e),\n-                                 id, expr.span, expected)\n+            let if_ty = self.check_then_else(&cond, &then_blk, opt_else_expr.as_ref().map(|e| &**e),\n+                                 expr.span, expected);\n+            self.write_ty(id, if_ty)\n           }\n           hir::ExprWhile(ref cond, ref body, _) => {\n             let cond_ty = self.check_expr_has_type(&cond, tcx.types.bool);\n@@ -3535,7 +3534,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n           }\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n-            self.check_match(expr, &discrim, arms, expected, match_src)\n+            let result_ty = self.check_match(expr, &discrim, arms, expected, match_src);\n+            self.write_ty(expr.id, result_ty)\n           }\n           hir::ExprClosure(capture, ref decl, ref body, _) => {\n               self.check_expr_closure(expr, capture, &decl, &body, expected)\n@@ -3571,16 +3571,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if t_expr.references_error() || t_cast.references_error() {\n                 self.write_error(id)\n             } else {\n-                // Write a type for the whole expression, assuming everything is going\n-                // to work out Ok.\n-                let ty = self.write_ty(id, t_cast);\n-\n                 // Defer other checks until we're done type checking.\n                 let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n                 match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n                     Ok(cast_check) => {\n                         deferred_cast_checks.push(cast_check);\n-                        ty\n+                        self.write_ty(id, t_cast)\n                     }\n                     Err(ErrorReported) => {\n                         self.write_error(id)\n@@ -4328,7 +4324,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n-        self.write_ty(node_id, ty_substituted);\n         self.write_substs(node_id, ty::ItemSubsts {\n             substs: substs\n         });"}]}