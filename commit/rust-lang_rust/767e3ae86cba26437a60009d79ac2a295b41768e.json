{"sha": "767e3ae86cba26437a60009d79ac2a295b41768e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2N2UzYWU4NmNiYTI2NDM3YTYwMDA5ZDc5YWMyYTI5NWI0MTc2OGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-14T17:10:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-14T17:10:54Z"}, "message": "auto merge of #6434 : alexcrichton/rust/less-implicit-vecs, r=bstrie\n\nThis closes #5204 and #6421.\r\n\r\nThis also removes the `vecs_implicitly_copyable` lint (although now reading #6421, this may not be desired?). If we want to leave it in, it at least removes it from the compiler.", "tree": {"sha": "8f3f8634548c02309d281d6cdbfd7b34b7ea8c9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f3f8634548c02309d281d6cdbfd7b34b7ea8c9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/767e3ae86cba26437a60009d79ac2a295b41768e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/767e3ae86cba26437a60009d79ac2a295b41768e", "html_url": "https://github.com/rust-lang/rust/commit/767e3ae86cba26437a60009d79ac2a295b41768e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/767e3ae86cba26437a60009d79ac2a295b41768e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27c228fad7d94a500866696f8c48ef1707a2507b", "url": "https://api.github.com/repos/rust-lang/rust/commits/27c228fad7d94a500866696f8c48ef1707a2507b", "html_url": "https://github.com/rust-lang/rust/commit/27c228fad7d94a500866696f8c48ef1707a2507b"}, {"sha": "ffcc680f9cc26b5b2cb2f453a89dbcf8144f8b9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffcc680f9cc26b5b2cb2f453a89dbcf8144f8b9b", "html_url": "https://github.com/rust-lang/rust/commit/ffcc680f9cc26b5b2cb2f453a89dbcf8144f8b9b"}], "stats": {"total": 1334, "additions": 653, "deletions": 681}, "files": [{"sha": "dedf465b56d8bd7ea9a46a15efd71a9ced22d289", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -10,9 +10,7 @@\n \n #[crate_type = \"bin\"];\n \n-#[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n-#[allow(deprecated_pattern)];\n \n extern mod std(vers = \"0.7-pre\");\n \n@@ -43,8 +41,8 @@ pub mod errors;\n pub fn main() {\n     let args = os::args();\n     let config = parse_config(args);\n-    log_config(config);\n-    run_tests(config);\n+    log_config(&config);\n+    run_tests(&config);\n }\n \n pub fn parse_config(args: ~[~str]) -> config {\n@@ -89,30 +87,31 @@ pub fn parse_config(args: ~[~str]) -> config {\n         run_ignored: getopts::opt_present(matches, ~\"ignored\"),\n         filter:\n              if vec::len(matches.free) > 0u {\n-                 option::Some(matches.free[0])\n+                 option::Some(copy matches.free[0])\n              } else { option::None },\n         logfile: getopts::opt_maybe_str(matches, ~\"logfile\").map(|s| Path(*s)),\n         runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n         rustcflags: getopts::opt_maybe_str(matches, ~\"rustcflags\"),\n         jit: getopts::opt_present(matches, ~\"jit\"),\n         newrt: getopts::opt_present(matches, ~\"newrt\"),\n-        target: opt_str(getopts::opt_maybe_str(matches, ~\"target\")),\n-        adb_path: opt_str(getopts::opt_maybe_str(matches, ~\"adb-path\")),\n-        adb_test_dir: opt_str(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")),\n+        target: opt_str2(getopts::opt_maybe_str(matches, ~\"target\")).to_str(),\n+        adb_path: opt_str2(getopts::opt_maybe_str(matches, ~\"adb-path\")).to_str(),\n+        adb_test_dir:\n+            opt_str2(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")).to_str(),\n         adb_device_status:\n-            if (opt_str(getopts::opt_maybe_str(matches, ~\"target\")) ==\n+            if (opt_str2(getopts::opt_maybe_str(matches, ~\"target\")) ==\n                 ~\"arm-linux-androideabi\") {\n-                if (opt_str(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")) !=\n+                if (opt_str2(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")) !=\n                     ~\"(none)\" &&\n-                    opt_str(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")) !=\n+                    opt_str2(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")) !=\n                     ~\"\") { true }\n                 else { false }\n             } else { false },\n         verbose: getopts::opt_present(matches, ~\"verbose\")\n     }\n }\n \n-pub fn log_config(config: config) {\n+pub fn log_config(config: &config) {\n     let c = config;\n     logv(c, fmt!(\"configuration:\"));\n     logv(c, fmt!(\"compile_lib_path: %s\", config.compile_lib_path));\n@@ -123,9 +122,9 @@ pub fn log_config(config: config) {\n     logv(c, fmt!(\"stage_id: %s\", config.stage_id));\n     logv(c, fmt!(\"mode: %s\", mode_str(config.mode)));\n     logv(c, fmt!(\"run_ignored: %b\", config.run_ignored));\n-    logv(c, fmt!(\"filter: %s\", opt_str(config.filter)));\n-    logv(c, fmt!(\"runtool: %s\", opt_str(config.runtool)));\n-    logv(c, fmt!(\"rustcflags: %s\", opt_str(config.rustcflags)));\n+    logv(c, fmt!(\"filter: %s\", opt_str(&config.filter)));\n+    logv(c, fmt!(\"runtool: %s\", opt_str(&config.runtool)));\n+    logv(c, fmt!(\"rustcflags: %s\", opt_str(&config.rustcflags)));\n     logv(c, fmt!(\"jit: %b\", config.jit));\n     logv(c, fmt!(\"newrt: %b\", config.newrt));\n     logv(c, fmt!(\"target: %s\", config.target));\n@@ -136,8 +135,18 @@ pub fn log_config(config: config) {\n     logv(c, fmt!(\"\\n\"));\n }\n \n-pub fn opt_str(maybestr: Option<~str>) -> ~str {\n-    match maybestr { option::Some(s) => s, option::None => ~\"(none)\" }\n+pub fn opt_str<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+    match *maybestr {\n+        option::None => \"(none)\",\n+        option::Some(ref s) => {\n+            let s: &'a str = *s;\n+            s\n+        }\n+    }\n+}\n+\n+pub fn opt_str2(maybestr: Option<~str>) -> ~str {\n+    match maybestr { None => ~\"(none)\", Some(s) => { s } }\n }\n \n pub fn str_opt(maybestr: ~str) -> Option<~str> {\n@@ -165,16 +174,16 @@ pub fn mode_str(mode: mode) -> ~str {\n     }\n }\n \n-pub fn run_tests(config: config) {\n+pub fn run_tests(config: &config) {\n     let opts = test_opts(config);\n     let tests = make_tests(config);\n     let res = test::run_tests_console(&opts, tests);\n     if !res { fail!(\"Some tests failed\"); }\n }\n \n-pub fn test_opts(config: config) -> test::TestOpts {\n+pub fn test_opts(config: &config) -> test::TestOpts {\n     test::TestOpts {\n-        filter: config.filter,\n+        filter: copy config.filter,\n         run_ignored: config.run_ignored,\n         logfile: copy config.logfile,\n         run_tests: true,\n@@ -184,7 +193,7 @@ pub fn test_opts(config: config) -> test::TestOpts {\n     }\n }\n \n-pub fn make_tests(config: config) -> ~[test::TestDescAndFn] {\n+pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n     debug!(\"making tests from %s\",\n            config.src_base.to_str());\n     let mut tests = ~[];\n@@ -198,7 +207,7 @@ pub fn make_tests(config: config) -> ~[test::TestDescAndFn] {\n     tests\n }\n \n-pub fn is_test(config: config, testfile: &Path) -> bool {\n+pub fn is_test(config: &config, testfile: &Path) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n         match config.mode {\n@@ -221,7 +230,7 @@ pub fn is_test(config: config, testfile: &Path) -> bool {\n     return valid;\n }\n \n-pub fn make_test(config: config, testfile: &Path) -> test::TestDescAndFn {\n+pub fn make_test(config: &config, testfile: &Path) -> test::TestDescAndFn {\n     test::TestDescAndFn {\n         desc: test::TestDesc {\n             name: make_test_name(config, testfile),\n@@ -232,13 +241,15 @@ pub fn make_test(config: config, testfile: &Path) -> test::TestDescAndFn {\n     }\n }\n \n-pub fn make_test_name(config: config, testfile: &Path) -> test::TestName {\n+pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n     test::DynTestName(fmt!(\"[%s] %s\",\n                            mode_str(config.mode),\n                            testfile.to_str()))\n }\n \n-pub fn make_test_closure(config: config, testfile: &Path) -> test::TestFn {\n-    let testfile = testfile.to_str();\n-    test::DynTestFn(|| runtest::run(config, testfile))\n+pub fn make_test_closure(config: &config, testfile: &Path) -> test::TestFn {\n+    use core::cell::Cell;\n+    let config = Cell(copy *config);\n+    let testfile = Cell(testfile.to_str());\n+    test::DynTestFn(|| { runtest::run(config.take(), testfile.take()) })\n }"}, {"sha": "b1f4c9f515bb0fc6280aa361e363d8f4feee7f74", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -52,12 +52,14 @@ pub fn load_props(testfile: &Path) -> TestProps {\n             pp_exact = parse_pp_exact(ln, testfile);\n         }\n \n-        for parse_aux_build(ln).each |ab| {\n-            aux_builds.push(*ab);\n+        match parse_aux_build(ln) {\n+            Some(ab) => { aux_builds.push(ab); }\n+            None => {}\n         }\n \n-        for parse_exec_env(ln).each |ee| {\n-            exec_env.push(*ee);\n+        match parse_exec_env(ln) {\n+            Some(ee) => { exec_env.push(ee); }\n+            None => {}\n         }\n \n         match parse_debugger_cmd(ln) {\n@@ -81,7 +83,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     };\n }\n \n-pub fn is_test_ignored(config: config, testfile: &Path) -> bool {\n+pub fn is_test_ignored(config: &config, testfile: &Path) -> bool {\n     for iter_header(testfile) |ln| {\n         if parse_name_directive(ln, ~\"xfail-test\") { return true; }\n         if parse_name_directive(ln, xfail_target()) { return true; }\n@@ -111,44 +113,47 @@ fn iter_header(testfile: &Path, it: &fn(~str) -> bool) -> bool {\n     return true;\n }\n \n-fn parse_error_pattern(line: ~str) -> Option<~str> {\n+fn parse_error_pattern(line: &str) -> Option<~str> {\n     parse_name_value_directive(line, ~\"error-pattern\")\n }\n \n-fn parse_aux_build(line: ~str) -> Option<~str> {\n+fn parse_aux_build(line: &str) -> Option<~str> {\n     parse_name_value_directive(line, ~\"aux-build\")\n }\n \n-fn parse_compile_flags(line: ~str) -> Option<~str> {\n+fn parse_compile_flags(line: &str) -> Option<~str> {\n     parse_name_value_directive(line, ~\"compile-flags\")\n }\n \n-fn parse_debugger_cmd(line: ~str) -> Option<~str> {\n+fn parse_debugger_cmd(line: &str) -> Option<~str> {\n     parse_name_value_directive(line, ~\"debugger\")\n }\n \n-fn parse_check_line(line: ~str) -> Option<~str> {\n+fn parse_check_line(line: &str) -> Option<~str> {\n     parse_name_value_directive(line, ~\"check\")\n }\n \n-fn parse_exec_env(line: ~str) -> Option<(~str, ~str)> {\n+fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n     do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n         let mut strs = ~[];\n         for str::each_splitn_char(*nv, '=', 1u) |s| { strs.push(s.to_owned()); }\n         match strs.len() {\n-          1u => (strs[0], ~\"\"),\n-          2u => (strs[0], strs[1]),\n+          1u => (strs.pop(), ~\"\"),\n+          2u => {\n+              let end = strs.pop();\n+              (strs.pop(), end)\n+          }\n           n => fail!(\"Expected 1 or 2 strings, not %u\", n)\n         }\n     }\n }\n \n-fn parse_pp_exact(line: ~str, testfile: &Path) -> Option<Path> {\n+fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n     match parse_name_value_directive(line, ~\"pp-exact\") {\n       Some(s) => Some(Path(s)),\n       None => {\n-        if parse_name_directive(line, ~\"pp-exact\") {\n+        if parse_name_directive(line, \"pp-exact\") {\n             Some(testfile.file_path())\n         } else {\n             None\n@@ -157,11 +162,11 @@ fn parse_pp_exact(line: ~str, testfile: &Path) -> Option<Path> {\n     }\n }\n \n-fn parse_name_directive(line: ~str, directive: ~str) -> bool {\n+fn parse_name_directive(line: &str, directive: &str) -> bool {\n     str::contains(line, directive)\n }\n \n-fn parse_name_value_directive(line: ~str,\n+fn parse_name_value_directive(line: &str,\n                               directive: ~str) -> Option<~str> {\n     let keycolon = directive + ~\":\";\n     match str::find_str(line, keycolon) {"}, {"sha": "71efa5596a8ad0d1c0dacdc823acd444fb08c57a", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -14,7 +14,7 @@ use core::run::spawn_process;\n use core::run;\n \n #[cfg(target_os = \"win32\")]\n-fn target_env(lib_path: ~str, prog: ~str) -> ~[(~str,~str)] {\n+fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n \n     let mut env = os::env();\n \n@@ -27,7 +27,7 @@ fn target_env(lib_path: ~str, prog: ~str) -> ~[(~str,~str)] {\n         if k == ~\"PATH\" { (~\"PATH\", v + ~\";\" + lib_path + ~\";\" + aux_path) }\n         else { (k,v) }\n     };\n-    if str::ends_with(prog, ~\"rustc.exe\") {\n+    if str::ends_with(prog, \"rustc.exe\") {\n         env.push((~\"RUST_THREADS\", ~\"1\"));\n     }\n     return env;\n@@ -36,16 +36,16 @@ fn target_env(lib_path: ~str, prog: ~str) -> ~[(~str,~str)] {\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn target_env(_lib_path: ~str, _prog: ~str) -> ~[(~str,~str)] {\n+fn target_env(_lib_path: &str, _prog: &str) -> ~[(~str,~str)] {\n     ~[]\n }\n \n-struct Result {status: int, out: ~str, err: ~str}\n+pub struct Result {status: int, out: ~str, err: ~str}\n \n // FIXME (#2659): This code is duplicated in core::run::program_output\n-pub fn run(lib_path: ~str,\n-           prog: ~str,\n-           args: ~[~str],\n+pub fn run(lib_path: &str,\n+           prog: &str,\n+           args: &[~str],\n            env: ~[(~str, ~str)],\n            input: Option<~str>) -> Result {\n     let pipe_in = os::pipe();"}, {"sha": "73e1e3ee763842ebb5b979b683fcc2c92f2dab81", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 150, "deletions": 163, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -30,40 +30,40 @@ pub fn run(config: config, testfile: ~str) {\n     let props = load_props(&testfile);\n     debug!(\"loaded props\");\n     match config.mode {\n-      mode_compile_fail => run_cfail_test(config, props, &testfile),\n-      mode_run_fail => run_rfail_test(config, props, &testfile),\n-      mode_run_pass => run_rpass_test(config, props, &testfile),\n-      mode_pretty => run_pretty_test(config, props, &testfile),\n-      mode_debug_info => run_debuginfo_test(config, props, &testfile)\n+      mode_compile_fail => run_cfail_test(&config, &props, &testfile),\n+      mode_run_fail => run_rfail_test(&config, &props, &testfile),\n+      mode_run_pass => run_rpass_test(&config, &props, &testfile),\n+      mode_pretty => run_pretty_test(&config, &props, &testfile),\n+      mode_debug_info => run_debuginfo_test(&config, &props, &testfile)\n     }\n }\n \n-fn run_cfail_test(config: config, props: TestProps, testfile: &Path) {\n+fn run_cfail_test(config: &config, props: &TestProps, testfile: &Path) {\n     let ProcRes = compile_test(config, props, testfile);\n \n     if ProcRes.status == 0 {\n-        fatal_ProcRes(~\"compile-fail test compiled successfully!\", ProcRes);\n+        fatal_ProcRes(~\"compile-fail test compiled successfully!\", &ProcRes);\n     }\n \n-    check_correct_failure_status(ProcRes);\n+    check_correct_failure_status(&ProcRes);\n \n     let expected_errors = errors::load_errors(testfile);\n     if !expected_errors.is_empty() {\n         if !props.error_patterns.is_empty() {\n             fatal(~\"both error pattern and expected errors specified\");\n         }\n-        check_expected_errors(expected_errors, testfile, ProcRes);\n+        check_expected_errors(expected_errors, testfile, &ProcRes);\n     } else {\n-        check_error_patterns(props, testfile, ProcRes);\n+        check_error_patterns(props, testfile, &ProcRes);\n     }\n }\n \n-fn run_rfail_test(config: config, props: TestProps, testfile: &Path) {\n+fn run_rfail_test(config: &config, props: &TestProps, testfile: &Path) {\n     let ProcRes = if !config.jit {\n         let ProcRes = compile_test(config, props, testfile);\n \n         if ProcRes.status != 0 {\n-            fatal_ProcRes(~\"compilation failed!\", ProcRes);\n+            fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n         }\n \n         exec_compiled_test(config, props, testfile)\n@@ -74,26 +74,26 @@ fn run_rfail_test(config: config, props: TestProps, testfile: &Path) {\n     // The value our Makefile configures valgrind to return on failure\n     static valgrind_err: int = 100;\n     if ProcRes.status == valgrind_err {\n-        fatal_ProcRes(~\"run-fail test isn't valgrind-clean!\", ProcRes);\n+        fatal_ProcRes(~\"run-fail test isn't valgrind-clean!\", &ProcRes);\n     }\n \n     match config.target {\n \n         ~\"arm-linux-androideabi\" => {\n             if (config.adb_device_status) {\n-                check_correct_failure_status(ProcRes);\n-                check_error_patterns(props, testfile, ProcRes);\n+                check_correct_failure_status(&ProcRes);\n+                check_error_patterns(props, testfile, &ProcRes);\n             }\n         }\n \n         _=> {\n-            check_correct_failure_status(ProcRes);\n-            check_error_patterns(props, testfile, ProcRes);\n+            check_correct_failure_status(&ProcRes);\n+            check_error_patterns(props, testfile, &ProcRes);\n         }\n     }\n }\n \n-fn check_correct_failure_status(ProcRes: ProcRes) {\n+fn check_correct_failure_status(ProcRes: &ProcRes) {\n     // The value the rust runtime returns on failure\n     static rust_err: int = 101;\n     if ProcRes.status != rust_err {\n@@ -104,27 +104,27 @@ fn check_correct_failure_status(ProcRes: ProcRes) {\n     }\n }\n \n-fn run_rpass_test(config: config, props: TestProps, testfile: &Path) {\n+fn run_rpass_test(config: &config, props: &TestProps, testfile: &Path) {\n     if !config.jit {\n         let mut ProcRes = compile_test(config, props, testfile);\n \n         if ProcRes.status != 0 {\n-            fatal_ProcRes(~\"compilation failed!\", ProcRes);\n+            fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n         }\n \n         ProcRes = exec_compiled_test(config, props, testfile);\n \n         if ProcRes.status != 0 {\n-            fatal_ProcRes(~\"test run failed!\", ProcRes);\n+            fatal_ProcRes(~\"test run failed!\", &ProcRes);\n         }\n     } else {\n         let ProcRes = jit_test(config, props, testfile);\n \n-        if ProcRes.status != 0 { fatal_ProcRes(~\"jit failed!\", ProcRes); }\n+        if ProcRes.status != 0 { fatal_ProcRes(~\"jit failed!\", &ProcRes); }\n     }\n }\n \n-fn run_pretty_test(config: config, props: TestProps, testfile: &Path) {\n+fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     if props.pp_exact.is_some() {\n         logv(config, ~\"testing for exact pretty-printing\");\n     } else { logv(config, ~\"testing for converging pretty-printing\"); }\n@@ -137,32 +137,33 @@ fn run_pretty_test(config: config, props: TestProps, testfile: &Path) {\n     let mut round = 0;\n     while round < rounds {\n         logv(config, fmt!(\"pretty-printing round %d\", round));\n-        let ProcRes = print_source(config, testfile, srcs[round]);\n+        let ProcRes = print_source(config, testfile, copy srcs[round]);\n \n         if ProcRes.status != 0 {\n             fatal_ProcRes(fmt!(\"pretty-printing failed in round %d\", round),\n-                          ProcRes);\n+                          &ProcRes);\n         }\n \n-        srcs.push(ProcRes.stdout);\n+        let ProcRes{ stdout, _ } = ProcRes;\n+        srcs.push(stdout);\n         round += 1;\n     }\n \n     let mut expected =\n         match props.pp_exact {\n-          Some(file) => {\n-            let filepath = testfile.dir_path().push_rel(&file);\n+          Some(ref file) => {\n+            let filepath = testfile.dir_path().push_rel(file);\n             io::read_whole_file_str(&filepath).get()\n           }\n-          None => { srcs[vec::len(srcs) - 2u] }\n+          None => { copy srcs[srcs.len() - 2u] }\n         };\n-    let mut actual = srcs[vec::len(srcs) - 1u];\n+    let mut actual = copy srcs[srcs.len() - 1u];\n \n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n         let cr = ~\"\\r\";\n-        actual = str::replace(actual, cr, ~\"\");\n-        expected = str::replace(expected, cr, ~\"\");\n+        actual = str::replace(actual, cr, \"\");\n+        expected = str::replace(expected, cr, \"\");\n     }\n \n     compare_source(expected, actual);\n@@ -171,23 +172,22 @@ fn run_pretty_test(config: config, props: TestProps, testfile: &Path) {\n     let ProcRes = typecheck_source(config, props, testfile, actual);\n \n     if ProcRes.status != 0 {\n-        fatal_ProcRes(~\"pretty-printed source does not typecheck\", ProcRes);\n+        fatal_ProcRes(~\"pretty-printed source does not typecheck\", &ProcRes);\n     }\n \n     return;\n \n-    fn print_source(config: config, testfile: &Path, src: ~str) -> ProcRes {\n+    fn print_source(config: &config, testfile: &Path, src: ~str) -> ProcRes {\n         compose_and_run(config, testfile, make_pp_args(config, testfile),\n                         ~[], config.compile_lib_path, Some(src))\n     }\n \n-    fn make_pp_args(config: config, _testfile: &Path) -> ProcArgs {\n-        let prog = config.rustc_path;\n+    fn make_pp_args(config: &config, _testfile: &Path) -> ProcArgs {\n         let args = ~[~\"-\", ~\"--pretty\", ~\"normal\"];\n-        return ProcArgs {prog: prog.to_str(), args: args};\n+        return ProcArgs {prog: config.rustc_path.to_str(), args: args};\n     }\n \n-    fn compare_source(expected: ~str, actual: ~str) {\n+    fn compare_source(expected: &str, actual: &str) {\n         if expected != actual {\n             error(~\"pretty-printed source does not match expected source\");\n             let msg =\n@@ -207,46 +207,45 @@ actual:\\n\\\n         }\n     }\n \n-    fn typecheck_source(config: config, props: TestProps,\n+    fn typecheck_source(config: &config, props: &TestProps,\n                         testfile: &Path, src: ~str) -> ProcRes {\n-        compose_and_run_compiler(\n-            config, props, testfile,\n-            make_typecheck_args(config, props, testfile),\n-            Some(src))\n+        let args = make_typecheck_args(config, props, testfile);\n+        compose_and_run_compiler(config, props, testfile, args, Some(src))\n     }\n \n-    fn make_typecheck_args(config: config, props: TestProps, testfile: &Path) -> ProcArgs {\n-        let prog = config.rustc_path;\n+    fn make_typecheck_args(config: &config, props: &TestProps, testfile: &Path) -> ProcArgs {\n         let mut args = ~[~\"-\",\n                          ~\"--no-trans\", ~\"--lib\",\n                          ~\"-L\", config.build_base.to_str(),\n                          ~\"-L\",\n                          aux_output_dir_name(config, testfile).to_str()];\n-        args += split_maybe_args(config.rustcflags);\n-        args += split_maybe_args(props.compile_flags);\n-        return ProcArgs {prog: prog.to_str(), args: args};\n+        args += split_maybe_args(&config.rustcflags);\n+        args += split_maybe_args(&props.compile_flags);\n+        return ProcArgs {prog: config.rustc_path.to_str(), args: args};\n     }\n }\n \n-fn run_debuginfo_test(config: config, props: TestProps, testfile: &Path) {\n+fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     // do not optimize debuginfo tests\n-    let config = match config.rustcflags {\n-        Some(flags) => config {\n-            rustcflags: Some(str::replace(flags, ~\"-O\", ~\"\")),\n-            .. config\n+    let mut config = match config.rustcflags {\n+        Some(ref flags) => config {\n+            rustcflags: Some(str::replace(*flags, ~\"-O\", ~\"\")),\n+            .. copy *config\n         },\n-        None => config\n+        None => copy *config\n     };\n+    let config = &mut config;\n+    let cmds = str::connect(props.debugger_cmds, \"\\n\");\n+    let check_lines = copy props.check_lines;\n \n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let mut ProcRes = compile_test(config, props, testfile);\n     if ProcRes.status != 0 {\n-        fatal_ProcRes(~\"compilation failed!\", ProcRes);\n+        fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n     }\n \n     // write debugger script\n-    let script_str = str::append(str::connect(props.debugger_cmds, \"\\n\"),\n-                                 ~\"\\nquit\\n\");\n+    let script_str = str::append(cmds, \"\\nquit\\n\");\n     debug!(\"script_str = %s\", script_str);\n     dump_output_file(config, testfile, script_str, ~\"debugger.script\");\n \n@@ -265,13 +264,13 @@ fn run_debuginfo_test(config: config, props: TestProps, testfile: &Path) {\n         fatal(~\"gdb failed to execute\");\n     }\n \n-    let num_check_lines = vec::len(props.check_lines);\n+    let num_check_lines = vec::len(check_lines);\n     if num_check_lines > 0 {\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n         for str::each_line(ProcRes.stdout) |line| {\n-            if props.check_lines[i].trim() == line.trim() {\n+            if check_lines[i].trim() == line.trim() {\n                 i += 1u;\n             }\n             if i == num_check_lines {\n@@ -281,14 +280,14 @@ fn run_debuginfo_test(config: config, props: TestProps, testfile: &Path) {\n         }\n         if i != num_check_lines {\n             fatal_ProcRes(fmt!(\"line not found in debugger output: %s\"\n-                               props.check_lines[i]), ProcRes);\n+                               check_lines[i]), &ProcRes);\n         }\n     }\n }\n \n-fn check_error_patterns(props: TestProps,\n+fn check_error_patterns(props: &TestProps,\n                         testfile: &Path,\n-                        ProcRes: ProcRes) {\n+                        ProcRes: &ProcRes) {\n     if vec::is_empty(props.error_patterns) {\n         fatal(~\"no error pattern specified in \" + testfile.to_str());\n     }\n@@ -298,18 +297,18 @@ fn check_error_patterns(props: TestProps,\n     }\n \n     let mut next_err_idx = 0u;\n-    let mut next_err_pat = props.error_patterns[next_err_idx];\n+    let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n     for str::each_line(ProcRes.stderr) |line| {\n-        if str::contains(line, next_err_pat) {\n-            debug!(\"found error pattern %s\", next_err_pat);\n+        if str::contains(line, *next_err_pat) {\n+            debug!(\"found error pattern %s\", *next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == vec::len(props.error_patterns) {\n                 debug!(\"found all error patterns\");\n                 done = true;\n                 break;\n             }\n-            next_err_pat = props.error_patterns[next_err_idx];\n+            next_err_pat = &props.error_patterns[next_err_idx];\n         }\n     }\n     if done { return; }\n@@ -330,7 +329,7 @@ fn check_error_patterns(props: TestProps,\n \n fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n                          testfile: &Path,\n-                         ProcRes: ProcRes) {\n+                         ProcRes: &ProcRes) {\n \n     // true if we found the error in question\n     let mut found_flags = vec::from_elem(\n@@ -380,14 +379,14 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n \n     for uint::range(0u, vec::len(found_flags)) |i| {\n         if !found_flags[i] {\n-            let ee = expected_errors[i];\n+            let ee = &expected_errors[i];\n             fatal_ProcRes(fmt!(\"expected %s on line %u not found: %s\",\n                                ee.kind, ee.line, ee.msg), ProcRes);\n         }\n     }\n }\n \n-fn is_compiler_error_or_warning(line: ~str) -> bool {\n+fn is_compiler_error_or_warning(line: &str) -> bool {\n     let mut i = 0u;\n     return\n         scan_until_char(line, ':', &mut i) &&\n@@ -401,11 +400,11 @@ fn is_compiler_error_or_warning(line: ~str) -> bool {\n         scan_char(line, ':', &mut i) &&\n         scan_integer(line, &mut i) &&\n         scan_char(line, ' ', &mut i) &&\n-        (scan_string(line, ~\"error\", &mut i) ||\n-         scan_string(line, ~\"warning\", &mut i));\n+        (scan_string(line, \"error\", &mut i) ||\n+         scan_string(line, \"warning\", &mut i));\n }\n \n-fn scan_until_char(haystack: ~str, needle: char, idx: &mut uint) -> bool {\n+fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n@@ -417,7 +416,7 @@ fn scan_until_char(haystack: ~str, needle: char, idx: &mut uint) -> bool {\n     return true;\n }\n \n-fn scan_char(haystack: ~str, needle: char, idx: &mut uint) -> bool {\n+fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n@@ -429,7 +428,7 @@ fn scan_char(haystack: ~str, needle: char, idx: &mut uint) -> bool {\n     return true;\n }\n \n-fn scan_integer(haystack: ~str, idx: &mut uint) -> bool {\n+fn scan_integer(haystack: &str, idx: &mut uint) -> bool {\n     let mut i = *idx;\n     while i < haystack.len() {\n         let range = str::char_range_at(haystack, i);\n@@ -445,7 +444,7 @@ fn scan_integer(haystack: ~str, idx: &mut uint) -> bool {\n     return true;\n }\n \n-fn scan_string(haystack: ~str, needle: ~str, idx: &mut uint) -> bool {\n+fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n     let mut haystack_i = *idx;\n     let mut needle_i = 0u;\n     while needle_i < needle.len() {\n@@ -466,34 +465,29 @@ struct ProcArgs {prog: ~str, args: ~[~str]}\n \n struct ProcRes {status: int, stdout: ~str, stderr: ~str, cmdline: ~str}\n \n-fn compile_test(config: config, props: TestProps,\n+fn compile_test(config: &config, props: &TestProps,\n                 testfile: &Path) -> ProcRes {\n     compile_test_(config, props, testfile, [])\n }\n \n-fn jit_test(config: config, props: TestProps, testfile: &Path) -> ProcRes {\n+fn jit_test(config: &config, props: &TestProps, testfile: &Path) -> ProcRes {\n     compile_test_(config, props, testfile, [~\"--jit\"])\n }\n \n-fn compile_test_(config: config, props: TestProps,\n+fn compile_test_(config: &config, props: &TestProps,\n                  testfile: &Path, extra_args: &[~str]) -> ProcRes {\n     let link_args = ~[~\"-L\", aux_output_dir_name(config, testfile).to_str()];\n-    compose_and_run_compiler(\n-        config, props, testfile,\n-        make_compile_args(config, props, link_args + extra_args,\n-                          make_exe_name, testfile),\n-        None)\n+    let args = make_compile_args(config, props, link_args + extra_args,\n+                                 make_exe_name, testfile);\n+    compose_and_run_compiler(config, props, testfile, args, None)\n }\n \n-fn exec_compiled_test(config: config, props: TestProps,\n+fn exec_compiled_test(config: &config, props: &TestProps,\n                       testfile: &Path) -> ProcRes {\n \n     // If testing the new runtime then set the RUST_NEWRT env var\n-    let env = if config.newrt {\n-        props.exec_env + ~[(~\"RUST_NEWRT\", ~\"1\")]\n-    } else {\n-        props.exec_env\n-    };\n+    let env = copy props.exec_env;\n+    let env = if config.newrt { env + &[(~\"RUST_NEWRT\", ~\"1\")] } else { env };\n \n     match config.target {\n \n@@ -515,8 +509,8 @@ fn exec_compiled_test(config: config, props: TestProps,\n }\n \n fn compose_and_run_compiler(\n-    config: config,\n-    props: TestProps,\n+    config: &config,\n+    props: &TestProps,\n     testfile: &Path,\n     args: ProcArgs,\n     input: Option<~str>) -> ProcRes {\n@@ -539,7 +533,7 @@ fn compose_and_run_compiler(\n             fatal_ProcRes(\n                 fmt!(\"auxiliary build of %s failed to compile: \",\n                      abs_ab.to_str()),\n-                auxres);\n+                &auxres);\n         }\n \n         match config.target {\n@@ -565,74 +559,66 @@ fn ensure_dir(path: &Path) {\n     }\n }\n \n-fn compose_and_run(config: config, testfile: &Path,\n-                   ProcArgs: ProcArgs,\n+fn compose_and_run(config: &config, testfile: &Path,\n+                   ProcArgs{ args, prog }: ProcArgs,\n                    procenv: ~[(~str, ~str)],\n-                   lib_path: ~str,\n+                   lib_path: &str,\n                    input: Option<~str>) -> ProcRes {\n     return program_output(config, testfile, lib_path,\n-                       ProcArgs.prog, ProcArgs.args, procenv, input);\n+                          prog, args, procenv, input);\n }\n \n-fn make_compile_args(config: config, props: TestProps, extras: ~[~str],\n-                     xform: &fn(config, (&Path)) -> Path,\n+fn make_compile_args(config: &config, props: &TestProps, extras: ~[~str],\n+                     xform: &fn(&config, (&Path)) -> Path,\n                      testfile: &Path) -> ProcArgs {\n-    let prog = config.rustc_path;\n     let mut args = ~[testfile.to_str(),\n                      ~\"-o\", xform(config, testfile).to_str(),\n                      ~\"-L\", config.build_base.to_str()]\n         + extras;\n-    args += split_maybe_args(config.rustcflags);\n-    args += split_maybe_args(props.compile_flags);\n-    return ProcArgs {prog: prog.to_str(), args: args};\n+    args += split_maybe_args(&config.rustcflags);\n+    args += split_maybe_args(&props.compile_flags);\n+    return ProcArgs {prog: config.rustc_path.to_str(), args: args};\n }\n \n-fn make_lib_name(config: config, auxfile: &Path, testfile: &Path) -> Path {\n+fn make_lib_name(config: &config, auxfile: &Path, testfile: &Path) -> Path {\n     // what we return here is not particularly important, as it\n     // happens; rustc ignores everything except for the directory.\n     let auxname = output_testname(auxfile);\n     aux_output_dir_name(config, testfile).push_rel(&auxname)\n }\n \n-fn make_exe_name(config: config, testfile: &Path) -> Path {\n+fn make_exe_name(config: &config, testfile: &Path) -> Path {\n     Path(output_base_name(config, testfile).to_str() +\n             str::to_owned(os::EXE_SUFFIX))\n }\n \n-fn make_run_args(config: config, _props: TestProps, testfile: &Path) ->\n+fn make_run_args(config: &config, _props: &TestProps, testfile: &Path) ->\n    ProcArgs {\n-    let toolargs = {\n-            // If we've got another tool to run under (valgrind),\n-            // then split apart its command\n-            let runtool =\n-                match config.runtool {\n-                  Some(s) => Some(s),\n-                  None => None\n-                };\n-            split_maybe_args(runtool)\n-        };\n+    // If we've got another tool to run under (valgrind),\n+    // then split apart its command\n+    let toolargs = split_maybe_args(&config.runtool);\n \n-    let args = toolargs + ~[make_exe_name(config, testfile).to_str()];\n-    return ProcArgs {prog: args[0],\n-                     args: vec::slice(args, 1, args.len()).to_vec()};\n+    let mut args = toolargs + ~[make_exe_name(config, testfile).to_str()];\n+    let prog = args.shift();\n+    return ProcArgs {prog: prog, args: args};\n }\n \n-fn split_maybe_args(argstr: Option<~str>) -> ~[~str] {\n+fn split_maybe_args(argstr: &Option<~str>) -> ~[~str] {\n     fn rm_whitespace(v: ~[~str]) -> ~[~str] {\n         v.filtered(|s| !str::is_whitespace(*s))\n     }\n \n-    match argstr {\n-        Some(s) => {\n+    match *argstr {\n+        Some(ref s) => {\n             let mut ss = ~[];\n-            for str::each_split_char(s, ' ') |s| { ss.push(s.to_owned()) }\n+            for str::each_split_char(*s, ' ') |s| { ss.push(s.to_owned()) }\n             rm_whitespace(ss)\n         }\n         None => ~[]\n     }\n }\n \n-fn program_output(config: config, testfile: &Path, lib_path: ~str, prog: ~str,\n+fn program_output(config: &config, testfile: &Path, lib_path: &str, prog: ~str,\n                   args: ~[~str], env: ~[(~str, ~str)],\n                   input: Option<~str>) -> ProcRes {\n     let cmdline =\n@@ -641,67 +627,68 @@ fn program_output(config: config, testfile: &Path, lib_path: ~str, prog: ~str,\n             logv(config, fmt!(\"executing %s\", cmdline));\n             cmdline\n         };\n-    let res = procsrv::run(lib_path, prog, args, env, input);\n-    dump_output(config, testfile, res.out, res.err);\n-    return ProcRes {status: res.status,\n-         stdout: res.out,\n-         stderr: res.err,\n+    let procsrv::Result{ out, err, status } =\n+            procsrv::run(lib_path, prog, args, env, input);\n+    dump_output(config, testfile, out, err);\n+    return ProcRes {status: status,\n+         stdout: out,\n+         stderr: err,\n          cmdline: cmdline};\n }\n \n // Linux and mac don't require adjusting the library search path\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn make_cmdline(_libpath: ~str, prog: ~str, args: ~[~str]) -> ~str {\n+fn make_cmdline(_libpath: &str, prog: &str, args: &[~str]) -> ~str {\n     fmt!(\"%s %s\", prog, str::connect(args, ~\" \"))\n }\n \n #[cfg(target_os = \"win32\")]\n-fn make_cmdline(libpath: ~str, prog: ~str, args: ~[~str]) -> ~str {\n+fn make_cmdline(libpath: &str, prog: &str, args: &[~str]) -> ~str {\n     fmt!(\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n          str::connect(args, ~\" \"))\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n-fn lib_path_cmd_prefix(path: ~str) -> ~str {\n+fn lib_path_cmd_prefix(path: &str) -> ~str {\n     fmt!(\"%s=\\\"%s\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n }\n \n-fn dump_output(config: config, testfile: &Path, out: ~str, err: ~str) {\n-    dump_output_file(config, testfile, out, ~\"out\");\n-    dump_output_file(config, testfile, err, ~\"err\");\n+fn dump_output(config: &config, testfile: &Path, out: &str, err: &str) {\n+    dump_output_file(config, testfile, out, \"out\");\n+    dump_output_file(config, testfile, err, \"err\");\n     maybe_dump_to_stdout(config, out, err);\n }\n \n-fn dump_output_file(config: config, testfile: &Path,\n-                    out: ~str, extension: ~str) {\n+fn dump_output_file(config: &config, testfile: &Path,\n+                    out: &str, extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n     let writer =\n         io::file_writer(&outfile, ~[io::Create, io::Truncate]).get();\n     writer.write_str(out);\n }\n \n-fn make_out_name(config: config, testfile: &Path, extension: ~str) -> Path {\n+fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n     output_base_name(config, testfile).with_filetype(extension)\n }\n \n-fn aux_output_dir_name(config: config, testfile: &Path) -> Path {\n+fn aux_output_dir_name(config: &config, testfile: &Path) -> Path {\n     output_base_name(config, testfile).with_filetype(\"libaux\")\n }\n \n fn output_testname(testfile: &Path) -> Path {\n     Path(testfile.filestem().get())\n }\n \n-fn output_base_name(config: config, testfile: &Path) -> Path {\n+fn output_base_name(config: &config, testfile: &Path) -> Path {\n     config.build_base\n         .push_rel(&output_testname(testfile))\n         .with_filetype(config.stage_id)\n }\n \n-fn maybe_dump_to_stdout(config: config, out: ~str, err: ~str) {\n+fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n     if config.verbose {\n         let sep1 = fmt!(\"------%s------------------------------\", ~\"stdout\");\n         let sep2 = fmt!(\"------%s------------------------------\", ~\"stderr\");\n@@ -718,7 +705,7 @@ fn error(err: ~str) { io::stdout().write_line(fmt!(\"\\nerror: %s\", err)); }\n \n fn fatal(err: ~str) -> ! { error(err); fail!(); }\n \n-fn fatal_ProcRes(err: ~str, ProcRes: ProcRes) -> ! {\n+fn fatal_ProcRes(err: ~str, ProcRes: &ProcRes) -> ! {\n     let msg =\n         fmt!(\"\\n\\\n error: %s\\n\\\n@@ -737,21 +724,20 @@ stderr:\\n\\\n     fail!();\n }\n \n-fn _arm_exec_compiled_test(config: config, props: TestProps,\n+fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n                       testfile: &Path) -> ProcRes {\n \n     let args = make_run_args(config, props, testfile);\n-    let cmdline = make_cmdline(~\"\", args.prog, args.args);\n+    let cmdline = make_cmdline(\"\", args.prog, args.args);\n \n     // get bare program string\n     let mut tvec = ~[];\n-    let tstr = args.prog;\n-    for str::each_split_char(tstr, '/') |ts| { tvec.push(ts.to_owned()) }\n+    for str::each_split_char(args.prog, '/') |ts| { tvec.push(ts.to_owned()) }\n     let prog_short = tvec.pop();\n \n     // copy to target\n-    let copy_result = procsrv::run(~\"\", config.adb_path,\n-        ~[~\"push\", args.prog, config.adb_test_dir],\n+    let copy_result = procsrv::run(\"\", config.adb_path,\n+        [~\"push\", copy args.prog, copy config.adb_test_dir],\n         ~[(~\"\",~\"\")], Some(~\"\"));\n \n     if config.verbose {\n@@ -767,7 +753,6 @@ fn _arm_exec_compiled_test(config: config, props: TestProps,\n     // to stdout and stderr separately but to stdout only\n     let mut newargs_out = ~[];\n     let mut newargs_err = ~[];\n-    let subargs = args.args;\n     newargs_out.push(~\"shell\");\n     newargs_err.push(~\"shell\");\n \n@@ -780,7 +765,7 @@ fn _arm_exec_compiled_test(config: config, props: TestProps,\n     newcmd_err.push_str(fmt!(\"LD_LIBRARY_PATH=%s %s/%s\",\n         config.adb_test_dir, config.adb_test_dir, prog_short));\n \n-    for vec::each(subargs) |tv| {\n+    for args.args.each |tv| {\n         newcmd_out.push_str(\" \");\n         newcmd_err.push_str(\" \");\n         newcmd_out.push_str(tv.to_owned());\n@@ -793,26 +778,28 @@ fn _arm_exec_compiled_test(config: config, props: TestProps,\n     newargs_out.push(newcmd_out);\n     newargs_err.push(newcmd_err);\n \n-    let exe_result_out = procsrv::run(~\"\", config.adb_path,\n-        newargs_out, ~[(~\"\",~\"\")], Some(~\"\"));\n-    let exe_result_err = procsrv::run(~\"\", config.adb_path,\n-        newargs_err, ~[(~\"\",~\"\")], Some(~\"\"));\n+    let procsrv::Result{ out: out_out, err: _out_err, status: out_status } =\n+            procsrv::run(~\"\", config.adb_path, newargs_out, ~[(~\"\",~\"\")],\n+                         Some(~\"\"));\n+    let procsrv::Result{ out: err_out, err: _err_err, status: _err_status } =\n+            procsrv::run(~\"\", config.adb_path, newargs_err, ~[(~\"\",~\"\")],\n+                         Some(~\"\"));\n \n-    dump_output(config, testfile, exe_result_out.out, exe_result_err.out);\n+    dump_output(config, testfile, out_out, err_out);\n \n-    match exe_result_err.out {\n-        ~\"\" => ProcRes {status: exe_result_out.status, stdout: exe_result_out.out,\n-            stderr: exe_result_err.out, cmdline: cmdline },\n-        _   => ProcRes {status: 101, stdout: exe_result_out.out,\n-            stderr: exe_result_err.out, cmdline: cmdline }\n+    match err_out {\n+        ~\"\" => ProcRes {status: out_status, stdout: out_out,\n+            stderr: err_out, cmdline: cmdline },\n+        _   => ProcRes {status: 101, stdout: out_out,\n+            stderr: err_out, cmdline: cmdline }\n     }\n }\n \n-fn _dummy_exec_compiled_test(config: config, props: TestProps,\n+fn _dummy_exec_compiled_test(config: &config, props: &TestProps,\n                       testfile: &Path) -> ProcRes {\n \n     let args = make_run_args(config, props, testfile);\n-    let cmdline = make_cmdline(~\"\", args.prog, args.args);\n+    let cmdline = make_cmdline(\"\", args.prog, args.args);\n \n     match config.mode {\n         mode_run_fail => ProcRes {status: 101, stdout: ~\"\",\n@@ -822,15 +809,15 @@ fn _dummy_exec_compiled_test(config: config, props: TestProps,\n     }\n }\n \n-fn _arm_push_aux_shared_library(config: config, testfile: &Path) {\n+fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n     let tstr = aux_output_dir_name(config, testfile).to_str();\n \n     for os::list_dir_path(&Path(tstr)).each |file| {\n \n         if (file.filetype() == Some(~\".so\")) {\n \n             let copy_result = procsrv::run(~\"\", config.adb_path,\n-                ~[~\"push\", file.to_str(), config.adb_test_dir],\n+                ~[~\"push\", file.to_str(), copy config.adb_test_dir],\n                 ~[(~\"\",~\"\")], Some(~\"\"));\n \n             if config.verbose {"}, {"sha": "05e5d902a47c9834399df5c994401a62f134e61b", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -12,15 +12,15 @@ use common::config;\n \n use core::os::getenv;\n \n-pub fn make_new_path(path: ~str) -> ~str {\n+pub fn make_new_path(path: &str) -> ~str {\n \n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n     match getenv(lib_path_env_var()) {\n       Some(curr) => {\n         fmt!(\"%s%s%s\", path, path_div(), curr)\n       }\n-      None => path\n+      None => path.to_str()\n     }\n }\n \n@@ -42,7 +42,7 @@ pub fn path_div() -> ~str { ~\":\" }\n #[cfg(target_os = \"win32\")]\n pub fn path_div() -> ~str { ~\";\" }\n \n-pub fn logv(config: config, s: ~str) {\n+pub fn logv(config: &config, s: ~str) {\n     debug!(\"%s\", s);\n     if config.verbose { io::println(s); }\n }"}, {"sha": "12740a5616b8dd30e589a3c90cbd1ea46563c63d", "filename": "src/etc/extract-tests.py", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Fetc%2Fextract-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Fetc%2Fextract-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fextract-tests.py?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -60,20 +60,16 @@\n             if not re.search(r\"\\bextern mod std\\b\", block):\n                 block = \"extern mod std;\\n\" + block\n             block = \"\"\"#[ forbid(ctypes) ];\n-#[ forbid(deprecated_mode) ];\n #[ forbid(deprecated_pattern) ];\n #[ forbid(implicit_copies) ];\n #[ forbid(non_implicitly_copyable_typarams) ];\n #[ forbid(path_statement) ];\n #[ forbid(type_limits) ];\n #[ forbid(unrecognized_lint) ];\n #[ forbid(unused_imports) ];\n-#[ forbid(vecs_implicitly_copyable) ];\n #[ forbid(while_true) ];\n \n-#[ warn(deprecated_self) ];\n-#[ warn(non_camel_case_types) ];\n-#[ warn(structural_records) ];\\n\n+#[ warn(non_camel_case_types) ];\\n\n \"\"\" + block\n             if xfail:\n                 block = \"// xfail-test\\n\" + block"}, {"sha": "59a715e7f9062f5d4f291396bac6dd32953e4157", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -134,7 +134,7 @@ pub fn stash_expr_if(c: @fn(@ast::expr, test_mode)->bool,\n                      e: @ast::expr,\n                      tm: test_mode) {\n     if c(e, tm) {\n-        *es += ~[e];\n+        *es = *es + ~[e];\n     } else {\n         /* now my indices are wrong :( */\n     }"}, {"sha": "7ea0840880c33c79a86089e0e7b5fdd2efd87a32", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -51,7 +51,6 @@ pub enum lint {\n     implicit_copies,\n     unrecognized_lint,\n     non_implicitly_copyable_typarams,\n-    vecs_implicitly_copyable,\n     deprecated_pattern,\n     non_camel_case_types,\n     type_limits,\n@@ -132,14 +131,6 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: warn\n      }),\n \n-    (\"vecs_implicitly_copyable\",\n-     LintSpec {\n-        lint: vecs_implicitly_copyable,\n-        desc: \"make vecs and strs not implicitly copyable \\\n-              (only checked at top level)\",\n-        default: warn\n-     }),\n-\n     (\"implicit_copies\",\n      LintSpec {\n         lint: implicit_copies,"}, {"sha": "fbb84751d030edbb737273dc50d231ce7ac3854e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -14,8 +14,6 @@ use metadata::csearch;\n use metadata;\n use middle::const_eval;\n use middle::freevars;\n-use middle::lint::{get_lint_level, allow};\n-use middle::lint;\n use middle::resolve::{Impl, MethodInfo};\n use middle::resolve;\n use middle::ty;\n@@ -241,7 +239,6 @@ struct ctxt_ {\n     diag: @syntax::diagnostic::span_handler,\n     interner: @mut HashMap<intern_key, ~t_box_>,\n     next_id: @mut uint,\n-    vecs_implicitly_copyable: bool,\n     legacy_modes: bool,\n     cstore: @mut metadata::cstore::CStore,\n     sess: session::Session,\n@@ -992,14 +989,10 @@ pub fn mk_ctxt(s: session::Session,\n         }\n     }\n \n-    let vecs_implicitly_copyable =\n-        get_lint_level(s.lint_settings.default_settings,\n-                       lint::vecs_implicitly_copyable) == allow;\n     @ctxt_ {\n         diag: s.diagnostic(),\n         interner: @mut HashMap::new(),\n         next_id: @mut primitives::LAST_PRIMITIVE_ID,\n-        vecs_implicitly_copyable: vecs_implicitly_copyable,\n         legacy_modes: legacy_modes,\n         cstore: s.cstore,\n         sess: s,\n@@ -1946,8 +1939,7 @@ pub impl TypeContents {\n     }\n \n     fn nonimplicitly_copyable(cx: ctxt) -> TypeContents {\n-        let base = TypeContents::noncopyable(cx) + TC_OWNED_POINTER;\n-        if cx.vecs_implicitly_copyable {base} else {base + TC_OWNED_VEC}\n+        TypeContents::noncopyable(cx) + TC_OWNED_POINTER + TC_OWNED_VEC\n     }\n \n     fn needs_drop(&self, cx: ctxt) -> bool {"}, {"sha": "dae4bb69c618bc6b8b93a253d35a3fea7055c023", "filename": "src/librustc/util/enum_set.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustc%2Futil%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustc%2Futil%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fenum_set.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -102,7 +102,6 @@ impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n \n #[cfg(test)]\n mod test {\n-    use core;\n     use core::iter;\n     use util::enum_set::*;\n "}, {"sha": "35cbe394b86a3a5a8b13de7173b3eddb307c5df2", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -103,7 +103,7 @@ fn parse_item_attrs<T:Owned>(\n     id: doc::AstId,\n     parse_attrs: ~fn(a: ~[ast::attribute]) -> T) -> T {\n     do astsrv::exec(srv) |ctxt| {\n-        let attrs = match *ctxt.ast_map.get(&id) {\n+        let attrs = match ctxt.ast_map.get_copy(&id) {\n             ast_map::node_item(item, _) => copy item.attrs,\n             ast_map::node_foreign_item(item, _, _, _) => copy item.attrs,\n             _ => fail!(\"parse_item_attrs: not an item\")\n@@ -127,7 +127,7 @@ fn fold_enum(\n             let desc = {\n                 let variant = copy variant;\n                 do astsrv::exec(srv.clone()) |ctxt| {\n-                    match *ctxt.ast_map.get(&doc_id) {\n+                    match ctxt.ast_map.get_copy(&doc_id) {\n                         ast_map::node_item(@ast::item {\n                             node: ast::item_enum(ref enum_definition, _), _\n                         }, _) => {\n@@ -177,7 +177,7 @@ fn merge_method_attrs(\n \n     // Create an assoc list from method name to attributes\n     let attrs: ~[(~str, Option<~str>)] = do astsrv::exec(srv) |ctxt| {\n-        match *ctxt.ast_map.get(&item_id) {\n+        match ctxt.ast_map.get_copy(&item_id) {\n             ast_map::node_item(@ast::item {\n                 node: ast::item_trait(_, _, ref methods), _\n             }, _) => {"}, {"sha": "c7fe29b3296e6303adac38147860089b08c941ae", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -53,7 +53,7 @@ fn is_hidden(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n \n     let id = doc.id;\n     do astsrv::exec(srv) |ctxt| {\n-        let attrs = match *ctxt.ast_map.get(&id) {\n+        let attrs = match ctxt.ast_map.get_copy(&id) {\n           ast_map::node_item(item, _) => copy item.attrs,\n           _ => ~[]\n         };"}, {"sha": "086b5f476016c1eb9e9b644bcd0a422f5cc3ac2b", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -55,7 +55,7 @@ fn fold_impl(\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n     do astsrv::exec(fold.ctxt.clone()) |ctxt| {\n-        match *ctxt.ast_map.get(&doc.item.id) {\n+        match ctxt.ast_map.get_copy(&doc.item.id) {\n             ast_map::node_item(item, _) => {\n                 match item.node {\n                     ast::item_impl(_, None, _, ref methods) => {\n@@ -134,7 +134,7 @@ fn is_visible(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n     let id = doc.id;\n \n     do astsrv::exec(srv) |ctxt| {\n-        match *ctxt.ast_map.get(&id) {\n+        match ctxt.ast_map.get_copy(&id) {\n             ast_map::node_item(item, _) => {\n                 match &item.node {\n                     &ast::item_impl(*) => {"}, {"sha": "bd6777df4afdf3dc045541bad4dc64dd963dcdc8", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -63,7 +63,7 @@ fn fold_fn(\n \n fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n     do astsrv::exec(srv) |ctxt| {\n-        match *ctxt.ast_map.get(&fn_id) {\n+        match ctxt.ast_map.get_copy(&fn_id) {\n             ast_map::node_item(@ast::item {\n                 ident: ident,\n                 node: ast::item_fn(ref decl, purity, _, ref tys, _), _\n@@ -90,7 +90,7 @@ fn fold_const(\n         sig: Some({\n             let doc = copy doc;\n             do astsrv::exec(srv) |ctxt| {\n-                match *ctxt.ast_map.get(&doc.id()) {\n+                match ctxt.ast_map.get_copy(&doc.id()) {\n                     ast_map::node_item(@ast::item {\n                         node: ast::item_const(ty, _), _\n                     }, _) => {\n@@ -115,7 +115,7 @@ fn fold_enum(\n             let sig = {\n                 let variant = copy *variant;\n                 do astsrv::exec(srv.clone()) |ctxt| {\n-                    match *ctxt.ast_map.get(&doc_id) {\n+                    match ctxt.ast_map.get_copy(&doc_id) {\n                         ast_map::node_item(@ast::item {\n                             node: ast::item_enum(ref enum_definition, _), _\n                         }, _) => {\n@@ -125,7 +125,7 @@ fn fold_enum(\n                             }.get();\n \n                             pprust::variant_to_str(\n-                                ast_variant, extract::interner())\n+                                &ast_variant, extract::interner())\n                         }\n                         _ => fail!(\"enum variant not bound to an enum item\")\n                     }\n@@ -170,7 +170,7 @@ fn get_method_sig(\n     method_name: ~str\n ) -> Option<~str> {\n     do astsrv::exec(srv) |ctxt| {\n-        match *ctxt.ast_map.get(&item_id) {\n+        match ctxt.ast_map.get_copy(&item_id) {\n             ast_map::node_item(@ast::item {\n                 node: ast::item_trait(_, _, ref methods), _\n             }, _) => {\n@@ -241,7 +241,7 @@ fn fold_impl(\n     let (bounds, trait_types, self_ty) = {\n         let doc = copy doc;\n         do astsrv::exec(srv) |ctxt| {\n-            match *ctxt.ast_map.get(&doc.id()) {\n+            match ctxt.ast_map.get_copy(&doc.id()) {\n                 ast_map::node_item(@ast::item {\n                     node: ast::item_impl(ref generics, opt_trait_type, self_ty, _), _\n                 }, _) => {\n@@ -280,7 +280,7 @@ fn fold_type(\n         sig: {\n             let doc = copy doc;\n             do astsrv::exec(srv) |ctxt| {\n-                match *ctxt.ast_map.get(&doc.id()) {\n+                match ctxt.ast_map.get_copy(&doc.id()) {\n                     ast_map::node_item(@ast::item {\n                         ident: ident,\n                         node: ast::item_ty(ty, ref params), _\n@@ -312,7 +312,7 @@ fn fold_struct(\n         sig: {\n             let doc = copy doc;\n             do astsrv::exec(srv) |ctxt| {\n-                match *ctxt.ast_map.get(&doc.id()) {\n+                match ctxt.ast_map.get_copy(&doc.id()) {\n                     ast_map::node_item(item, _) => {\n                         let item = strip_struct_extra_stuff(item);\n                         Some(pprust::item_to_str(item,"}, {"sha": "7e2ad69c88e5b8ebe0f2ef995c5cc72ced9d7ede", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -18,14 +18,12 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[allow(vecs_implicitly_copyable,\n-        non_implicitly_copyable_typarams)];\n-\n extern mod std(vers = \"0.7-pre\");\n extern mod rustc(vers = \"0.7-pre\");\n extern mod syntax(vers = \"0.7-pre\");\n \n use core::*;\n+use core::cell::Cell;\n use rustc::driver::{driver, session};\n use syntax::{ast, diagnostic};\n use syntax::ast_util::*;\n@@ -71,8 +69,8 @@ fn with_pp(intr: @token::ident_interner,\n  * because it has to parse the statements and view_items on each\n  * input.\n  */\n-fn record(repl: Repl, blk: @ast::blk, intr: @token::ident_interner) -> Repl {\n-    let view_items = if blk.node.view_items.len() > 0 {\n+fn record(mut repl: Repl, blk: &ast::blk, intr: @token::ident_interner) -> Repl {\n+    if blk.node.view_items.len() > 0 {\n         let new_view_items = do with_pp(intr) |pp, writer| {\n             for blk.node.view_items.each |view_item| {\n                 pprust::print_view_item(pp, *view_item);\n@@ -82,9 +80,9 @@ fn record(repl: Repl, blk: @ast::blk, intr: @token::ident_interner) -> Repl {\n \n         debug!(\"new view items %s\", new_view_items);\n \n-        repl.view_items + \"\\n\" + new_view_items\n-    } else { repl.view_items };\n-    let stmts = if blk.node.stmts.len() > 0 {\n+        repl.view_items = repl.view_items + \"\\n\" + new_view_items\n+    }\n+    if blk.node.stmts.len() > 0 {\n         let new_stmts = do with_pp(intr) |pp, writer| {\n             for blk.node.stmts.each |stmt| {\n                 match stmt.node {\n@@ -105,24 +103,21 @@ fn record(repl: Repl, blk: @ast::blk, intr: @token::ident_interner) -> Repl {\n \n         debug!(\"new stmts %s\", new_stmts);\n \n-        repl.stmts + \"\\n\" + new_stmts\n-    } else { repl.stmts };\n-\n-    Repl{\n-        view_items: view_items,\n-        stmts: stmts,\n-        .. repl\n+        repl.stmts = repl.stmts + \"\\n\" + new_stmts\n     }\n+\n+    return repl;\n }\n \n /// Run an input string in a Repl, returning the new Repl.\n fn run(repl: Repl, input: ~str) -> Repl {\n+    let binary = @copy repl.binary;\n     let options = @session::options {\n         crate_type: session::unknown_crate,\n-        binary: @repl.binary,\n+        binary: binary,\n         addl_lib_search_paths: repl.lib_search_paths.map(|p| Path(*p)),\n         jit: true,\n-        .. *session::basic_options()\n+        .. copy *session::basic_options()\n     };\n \n     debug!(\"building driver input\");\n@@ -138,7 +133,7 @@ fn run(repl: Repl, input: ~str) -> Repl {\n \n     debug!(\"building driver configuration\");\n     let cfg = driver::build_configuration(sess,\n-                                          @repl.binary,\n+                                          binary,\n                                           &wrapped);\n \n     let outputs = driver::build_output_filenames(&wrapped, &None, &None, sess);\n@@ -151,7 +146,7 @@ fn run(repl: Repl, input: ~str) -> Repl {\n \n     for crate.node.module.items.each |item| {\n         match item.node {\n-            ast::item_fn(_, _, _, _, blk) => {\n+            ast::item_fn(_, _, _, _, ref blk) => {\n                 if item.ident == sess.ident_of(\"main\") {\n                     opt = blk.node.expr;\n                 }\n@@ -160,10 +155,11 @@ fn run(repl: Repl, input: ~str) -> Repl {\n         }\n     }\n \n-    let blk = match opt.get().node {\n-        ast::expr_call(_, exprs, _) => {\n+    let e = opt.unwrap();\n+    let blk = match e.node {\n+        ast::expr_call(_, ref exprs, _) => {\n             match exprs[0].node {\n-                ast::expr_block(blk) => @blk,\n+                ast::expr_block(ref blk) => blk,\n                 _ => fail!()\n             }\n         }\n@@ -182,15 +178,16 @@ fn run(repl: Repl, input: ~str) -> Repl {\n fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n     match do task::try {\n         let src_path = Path(src_filename);\n+        let binary = @copy binary;\n         let options = @session::options {\n-            binary: @binary,\n+            binary: binary,\n             addl_lib_search_paths: ~[os::getcwd()],\n-            .. *session::basic_options()\n+            .. copy *session::basic_options()\n         };\n-        let input = driver::file_input(src_path);\n+        let input = driver::file_input(copy src_path);\n         let sess = driver::build_session(options, diagnostic::emit);\n         *sess.building_library = true;\n-        let cfg = driver::build_configuration(sess, @binary, &input);\n+        let cfg = driver::build_configuration(sess, binary, &input);\n         let outputs = driver::build_output_filenames(\n             &input, &None, &None, sess);\n         // If the library already exists and is newer than the source\n@@ -233,7 +230,7 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n \n /// Tries to get a line from rl after outputting a prompt. Returns\n /// None if no input was read (e.g. EOF was reached).\n-fn get_line(use_rl: bool, prompt: ~str) -> Option<~str> {\n+fn get_line(use_rl: bool, prompt: &str) -> Option<~str> {\n     if use_rl {\n         let result = unsafe { rl::read(prompt) };\n \n@@ -280,11 +277,11 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n             for args.each |arg| {\n                 let (crate, filename) =\n                     if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n-                    (arg.substr(0, arg.len() - 3).to_owned(), *arg)\n+                    (arg.substr(0, arg.len() - 3).to_owned(), copy *arg)\n                 } else {\n-                    (*arg, arg + ~\".rs\")\n+                    (copy *arg, arg + \".rs\")\n                 };\n-                match compile_crate(filename, repl.binary) {\n+                match compile_crate(filename, copy repl.binary) {\n                     Some(_) => loaded_crates.push(crate),\n                     None => { }\n                 }\n@@ -311,7 +308,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n             let mut multiline_cmd = ~\"\";\n             let mut end_multiline = false;\n             while (!end_multiline) {\n-                match get_line(use_rl, ~\"rusti| \") {\n+                match get_line(use_rl, \"rusti| \") {\n                     None => fail!(\"unterminated multiline command :{ .. :}\"),\n                     Some(line) => {\n                         if str::trim(line) == ~\":}\" {\n@@ -334,14 +331,14 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n             use_rl: bool)\n     -> Option<Repl> {\n-    if line.starts_with(~\":\") {\n+    if line.starts_with(\":\") {\n         let full = line.substr(1, line.len() - 1);\n         let mut split = ~[];\n         for str::each_word(full) |word| { split.push(word.to_owned()) }\n         let len = split.len();\n \n         if len > 0 {\n-            let cmd = split[0];\n+            let cmd = copy split[0];\n \n             if !cmd.is_empty() {\n                 let args = if len > 1 {\n@@ -361,9 +358,10 @@ fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n         }\n     }\n \n-    let r = *repl;\n+    let line = Cell(line);\n+    let r = Cell(copy *repl);\n     let result = do task::try {\n-        run(r, line)\n+        run(r.take(), line.take())\n     };\n \n     if result.is_ok() {\n@@ -378,7 +376,7 @@ pub fn main() {\n     let out = io::stdout();\n     let mut repl = Repl {\n         prompt: ~\"rusti> \",\n-        binary: args[0],\n+        binary: copy args[0],\n         running: true,\n         view_items: ~\"\",\n         lib_search_paths: ~[],"}, {"sha": "a47d4ba5329ca31ce45f54b2b04e7bbe61f84724", "filename": "src/librusti/wrapper.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrusti%2Fwrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrusti%2Fwrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fwrapper.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -13,13 +13,15 @@\n #[allow(implicit_copies)];\n #[allow(managed_heap_memory)];\n #[allow(non_camel_case_types)];\n-#[allow(non_implicitly_copyable_typarams)];\n #[allow(owned_heap_memory)];\n #[allow(path_statement)];\n #[allow(unrecognized_lint)];\n #[allow(unused_imports)];\n-#[allow(vecs_implicitly_copyable)];\n #[allow(while_true)];\n+#[allow(dead_assignment)];\n+#[allow(unused_variable)];\n+#[allow(unused_unsafe)];\n+#[allow(unused_mut)];\n \n extern mod std;\n "}, {"sha": "477a7af45504bb7250c5c245dbef35e84c937751", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -55,21 +55,21 @@ pub fn normalize(p: ~Path) -> ~Path {\n \n /// True if there's a directory in <workspace> with\n /// pkgid's short name\n-pub fn workspace_contains_package_id(pkgid: PkgId, workspace: &Path) -> bool {\n+pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n     let pkgpath = workspace.push(\"src\").push(pkgid.path.to_str());\n     os::path_is_dir(&pkgpath)\n }\n \n /// Return the directory for <pkgid>'s source files in <workspace>.\n /// Doesn't check that it exists.\n-pub fn pkgid_src_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     let result = workspace.push(\"src\");\n     result.push(pkgid.path.to_str())\n }\n \n /// Figure out what the executable name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_executable_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path> {\n+pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let mut result = workspace.push(\"build\");\n     result = result.push_rel(&pkgid.path);\n     // should use a target-specific subdirectory\n@@ -87,7 +87,7 @@ pub fn built_executable_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<P\n \n /// Figure out what the library name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_library_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path> {\n+pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let mut result = workspace.push(\"build\");\n     result = result.push_rel(&pkgid.path);\n     // should use a target-specific subdirectory\n@@ -159,31 +159,31 @@ pub fn built_library_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path\n /// Returns the executable that would be installed for <pkgid>\n /// in <workspace>\n /// As a side effect, creates the bin-dir if it doesn't exist\n-pub fn target_executable_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn target_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Main)\n }\n \n \n /// Returns the executable that would be installed for <pkgid>\n /// in <workspace>\n /// As a side effect, creates the bin-dir if it doesn't exist\n-pub fn target_library_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Lib)\n }\n \n /// Returns the test executable that would be installed for <pkgid>\n /// in <workspace>\n-pub fn target_test_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn target_test_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Test)\n }\n \n /// Returns the bench executable that would be installed for <pkgid>\n /// in <workspace>\n-pub fn target_bench_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn target_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Bench)\n }\n \n-fn target_file_in_workspace(pkgid: PkgId, workspace: &Path,\n+fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n                             what: OutputType) -> Path {\n     use conditions::bad_path::cond;\n \n@@ -193,7 +193,8 @@ fn target_file_in_workspace(pkgid: PkgId, workspace: &Path,\n     let result = workspace.push(subdir);\n     if create_dir {\n         if !os::path_exists(&result) && !mkdir_recursive(&result, u_rwx) {\n-            cond.raise((result, fmt!(\"I couldn't create the %s dir\", subdir)));\n+            cond.raise((copy result,\n+                        fmt!(\"I couldn't create the %s dir\", subdir)));\n         }\n     }\n     mk_output_path(what, pkgid.path.to_str(), result)\n@@ -202,13 +203,13 @@ fn target_file_in_workspace(pkgid: PkgId, workspace: &Path,\n \n /// Return the directory for <pkgid>'s build artifacts in <workspace>.\n /// Creates it if it doesn't exist.\n-pub fn build_pkg_id_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     use conditions::bad_path::cond;\n \n     let mut result = workspace.push(\"build\");\n     // n.b. Should actually use a target-specific\n     // subdirectory of build/\n-    result = result.push(normalize(~pkgid.path).to_str());\n+    result = result.push(normalize(~copy pkgid.path).to_str());\n     if os::path_exists(&result) || os::mkdir_recursive(&result, u_rwx) {\n         result\n     }"}, {"sha": "884f0a73589dc1334241f45e0df752661d52f7c0", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -17,8 +17,6 @@\n \n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n-#[allow(vecs_implicitly_copyable,\n-        non_implicitly_copyable_typarams)];\n \n extern mod std(vers = \"0.7-pre\");\n extern mod rustc(vers = \"0.7-pre\");\n@@ -43,6 +41,7 @@ use context::Ctx;\n mod conditions;\n mod context;\n mod path_util;\n+#[cfg(test)]\n mod tests;\n mod util;\n mod workspace;\n@@ -52,9 +51,9 @@ pub mod usage;\n /// A PkgScript represents user-supplied custom logic for\n /// special build hooks. This only exists for packages with\n /// an explicit package script.\n-struct PkgScript {\n+struct PkgScript<'self> {\n     /// Uniquely identifies this package\n-    id: PkgId,\n+    id: &'self PkgId,\n     // Used to have this field:    deps: ~[(~str, Option<~str>)]\n     // but I think it shouldn't be stored here\n     /// The contents of the package script: either a file path,\n@@ -71,24 +70,24 @@ struct PkgScript {\n     build_dir: Path\n }\n \n-impl PkgScript {\n+impl<'self> PkgScript<'self> {\n     /// Given the path name for a package script\n     /// and a package ID, parse the package script into\n     /// a PkgScript that we can then execute\n-    fn parse(script: Path, workspace: &Path, id: PkgId) -> PkgScript {\n+    fn parse<'a>(script: Path, workspace: &Path, id: &'a PkgId) -> PkgScript<'a> {\n         // Get the executable name that was invoked\n-        let binary = os::args()[0];\n+        let binary = @copy os::args()[0];\n         // Build the rustc session data structures to pass\n         // to the compiler\n         let options = @session::options {\n-            binary: @binary,\n+            binary: binary,\n             crate_type: session::bin_crate,\n-            .. *session::basic_options()\n+            .. copy *session::basic_options()\n         };\n         let input = driver::file_input(script);\n         let sess = driver::build_session(options, diagnostic::emit);\n-        let cfg = driver::build_configuration(sess, @binary, &input);\n-        let (crate, _) = driver::compile_upto(sess, cfg, &input,\n+        let cfg = driver::build_configuration(sess, binary, &input);\n+        let (crate, _) = driver::compile_upto(sess, copy cfg, &input,\n                                               driver::cu_parse, None);\n         let work_dir = build_pkg_id_in_workspace(id, workspace);\n \n@@ -123,10 +122,10 @@ impl PkgScript {\n                 let root = r.pop().pop().pop().pop(); // :-\\\n                 debug!(\"Root is %s, calling compile_rest\", root.to_str());\n                 let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n-                util::compile_crate_from_input(self.input, self.id,\n-                                               Some(self.build_dir),\n+                util::compile_crate_from_input(&self.input, self.id,\n+                                               Some(copy self.build_dir),\n                                                sess, Some(crate),\n-                                               exe, os::args()[0],\n+                                               &exe, @copy os::args()[0],\n                                                driver::cu_everything);\n                 debug!(\"Running program: %s %s %s\", exe.to_str(), root.to_str(), what);\n                 let status = run::run_program(exe.to_str(), ~[root.to_str(), what]);\n@@ -188,9 +187,9 @@ impl Ctx {\n                 }\n                 // The package id is presumed to be the first command-line\n                 // argument\n-                let pkgid = PkgId::new(args[0]);\n-                for pkg_parent_workspaces(pkgid) |workspace| {\n-                    self.build(workspace, pkgid);\n+                let pkgid = PkgId::new(copy args[0]);\n+                for pkg_parent_workspaces(&pkgid) |workspace| {\n+                    self.build(workspace, &pkgid);\n                 }\n             }\n             ~\"clean\" => {\n@@ -199,16 +198,16 @@ impl Ctx {\n                 }\n                 // The package id is presumed to be the first command-line\n                 // argument\n-                let pkgid = PkgId::new(args[0]);\n+                let pkgid = PkgId::new(copy args[0]);\n                 let cwd = os::getcwd();\n-                self.clean(&cwd, pkgid); // tjc: should use workspace, not cwd\n+                self.clean(&cwd, &pkgid); // tjc: should use workspace, not cwd\n             }\n             ~\"do\" => {\n                 if args.len() < 2 {\n                     return usage::do_cmd();\n                 }\n \n-                self.do_cmd(args[0], args[1]);\n+                self.do_cmd(copy args[0], copy args[1]);\n             }\n             ~\"info\" => {\n                 self.info();\n@@ -221,16 +220,16 @@ impl Ctx {\n                 // The package id is presumed to be the first command-line\n                 // argument\n                 let pkgid = PkgId::new(args[0]);\n-                for pkg_parent_workspaces(pkgid) |workspace| {\n-                    self.install(workspace, pkgid);\n+                for pkg_parent_workspaces(&pkgid) |workspace| {\n+                    self.install(workspace, &pkgid);\n                 }\n             }\n             ~\"prefer\" => {\n                 if args.len() < 1 {\n                     return usage::uninstall();\n                 }\n \n-                let (name, vers) = sep_name_vers(args[0]);\n+                let (name, vers) = sep_name_vers(copy args[0]);\n \n                 self.prefer(name.get(), vers);\n             }\n@@ -242,7 +241,7 @@ impl Ctx {\n                     return usage::uninstall();\n                 }\n \n-                let (name, vers) = sep_name_vers(args[0]);\n+                let (name, vers) = sep_name_vers(copy args[0]);\n \n                 self.uninstall(name.get(), vers);\n             }\n@@ -251,26 +250,26 @@ impl Ctx {\n                     return usage::uninstall();\n                 }\n \n-                let (name, vers) = sep_name_vers(args[0]);\n+                let (name, vers) = sep_name_vers(copy args[0]);\n \n                 self.unprefer(name.get(), vers);\n             }\n             _ => fail!(\"reached an unhandled command\")\n         }\n     }\n \n-    fn do_cmd(&self, _cmd: ~str, _pkgname: ~str)  {\n+    fn do_cmd(&self, _cmd: &str, _pkgname: &str)  {\n         // stub\n         fail!(\"`do` not yet implemented\");\n     }\n \n-    fn build(&self, workspace: &Path, pkgid: PkgId) {\n+    fn build(&self, workspace: &Path, pkgid: &PkgId) {\n         let src_dir   = pkgid_src_in_workspace(pkgid, workspace);\n         let build_dir = build_pkg_id_in_workspace(pkgid, workspace);\n         debug!(\"Destination dir = %s\", build_dir.to_str());\n \n         // Create the package source\n-        let mut src = PkgSrc::new(&workspace.push(\"src\"), &build_dir, &pkgid);\n+        let mut src = PkgSrc::new(&workspace.push(\"src\"), &build_dir, pkgid);\n         debug!(\"Package src = %?\", src);\n \n         // Is there custom build logic? If so, use it\n@@ -311,7 +310,7 @@ impl Ctx {\n \n     }\n \n-    fn clean(&self, workspace: &Path, id: PkgId)  {\n+    fn clean(&self, workspace: &Path, id: &PkgId)  {\n         // Could also support a custom build hook in the pkg\n         // script for cleaning files rustpkg doesn't know about.\n         // Do something reasonable for now\n@@ -332,7 +331,7 @@ impl Ctx {\n         fail!(\"info not yet implemented\");\n     }\n \n-    fn install(&self, workspace: &Path, id: PkgId)  {\n+    fn install(&self, workspace: &Path, id: &PkgId)  {\n         use conditions::copy_failed::cond;\n \n         // Should use RUST_PATH in the future.\n@@ -348,13 +347,13 @@ impl Ctx {\n         for maybe_executable.each |exec| {\n             debug!(\"Copying: %s -> %s\", exec.to_str(), target_exec.to_str());\n             if !os::copy_file(exec, &target_exec) {\n-                cond.raise((*exec, target_exec));\n+                cond.raise((copy *exec, copy target_exec));\n             }\n         }\n         for maybe_library.each |lib| {\n             debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());\n             if !os::copy_file(lib, &target_lib) {\n-                cond.raise((*lib, target_lib));\n+                cond.raise((copy *lib, copy target_lib));\n             }\n         }\n     }\n@@ -387,7 +386,7 @@ impl Ctx {\n         }\n     }\n \n-    fn fetch_git(&self, dir: &Path, url: ~str, target: Option<~str>)  {\n+    fn fetch_git(&self, dir: &Path, url: ~str, mut target: Option<~str>)  {\n         util::note(fmt!(\"fetching from %s using git\", url));\n \n         // Git can't clone into a non-empty directory\n@@ -405,7 +404,7 @@ impl Ctx {\n             do util::temp_change_dir(dir) {\n                 success = run::program_output(~\"git\",\n                                               ~[~\"checkout\",\n-                                                target.get()]).status != 0\n+                                                target.swap_unwrap()]).status != 0\n             }\n \n             if !success {\n@@ -525,7 +524,7 @@ pub struct Listener {\n }\n \n pub fn run(listeners: ~[Listener]) {\n-    let rcmd = os::args()[2];\n+    let rcmd = copy os::args()[2];\n     let mut found = false;\n \n     for listeners.each |listener| {\n@@ -652,12 +651,12 @@ impl PkgSrc {\n         // tjc: Rather than erroring out, need to try downloading the\n         // contents of the path to a local directory (#5679)\n         if !os::path_exists(&dir) {\n-            cond.raise((self.id, ~\"missing package dir\"));\n+            cond.raise((copy self.id, ~\"missing package dir\"));\n         }\n \n         if !os::path_is_dir(&dir) {\n-            cond.raise((self.id, ~\"supplied path for package dir is a \\\n-                                   non-directory\"));\n+            cond.raise((copy self.id, ~\"supplied path for package dir is a \\\n+                                        non-directory\"));\n         }\n \n         dir\n@@ -681,7 +680,7 @@ impl PkgSrc {\n     /// Requires that dashes in p have already been normalized to\n     /// underscores\n     fn stem_matches(&self, p: &Path) -> bool {\n-        let self_id = normalize(~self.id.path).filestem();\n+        let self_id = normalize(~copy self.id.path).filestem();\n         if self_id == p.filestem() {\n             return true;\n         }\n@@ -737,7 +736,7 @@ impl PkgSrc {\n             util::note(~\"Couldn't infer any crates to build.\\n\\\n                          Try naming a crate `main.rs`, `lib.rs`, \\\n                          `test.rs`, or `bench.rs`.\");\n-            cond.raise(self.id);\n+            cond.raise(copy self.id);\n         }\n \n         debug!(\"found %u libs, %u mains, %u tests, %u benchs\",\n@@ -752,15 +751,15 @@ impl PkgSrc {\n                     dst_dir: &Path,\n                     src_dir: &Path,\n                     crates: &[Crate],\n-                    cfgs: ~[~str],\n+                    cfgs: &[~str],\n                     test: bool, crate_type: crate_type) {\n \n         for crates.each |&crate| {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n             util::note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n             util::note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));\n \n-            let result = util::compile_crate(maybe_sysroot, self.id, path,\n+            let result = util::compile_crate(maybe_sysroot, &self.id, path,\n                                      dst_dir,\n                                      crate.flags,\n                                      crate.cfgs + cfgs,"}, {"sha": "7f0bfa250865e809e13cd26dfdb1590d9e2055d8", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -77,7 +77,6 @@ fn is_rwx(p: &Path) -> bool {\n     }\n }\n \n-#[cfg(test)]\n fn test_sysroot() -> Path {\n     // Totally gross hack but it's just for test cases.\n     // Infer the sysroot from the exe name and tack \"stage2\"\n@@ -107,19 +106,19 @@ fn test_install_valid() {\n     let temp_pkg_id = fake_pkg();\n     let temp_workspace = mk_temp_workspace(&temp_pkg_id.path);\n     // should have test, bench, lib, and main\n-    ctxt.install(&temp_workspace, temp_pkg_id);\n+    ctxt.install(&temp_workspace, &temp_pkg_id);\n     // Check that all files exist\n-    let exec = target_executable_in_workspace(temp_pkg_id, &temp_workspace);\n+    let exec = target_executable_in_workspace(&temp_pkg_id, &temp_workspace);\n     debug!(\"exec = %s\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n-    let lib = target_library_in_workspace(temp_pkg_id, &temp_workspace);\n+    let lib = target_library_in_workspace(&temp_pkg_id, &temp_workspace);\n     debug!(\"lib = %s\", lib.to_str());\n     assert!(os::path_exists(&lib));\n     assert!(is_rwx(&lib));\n     // And that the test and bench executables aren't installed\n-    assert!(!os::path_exists(&target_test_in_workspace(temp_pkg_id, &temp_workspace)));\n-    let bench = target_bench_in_workspace(temp_pkg_id, &temp_workspace);\n+    assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, &temp_workspace)));\n+    let bench = target_bench_in_workspace(&temp_pkg_id, &temp_workspace);\n     debug!(\"bench = %s\", bench.to_str());\n     assert!(!os::path_exists(&bench));\n }\n@@ -140,7 +139,7 @@ fn test_install_invalid() {\n         do cond.trap(|_| {\n             error_occurred = true;\n         }).in {\n-            ctxt.install(&temp_workspace, pkgid);\n+            ctxt.install(&temp_workspace, &pkgid);\n         }\n     }\n     assert!(error_occurred && error1_occurred);\n@@ -155,19 +154,19 @@ fn test_install_url() {\n     let temp_pkg_id = remote_pkg();\n     let temp_workspace = mk_temp_workspace(&temp_pkg_id.path);\n     // should have test, bench, lib, and main\n-    ctxt.install(&temp_workspace, temp_pkg_id);\n+    ctxt.install(&temp_workspace, &temp_pkg_id);\n     // Check that all files exist\n-    let exec = target_executable_in_workspace(temp_pkg_id, &temp_workspace);\n+    let exec = target_executable_in_workspace(&temp_pkg_id, &temp_workspace);\n     debug!(\"exec = %s\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n-    let lib = target_library_in_workspace(temp_pkg_id, &temp_workspace);\n+    let lib = target_library_in_workspace(&temp_pkg_id, &temp_workspace);\n     debug!(\"lib = %s\", lib.to_str());\n     assert!(os::path_exists(&lib));\n     assert!(is_rwx(&lib));\n     // And that the test and bench executables aren't installed\n-    assert!(!os::path_exists(&target_test_in_workspace(temp_pkg_id, &temp_workspace)));\n-    let bench = target_bench_in_workspace(temp_pkg_id, &temp_workspace);\n+    assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, &temp_workspace)));\n+    let bench = target_bench_in_workspace(&temp_pkg_id, &temp_workspace);\n     debug!(\"bench = %s\", bench.to_str());\n     assert!(!os::path_exists(&bench));\n-}\n\\ No newline at end of file\n+}"}, {"sha": "e9c4b7fde5548f150587f8a4a237a55a9fdbd5b1", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 45, "deletions": 51, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -23,11 +23,16 @@ use syntax::codemap::{dummy_sp, spanned, dummy_spanned};\n use syntax::ext::base::{mk_ctxt, ext_ctxt};\n use syntax::ext::build;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n-use syntax::ast::{meta_name_value, meta_list, attribute, crate_};\n+use syntax::ast::{meta_name_value, meta_list, attribute};\n use syntax::attr::{mk_attr};\n use rustc::back::link::output_type_exe;\n use rustc::driver::session::{lib_crate, unknown_crate, crate_type};\n \n+static Commands: &'static [&'static str] =\n+    &[\"build\", \"clean\", \"do\", \"info\", \"install\", \"prefer\", \"test\", \"uninstall\",\n+      \"unprefer\"];\n+\n+\n pub type ExitCode = int; // For now\n \n /// A version is either an exact revision,\n@@ -41,28 +46,28 @@ impl Ord for Version {\n     fn lt(&self, other: &Version) -> bool {\n         match (self, other) {\n             (&ExactRevision(f1), &ExactRevision(f2)) => f1 < f2,\n-            (&SemVersion(v1), &SemVersion(v2)) => v1 < v2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 < v2,\n             _ => false // incomparable, really\n         }\n     }\n     fn le(&self, other: &Version) -> bool {\n         match (self, other) {\n             (&ExactRevision(f1), &ExactRevision(f2)) => f1 <= f2,\n-            (&SemVersion(v1), &SemVersion(v2)) => v1 <= v2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 <= v2,\n             _ => false // incomparable, really\n         }\n     }\n     fn ge(&self, other: &Version) -> bool {\n         match (self, other) {\n             (&ExactRevision(f1), &ExactRevision(f2)) => f1 > f2,\n-            (&SemVersion(v1), &SemVersion(v2)) => v1 > v2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 > v2,\n             _ => false // incomparable, really\n         }\n     }\n     fn gt(&self, other: &Version) -> bool {\n         match (self, other) {\n             (&ExactRevision(f1), &ExactRevision(f2)) => f1 >= f2,\n-            (&SemVersion(v1), &SemVersion(v2)) => v1 >= v2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 >= v2,\n             _ => false // incomparable, really\n         }\n     }\n@@ -72,8 +77,8 @@ impl Ord for Version {\n impl ToStr for Version {\n     fn to_str(&self) -> ~str {\n         match *self {\n-            ExactRevision(n) => n.to_str(),\n-            SemVersion(v) => v.to_str()\n+            ExactRevision(ref n) => n.to_str(),\n+            SemVersion(ref v) => v.to_str()\n         }\n     }\n }\n@@ -147,11 +152,8 @@ pub fn root() -> Path {\n     }\n }\n \n-pub fn is_cmd(cmd: ~str) -> bool {\n-    let cmds = &[~\"build\", ~\"clean\", ~\"do\", ~\"info\", ~\"install\", ~\"prefer\",\n-                 ~\"test\", ~\"uninstall\", ~\"unprefer\"];\n-\n-    vec::contains(cmds, &cmd)\n+pub fn is_cmd(cmd: &str) -> bool {\n+    Commands.any(|&c| c == cmd)\n }\n \n pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n@@ -220,7 +222,7 @@ fn fold_item(ctx: @mut ReadyCtx,\n \n         for attrs.each |attr| {\n             match attr.node.value.node {\n-                ast::meta_list(_, mis) => {\n+                ast::meta_list(_, ref mis) => {\n                     for mis.each |mi| {\n                         match mi.node {\n                             ast::meta_word(cmd) => cmds.push(copy *cmd),\n@@ -266,15 +268,14 @@ fn add_pkg_module(ctx: @mut ReadyCtx, m: ast::_mod) -> ast::_mod {\n }\n \n fn mk_listener_vec(ctx: @mut ReadyCtx) -> @ast::expr {\n-    let fns = ctx.fns;\n-    let descs = do fns.map |listener| {\n-        mk_listener_rec(ctx, *listener)\n+    let descs = do ctx.fns.map |listener| {\n+        mk_listener_rec(ctx, listener)\n     };\n     let ext_cx = ctx.ext_cx;\n     build::mk_slice_vec_e(ext_cx, dummy_sp(), descs)\n }\n \n-fn mk_listener_rec(ctx: @mut ReadyCtx, listener: ListenerFn) -> @ast::expr {\n+fn mk_listener_rec(ctx: @mut ReadyCtx, listener: &ListenerFn) -> @ast::expr {\n     let span = listener.span;\n     let cmds = do listener.cmds.map |&cmd| {\n         let ext_cx = ctx.ext_cx;\n@@ -437,11 +438,11 @@ pub fn add_pkg(pkg: &Pkg) -> bool {\n \n // FIXME (#4432): Use workcache to only compile when needed\n pub fn compile_input(sysroot: Option<@Path>,\n-                     pkg_id: PkgId,\n+                     pkg_id: &PkgId,\n                      in_file: &Path,\n                      out_dir: &Path,\n-                     flags: ~[~str],\n-                     cfgs: ~[~str],\n+                     flags: &[~str],\n+                     cfgs: &[~str],\n                      opt: bool,\n                      test: bool,\n                      crate_type: session::crate_type) -> bool {\n@@ -456,7 +457,7 @@ pub fn compile_input(sysroot: Option<@Path>,\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n-    let binary = os::args()[0];\n+    let binary = @copy os::args()[0];\n     let building_library = match crate_type {\n         lib_crate | unknown_crate => true,\n         _ => false\n@@ -485,32 +486,27 @@ pub fn compile_input(sysroot: Option<@Path>,\n                           + flags\n                           + cfgs.flat_map(|&c| { ~[~\"--cfg\", c] }),\n                           driver::optgroups()).get();\n-    let options = @session::options {\n+    let mut options = session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: test,\n         maybe_sysroot: sysroot,\n         addl_lib_search_paths: ~[copy *out_dir],\n-        .. *driver::build_session_options(@binary, &matches, diagnostic::emit)\n+        // output_type should be conditional\n+        output_type: output_type_exe, // Use this to get a library? That's weird\n+        .. copy *driver::build_session_options(binary, &matches, diagnostic::emit)\n     };\n-    let mut crate_cfg = options.cfg;\n \n     for cfgs.each |&cfg| {\n-        crate_cfg.push(attr::mk_word_item(@cfg));\n+        options.cfg.push(attr::mk_word_item(@cfg));\n     }\n \n-    let options = @session::options {\n-        cfg: vec::append(options.cfg, crate_cfg),\n-        // output_type should be conditional\n-        output_type: output_type_exe, // Use this to get a library? That's weird\n-        .. *options\n-    };\n-    let sess = driver::build_session(options, diagnostic::emit);\n+    let sess = driver::build_session(@options, diagnostic::emit);\n \n     debug!(\"calling compile_crate_from_input, out_dir = %s,\n            building_library = %?\", out_dir.to_str(), sess.building_library);\n-    let _ = compile_crate_from_input(input, pkg_id, Some(*out_dir), sess, None,\n-                                     out_file, binary,\n+    let _ = compile_crate_from_input(&input, pkg_id, Some(copy *out_dir), sess,\n+                                     None, &out_file, binary,\n                                      driver::cu_everything);\n     true\n }\n@@ -520,18 +516,19 @@ pub fn compile_input(sysroot: Option<@Path>,\n // If crate_opt is present, then finish compilation. If it's None, then\n // call compile_upto and return the crate\n // also, too many arguments\n-pub fn compile_crate_from_input(input: driver::input,\n-                                pkg_id: PkgId,\n+pub fn compile_crate_from_input(input: &driver::input,\n+                                pkg_id: &PkgId,\n                                 build_dir_opt: Option<Path>,\n                                 sess: session::Session,\n                                 crate_opt: Option<@ast::crate>,\n-                                out_file: Path,\n-                                binary: ~str,\n+                                out_file: &Path,\n+                                binary: @~str,\n                                 what: driver::compile_upto) -> @ast::crate {\n     debug!(\"Calling build_output_filenames with %? and %s\", build_dir_opt, out_file.to_str());\n-    let outputs = driver::build_output_filenames(&input, &build_dir_opt, &Some(out_file), sess);\n+    let outputs = driver::build_output_filenames(input, &build_dir_opt,\n+                                                 &Some(copy *out_file), sess);\n     debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n-    let cfg = driver::build_configuration(sess, @binary, &input);\n+    let cfg = driver::build_configuration(sess, binary, input);\n     match crate_opt {\n         Some(c) => {\n             debug!(\"Calling compile_rest, outputs = %?\", outputs);\n@@ -541,7 +538,7 @@ pub fn compile_crate_from_input(input: driver::input,\n         }\n         None => {\n             debug!(\"Calling compile_upto, outputs = %?\", outputs);\n-            let (crate, _) = driver::compile_upto(sess, cfg, &input,\n+            let (crate, _) = driver::compile_upto(sess, copy cfg, input,\n                                                   driver::cu_parse, Some(outputs));\n \n             debug!(\"About to inject link_meta info...\");\n@@ -552,7 +549,8 @@ pub fn compile_crate_from_input(input: driver::input,\n             debug!(\"How many attrs? %?\", attr::find_linkage_metas(crate.node.attrs).len());\n \n             if attr::find_linkage_metas(crate.node.attrs).is_empty() {\n-                crate_to_use = add_attrs(*crate, ~[mk_attr(@dummy_spanned(meta_list(@~\"link\",\n+                crate_to_use = add_attrs(copy *crate,\n+                    ~[mk_attr(@dummy_spanned(meta_list(@~\"link\",\n                                                   // change PkgId to have a <shortname> field?\n                     ~[@dummy_spanned(meta_name_value(@~\"name\",\n                                                     mk_string_lit(@pkg_id.path.filestem().get()))),\n@@ -578,20 +576,16 @@ pub fn exe_suffix() -> ~str { ~\"\" }\n \n /// Returns a copy of crate `c` with attributes `attrs` added to its\n /// attributes\n-fn add_attrs(c: ast::crate, new_attrs: ~[attribute]) -> @ast::crate {\n-    @spanned {\n-        node: crate_ {\n-            attrs: c.node.attrs + new_attrs, ..c.node\n-        },\n-        span: c.span\n-    }\n+fn add_attrs(mut c: ast::crate, new_attrs: ~[attribute]) -> @ast::crate {\n+    c.node.attrs += new_attrs;\n+    @c\n }\n \n // Called by build_crates\n // FIXME (#4432): Use workcache to only compile when needed\n-pub fn compile_crate(sysroot: Option<@Path>, pkg_id: PkgId,\n+pub fn compile_crate(sysroot: Option<@Path>, pkg_id: &PkgId,\n                      crate: &Path, dir: &Path,\n-                     flags: ~[~str], cfgs: ~[~str], opt: bool,\n+                     flags: &[~str], cfgs: &[~str], opt: bool,\n                      test: bool, crate_type: crate_type) -> bool {\n     debug!(\"compile_crate: crate=%s, dir=%s\", crate.to_str(), dir.to_str());\n     debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());"}, {"sha": "8941dbfd20eabf6565724e408b2746250a37c25c", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -14,7 +14,7 @@ use path_util::{rust_path, workspace_contains_package_id};\n use util::PkgId;\n use core::path::Path;\n \n-pub fn pkg_parent_workspaces(pkgid: PkgId, action: &fn(&Path) -> bool) -> bool {\n+pub fn pkg_parent_workspaces(pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n     // this package ID\n     let workspaces = rust_path().filtered(|ws|"}, {"sha": "d15a8fc0136d49be9b03cf602b5503bd62a31f89", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -28,7 +28,7 @@ pub mod rustrt {\n }\n \n /// Add a line to history\n-pub unsafe fn add_history(line: ~str) -> bool {\n+pub unsafe fn add_history(line: &str) -> bool {\n     do str::as_c_str(line) |buf| {\n         rustrt::linenoiseHistoryAdd(buf) == 1 as c_int\n     }\n@@ -40,21 +40,21 @@ pub unsafe fn set_history_max_len(len: int) -> bool {\n }\n \n /// Save line history to a file\n-pub unsafe fn save_history(file: ~str) -> bool {\n+pub unsafe fn save_history(file: &str) -> bool {\n     do str::as_c_str(file) |buf| {\n         rustrt::linenoiseHistorySave(buf) == 1 as c_int\n     }\n }\n \n /// Load line history from a file\n-pub unsafe fn load_history(file: ~str) -> bool {\n+pub unsafe fn load_history(file: &str) -> bool {\n     do str::as_c_str(file) |buf| {\n         rustrt::linenoiseHistoryLoad(buf) == 1 as c_int\n     }\n }\n \n /// Print out a prompt and then wait for input and return it\n-pub unsafe fn read(prompt: ~str) -> Option<~str> {\n+pub unsafe fn read(prompt: &str) -> Option<~str> {\n     do str::as_c_str(prompt) |buf| {\n         let line = rustrt::linenoise(buf);\n "}, {"sha": "e9f15c0a8f5ceda338e0846cff844bd49a6319c0", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -60,12 +60,12 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: ~str, itr: @ident_interner)\n     str::connect(strs, sep)\n }\n \n-pub fn path_ident_to_str(p: path, i: ident, itr: @ident_interner) -> ~str {\n-    if vec::is_empty(p) {\n+pub fn path_ident_to_str(p: &path, i: ident, itr: @ident_interner) -> ~str {\n+    if vec::is_empty(*p) {\n         //FIXME /* FIXME (#2543) */ copy *i\n         copy *itr.get(i)\n     } else {\n-        fmt!(\"%s::%s\", path_to_str(p, itr), *itr.get(i))\n+        fmt!(\"%s::%s\", path_to_str(*p, itr), *itr.get(i))\n     }\n }\n \n@@ -338,7 +338,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n         fmt!(\"unknown node (id=%d)\", id)\n       }\n       Some(&node_item(item, path)) => {\n-        let path_str = path_ident_to_str(*path, item.ident, itr);\n+        let path_str = path_ident_to_str(path, item.ident, itr);\n         let item_str = match item.node {\n           item_const(*) => ~\"const\",\n           item_fn(*) => ~\"fn\",\n@@ -355,7 +355,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       }\n       Some(&node_foreign_item(item, abi, _, path)) => {\n         fmt!(\"foreign item %s with abi %? (id=%?)\",\n-             path_ident_to_str(*path, item.ident, itr), abi, id)\n+             path_ident_to_str(path, item.ident, itr), abi, id)\n       }\n       Some(&node_method(m, _, path)) => {\n         fmt!(\"method %s in %s (id=%?)\","}, {"sha": "212ceadf912c8a8288c136c3eb23e5ea3a601b7d", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -679,19 +679,19 @@ mod test {\n     #[test] fn xorpush_test () {\n         let mut s = ~[];\n         xorPush(&mut s,14);\n-        assert_eq!(s,~[14]);\n+        assert_eq!(copy s,~[14]);\n         xorPush(&mut s,14);\n-        assert_eq!(s,~[]);\n+        assert_eq!(copy s,~[]);\n         xorPush(&mut s,14);\n-        assert_eq!(s,~[14]);\n+        assert_eq!(copy s,~[14]);\n         xorPush(&mut s,15);\n-        assert_eq!(s,~[14,15]);\n+        assert_eq!(copy s,~[14,15]);\n         xorPush (&mut s,16);\n-        assert_eq! (s,~[14,15,16]);\n+        assert_eq!(copy s,~[14,15,16]);\n         xorPush (&mut s,16);\n-        assert_eq! (s,~[14,15]);\n+        assert_eq!(copy s,~[14,15]);\n         xorPush (&mut s,15);\n-        assert_eq! (s,~[14]);\n+        assert_eq!(copy s,~[14]);\n     }\n \n     // convert a list of uints to an @~[ident]\n@@ -746,7 +746,7 @@ mod test {\n         let mut t = mk_sctable();\n \n         let test_sc = ~[M(3),R(id(101,0),14),M(9)];\n-        assert_eq!(unfold_test_sc(test_sc,empty_ctxt,&mut t),3);\n+        assert_eq!(unfold_test_sc(copy test_sc,empty_ctxt,&mut t),3);\n         assert_eq!(t[1],Mark(9,0));\n         assert_eq!(t[2],Rename(id(101,0),14,1));\n         assert_eq!(t[3],Mark(3,2));"}, {"sha": "6b2aa2416f8c73db12e00f092e7955a3d4bcbf8d", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -184,7 +184,7 @@ fn diagnosticcolor(lvl: level) -> u8 {\n     }\n }\n \n-fn print_diagnostic(topic: ~str, lvl: level, msg: &str) {\n+fn print_diagnostic(topic: &str, lvl: level, msg: &str) {\n     let use_color = term::color_supported() &&\n         io::stderr().get_type() == io::Screen;\n     if !topic.is_empty() {"}, {"sha": "97c5797cf57d24e9237bd81ada5b0e3a6b94ceaa", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -119,13 +119,13 @@ pub fn expand_asm(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n                 cons = str::connect(clobs, \",\");\n             }\n             Options => {\n-                let option = *p.parse_str();\n+                let option = p.parse_str();\n \n-                if option == ~\"volatile\" {\n+                if \"volatile\" == *option {\n                     volatile = true;\n-                } else if option == ~\"alignstack\" {\n+                } else if \"alignstack\" == *option {\n                     alignstack = true;\n-                } else if option == ~\"intel\" {\n+                } else if \"intel\" == *option {\n                     dialect = ast::asm_intel;\n                 }\n "}, {"sha": "ac86d266d736b8ee00486b72946bd2d91d5c6dba", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -836,7 +836,7 @@ fn mk_struct_deser_impl(\n     cx: @ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    fields: ~[@ast::struct_field],\n+    fields: &[@ast::struct_field],\n     generics: &ast::Generics\n ) -> @ast::item {\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n@@ -1120,7 +1120,7 @@ fn mk_enum_deser_body(\n     ext_cx: @ext_ctxt,\n     span: span,\n     name: ast::ident,\n-    variants: ~[ast::variant]\n+    variants: &[ast::variant]\n ) -> @ast::expr {\n     let expr_arm_names = build::mk_base_vec_e(\n         ext_cx,"}, {"sha": "605ba65b51a9df5ee7fe471cb1ec27d88e8970f9", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -509,7 +509,7 @@ pub fn mk_unreachable(cx: @ext_ctxt, span: span) -> @ast::expr {\n         ],\n         ~[\n             mk_base_str(cx, span, ~\"internal error: entered unreachable code\"),\n-            mk_base_str(cx, span, loc.file.name),\n+            mk_base_str(cx, span, copy loc.file.name),\n             mk_uint(cx, span, loc.line),\n         ]\n     )"}, {"sha": "2151e9529c415b85cf7f2c699457cf4dcf4b8b87", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -60,19 +60,19 @@ fn cs_clone(cx: @ext_ctxt, span: span,\n         build::mk_method_call(cx, span, field, clone_ident, ~[]);\n \n     match *substr.fields {\n-        Struct(af) => {\n+        Struct(ref af) => {\n             ctor_ident = ~[ substr.type_ident ];\n             all_fields = af;\n         }\n-        EnumMatching(_, variant, af) => {\n+        EnumMatching(_, variant, ref af) => {\n             ctor_ident = ~[ variant.node.name ];\n             all_fields = af;\n         },\n         EnumNonMatching(*) => cx.span_bug(span, \"Non-matching enum variants in `deriving(Clone)`\"),\n         StaticEnum(*) | StaticStruct(*) => cx.span_bug(span, \"Static method in `deriving(Clone)`\")\n     }\n \n-    match all_fields {\n+    match *all_fields {\n         [(None, _, _), .. _] => {\n             // enum-like\n             let subcalls = all_fields.map(|&(_, self_f, _)| subcall(self_f));"}, {"sha": "cdb9f620301489653fe7dedf1461e566d5b696ab", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -65,8 +65,6 @@ fn cs_ord(less: bool, equal: bool,\n     let false_blk_expr = build::mk_block(cx, span,\n                                          ~[], ~[],\n                                          Some(build::mk_bool(cx, span, false)));\n-    let true_blk = build::mk_simple_block(cx, span,\n-                                          build::mk_bool(cx, span, true));\n     let base = build::mk_bool(cx, span, equal);\n \n     cs_fold(\n@@ -108,6 +106,8 @@ fn cs_ord(less: bool, equal: bool,\n \n             let cmp = build::mk_method_call(cx, span,\n                                             self_f, binop, other_fs.to_owned());\n+            let true_blk = build::mk_simple_block(cx, span,\n+                                                  build::mk_bool(cx, span, true));\n             let if_ = expr_if(cmp, true_blk, Some(elseif));\n \n             build::mk_expr(cx, span, if_)"}, {"sha": "5ec4e028454fb88c721c8db6b4c9dd36dec37100", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -55,15 +55,16 @@ pub fn ordering_const(cx: @ext_ctxt, span: span, cnst: Ordering) -> @expr {\n \n pub fn cs_cmp(cx: @ext_ctxt, span: span,\n               substr: &Substructure) -> @expr {\n-    let lexical_ord = ~[cx.ident_of(\"core\"),\n-                        cx.ident_of(\"cmp\"),\n-                        cx.ident_of(\"lexical_ordering\")];\n \n     cs_same_method_fold(\n         // foldr (possibly) nests the matches in lexical_ordering better\n         false,\n         |cx, span, old, new| {\n-            build::mk_call_global(cx, span, lexical_ord, ~[old, new])\n+            build::mk_call_global(cx, span,\n+                                  ~[cx.ident_of(\"core\"),\n+                                    cx.ident_of(\"cmp\"),\n+                                    cx.ident_of(\"lexical_ordering\")],\n+                                  ~[old, new])\n         },\n         ordering_const(cx, span, Equal),\n         |cx, span, list, _| {"}, {"sha": "be2cc6dd25e06653b7e1950d83860caeb10674a8", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 63, "deletions": 62, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -259,14 +259,14 @@ pub enum SubstructureFields<'self> {\n     fields: `(field ident, self, [others])`, where the field ident is\n     only non-`None` in the case of a struct variant.\n     */\n-    EnumMatching(uint, ast::variant, ~[(Option<ident>, @expr, ~[@expr])]),\n+    EnumMatching(uint, &'self ast::variant, ~[(Option<ident>, @expr, ~[@expr])]),\n \n     /**\n     non-matching variants of the enum, [(variant index, ast::variant,\n     [field ident, fields])] (i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n-    EnumNonMatching(~[(uint, ast::variant, ~[(Option<ident>, @expr)])]),\n+    EnumNonMatching(&'self [(uint, ast::variant, ~[(Option<ident>, @expr)])]),\n \n     /// A static method where Self is a struct\n     StaticStruct(&'self ast::struct_def, Either<uint, ~[ident]>),\n@@ -290,7 +290,7 @@ representing each variant: (variant index, ast::variant instance,\n */\n pub type EnumNonMatchFunc<'self> =\n     &'self fn(@ext_ctxt, span,\n-              ~[(uint, ast::variant,\n+              &[(uint, ast::variant,\n                  ~[(Option<ident>, @expr)])],\n               &[@expr]) -> @expr;\n \n@@ -416,8 +416,9 @@ impl<'self> MethodDef<'self> {\n         let mut nonstatic = false;\n \n         match self.self_ty {\n-            Some(self_ptr) => {\n-                let (self_expr, self_ty) = ty::get_explicit_self(cx, span, self_ptr);\n+            Some(ref self_ptr) => {\n+                let (self_expr, self_ty) = ty::get_explicit_self(cx, span,\n+                                                                 self_ptr);\n \n                 ast_self_ty = self_ty;\n                 self_args.push(self_expr);\n@@ -616,9 +617,10 @@ impl<'self> MethodDef<'self> {\n                                self_args: &[@expr],\n                                nonself_args: &[@expr])\n         -> @expr {\n+        let mut matches = ~[];\n         self.build_enum_match(cx, span, enum_def, type_ident,\n                               self_args, nonself_args,\n-                              None, ~[], 0)\n+                              None, &mut matches, 0)\n     }\n \n \n@@ -650,58 +652,57 @@ impl<'self> MethodDef<'self> {\n                         self_args: &[@expr],\n                         nonself_args: &[@expr],\n                         matching: Option<uint>,\n-                        matches_so_far: ~[(uint, ast::variant,\n-                                           ~[(Option<ident>, @expr)])],\n+                        matches_so_far: &mut ~[(uint, ast::variant,\n+                                              ~[(Option<ident>, @expr)])],\n                         match_count: uint) -> @expr {\n         if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n             // expression at the bottom of the match tree\n-            match matches_so_far {\n-                [] => cx.span_bug(span, ~\"no self match on an enum in generic `deriving`\"),\n-                _ => {\n-                    // we currently have a vec of vecs, where each\n-                    // subvec is the fields of one of the arguments,\n-                    // but if the variants all match, we want this as\n-                    // vec of tuples, where each tuple represents a\n-                    // field.\n-\n-                    let substructure;\n-\n-                    // most arms don't have matching variants, so do a\n-                    // quick check to see if they match (even though\n-                    // this means iterating twice) instead of being\n-                    // optimistic and doing a pile of allocations etc.\n-                    match matching {\n-                        Some(variant_index) => {\n-                            // `ref` inside let matches is buggy. Causes havoc wih rusc.\n-                            // let (variant_index, ref self_vec) = matches_so_far[0];\n-                            let (variant, self_vec) = match matches_so_far[0] {\n-                                (_, v, ref s) => (v, s)\n-                            };\n-\n-                            let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n-\n-                            for matches_so_far.tail().each |&(_, _, other_fields)| {\n-                                for other_fields.eachi |i, &(_, other_field)| {\n-                                    enum_matching_fields[i].push(other_field);\n-                                }\n-                            }\n-                            let field_tuples =\n-                                do vec::map_zip(*self_vec,\n-                                             enum_matching_fields) |&(id, self_f), &other| {\n-                                (id, self_f, other)\n-                            };\n-                            substructure = EnumMatching(variant_index, variant, field_tuples);\n-                        }\n-                        None => {\n-                            substructure = EnumNonMatching(matches_so_far);\n+            if matches_so_far.len() == 0 {\n+                cx.span_bug(span, ~\"no self match on an enum in generic \\\n+                                    `deriving`\");\n+            }\n+            // we currently have a vec of vecs, where each\n+            // subvec is the fields of one of the arguments,\n+            // but if the variants all match, we want this as\n+            // vec of tuples, where each tuple represents a\n+            // field.\n+\n+            let substructure;\n+\n+            // most arms don't have matching variants, so do a\n+            // quick check to see if they match (even though\n+            // this means iterating twice) instead of being\n+            // optimistic and doing a pile of allocations etc.\n+            match matching {\n+                Some(variant_index) => {\n+                    // `ref` inside let matches is buggy. Causes havoc wih rusc.\n+                    // let (variant_index, ref self_vec) = matches_so_far[0];\n+                    let (variant, self_vec) = match matches_so_far[0] {\n+                        (_, ref v, ref s) => (v, s)\n+                    };\n+\n+                    let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n+\n+                    for matches_so_far.tail().each |&(_, _, other_fields)| {\n+                        for other_fields.eachi |i, &(_, other_field)| {\n+                            enum_matching_fields[i].push(other_field);\n                         }\n                     }\n-                    self.call_substructure_method(cx, span, type_ident,\n-                                                  self_args, nonself_args,\n-                                                  &substructure)\n+                    let field_tuples =\n+                        do vec::map_zip(*self_vec,\n+                                     enum_matching_fields) |&(id, self_f), &other| {\n+                        (id, self_f, other)\n+                    };\n+                    substructure = EnumMatching(variant_index, variant, field_tuples);\n+                }\n+                None => {\n+                    substructure = EnumNonMatching(*matches_so_far);\n                 }\n             }\n+            self.call_substructure_method(cx, span, type_ident,\n+                                          self_args, nonself_args,\n+                                          &substructure)\n \n         } else {  // there are still matches to create\n             let current_match_str = if match_count == 0 {\n@@ -712,9 +713,6 @@ impl<'self> MethodDef<'self> {\n \n             let mut arms = ~[];\n \n-            // this is used as a stack\n-            let mut matches_so_far = matches_so_far;\n-\n             // the code for nonmatching variants only matters when\n             // we've seen at least one other variant already\n             if self.const_nonmatching && match_count > 0 {\n@@ -732,7 +730,7 @@ impl<'self> MethodDef<'self> {\n                                                                     current_match_str,\n                                                                     ast::m_imm);\n \n-                matches_so_far.push((index, *variant, idents));\n+                matches_so_far.push((index, /*bad*/ copy *variant, idents));\n                 let arm_expr = self.build_enum_match(cx, span,\n                                                      enum_def,\n                                                      type_ident,\n@@ -744,9 +742,10 @@ impl<'self> MethodDef<'self> {\n                 arms.push(build::mk_arm(cx, span, ~[ pattern ], arm_expr));\n \n                 if enum_def.variants.len() > 1 {\n+                    let e = &EnumNonMatching(&[]);\n                     let wild_expr = self.call_substructure_method(cx, span, type_ident,\n                                                                   self_args, nonself_args,\n-                                                                  &EnumNonMatching(~[]));\n+                                                                  e);\n                     let wild_arm = build::mk_arm(cx, span,\n                                                  ~[ build::mk_pat_wild(cx, span) ],\n                                                  wild_expr);\n@@ -760,7 +759,7 @@ impl<'self> MethodDef<'self> {\n                                                                        current_match_str,\n                                                                        ast::m_imm);\n \n-                    matches_so_far.push((index, *variant, idents));\n+                    matches_so_far.push((index, /*bad*/ copy *variant, idents));\n                     let new_matching =\n                         match matching {\n                             _ if match_count == 0 => Some(index),\n@@ -850,7 +849,7 @@ pub fn cs_fold(use_foldl: bool,\n                cx: @ext_ctxt, span: span,\n                substructure: &Substructure) -> @expr {\n     match *substructure.fields {\n-        EnumMatching(_, _, all_fields) | Struct(all_fields) => {\n+        EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n                 do all_fields.foldl(base) |&old, &(_, self_f, other_fs)| {\n                     f(cx, span, old, self_f, other_fs)\n@@ -861,8 +860,9 @@ pub fn cs_fold(use_foldl: bool,\n                 }\n             }\n         },\n-        EnumNonMatching(all_enums) => enum_nonmatch_f(cx, span,\n-                                                      all_enums, substructure.nonself_args),\n+        EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, span,\n+                                                          *all_enums,\n+                                                          substructure.nonself_args),\n         StaticEnum(*) | StaticStruct(*) => {\n             cx.span_bug(span, \"Static function in `deriving`\")\n         }\n@@ -885,7 +885,7 @@ pub fn cs_same_method(f: &fn(@ext_ctxt, span, ~[@expr]) -> @expr,\n                       cx: @ext_ctxt, span: span,\n                       substructure: &Substructure) -> @expr {\n     match *substructure.fields {\n-        EnumMatching(_, _, all_fields) | Struct(all_fields) => {\n+        EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n             let called = do all_fields.map |&(_, self_field, other_fields)| {\n                 build::mk_method_call(cx, span,\n@@ -896,8 +896,9 @@ pub fn cs_same_method(f: &fn(@ext_ctxt, span, ~[@expr]) -> @expr,\n \n             f(cx, span, called)\n         },\n-        EnumNonMatching(all_enums) => enum_nonmatch_f(cx, span,\n-                                                      all_enums, substructure.nonself_args),\n+        EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, span,\n+                                                          *all_enums,\n+                                                          substructure.nonself_args),\n         StaticEnum(*) | StaticStruct(*) => {\n             cx.span_bug(span, \"Static function in `deriving`\")\n         }"}, {"sha": "ba1f4e3ebb208a574641a68bde45c9fc5c04b899", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -59,15 +59,15 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n     use ast::{meta_list, meta_name_value, meta_word};\n \n     match mitem.node {\n-        meta_name_value(_, l) => {\n+        meta_name_value(_, ref l) => {\n             cx.span_err(l.span, ~\"unexpected value in `deriving`\");\n             in_items\n         }\n         meta_word(_) | meta_list(_, []) => {\n             cx.span_warn(mitem.span, ~\"empty trait list in `deriving`\");\n             in_items\n         }\n-        meta_list(_, titems) => {\n+        meta_list(_, ref titems) => {\n             do titems.foldr(in_items) |&titem, in_items| {\n                 match titem.node {\n                     meta_name_value(tname, _) |\n@@ -92,9 +92,9 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n \n                             ~\"ToStr\" => expand!(to_str::expand_deriving_to_str),\n \n-                            tname => {\n+                            ref tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\\n-                                    `deriving` trait: `%s`\", tname));\n+                                    `deriving` trait: `%s`\", *tname));\n                                 in_items\n                             }\n                         }"}, {"sha": "768ac7458d673c7ad905d250c03a04df7bf92b25", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -63,7 +63,7 @@ pub impl Path {\n     fn to_path(&self, cx: @ext_ctxt, span: span,\n                self_ty: ident, self_generics: &Generics) -> @ast::Path {\n         let idents = self.path.map(|s| cx.ident_of(*s) );\n-        let lt = mk_lifetime(cx, span, self.lifetime);\n+        let lt = mk_lifetime(cx, span, &self.lifetime);\n         let tys = self.params.map(|t| t.to_ty(cx, span, self_ty, self_generics));\n \n         if self.global {\n@@ -106,9 +106,9 @@ pub fn nil_ty() -> Ty {\n     Tuple(~[])\n }\n \n-fn mk_lifetime(cx: @ext_ctxt, span: span, lt: Option<~str>) -> Option<@ast::Lifetime> {\n-    match lt {\n-        Some(s) => Some(@build::mk_lifetime(cx, span, cx.ident_of(s))),\n+fn mk_lifetime(cx: @ext_ctxt, span: span, lt: &Option<~str>) -> Option<@ast::Lifetime> {\n+    match *lt {\n+        Some(ref s) => Some(@build::mk_lifetime(cx, span, cx.ident_of(*s))),\n         None => None\n     }\n }\n@@ -123,10 +123,10 @@ pub impl Ty {\n                     Owned => {\n                         build::mk_ty_uniq(cx, span, raw_ty)\n                     }\n-                    Managed(copy mutbl) => {\n+                    Managed(mutbl) => {\n                         build::mk_ty_box(cx, span, raw_ty, mutbl)\n                     }\n-                    Borrowed(copy lt, copy mutbl) => {\n+                    Borrowed(ref lt, mutbl) => {\n                         let lt = mk_lifetime(cx, span, lt);\n                         build::mk_ty_rptr(cx, span, raw_ty, lt, mutbl)\n                     }\n@@ -216,20 +216,20 @@ pub impl LifetimeBounds {\n }\n \n \n-pub fn get_explicit_self(cx: @ext_ctxt, span: span, self_ptr: Option<PtrTy>)\n+pub fn get_explicit_self(cx: @ext_ctxt, span: span, self_ptr: &Option<PtrTy>)\n     -> (@expr, ast::self_ty) {\n     let self_path = build::make_self(cx, span);\n-    match self_ptr {\n+    match *self_ptr {\n         None => {\n             (self_path, respan(span, ast::sty_value))\n         }\n-        Some(ptr) => {\n+        Some(ref ptr) => {\n             let self_ty = respan(\n                 span,\n-                match ptr {\n+                match *ptr {\n                     Owned => ast::sty_uniq(ast::m_imm),\n                     Managed(mutbl) => ast::sty_box(mutbl),\n-                    Borrowed(lt, mutbl) => {\n+                    Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| @build::mk_lifetime(cx, span,\n                                                                 cx.ident_of(*s)));\n                         ast::sty_region(lt, mutbl)"}, {"sha": "9afbe1e479d66e8d23619662f1936215ca1fc995", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -662,12 +662,11 @@ mod test {\n     #[test] fn fail_exists_test () {\n         let src = ~\"fn main() { fail!(\\\"something appropriately gloomy\\\");}\";\n         let sess = parse::new_parse_sess(None);\n-        let cfg = ~[];\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             @src,\n-            cfg,sess);\n-        expand_crate(sess,cfg,crate_ast);\n+            ~[],sess);\n+        expand_crate(sess,~[],crate_ast);\n     }\n \n     // these following tests are quite fragile, in that they don't test what\n@@ -679,13 +678,12 @@ mod test {\n         let src = ~\"fn bogus() {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n         let sess = parse::new_parse_sess(None);\n-        let cfg = ~[];\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             @src,\n-            cfg,sess);\n+            ~[],sess);\n         // should fail:\n-        expand_crate(sess,cfg,crate_ast);\n+        expand_crate(sess,~[],crate_ast);\n     }\n \n     // make sure that macros can leave scope for modules\n@@ -694,27 +692,25 @@ mod test {\n         let src = ~\"mod foo {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n         let sess = parse::new_parse_sess(None);\n-        let cfg = ~[];\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             @src,\n-            cfg,sess);\n+            ~[],sess);\n         // should fail:\n-        expand_crate(sess,cfg,crate_ast);\n+        expand_crate(sess,~[],crate_ast);\n     }\n \n     // macro_escape modules shouldn't cause macros to leave scope\n     #[test] fn macros_can_escape_flattened_mods_test () {\n         let src = ~\"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n         let sess = parse::new_parse_sess(None);\n-        let cfg = ~[];\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             @src,\n-            cfg,sess);\n+            ~[], sess);\n         // should fail:\n-        expand_crate(sess,cfg,crate_ast);\n+        expand_crate(sess,~[],crate_ast);\n     }\n \n     #[test] fn core_macros_must_parse () {"}, {"sha": "26b3178a91110203b0aad867c9f72b9e2d9441cc", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -62,7 +62,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n     // which tells the RT::conv* functions how to perform the conversion\n \n     fn make_rt_conv_expr(cx: @ext_ctxt, sp: span, cnv: &Conv) -> @ast::expr {\n-        fn make_flags(cx: @ext_ctxt, sp: span, flags: ~[Flag]) -> @ast::expr {\n+        fn make_flags(cx: @ext_ctxt, sp: span, flags: &[Flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, \"flag_none\");\n             for flags.each |f| {\n                 let fstr = match *f {"}, {"sha": "f897eb787e5665dafc0d2d5cb5a25ae633cdbe8e", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -154,14 +154,14 @@ pub struct protocol_ {\n \n pub impl protocol_ {\n     /// Get a state.\n-    fn get_state(&self, name: ~str) -> state {\n-        self.states.find(|i| i.name == name).get()\n+    fn get_state(&self, name: &str) -> state {\n+        self.states.find(|i| name == i.name).get()\n     }\n \n     fn get_state_by_id(&self, id: uint) -> state { self.states[id] }\n \n-    fn has_state(&self, name: ~str) -> bool {\n-        self.states.find(|i| i.name == name).is_some()\n+    fn has_state(&self, name: &str) -> bool {\n+        self.states.find(|i| name == i.name).is_some()\n     }\n \n     fn filename(&self) -> ~str {"}, {"sha": "f4227cd2f2c74eb133aacd61ac130c51db6e0e8f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -452,9 +452,9 @@ fn mk_binop(cx: @ext_ctxt, sp: span, bop: token::binop) -> @ast::expr {\n                    ids_ext(cx, ~[name.to_owned()]))\n }\n \n-fn mk_token(cx: @ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n+fn mk_token(cx: @ext_ctxt, sp: span, tok: &token::Token) -> @ast::expr {\n \n-    match tok {\n+    match *tok {\n         BINOP(binop) => {\n             return build::mk_call(cx, sp,\n                                   ids_ext(cx, ~[~\"BINOP\"]),\n@@ -561,7 +561,7 @@ fn mk_token(cx: @ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n         _ => ()\n     }\n \n-    let name = match tok {\n+    let name = match *tok {\n         EQ => \"EQ\",\n         LT => \"LT\",\n         LE => \"LE\",\n@@ -612,7 +612,7 @@ fn mk_tt(cx: @ext_ctxt, sp: span, tt: &ast::token_tree)\n             let e_tok =\n                 build::mk_call(cx, sp,\n                                ids_ext(cx, ~[~\"tt_tok\"]),\n-                               ~[e_sp, mk_token(cx, sp, *tok)]);\n+                               ~[e_sp, mk_token(cx, sp, tok)]);\n             let e_push =\n                 build::mk_method_call(cx, sp,\n                                       build::mk_path(cx, sp, ids_ext(cx, ~[~\"tt\"])),"}, {"sha": "aa211973f1c52b19992d1ac8180e0e501ef6a4c3", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -130,7 +130,6 @@ pub fn count_names(ms: &[matcher]) -> uint {\n         }})\n }\n \n-#[allow(non_implicitly_copyable_typarams)]\n pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n                         -> ~MatcherPos {\n     let mut match_idx_hi = 0u;\n@@ -184,15 +183,15 @@ pub enum named_match {\n \n pub type earley_item = ~MatcherPos;\n \n-pub fn nameize(p_s: @mut ParseSess, ms: ~[matcher], res: ~[@named_match])\n+pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n             -> HashMap<ident,@named_match> {\n-    fn n_rec(p_s: @mut ParseSess, m: matcher, res: ~[@named_match],\n+    fn n_rec(p_s: @mut ParseSess, m: &matcher, res: &[@named_match],\n              ret_val: &mut HashMap<ident, @named_match>) {\n-        match m {\n+        match *m {\n           codemap::spanned {node: match_tok(_), _} => (),\n           codemap::spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n-            for (*more_ms).each() |next_m| {\n-                n_rec(p_s, *next_m, res, ret_val)\n+            for more_ms.each |next_m| {\n+                n_rec(p_s, next_m, res, ret_val)\n             };\n           }\n           codemap::spanned {\n@@ -207,7 +206,7 @@ pub fn nameize(p_s: @mut ParseSess, ms: ~[matcher], res: ~[@named_match])\n         }\n     }\n     let mut ret_val = HashMap::new();\n-    for ms.each() |m| { n_rec(p_s, *m, res, &mut ret_val) }\n+    for ms.each |m| { n_rec(p_s, m, res, &mut ret_val) }\n     return ret_val;\n }\n \n@@ -234,10 +233,10 @@ pub fn parse(\n     sess: @mut ParseSess,\n     cfg: ast::crate_cfg,\n     rdr: @reader,\n-    ms: ~[matcher]\n+    ms: &[matcher]\n ) -> parse_result {\n     let mut cur_eis = ~[];\n-    cur_eis.push(initial_matcher_pos(copy ms, None, rdr.peek().sp.lo));\n+    cur_eis.push(initial_matcher_pos(ms.to_owned(), None, rdr.peek().sp.lo));\n \n     loop {\n         let mut bb_eis = ~[]; // black-box parsed by parser.rs\n@@ -277,7 +276,7 @@ pub fn parse(\n \n                         // Only touch the binders we have actually bound\n                         for uint::range(ei.match_lo, ei.match_hi) |idx| {\n-                            let sub = ei.matches[idx];\n+                            let sub = copy ei.matches[idx];\n                             new_pos.matches[idx]\n                                 .push(@matched_seq(sub,\n                                                    mk_sp(ei.sp_lo,\n@@ -410,31 +409,31 @@ pub fn parse(\n     }\n }\n \n-pub fn parse_nt(p: &Parser, name: ~str) -> nonterminal {\n+pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n     match name {\n-      ~\"item\" => match p.parse_item(~[]) {\n+      \"item\" => match p.parse_item(~[]) {\n         Some(i) => token::nt_item(i),\n         None => p.fatal(~\"expected an item keyword\")\n       },\n-      ~\"block\" => token::nt_block(p.parse_block()),\n-      ~\"stmt\" => token::nt_stmt(p.parse_stmt(~[])),\n-      ~\"pat\" => token::nt_pat(p.parse_pat(true)),\n-      ~\"expr\" => token::nt_expr(p.parse_expr()),\n-      ~\"ty\" => token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)),\n+      \"block\" => token::nt_block(p.parse_block()),\n+      \"stmt\" => token::nt_stmt(p.parse_stmt(~[])),\n+      \"pat\" => token::nt_pat(p.parse_pat(true)),\n+      \"expr\" => token::nt_expr(p.parse_expr()),\n+      \"ty\" => token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)),\n       // this could be handled like a token, since it is one\n-      ~\"ident\" => match *p.token {\n+      \"ident\" => match *p.token {\n         token::IDENT(sn,b) => { p.bump(); token::nt_ident(sn,b) }\n         _ => p.fatal(~\"expected ident, found \"\n                      + token::to_str(p.reader.interner(), &copy *p.token))\n       },\n-      ~\"path\" => token::nt_path(p.parse_path_with_tps(false)),\n-      ~\"tt\" => {\n+      \"path\" => token::nt_path(p.parse_path_with_tps(false)),\n+      \"tt\" => {\n         *p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n         let res = token::nt_tt(@p.parse_token_tree());\n         *p.quote_depth -= 1u;\n         res\n       }\n-      ~\"matchers\" => token::nt_matchers(p.parse_matchers()),\n+      \"matchers\" => token::nt_matchers(p.parse_matchers()),\n       _ => p.fatal(~\"Unsupported builtin nonterminal parser: \" + name)\n     }\n }"}, {"sha": "be6cc7a846ad35751fa6ad9cecc56b37dddc9a2d", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -63,19 +63,19 @@ pub fn add_new_extension(cx: @ext_ctxt,\n \n     // Extract the arguments:\n     let lhses = match *argument_map.get(&lhs_nm) {\n-        @matched_seq(ref s, _) => /* FIXME (#2543) */ copy *s,\n+        @matched_seq(ref s, _) => /* FIXME (#2543) */ @copy *s,\n         _ => cx.span_bug(sp, ~\"wrong-structured lhs\")\n     };\n \n     let rhses = match *argument_map.get(&rhs_nm) {\n-      @matched_seq(ref s, _) => /* FIXME (#2543) */ copy *s,\n+      @matched_seq(ref s, _) => /* FIXME (#2543) */ @copy *s,\n       _ => cx.span_bug(sp, ~\"wrong-structured rhs\")\n     };\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n     fn generic_extension(cx: @ext_ctxt, sp: span, name: ident,\n                          arg: &[ast::token_tree],\n-                         lhses: ~[@named_match], rhses: ~[@named_match])\n+                         lhses: &[@named_match], rhses: &[@named_match])\n     -> MacResult {\n \n         if cx.trace_macros() {\n@@ -93,7 +93,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n         let s_d = cx.parse_sess().span_diagnostic;\n         let itr = cx.parse_sess().interner;\n \n-        for lhses.eachi() |i, lhs| { // try each arm's matchers\n+        for lhses.eachi |i, lhs| { // try each arm's matchers\n             match *lhs {\n               @matched_nonterminal(nt_matchers(ref mtcs)) => {\n                 // `none` is because we're not interpolating\n@@ -103,7 +103,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n                     None,\n                     vec::to_owned(arg)\n                 ) as @reader;\n-                match parse(cx.parse_sess(), cx.cfg(), arg_rdr, (*mtcs)) {\n+                match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n                   success(named_matches) => {\n                     let rhs = match rhses[i] {\n                         // okay, what's your transcriber?\n@@ -146,7 +146,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n     }\n \n     let exp: @fn(@ext_ctxt, span, &[ast::token_tree]) -> MacResult =\n-        |cx, sp, arg| generic_extension(cx, sp, name, arg, lhses, rhses);\n+        |cx, sp, arg| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n \n     return MRDef(MacroDef{\n         name: copy *cx.parse_sess().interner.get(name),"}, {"sha": "438efb2326c7a0a4c9ba28dbeeab934bee8b3902", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -91,11 +91,11 @@ pub fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n         sp_diag: r.sp_diag,\n         interner: r.interner,\n         stack: dup_tt_frame(r.stack),\n-        interpolations: r.interpolations,\n         repeat_idx: copy r.repeat_idx,\n         repeat_len: copy r.repeat_len,\n         cur_tok: copy r.cur_tok,\n-        cur_span: r.cur_span\n+        cur_span: r.cur_span,\n+        interpolations: copy r.interpolations,\n     }\n }\n \n@@ -127,7 +127,7 @@ enum lis {\n     lis_unconstrained, lis_constraint(uint, ident), lis_contradiction(~str)\n }\n \n-fn lockstep_iter_size(t: token_tree, r: &mut TtReader) -> lis {\n+fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n     fn lis_merge(lhs: lis, rhs: lis, r: &mut TtReader) -> lis {\n         match lhs {\n           lis_unconstrained => copy rhs,\n@@ -146,10 +146,10 @@ fn lockstep_iter_size(t: token_tree, r: &mut TtReader) -> lis {\n           }\n         }\n     }\n-    match t {\n+    match *t {\n       tt_delim(ref tts) | tt_seq(_, ref tts, _, _) => {\n-        vec::foldl(lis_unconstrained, (*tts), |lis, tt| {\n-            let lis2 = lockstep_iter_size(*tt, r);\n+        vec::foldl(lis_unconstrained, *tts, |lis, tt| {\n+            let lis2 = lockstep_iter_size(tt, r);\n             lis_merge(lis, lis2, r)\n         })\n       }\n@@ -230,7 +230,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n           }\n           tt_seq(sp, copy tts, copy sep, zerok) => {\n             let t = tt_seq(sp, copy tts, copy sep, zerok);\n-            match lockstep_iter_size(t, r) {\n+            match lockstep_iter_size(&t, r) {\n               lis_unconstrained => {\n                 r.sp_diag.span_fatal(\n                     sp, /* blame macro writer */"}, {"sha": "6ed8994ed3319566a7b4d95ed48c07a4b3206596", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -44,7 +44,7 @@ pub trait ast_fold {\n pub struct AstFoldFns {\n     //unlike the others, item_ is non-trivial\n     fold_crate: @fn(&crate_, span, @ast_fold) -> (crate_, span),\n-    fold_view_item: @fn(view_item_, @ast_fold) -> view_item_,\n+    fold_view_item: @fn(&view_item_, @ast_fold) -> view_item_,\n     fold_foreign_item: @fn(@foreign_item, @ast_fold) -> @foreign_item,\n     fold_item: @fn(@item, @ast_fold) -> Option<@item>,\n     fold_struct_field: @fn(@struct_field, @ast_fold) -> @struct_field,\n@@ -112,7 +112,7 @@ fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n     }\n }\n //used in noop_fold_expr, and possibly elsewhere in the future\n-fn fold_mac_(m: mac, fld: @ast_fold) -> mac {\n+fn fold_mac_(m: &mac, fld: @ast_fold) -> mac {\n     spanned {\n         node: match m.node { mac_invoc_tt(*) => copy m.node },\n         span: fld.new_span(m.span),\n@@ -174,8 +174,8 @@ pub fn noop_fold_crate(c: &crate_, fld: @ast_fold) -> crate_ {\n     }\n }\n \n-fn noop_fold_view_item(vi: view_item_, _fld: @ast_fold) -> view_item_ {\n-    return /* FIXME (#2543) */ copy vi;\n+fn noop_fold_view_item(vi: &view_item_, _fld: @ast_fold) -> view_item_ {\n+    return /* FIXME (#2543) */ copy *vi;\n }\n \n \n@@ -351,7 +351,7 @@ fn noop_fold_stmt(s: &stmt_, fld: @ast_fold) -> stmt_ {\n         stmt_decl(d, nid) => stmt_decl(fld.fold_decl(d), fld.new_id(nid)),\n         stmt_expr(e, nid) => stmt_expr(fld.fold_expr(e), fld.new_id(nid)),\n         stmt_semi(e, nid) => stmt_semi(fld.fold_expr(e), fld.new_id(nid)),\n-        stmt_mac(ref mac, semi) => stmt_mac(fold_mac((*mac)), semi)\n+        stmt_mac(ref mac, semi) => stmt_mac(fold_mac(mac), semi)\n     }\n }\n \n@@ -540,14 +540,14 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n                 fld.fold_expr(e)\n             )\n         }\n-        expr_inline_asm(a) => {\n+        expr_inline_asm(ref a) => {\n             expr_inline_asm(inline_asm {\n                 inputs: a.inputs.map(|&(c, in)| (c, fld.fold_expr(in))),\n                 outputs: a.outputs.map(|&(c, out)| (c, fld.fold_expr(out))),\n-                .. a\n+                .. copy *a\n             })\n         }\n-        expr_mac(ref mac) => expr_mac(fold_mac((*mac))),\n+        expr_mac(ref mac) => expr_mac(fold_mac(mac)),\n         expr_struct(path, ref fields, maybe_expr) => {\n             expr_struct(\n                 fld.fold_path(path),\n@@ -590,12 +590,12 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n                 region: f.region,\n                 onceness: f.onceness,\n                 decl: fold_fn_decl(&f.decl, fld),\n-                lifetimes: f.lifetimes,\n+                lifetimes: copy f.lifetimes,\n             })\n         }\n         ty_bare_fn(ref f) => {\n             ty_bare_fn(@TyBareFn {\n-                lifetimes: f.lifetimes,\n+                lifetimes: copy f.lifetimes,\n                 purity: f.purity,\n                 abis: f.abis,\n                 decl: fold_fn_decl(&f.decl, fld)\n@@ -609,7 +609,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n                 fld.fold_expr(e)\n             )\n         }\n-        ty_mac(ref mac) => ty_mac(fold_mac(*mac))\n+        ty_mac(ref mac) => ty_mac(fold_mac(mac))\n     }\n }\n \n@@ -740,7 +740,7 @@ impl ast_fold for AstFoldFns {\n     fn fold_view_item(@self, x: @view_item) ->\n        @view_item {\n         @ast::view_item {\n-            node: (self.fold_view_item)(x.node, self as @ast_fold),\n+            node: (self.fold_view_item)(&x.node, self as @ast_fold),\n             attrs: vec::map(x.attrs, |a|\n                   fold_attribute_(*a, self as @ast_fold)),\n             vis: x.vis,"}, {"sha": "fa91b968f696f7b4204fa3a74306ad19dac11095", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -192,7 +192,7 @@ fn read_line_comments(rdr: @mut StringReader, code_to_the_left: bool,\n \n // FIXME #3961: This is not the right way to convert string byte\n // offsets to characters.\n-fn all_whitespace(s: ~str, begin: uint, end: uint) -> bool {\n+fn all_whitespace(s: &str, begin: uint, end: uint) -> bool {\n     let mut i: uint = begin;\n     while i != end {\n         if !is_whitespace(s[i] as char) { return false; } i += 1u;"}, {"sha": "9a8a6620652346f0b4673e60bfa5228bc1e18ac0", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -351,15 +351,14 @@ mod test {\n     use core::option::None;\n     use core::int;\n     use core::num::NumCast;\n-    use core::path::Path;\n-    use codemap::{dummy_sp, CodeMap, span, BytePos, spanned};\n+    use codemap::{CodeMap, span, BytePos, spanned};\n     use opt_vec;\n     use ast;\n     use abi;\n     use ast_util::mk_ident;\n     use parse::parser::Parser;\n-    use parse::token::{ident_interner, mk_ident_interner, mk_fresh_ident_interner};\n-    use diagnostic::{span_handler, mk_span_handler, mk_handler, Emitter};\n+    use parse::token::{ident_interner, mk_fresh_ident_interner};\n+    use diagnostic::{mk_span_handler, mk_handler};\n \n     // add known names to interner for testing\n     fn mk_testing_interner() -> @ident_interner {\n@@ -408,7 +407,7 @@ mod test {\n \n     // map a string to tts, return the tt without its parsesess\n     fn string_to_tts_only(source_str : @~str) -> ~[ast::token_tree] {\n-        let (tts,ps) = string_to_tts_t(source_str);\n+        let (tts,_ps) = string_to_tts_t(source_str);\n         tts\n     }\n \n@@ -483,7 +482,7 @@ mod test {\n     }*/\n \n     #[test] fn string_to_tts_1 () {\n-        let (tts,ps) = string_to_tts_t(@~\"fn a (b : int) { b; }\");\n+        let (tts,_ps) = string_to_tts_t(@~\"fn a (b : int) { b; }\");\n         assert_eq!(to_json_str(@tts),\n                    ~\"[\\\n                 [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"fn\\\",false]],\\\n@@ -548,7 +547,7 @@ mod test {\n     }\n \n     fn parser_done(p: Parser){\n-        assert_eq!(*p.token,token::EOF);\n+        assert_eq!(copy *p.token,token::EOF);\n     }\n \n     #[test] fn parse_ident_pat () {"}, {"sha": "211d123e8872db251ce136698552ddb17524d3f0", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -253,17 +253,17 @@ pub impl Parser {\n         }\n     }\n \n-    fn token_is_obsolete_ident(&self, ident: &str, token: Token) -> bool {\n-        match token {\n-            token::IDENT(copy sid, _) => {\n+    fn token_is_obsolete_ident(&self, ident: &str, token: &Token) -> bool {\n+        match *token {\n+            token::IDENT(sid, _) => {\n                 str::eq_slice(*self.id_to_str(sid), ident)\n             }\n             _ => false\n         }\n     }\n \n     fn is_obsolete_ident(&self, ident: &str) -> bool {\n-        self.token_is_obsolete_ident(ident, *self.token)\n+        self.token_is_obsolete_ident(ident, self.token)\n     }\n \n     fn eat_obsolete_ident(&self, ident: &str) -> bool {\n@@ -289,7 +289,7 @@ pub impl Parser {\n     fn try_parse_obsolete_with(&self) -> bool {\n         if *self.token == token::COMMA\n             && self.token_is_obsolete_ident(\"with\",\n-                                            self.look_ahead(1u)) {\n+                                            &self.look_ahead(1u)) {\n             self.bump();\n         }\n         if self.eat_obsolete_ident(\"with\") {\n@@ -301,13 +301,13 @@ pub impl Parser {\n         }\n     }\n \n-    fn try_parse_obsolete_priv_section(&self, attrs: ~[attribute]) -> bool {\n+    fn try_parse_obsolete_priv_section(&self, attrs: &[attribute]) -> bool {\n         if self.is_keyword(&~\"priv\") && self.look_ahead(1) == token::LBRACE {\n             self.obsolete(copy *self.span, ObsoletePrivSection);\n             self.eat_keyword(&~\"priv\");\n             self.bump();\n             while *self.token != token::RBRACE {\n-                self.parse_single_struct_field(ast::private, attrs);\n+                self.parse_single_struct_field(ast::private, attrs.to_owned());\n             }\n             self.bump();\n             true"}, {"sha": "e1fe20695c7c6b65a93a2fd6cb1805be0300ec64", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -708,7 +708,7 @@ pub impl Parser {\n             self.obsolete(*self.last_span, ObsoleteBareFnType);\n             result\n         } else if *self.token == token::MOD_SEP\n-            || is_ident_or_path(&*self.token) {\n+            || is_ident_or_path(self.token) {\n             // NAMED TYPE\n             let path = self.parse_path_with_tps(false);\n             ty_path(path, self.get_id())\n@@ -1556,9 +1556,12 @@ pub impl Parser {\n                         |p| p.parse_token_tree()\n                     );\n                     let (s, z) = p.parse_sep_and_zerok();\n+                    let seq = match seq {\n+                        spanned { node, _ } => node,\n+                    };\n                     tt_seq(\n-                        mk_sp(sp.lo ,p.span.hi),\n-                        seq.node,\n+                        mk_sp(sp.lo, p.span.hi),\n+                        seq,\n                         s,\n                         z\n                     )\n@@ -1624,9 +1627,9 @@ pub impl Parser {\n             token::LBRACE | token::LPAREN | token::LBRACKET => {\n                 self.parse_matcher_subseq(\n                     name_idx,\n-                    *self.token,\n+                    copy *self.token,\n                     // tjc: not sure why we need a copy\n-                    token::flip_delimiter(&*self.token)\n+                    token::flip_delimiter(self.token)\n                 )\n             }\n             _ => self.fatal(~\"expected open delimiter\")\n@@ -1986,22 +1989,23 @@ pub impl Parser {\n         // them as the lambda arguments\n         let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n         match e.node {\n-            expr_call(f, args, NoSugar) => {\n+            expr_call(f, /*bad*/ copy args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append(args, ~[last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi, expr_call(f, args, sugar))\n             }\n-            expr_method_call(f, i, tps, args, NoSugar) => {\n+            expr_method_call(f, i, /*bad*/ copy tps,\n+                             /*bad*/ copy args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append(args, ~[last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi,\n                              expr_method_call(f, i, tps, args, sugar))\n             }\n-            expr_field(f, i, tps) => {\n+            expr_field(f, i, /*bad*/ copy tps) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n@@ -2259,7 +2263,7 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n         let pat;\n-        match *self.token {\n+        match /*bad*/ copy *self.token {\n             // parse _\n           token::UNDERSCORE => { self.bump(); pat = pat_wild; }\n             // parse @pat\n@@ -2373,8 +2377,8 @@ pub impl Parser {\n             self.expect(&token::RBRACKET);\n             pat = ast::pat_vec(before, slice, after);\n           }\n-          tok => {\n-            if !is_ident_or_path(&tok)\n+          ref tok => {\n+            if !is_ident_or_path(tok)\n                 || self.is_keyword(&~\"true\")\n                 || self.is_keyword(&~\"false\")\n             {\n@@ -2384,7 +2388,7 @@ pub impl Parser {\n                 // preceded by unary-minus) or identifiers.\n                 let val = self.parse_literal_maybe_minus();\n                 if self.eat(&token::DOTDOT) {\n-                    let end = if is_ident_or_path(&tok) {\n+                    let end = if is_ident_or_path(tok) {\n                         let path = self.parse_path_with_tps(true);\n                         let hi = self.span.hi;\n                         self.mk_expr(lo, hi, expr_path(path))\n@@ -2897,7 +2901,7 @@ pub impl Parser {\n                 loop;\n             }\n \n-            if is_ident_or_path(&*self.token) {\n+            if is_ident_or_path(self.token) {\n                 self.obsolete(*self.span,\n                               ObsoleteTraitBoundSeparator);\n             }\n@@ -3531,6 +3535,7 @@ pub impl Parser {\n     fn parse_item_mod(&self, outer_attrs: ~[ast::attribute]) -> item_info {\n         let id_span = *self.span;\n         let id = self.parse_ident();\n+        let merge = ::attr::first_attr_value_str_by_name(outer_attrs, \"merge\");\n         let info_ = if *self.token == token::SEMI {\n             self.bump();\n             // This mod is in an external file. Let's go get it!\n@@ -3550,7 +3555,7 @@ pub impl Parser {\n         // (int-template, iter-trait). If there's a 'merge' attribute\n         // on the mod, then we'll go and suck in another file and merge\n         // its contents\n-        match ::attr::first_attr_value_str_by_name(outer_attrs, ~\"merge\") {\n+        match merge {\n             Some(path) => {\n                 let prefix = Path(\n                     self.sess.cm.span_to_filename(*self.span));\n@@ -3636,10 +3641,7 @@ pub impl Parser {\n             new_sub_parser_from_file(self.sess, copy self.cfg,\n                                      &full_path, id_sp);\n         let (inner, next) = p0.parse_inner_attrs_and_next();\n-        let mod_attrs = vec::append(\n-            /*bad*/ copy outer_attrs,\n-            inner\n-        );\n+        let mod_attrs = vec::append(outer_attrs, inner);\n         let first_item_outer_attrs = next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n         return (ast::item_mod(m0), mod_attrs);\n@@ -4105,7 +4107,8 @@ pub impl Parser {\n         }\n         if self.eat_keyword(&~\"mod\") {\n             // MODULE ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_mod(attrs);\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_mod(/*bad*/ copy attrs);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));"}, {"sha": "7944469cb963fcc48a25043282eb43d818041d43", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -457,9 +457,9 @@ pub impl Printer {\n             }\n         }\n     }\n-    fn print_str(&mut self, s: ~str) {\n+    fn print_str(&mut self, s: &str) {\n         while self.pending_indentation > 0 {\n-            (*self.out).write_str(~\" \");\n+            (*self.out).write_str(\" \");\n             self.pending_indentation -= 1;\n         }\n         (*self.out).write_str(s);\n@@ -562,16 +562,16 @@ pub fn end(p: @mut Printer) { p.pretty_print(END); }\n \n pub fn eof(p: @mut Printer) { p.pretty_print(EOF); }\n \n-pub fn word(p: @mut Printer, wrd: ~str) {\n-    p.pretty_print(STRING(@/*bad*/ copy wrd, wrd.len() as int));\n+pub fn word(p: @mut Printer, wrd: &str) {\n+    p.pretty_print(STRING(@/*bad*/ wrd.to_owned(), wrd.len() as int));\n }\n \n-pub fn huge_word(p: @mut Printer, wrd: ~str) {\n-    p.pretty_print(STRING(@/*bad*/ copy wrd, size_infinity));\n+pub fn huge_word(p: @mut Printer, wrd: &str) {\n+    p.pretty_print(STRING(@/*bad*/ wrd.to_owned(), size_infinity));\n }\n \n-pub fn zero_word(p: @mut Printer, wrd: ~str) {\n-    p.pretty_print(STRING(@/*bad*/ copy wrd, 0));\n+pub fn zero_word(p: @mut Printer, wrd: &str) {\n+    p.pretty_print(STRING(@/*bad*/ wrd.to_owned(), 0));\n }\n \n pub fn spaces(p: @mut Printer, n: uint) { break_offset(p, n, 0); }"}, {"sha": "1e94c16f87ab254e8589d46404563579dcfdd4e7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -156,7 +156,7 @@ pub fn lifetime_to_str(e: &ast::Lifetime, intr: @ident_interner) -> ~str {\n }\n \n pub fn tt_to_str(tt: ast::token_tree, intr: @ident_interner) -> ~str {\n-    to_str(tt, print_tt, intr)\n+    to_str(&tt, print_tt, intr)\n }\n \n pub fn tts_to_str(tts: &[ast::token_tree], intr: @ident_interner) -> ~str {\n@@ -213,7 +213,7 @@ pub fn attribute_to_str(attr: ast::attribute, intr: @ident_interner) -> ~str {\n     to_str(attr, print_attribute, intr)\n }\n \n-pub fn variant_to_str(var: ast::variant, intr: @ident_interner) -> ~str {\n+pub fn variant_to_str(var: &ast::variant, intr: @ident_interner) -> ~str {\n     to_str(var, print_variant, intr)\n }\n \n@@ -229,9 +229,9 @@ pub fn box(s: @ps, u: uint, b: pp::breaks) {\n \n pub fn nbsp(s: @ps) { word(s.s, ~\" \"); }\n \n-pub fn word_nbsp(s: @ps, w: ~str) { word(s.s, w); nbsp(s); }\n+pub fn word_nbsp(s: @ps, w: &str) { word(s.s, w); nbsp(s); }\n \n-pub fn word_space(s: @ps, w: ~str) { word(s.s, w); space(s.s); }\n+pub fn word_space(s: @ps, w: &str) { word(s.s, w); space(s.s); }\n \n pub fn popen(s: @ps) { word(s.s, ~\"(\"); }\n \n@@ -346,7 +346,7 @@ pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::expr]) {\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n-pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: ~[ast::attribute]) {\n+pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for _mod.view_items.each |vitem| {\n         print_view_item(s, *vitem);\n@@ -355,7 +355,7 @@ pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: ~[ast::attribute]) {\n }\n \n pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n-                         attrs: ~[ast::attribute]) {\n+                         attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for nmod.view_items.each |vitem| {\n         print_view_item(s, *vitem);\n@@ -539,7 +539,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n       ast::item_enum(ref enum_definition, ref params) => {\n         print_enum_def(\n             s,\n-            *enum_definition,\n+            enum_definition,\n             params,\n             item.ident,\n             item.span,\n@@ -621,7 +621,7 @@ fn print_trait_ref(s: @ps, t: &ast::trait_ref) {\n     print_path(s, t.path, false);\n }\n \n-pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n+pub fn print_enum_def(s: @ps, enum_definition: &ast::enum_def,\n                       generics: &ast::Generics, ident: ast::ident,\n                       span: codemap::span, visibility: ast::visibility) {\n     head(s, visibility_qualified(visibility, ~\"enum\"));\n@@ -632,15 +632,15 @@ pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n }\n \n pub fn print_variants(s: @ps,\n-                      variants: ~[ast::variant],\n+                      variants: &[ast::variant],\n                       span: codemap::span) {\n     bopen(s);\n     for variants.each |v| {\n         space_if_not_bol(s);\n         maybe_print_comment(s, v.span.lo);\n         print_outer_attributes(s, v.node.attrs);\n         ibox(s, indent_unit);\n-        print_variant(s, *v);\n+        print_variant(s, v);\n         word(s.s, ~\",\");\n         end(s);\n         maybe_print_trailing_comment(s, v.span, None);\n@@ -727,15 +727,15 @@ pub fn print_struct(s: @ps,\n /// appropriate macro, transcribe back into the grammar we just parsed from,\n /// and then pretty-print the resulting AST nodes (so, e.g., we print\n /// expression arguments as expressions). It can be done! I think.\n-pub fn print_tt(s: @ps, tt: ast::token_tree) {\n-    match tt {\n+pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n+    match *tt {\n       ast::tt_delim(ref tts) => print_tts(s, *tts),\n       ast::tt_tok(_, ref tk) => {\n           word(s.s, parse::token::to_str(s.intr, tk));\n       }\n       ast::tt_seq(_, ref tts, ref sep, zerok) => {\n         word(s.s, ~\"$(\");\n-        for (*tts).each() |tt_elt| { print_tt(s, *tt_elt); }\n+        for (*tts).each() |tt_elt| { print_tt(s, tt_elt); }\n         word(s.s, ~\")\");\n         match (*sep) {\n           Some(ref tk) => word(s.s, parse::token::to_str(s.intr, tk)),\n@@ -756,12 +756,12 @@ pub fn print_tts(s: @ps, tts: &[ast::token_tree]) {\n         if i != 0 {\n             space(s.s);\n         }\n-        print_tt(s, *tt);\n+        print_tt(s, tt);\n     }\n     end(s);\n }\n \n-pub fn print_variant(s: @ps, v: ast::variant) {\n+pub fn print_variant(s: @ps, v: &ast::variant) {\n     print_visibility(s, v.node.vis);\n     match v.node.kind {\n         ast::tuple_variant_kind(ref args) => {\n@@ -819,7 +819,7 @@ pub fn print_method(s: @ps, meth: @ast::method) {\n     print_block_with_attrs(s, &meth.body, meth.attrs);\n }\n \n-pub fn print_outer_attributes(s: @ps, attrs: ~[ast::attribute]) {\n+pub fn print_outer_attributes(s: @ps, attrs: &[ast::attribute]) {\n     let mut count = 0;\n     for attrs.each |attr| {\n         match attr.node.style {\n@@ -830,7 +830,7 @@ pub fn print_outer_attributes(s: @ps, attrs: ~[ast::attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-pub fn print_inner_attributes(s: @ps, attrs: ~[ast::attribute]) {\n+pub fn print_inner_attributes(s: @ps, attrs: &[ast::attribute]) {\n     let mut count = 0;\n     for attrs.each |attr| {\n         match attr.node.style {\n@@ -879,7 +879,7 @@ pub fn print_stmt(s: @ps, st: &ast::stmt) {\n       }\n       ast::stmt_mac(ref mac, semi) => {\n         space_if_not_bol(s);\n-        print_mac(s, (*mac));\n+        print_mac(s, mac);\n         if semi { word(s.s, ~\";\"); }\n       }\n     }\n@@ -892,18 +892,18 @@ pub fn print_block(s: @ps, blk: &ast::blk) {\n }\n \n pub fn print_block_unclosed(s: @ps, blk: &ast::blk) {\n-    print_possibly_embedded_block_(s, blk, block_normal, indent_unit, ~[],\n+    print_possibly_embedded_block_(s, blk, block_normal, indent_unit, &[],\n                                  false);\n }\n \n pub fn print_block_unclosed_indent(s: @ps, blk: &ast::blk, indented: uint) {\n-    print_possibly_embedded_block_(s, blk, block_normal, indented, ~[],\n+    print_possibly_embedded_block_(s, blk, block_normal, indented, &[],\n                                    false);\n }\n \n pub fn print_block_with_attrs(s: @ps,\n                               blk: &ast::blk,\n-                              attrs: ~[ast::attribute]) {\n+                              attrs: &[ast::attribute]) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs,\n                                   true);\n }\n@@ -915,14 +915,14 @@ pub fn print_possibly_embedded_block(s: @ps,\n                                      embedded: embed_type,\n                                      indented: uint) {\n     print_possibly_embedded_block_(\n-        s, blk, embedded, indented, ~[], true);\n+        s, blk, embedded, indented, &[], true);\n }\n \n pub fn print_possibly_embedded_block_(s: @ps,\n                                       blk: &ast::blk,\n                                       embedded: embed_type,\n                                       indented: uint,\n-                                      attrs: ~[ast::attribute],\n+                                      attrs: &[ast::attribute],\n                                       close_box: bool) {\n     match blk.node.rules {\n       ast::unsafe_blk => word_space(s, ~\"unsafe\"),\n@@ -994,7 +994,7 @@ pub fn print_if(s: @ps, test: @ast::expr, blk: &ast::blk,\n     do_else(s, elseopt);\n }\n \n-pub fn print_mac(s: @ps, m: ast::mac) {\n+pub fn print_mac(s: @ps, m: &ast::mac) {\n     match m.node {\n       ast::mac_invoc_tt(pth, ref tts) => {\n         print_path(s, pth, false);\n@@ -1387,7 +1387,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_expr(s, expr);\n         pclose(s);\n       }\n-      ast::expr_inline_asm(a) => {\n+      ast::expr_inline_asm(ref a) => {\n         if a.volatile {\n             word(s.s, ~\"__volatile__ asm!\");\n         } else {\n@@ -1415,7 +1415,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_string(s, *a.clobbers);\n         pclose(s);\n       }\n-      ast::expr_mac(ref m) => print_mac(s, (*m)),\n+      ast::expr_mac(ref m) => print_mac(s, m),\n       ast::expr_paren(e) => {\n           popen(s);\n           print_expr(s, e);\n@@ -1559,7 +1559,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n           }\n         }\n       }\n-      ast::pat_struct(path, fields, etc) => {\n+      ast::pat_struct(path, ref fields, etc) => {\n         print_path(s, path, true);\n         word(s.s, ~\"{\");\n         fn print_field(s: @ps, f: ast::field_pat, refutable: bool) {\n@@ -1570,18 +1570,18 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n             end(s);\n         }\n         fn get_span(f: ast::field_pat) -> codemap::span { return f.pat.span; }\n-        commasep_cmnt(s, consistent, fields,\n+        commasep_cmnt(s, consistent, *fields,\n                       |s, f| print_field(s,f,refutable),\n                       get_span);\n         if etc {\n-            if vec::len(fields) != 0u { word_space(s, ~\",\"); }\n+            if fields.len() != 0u { word_space(s, ~\",\"); }\n             word(s.s, ~\"_\");\n         }\n         word(s.s, ~\"}\");\n       }\n-      ast::pat_tup(elts) => {\n+      ast::pat_tup(ref elts) => {\n         popen(s);\n-        commasep(s, inconsistent, elts, |s, p| print_pat(s, p, refutable));\n+        commasep(s, inconsistent, *elts, |s, p| print_pat(s, p, refutable));\n         if elts.len() == 1 {\n             word(s.s, ~\",\");\n         }\n@@ -1606,9 +1606,9 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n         word(s.s, ~\"..\");\n         print_expr(s, end);\n       }\n-      ast::pat_vec(before, slice, after) => {\n+      ast::pat_vec(ref before, slice, ref after) => {\n         word(s.s, ~\"[\");\n-        do commasep(s, inconsistent, before) |s, p| {\n+        do commasep(s, inconsistent, *before) |s, p| {\n             print_pat(s, p, refutable);\n         }\n         for slice.each |&p| {\n@@ -1617,7 +1617,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n             print_pat(s, p, refutable);\n             if !after.is_empty() { word_space(s, ~\",\"); }\n         }\n-        do commasep(s, inconsistent, after) |s, p| {\n+        do commasep(s, inconsistent, *after) |s, p| {\n             print_pat(s, p, refutable);\n         }\n         word(s.s, ~\"]\");\n@@ -1832,12 +1832,12 @@ pub fn print_view_item(s: @ps, item: @ast::view_item) {\n     print_outer_attributes(s, item.attrs);\n     print_visibility(s, item.vis);\n     match item.node {\n-        ast::view_item_extern_mod(id, mta, _) => {\n+        ast::view_item_extern_mod(id, ref mta, _) => {\n             head(s, ~\"extern mod\");\n             print_ident(s, id);\n             if !mta.is_empty() {\n                 popen(s);\n-                commasep(s, consistent, mta, print_meta_item);\n+                commasep(s, consistent, *mta, print_meta_item);\n                 pclose(s);\n             }\n         }\n@@ -1960,7 +1960,7 @@ pub fn maybe_print_trailing_comment(s: @ps, span: codemap::span,\n         match next_pos { None => (), Some(p) => next = p }\n         if span.hi < (*cmnt).pos && (*cmnt).pos < next &&\n                span_line.line == comment_line.line {\n-            print_comment(s, (*cmnt));\n+            print_comment(s, cmnt);\n             s.cur_cmnt_and_lit.cur_cmnt += 1u;\n         }\n       }\n@@ -1975,7 +1975,7 @@ pub fn print_remaining_comments(s: @ps) {\n     loop {\n         match next_comment(s) {\n           Some(ref cmnt) => {\n-            print_comment(s, (*cmnt));\n+            print_comment(s, cmnt);\n             s.cur_cmnt_and_lit.cur_cmnt += 1u;\n           }\n           _ => break\n@@ -2055,7 +2055,7 @@ pub fn maybe_print_comment(s: @ps, pos: BytePos) {\n         match next_comment(s) {\n           Some(ref cmnt) => {\n             if (*cmnt).pos < pos {\n-                print_comment(s, (*cmnt));\n+                print_comment(s, cmnt);\n                 s.cur_cmnt_and_lit.cur_cmnt += 1u;\n             } else { break; }\n           }\n@@ -2064,7 +2064,7 @@ pub fn maybe_print_comment(s: @ps, pos: BytePos) {\n     }\n }\n \n-pub fn print_comment(s: @ps, cmnt: comments::cmnt) {\n+pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n     match cmnt.style {\n       comments::mixed => {\n         assert!((vec::len(cmnt.lines) == 1u));\n@@ -2274,7 +2274,7 @@ mod test {\n             vis: ast::public,\n         });\n \n-        let varstr = variant_to_str(var,mock_interner);\n+        let varstr = variant_to_str(&var,mock_interner);\n         assert_eq!(&varstr,&~\"pub principal_skinner\");\n     }\n }"}, {"sha": "8deca72779e5159adb57791e071fdfd66a411492", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -20,7 +20,6 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n #[deny(deprecated_pattern)];\n "}, {"sha": "4cfd54256f82e043efc72e9c394271f92e20c146", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767e3ae86cba26437a60009d79ac2a295b41768e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=767e3ae86cba26437a60009d79ac2a295b41768e", "patch": "@@ -179,7 +179,7 @@ pub fn visit_item<E: Copy>(i: @item, e: E, v: vt<E>) {\n         item_enum(ref enum_definition, ref tps) => {\n             (v.visit_generics)(tps, e, v);\n             visit_enum_def(\n-                *enum_definition,\n+                enum_definition,\n                 tps,\n                 e,\n                 v\n@@ -206,11 +206,11 @@ pub fn visit_item<E: Copy>(i: @item, e: E, v: vt<E>) {\n                 (v.visit_trait_method)(m, e, v);\n             }\n         }\n-        item_mac(ref m) => visit_mac((*m), e, v)\n+        item_mac(ref m) => visit_mac(m, e, v)\n     }\n }\n \n-pub fn visit_enum_def<E: Copy>(enum_definition: ast::enum_def,\n+pub fn visit_enum_def<E: Copy>(enum_definition: &ast::enum_def,\n                                tps: &Generics,\n                                e: E,\n                                v: vt<E>) {\n@@ -422,7 +422,7 @@ pub fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n       stmt_decl(d, _) => (v.visit_decl)(d, e, v),\n       stmt_expr(ex, _) => (v.visit_expr)(ex, e, v),\n       stmt_semi(ex, _) => (v.visit_expr)(ex, e, v),\n-      stmt_mac(ref mac, _) => visit_mac((*mac), e, v)\n+      stmt_mac(ref mac, _) => visit_mac(mac, e, v)\n     }\n }\n \n@@ -445,7 +445,7 @@ pub fn visit_exprs<E: Copy>(exprs: &[@expr], e: E, v: vt<E>) {\n     for exprs.each |ex| { (v.visit_expr)(*ex, e, v); }\n }\n \n-pub fn visit_mac<E>(_m: mac, _e: E, _v: vt<E>) {\n+pub fn visit_mac<E>(_m: &mac, _e: E, _v: vt<E>) {\n     /* no user-serviceable parts inside */\n }\n \n@@ -537,7 +537,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, e: E, v: vt<E>) {\n             (v.visit_expr)(lv, e, v);\n             (v.visit_expr)(x, e, v);\n         }\n-        expr_mac(ref mac) => visit_mac((*mac), e, v),\n+        expr_mac(ref mac) => visit_mac(mac, e, v),\n         expr_paren(x) => (v.visit_expr)(x, e, v),\n         expr_inline_asm(ref a) => {\n             for a.inputs.each |&(_, in)| {"}]}