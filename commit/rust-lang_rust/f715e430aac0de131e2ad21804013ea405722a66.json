{"sha": "f715e430aac0de131e2ad21804013ea405722a66", "node_id": "C_kwDOAAsO6NoAKGY3MTVlNDMwYWFjMGRlMTMxZTJhZDIxODA0MDEzZWE0MDU3MjJhNjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-21T04:22:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-21T04:22:23Z"}, "message": "Auto merge of #107728 - RalfJung:miri-dyn-star, r=RalfJung,oli-obk\n\nMiri: basic dyn* support\n\nAs usual I am very unsure about the dynamic dispatch stuff, but it passes even the `Pin<&mut dyn* Trait>` test so that is something.\n\nTBH I think it was a mistake to make `dyn Trait` and `dyn* Trait` part of the same `TyKind` variant. Almost everywhere in Miri this lead to the wrong default behavior, resulting in strange ICEs instead of nice \"unimplemented\" messages. The two types describe pretty different runtime data layout after all.\n\nStrangely I did not need to do the equivalent of [this diff](https://github.com/rust-lang/rust/pull/106532#discussion_r1087095963) in Miri. Maybe that is because the unsizing logic matches on `ty::Dynamic(.., ty::Dyn)` already? In `unsized_info` I don't think the `target_dyn_kind` can be `DynStar`, since then it wouldn't be unsized!\n\nr? `@oli-obk` Cc `@eholk` (dyn-star) https://github.com/rust-lang/rust/issues/102425", "tree": {"sha": "939698b73a07d4fb71bc0a27a9c8e0054986d42f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/939698b73a07d4fb71bc0a27a9c8e0054986d42f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f715e430aac0de131e2ad21804013ea405722a66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f715e430aac0de131e2ad21804013ea405722a66", "html_url": "https://github.com/rust-lang/rust/commit/f715e430aac0de131e2ad21804013ea405722a66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f715e430aac0de131e2ad21804013ea405722a66/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2deff71719a32af76eb4493ddb1dc4653fb88cad", "url": "https://api.github.com/repos/rust-lang/rust/commits/2deff71719a32af76eb4493ddb1dc4653fb88cad", "html_url": "https://github.com/rust-lang/rust/commit/2deff71719a32af76eb4493ddb1dc4653fb88cad"}, {"sha": "054c76d6580eb84139cb619c3dff8865828a9fbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/054c76d6580eb84139cb619c3dff8865828a9fbc", "html_url": "https://github.com/rust-lang/rust/commit/054c76d6580eb84139cb619c3dff8865828a9fbc"}], "stats": {"total": 405, "additions": 320, "deletions": 85}, "files": [{"sha": "2be5ed896ec808ea6fc431ad89d8c1c6f62b7436", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -312,6 +312,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n+    /// `src` is a *pointer to* a `source_ty`, and in `dest` we should store a pointer to th same\n+    /// data at type `cast_ty`.\n     fn unsize_into_ptr(\n         &mut self,\n         src: &OpTy<'tcx, M::Provenance>,\n@@ -335,7 +337,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 );\n                 self.write_immediate(val, dest)\n             }\n-            (ty::Dynamic(data_a, ..), ty::Dynamic(data_b, ..)) => {\n+            (ty::Dynamic(data_a, _, ty::Dyn), ty::Dynamic(data_b, _, ty::Dyn)) => {\n                 let val = self.read_immediate(src)?;\n                 if data_a.principal() == data_b.principal() {\n                     // A NOP cast that doesn't actually change anything, should be allowed even with mismatching vtables.\n@@ -359,7 +361,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             _ => {\n-                span_bug!(self.cur_span(), \"invalid unsizing {:?} -> {:?}\", src.layout.ty, cast_ty)\n+                span_bug!(\n+                    self.cur_span(),\n+                    \"invalid pointer unsizing {:?} -> {:?}\",\n+                    src.layout.ty,\n+                    cast_ty\n+                )\n             }\n         }\n     }"}, {"sha": "24b157054d3e49e895f89f7181881aec14fa3020", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -632,7 +632,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 Ok(Some((size, align)))\n             }\n-            ty::Dynamic(..) => {\n+            ty::Dynamic(_, _, ty::Dyn) => {\n                 let vtable = metadata.unwrap_meta().to_pointer(self)?;\n                 // Read size and align from vtable (already checks size).\n                 Ok(Some(self.get_vtable_size_and_align(vtable)?))"}, {"sha": "21ef1836188c02133b40f572aadb282ee705c79d", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -242,7 +242,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n             let mplace = self.ecx.ref_to_mplace(&value)?;\n             assert_eq!(mplace.layout.ty, referenced_ty);\n             // Handle trait object vtables.\n-            if let ty::Dynamic(..) =\n+            if let ty::Dynamic(_, _, ty::Dyn) =\n                 tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind()\n             {\n                 let ptr = mplace.meta.unwrap_meta().to_pointer(&tcx)?;"}, {"sha": "8d5192bca67e5deeeeed9abfb4598b4edffecd35", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -255,7 +255,22 @@ impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n         }\n     }\n \n-    pub fn offset_with_meta(\n+    /// Replace the layout of this operand. There's basically no sanity check that this makes sense,\n+    /// you better know what you are doing! If this is an immediate, applying the wrong layout can\n+    /// not just lead to invalid data, it can actually *shift the data around* since the offsets of\n+    /// a ScalarPair are entirely determined by the layout, not the data.\n+    pub fn transmute(&self, layout: TyAndLayout<'tcx>) -> Self {\n+        assert_eq!(\n+            self.layout.size, layout.size,\n+            \"transmuting with a size change, that doesn't seem right\"\n+        );\n+        OpTy { layout, ..*self }\n+    }\n+\n+    /// Offset the operand in memory (if possible) and change its metadata.\n+    ///\n+    /// This can go wrong very easily if you give the wrong layout for the new place!\n+    pub(super) fn offset_with_meta(\n         &self,\n         offset: Size,\n         meta: MemPlaceMeta<Prov>,\n@@ -276,6 +291,9 @@ impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n         }\n     }\n \n+    /// Offset the operand in memory (if possible).\n+    ///\n+    /// This can go wrong very easily if you give the wrong layout for the new place!\n     pub fn offset(\n         &self,\n         offset: Size,"}, {"sha": "244fa8030af73e0960ecd2b6a998c9a85e69bcd5", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 52, "deletions": 15, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -26,6 +26,7 @@ pub enum MemPlaceMeta<Prov: Provenance = AllocId> {\n }\n \n impl<Prov: Provenance> MemPlaceMeta<Prov> {\n+    #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn unwrap_meta(self) -> Scalar<Prov> {\n         match self {\n             Self::Meta(s) => s,\n@@ -147,12 +148,16 @@ impl<Prov: Provenance> MemPlace<Prov> {\n     }\n \n     #[inline]\n-    pub fn offset_with_meta<'tcx>(\n+    pub(super) fn offset_with_meta<'tcx>(\n         self,\n         offset: Size,\n         meta: MemPlaceMeta<Prov>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n+        debug_assert!(\n+            !meta.has_meta() || self.meta.has_meta(),\n+            \"cannot use `offset_with_meta` to add metadata to a place\"\n+        );\n         Ok(MemPlace { ptr: self.ptr.offset(offset, cx)?, meta })\n     }\n }\n@@ -182,8 +187,11 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n         MPlaceTy { mplace: MemPlace { ptr, meta: MemPlaceMeta::None }, layout, align }\n     }\n \n+    /// Offset the place in memory and change its metadata.\n+    ///\n+    /// This can go wrong very easily if you give the wrong layout for the new place!\n     #[inline]\n-    pub fn offset_with_meta(\n+    pub(crate) fn offset_with_meta(\n         &self,\n         offset: Size,\n         meta: MemPlaceMeta<Prov>,\n@@ -197,6 +205,9 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n         })\n     }\n \n+    /// Offset the place in memory.\n+    ///\n+    /// This can go wrong very easily if you give the wrong layout for the new place!\n     pub fn offset(\n         &self,\n         offset: Size,\n@@ -241,14 +252,6 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n             }\n         }\n     }\n-\n-    #[inline]\n-    pub(super) fn vtable(&self) -> Scalar<Prov> {\n-        match self.layout.ty.kind() {\n-            ty::Dynamic(..) => self.mplace.meta.unwrap_meta(),\n-            _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n-        }\n-    }\n }\n \n // These are defined here because they produce a place.\n@@ -266,7 +269,12 @@ impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Prov> {\n-        self.as_mplace_or_imm().left().unwrap()\n+        self.as_mplace_or_imm().left().unwrap_or_else(|| {\n+            bug!(\n+                \"OpTy of type {} was immediate when it was expected to be an MPlace\",\n+                self.layout.ty\n+            )\n+        })\n     }\n }\n \n@@ -283,7 +291,12 @@ impl<'tcx, Prov: Provenance> PlaceTy<'tcx, Prov> {\n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Prov> {\n-        self.as_mplace_or_local().left().unwrap()\n+        self.as_mplace_or_local().left().unwrap_or_else(|| {\n+            bug!(\n+                \"PlaceTy of type {} was a local when it was expected to be an MPlace\",\n+                self.layout.ty\n+            )\n+        })\n     }\n }\n \n@@ -807,11 +820,16 @@ where\n     }\n \n     /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type.\n+    /// Aso returns the vtable.\n     pub(super) fn unpack_dyn_trait(\n         &self,\n         mplace: &MPlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n-        let vtable = mplace.vtable().to_pointer(self)?; // also sanity checks the type\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::Provenance>, Pointer<Option<M::Provenance>>)> {\n+        assert!(\n+            matches!(mplace.layout.ty.kind(), ty::Dynamic(_, _, ty::Dyn)),\n+            \"`unpack_dyn_trait` only makes sense on `dyn*` types\"\n+        );\n+        let vtable = mplace.meta.unwrap_meta().to_pointer(self)?;\n         let (ty, _) = self.get_ptr_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n \n@@ -820,7 +838,26 @@ where\n             layout,\n             align: layout.align.abi,\n         };\n-        Ok(mplace)\n+        Ok((mplace, vtable))\n+    }\n+\n+    /// Turn an operand with a `dyn* Trait` type into an operand with the actual dynamic type.\n+    /// Aso returns the vtable.\n+    pub(super) fn unpack_dyn_star(\n+        &self,\n+        op: &OpTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (OpTy<'tcx, M::Provenance>, Pointer<Option<M::Provenance>>)> {\n+        assert!(\n+            matches!(op.layout.ty.kind(), ty::Dynamic(_, _, ty::DynStar)),\n+            \"`unpack_dyn_star` only makes sense on `dyn*` types\"\n+        );\n+        let data = self.operand_field(&op, 0)?;\n+        let vtable = self.operand_field(&op, 1)?;\n+        let vtable = self.read_pointer(&vtable)?;\n+        let (ty, _) = self.get_ptr_vtable(vtable)?;\n+        let layout = self.layout_of(ty)?;\n+        let data = data.transmute(layout);\n+        Ok((data, vtable))\n     }\n }\n "}, {"sha": "d934cfbbb84eaed16ce96056698ff8c436693d1b", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 69, "deletions": 38, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -547,7 +547,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let receiver_place = loop {\n                     match receiver.layout.ty.kind() {\n                         ty::Ref(..) | ty::RawPtr(..) => break self.deref_operand(&receiver)?,\n-                        ty::Dynamic(..) => break receiver.assert_mem_place(), // no immediate unsized values\n+                        ty::Dynamic(.., ty::Dyn) => break receiver.assert_mem_place(), // no immediate unsized values\n+                        ty::Dynamic(.., ty::DynStar) => {\n+                            // Not clear how to handle this, so far we assume the receiver is always a pointer.\n+                            span_bug!(\n+                                self.cur_span(),\n+                                \"by-value calls on a `dyn*`... are those a thing?\"\n+                            );\n+                        }\n                         _ => {\n                             // Not there yet, search for the only non-ZST field.\n                             let mut non_zst_field = None;\n@@ -573,39 +580,59 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         }\n                     }\n                 };\n-                // Obtain the underlying trait we are working on.\n-                let receiver_tail = self\n-                    .tcx\n-                    .struct_tail_erasing_lifetimes(receiver_place.layout.ty, self.param_env);\n-                let ty::Dynamic(data, ..) = receiver_tail.kind() else {\n-                    span_bug!(self.cur_span(), \"dynamic call on non-`dyn` type {}\", receiver_tail)\n-                };\n \n-                // Get the required information from the vtable.\n-                let vptr = receiver_place.meta.unwrap_meta().to_pointer(self)?;\n-                let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n-                if dyn_trait != data.principal() {\n-                    throw_ub_format!(\n-                        \"`dyn` call on a pointer whose vtable does not match its type\"\n-                    );\n-                }\n+                // Obtain the underlying trait we are working on, and the adjusted receiver argument.\n+                let (vptr, dyn_ty, adjusted_receiver) = if let ty::Dynamic(data, _, ty::DynStar) =\n+                    receiver_place.layout.ty.kind()\n+                {\n+                    let (recv, vptr) = self.unpack_dyn_star(&receiver_place.into())?;\n+                    let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n+                    if dyn_trait != data.principal() {\n+                        throw_ub_format!(\n+                            \"`dyn*` call on a pointer whose vtable does not match its type\"\n+                        );\n+                    }\n+                    let recv = recv.assert_mem_place(); // we passed an MPlaceTy to `unpack_dyn_star` so we definitely still have one\n+\n+                    (vptr, dyn_ty, recv.ptr)\n+                } else {\n+                    // Doesn't have to be a `dyn Trait`, but the unsized tail must be `dyn Trait`.\n+                    // (For that reason we also cannot use `unpack_dyn_trait`.)\n+                    let receiver_tail = self\n+                        .tcx\n+                        .struct_tail_erasing_lifetimes(receiver_place.layout.ty, self.param_env);\n+                    let ty::Dynamic(data, _, ty::Dyn) = receiver_tail.kind() else {\n+                            span_bug!(self.cur_span(), \"dynamic call on non-`dyn` type {}\", receiver_tail)\n+                        };\n+                    assert!(receiver_place.layout.is_unsized());\n+\n+                    // Get the required information from the vtable.\n+                    let vptr = receiver_place.meta.unwrap_meta().to_pointer(self)?;\n+                    let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n+                    if dyn_trait != data.principal() {\n+                        throw_ub_format!(\n+                            \"`dyn` call on a pointer whose vtable does not match its type\"\n+                        );\n+                    }\n+\n+                    // It might be surprising that we use a pointer as the receiver even if this\n+                    // is a by-val case; this works because by-val passing of an unsized `dyn\n+                    // Trait` to a function is actually desugared to a pointer.\n+                    (vptr, dyn_ty, receiver_place.ptr)\n+                };\n \n                 // Now determine the actual method to call. We can do that in two different ways and\n                 // compare them to ensure everything fits.\n                 let Some(ty::VtblEntry::Method(fn_inst)) = self.get_vtable_entries(vptr)?.get(idx).copied() else {\n                     throw_ub_format!(\"`dyn` call trying to call something that is not a method\")\n                 };\n+                trace!(\"Virtual call dispatches to {fn_inst:#?}\");\n                 if cfg!(debug_assertions) {\n                     let tcx = *self.tcx;\n \n                     let trait_def_id = tcx.trait_of_item(def_id).unwrap();\n                     let virtual_trait_ref =\n                         ty::TraitRef::from_method(tcx, trait_def_id, instance.substs);\n-                    assert_eq!(\n-                        receiver_tail,\n-                        virtual_trait_ref.self_ty(),\n-                        \"mismatch in underlying dyn trait computation within Miri and MIR building\",\n-                    );\n                     let existential_trait_ref =\n                         ty::ExistentialTraitRef::erase_self_ty(tcx, virtual_trait_ref);\n                     let concrete_trait_ref = existential_trait_ref.with_self_ty(tcx, dyn_ty);\n@@ -620,17 +647,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     assert_eq!(fn_inst, concrete_method);\n                 }\n \n-                // `*mut receiver_place.layout.ty` is almost the layout that we\n-                // want for args[0]: We have to project to field 0 because we want\n-                // a thin pointer.\n-                assert!(receiver_place.layout.is_unsized());\n-                let receiver_ptr_ty = self.tcx.mk_mut_ptr(receiver_place.layout.ty);\n-                let this_receiver_ptr = self.layout_of(receiver_ptr_ty)?.field(self, 0);\n-                // Adjust receiver argument.\n-                args[0] = OpTy::from(ImmTy::from_immediate(\n-                    Scalar::from_maybe_pointer(receiver_place.ptr, self).into(),\n-                    this_receiver_ptr,\n-                ));\n+                // Adjust receiver argument. Layout can be any (thin) ptr.\n+                args[0] = ImmTy::from_immediate(\n+                    Scalar::from_maybe_pointer(adjusted_receiver, self).into(),\n+                    self.layout_of(self.tcx.mk_mut_ptr(dyn_ty))?,\n+                )\n+                .into();\n                 trace!(\"Patched receiver operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(\n@@ -659,15 +681,24 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // implementation fail -- a problem shared by rustc.\n         let place = self.force_allocation(place)?;\n \n-        let (instance, place) = match place.layout.ty.kind() {\n-            ty::Dynamic(..) => {\n+        let place = match place.layout.ty.kind() {\n+            ty::Dynamic(_, _, ty::Dyn) => {\n                 // Dropping a trait object. Need to find actual drop fn.\n-                let place = self.unpack_dyn_trait(&place)?;\n-                let instance = ty::Instance::resolve_drop_in_place(*self.tcx, place.layout.ty);\n-                (instance, place)\n+                self.unpack_dyn_trait(&place)?.0\n+            }\n+            ty::Dynamic(_, _, ty::DynStar) => {\n+                // Dropping a `dyn*`. Need to find actual drop fn.\n+                self.unpack_dyn_star(&place.into())?.0.assert_mem_place()\n+            }\n+            _ => {\n+                debug_assert_eq!(\n+                    instance,\n+                    ty::Instance::resolve_drop_in_place(*self.tcx, place.layout.ty)\n+                );\n+                place\n             }\n-            _ => (instance, place),\n         };\n+        let instance = ty::Instance::resolve_drop_in_place(*self.tcx, place.layout.ty);\n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty())?;\n \n         let arg = ImmTy::from_immediate("}, {"sha": "e76d4c1728e90b3518d7573e987aa827c4a53b30", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -23,18 +23,18 @@ use std::hash::Hash;\n // for the validation errors\n use super::UndefinedBehaviorInfo::*;\n use super::{\n-    CheckInAllocMsg, GlobalAlloc, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy, Machine,\n-    MemPlaceMeta, OpTy, Scalar, ValueVisitor,\n+    AllocId, CheckInAllocMsg, GlobalAlloc, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy,\n+    Machine, MemPlaceMeta, OpTy, Pointer, Scalar, ValueVisitor,\n };\n \n macro_rules! throw_validation_failure {\n-    ($where:expr, { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )?) => {{\n+    ($where:expr, { $( $what_fmt:tt )* } $( expected { $( $expected_fmt:tt )* } )?) => {{\n         let mut msg = String::new();\n         msg.push_str(\"encountered \");\n-        write!(&mut msg, $($what_fmt),+).unwrap();\n+        write!(&mut msg, $($what_fmt)*).unwrap();\n         $(\n             msg.push_str(\", but expected \");\n-            write!(&mut msg, $($expected_fmt),+).unwrap();\n+            write!(&mut msg, $($expected_fmt)*).unwrap();\n         )?\n         let path = rustc_middle::ty::print::with_no_trimmed_paths!({\n             let where_ = &$where;\n@@ -82,7 +82,7 @@ macro_rules! throw_validation_failure {\n ///\n macro_rules! try_validation {\n     ($e:expr, $where:expr,\n-    $( $( $p:pat_param )|+ => { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )? ),+ $(,)?\n+    $( $( $p:pat_param )|+ => { $( $what_fmt:tt )* } $( expected { $( $expected_fmt:tt )* } )? ),+ $(,)?\n     ) => {{\n         match $e {\n             Ok(x) => x,\n@@ -93,7 +93,7 @@ macro_rules! try_validation {\n                     InterpError::UndefinedBehavior($($p)|+) =>\n                        throw_validation_failure!(\n                             $where,\n-                            { $( $what_fmt ),+ } $( expected { $( $expected_fmt ),+ } )?\n+                            { $( $what_fmt )* } $( expected { $( $expected_fmt )* } )?\n                         )\n                 ),+,\n                 #[allow(unreachable_patterns)]\n@@ -335,7 +335,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     ) -> InterpResult<'tcx> {\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n         match tail.kind() {\n-            ty::Dynamic(..) => {\n+            ty::Dynamic(_, _, ty::Dyn) => {\n                 let vtable = meta.unwrap_meta().to_pointer(self.ecx)?;\n                 // Make sure it is a genuine vtable pointer.\n                 let (_ty, _trait) = try_validation!(\n@@ -399,12 +399,15 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 {\n                     \"an unaligned {kind} (required {} byte alignment but found {})\",\n                     required.bytes(),\n-                    has.bytes()\n+                    has.bytes(),\n                 },\n             DanglingIntPointer(0, _) =>\n                 { \"a null {kind}\" },\n             DanglingIntPointer(i, _) =>\n-                { \"a dangling {kind} (address {i:#x} is unallocated)\" },\n+                {\n+                    \"a dangling {kind} ({pointer} has no provenance)\",\n+                    pointer = Pointer::<Option<AllocId>>::from_addr_invalid(*i),\n+                },\n             PointerOutOfBounds { .. } =>\n                 { \"a dangling {kind} (going beyond the bounds of its allocation)\" },\n             // This cannot happen during const-eval (because interning already detects"}, {"sha": "7a14459399c436640c9c2b08fbdea01d820e90c4", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -284,7 +284,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n         &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n-        // We `force_allocation` here so that `from_op` below can work.\n+        // No need for `force_allocation` since we are just going to read from this.\n         ecx.place_to_op(self)\n     }\n \n@@ -421,15 +421,25 @@ macro_rules! make_value_visitor {\n                 // Special treatment for special types, where the (static) layout is not sufficient.\n                 match *ty.kind() {\n                     // If it is a trait object, switch to the real type that was used to create it.\n-                    ty::Dynamic(..) => {\n+                    ty::Dynamic(_, _, ty::Dyn) => {\n+                        // Dyn types. This is unsized, and the actual dynamic type of the data is given by the\n+                        // vtable stored in the place metadata.\n                         // unsized values are never immediate, so we can assert_mem_place\n                         let op = v.to_op_for_read(self.ecx())?;\n                         let dest = op.assert_mem_place();\n-                        let inner_mplace = self.ecx().unpack_dyn_trait(&dest)?;\n+                        let inner_mplace = self.ecx().unpack_dyn_trait(&dest)?.0;\n                         trace!(\"walk_value: dyn object layout: {:#?}\", inner_mplace.layout);\n                         // recurse with the inner type\n                         return self.visit_field(&v, 0, &$value_trait::from_op(&inner_mplace.into()));\n                     },\n+                    ty::Dynamic(_, _, ty::DynStar) => {\n+                        // DynStar types. Very different from a dyn type (but strangely part of the\n+                        // same variant in `TyKind`): These are pairs where the 2nd component is the\n+                        // vtable, and the first component is the data (which must be ptr-sized).\n+                        let op = v.to_op_for_proj(self.ecx())?;\n+                        let data = self.ecx().unpack_dyn_star(&op)?.0;\n+                        return self.visit_field(&v, 0, &$value_trait::from_op(&data));\n+                    }\n                     // Slices do not need special handling here: they have `Array` field\n                     // placement with length 0, so we enter the `Array` case below which\n                     // indirectly uses the metadata to determine the actual length."}, {"sha": "ed3dd741a8be0fe64f6bd107e6c58063b65c9583", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -478,6 +478,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 } else if matches!(v.layout.fields, FieldsShape::Union(..)) {\n                     // A (non-frozen) union. We fall back to whatever the type says.\n                     (self.unsafe_cell_action)(v)\n+                } else if matches!(v.layout.ty.kind(), ty::Dynamic(_, _, ty::DynStar)) {\n+                    // This needs to read the vtable pointer to proceed type-driven, but we don't\n+                    // want to reentrantly read from memory here.\n+                    (self.unsafe_cell_action)(v)\n                 } else {\n                     // We want to not actually read from memory for this visit. So, before\n                     // walking this value, we have to make sure it is not a"}, {"sha": "d68b4b8dfc675bff6f1387c9cb29deaa5074c851", "filename": "src/tools/miri/tests/fail/branchless-select-i128-pointer.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbranchless-select-i128-pointer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbranchless-select-i128-pointer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbranchless-select-i128-pointer.stderr?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -1,12 +1,12 @@\n-error: Undefined Behavior: constructing invalid value: encountered a dangling reference (address $HEX is unallocated)\n+error: Undefined Behavior: constructing invalid value: encountered a dangling reference ($HEX[noalloc] has no provenance)\n   --> $DIR/branchless-select-i128-pointer.rs:LL:CC\n    |\n LL | /             transmute::<_, &str>(\n LL | |\n LL | |                 !mask & transmute::<_, TwoPtrs>(\"false !\")\n LL | |                     | mask & transmute::<_, TwoPtrs>(\"true !\"),\n LL | |             )\n-   | |_____________^ constructing invalid value: encountered a dangling reference (address $HEX is unallocated)\n+   | |_____________^ constructing invalid value: encountered a dangling reference ($HEX[noalloc] has no provenance)\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "fc3a9f344638f96d07fe6688bb5a040de653d95a", "filename": "src/tools/miri/tests/fail/validity/dangling_ref1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fvalidity%2Fdangling_ref1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fvalidity%2Fdangling_ref1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fvalidity%2Fdangling_ref1.rs?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -3,5 +3,5 @@\n use std::mem;\n \n fn main() {\n-    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR: encountered a dangling reference (address 0x10 is unallocated)\n+    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR: encountered a dangling reference\n }"}, {"sha": "830ab9ca501d8e6ae12c35e364eec41c7f0f2b74", "filename": "src/tools/miri/tests/fail/validity/dangling_ref1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fvalidity%2Fdangling_ref1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fvalidity%2Fdangling_ref1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fvalidity%2Fdangling_ref1.stderr?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: constructing invalid value: encountered a dangling reference (address 0x10 is unallocated)\n+error: Undefined Behavior: constructing invalid value: encountered a dangling reference (0x10[noalloc] has no provenance)\n   --> $DIR/dangling_ref1.rs:LL:CC\n    |\n LL |     let _x: &i32 = unsafe { mem::transmute(16usize) };\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x10 is unallocated)\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (0x10[noalloc] has no provenance)\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "16a8cec6cdae16c6ca7bac91c1cfb470d37f26a3", "filename": "src/tools/miri/tests/pass/dyn-star.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-star.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-star.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-star.rs?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -0,0 +1,116 @@\n+#![feature(dyn_star)]\n+#![allow(incomplete_features)]\n+\n+use std::fmt::{Debug, Display};\n+\n+fn main() {\n+    make_dyn_star();\n+    method();\n+    box_();\n+    dispatch_on_pin_mut();\n+    dyn_star_to_dyn();\n+    dyn_to_dyn_star();\n+}\n+\n+fn dyn_star_to_dyn() {\n+    let x: dyn* Debug = &42;\n+    let x = Box::new(x) as Box<dyn Debug>;\n+    assert_eq!(\"42\", format!(\"{x:?}\"));\n+}\n+\n+fn dyn_to_dyn_star() {\n+    let x: Box<dyn Debug> = Box::new(42);\n+    let x = &x as dyn* Debug;\n+    assert_eq!(\"42\", format!(\"{x:?}\"));\n+}\n+\n+fn make_dyn_star() {\n+    fn make_dyn_star_coercion(i: usize) {\n+        let _dyn_i: dyn* Debug = i;\n+    }\n+\n+    fn make_dyn_star_explicit(i: usize) {\n+        let _dyn_i: dyn* Debug = i as dyn* Debug;\n+    }\n+\n+    make_dyn_star_coercion(42);\n+    make_dyn_star_explicit(42);\n+}\n+\n+fn method() {\n+    trait Foo {\n+        fn get(&self) -> usize;\n+    }\n+    \n+    impl Foo for usize {\n+        fn get(&self) -> usize {\n+            *self\n+        }\n+    }\n+    \n+    fn invoke_dyn_star(i: dyn* Foo) -> usize {\n+        i.get()\n+    }\n+    \n+    fn make_and_invoke_dyn_star(i: usize) -> usize {\n+        let dyn_i: dyn* Foo = i;\n+        invoke_dyn_star(dyn_i)\n+    }\n+    \n+    assert_eq!(make_and_invoke_dyn_star(42), 42);\n+}\n+\n+fn box_() {\n+    fn make_dyn_star() -> dyn* Display {\n+        Box::new(42) as dyn* Display\n+    }\n+    \n+    let x = make_dyn_star();\n+    assert_eq!(format!(\"{x}\"), \"42\");\n+}\n+\n+fn dispatch_on_pin_mut() {\n+    use std::future::Future;\n+\n+    async fn foo(f: dyn* Future<Output = i32>) {\n+        println!(\"dispatch_on_pin_mut: value: {}\", f.await);\n+    }\n+\n+    async fn async_main() {\n+        foo(Box::pin(async { 1 })).await\n+    }\n+\n+    // ------------------------------------------------------------------------- //\n+    // Implementation Details Below...\n+\n+    use std::pin::Pin;\n+    use std::task::*;\n+\n+    pub fn noop_waker() -> Waker {\n+        let raw = RawWaker::new(std::ptr::null(), &NOOP_WAKER_VTABLE);\n+\n+        // SAFETY: the contracts for RawWaker and RawWakerVTable are upheld\n+        unsafe { Waker::from_raw(raw) }\n+    }\n+\n+    const NOOP_WAKER_VTABLE: RawWakerVTable = RawWakerVTable::new(noop_clone, noop, noop, noop);\n+\n+    unsafe fn noop_clone(_p: *const ()) -> RawWaker {\n+        RawWaker::new(std::ptr::null(), &NOOP_WAKER_VTABLE)\n+    }\n+\n+    unsafe fn noop(_p: *const ()) {}\n+\n+    let mut fut = async_main();\n+\n+    // Poll loop, just to test the future...\n+    let waker = noop_waker();\n+    let ctx = &mut Context::from_waker(&waker);\n+\n+    loop {\n+        match unsafe { Pin::new_unchecked(&mut fut).poll(ctx) } {\n+            Poll::Pending => {}\n+            Poll::Ready(()) => break,\n+        }\n+    }\n+}"}, {"sha": "e94427ee30531b4cbc8bc2786a635710e1dba177", "filename": "src/tools/miri/tests/pass/dyn-star.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-star.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-star.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-star.stdout?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -0,0 +1 @@\n+dispatch_on_pin_mut: value: 1"}, {"sha": "a0f8dd097c7955c3d663d7ae91b0dd5e71d021f6", "filename": "tests/ui/consts/const-eval/raw-bytes.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -167,7 +167,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:96:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (0x539[noalloc] has no provenance)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n@@ -178,7 +178,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:99:1\n    |\n LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (0x539[noalloc] has no provenance)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {"}, {"sha": "9706f3ec2e01b3da7d95a874e5269a40d84c91d7", "filename": "tests/ui/consts/const-eval/raw-bytes.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -167,7 +167,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:96:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (0x539[noalloc] has no provenance)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n@@ -178,7 +178,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:99:1\n    |\n LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (0x539[noalloc] has no provenance)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {"}, {"sha": "6bd367b646902c07484f8658cb0a63eff096b521", "filename": "tests/ui/consts/const-eval/ub-ref-ptr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -85,7 +85,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:43:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (0x539[noalloc] has no provenance)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n@@ -96,7 +96,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:46:1\n    |\n LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (0x539[noalloc] has no provenance)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {"}, {"sha": "1d974b7ecb211f744893e1ea508d1e53b71c9a97", "filename": "tests/ui/dyn-star/dyn-star-to-dyn.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f715e430aac0de131e2ad21804013ea405722a66/tests%2Fui%2Fdyn-star%2Fdyn-star-to-dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f715e430aac0de131e2ad21804013ea405722a66/tests%2Fui%2Fdyn-star%2Fdyn-star-to-dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fdyn-star-to-dyn.rs?ref=f715e430aac0de131e2ad21804013ea405722a66", "patch": "@@ -1,9 +1,17 @@\n-// build-pass\n+// run-pass\n \n #![feature(dyn_star)]\n //~^ WARN the feature `dyn_star` is incomplete and may not be safe to use and/or cause compiler crashes\n \n+use std::fmt::Debug;\n+\n fn main() {\n-    let x: dyn* Send = &();\n-    let x = Box::new(x) as Box<dyn Send>;\n+    let x: dyn* Debug = &42;\n+    let x = Box::new(x) as Box<dyn Debug>;\n+    assert_eq!(\"42\", format!(\"{x:?}\"));\n+\n+    // Also test opposite direction.\n+    let x: Box<dyn Debug> = Box::new(42);\n+    let x = &x as dyn* Debug;\n+    assert_eq!(\"42\", format!(\"{x:?}\"));\n }"}]}