{"sha": "e01e883e4f2e86961f02ce3041e4773a04286cfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMWU4ODNlNGYyZTg2OTYxZjAyY2UzMDQxZTQ3NzNhMDQyODZjZmI=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-06-26T22:00:24Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-07-01T15:14:25Z"}, "message": "Introduce new categories and show a reasonable error message.", "tree": {"sha": "89f54ffc337ac17292a99e3b96dda763d7d01429", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89f54ffc337ac17292a99e3b96dda763d7d01429"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e01e883e4f2e86961f02ce3041e4773a04286cfb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAls479EACgkQAXYLT59T\n8VQ7Xg//QZ8ybxQf2EHnwcSRyRUlBPGzW4C/aGZX+wMbq7bwJO/UkLhGy31R7N5I\n6dXZkcXkk9uNDI2747EXfwLDA9oy/C7bzdrq+35vAaMQ8qsDQb/ukhOEGfBxFbay\nQ5dBDq1UjnIuXMog9VKgcb8L8g8g6h4oS7vjooV7iTwTXsRzI7v6zxWvoHORoQyw\nW50FptW2Vh5qKP6E61rKoxPrcGmR65UV5NKcZCks+T36WvncHepdmW+dB61bXjqZ\nq1DLmeCuVQRCnJVGh9Z2LzROuWtFO+irNeBv88q1rFjWqg4t3Rj3X5cOy+qbQTbn\nR/j89M9b5cbghMHyzVr2zT40RVN8v9aHkjxDSsejmTLVCpSc3GsDltUp0inJO8Ys\njqrjn9w1tnAGyuKE8EuRt2CpUISezkAJ+XiO1NitCouIbRuVA+hr7GV2hDUgY+4b\ndZXBZt2D+0y5zfqM47BMp/77r30FVdZyNFJPjvWWO+QIVABnxtTuNoNWSxRwbpK2\nehEZGMyubuMjug3jG5yCjHDZYGpKTKyuHf+phZjBKfcTeI2XreZlBXtcdBdKhLt1\nGNexXjldUDATJP1OBFnTRui6DmCcZD9sLWiVz1LDBqItBoBP/jJMnJwsXtmP0fzo\nmrAADwPIqm4X4yHXHIzuniRllbA6Rj+0AIfPbXCNdvu8WYH8UbE=\n=q67m\n-----END PGP SIGNATURE-----", "payload": "tree 89f54ffc337ac17292a99e3b96dda763d7d01429\nparent 27ce0cca8e93885d16890e712a7bc4ac27475176\nauthor David Wood <david@davidtw.co> 1530050424 +0100\ncommitter David Wood <david@davidtw.co> 1530458065 +0100\n\nIntroduce new categories and show a reasonable error message.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e01e883e4f2e86961f02ce3041e4773a04286cfb", "html_url": "https://github.com/rust-lang/rust/commit/e01e883e4f2e86961f02ce3041e4773a04286cfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e01e883e4f2e86961f02ce3041e4773a04286cfb/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27ce0cca8e93885d16890e712a7bc4ac27475176", "url": "https://api.github.com/repos/rust-lang/rust/commits/27ce0cca8e93885d16890e712a7bc4ac27475176", "html_url": "https://github.com/rust-lang/rust/commit/27ce0cca8e93885d16890e712a7bc4ac27475176"}], "stats": {"total": 100, "additions": 58, "deletions": 42}, "files": [{"sha": "cc78043b83cceedcb2e95e4e9acbd4ad8dd40dcf", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting.rs", "status": "modified", "additions": 58, "deletions": 42, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e01e883e4f2e86961f02ce3041e4773a04286cfb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e01e883e4f2e86961f02ce3041e4773a04286cfb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs?ref=e01e883e4f2e86961f02ce3041e4773a04286cfb", "patch": "@@ -8,26 +8,42 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::fmt;\n use borrow_check::nll::region_infer::{Cause, ConstraintIndex, RegionInferenceContext};\n use borrow_check::nll::region_infer::values::ToElementIndex;\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc::mir::{Location, Mir, StatementKind, TerminatorKind, Rvalue};\n+use rustc::mir::{self, Location, Mir, Place, StatementKind, TerminatorKind, Rvalue};\n use rustc::ty::RegionVid;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n use syntax_pos::Span;\n \n /// Constraints that are considered interesting can be categorized to\n-/// determine why they are interesting.\n+/// determine why they are interesting. Order of variants indicates\n+/// sort order of the category, thereby influencing diagnostic output.\n #[derive(Debug, Eq, PartialEq, PartialOrd, Ord)]\n enum ConstraintCategory {\n-    Assignment,\n     Cast,\n+    Assignment,\n+    Return,\n     CallArgument,\n     Other,\n+    Boring,\n+}\n+\n+impl fmt::Display for ConstraintCategory {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            ConstraintCategory::Assignment => write!(f, \"Assignment\"),\n+            ConstraintCategory::Return => write!(f, \"Return\"),\n+            ConstraintCategory::Cast => write!(f, \"Cast\"),\n+            ConstraintCategory::CallArgument => write!(f, \"Argument\"),\n+            _ => write!(f, \"Free region\"),\n+        }\n+    }\n }\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n@@ -132,9 +148,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// This function classifies a constraint from a location.\n-    fn classify_constraint(&self, location: Location, mir: &Mir<'tcx>) -> ConstraintCategory {\n+    fn classify_constraint(&self, index: &ConstraintIndex,\n+                           mir: &Mir<'tcx>) -> Option<(ConstraintCategory, Span)> {\n+        let constraint = self.constraints.get(*index)?;\n+        let span = constraint.locations.span(mir);\n+        let location = constraint.locations.from_location()?;\n+\n+        if !self.constraint_is_interesting(index) {\n+            return Some((ConstraintCategory::Boring, span));\n+        }\n+\n         let data = &mir[location.block];\n-        if location.statement_index == data.statements.len() {\n+        let category = if location.statement_index == data.statements.len() {\n             if let Some(ref terminator) = data.terminator {\n                 match terminator.kind {\n                     TerminatorKind::DropAndReplace { .. } => ConstraintCategory::Assignment,\n@@ -147,14 +172,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         } else {\n             let statement = &data.statements[location.statement_index];\n             match statement.kind {\n-                StatementKind::Assign(_, ref rvalue) => match rvalue {\n-                    Rvalue::Cast(..) => ConstraintCategory::Cast,\n-                    Rvalue::Use(..) => ConstraintCategory::Assignment,\n-                    _ => ConstraintCategory::Other,\n+                StatementKind::Assign(ref place, ref rvalue) => {\n+                    if *place == Place::Local(mir::RETURN_PLACE) {\n+                        ConstraintCategory::Return\n+                    } else {\n+                        match rvalue {\n+                            Rvalue::Cast(..) => ConstraintCategory::Cast,\n+                            Rvalue::Use(..) => ConstraintCategory::Assignment,\n+                            _ => ConstraintCategory::Other,\n+                        }\n+                    }\n                 },\n                 _ => ConstraintCategory::Other,\n             }\n-        }\n+        };\n+\n+        Some((category, span))\n     }\n \n     /// Report an error because the universal region `fr` was required to outlive\n@@ -187,53 +220,36 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n+        let fr_string = match fr_name {\n+            Some(r) => format!(\"free region `{}`\", r),\n+            None => format!(\"free region `{:?}`\", fr),\n+        };\n+\n+        let outlived_fr_string = match outlived_fr_name {\n+            Some(r) => format!(\"free region `{}`\", r),\n+            None => format!(\"free region `{:?}`\", outlived_fr),\n+        };\n+\n         let constraints = self.find_constraint_paths_from_region(fr.clone());\n         let path = constraints.iter().min_by_key(|p| p.len()).unwrap();\n-        debug!(\"report_error: path={:?}\", path);\n-\n-        let path = path.iter()\n-            .filter(|index| self.constraint_is_interesting(index))\n-            .collect::<Vec<&ConstraintIndex>>();\n-        debug!(\"report_error: path={:?}\", path);\n+        debug!(\"report_error: shortest_path={:?}\", path);\n \n         let mut categorized_path = path.iter().filter_map(|index| {\n-            self.constraints.get(**index).iter().filter_map(|constraint| {\n-                let span = constraint.locations.span(mir);\n-                constraint.locations.from_location().iter().filter_map(|location| {\n-                    let classification = self.classify_constraint(*location, mir);\n-                    Some((classification, span))\n-                }).next()\n-            }).next()\n+            self.classify_constraint(index, mir)\n         }).collect::<Vec<(ConstraintCategory, Span)>>();\n         debug!(\"report_error: categorized_path={:?}\", categorized_path);\n \n         categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n         debug!(\"report_error: sorted_path={:?}\", categorized_path);\n \n-        if categorized_path.len() > 0 {\n-            let blame_constraint = &categorized_path[0];\n-\n+        if let Some((category, span)) = &categorized_path.first() {\n             let mut diag = infcx.tcx.sess.struct_span_err(\n-                blame_constraint.1,\n-                &format!(\"{:?}\", blame_constraint.0),\n+                *span, &format!(\"{} requires that data must outlive {}\",\n+                                category, outlived_fr_string),\n             );\n \n-            for secondary in categorized_path.iter().skip(1) {\n-                diag.span_label(secondary.1, format!(\"{:?}\", secondary.0));\n-            }\n-\n             diag.emit();\n         } else {\n-            let fr_string = match fr_name {\n-                Some(r) => format!(\"free region `{}`\", r),\n-                None => format!(\"free region `{:?}`\", fr),\n-            };\n-\n-            let outlived_fr_string = match outlived_fr_name {\n-                Some(r) => format!(\"free region `{}`\", r),\n-                None => format!(\"free region `{:?}`\", outlived_fr),\n-            };\n-\n             let mut diag = infcx.tcx.sess.struct_span_err(\n                 blame_span,\n                 &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),"}]}