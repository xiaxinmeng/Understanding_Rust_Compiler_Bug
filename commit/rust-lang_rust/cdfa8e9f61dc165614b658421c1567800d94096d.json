{"sha": "cdfa8e9f61dc165614b658421c1567800d94096d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkZmE4ZTlmNjFkYzE2NTYxNGI2NTg0MjFjMTU2NzgwMGQ5NDA5NmQ=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-08-08T11:27:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-08T11:27:12Z"}, "message": "Merge pull request #1146 from birkenfeld/housekeeping\n\nSome housekeeping on lint descriptions", "tree": {"sha": "e13754676c234c89e455da41ad6daceee3606463", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e13754676c234c89e455da41ad6daceee3606463"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdfa8e9f61dc165614b658421c1567800d94096d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdfa8e9f61dc165614b658421c1567800d94096d", "html_url": "https://github.com/rust-lang/rust/commit/cdfa8e9f61dc165614b658421c1567800d94096d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdfa8e9f61dc165614b658421c1567800d94096d/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74c78805970548980d6e3d58e0d3305d27a30670", "url": "https://api.github.com/repos/rust-lang/rust/commits/74c78805970548980d6e3d58e0d3305d27a30670", "html_url": "https://github.com/rust-lang/rust/commit/74c78805970548980d6e3d58e0d3305d27a30670"}, {"sha": "9a221402e6086678c921b77eef4b676cbdefb8ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a221402e6086678c921b77eef4b676cbdefb8ae", "html_url": "https://github.com/rust-lang/rust/commit/9a221402e6086678c921b77eef4b676cbdefb8ae"}], "stats": {"total": 2585, "additions": 1416, "deletions": 1169}, "files": [{"sha": "a6b636709c5231ddd9de23898cea2e2e9a5609a2", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -7,6 +7,7 @@ out\n *.so\n *.rlib\n *.dll\n+*.pyc\n \n # Executables\n *.exe"}, {"sha": "8734242c6c016eac7e806205edf449b71951bf59", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -42,13 +42,16 @@ travis build actually checks for this.\n \n Also please document your lint with a doc comment akin to the following:\n ```rust\n-/// **What it does:** Describe what the lint matches.\n+/// **What it does:** Checks for ... (describe what the lint matches).\n ///\n-/// **Why is this bad?** Write the reason for linting the code.\n+/// **Why is this bad?** Supply the reason for linting the code.\n ///\n-/// **Known problems:** Hopefully none.\n+/// **Known problems:** None. (Or describe where it could go wrong.)\n ///\n-/// **Example:** Insert a short example if you have one\n+/// **Example:**\n+/// ```rust\n+/// Insert a short example if you have one.\n+/// ```\n ```\n \n Our `util/update_wiki.py` script can then add your lint docs to the wiki."}, {"sha": "b5e69b918b364ff79884e3506b3fe04b010e3188", "filename": "README.md", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -19,86 +19,86 @@ Table of contents:\n \n There are 162 lints included in this crate:\n \n-name                                                                                                                 | default | meaning\n----------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n-[absurd_extreme_comparisons](https://github.com/Manishearth/rust-clippy/wiki#absurd_extreme_comparisons)             | warn    | a comparison involving a maximum or minimum value involves a case that is always true or always false\n+name                                                                                                                 | default | triggers on\n+---------------------------------------------------------------------------------------------------------------------|---------|----------------------------------------------------------------------------------------------------------------------------------\n+[absurd_extreme_comparisons](https://github.com/Manishearth/rust-clippy/wiki#absurd_extreme_comparisons)             | warn    | a comparison with a maximum or minimum value that is always true or false\n [almost_swapped](https://github.com/Manishearth/rust-clippy/wiki#almost_swapped)                                     | warn    | `foo = bar; bar = foo` sequence\n-[approx_constant](https://github.com/Manishearth/rust-clippy/wiki#approx_constant)                                   | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n+[approx_constant](https://github.com/Manishearth/rust-clippy/wiki#approx_constant)                                   | warn    | the approximate of a known float constant (in `std::fXX::consts`)\n [assign_op_pattern](https://github.com/Manishearth/rust-clippy/wiki#assign_op_pattern)                               | warn    | assigning the result of an operation on a variable to that same variable\n-[assign_ops](https://github.com/Manishearth/rust-clippy/wiki#assign_ops)                                             | allow   | any assignment operation\n-[bad_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask)                                         | warn    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n+[assign_ops](https://github.com/Manishearth/rust-clippy/wiki#assign_ops)                                             | allow   | any compound assignment operation\n+[bad_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask)                                         | warn    | expressions of the form `_ & mask == select` that will only ever return `true` or `false`\n [blacklisted_name](https://github.com/Manishearth/rust-clippy/wiki#blacklisted_name)                                 | warn    | usage of a blacklisted/placeholder name\n-[block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr)             | warn    | braces can be eliminated in conditions that are expressions, e.g `if { true } ...`\n-[block_in_if_condition_stmt](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_stmt)             | warn    | avoid complex blocks in conditions, instead move the block higher and bind it with 'let'; e.g: `if { let x = true; x } ...`\n+[block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr)             | warn    | braces that can be eliminated in conditions, e.g `if { true } ...`\n+[block_in_if_condition_stmt](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_stmt)             | warn    | complex blocks in conditions, e.g. `if { let x = true; x } ...`\n [bool_comparison](https://github.com/Manishearth/rust-clippy/wiki#bool_comparison)                                   | warn    | comparing a variable to a boolean, e.g. `if x == true`\n [box_vec](https://github.com/Manishearth/rust-clippy/wiki#box_vec)                                                   | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n [boxed_local](https://github.com/Manishearth/rust-clippy/wiki#boxed_local)                                           | warn    | using `Box<T>` where unnecessary\n [cast_possible_truncation](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_truncation)                 | allow   | casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\n [cast_possible_wrap](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_wrap)                             | allow   | casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\n [cast_precision_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_precision_loss)                           | allow   | casts that cause loss of precision, e.g `x as f32` where `x: u64`\n [cast_sign_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_sign_loss)                                     | allow   | casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\n-[char_lit_as_u8](https://github.com/Manishearth/rust-clippy/wiki#char_lit_as_u8)                                     | warn    | Casting a character literal to u8\n+[char_lit_as_u8](https://github.com/Manishearth/rust-clippy/wiki#char_lit_as_u8)                                     | warn    | casting a character literal to u8\n [chars_next_cmp](https://github.com/Manishearth/rust-clippy/wiki#chars_next_cmp)                                     | warn    | using `.chars().next()` to check if a string starts with a char\n [clone_double_ref](https://github.com/Manishearth/rust-clippy/wiki#clone_double_ref)                                 | warn    | using `clone` on `&&T`\n [clone_on_copy](https://github.com/Manishearth/rust-clippy/wiki#clone_on_copy)                                       | warn    | using `clone` on a `Copy` type\n-[cmp_nan](https://github.com/Manishearth/rust-clippy/wiki#cmp_nan)                                                   | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n+[cmp_nan](https://github.com/Manishearth/rust-clippy/wiki#cmp_nan)                                                   | deny    | comparisons to NAN, which will always return false, probably not intended\n [cmp_owned](https://github.com/Manishearth/rust-clippy/wiki#cmp_owned)                                               | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n [collapsible_if](https://github.com/Manishearth/rust-clippy/wiki#collapsible_if)                                     | warn    | `if`s that can be collapsed (e.g. `if x { if y { ... } }` and `else { if x { ... } }`)\n [crosspointer_transmute](https://github.com/Manishearth/rust-clippy/wiki#crosspointer_transmute)                     | warn    | transmutes that have to or from types that are a pointer to the other\n-[cyclomatic_complexity](https://github.com/Manishearth/rust-clippy/wiki#cyclomatic_complexity)                       | warn    | finds functions that should be split up into multiple functions\n-[deprecated_semver](https://github.com/Manishearth/rust-clippy/wiki#deprecated_semver)                               | warn    | `Warn` on `#[deprecated(since = \"x\")]` where x is not semver\n+[cyclomatic_complexity](https://github.com/Manishearth/rust-clippy/wiki#cyclomatic_complexity)                       | warn    | functions that should be split up into multiple functions\n+[deprecated_semver](https://github.com/Manishearth/rust-clippy/wiki#deprecated_semver)                               | warn    | use of `#[deprecated(since = \"x\")]` where x is not semver\n [derive_hash_xor_eq](https://github.com/Manishearth/rust-clippy/wiki#derive_hash_xor_eq)                             | warn    | deriving `Hash` but implementing `PartialEq` explicitly\n-[doc_markdown](https://github.com/Manishearth/rust-clippy/wiki#doc_markdown)                                         | warn    | checks for the presence of `_`, `::` or camel-case outside ticks in documentation\n-[double_neg](https://github.com/Manishearth/rust-clippy/wiki#double_neg)                                             | warn    | `--x` is a double negation of `x` and not a pre-decrement as in C or C++\n-[drop_ref](https://github.com/Manishearth/rust-clippy/wiki#drop_ref)                                                 | warn    | call to `std::mem::drop` with a reference instead of an owned value, which will not call the `Drop::drop` method on the underlying value\n-[duplicate_underscore_argument](https://github.com/Manishearth/rust-clippy/wiki#duplicate_underscore_argument)       | warn    | Function arguments having names which only differ by an underscore\n-[empty_loop](https://github.com/Manishearth/rust-clippy/wiki#empty_loop)                                             | warn    | empty `loop {}` detected\n-[enum_clike_unportable_variant](https://github.com/Manishearth/rust-clippy/wiki#enum_clike_unportable_variant)       | warn    | finds C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`\n-[enum_glob_use](https://github.com/Manishearth/rust-clippy/wiki#enum_glob_use)                                       | allow   | finds use items that import all variants of an enum\n-[enum_variant_names](https://github.com/Manishearth/rust-clippy/wiki#enum_variant_names)                             | warn    | finds enums where all variants share a prefix/postfix\n+[doc_markdown](https://github.com/Manishearth/rust-clippy/wiki#doc_markdown)                                         | warn    | presence of `_`, `::` or camel-case outside backticks in documentation\n+[double_neg](https://github.com/Manishearth/rust-clippy/wiki#double_neg)                                             | warn    | `--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\n+[drop_ref](https://github.com/Manishearth/rust-clippy/wiki#drop_ref)                                                 | warn    | calls to `std::mem::drop` with a reference instead of an owned value\n+[duplicate_underscore_argument](https://github.com/Manishearth/rust-clippy/wiki#duplicate_underscore_argument)       | warn    | function arguments having names which only differ by an underscore\n+[empty_loop](https://github.com/Manishearth/rust-clippy/wiki#empty_loop)                                             | warn    | empty `loop {}`, which should block or sleep\n+[enum_clike_unportable_variant](https://github.com/Manishearth/rust-clippy/wiki#enum_clike_unportable_variant)       | warn    | C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`\n+[enum_glob_use](https://github.com/Manishearth/rust-clippy/wiki#enum_glob_use)                                       | allow   | use items that import all variants of an enum\n+[enum_variant_names](https://github.com/Manishearth/rust-clippy/wiki#enum_variant_names)                             | warn    | enums where all variants share a prefix/postfix\n [eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                                       | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n [expl_impl_clone_on_copy](https://github.com/Manishearth/rust-clippy/wiki#expl_impl_clone_on_copy)                   | warn    | implementing `Clone` explicitly on `Copy` types\n [explicit_counter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop)                       | warn    | for-looping with an explicit counter when `_.enumerate()` would do\n [explicit_iter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop)                             | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n [extend_from_slice](https://github.com/Manishearth/rust-clippy/wiki#extend_from_slice)                               | warn    | `.extend_from_slice(_)` is a faster way to extend a Vec by a slice\n [filter_map](https://github.com/Manishearth/rust-clippy/wiki#filter_map)                                             | allow   | using combinations of `filter`, `map`, `filter_map` and `flat_map` which can usually be written as a single method call\n [filter_next](https://github.com/Manishearth/rust-clippy/wiki#filter_next)                                           | warn    | using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\n-[float_arithmetic](https://github.com/Manishearth/rust-clippy/wiki#float_arithmetic)                                 | allow   | Any floating-point arithmetic statement\n-[float_cmp](https://github.com/Manishearth/rust-clippy/wiki#float_cmp)                                               | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n+[float_arithmetic](https://github.com/Manishearth/rust-clippy/wiki#float_arithmetic)                                 | allow   | any floating-point arithmetic statement\n+[float_cmp](https://github.com/Manishearth/rust-clippy/wiki#float_cmp)                                               | warn    | using `==` or `!=` on float values instead of comparing difference with an epsilon\n [for_kv_map](https://github.com/Manishearth/rust-clippy/wiki#for_kv_map)                                             | warn    | looping on a map using `iter` when `keys` or `values` would do\n [for_loop_over_option](https://github.com/Manishearth/rust-clippy/wiki#for_loop_over_option)                         | warn    | for-looping over an `Option`, which is more clearly expressed as an `if let`\n [for_loop_over_result](https://github.com/Manishearth/rust-clippy/wiki#for_loop_over_result)                         | warn    | for-looping over a `Result`, which is more clearly expressed as an `if let`\n [identity_op](https://github.com/Manishearth/rust-clippy/wiki#identity_op)                                           | warn    | using identity operations, e.g. `x + 0` or `y / 1`\n-[if_not_else](https://github.com/Manishearth/rust-clippy/wiki#if_not_else)                                           | allow   | finds if branches that could be swapped so no negation operation is necessary on the condition\n+[if_not_else](https://github.com/Manishearth/rust-clippy/wiki#if_not_else)                                           | allow   | `if` branches that could be swapped so no negation operation is necessary on the condition\n [if_same_then_else](https://github.com/Manishearth/rust-clippy/wiki#if_same_then_else)                               | warn    | if with the same *then* and *else* blocks\n [ifs_same_cond](https://github.com/Manishearth/rust-clippy/wiki#ifs_same_cond)                                       | warn    | consecutive `ifs` with the same condition\n [indexing_slicing](https://github.com/Manishearth/rust-clippy/wiki#indexing_slicing)                                 | allow   | indexing/slicing usage\n [ineffective_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask)                         | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n-[inline_always](https://github.com/Manishearth/rust-clippy/wiki#inline_always)                                       | warn    | `#[inline(always)]` is a bad idea in most cases\n-[integer_arithmetic](https://github.com/Manishearth/rust-clippy/wiki#integer_arithmetic)                             | allow   | Any integer arithmetic statement\n-[invalid_regex](https://github.com/Manishearth/rust-clippy/wiki#invalid_regex)                                       | deny    | finds invalid regular expressions\n+[inline_always](https://github.com/Manishearth/rust-clippy/wiki#inline_always)                                       | warn    | use of `#[inline(always)]`\n+[integer_arithmetic](https://github.com/Manishearth/rust-clippy/wiki#integer_arithmetic)                             | allow   | any integer arithmetic statement\n+[invalid_regex](https://github.com/Manishearth/rust-clippy/wiki#invalid_regex)                                       | deny    | invalid regular expressions\n [invalid_upcast_comparisons](https://github.com/Manishearth/rust-clippy/wiki#invalid_upcast_comparisons)             | allow   | a comparison involving an upcast which is always true or false\n-[items_after_statements](https://github.com/Manishearth/rust-clippy/wiki#items_after_statements)                     | allow   | finds blocks where an item comes after a statement\n+[items_after_statements](https://github.com/Manishearth/rust-clippy/wiki#items_after_statements)                     | allow   | blocks where an item comes after a statement\n [iter_next_loop](https://github.com/Manishearth/rust-clippy/wiki#iter_next_loop)                                     | warn    | for-looping over `_.next()` which is probably not intended\n [iter_nth](https://github.com/Manishearth/rust-clippy/wiki#iter_nth)                                                 | warn    | using `.iter().nth()` on a standard library type with O(1) element access\n [len_without_is_empty](https://github.com/Manishearth/rust-clippy/wiki#len_without_is_empty)                         | warn    | traits and impls that have `.len()` but not `.is_empty()`\n [len_zero](https://github.com/Manishearth/rust-clippy/wiki#len_zero)                                                 | warn    | checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\n [let_and_return](https://github.com/Manishearth/rust-clippy/wiki#let_and_return)                                     | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\n [let_unit_value](https://github.com/Manishearth/rust-clippy/wiki#let_unit_value)                                     | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n [linkedlist](https://github.com/Manishearth/rust-clippy/wiki#linkedlist)                                             | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\n-[logic_bug](https://github.com/Manishearth/rust-clippy/wiki#logic_bug)                                               | warn    | checks for boolean expressions that contain terminals which can be eliminated\n-[manual_swap](https://github.com/Manishearth/rust-clippy/wiki#manual_swap)                                           | warn    | manual swap\n+[logic_bug](https://github.com/Manishearth/rust-clippy/wiki#logic_bug)                                               | warn    | boolean expressions that contain terminals which can be eliminated\n+[manual_swap](https://github.com/Manishearth/rust-clippy/wiki#manual_swap)                                           | warn    | manual swap of two variables\n [many_single_char_names](https://github.com/Manishearth/rust-clippy/wiki#many_single_char_names)                     | warn    | too many single character bindings\n-[map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                               | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends `.cloned()` instead)\n+[map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                               | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents\n [map_entry](https://github.com/Manishearth/rust-clippy/wiki#map_entry)                                               | warn    | use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\n-[match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                                             | warn    | a match on boolean expression; recommends `if..else` block instead\n-[match_overlapping_arm](https://github.com/Manishearth/rust-clippy/wiki#match_overlapping_arm)                       | warn    | a match has overlapping arms\n-[match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                                     | warn    | a match or `if let` has all arms prefixed with `&`; the match expression can be dereferenced instead\n+[match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                                             | warn    | a match on a boolean expression instead of an `if..else` block\n+[match_overlapping_arm](https://github.com/Manishearth/rust-clippy/wiki#match_overlapping_arm)                       | warn    | a match with overlapping arms\n+[match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                                     | warn    | a match or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\n [match_same_arms](https://github.com/Manishearth/rust-clippy/wiki#match_same_arms)                                   | warn    | `match` with identical arm bodies\n-[mem_forget](https://github.com/Manishearth/rust-clippy/wiki#mem_forget)                                             | allow   | `mem::forget` usage on `Drop` types is likely to cause memory leaks\n+[mem_forget](https://github.com/Manishearth/rust-clippy/wiki#mem_forget)                                             | allow   | `mem::forget` usage on `Drop` types, likely to cause memory leaks\n [min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                                   | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n [misrefactored_assign_op](https://github.com/Manishearth/rust-clippy/wiki#misrefactored_assign_op)                   | warn    | having a variable on both sides of an assign op\n-[mixed_case_hex_literals](https://github.com/Manishearth/rust-clippy/wiki#mixed_case_hex_literals)                   | warn    | letter digits in hex literals should be either completely upper- or lowercased\n+[mixed_case_hex_literals](https://github.com/Manishearth/rust-clippy/wiki#mixed_case_hex_literals)                   | warn    | hex literals whose letter digits are not consistently upper- or lowercased\n [modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                                             | warn    | taking a number modulo 1, which always returns 0\n [mut_mut](https://github.com/Manishearth/rust-clippy/wiki#mut_mut)                                                   | allow   | usage of double-mut refs, e.g. `&mut &mut ...`\n [mutex_atomic](https://github.com/Manishearth/rust-clippy/wiki#mutex_atomic)                                         | warn    | using a mutex where an atomic value could be used instead\n@@ -109,74 +109,74 @@ name\n [needless_range_loop](https://github.com/Manishearth/rust-clippy/wiki#needless_range_loop)                           | warn    | for-looping over a range of indices where an iterator over items would do\n [needless_return](https://github.com/Manishearth/rust-clippy/wiki#needless_return)                                   | warn    | using a return statement like `return expr;` where an expression would suffice\n [needless_update](https://github.com/Manishearth/rust-clippy/wiki#needless_update)                                   | warn    | using `Foo { ..base }` when there are no missing fields\n-[neg_multiply](https://github.com/Manishearth/rust-clippy/wiki#neg_multiply)                                         | warn    | Warns on multiplying integers with -1\n+[neg_multiply](https://github.com/Manishearth/rust-clippy/wiki#neg_multiply)                                         | warn    | multiplying integers with -1\n [new_ret_no_self](https://github.com/Manishearth/rust-clippy/wiki#new_ret_no_self)                                   | warn    | not returning `Self` in a `new` method\n [new_without_default](https://github.com/Manishearth/rust-clippy/wiki#new_without_default)                           | warn    | `fn new() -> Self` method without `Default` implementation\n [new_without_default_derive](https://github.com/Manishearth/rust-clippy/wiki#new_without_default_derive)             | warn    | `fn new() -> Self` without `#[derive]`able `Default` implementation\n [no_effect](https://github.com/Manishearth/rust-clippy/wiki#no_effect)                                               | warn    | statements with no effect\n-[non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                               | allow   | using any literal non-ASCII chars in a string literal; suggests using the `\\\\u` escape instead\n-[nonminimal_bool](https://github.com/Manishearth/rust-clippy/wiki#nonminimal_bool)                                   | allow   | checks for boolean expressions that can be written more concisely\n+[non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                               | allow   | using any literal non-ASCII chars in a string literal instead of using the `\\\\u` escape\n+[nonminimal_bool](https://github.com/Manishearth/rust-clippy/wiki#nonminimal_bool)                                   | allow   | boolean expressions that can be written more concisely\n [nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)                 | warn    | nonsensical combination of options for opening a file\n [not_unsafe_ptr_arg_deref](https://github.com/Manishearth/rust-clippy/wiki#not_unsafe_ptr_arg_deref)                 | warn    | public functions dereferencing raw pointer arguments but not marked `unsafe`\n [ok_expect](https://github.com/Manishearth/rust-clippy/wiki#ok_expect)                                               | warn    | using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\n [option_map_unwrap_or](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or)                         | warn    | using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`\n [option_map_unwrap_or_else](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or_else)               | warn    | using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`\n [option_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#option_unwrap_used)                             | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n-[or_fun_call](https://github.com/Manishearth/rust-clippy/wiki#or_fun_call)                                           | warn    | using any `*or` method when the `*or_else` would do\n-[out_of_bounds_indexing](https://github.com/Manishearth/rust-clippy/wiki#out_of_bounds_indexing)                     | deny    | out of bound constant indexing\n-[overflow_check_conditional](https://github.com/Manishearth/rust-clippy/wiki#overflow_check_conditional)             | warn    | Using overflow checks which are likely to panic\n-[panic_params](https://github.com/Manishearth/rust-clippy/wiki#panic_params)                                         | warn    | missing parameters in `panic!`\n-[precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                                             | warn    | catches operations where precedence may be unclear\n+[or_fun_call](https://github.com/Manishearth/rust-clippy/wiki#or_fun_call)                                           | warn    | using any `*or` method with a function call, which suggests `*or_else`\n+[out_of_bounds_indexing](https://github.com/Manishearth/rust-clippy/wiki#out_of_bounds_indexing)                     | deny    | out of bounds constant indexing\n+[overflow_check_conditional](https://github.com/Manishearth/rust-clippy/wiki#overflow_check_conditional)             | warn    | overflow checks inspired by C which are likely to panic\n+[panic_params](https://github.com/Manishearth/rust-clippy/wiki#panic_params)                                         | warn    | missing parameters in `panic!` calls\n+[precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                                             | warn    | operations where precedence may be unclear\n [print_stdout](https://github.com/Manishearth/rust-clippy/wiki#print_stdout)                                         | allow   | printing on stdout\n-[ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                                   | warn    | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n-[range_step_by_zero](https://github.com/Manishearth/rust-clippy/wiki#range_step_by_zero)                             | warn    | using Range::step_by(0), which produces an infinite iterator\n-[range_zip_with_len](https://github.com/Manishearth/rust-clippy/wiki#range_zip_with_len)                             | warn    | zipping iterator with a range when enumerate() would do\n-[redundant_closure](https://github.com/Manishearth/rust-clippy/wiki#redundant_closure)                               | warn    | using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n-[redundant_closure_call](https://github.com/Manishearth/rust-clippy/wiki#redundant_closure_call)                     | warn    | Closures should not be called in the expression they are defined\n+[ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                                   | warn    | arguments of the type `&Vec<...>` (instead of `&[...]`) or `&String` (instead of `&str`)\n+[range_step_by_zero](https://github.com/Manishearth/rust-clippy/wiki#range_step_by_zero)                             | warn    | using `Range::step_by(0)`, which produces an infinite iterator\n+[range_zip_with_len](https://github.com/Manishearth/rust-clippy/wiki#range_zip_with_len)                             | warn    | zipping iterator with a range when `enumerate()` would do\n+[redundant_closure](https://github.com/Manishearth/rust-clippy/wiki#redundant_closure)                               | warn    | redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n+[redundant_closure_call](https://github.com/Manishearth/rust-clippy/wiki#redundant_closure_call)                     | warn    | throwaway closures called in the expression they are defined\n [redundant_pattern](https://github.com/Manishearth/rust-clippy/wiki#redundant_pattern)                               | warn    | using `name @ _` in a pattern\n-[regex_macro](https://github.com/Manishearth/rust-clippy/wiki#regex_macro)                                           | warn    | finds use of `regex!(_)`, suggests `Regex::new(_)` instead\n+[regex_macro](https://github.com/Manishearth/rust-clippy/wiki#regex_macro)                                           | warn    | use of `regex!(_)` instead of `Regex::new(_)`\n [result_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#result_unwrap_used)                             | allow   | using `Result.unwrap()`, which might be better handled\n-[reverse_range_loop](https://github.com/Manishearth/rust-clippy/wiki#reverse_range_loop)                             | warn    | Iterating over an empty range, such as `10..0` or `5..5`\n+[reverse_range_loop](https://github.com/Manishearth/rust-clippy/wiki#reverse_range_loop)                             | warn    | iteration over an empty range, such as `10..0` or `5..5`\n [search_is_some](https://github.com/Manishearth/rust-clippy/wiki#search_is_some)                                     | warn    | using an iterator search followed by `is_some()`, which is more succinctly expressed as a call to `any()`\n-[serde_api_misuse](https://github.com/Manishearth/rust-clippy/wiki#serde_api_misuse)                                 | warn    | Various things that will negatively affect your serde experience\n+[serde_api_misuse](https://github.com/Manishearth/rust-clippy/wiki#serde_api_misuse)                                 | warn    | various things that will negatively affect your serde experience\n [shadow_reuse](https://github.com/Manishearth/rust-clippy/wiki#shadow_reuse)                                         | allow   | rebinding a name to an expression that re-uses the original value, e.g. `let x = x + 1`\n [shadow_same](https://github.com/Manishearth/rust-clippy/wiki#shadow_same)                                           | allow   | rebinding a name to itself, e.g. `let mut x = &mut x`\n-[shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                                 | allow   | The name is re-bound without even using the original value\n+[shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                                 | allow   | rebinding a name without even using the original value\n [should_implement_trait](https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait)                     | warn    | defining a method that should be implementing a std trait\n [similar_names](https://github.com/Manishearth/rust-clippy/wiki#similar_names)                                       | allow   | similarly named items and bindings\n [single_char_pattern](https://github.com/Manishearth/rust-clippy/wiki#single_char_pattern)                           | warn    | using a single-character str where a char could be used, e.g. `_.split(\"x\")`\n-[single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                                         | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n-[single_match_else](https://github.com/Manishearth/rust-clippy/wiki#single_match_else)                               | allow   | a match statement with a two arms where the second arm's pattern is a wildcard; recommends `if let` instead\n-[string_add](https://github.com/Manishearth/rust-clippy/wiki#string_add)                                             | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead\n-[string_add_assign](https://github.com/Manishearth/rust-clippy/wiki#string_add_assign)                               | allow   | using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\n-[string_lit_as_bytes](https://github.com/Manishearth/rust-clippy/wiki#string_lit_as_bytes)                           | warn    | calling `as_bytes` on a string literal; suggests using a byte string literal instead\n-[stutter](https://github.com/Manishearth/rust-clippy/wiki#stutter)                                                   | allow   | finds type names prefixed/postfixed with their containing module's name\n+[single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                                         | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) instead of `if let`\n+[single_match_else](https://github.com/Manishearth/rust-clippy/wiki#single_match_else)                               | allow   | a match statement with a two arms where the second arm's pattern is a wildcard instead of `if let`\n+[string_add](https://github.com/Manishearth/rust-clippy/wiki#string_add)                                             | allow   | using `x + ..` where x is a `String` instead of `push_str()`\n+[string_add_assign](https://github.com/Manishearth/rust-clippy/wiki#string_add_assign)                               | allow   | using `x = x + ..` where x is a `String` instead of `push_str()`\n+[string_lit_as_bytes](https://github.com/Manishearth/rust-clippy/wiki#string_lit_as_bytes)                           | warn    | calling `as_bytes` on a string literal instead of using a byte string literal\n+[stutter](https://github.com/Manishearth/rust-clippy/wiki#stutter)                                                   | allow   | type names prefixed/postfixed with their containing module's name\n [suspicious_assignment_formatting](https://github.com/Manishearth/rust-clippy/wiki#suspicious_assignment_formatting) | warn    | suspicious formatting of `*=`, `-=` or `!=`\n [suspicious_else_formatting](https://github.com/Manishearth/rust-clippy/wiki#suspicious_else_formatting)             | warn    | suspicious formatting of `else if`\n [temporary_assignment](https://github.com/Manishearth/rust-clippy/wiki#temporary_assignment)                         | warn    | assignments to temporaries\n [temporary_cstring_as_ptr](https://github.com/Manishearth/rust-clippy/wiki#temporary_cstring_as_ptr)                 | warn    | getting the inner pointer of a temporary `CString`\n [too_many_arguments](https://github.com/Manishearth/rust-clippy/wiki#too_many_arguments)                             | warn    | functions with too many arguments\n-[toplevel_ref_arg](https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg)                                 | warn    | An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take references with `&`.\n+[toplevel_ref_arg](https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg)                                 | warn    | an entire binding declared as `ref`, in a function argument or a `let` statement\n [transmute_ptr_to_ref](https://github.com/Manishearth/rust-clippy/wiki#transmute_ptr_to_ref)                         | warn    | transmutes from a pointer to a reference type\n-[trivial_regex](https://github.com/Manishearth/rust-clippy/wiki#trivial_regex)                                       | warn    | finds trivial regular expressions\n-[type_complexity](https://github.com/Manishearth/rust-clippy/wiki#type_complexity)                                   | warn    | usage of very complex types; recommends factoring out parts into `type` definitions\n+[trivial_regex](https://github.com/Manishearth/rust-clippy/wiki#trivial_regex)                                       | warn    | trivial regular expressions\n+[type_complexity](https://github.com/Manishearth/rust-clippy/wiki#type_complexity)                                   | warn    | usage of very complex types that might be better factored into `type` definitions\n [unicode_not_nfc](https://github.com/Manishearth/rust-clippy/wiki#unicode_not_nfc)                                   | allow   | using a unicode literal not in NFC normal form (see [unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\n-[unit_cmp](https://github.com/Manishearth/rust-clippy/wiki#unit_cmp)                                                 | warn    | comparing unit values (which is always `true` or `false`, respectively)\n-[unnecessary_mut_passed](https://github.com/Manishearth/rust-clippy/wiki#unnecessary_mut_passed)                     | warn    | an argument is passed as a mutable reference although the function/method only demands an immutable reference\n+[unit_cmp](https://github.com/Manishearth/rust-clippy/wiki#unit_cmp)                                                 | warn    | comparing unit values\n+[unnecessary_mut_passed](https://github.com/Manishearth/rust-clippy/wiki#unnecessary_mut_passed)                     | warn    | an argument passed as a mutable reference although the callee only demands an immutable reference\n [unnecessary_operation](https://github.com/Manishearth/rust-clippy/wiki#unnecessary_operation)                       | warn    | outer expressions with no effect\n-[unneeded_field_pattern](https://github.com/Manishearth/rust-clippy/wiki#unneeded_field_pattern)                     | warn    | Struct fields are bound to a wildcard instead of using `..`\n-[unsafe_removed_from_name](https://github.com/Manishearth/rust-clippy/wiki#unsafe_removed_from_name)                 | warn    | unsafe removed from name\n-[unseparated_literal_suffix](https://github.com/Manishearth/rust-clippy/wiki#unseparated_literal_suffix)             | allow   | literal suffixes should be separated with an underscore\n+[unneeded_field_pattern](https://github.com/Manishearth/rust-clippy/wiki#unneeded_field_pattern)                     | warn    | struct fields bound to a wildcard instead of using `..`\n+[unsafe_removed_from_name](https://github.com/Manishearth/rust-clippy/wiki#unsafe_removed_from_name)                 | warn    | `unsafe` removed from API names on import\n+[unseparated_literal_suffix](https://github.com/Manishearth/rust-clippy/wiki#unseparated_literal_suffix)             | allow   | literals whose suffix is not separated by an underscore\n [unused_collect](https://github.com/Manishearth/rust-clippy/wiki#unused_collect)                                     | warn    | `collect()`ing an iterator without using the result; this is usually better written as a for loop\n-[unused_label](https://github.com/Manishearth/rust-clippy/wiki#unused_label)                                         | warn    | unused label\n+[unused_label](https://github.com/Manishearth/rust-clippy/wiki#unused_label)                                         | warn    | unused labels\n [unused_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#unused_lifetimes)                                 | warn    | unused lifetimes in function definitions\n-[use_debug](https://github.com/Manishearth/rust-clippy/wiki#use_debug)                                               | allow   | use `Debug`-based formatting\n+[use_debug](https://github.com/Manishearth/rust-clippy/wiki#use_debug)                                               | allow   | use of `Debug`-based formatting\n [used_underscore_binding](https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding)                   | allow   | using a binding which is prefixed with an underscore\n [useless_format](https://github.com/Manishearth/rust-clippy/wiki#useless_format)                                     | warn    | useless use of `format!`\n-[useless_let_if_seq](https://github.com/Manishearth/rust-clippy/wiki#useless_let_if_seq)                             | warn    | Checks for unidiomatic `let mut` declaration followed by initialization in `if`\n+[useless_let_if_seq](https://github.com/Manishearth/rust-clippy/wiki#useless_let_if_seq)                             | warn    | unidiomatic `let mut` declaration followed by initialization in `if`\n [useless_transmute](https://github.com/Manishearth/rust-clippy/wiki#useless_transmute)                               | warn    | transmutes that have the same to and from types or could be a cast/coercion\n [useless_vec](https://github.com/Manishearth/rust-clippy/wiki#useless_vec)                                           | warn    | useless `vec!`\n-[while_let_loop](https://github.com/Manishearth/rust-clippy/wiki#while_let_loop)                                     | warn    | `loop { if let { ... } else break }` can be written as a `while let` loop\n+[while_let_loop](https://github.com/Manishearth/rust-clippy/wiki#while_let_loop)                                     | warn    | `loop { if let { ... } else break }`, which can be written as a `while let` loop\n [while_let_on_iterator](https://github.com/Manishearth/rust-clippy/wiki#while_let_on_iterator)                       | warn    | using a while-let loop instead of a for loop on an iterator\n [wrong_pub_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_pub_self_convention)               | allow   | defining a public method named with an established prefix (like \"into_\") that takes `self` with the wrong convention\n [wrong_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_self_convention)                       | warn    | defining a method named with an established prefix (like \"into_\") that takes `self` with the wrong convention"}, {"sha": "01877465c00a06631a67762934768ef86d18ac93", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -4,11 +4,22 @@ use std::f64::consts as f64;\n use syntax::ast::{Lit, LitKind, FloatTy};\n use utils::span_lint;\n \n-/// **What it does:** This lint checks for floating point literals that approximate constants which are defined in [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants) or [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants), respectively, suggesting to use the predefined constant.\n+/// **What it does:** Checks for floating point literals that approximate\n+/// constants which are defined in\n+/// [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\n+/// or\n+/// [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\n+/// respectively, suggesting to use the predefined constant.\n ///\n-/// **Why is this bad?** Usually, the definition in the standard library is more precise than what people come up with. If you find that your definition is actually more precise, please [file a Rust issue](https://github.com/rust-lang/rust/issues).\n+/// **Why is this bad?** Usually, the definition in the standard library is more\n+/// precise than what people come up with. If you find that your definition is\n+/// actually more precise, please [file a Rust\n+/// issue](https://github.com/rust-lang/rust/issues).\n ///\n-/// **Known problems:** If you happen to have a value that is within 1/8192 of a known constant, but is not *and should not* be the same, this lint will report your value anyway. We have not yet noticed any false positives in code we tested clippy with (this includes servo), but YMMV.\n+/// **Known problems:** If you happen to have a value that is within 1/8192 of a\n+/// known constant, but is not *and should not* be the same, this lint will\n+/// report your value anyway. We have not yet noticed any false positives in\n+/// code we tested clippy with (this includes servo), but YMMV.\n ///\n /// **Example:**\n /// ```rust\n@@ -17,8 +28,7 @@ use utils::span_lint;\n declare_lint! {\n     pub APPROX_CONSTANT,\n     Warn,\n-    \"the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) \\\n-     is found; suggests to use the constant\"\n+    \"the approximate of a known float constant (in `std::fXX::consts`)\"\n }\n \n // Tuples are of the form (constant, name, min_digits)\n@@ -72,7 +82,8 @@ fn check_known_consts(cx: &LateContext, e: &Expr, s: &str, module: &str) {\n                 span_lint(cx,\n                           APPROX_CONSTANT,\n                           e.span,\n-                          &format!(\"approximate value of `{}::consts::{}` found. Consider using it directly\", module, &name));\n+                          &format!(\"approximate value of `{}::consts::{}` found. \\\n+                                    Consider using it directly\", module, &name));\n                 return;\n             }\n         }"}, {"sha": "55d0e82059c355367ef6a6c1736d8db8b8efbc4e", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -3,37 +3,37 @@ use rustc::lint::*;\n use syntax::codemap::Span;\n use utils::span_lint;\n \n-/// **What it does:** This lint checks for plain integer arithmetic\n+/// **What it does:** Checks for plain integer arithmetic.\n ///\n /// **Why is this bad?** This is only checked against overflow in debug builds.\n /// In some applications one wants explicitly checked, wrapping or saturating\n /// arithmetic.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n /// a + 1\n /// ```\n declare_restriction_lint! {\n     pub INTEGER_ARITHMETIC,\n-    \"Any integer arithmetic statement\"\n+    \"any integer arithmetic statement\"\n }\n \n-/// **What it does:** This lint checks for float arithmetic\n+/// **What it does:** Checks for float arithmetic.\n ///\n /// **Why is this bad?** For some embedded systems or kernel development, it\n-/// can be useful to rule out floating-point numbers\n+/// can be useful to rule out floating-point numbers.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n /// a + 1.0\n /// ```\n declare_restriction_lint! {\n     pub FLOAT_ARITHMETIC,\n-    \"Any floating-point arithmetic statement\"\n+    \"any floating-point arithmetic statement\"\n }\n \n #[derive(Copy, Clone, Default)]"}, {"sha": "5d8a0b8b8f0f8ccb73f28543f8b9764c4c34b4e5", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -8,14 +8,13 @@ use rustc::hir::*;\n use syntax::ast::RangeLimits;\n use utils::{self, higher};\n \n-/// **What it does:** Check for out of bounds array indexing with a constant index.\n+/// **What it does:** Checks for out of bounds array indexing with a constant index.\n ///\n /// **Why is this bad?** This will always panic at runtime.\n ///\n /// **Known problems:** Hopefully none.\n ///\n /// **Example:**\n-///\n /// ```rust\n /// let x = [1,2,3,4];\n /// ...\n@@ -25,27 +24,25 @@ use utils::{self, higher};\n declare_lint! {\n     pub OUT_OF_BOUNDS_INDEXING,\n     Deny,\n-    \"out of bound constant indexing\"\n+    \"out of bounds constant indexing\"\n }\n \n-/// **What it does:** Check for usage of indexing or slicing.\n+/// **What it does:** Checks for usage of indexing or slicing.\n ///\n-/// **Why is this bad?** Usually, this can be safely allowed. However,\n-/// in some domains such as kernel development, a panic can cause the\n-/// whole operating system to crash.\n+/// **Why is this bad?** Usually, this can be safely allowed. However, in some\n+/// domains such as kernel development, a panic can cause the whole operating\n+/// system to crash.\n ///\n /// **Known problems:** Hopefully none.\n ///\n /// **Example:**\n-///\n /// ```rust\n /// ...\n /// x[2];\n /// &x[0..2];\n /// ```\n-declare_lint! {\n+declare_restriction_lint! {\n     pub INDEXING_SLICING,\n-    Allow,\n     \"indexing/slicing usage\"\n }\n "}, {"sha": "36814808a2bcf596f01390d65700ed9a1fbd769c", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -3,10 +3,10 @@ use rustc::lint::*;\n use utils::{span_lint_and_then, snippet_opt, SpanlessEq, get_trait_def_id, implements_trait};\n use utils::{higher, sugg};\n \n-/// **What it does:** This lint checks for `+=` operations and similar.\n+/// **What it does:** Checks for compound assignment operations (`+=` and similar).\n ///\n-/// **Why is this bad?** Projects with many developers from languages without those operations may\n-/// find them unreadable and not worth their weight.\n+/// **Why is this bad?** Projects with many developers from languages without\n+/// those operations may find them unreadable and not worth their weight.\n ///\n /// **Known problems:** Types implementing `OpAssign` don't necessarily implement `Op`.\n ///\n@@ -16,17 +16,17 @@ use utils::{higher, sugg};\n /// ```\n declare_restriction_lint! {\n     pub ASSIGN_OPS,\n-    \"any assignment operation\"\n+    \"any compound assignment operation\"\n }\n \n-/// **What it does:** Check for `a = a op b` or `a = b commutative_op a` patterns.\n+/// **What it does:** Checks for `a = a op b` or `a = b commutative_op a` patterns.\n ///\n /// **Why is this bad?** These can be written as the shorter `a op= b`.\n ///\n-/// **Known problems:** While forbidden by the spec, `OpAssign` traits may have implementations that differ from the regular `Op` impl.\n+/// **Known problems:** While forbidden by the spec, `OpAssign` traits may have\n+/// implementations that differ from the regular `Op` impl.\n ///\n /// **Example:**\n-///\n /// ```rust\n /// let mut a = 5;\n /// ...\n@@ -38,14 +38,14 @@ declare_lint! {\n     \"assigning the result of an operation on a variable to that same variable\"\n }\n \n-/// **What it does:** Check for `a op= a op b` or `a op= b op a` patterns.\n+/// **What it does:** Checks for `a op= a op b` or `a op= b op a` patterns.\n ///\n-/// **Why is this bad?** Most likely these are bugs where one meant to write `a op= b`\n+/// **Why is this bad?** Most likely these are bugs where one meant to write `a op= b`.\n ///\n-/// **Known problems:** Someone might actually mean `a op= a op b`, but that should rather be written as `a = (2 * a) op b` where applicable.\n+/// **Known problems:** Someone might actually mean `a op= a op b`, but that\n+/// should rather be written as `a = (2 * a) op b` where applicable.\n ///\n /// **Example:**\n-///\n /// ```rust\n /// let mut a = 5;\n /// ..."}, {"sha": "0679bf50aa7ee2cf0d4758649a8d41829cf3a5c2", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -9,38 +9,49 @@ use syntax::codemap::Span;\n use utils::{in_macro, match_path, span_lint};\n use utils::paths;\n \n-/// **What it does:** This lint checks for items annotated with `#[inline(always)]`, unless the annotated function is empty or simply panics.\n+/// **What it does:** Checks for items annotated with `#[inline(always)]`,\n+/// unless the annotated function is empty or simply panics.\n ///\n-/// **Why is this bad?** While there are valid uses of this annotation (and once you know when to use it, by all means `allow` this lint), it's a common newbie-mistake to pepper one's code with it.\n+/// **Why is this bad?** While there are valid uses of this annotation (and once\n+/// you know when to use it, by all means `allow` this lint), it's a common\n+/// newbie-mistake to pepper one's code with it.\n ///\n-/// As a rule of thumb, before slapping `#[inline(always)]` on a function, measure if that additional function call really affects your runtime profile sufficiently to make up for the increase in compile time.\n+/// As a rule of thumb, before slapping `#[inline(always)]` on a function,\n+/// measure if that additional function call really affects your runtime profile\n+/// sufficiently to make up for the increase in compile time.\n ///\n-/// **Known problems:** False positives, big time. This lint is meant to be deactivated by everyone doing serious performance work. This means having done the measurement.\n+/// **Known problems:** False positives, big time. This lint is meant to be\n+/// deactivated by everyone doing serious performance work. This means having\n+/// done the measurement.\n ///\n /// **Example:**\n /// ```rust\n /// #[inline(always)]\n /// fn not_quite_hot_code(..) { ... }\n /// ```\n declare_lint! {\n-    pub INLINE_ALWAYS, Warn,\n-    \"`#[inline(always)]` is a bad idea in most cases\"\n+    pub INLINE_ALWAYS,\n+    Warn,\n+    \"use of `#[inline(always)]`\"\n }\n \n-/// **What it does:** This lint checks for `#[deprecated]` annotations with a `since` field that is not a valid semantic version..\n+/// **What it does:** Checks for `#[deprecated]` annotations with a `since`\n+/// field that is not a valid semantic version.\n ///\n-/// **Why is this bad?** For checking the version of the deprecation, it must be valid semver. Failing that, the contained information is useless.\n+/// **Why is this bad?** For checking the version of the deprecation, it must be\n+/// a valid semver. Failing that, the contained information is useless.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n /// #[deprecated(since = \"forever\")]\n /// fn something_else(..) { ... }\n /// ```\n declare_lint! {\n-    pub DEPRECATED_SEMVER, Warn,\n-    \"`Warn` on `#[deprecated(since = \\\"x\\\")]` where x is not semver\"\n+    pub DEPRECATED_SEMVER,\n+    Warn,\n+    \"use of `#[deprecated(since = \\\"x\\\")]` where x is not semver\"\n }\n \n #[derive(Copy,Clone)]"}, {"sha": "b021079fd975f2bca10b314d430fb5a1676ec3cf", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 23, "deletions": 37, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -6,10 +6,12 @@ use syntax::ast::LitKind;\n use syntax::codemap::Span;\n use utils::span_lint;\n \n-/// **What it does:** This lint checks for incompatible bit masks in comparisons.\n+/// **What it does:** Checks for incompatible bit masks in comparisons.\n ///\n-/// The formula for detecting if an expression of the type  `_ <bit_op> m <cmp_op> c` (where `<bit_op>`\n-/// is one of {`&`, `|`} and `<cmp_op>` is one of {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following table:\n+/// The formula for detecting if an expression of the type `_ <bit_op> m\n+/// <cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n+/// {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\n+/// table:\n ///\n /// |Comparison  |Bit Op|Example     |is always|Formula               |\n /// |------------|------|------------|---------|----------------------|\n@@ -20,11 +22,15 @@ use utils::span_lint;\n /// |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n /// |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n ///\n-/// **Why is this bad?** If the bits that the comparison cares about are always set to zero or one by the bit mask, the comparison is constant `true` or `false` (depending on mask, compared value, and operators).\n+/// **Why is this bad?** If the bits that the comparison cares about are always\n+/// set to zero or one by the bit mask, the comparison is constant `true` or\n+/// `false` (depending on mask, compared value, and operators).\n ///\n-/// So the code is actively misleading, and the only reason someone would write this intentionally is to win an underhanded Rust contest or create a test-case for this lint.\n+/// So the code is actively misleading, and the only reason someone would write\n+/// this intentionally is to win an underhanded Rust contest or create a\n+/// test-case for this lint.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -33,20 +39,26 @@ use utils::span_lint;\n declare_lint! {\n     pub BAD_BIT_MASK,\n     Warn,\n-    \"expressions of the form `_ & mask == select` that will only ever return `true` or `false` \\\n-     (because in the example `select` containing bits that `mask` doesn't have)\"\n+    \"expressions of the form `_ & mask == select` that will only ever return `true` or `false`\"\n }\n \n-/// **What it does:** This lint checks for bit masks in comparisons which can be removed without changing the outcome. The basic structure can be seen in the following table:\n+/// **What it does:** Checks for bit masks in comparisons which can be removed\n+/// without changing the outcome. The basic structure can be seen in the\n+/// following table:\n ///\n /// |Comparison| Bit Op  |Example    |equals |\n /// |----------|---------|-----------|-------|\n /// |`>` / `<=`|`|` / `^`|`x | 2 > 3`|`x > 3`|\n /// |`<` / `>=`|`|` / `^`|`x ^ 1 < 4`|`x < 4`|\n ///\n-/// **Why is this bad?** Not equally evil as [`bad_bit_mask`](#bad_bit_mask), but still a bit misleading, because the bit mask is ineffective.\n+/// **Why is this bad?** Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\n+/// but still a bit misleading, because the bit mask is ineffective.\n ///\n-/// **Known problems:** False negatives: This lint will only match instances where we have figured out the math (which is for a power-of-two compared value). This means things like `x | 1 >= 7` (which would be better written as `x >= 6`) will not be reported (but bit masks like this are fairly uncommon).\n+/// **Known problems:** False negatives: This lint will only match instances\n+/// where we have figured out the math (which is for a power-of-two compared\n+/// value). This means things like `x | 1 >= 7` (which would be better written\n+/// as `x >= 6`) will not be reported (but bit masks like this are fairly\n+/// uncommon).\n ///\n /// **Example:**\n /// ```rust\n@@ -58,32 +70,6 @@ declare_lint! {\n     \"expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\"\n }\n \n-/// Checks for incompatible bit masks in comparisons, e.g. `x & 1 == 2`.\n-/// This cannot work because the bit that makes up the value two was\n-/// zeroed out by the bit-and with 1. So the formula for detecting if an\n-/// expression of the type  `_ <bit_op> m <cmp_op> c` (where `<bit_op>`\n-/// is one of {`&`, '|'} and `<cmp_op>` is one of {`!=`, `>=`, `>` ,\n-/// `!=`, `>=`, `>`}) can be determined from the following table:\n-///\n-/// |Comparison  |Bit Op|Example     |is always|Formula               |\n-/// |------------|------|------------|---------|----------------------|\n-/// |`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n-/// |`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n-/// |`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n-/// |`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n-/// |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n-/// |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n-///\n-/// This lint is **deny** by default\n-///\n-/// There is also a lint that warns on ineffective masks that is *warn*\n-/// by default.\n-///\n-/// |Comparison|Bit Op   |Example    |equals |Formula|\n-/// |`>` / `<=`|`|` / `^`|`x | 2 > 3`|`x > 3`|`\u00b9 && m <= c`|\n-/// |`<` / `>=`|`|` / `^`|`x ^ 1 < 4`|`x < 4`|`\u00b9 && m < c` |\n-///\n-/// `\u00b9 power_of_two(c + 1)`\n #[derive(Copy,Clone)]\n pub struct BitMask;\n "}, {"sha": "55d0efd3536296d4b021d2a77014f43f56c7eec9", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -2,9 +2,11 @@ use rustc::lint::*;\n use rustc::hir::*;\n use utils::span_lint;\n \n-/// **What it does:** This lints about usage of blacklisted names.\n+/// **What it does:** Checks for usage of blacklisted names for variables, such\n+/// as `foo`.\n ///\n-/// **Why is this bad?** These names are usually placeholder names and should be avoided.\n+/// **Why is this bad?** These names are usually placeholder names and should be\n+/// avoided.\n ///\n /// **Known problems:** None.\n ///"}, {"sha": "3f506e4f26d3a763d495f734ca1b7fc87840e376", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -3,26 +3,30 @@ use rustc::hir::*;\n use rustc::hir::intravisit::{Visitor, walk_expr};\n use utils::*;\n \n-/// **What it does:** This lint checks for `if` conditions that use blocks to contain an expression.\n+/// **What it does:** Checks for `if` conditions that use blocks to contain an\n+/// expression.\n ///\n-/// **Why is this bad?** It isn't really rust style, same as using parentheses to contain expressions.\n+/// **Why is this bad?** It isn't really Rust style, same as using parentheses\n+/// to contain expressions.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n /// if { true } ..\n /// ```\n declare_lint! {\n-    pub BLOCK_IN_IF_CONDITION_EXPR, Warn,\n-    \"braces can be eliminated in conditions that are expressions, e.g `if { true } ...`\"\n+    pub BLOCK_IN_IF_CONDITION_EXPR,\n+    Warn,\n+    \"braces that can be eliminated in conditions, e.g `if { true } ...`\"\n }\n \n-/// **What it does:** This lint checks for `if` conditions that use blocks containing statements, or conditions that use closures with blocks.\n+/// **What it does:** Checks for `if` conditions that use blocks containing\n+/// statements, or conditions that use closures with blocks.\n ///\n /// **Why is this bad?** Using blocks in the condition makes it hard to read.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -31,9 +35,9 @@ declare_lint! {\n /// if somefunc(|x| { x == 47 }) ..\n /// ```\n declare_lint! {\n-    pub BLOCK_IN_IF_CONDITION_STMT, Warn,\n-    \"avoid complex blocks in conditions, instead move the block higher and bind it \\\n-    with 'let'; e.g: `if { let x = true; x } ...`\"\n+    pub BLOCK_IN_IF_CONDITION_STMT,\n+    Warn,\n+    \"complex blocks in conditions, e.g. `if { let x = true; x } ...`\"\n }\n \n #[derive(Copy,Clone)]"}, {"sha": "c6c70640bbae08a8fd4d023850599fd85998b285", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -6,28 +6,41 @@ use syntax::codemap::{DUMMY_SP, dummy_spanned};\n use syntax::util::ThinVec;\n use utils::{span_lint_and_then, in_macro, snippet_opt, SpanlessEq};\n \n-/// **What it does:** This lint checks for boolean expressions that can be written more concisely.\n+/// **What it does:** Checks for boolean expressions that can be written more\n+/// concisely.\n ///\n-/// **Why is this bad?** Readability of boolean expressions suffers from unnecessary duplication.\n+/// **Why is this bad?** Readability of boolean expressions suffers from\n+/// unnecessary duplication.\n ///\n-/// **Known problems:** Ignores short circuiting behavior of `||` and `&&`. Ignores `|`, `&` and `^`.\n+/// **Known problems:** Ignores short circuiting behavior of `||` and\n+/// `&&`. Ignores `|`, `&` and `^`.\n ///\n-/// **Example:** `if a && true` should be `if a` and `!(a == b)` should be `a != b`\n+/// **Example:**\n+/// ```rust\n+/// if a && true  // should be: if a\n+/// if !(a == b)  // should be: if a != b\n declare_lint! {\n-    pub NONMINIMAL_BOOL, Allow,\n-    \"checks for boolean expressions that can be written more concisely\"\n+    pub NONMINIMAL_BOOL,\n+    Allow,\n+    \"boolean expressions that can be written more concisely\"\n }\n \n-/// **What it does:** This lint checks for boolean expressions that contain terminals that can be eliminated.\n+/// **What it does:** Checks for boolean expressions that contain terminals that\n+/// can be eliminated.\n ///\n /// **Why is this bad?** This is most likely a logic bug.\n ///\n /// **Known problems:** Ignores short circuiting behavior.\n ///\n-/// **Example:** The `b` in `if a && b || a` is unnecessary because the expression is equivalent to `if a`\n+/// **Example:**\n+/// ```rust\n+/// if a && b || a { ... }\n+/// ```\n+/// The `b` is unnecessary, the expression is equivalent to `if a`.\n declare_lint! {\n-    pub LOGIC_BUG, Warn,\n-    \"checks for boolean expressions that contain terminals which can be eliminated\"\n+    pub LOGIC_BUG,\n+    Warn,\n+    \"boolean expressions that contain terminals which can be eliminated\"\n }\n \n #[derive(Copy,Clone)]"}, {"sha": "9d23d32c81ae33a4dc3280284c9446210ed0108c", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -18,13 +18,14 @@ use syntax::ast;\n use utils::{in_macro, snippet_block, span_lint_and_then};\n use utils::sugg::Sugg;\n \n-/// **What it does:** This lint checks for nested `if`-statements which can be collapsed by\n-/// `&&`-combining their conditions and for `else { if .. }` expressions that can be collapsed to\n-/// `else if ..`.\n+/// **What it does:** Checks for nested `if` statements which can be collapsed\n+/// by `&&`-combining their conditions and for `else { if ... }` expressions that\n+/// can be collapsed to `else if ...`.\n ///\n-/// **Why is this bad?** Each `if`-statement adds one level of nesting, which makes code look more complex than it really is.\n+/// **Why is this bad?** Each `if`-statement adds one level of nesting, which\n+/// makes code look more complex than it really is.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust"}, {"sha": "0a0dc6a60c80b9e593ad16b767a2a62950e0cfa4", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -8,7 +8,7 @@ use syntax::util::small_vector::SmallVector;\n use utils::{SpanlessEq, SpanlessHash};\n use utils::{get_parent_expr, in_macro, span_lint_and_then, span_note_and_lint, snippet};\n \n-/// **What it does:** This lint checks for consecutive `ifs` with the same condition.\n+/// **What it does:** Checks for consecutive `if`s with the same condition.\n ///\n /// **Why is this bad?** This is probably a copy & paste error.\n ///\n@@ -23,7 +23,8 @@ use utils::{get_parent_expr, in_macro, span_lint_and_then, span_note_and_lint, s\n /// }\n /// ```\n ///\n-/// Note that this lint ignores all conditions with a function call as it could have side effects:\n+/// Note that this lint ignores all conditions with a function call as it could\n+/// have side effects:\n ///\n /// ```rust\n /// if foo() {\n@@ -38,8 +39,8 @@ declare_lint! {\n     \"consecutive `ifs` with the same condition\"\n }\n \n-/// **What it does:** This lint checks for `if/else` with the same body as the *then* part and the\n-/// *else* part.\n+/// **What it does:** Checks for `if/else` with the same body as the *then* part\n+/// and the *else* part.\n ///\n /// **Why is this bad?** This is probably a copy & paste error.\n ///\n@@ -59,10 +60,10 @@ declare_lint! {\n     \"if with the same *then* and *else* blocks\"\n }\n \n-/// **What it does:** This lint checks for `match` with identical arm bodies.\n+/// **What it does:** Checks for `match` with identical arm bodies.\n ///\n-/// **Why is this bad?** This is probably a copy & paste error. If arm bodies are the same on\n-/// purpose, you can factor them\n+/// **Why is this bad?** This is probably a copy & paste error. If arm bodies\n+/// are the same on purpose, you can factor them\n /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n ///\n /// **Known problems:** False positive possible with order dependent `match`"}, {"sha": "3e3237ffe08796b44ca4d00c8e242fad6415ffcc", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -11,17 +11,18 @@ use syntax::codemap::Span;\n \n use utils::{in_macro, LimitStack, span_help_and_lint, paths, match_type};\n \n-/// **What it does:** This lint checks for methods with high cyclomatic complexity\n+/// **What it does:** Checks for methods with high cyclomatic complexity.\n ///\n-/// **Why is this bad?** Methods of high cyclomatic complexity tend to be badly readable. Also LLVM\n-/// will usually optimize small methods better.\n+/// **Why is this bad?** Methods of high cyclomatic complexity tend to be badly\n+/// readable. Also LLVM will usually optimize small methods better.\n ///\n-/// **Known problems:** Sometimes it's hard to find a way to reduce the complexity\n+/// **Known problems:** Sometimes it's hard to find a way to reduce the complexity.\n ///\n /// **Example:** No. You'll see it when you get the warning.\n declare_lint! {\n-    pub CYCLOMATIC_COMPLEXITY, Warn,\n-    \"finds functions that should be split up into multiple functions\"\n+    pub CYCLOMATIC_COMPLEXITY,\n+    Warn,\n+    \"functions that should be split up into multiple functions\"\n }\n \n pub struct CyclomaticComplexity {"}, {"sha": "4177b953b9470c4322ebd7899a960adddb69addc", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -8,12 +8,13 @@ use syntax::codemap::Span;\n use utils::paths;\n use utils::{match_path, span_lint_and_then};\n \n-/// **What it does:** This lint warns about deriving `Hash` but implementing `PartialEq`\n+/// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n /// explicitly.\n ///\n-/// **Why is this bad?** The implementation of these traits must agree (for example for use with\n-/// `HashMap`) so it\u2019s probably a bad idea to use a default-generated `Hash` implementation  with\n-/// an explicitly defined `PartialEq`. In particular, the following must hold for any type:\n+/// **Why is this bad?** The implementation of these traits must agree (for\n+/// example for use with `HashMap`) so it\u2019s probably a bad idea to use a\n+/// default-generated `Hash` implementation with an explicitly defined\n+/// `PartialEq`. In particular, the following must hold for any type:\n ///\n /// ```rust\n /// k1 == k2 \u21d2 hash(k1) == hash(k2)\n@@ -27,7 +28,7 @@ use utils::{match_path, span_lint_and_then};\n /// struct Foo;\n ///\n /// impl PartialEq for Foo {\n-///     ..\n+///     ...\n /// }\n /// ```\n declare_lint! {\n@@ -36,12 +37,14 @@ declare_lint! {\n     \"deriving `Hash` but implementing `PartialEq` explicitly\"\n }\n \n-/// **What it does:** This lint warns about explicit `Clone` implementation for `Copy` types.\n+/// **What it does:** Checks for explicit `Clone` implementations for `Copy`\n+/// types.\n ///\n-/// **Why is this bad?** To avoid surprising behaviour, these traits should agree and the behaviour\n-/// of `Copy` cannot be overridden. In almost all situations a `Copy` type should have a `Clone`\n-/// implementation that does nothing more than copy the object, which is what\n-/// `#[derive(Copy, Clone)]` gets you.\n+/// **Why is this bad?** To avoid surprising behaviour, these traits should\n+/// agree and the behaviour of `Copy` cannot be overridden. In almost all\n+/// situations a `Copy` type should have a `Clone` implementation that does\n+/// nothing more than copy the object, which is what `#[derive(Copy, Clone)]`\n+/// gets you.\n ///\n /// **Known problems:** None.\n ///"}, {"sha": "1cfe6c109297781b796ac3493c4e4550fc35cc06", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -3,14 +3,16 @@ use syntax::ast;\n use syntax::codemap::{Span, BytePos};\n use utils::span_lint;\n \n-/// **What it does:** This lint checks for the presence of `_`, `::` or camel-case words outside\n-/// ticks in documentation.\n+/// **What it does:** Checks for the presence of `_`, `::` or camel-case words\n+/// outside ticks in documentation.\n ///\n-/// **Why is this bad?** *Rustdoc* supports markdown formatting, `_`, `::` and camel-case probably\n-/// indicates some code which should be included between ticks. `_` can also be used for empasis in\n-/// markdown, this lint tries to consider that.\n+/// **Why is this bad?** *Rustdoc* supports markdown formatting, `_`, `::` and\n+/// camel-case probably indicates some code which should be included between\n+/// ticks. `_` can also be used for empasis in markdown, this lint tries to\n+/// consider that.\n ///\n-/// **Known problems:** Lots of bad docs won\u2019t be fixed, what the lint checks for is limited.\n+/// **Known problems:** Lots of bad docs won\u2019t be fixed, what the lint checks\n+/// for is limited, and there are still false positives.\n ///\n /// **Examples:**\n /// ```rust\n@@ -19,8 +21,9 @@ use utils::span_lint;\n /// fn doit(foo_bar) { .. }\n /// ```\n declare_lint! {\n-    pub DOC_MARKDOWN, Warn,\n-    \"checks for the presence of `_`, `::` or camel-case outside ticks in documentation\"\n+    pub DOC_MARKDOWN,\n+    Warn,\n+    \"presence of `_`, `::` or camel-case outside backticks in documentation\"\n }\n \n #[derive(Clone)]"}, {"sha": "88739bb6d78ea707c8f2e462dfad66101b914ba0", "filename": "clippy_lints/src/drop_ref.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_ref.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -4,11 +4,15 @@ use rustc::hir::*;\n use syntax::codemap::Span;\n use utils::{match_def_path, paths, span_note_and_lint};\n \n-/// **What it does:** This lint checks for calls to `std::mem::drop` with a reference instead of an owned value.\n+/// **What it does:** Checks for calls to `std::mem::drop` with a reference\n+/// instead of an owned value.\n ///\n-/// **Why is this bad?** Calling `drop` on a reference will only drop the reference itself, which is a no-op. It will not call the `drop` method (from the `Drop` trait implementation) on the underlying referenced value, which is likely what was intended.\n+/// **Why is this bad?** Calling `drop` on a reference will only drop the\n+/// reference itself, which is a no-op. It will not call the `drop` method (from\n+/// the `Drop` trait implementation) on the underlying referenced value, which\n+/// is likely what was intended.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -17,9 +21,9 @@ use utils::{match_def_path, paths, span_note_and_lint};\n /// operation_that_requires_mutex_to_be_unlocked();\n /// ```\n declare_lint! {\n-    pub DROP_REF, Warn,\n-    \"call to `std::mem::drop` with a reference instead of an owned value, \\\n-    which will not call the `Drop::drop` method on the underlying value\"\n+    pub DROP_REF,\n+    Warn,\n+    \"calls to `std::mem::drop` with a reference instead of an owned value\"\n }\n \n #[allow(missing_copy_implementations)]"}, {"sha": "2a56ba1f22db6b17a00cf3a45d5fd3d23963d37d", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -5,8 +5,8 @@ use syntax::codemap::Span;\n use utils::SpanlessEq;\n use utils::{get_item_name, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty};\n \n-/// **What it does:** This lint checks for uses of `contains_key` + `insert` on `HashMap` or\n-/// `BTreeMap`.\n+/// **What it does:** Checks for uses of `contains_key` + `insert` on `HashMap`\n+/// or `BTreeMap`.\n ///\n /// **Why is this bad?** Using `entry` is more efficient.\n ///"}, {"sha": "9188c421ccd486748b56ca2739fc5a7c79228e0c", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -6,13 +6,13 @@ use rustc_const_math::*;\n use rustc::hir::*;\n use utils::span_lint;\n \n-/// **What it does:** Lints on C-like enumerations that are `repr(isize/usize)` and have values\n-/// that don't fit into an `i32`.\n+/// **What it does:** Checks for C-like enumerations that are\n+/// `repr(isize/usize)` and have values that don't fit into an `i32`.\n ///\n-/// **Why is this bad?** This will truncate the variant value on 32 bit architectures, but works\n-/// fine on 64 bit.\n+/// **Why is this bad?** This will truncate the variant value on 32 bit\n+/// architectures, but works fine on 64 bit.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -23,8 +23,9 @@ use utils::span_lint;\n /// }\n /// ```\n declare_lint! {\n-    pub ENUM_CLIKE_UNPORTABLE_VARIANT, Warn,\n-    \"finds C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`\"\n+    pub ENUM_CLIKE_UNPORTABLE_VARIANT,\n+    Warn,\n+    \"C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`\"\n }\n \n pub struct UnportableVariant;"}, {"sha": "214390054753da864160028ec5092908ec542b2e", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -9,18 +9,23 @@ use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use utils::span_lint;\n \n-/// **What it does:** Warns when `use`ing all variants of an enumeration.\n+/// **What it does:** Checks for `use Enum::*`.\n ///\n-/// **Why is this bad?** It is usually better style to use the prefixed name of an enumeration variant, rather than importing variants\n+/// **Why is this bad?** It is usually better style to use the prefixed name of\n+/// an enumeration variant, rather than importing variants.\n ///\n-/// **Known problems:** Old-style enumerations that prefix the variants are still around\n+/// **Known problems:** Old-style enumerations that prefix the variants are\n+/// still around.\n ///\n /// **Example:**\n /// ```rust\n /// use std::cmp::Ordering::*;\n /// ```\n-declare_lint! { pub ENUM_GLOB_USE, Allow,\n-    \"finds use items that import all variants of an enum\" }\n+declare_lint! {\n+    pub ENUM_GLOB_USE,\n+    Allow,\n+    \"use items that import all variants of an enum\"\n+}\n \n pub struct EnumGlobUse;\n "}, {"sha": "17c3de480480e3eae6010fbf0b9e74d66a6b6c5d", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -7,13 +7,13 @@ use syntax::parse::token::InternedString;\n use utils::{span_help_and_lint, span_lint};\n use utils::{camel_case_from, camel_case_until, in_macro};\n \n-/// **What it does:** Warns on enumeration variants that are prefixed or suffixed by the same\n-/// characters.\n+/// **What it does:** Detects enumeration variants that are prefixed or suffixed\n+/// by the same characters.\n ///\n-/// **Why is this bad?** Enumeration variant names should specify their variant, not repeat the\n-/// enumeration name.\n+/// **Why is this bad?** Enumeration variant names should specify their variant,\n+/// not repeat the enumeration name.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -23,15 +23,17 @@ use utils::{camel_case_from, camel_case_until, in_macro};\n /// }\n /// ```\n declare_lint! {\n-    pub ENUM_VARIANT_NAMES, Warn,\n-    \"finds enums where all variants share a prefix/postfix\"\n+    pub ENUM_VARIANT_NAMES,\n+    Warn,\n+    \"enums where all variants share a prefix/postfix\"\n }\n \n-/// **What it does:** Warns on type names that are prefixed or suffixed by the containing module's name\n+/// **What it does:** Detects type names that are prefixed or suffixed by the\n+/// containing module's name.\n ///\n-/// **Why is this bad?** It requires the user to type the module name twice\n+/// **Why is this bad?** It requires the user to type the module name twice.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -40,8 +42,9 @@ declare_lint! {\n /// }\n /// ```\n declare_lint! {\n-    pub STUTTER, Allow,\n-    \"finds type names prefixed/postfixed with their containing module's name\"\n+    pub STUTTER,\n+    Allow,\n+    \"type names prefixed/postfixed with their containing module's name\"\n }\n \n pub struct EnumVariantNames {"}, {"sha": "7591e3dc076c628b92163c3b6f1ab9a50f47816c", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -2,16 +2,16 @@ use rustc::hir::*;\n use rustc::lint::*;\n use utils::{SpanlessEq, span_lint};\n \n-/// **What it does:** This lint checks for equal operands to comparison, logical and bitwise,\n-/// difference and division binary operators (`==`, `>`, etc., `&&`, `||`, `&`, `|`, `^`, `-` and\n-/// `/`).\n+/// **What it does:** Checks for equal operands to comparison, logical and\n+/// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n+/// `||`, `&`, `|`, `^`, `-` and `/`).\n ///\n /// **Why is this bad?** This is usually just a typo or a copy and paste error.\n ///\n-/// **Known problems:** False negatives: We had some false positives regarding calls (notably\n-/// [racer](https://github.com/phildawes/racer) had one instance of `x.pop() && x.pop()`), so we\n-/// removed matching any function or method calls. We may introduce a whitelist of known pure\n-/// functions in the future.\n+/// **Known problems:** False negatives: We had some false positives regarding\n+/// calls (notably [racer](https://github.com/phildawes/racer) had one instance\n+/// of `x.pop() && x.pop()`), so we removed matching any function or method\n+/// calls. We may introduce a whitelist of known pure functions in the future.\n ///\n /// **Example:**\n /// ```rust"}, {"sha": "2e7cd04d78ecc4017d394707b1434dff9bfc8937", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -17,15 +17,16 @@ pub struct Pass {\n     pub too_large_for_stack: u64,\n }\n \n-/// **What it does:** This lint checks for usage of `Box<T>` where an unboxed `T` would work fine.\n+/// **What it does:** Checks for usage of `Box<T>` where an unboxed `T` would\n+/// work fine.\n ///\n-/// **Why is this bad?** This is an unnecessary allocation, and bad for performance. It is only\n-/// necessary to allocate if you wish to move the box into something.\n+/// **Why is this bad?** This is an unnecessary allocation, and bad for\n+/// performance. It is only necessary to allocate if you wish to move the box\n+/// into something.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n-///\n /// ```rust\n /// fn main() {\n ///     let x = Box::new(1);\n@@ -34,7 +35,9 @@ pub struct Pass {\n /// }\n /// ```\n declare_lint! {\n-    pub BOXED_LOCAL, Warn, \"using `Box<T>` where unnecessary\"\n+    pub BOXED_LOCAL,\n+    Warn,\n+    \"using `Box<T>` where unnecessary\"\n }\n \n fn is_non_trait_box(ty: ty::Ty) -> bool {"}, {"sha": "1d9eb70b008de253959eff1731815ac1162454af", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -7,20 +7,24 @@ use utils::{snippet_opt, span_lint_and_then, is_adjusted};\n pub struct EtaPass;\n \n \n-/// **What it does:** This lint checks for closures which just call another function where the\n-/// function can be called directly. `unsafe` functions or calls where types get adjusted are\n-/// ignored.\n+/// **What it does:** Checks for closures which just call another function where\n+/// the function can be called directly. `unsafe` functions or calls where types\n+/// get adjusted are ignored.\n ///\n-/// **Why is this bad?** Needlessly creating a closure adds code for no\n-/// benefit and gives the optimizer more work.\n+/// **Why is this bad?** Needlessly creating a closure adds code for no benefit\n+/// and gives the optimizer more work.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `xs.map(|x| foo(x))` where `foo(_)` is a plain function that takes the exact\n-/// argument type of `x`.\n+/// **Example:**\n+/// ```rust\n+/// xs.map(|x| foo(x))\n+/// ```\n+/// where `foo(_)` is a plain function that takes the exact argument type of `x`.\n declare_lint! {\n-    pub REDUNDANT_CLOSURE, Warn,\n-    \"using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\"\n+    pub REDUNDANT_CLOSURE,\n+    Warn,\n+    \"redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\"\n }\n \n impl LintPass for EtaPass {"}, {"sha": "39a93eae94a0c21d71b161b68e10cc813a2e03b6", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -6,17 +6,22 @@ use syntax::ast::LitKind;\n use utils::paths;\n use utils::{is_expn_of, match_path, match_type, span_lint, walk_ptrs_ty};\n \n-/// **What it does:** This lints about use of `format!(\"string literal with no argument\")` and\n-/// `format!(\"{}\", foo)` where `foo` is a string.\n+/// **What it does:** Checks for the use of `format!(\"string literal with no\n+/// argument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n ///\n-/// **Why is this bad?** There is no point of doing that. `format!(\"too\")` can be replaced by\n-/// `\"foo\".to_owned()` if you really need a `String`. The even worse `&format!(\"foo\")` is often\n-/// encountered in the wild. `format!(\"{}\", foo)` can be replaced by `foo.clone()` if `foo: String`\n-/// or `foo.to_owned()` is `foo: &str`.\n+/// **Why is this bad?** There is no point of doing that. `format!(\"too\")` can\n+/// be replaced by `\"foo\".to_owned()` if you really need a `String`. The even\n+/// worse `&format!(\"foo\")` is often encountered in the wild. `format!(\"{}\",\n+/// foo)` can be replaced by `foo.clone()` if `foo: String` or `foo.to_owned()`\n+/// is `foo: &str`.\n ///\n /// **Known problems:** None.\n ///\n-/// **Examples:** `format!(\"foo\")` and `format!(\"{}\", foo)`\n+/// **Examples:**\n+/// ```rust\n+/// format!(\"foo\")\n+/// format!(\"{}\", foo)\n+/// ```\n declare_lint! {\n     pub USELESS_FORMAT,\n     Warn,"}, {"sha": "e9af1a011d98e767e7c41e15a9ea9db99a0afb77", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -4,7 +4,7 @@ use syntax::ast;\n use utils::{differing_macro_contexts, in_macro, snippet_opt, span_note_and_lint};\n use syntax::ptr::P;\n \n-/// **What it does:** This lint looks for use of the non-existent `=*`, `=!` and `=-` operators.\n+/// **What it does:** Checks for use of the non-existent `=*`, `=!` and `=-` operators.\n ///\n /// **Why is this bad?** This is either a typo of `*=`, `!=` or `-=` or confusing.\n ///\n@@ -20,11 +20,11 @@ declare_lint! {\n     \"suspicious formatting of `*=`, `-=` or `!=`\"\n }\n \n-/// **What it does:** This lint checks for formatting of `else if`. It lints if the `else` and `if`\n-/// are not on the same line or the `else` seems to be missing.\n+/// **What it does:** Checks for formatting of `else if`. It lints if the `else`\n+/// and `if` are not on the same line or the `else` seems to be missing.\n ///\n-/// **Why is this bad?** This is probably some refactoring remnant, even if the code is correct, it\n-/// might look confusing.\n+/// **Why is this bad?** This is probably some refactoring remnant, even if the\n+/// code is correct, it might look confusing.\n ///\n /// **Known problems:** None.\n ///"}, {"sha": "789660391a471d5b0754c32b7e93f04c8a898541", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -7,16 +7,15 @@ use syntax::ast;\n use syntax::codemap::Span;\n use utils::{span_lint, type_is_unsafe_function};\n \n-/// **What it does:** Check for functions with too many parameters.\n+/// **What it does:** Checks for functions with too many parameters.\n ///\n-/// **Why is this bad?** Functions with lots of parameters are considered bad style and reduce\n-/// readability (\u201cwhat does the 5th parameter mean?\u201d). Consider grouping some parameters into a\n-/// new type.\n+/// **Why is this bad?** Functions with lots of parameters are considered bad\n+/// style and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\n+/// grouping some parameters into a new type.\n ///\n /// **Known problems:** None.\n ///\n /// **Example:**\n-///\n /// ```rust\n /// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) { .. }\n /// ```\n@@ -26,21 +25,22 @@ declare_lint! {\n     \"functions with too many arguments\"\n }\n \n-/// **What it does:** Check for public functions that dereferences raw pointer arguments but are\n-/// not marked unsafe.\n+/// **What it does:** Checks for public functions that dereferences raw pointer\n+/// arguments but are not marked unsafe.\n ///\n-/// **Why is this bad?** The function should probably be marked `unsafe`, since for an arbitrary\n-/// raw pointer, there is no way of telling for sure if it is valid.\n+/// **Why is this bad?** The function should probably be marked `unsafe`, since\n+/// for an arbitrary raw pointer, there is no way of telling for sure if it is\n+/// valid.\n ///\n /// **Known problems:**\n ///\n-/// * It does not check functions recursively so if the pointer is passed to a private non-\n-/// `unsafe` function which does the dereferencing, the lint won't trigger.\n-/// * It only checks for arguments whose type are raw pointers, not raw pointers got from an\n-/// argument in some other way (`fn foo(bar: &[*const u8])` or `some_argument.get_raw_ptr()`).\n+/// * It does not check functions recursively so if the pointer is passed to a\n+/// private non-`unsafe` function which does the dereferencing, the lint won't trigger.\n+/// * It only checks for arguments whose type are raw pointers, not raw pointers\n+/// got from an argument in some other way (`fn foo(bar: &[*const u8])` or\n+/// `some_argument.get_raw_ptr()`).\n ///\n /// **Example:**\n-///\n /// ```rust\n /// pub fn foo(x: *const u8) { println!(\"{}\", unsafe { *x }); }\n /// ```"}, {"sha": "92901aa7855bacb0c0ae55a6942865112790efa4", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -5,19 +5,20 @@ use syntax::codemap::Span;\n use utils::{span_lint, snippet, in_macro};\n use rustc_const_math::ConstInt;\n \n-/// **What it does:** This lint checks for identity operations, e.g. `x + 0`.\n+/// **What it does:** Checks for identity operations, e.g. `x + 0`.\n ///\n-/// **Why is this bad?** This code can be removed without changing the meaning. So it just obscures\n-/// what's going on. Delete it mercilessly.\n+/// **Why is this bad?** This code can be removed without changing the\n+/// meaning. So it just obscures what's going on. Delete it mercilessly.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n /// x / 1 + 0 * 1 - 0 | 0\n /// ```\n declare_lint! {\n-    pub IDENTITY_OP, Warn,\n+    pub IDENTITY_OP,\n+    Warn,\n     \"using identity operations, e.g. `x + 0` or `y / 1`\"\n }\n "}, {"sha": "273c1bd0eb0aa97275a0134302d936649cc5c5b0", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -5,11 +5,12 @@ use syntax::ast::*;\n \n use utils::span_help_and_lint;\n \n-/// **What it does:** Warns on the use of `!` or `!=` in an if condition with an else branch\n+/// **What it does:** Checks for usage of `!` or `!=` in an if condition with an\n+/// else branch.\n ///\n-/// **Why is this bad?** Negations reduce the readability of statements\n+/// **Why is this bad?** Negations reduce the readability of statements.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -30,8 +31,9 @@ use utils::span_help_and_lint;\n /// }\n /// ```\n declare_lint! {\n-    pub IF_NOT_ELSE, Allow,\n-    \"finds if branches that could be swapped so no negation operation is necessary on the condition\"\n+    pub IF_NOT_ELSE,\n+    Allow,\n+    \"`if` branches that could be swapped so no negation operation is necessary on the condition\"\n }\n \n pub struct IfNotElse;"}, {"sha": "78b43974364d8a1e513b01acea45b6ab8b54627f", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -4,13 +4,13 @@ use rustc::lint::*;\n use syntax::ast::*;\n use utils::{in_macro, span_lint};\n \n-/// **What it does:** This lints checks for items declared after some statement in a block\n+/// **What it does:** Checks for items declared after some statement in a block.\n ///\n-/// **Why is this bad?** Items live for the entire scope they are declared in. But statements are\n-/// processed in order. This might cause confusion as it's hard to figure out which item is meant\n-/// in a statement.\n+/// **Why is this bad?** Items live for the entire scope they are declared\n+/// in. But statements are processed in order. This might cause confusion as\n+/// it's hard to figure out which item is meant in a statement.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -29,7 +29,7 @@ use utils::{in_macro, span_lint};\n declare_lint! {\n     pub ITEMS_AFTER_STATEMENTS,\n     Allow,\n-    \"finds blocks where an item comes after a statement\"\n+    \"blocks where an item comes after a statement\"\n }\n \n pub struct ItemsAfterStatements;"}, {"sha": "e8ca113fab1f1532babaab296169a6636784fc4d", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -7,33 +7,37 @@ use syntax::codemap::{Span, Spanned};\n use syntax::ptr::P;\n use utils::{get_item_name, in_macro, snippet, span_lint, span_lint_and_then, walk_ptrs_ty};\n \n-/// **What it does:** This lint checks for getting the length of something via `.len()` just to\n-/// compare to zero, and suggests using `.is_empty()` where applicable.\n+/// **What it does:** Checks for getting the length of something via `.len()`\n+/// just to compare to zero, and suggests using `.is_empty()` where applicable.\n ///\n-/// **Why is this bad?** Some structures can answer `.is_empty()` much faster than calculating\n-/// their length. So it is good to get into the habit of using `.is_empty()`, and having it is\n-/// cheap. Besides, it makes the intent clearer than a comparison.\n+/// **Why is this bad?** Some structures can answer `.is_empty()` much faster\n+/// than calculating their length. So it is good to get into the habit of using\n+/// `.is_empty()`, and having it is cheap. Besides, it makes the intent clearer\n+/// than a comparison.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n /// if x.len() == 0 { .. }\n /// ```\n declare_lint! {\n-    pub LEN_ZERO, Warn,\n+    pub LEN_ZERO,\n+    Warn,\n     \"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` \\\n      could be used instead\"\n }\n \n-/// **What it does:** This lint checks for items that implement `.len()` but not `.is_empty()`.\n+/// **What it does:** Checks for items that implement `.len()` but not\n+/// `.is_empty()`.\n ///\n-/// **Why is this bad?** It is good custom to have both methods, because for some data structures,\n-/// asking about the length will be a costly operation, whereas `.is_empty()` can usually answer in\n-/// constant time. Also it used to lead to false positives on the [`len_zero`](#len_zero) lint \u2013\n-/// currently that lint will ignore such entities.\n+/// **Why is this bad?** It is good custom to have both methods, because for\n+/// some data structures, asking about the length will be a costly operation,\n+/// whereas `.is_empty()` can usually answer in constant time. Also it used to\n+/// lead to false positives on the [`len_zero`](#len_zero) lint \u2013 currently that\n+/// lint will ignore such entities.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -42,7 +46,8 @@ declare_lint! {\n /// }\n /// ```\n declare_lint! {\n-    pub LEN_WITHOUT_IS_EMPTY, Warn,\n+    pub LEN_WITHOUT_IS_EMPTY,\n+    Warn,\n     \"traits and impls that have `.len()` but not `.is_empty()`\"\n }\n "}, {"sha": "9c78e864c02ed77e917245f3da8a9c7824b39ea0", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -3,7 +3,7 @@ use rustc::hir;\n use syntax::codemap;\n use utils::{snippet, span_lint_and_then};\n \n-/// **What it does:** This lint checks for variable declarations immediately followed by a\n+/// **What it does:** Checks for variable declarations immediately followed by a\n /// conditional affectation.\n ///\n /// **Why is this bad?** This is not idiomatic Rust.\n@@ -45,7 +45,7 @@ use utils::{snippet, span_lint_and_then};\n declare_lint! {\n     pub USELESS_LET_IF_SEQ,\n     Warn,\n-    \"Checks for unidiomatic `let mut` declaration followed by initialization in `if`\"\n+    \"unidiomatic `let mut` declaration followed by initialization in `if`\"\n }\n \n #[derive(Copy,Clone)]"}, {"sha": "0ab736d2920a1f0ff26492f07ea8b7762cbd35ba", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -260,11 +260,11 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_lint_group(\"clippy_restrictions\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n         arithmetic::INTEGER_ARITHMETIC,\n+        array_indexing::INDEXING_SLICING,\n         assign_ops::ASSIGN_OPS,\n     ]);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n-        array_indexing::INDEXING_SLICING,\n         booleans::NONMINIMAL_BOOL,\n         enum_glob_use::ENUM_GLOB_USE,\n         enum_variants::STUTTER,"}, {"sha": "c0455fa3c671fcd5c021b00df3470b9b3dcdc293", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -7,14 +7,15 @@ use std::collections::{HashSet, HashMap};\n use syntax::codemap::Span;\n use utils::{in_external_macro, span_lint};\n \n-/// **What it does:** This lint checks for lifetime annotations which can be removed by relying on\n-/// lifetime elision.\n+/// **What it does:** Checks for lifetime annotations which can be removed by\n+/// relying on lifetime elision.\n ///\n-/// **Why is this bad?** The additional lifetimes make the code look more complicated, while there\n-/// is nothing out of the ordinary going on. Removing them leads to more readable code.\n+/// **Why is this bad?** The additional lifetimes make the code look more\n+/// complicated, while there is nothing out of the ordinary going on. Removing\n+/// them leads to more readable code.\n ///\n-/// **Known problems:** Potential false negatives: we bail out if the function has a `where` clause\n-/// where lifetimes are mentioned.\n+/// **Known problems:** Potential false negatives: we bail out if the function\n+/// has a `where` clause where lifetimes are mentioned.\n ///\n /// **Example:**\n /// ```rust\n@@ -27,12 +28,14 @@ declare_lint! {\n      would allow omitting them\"\n }\n \n-/// **What it does:** This lint checks for lifetimes in generics that are never used anywhere else.\n+/// **What it does:** Checks for lifetimes in generics that are never used\n+/// anywhere else.\n ///\n-/// **Why is this bad?** The additional lifetimes make the code look more complicated, while there\n-/// is nothing out of the ordinary going on. Removing them leads to more readable code.\n+/// **Why is this bad?** The additional lifetimes make the code look more\n+/// complicated, while there is nothing out of the ordinary going on. Removing\n+/// them leads to more readable code.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust"}, {"sha": "612133a1ddff405fe89d8b5f9f2bdb912e1f1015", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 61, "deletions": 55, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -19,13 +19,13 @@ use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type,\n             walk_ptrs_ty};\n use utils::paths;\n \n-/// **What it does:** This lint checks for looping over the range of `0..len` of some collection\n-/// just to get the values by index.\n+/// **What it does:** Checks for looping over the range of `0..len` of some\n+/// collection just to get the values by index.\n ///\n-/// **Why is this bad?** Just iterating the collection itself makes the intent more clear and is\n-/// probably faster.\n+/// **Why is this bad?** Just iterating the collection itself makes the intent\n+/// more clear and is probably faster.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -39,11 +39,13 @@ declare_lint! {\n     \"for-looping over a range of indices where an iterator over items would do\"\n }\n \n-/// **What it does:** This lint checks for loops on `x.iter()` where `&x` will do, and suggest the latter.\n+/// **What it does:** Checks for loops on `x.iter()` where `&x` will do, and\n+/// suggests the latter.\n ///\n /// **Why is this bad?** Readability.\n ///\n-/// **Known problems:** False negatives. We currently only warn on some known types.\n+/// **Known problems:** False negatives. We currently only warn on some known\n+/// types.\n ///\n /// **Example:**\n /// ```rust\n@@ -56,15 +58,16 @@ declare_lint! {\n     \"for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\"\n }\n \n-/// **What it does:** This lint checks for loops on `x.next()`.\n+/// **What it does:** Checks for loops on `x.next()`.\n ///\n-/// **Why is this bad?** `next()` returns either `Some(value)` if there was a value, or `None`\n-/// otherwise. The insidious thing is that `Option<_>` implements `IntoIterator`, so that possibly\n-/// one value will be iterated, leading to some hard to find bugs. No one will want to write such\n-/// code [except to win an Underhanded Rust\n+/// **Why is this bad?** `next()` returns either `Some(value)` if there was a\n+/// value, or `None` otherwise. The insidious thing is that `Option<_>`\n+/// implements `IntoIterator`, so that possibly one value will be iterated,\n+/// leading to some hard to find bugs. No one will want to write such code\n+/// [except to win an Underhanded Rust\n /// Contest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -76,11 +79,11 @@ declare_lint! {\n     \"for-looping over `_.next()` which is probably not intended\"\n }\n \n-/// **What it does:** This lint checks for `for` loops over `Option` values.\n+/// **What it does:** Checks for `for` loops over `Option` values.\n ///\n /// **Why is this bad?** Readability. This is more clearly expressed as an `if let`.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -97,11 +100,11 @@ declare_lint! {\n     \"for-looping over an `Option`, which is more clearly expressed as an `if let`\"\n }\n \n-/// **What it does:** This lint checks for `for` loops over `Result` values.\n+/// **What it does:** Checks for `for` loops over `Result` values.\n ///\n /// **Why is this bad?** Readability. This is more clearly expressed as an `if let`.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -118,15 +121,14 @@ declare_lint! {\n     \"for-looping over a `Result`, which is more clearly expressed as an `if let`\"\n }\n \n-/// **What it does:** This lint detects `loop + match` combinations that are easier written as a\n-/// `while let` loop.\n+/// **What it does:** Detects `loop + match` combinations that are easier\n+/// written as a `while let` loop.\n ///\n-/// **Why is this bad?** The `while let` loop is usually shorter and more readable\n+/// **Why is this bad?** The `while let` loop is usually shorter and more readable.\n ///\n-/// **Known problems:** Sometimes the wrong binding is displayed (#383)\n+/// **Known problems:** Sometimes the wrong binding is displayed (#383).\n ///\n /// **Example:**\n-///\n /// ```rust\n /// loop {\n ///     let x = match y {\n@@ -143,15 +145,16 @@ declare_lint! {\n declare_lint! {\n     pub WHILE_LET_LOOP,\n     Warn,\n-    \"`loop { if let { ... } else break }` can be written as a `while let` loop\"\n+    \"`loop { if let { ... } else break }`, which can be written as a `while let` loop\"\n }\n \n-/// **What it does:** This lint checks for using `collect()` on an iterator without using the\n-/// result.\n+/// **What it does:** Checks for using `collect()` on an iterator without using\n+/// the result.\n ///\n-/// **Why is this bad?** It is more idiomatic to use a `for` loop over the iterator instead.\n+/// **Why is this bad?** It is more idiomatic to use a `for` loop over the\n+/// iterator instead.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -164,32 +167,34 @@ declare_lint! {\n      written as a for loop\"\n }\n \n-/// **What it does:** This lint checks for loops over ranges `x..y` where both `x` and `y` are\n-/// constant and `x` is greater or equal to `y`, unless the range is reversed or has a negative\n-/// `.step_by(_)`.\n+/// **What it does:** Checks for loops over ranges `x..y` where both `x` and `y`\n+/// are constant and `x` is greater or equal to `y`, unless the range is\n+/// reversed or has a negative `.step_by(_)`.\n ///\n-/// **Why is it bad?** Such loops will either be skipped or loop until wrap-around (in debug code,\n-/// this may `panic!()`). Both options are probably not intended.\n+/// **Why is it bad?** Such loops will either be skipped or loop until\n+/// wrap-around (in debug code, this may `panic!()`). Both options are probably\n+/// not intended.\n ///\n-/// **Known problems:** The lint cannot catch loops over dynamically defined ranges. Doing this\n-/// would require simulating all possible inputs and code paths through the program, which would be\n-/// complex and error-prone.\n+/// **Known problems:** The lint cannot catch loops over dynamically defined\n+/// ranges. Doing this would require simulating all possible inputs and code\n+/// paths through the program, which would be complex and error-prone.\n ///\n-/// **Examples**:\n+/// **Example:**\n /// ```rust\n /// for x in 5..10-5 { .. } // oops, stray `-`\n /// ```\n declare_lint! {\n     pub REVERSE_RANGE_LOOP,\n     Warn,\n-    \"Iterating over an empty range, such as `10..0` or `5..5`\"\n+    \"iteration over an empty range, such as `10..0` or `5..5`\"\n }\n \n-/// **What it does:** This lint checks `for` loops over slices with an explicit counter and\n-/// suggests the use of `.enumerate()`.\n+/// **What it does:** Checks `for` loops over slices with an explicit counter\n+/// and suggests the use of `.enumerate()`.\n ///\n-/// **Why is it bad?** Not only is the version using `.enumerate()` more readable, the compiler is\n-/// able to remove bounds checks which can lead to faster code in some instances.\n+/// **Why is it bad?** Not only is the version using `.enumerate()` more\n+/// readable, the compiler is able to remove bounds checks which can lead to\n+/// faster code in some instances.\n ///\n /// **Known problems:** None.\n ///\n@@ -204,13 +209,13 @@ declare_lint! {\n     \"for-looping with an explicit counter when `_.enumerate()` would do\"\n }\n \n-/// **What it does:** This lint checks for empty `loop` expressions.\n+/// **What it does:** Checks for empty `loop` expressions.\n ///\n-/// **Why is this bad?** Those busy loops burn CPU cycles without doing anything. Think of the\n-/// environment and either block on something or at least make the thread sleep for some\n-/// microseconds.\n+/// **Why is this bad?** Those busy loops burn CPU cycles without doing\n+/// anything. Think of the environment and either block on something or at least\n+/// make the thread sleep for some microseconds.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -219,14 +224,15 @@ declare_lint! {\n declare_lint! {\n     pub EMPTY_LOOP,\n     Warn,\n-    \"empty `loop {}` detected\"\n+    \"empty `loop {}`, which should block or sleep\"\n }\n \n-/// **What it does:** This lint checks for `while let` expressions on iterators.\n+/// **What it does:** Checks for `while let` expressions on iterators.\n ///\n-/// **Why is this bad?** Readability. A simple `for` loop is shorter and conveys the intent better.\n+/// **Why is this bad?** Readability. A simple `for` loop is shorter and conveys\n+/// the intent better.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -238,13 +244,13 @@ declare_lint! {\n     \"using a while-let loop instead of a for loop on an iterator\"\n }\n \n-/// **What it does:** This warns when you iterate on a map (`HashMap` or `BTreeMap`) and ignore\n-/// either the keys or values.\n+/// **What it does:** Checks for iterating a map (`HashMap` or `BTreeMap`) and\n+/// ignoring either the keys or values.\n ///\n-/// **Why is this bad?** Readability. There are `keys` and `values` methods that can be used to\n-/// express that don't need the values or keys.\n+/// **Why is this bad?** Readability. There are `keys` and `values` methods that\n+/// can be used to express that don't need the values or keys.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust"}, {"sha": "39b0c7d80a59c6128611a119ee8def888135d2bf", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -4,20 +4,21 @@ use syntax::ast;\n use utils::{is_adjusted, match_path, match_trait_method, match_type, paths, snippet,\n             span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n \n-/// **What it does:** This lint checks for mapping clone() over an iterator.\n+/// **What it does:** Checks for mapping `clone()` over an iterator.\n ///\n-/// **Why is this bad?** It makes the code less readable.\n+/// **Why is this bad?** It makes the code less readable than using the\n+/// `.cloned()` adapter.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n /// x.map(|e| e.clone());\n /// ```\n declare_lint! {\n-    pub MAP_CLONE, Warn,\n-    \"using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends \\\n-     `.cloned()` instead)\"\n+    pub MAP_CLONE,\n+    Warn,\n+    \"using `.map(|x| x.clone())` to clone an iterator or option's contents\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "d96854cc38ab54d194d5a5dc08ea05a430063f19", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -12,12 +12,12 @@ use utils::paths;\n use utils::{match_type, snippet, span_note_and_lint, span_lint_and_then, in_external_macro, expr_block};\n use utils::sugg::Sugg;\n \n-/// **What it does:** This lint checks for matches with a single arm where an `if let` will usually\n-/// suffice.\n+/// **What it does:** Checks for matches with a single arm where an `if let`\n+/// will usually suffice.\n ///\n /// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -27,17 +27,18 @@ use utils::sugg::Sugg;\n /// }\n /// ```\n declare_lint! {\n-    pub SINGLE_MATCH, Warn,\n+    pub SINGLE_MATCH,\n+    Warn,\n     \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n-     is `_ => {}`) is used; recommends `if let` instead\"\n+     is `_ => {}`) instead of `if let`\"\n }\n \n-/// **What it does:** This lint checks for matches with a two arms where an `if let` will usually\n-/// suffice.\n+/// **What it does:** Checks for matches with a two arms where an `if let` will\n+/// usually suffice.\n ///\n /// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n ///\n-/// **Known problems:** Personal style preferences may differ\n+/// **Known problems:** Personal style preferences may differ.\n ///\n /// **Example:**\n /// ```rust\n@@ -47,22 +48,22 @@ declare_lint! {\n /// }\n /// ```\n declare_lint! {\n-    pub SINGLE_MATCH_ELSE, Allow,\n-    \"a match statement with a two arms where the second arm's pattern is a wildcard; \\\n-     recommends `if let` instead\"\n+    pub SINGLE_MATCH_ELSE,\n+    Allow,\n+    \"a match statement with a two arms where the second arm's pattern is a wildcard \\\n+     instead of `if let`\"\n }\n \n-/// **What it does:** This lint checks for matches where all arms match a reference, suggesting to\n-/// remove the reference and deref the matched expression instead. It also checks for `if let &foo\n-/// = bar` blocks.\n+/// **What it does:** Checks for matches where all arms match a reference,\n+/// suggesting to remove the reference and deref the matched expression\n+/// instead. It also checks for `if let &foo = bar` blocks.\n ///\n-/// **Why is this bad?** It just makes the code less readable. That reference destructuring adds\n-/// nothing to the code.\n+/// **Why is this bad?** It just makes the code less readable. That reference\n+/// destructuring adds nothing to the code.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n-///\n /// ```rust\n /// match x {\n ///     &A(ref y) => foo(y),\n@@ -71,20 +72,19 @@ declare_lint! {\n /// }\n /// ```\n declare_lint! {\n-    pub MATCH_REF_PATS, Warn,\n-    \"a match or `if let` has all arms prefixed with `&`; the match expression can be \\\n-     dereferenced instead\"\n+    pub MATCH_REF_PATS,\n+    Warn,\n+    \"a match or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\"\n }\n \n-/// **What it does:** This lint checks for matches where match expression is a `bool`. It suggests\n-/// to replace the expression with an `if...else` block.\n+/// **What it does:** Checks for matches where match expression is a `bool`. It\n+/// suggests to replace the expression with an `if...else` block.\n ///\n /// **Why is this bad?** It makes the code less readable.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n-///\n /// ```rust\n /// let condition: bool = true;\n /// match condition {\n@@ -93,18 +93,19 @@ declare_lint! {\n /// }\n /// ```\n declare_lint! {\n-    pub MATCH_BOOL, Warn,\n-    \"a match on boolean expression; recommends `if..else` block instead\"\n+    pub MATCH_BOOL,\n+    Warn,\n+    \"a match on a boolean expression instead of an `if..else` block\"\n }\n \n-/// **What it does:** This lint checks for overlapping match arms.\n+/// **What it does:** Checks for overlapping match arms.\n ///\n-/// **Why is this bad?** It is likely to be an error and if not, makes the code less obvious.\n+/// **Why is this bad?** It is likely to be an error and if not, makes the code\n+/// less obvious.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n-///\n /// ```rust\n /// let x = 5;\n /// match x {\n@@ -114,7 +115,9 @@ declare_lint! {\n /// }\n /// ```\n declare_lint! {\n-    pub MATCH_OVERLAPPING_ARM, Warn, \"a match has overlapping arms\"\n+    pub MATCH_OVERLAPPING_ARM,\n+    Warn,\n+    \"a match with overlapping arms\"\n }\n \n #[allow(missing_copy_implementations)]"}, {"sha": "41151835ce1848cce9fae8ee0cd7b7df5f69a296", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -2,10 +2,10 @@ use rustc::lint::*;\n use rustc::hir::{Expr, ExprCall, ExprPath};\n use utils::{match_def_path, paths, span_lint};\n \n-/// **What it does:** This lint checks for usage of `std::mem::forget(t)` where `t` is `Drop`.\n+/// **What it does:** Checks for usage of `std::mem::forget(t)` where `t` is `Drop`.\n ///\n-/// **Why is this bad?** `std::mem::forget(t)` prevents `t` from running its destructor, possibly\n-/// causing leaks\n+/// **Why is this bad?** `std::mem::forget(t)` prevents `t` from running its\n+/// destructor, possibly causing leaks.\n ///\n /// **Known problems:** None.\n ///\n@@ -16,7 +16,7 @@ use utils::{match_def_path, paths, span_lint};\n declare_lint! {\n     pub MEM_FORGET,\n     Allow,\n-    \"`mem::forget` usage on `Drop` types is likely to cause memory leaks\"\n+    \"`mem::forget` usage on `Drop` types, likely to cause memory leaks\"\n }\n \n pub struct MemForget;"}, {"sha": "b329bc3d09956f7291e129c45d6f6af2f5c05385", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 134, "deletions": 93, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -20,52 +20,58 @@ use utils::sugg;\n #[derive(Clone)]\n pub struct Pass;\n \n-/// **What it does:** This lint checks for `.unwrap()` calls on `Option`s.\n+/// **What it does:** Checks for `.unwrap()` calls on `Option`s.\n ///\n-/// **Why is this bad?** Usually it is better to handle the `None` case, or to at least call\n-/// `.expect(_)` with a more helpful message. Still, for a lot of quick-and-dirty code, `unwrap` is\n-/// a good choice, which is why this lint is `Allow` by default.\n+/// **Why is this bad?** Usually it is better to handle the `None` case, or to\n+/// at least call `.expect(_)` with a more helpful message. Still, for a lot of\n+/// quick-and-dirty code, `unwrap` is a good choice, which is why this lint is\n+/// `Allow` by default.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n /// x.unwrap()\n /// ```\n declare_lint! {\n-    pub OPTION_UNWRAP_USED, Allow,\n+    pub OPTION_UNWRAP_USED,\n+    Allow,\n     \"using `Option.unwrap()`, which should at least get a better message using `expect()`\"\n }\n \n-/// **What it does:** This lint checks for `.unwrap()` calls on `Result`s.\n+/// **What it does:** Checks for `.unwrap()` calls on `Result`s.\n ///\n-/// **Why is this bad?** `result.unwrap()` will let the thread panic on `Err` values. Normally, you\n-/// want to implement more sophisticated error handling, and propagate errors upwards with `try!`.\n+/// **Why is this bad?** `result.unwrap()` will let the thread panic on `Err`\n+/// values. Normally, you want to implement more sophisticated error handling,\n+/// and propagate errors upwards with `try!`.\n ///\n-/// Even if you want to panic on errors, not all `Error`s implement good messages on display.\n-/// Therefore it may be beneficial to look at the places where they may get displayed. Activate\n-/// this lint to do just that.\n+/// Even if you want to panic on errors, not all `Error`s implement good\n+/// messages on display.  Therefore it may be beneficial to look at the places\n+/// where they may get displayed. Activate this lint to do just that.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n /// x.unwrap()\n /// ```\n declare_lint! {\n-    pub RESULT_UNWRAP_USED, Allow,\n+    pub RESULT_UNWRAP_USED,\n+    Allow,\n     \"using `Result.unwrap()`, which might be better handled\"\n }\n \n-/// **What it does:** This lint checks for methods that should live in a trait implementation of a\n-/// `std` trait (see [llogiq's blog post](http://llogiq.github.io/2015/07/30/traits.html) for\n-/// further information) instead of an inherent implementation.\n+/// **What it does:** Checks for methods that should live in a trait\n+/// implementation of a `std` trait (see [llogiq's blog\n+/// post](http://llogiq.github.io/2015/07/30/traits.html) for further\n+/// information) instead of an inherent implementation.\n ///\n-/// **Why is this bad?** Implementing the traits improve ergonomics for users of the code, often\n-/// with very little cost. Also people seeing a `mul(..)` method may expect `*` to work equally, so\n-/// you should have good reason to disappoint them.\n+/// **Why is this bad?** Implementing the traits improve ergonomics for users of\n+/// the code, often with very little cost. Also people seeing a `mul(...)` method\n+/// may expect `*` to work equally, so you should have good reason to disappoint\n+/// them.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -75,12 +81,13 @@ declare_lint! {\n /// }\n /// ```\n declare_lint! {\n-    pub SHOULD_IMPLEMENT_TRAIT, Warn,\n+    pub SHOULD_IMPLEMENT_TRAIT,\n+    Warn,\n     \"defining a method that should be implementing a std trait\"\n }\n \n-/// **What it does:** This lint checks for methods with certain name prefixes and which doesn't\n-/// match how self is taken. The actual rules are:\n+/// **What it does:** Checks for methods with certain name prefixes and which\n+/// doesn't match how self is taken. The actual rules are:\n ///\n /// |Prefix |`self` taken          |\n /// |-------|----------------------|\n@@ -90,32 +97,33 @@ declare_lint! {\n /// |`is_`  |`&self` or none       |\n /// |`to_`  |`&self`               |\n ///\n-/// **Why is this bad?** Consistency breeds readability. If you follow the conventions, your users\n-/// won't be surprised that they, e.g., need to supply a mutable reference to a `as_..` function.\n-///\n-/// **Known problems:** None\n+/// **Why is this bad?** Consistency breeds readability. If you follow the\n+/// conventions, your users won't be surprised that they, e.g., need to supply a\n+/// mutable reference to a `as_..` function.\n ///\n-/// **Example**\n+/// **Known problems:** None.\n ///\n+/// **Example:**\n /// ```rust\n /// impl X {\n ///     fn as_str(self) -> &str { .. }\n /// }\n /// ```\n declare_lint! {\n-    pub WRONG_SELF_CONVENTION, Warn,\n+    pub WRONG_SELF_CONVENTION,\n+    Warn,\n     \"defining a method named with an established prefix (like \\\"into_\\\") that takes \\\n      `self` with the wrong convention\"\n }\n \n-/// **What it does:** This is the same as [`wrong_self_convention`](#wrong_self_convention), but\n-/// for public items.\n+/// **What it does:** This is the same as\n+/// [`wrong_self_convention`](#wrong_self_convention), but for public items.\n ///\n /// **Why is this bad?** See [`wrong_self_convention`](#wrong_self_convention).\n ///\n-/// **Known problems:** Actually *renaming* the function may break clients if the function is part\n-/// of the public interface. In that case, be mindful of the stability guarantees you've given your\n-/// users.\n+/// **Known problems:** Actually *renaming* the function may break clients if\n+/// the function is part of the public interface. In that case, be mindful of\n+/// the stability guarantees you've given your users.\n ///\n /// **Example:**\n /// ```rust\n@@ -124,15 +132,16 @@ declare_lint! {\n /// }\n /// ```\n declare_lint! {\n-    pub WRONG_PUB_SELF_CONVENTION, Allow,\n+    pub WRONG_PUB_SELF_CONVENTION,\n+    Allow,\n     \"defining a public method named with an established prefix (like \\\"into_\\\") that takes \\\n      `self` with the wrong convention\"\n }\n \n-/// **What it does:** This lint checks for usage of `ok().expect(..)`.\n+/// **What it does:** Checks for usage of `ok().expect(..)`.\n ///\n-/// **Why is this bad?** Because you usually call `expect()` on the `Result` directly to get a good\n-/// error message.\n+/// **Why is this bad?** Because you usually call `expect()` on the `Result`\n+/// directly to get a better error message.\n ///\n /// **Known problems:** None.\n ///\n@@ -141,14 +150,16 @@ declare_lint! {\n /// x.ok().expect(\"why did I do this again?\")\n /// ```\n declare_lint! {\n-    pub OK_EXPECT, Warn,\n+    pub OK_EXPECT,\n+    Warn,\n     \"using `ok().expect()`, which gives worse error messages than \\\n      calling `expect` directly on the Result\"\n }\n \n-/// **What it does:** This lint checks for usage of `_.map(_).unwrap_or(_)`.\n+/// **What it does:** Checks for usage of `_.map(_).unwrap_or(_)`.\n ///\n-/// **Why is this bad?** Readability, this can be written more concisely as `_.map_or(_, _)`.\n+/// **Why is this bad?** Readability, this can be written more concisely as\n+/// `_.map_or(_, _)`.\n ///\n /// **Known problems:** None.\n ///\n@@ -157,14 +168,16 @@ declare_lint! {\n /// x.map(|a| a + 1).unwrap_or(0)\n /// ```\n declare_lint! {\n-    pub OPTION_MAP_UNWRAP_OR, Warn,\n+    pub OPTION_MAP_UNWRAP_OR,\n+    Warn,\n     \"using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as \\\n      `map_or(a, f)`\"\n }\n \n-/// **What it does:** This lint `Warn`s on `_.map(_).unwrap_or_else(_)`.\n+/// **What it does:** Checks for usage of `_.map(_).unwrap_or_else(_)`.\n ///\n-/// **Why is this bad?** Readability, this can be written more concisely as `_.map_or_else(_, _)`.\n+/// **Why is this bad?** Readability, this can be written more concisely as\n+/// `_.map_or_else(_, _)`.\n ///\n /// **Known problems:** None.\n ///\n@@ -173,14 +186,16 @@ declare_lint! {\n /// x.map(|a| a + 1).unwrap_or_else(some_function)\n /// ```\n declare_lint! {\n-    pub OPTION_MAP_UNWRAP_OR_ELSE, Warn,\n+    pub OPTION_MAP_UNWRAP_OR_ELSE,\n+    Warn,\n     \"using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as \\\n      `map_or_else(g, f)`\"\n }\n \n-/// **What it does:** This lint `Warn`s on `_.filter(_).next()`.\n+/// **What it does:** Checks for usage of `_.filter(_).next()`.\n ///\n-/// **Why is this bad?** Readability, this can be written more concisely as `_.find(_)`.\n+/// **Why is this bad?** Readability, this can be written more concisely as\n+/// `_.find(_)`.\n ///\n /// **Known problems:** None.\n ///\n@@ -189,30 +204,36 @@ declare_lint! {\n /// iter.filter(|x| x == 0).next()\n /// ```\n declare_lint! {\n-    pub FILTER_NEXT, Warn,\n+    pub FILTER_NEXT,\n+    Warn,\n     \"using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\"\n }\n \n-/// **What it does:** This lint `Warn`s on `_.filter(_).map(_)`, `_.filter(_).flat_map(_)`,\n-/// `_.filter_map(_).flat_map(_)` and similar.\n+/// **What it does:** Checks for usage of `_.filter(_).map(_)`,\n+/// `_.filter(_).flat_map(_)`, `_.filter_map(_).flat_map(_)` and similar.\n ///\n-/// **Why is this bad?** Readability, this can be written more concisely as a single method call\n+/// **Why is this bad?** Readability, this can be written more concisely as a\n+/// single method call.\n ///\n-/// **Known problems:** Often requires a condition + Option/Iterator creation inside the closure\n+/// **Known problems:** Often requires a condition + Option/Iterator creation\n+/// inside the closure.\n ///\n /// **Example:**\n /// ```rust\n /// iter.filter(|x| x == 0).map(|x| x * 2)\n /// ```\n declare_lint! {\n-    pub FILTER_MAP, Allow,\n-    \"using combinations of `filter`, `map`, `filter_map` and `flat_map` which can usually be written as a single method call\"\n+    pub FILTER_MAP,\n+    Allow,\n+    \"using combinations of `filter`, `map`, `filter_map` and `flat_map` which can \\\n+     usually be written as a single method call\"\n }\n \n-/// **What it does:** This lint `Warn`s on an iterator search (such as `find()`, `position()`, or\n-/// `rposition()`) followed by a call to `is_some()`.\n+/// **What it does:** Checks for an iterator search (such as `find()`,\n+/// `position()`, or `rposition()`) followed by a call to `is_some()`.\n ///\n-/// **Why is this bad?** Readability, this can be written more concisely as `_.any(_)`.\n+/// **Why is this bad?** Readability, this can be written more concisely as\n+/// `_.any(_)`.\n ///\n /// **Known problems:** None.\n ///\n@@ -221,15 +242,17 @@ declare_lint! {\n /// iter.find(|x| x == 0).is_some()\n /// ```\n declare_lint! {\n-    pub SEARCH_IS_SOME, Warn,\n+    pub SEARCH_IS_SOME,\n+    Warn,\n     \"using an iterator search followed by `is_some()`, which is more succinctly \\\n      expressed as a call to `any()`\"\n }\n \n-/// **What it does:** This lint `Warn`s on using `.chars().next()` on a `str` to check if it\n-/// starts with a given char.\n+/// **What it does:** Checks for usage of `.chars().next()` on a `str` to check\n+/// if it starts with a given char.\n ///\n-/// **Why is this bad?** Readability, this can be written more concisely as `_.starts_with(_)`.\n+/// **Why is this bad?** Readability, this can be written more concisely as\n+/// `_.starts_with(_)`.\n ///\n /// **Known problems:** None.\n ///\n@@ -238,15 +261,22 @@ declare_lint! {\n /// name.chars().next() == Some('_')\n /// ```\n declare_lint! {\n-    pub CHARS_NEXT_CMP, Warn,\n+    pub CHARS_NEXT_CMP,\n+    Warn,\n     \"using `.chars().next()` to check if a string starts with a char\"\n }\n \n-/// **What it does:** This lint checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`, etc., and\n-/// suggests to use `or_else`, `unwrap_or_else`, etc., or `unwrap_or_default` instead.\n+/// **What it does:** Checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`,\n+/// etc., and suggests to use `or_else`, `unwrap_or_else`, etc., or\n+/// `unwrap_or_default` instead.\n+///\n+/// **Why is this bad?** The function will always be called and potentially\n+/// allocate an object acting as the default.\n ///\n-/// **Why is this bad?** The function will always be called and potentially allocate an object\n-/// in expressions such as:\n+/// **Known problems:** If the function has side-effects, not calling it will\n+/// change the semantic of the program, but you shouldn't rely on that anyway.\n+///\n+/// **Example:**\n /// ```rust\n /// foo.unwrap_or(String::new())\n /// ```\n@@ -258,17 +288,17 @@ declare_lint! {\n /// ```rust\n /// foo.unwrap_or_default()\n /// ```\n-///\n-/// **Known problems:** If the function as side-effects, not calling it will change the semantic of\n-/// the program, but you shouldn't rely on that anyway.\n declare_lint! {\n-    pub OR_FUN_CALL, Warn,\n-    \"using any `*or` method when the `*or_else` would do\"\n+    pub OR_FUN_CALL,\n+    Warn,\n+    \"using any `*or` method with a function call, which suggests `*or_else`\"\n }\n \n-/// **What it does:** This lint checks for usage of `.extend(s)` on a `Vec` to extend the vector by a slice.\n+/// **What it does:** Checks for usage of `.extend(s)` on a `Vec` to extend the\n+/// vector by a slice.\n ///\n-/// **Why is this bad?** Since Rust 1.6, the `extend_from_slice(_)` method is stable and at least for now faster.\n+/// **Why is this bad?** Since Rust 1.6, the `extend_from_slice(_)` method is\n+/// stable and at least for now faster.\n ///\n /// **Known problems:** None.\n ///\n@@ -277,14 +307,15 @@ declare_lint! {\n /// my_vec.extend(&xs)\n /// ```\n declare_lint! {\n-    pub EXTEND_FROM_SLICE, Warn,\n+    pub EXTEND_FROM_SLICE,\n+    Warn,\n     \"`.extend_from_slice(_)` is a faster way to extend a Vec by a slice\"\n }\n \n-/// **What it does:** This lint warns on using `.clone()` on a `Copy` type.\n+/// **What it does:** Checks for usage of `.clone()` on a `Copy` type.\n ///\n-/// **Why is this bad?** The only reason `Copy` types implement `Clone` is for generics, not for\n-/// using the `clone` method on a concrete type.\n+/// **Why is this bad?** The only reason `Copy` types implement `Clone` is for\n+/// generics, not for using the `clone` method on a concrete type.\n ///\n /// **Known problems:** None.\n ///\n@@ -293,13 +324,15 @@ declare_lint! {\n /// 42u64.clone()\n /// ```\n declare_lint! {\n-    pub CLONE_ON_COPY, Warn, \"using `clone` on a `Copy` type\"\n+    pub CLONE_ON_COPY,\n+    Warn,\n+    \"using `clone` on a `Copy` type\"\n }\n \n-/// **What it does:** This lint warns on using `.clone()` on an `&&T`\n+/// **What it does:** Checks for usage of `.clone()` on an `&&T`.\n ///\n-/// **Why is this bad?** Cloning an `&&T` copies the inner `&T`, instead of cloning the underlying\n-/// `T`\n+/// **Why is this bad?** Cloning an `&&T` copies the inner `&T`, instead of\n+/// cloning the underlying `T`.\n ///\n /// **Known problems:** None.\n ///\n@@ -313,12 +346,15 @@ declare_lint! {\n /// }\n /// ```\n declare_lint! {\n-    pub CLONE_DOUBLE_REF, Warn, \"using `clone` on `&&T`\"\n+    pub CLONE_DOUBLE_REF,\n+    Warn,\n+    \"using `clone` on `&&T`\"\n }\n \n-/// **What it does:** This lint warns about `new` not returning `Self`.\n+/// **What it does:** Checks for `new` not returning `Self`.\n ///\n-/// **Why is this bad?** As a convention, `new` methods are used to make a new instance of a type.\n+/// **Why is this bad?** As a convention, `new` methods are used to make a new\n+/// instance of a type.\n ///\n /// **Known problems:** None.\n ///\n@@ -330,12 +366,16 @@ declare_lint! {\n /// }\n /// ```\n declare_lint! {\n-    pub NEW_RET_NO_SELF, Warn, \"not returning `Self` in a `new` method\"\n+    pub NEW_RET_NO_SELF,\n+    Warn,\n+    \"not returning `Self` in a `new` method\"\n }\n \n-/// **What it does:** This lint checks for string methods that receive a single-character `str` as an argument, e.g. `_.split(\"x\")`.\n+/// **What it does:** Checks for string methods that receive a single-character\n+/// `str` as an argument, e.g. `_.split(\"x\")`.\n ///\n-/// **Why is this bad?** Performing these methods using a `char` is faster than using a `str`.\n+/// **Why is this bad?** Performing these methods using a `char` is faster than\n+/// using a `str`.\n ///\n /// **Known problems:** Does not catch multi-byte unicode characters.\n ///\n@@ -350,10 +390,10 @@ declare_lint! {\n      `_.split(\\\"x\\\")`\"\n }\n \n-/// **What it does:** This lint checks for getting the inner pointer of a temporary `CString`.\n+/// **What it does:** Checks for getting the inner pointer of a temporary `CString`.\n ///\n-/// **Why is this bad?** The inner pointer of a `CString` is only valid as long as the `CString` is\n-/// alive.\n+/// **Why is this bad?** The inner pointer of a `CString` is only valid as long\n+/// as the `CString` is alive.\n ///\n /// **Known problems:** None.\n ///\n@@ -377,10 +417,11 @@ declare_lint! {\n     \"getting the inner pointer of a temporary `CString`\"\n }\n \n-/// **What it does:** This lint checks for use of `.iter().nth()` (and the related\n+/// **What it does:** Checks for use of `.iter().nth()` (and the related\n /// `.iter_mut().nth()`) on standard library types with O(1) element access.\n ///\n-/// **Why is this bad?** `.get()` and `.get_mut()` are more efficient and more readable.\n+/// **Why is this bad?** `.get()` and `.get_mut()` are more efficient and more\n+/// readable.\n ///\n /// **Known problems:** None.\n ///"}, {"sha": "05d4d40e0abe003217a584ab6b9a3d278339d12a", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -5,18 +5,23 @@ use std::cmp::{PartialOrd, Ordering};\n use syntax::ptr::P;\n use utils::{match_def_path, paths, span_lint};\n \n-/// **What it does:** This lint checks for expressions where `std::cmp::min` and `max` are used to\n-/// clamp values, but switched so that the result is constant.\n+/// **What it does:** Checks for expressions where `std::cmp::min` and `max` are\n+/// used to clamp values, but switched so that the result is constant.\n ///\n-/// **Why is this bad?** This is in all probability not the intended outcome. At the least it hurts\n-/// readability of the code.\n+/// **Why is this bad?** This is in all probability not the intended outcome. At\n+/// the least it hurts readability of the code.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `min(0, max(100, x))` will always be equal to `0`. Probably the author meant to\n-/// clamp the value between 0 and 100, but has erroneously swapped `min` and `max`.\n+/// **Example:**\n+/// ```rust\n+/// min(0, max(100, x))\n+/// ```\n+/// It will always be equal to `0`. Probably the author meant to clamp the value\n+/// between 0 and 100, but has erroneously swapped `min` and `max`.\n declare_lint! {\n-    pub MIN_MAX, Warn,\n+    pub MIN_MAX,\n+    Warn,\n     \"`min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\"\n }\n "}, {"sha": "3dc30110b9252e2f2bb151e2465acacab52abf86", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 95, "deletions": 51, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -15,29 +15,29 @@ use utils::{\n };\n use utils::sugg::Sugg;\n \n-/// **What it does:** This lint checks for function arguments and let bindings denoted as `ref`.\n+/// **What it does:** Checks for function arguments and let bindings denoted as `ref`.\n ///\n-/// **Why is this bad?** The `ref` declaration makes the function take an owned value, but turns\n-/// the argument into a reference (which means that the value is destroyed when exiting the\n-/// function). This adds not much value: either take a reference type, or take an owned value and\n-/// create references in the body.\n+/// **Why is this bad?** The `ref` declaration makes the function take an owned\n+/// value, but turns the argument into a reference (which means that the value\n+/// is destroyed when exiting the function). This adds not much value: either\n+/// take a reference type, or take an owned value and create references in the\n+/// body.\n ///\n-/// For let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The type of `x` is more\n-/// obvious with the former.\n+/// For let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The\n+/// type of `x` is more obvious with the former.\n ///\n-/// **Known problems:** If the argument is dereferenced within the function, removing the `ref`\n-/// will lead to errors. This can be fixed by removing the dereferences, e.g. changing `*x` to `x`\n-/// within the function.\n+/// **Known problems:** If the argument is dereferenced within the function,\n+/// removing the `ref` will lead to errors. This can be fixed by removing the\n+/// dereferences, e.g. changing `*x` to `x` within the function.\n ///\n /// **Example:**\n /// ```rust\n /// fn foo(ref x: u8) -> bool { .. }\n /// ```\n declare_lint! {\n-    pub TOPLEVEL_REF_ARG, Warn,\n-    \"An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), \\\n-     or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take \\\n-     references with `&`.\"\n+    pub TOPLEVEL_REF_ARG,\n+    Warn,\n+    \"an entire binding declared as `ref`, in a function argument or a `let` statement\"\n }\n \n #[allow(missing_copy_implementations)]\n@@ -99,15 +99,22 @@ impl LateLintPass for TopLevelRefPass {\n     }\n }\n \n-/// **What it does:** This lint checks for comparisons to NAN.\n+/// **What it does:** Checks for comparisons to NaN.\n ///\n-/// **Why is this bad?** NAN does not compare meaningfully to anything \u2013 not even itself \u2013 so those comparisons are simply wrong.\n+/// **Why is this bad?** NaN does not compare meaningfully to anything \u2013 not\n+/// even itself \u2013 so those comparisons are simply wrong.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `x == NAN`\n-declare_lint!(pub CMP_NAN, Deny,\n-              \"comparisons to NAN (which will always return false, which is probably not intended)\");\n+/// **Example:**\n+/// ```rust\n+/// x == NAN\n+/// ```\n+declare_lint! {\n+    pub CMP_NAN,\n+    Deny,\n+    \"comparisons to NAN, which will always return false, probably not intended\"\n+}\n \n #[derive(Copy,Clone)]\n pub struct CmpNan;\n@@ -144,17 +151,27 @@ fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n     });\n }\n \n-/// **What it does:** This lint checks for (in-)equality comparisons on floating-point values (apart from zero), except in functions called `*eq*` (which probably implement equality for a type involving floats).\n+/// **What it does:** Checks for (in-)equality comparisons on floating-point\n+/// values (apart from zero), except in functions called `*eq*` (which probably\n+/// implement equality for a type involving floats).\n ///\n-/// **Why is this bad?** Floating point calculations are usually imprecise, so asking if two values are *exactly* equal is asking for trouble. For a good guide on what to do, see [the floating point guide](http://www.floating-point-gui.de/errors/comparison).\n+/// **Why is this bad?** Floating point calculations are usually imprecise, so\n+/// asking if two values are *exactly* equal is asking for trouble. For a good\n+/// guide on what to do, see [the floating point\n+/// guide](http://www.floating-point-gui.de/errors/comparison).\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `y == 1.23f64`\n-declare_lint!(pub FLOAT_CMP, Warn,\n-              \"using `==` or `!=` on float values (as floating-point operations \\\n-               usually involve rounding errors, it is always better to check for approximate \\\n-               equality within small bounds)\");\n+/// **Example:**\n+/// ```rust\n+/// y == 1.23f64\n+/// y != x  // where both are floats\n+/// ```\n+declare_lint! {\n+    pub FLOAT_CMP,\n+    Warn,\n+    \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n+}\n \n #[derive(Copy,Clone)]\n pub struct FloatCmp;\n@@ -230,15 +247,24 @@ fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n     matches!(walk_ptrs_ty(cx.tcx.expr_ty(expr)).sty, ty::TyFloat(_))\n }\n \n-/// **What it does:** This lint checks for conversions to owned values just for the sake of a comparison.\n+/// **What it does:** Checks for conversions to owned values just for the sake\n+/// of a comparison.\n ///\n-/// **Why is this bad?** The comparison can operate on a reference, so creating an owned value effectively throws it away directly afterwards, which is needlessly consuming code and heap space.\n+/// **Why is this bad?** The comparison can operate on a reference, so creating\n+/// an owned value effectively throws it away directly afterwards, which is\n+/// needlessly consuming code and heap space.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `x.to_owned() == y`\n-declare_lint!(pub CMP_OWNED, Warn,\n-              \"creating owned instances for comparing with others, e.g. `x == \\\"foo\\\".to_string()`\");\n+/// **Example:**\n+/// ```rust\n+/// x.to_owned() == y\n+/// ```\n+declare_lint! {\n+    pub CMP_OWNED,\n+    Warn,\n+    \"creating owned instances for comparing with others, e.g. `x == \\\"foo\\\".to_string()`\"\n+}\n \n #[derive(Copy,Clone)]\n pub struct CmpOwned;\n@@ -320,14 +346,24 @@ fn is_str_arg(cx: &LateContext, args: &[P<Expr>]) -> bool {\n         matches!(walk_ptrs_ty(cx.tcx.expr_ty(&args[0])).sty, ty::TyStr)\n }\n \n-/// **What it does:** This lint checks for getting the remainder of a division by one.\n+/// **What it does:** Checks for getting the remainder of a division by one.\n ///\n-/// **Why is this bad?** The result can only ever be zero. No one will write such code deliberately, unless trying to win an Underhanded Rust Contest. Even for that contest, it's probably a bad idea. Use something more underhanded.\n+/// **Why is this bad?** The result can only ever be zero. No one will write\n+/// such code deliberately, unless trying to win an Underhanded Rust\n+/// Contest. Even for that contest, it's probably a bad idea. Use something more\n+/// underhanded.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `x % 1`\n-declare_lint!(pub MODULO_ONE, Warn, \"taking a number modulo 1, which always returns 0\");\n+/// **Example:**\n+/// ```rust\n+/// x % 1\n+/// ```\n+declare_lint! {\n+    pub MODULO_ONE,\n+    Warn,\n+    \"taking a number modulo 1, which always returns 0\"\n+}\n \n #[derive(Copy,Clone)]\n pub struct ModuloOne;\n@@ -350,20 +386,24 @@ impl LateLintPass for ModuloOne {\n     }\n }\n \n-/// **What it does:** This lint checks for patterns in the form `name @ _`.\n+/// **What it does:** Checks for patterns in the form `name @ _`.\n ///\n /// **Why is this bad?** It's almost always more readable to just use direct bindings.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example**:\n+/// **Example:**\n /// ```rust\n /// match v {\n ///     Some(x) => (),\n ///     y @ _   => (), // easier written as `y`,\n /// }\n /// ```\n-declare_lint!(pub REDUNDANT_PATTERN, Warn, \"using `name @ _` in a pattern\");\n+declare_lint! {\n+    pub REDUNDANT_PATTERN,\n+    Warn,\n+    \"using `name @ _` in a pattern\"\n+}\n \n #[derive(Copy,Clone)]\n pub struct PatternPass;\n@@ -390,22 +430,26 @@ impl LateLintPass for PatternPass {\n }\n \n \n-/// **What it does:** This lint checks for the use of bindings with a single leading underscore\n+/// **What it does:** Checks for the use of bindings with a single leading underscore.\n ///\n-/// **Why is this bad?** A single leading underscore is usually used to indicate that a binding\n-/// will not be used. Using such a binding breaks this expectation.\n+/// **Why is this bad?** A single leading underscore is usually used to indicate\n+/// that a binding will not be used. Using such a binding breaks this\n+/// expectation.\n ///\n-/// **Known problems:** The lint does not work properly with desugaring and macro, it has been\n-/// allowed in the mean time.\n+/// **Known problems:** The lint does not work properly with desugaring and\n+/// macro, it has been allowed in the mean time.\n ///\n-/// **Example**:\n+/// **Example:**\n /// ```rust\n /// let _x = 0;\n /// let y = _x + 1; // Here we are using `_x`, even though it has a leading underscore.\n ///                 // We should rename `_x` to `x`\n /// ```\n-declare_lint!(pub USED_UNDERSCORE_BINDING, Allow,\n-              \"using a binding which is prefixed with an underscore\");\n+declare_lint! {\n+    pub USED_UNDERSCORE_BINDING,\n+    Allow,\n+    \"using a binding which is prefixed with an underscore\"\n+}\n \n #[derive(Copy, Clone)]\n pub struct UsedUnderscoreBinding;"}, {"sha": "63b27f48f0d9caf91102bb3459c24bb1ae7ddfb2", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -5,9 +5,11 @@ use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::visit::FnKind;\n use utils::{span_lint, span_help_and_lint, snippet, snippet_opt, span_lint_and_then};\n-/// **What it does:** This lint checks for structure field patterns bound to wildcards.\n+\n+/// **What it does:** Checks for structure field patterns bound to wildcards.\n ///\n-/// **Why is this bad?** Using `..` instead is shorter and leaves the focus on the fields that are actually bound.\n+/// **Why is this bad?** Using `..` instead is shorter and leaves the focus on\n+/// the fields that are actually bound.\n ///\n /// **Known problems:** None.\n ///\n@@ -16,13 +18,15 @@ use utils::{span_lint, span_help_and_lint, snippet, snippet_opt, span_lint_and_t\n /// let { a: _, b: ref b, c: _ } = ..\n /// ```\n declare_lint! {\n-    pub UNNEEDED_FIELD_PATTERN, Warn,\n-    \"Struct fields are bound to a wildcard instead of using `..`\"\n+    pub UNNEEDED_FIELD_PATTERN,\n+    Warn,\n+    \"struct fields bound to a wildcard instead of using `..`\"\n }\n \n-/// **What it does:** This lint checks for function arguments having the similar names differing by an underscore\n+/// **What it does:** Checks for function arguments having the similar names\n+/// differing by an underscore.\n ///\n-/// **Why is this bad?** It affects code readability\n+/// **Why is this bad?** It affects code readability.\n ///\n /// **Known problems:** None.\n ///\n@@ -31,11 +35,12 @@ declare_lint! {\n /// fn foo(a: i32, _a: i32) {}\n /// ```\n declare_lint! {\n-    pub DUPLICATE_UNDERSCORE_ARGUMENT, Warn,\n-    \"Function arguments having names which only differ by an underscore\"\n+    pub DUPLICATE_UNDERSCORE_ARGUMENT,\n+    Warn,\n+    \"function arguments having names which only differ by an underscore\"\n }\n \n-/// **What it does:** This lint detects closures called in the same expression where they are defined.\n+/// **What it does:** Detects closures called in the same expression where they are defined.\n ///\n /// **Why is this bad?** It is unnecessarily adding to the expression's complexity.\n ///\n@@ -46,13 +51,15 @@ declare_lint! {\n /// (|| 42)()\n /// ```\n declare_lint! {\n-    pub REDUNDANT_CLOSURE_CALL, Warn,\n-    \"Closures should not be called in the expression they are defined\"\n+    pub REDUNDANT_CLOSURE_CALL,\n+    Warn,\n+    \"throwaway closures called in the expression they are defined\"\n }\n \n-/// **What it does:** This lint detects expressions of the form `--x`\n+/// **What it does:** Detects expressions of the form `--x`.\n ///\n-/// **Why is this bad?** It can mislead C/C++ programmers to think `x` was decremented.\n+/// **Why is this bad?** It can mislead C/C++ programmers to think `x` was\n+/// decremented.\n ///\n /// **Known problems:** None.\n ///\n@@ -61,8 +68,9 @@ declare_lint! {\n /// --x;\n /// ```\n declare_lint! {\n-    pub DOUBLE_NEG, Warn,\n-    \"`--x` is a double negation of `x` and not a pre-decrement as in C or C++\"\n+    pub DOUBLE_NEG,\n+    Warn,\n+    \"`--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\"\n }\n \n /// **What it does:** Warns on hexadecimal literals with mixed-case letter digits.\n@@ -76,8 +84,9 @@ declare_lint! {\n /// let y = 0x1a9BAcD;\n /// ```\n declare_lint! {\n-    pub MIXED_CASE_HEX_LITERALS, Warn,\n-    \"letter digits in hex literals should be either completely upper- or lowercased\"\n+    pub MIXED_CASE_HEX_LITERALS,\n+    Warn,\n+    \"hex literals whose letter digits are not consistently upper- or lowercased\"\n }\n \n /// **What it does:** Warns if literal suffixes are not separated by an underscore.\n@@ -91,8 +100,9 @@ declare_lint! {\n /// let y = 123832i32;\n /// ```\n declare_lint! {\n-    pub UNSEPARATED_LITERAL_SUFFIX, Allow,\n-    \"literal suffixes should be separated with an underscore\"\n+    pub UNSEPARATED_LITERAL_SUFFIX,\n+    Allow,\n+    \"literals whose suffix is not separated by an underscore\"\n }\n \n "}, {"sha": "24eb8dfc3635075bcee8a6b89d0ea388bafda15f", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -4,12 +4,13 @@ use rustc::lint::*;\n use rustc::ty::{TypeAndMut, TyRef};\n use utils::{higher, in_external_macro, span_lint};\n \n-/// **What it does:** This lint checks for instances of `mut mut` references.\n+/// **What it does:** Checks for instances of `mut mut` references.\n ///\n-/// **Why is this bad?** Multiple `mut`s don't add anything meaningful to the source. This is\n-/// either a copy'n'paste error, or it shows a fundamental misunderstanding of references)\n+/// **Why is this bad?** Multiple `mut`s don't add anything meaningful to the\n+/// source. This is either a copy'n'paste error, or it shows a fundamental\n+/// misunderstanding of references.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust"}, {"sha": "21aa21e08a4198785381900cce681627eb10d185", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -4,22 +4,22 @@ use rustc::hir::*;\n use syntax::ptr::P;\n use utils::span_lint;\n \n-/// **What it does:** This lint detects giving a mutable reference to a function that only requires\n-/// an immutable reference.\n+/// **What it does:** Detects giving a mutable reference to a function that only\n+/// requires an immutable reference.\n ///\n-/// **Why is this bad?** The immutable reference rules out all other references to the value. Also\n-/// the code misleads about the intent of the call site.\n+/// **Why is this bad?** The immutable reference rules out all other references\n+/// to the value. Also the code misleads about the intent of the call site.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example**\n+/// **Example:**\n /// ```rust\n /// my_vec.push(&mut value)\n /// ```\n declare_lint! {\n     pub UNNECESSARY_MUT_PASSED,\n     Warn,\n-    \"an argument is passed as a mutable reference although the function/method only demands an \\\n+    \"an argument passed as a mutable reference although the callee only demands an \\\n      immutable reference\"\n }\n "}, {"sha": "ff2d8b2115434fc1be276aafdcd592843c3dffdc", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -9,13 +9,15 @@ use rustc::hir::Expr;\n use syntax::ast;\n use utils::{match_type, paths, span_lint};\n \n-/// **What it does:** This lint checks for usages of `Mutex<X>` where an atomic will do.\n+/// **What it does:** Checks for usages of `Mutex<X>` where an atomic will do.\n ///\n-/// **Why is this bad?** Using a mutex just to make access to a plain bool or reference sequential\n-/// is shooting flies with cannons. `std::atomic::AtomicBool` and `std::atomic::AtomicPtr` are\n-/// leaner and faster.\n+/// **Why is this bad?** Using a mutex just to make access to a plain bool or\n+/// reference sequential is shooting flies with cannons.\n+/// `std::atomic::AtomicBool` and `std::atomic::AtomicPtr` are leaner and\n+/// faster.\n ///\n-/// **Known problems:** This lint cannot detect if the mutex is actually used for waiting before a critical section.\n+/// **Known problems:** This lint cannot detect if the mutex is actually used\n+/// for waiting before a critical section.\n ///\n /// **Example:**\n /// ```rust\n@@ -27,12 +29,13 @@ declare_lint! {\n     \"using a mutex where an atomic value could be used instead\"\n }\n \n-/// **What it does:** This lint checks for usages of `Mutex<X>` where `X` is an integral type.\n+/// **What it does:** Checks for usages of `Mutex<X>` where `X` is an integral type.\n ///\n /// **Why is this bad?** Using a mutex just to make access to a plain integer sequential is\n /// shooting flies with cannons. `std::atomic::usize` is leaner and faster.\n ///\n-/// **Known problems:** This lint cannot detect if the mutex is actually used for waiting before a critical section.\n+/// **Known problems:** This lint cannot detect if the mutex is actually used\n+/// for waiting before a critical section.\n ///\n /// **Example:**\n /// ```rust"}, {"sha": "64f0af90aa81d041f17b385b3695ca813fdb0bb0", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -9,14 +9,15 @@ use syntax::codemap::Spanned;\n use utils::{span_lint, span_lint_and_then, snippet};\n use utils::sugg::Sugg;\n \n-/// **What it does:** This lint checks for expressions of the form `if c { true } else { false }`\n+/// **What it does:** Checks for expressions of the form `if c { true } else { false }`\n /// (or vice versa) and suggest using the condition directly.\n ///\n /// **Why is this bad?** Redundant code.\n ///\n-/// **Known problems:** Maybe false positives: Sometimes, the two branches are painstakingly\n-/// documented (which we of course do not detect), so they *may* have some value. Even then, the\n-/// documentation can be rewritten to match the shorter code.\n+/// **Known problems:** Maybe false positives: Sometimes, the two branches are\n+/// painstakingly documented (which we of course do not detect), so they *may*\n+/// have some value. Even then, the documentation can be rewritten to match the\n+/// shorter code.\n ///\n /// **Example:**\n /// ```rust\n@@ -29,19 +30,21 @@ declare_lint! {\n      `if p { true } else { false }`\"\n }\n \n-/// **What it does:** This lint checks for expressions of the form `x == true` (or vice versa) and\n-/// suggest using the variable directly.\n+/// **What it does:** Checks for expressions of the form `x == true` (or vice\n+/// versa) and suggest using the variable directly.\n ///\n /// **Why is this bad?** Unnecessary code.\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `if x == true { }` could be `if x { }`\n+/// **Example:**\n+/// ```rust\n+/// if x == true { }  // could be `if x { }`\n+/// ```\n declare_lint! {\n     pub BOOL_COMPARISON,\n     Warn,\n-    \"comparing a variable to a boolean, e.g. \\\n-     `if x == true`\"\n+    \"comparing a variable to a boolean, e.g. `if x == true`\"\n }\n \n #[derive(Copy,Clone)]"}, {"sha": "29691504b8283fda7710ec1af4eca383647442fe", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -8,12 +8,13 @@ use rustc::ty::TyRef;\n use utils::{span_lint, in_macro};\n use rustc::ty::adjustment::AutoAdjustment::AdjustDerefRef;\n \n-/// **What it does:** This lint checks for address of operations (`&`) that are going to be\n-/// dereferenced immediately by the compiler\n+/// **What it does:** Checks for address of operations (`&`) that are going to\n+/// be dereferenced immediately by the compiler.\n ///\n-/// **Why is this bad?** Suggests that the receiver of the expression borrows the expression.\n+/// **Why is this bad?** Suggests that the receiver of the expression borrows\n+/// the expression.\n ///\n-/// **Known problems:**\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust"}, {"sha": "2b5aa12f7a9b3442047b105ff9099566338070b8", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -3,9 +3,11 @@ use rustc::ty::TyStruct;\n use rustc::hir::{Expr, ExprStruct};\n use utils::span_lint;\n \n-/// **What it does:** This lint warns on needlessly including a base struct on update when all fields are changed anyway.\n+/// **What it does:** Checks for needlessly including a base struct on update\n+/// when all fields are changed anyway.\n ///\n-/// **Why is this bad?** This will cost resources (because the base has to be somewhere), and make the code less readable.\n+/// **Why is this bad?** This will cost resources (because the base has to be\n+/// somewhere), and make the code less readable.\n ///\n /// **Known problems:** None.\n ///"}, {"sha": "3749b36540c496fad41080a4010d0503bef66855", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -9,7 +9,7 @@ use utils::span_lint;\n ///\n /// **Why is this bad?** It's more readable to just negate.\n ///\n-/// **Known problems:** This only catches integers (for now)\n+/// **Known problems:** This only catches integers (for now).\n ///\n /// **Example:**\n /// ```rust\n@@ -18,7 +18,7 @@ use utils::span_lint;\n declare_lint! {\n     pub NEG_MULTIPLY,\n     Warn,\n-    \"Warns on multiplying integers with -1\"\n+    \"multiplying integers with -1\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "7a2db85b3c71ac195a91055686eda57bd8ab9b64", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -9,13 +9,13 @@ use utils::paths;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, return_ty, same_tys, span_lint_and_then};\n use utils::sugg::DiagnosticBuilderExt;\n \n-/// **What it does:** This lints about type with a `fn new() -> Self` method\n-/// and no implementation of\n-/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n+/// **What it does:** Checks for types with a `fn new() -> Self` method and no\n+/// implementation of\n+/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html).\n ///\n-/// **Why is this bad?** User might expect to be able to use\n-/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n-/// as the type can be constructed without arguments.\n+/// **Why is this bad?** The user might expect to be able to use\n+/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) as the\n+/// type can be constructed without arguments.\n ///\n /// **Known problems:** Hopefully none.\n ///\n@@ -43,21 +43,21 @@ use utils::sugg::DiagnosticBuilderExt;\n /// }\n /// ```\n ///\n-/// You can also have `new()` call `Default::default()`\n+/// You can also have `new()` call `Default::default()`.\n declare_lint! {\n     pub NEW_WITHOUT_DEFAULT,\n     Warn,\n     \"`fn new() -> Self` method without `Default` implementation\"\n }\n \n-/// **What it does:** This lints about type with a `fn new() -> Self` method\n+/// **What it does:** Checks for types with a `fn new() -> Self` method\n /// and no implementation of\n-/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n+/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html),\n+/// where the `Default` can be derived by `#[derive(Default)]`.\n ///\n-/// **Why is this bad?** User might expect to be able to use\n-/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html)\n-/// as the type can be\n-/// constructed without arguments.\n+/// **Why is this bad?** The user might expect to be able to use\n+/// [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) as the\n+/// type can be constructed without arguments.\n ///\n /// **Known problems:** Hopefully none.\n ///\n@@ -73,7 +73,7 @@ declare_lint! {\n /// }\n /// ```\n ///\n-/// Just prepend `#[derive(Default)]` before the `struct` definition\n+/// Just prepend `#[derive(Default)]` before the `struct` definition.\n declare_lint! {\n     pub NEW_WITHOUT_DEFAULT_DERIVE,\n     Warn,"}, {"sha": "18f1ce6a1f224c4eb064f77802d54aa6fd11aa77", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -4,10 +4,11 @@ use rustc::hir::{Expr, Expr_, Stmt, StmtSemi, BlockCheckMode, UnsafeSource};\n use utils::{in_macro, span_lint, snippet_opt, span_lint_and_then};\n use std::ops::Deref;\n \n-/// **What it does:** This lint checks for statements which have no effect.\n+/// **What it does:** Checks for statements which have no effect.\n ///\n-/// **Why is this bad?** Similar to dead code, these statements are actually executed. However, as\n-/// they have no effect, all they do is make the code less readable.\n+/// **Why is this bad?** Similar to dead code, these statements are actually\n+/// executed. However, as they have no effect, all they do is make the code less\n+/// readable.\n ///\n /// **Known problems:** None.\n ///\n@@ -21,10 +22,11 @@ declare_lint! {\n     \"statements with no effect\"\n }\n \n-/// **What it does:** This lint checks for expression statements that can be reduced to a sub-expression\n+/// **What it does:** Checks for expression statements that can be reduced to a\n+/// sub-expression.\n ///\n-/// **Why is this bad?** Expressions by themselves often have no side-effects. Having such\n-/// expressions reduces readability.\n+/// **Why is this bad?** Expressions by themselves often have no side-effects.\n+/// Having such expressions reduces readability.\n ///\n /// **Known problems:** None.\n ///"}, {"sha": "593eb0fd61dcf7ad1b84f4cef4b1fa685a1ec452", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -6,27 +6,33 @@ use syntax::attr;\n use syntax::visit::{Visitor, walk_block, walk_pat, walk_expr};\n use utils::{span_lint_and_then, in_macro, span_lint};\n \n-/// **What it does:** This lint warns about names that are very similar and thus confusing\n+/// **What it does:** Checks for names that are very similar and thus confusing.\n ///\n-/// **Why is this bad?** It's hard to distinguish between names that differ only by a single character\n+/// **Why is this bad?** It's hard to distinguish between names that differ only\n+/// by a single character.\n ///\n /// **Known problems:** None?\n ///\n-/// **Example:** `checked_exp` and `checked_expr`\n+/// **Example:**\n+/// ```rust\n+/// let checked_exp = something;\n+/// let checked_expr = something_else;\n+/// ```\n declare_lint! {\n     pub SIMILAR_NAMES,\n     Allow,\n     \"similarly named items and bindings\"\n }\n \n-/// **What it does:** This lint warns about having too many variables whose name consists of a single character\n+/// **What it does:** Checks for too many variables whose name consists of a\n+/// single character.\n ///\n-/// **Why is this bad?** It's hard to memorize what a variable means without a descriptive name.\n+/// **Why is this bad?** It's hard to memorize what a variable means without a\n+/// descriptive name.\n ///\n /// **Known problems:** None?\n ///\n /// **Example:**\n-///\n /// ```rust\n /// let (a, b, c, d, e, f, g) = (...);\n /// ```"}, {"sha": "42851c1fe24c251373176fce60ffa3f96a35987e", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -4,13 +4,13 @@ use syntax::ast::LitKind;\n use syntax::codemap::{Span, Spanned};\n use utils::{match_type, paths, span_lint, walk_ptrs_ty_depth};\n \n-/// **What it does:** This lint checks for duplicate open options as well as combinations that make\n-/// no sense.\n+/// **What it does:** Checks for duplicate open options as well as combinations\n+/// that make no sense.\n ///\n-/// **Why is this bad?** In the best case, the code will be harder to read than necessary. I don't\n-/// know the worst case.\n+/// **Why is this bad?** In the best case, the code will be harder to read than\n+/// necessary. I don't know the worst case.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust"}, {"sha": "24bccf687f18130dc89cd2edd28299691f76b842", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -2,10 +2,10 @@ use rustc::lint::*;\n use rustc::hir::*;\n use utils::span_lint;\n \n-/// **What it does:** This lint finds classic underflow / overflow checks.\n+/// **What it does:** Detects classic underflow/overflow checks.\n ///\n-/// **Why is this bad?** Most classic C underflow / overflow checks will fail in Rust. Users can\n-/// use functions like `overflowing_*` and `wrapping_*` instead.\n+/// **Why is this bad?** Most classic C underflow/overflow checks will fail in\n+/// Rust. Users can use functions like `overflowing_*` and `wrapping_*` instead.\n ///\n /// **Known problems:** None.\n ///\n@@ -14,8 +14,11 @@ use utils::span_lint;\n /// a + b < a\n /// ```\n \n-declare_lint!(pub OVERFLOW_CHECK_CONDITIONAL, Warn,\n-              \"Using overflow checks which are likely to panic\");\n+declare_lint! {\n+    pub OVERFLOW_CHECK_CONDITIONAL,\n+    Warn,\n+    \"overflow checks inspired by C which are likely to panic\"\n+}\n \n #[derive(Copy, Clone)]\n pub struct OverflowCheckConditional;"}, {"sha": "d4b7c0fb75aeaa01a52d3e2865a734d6bd87bd6d", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -3,17 +3,24 @@ use rustc::lint::*;\n use syntax::ast::LitKind;\n use utils::{is_direct_expn_of, match_path, paths, span_lint};\n \n-/// **What it does:** This lint checks for missing parameters in `panic!`.\n+/// **What it does:** Checks for missing parameters in `panic!`.\n ///\n-/// **Known problems:** Should you want to use curly brackets in `panic!` without any parameter,\n-/// this lint will warn.\n+/// **Why is this bad?** Contrary to the `format!` family of macros, there are\n+/// two forms of `panic!`: if there are no parameters given, the first argument\n+/// is not a format string and used literally. So while `format!(\"{}\")` will\n+/// fail to compile, `panic!(\"{}\")` will not.\n+///\n+/// **Known problems:** Should you want to use curly brackets in `panic!`\n+/// without any parameter, this lint will warn.\n ///\n /// **Example:**\n /// ```rust\n /// panic!(\"This `panic!` is probably missing a parameter there: {}\");\n /// ```\n declare_lint! {\n-    pub PANIC_PARAMS, Warn, \"missing parameters in `panic!`\"\n+    pub PANIC_PARAMS,\n+    Warn,\n+    \"missing parameters in `panic!` calls\"\n }\n \n #[allow(missing_copy_implementations)]"}, {"sha": "1d10fb19c7338876aec16da36ea96bb6268b84ab", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -3,23 +3,25 @@ use syntax::ast::*;\n use syntax::codemap::Spanned;\n use utils::{span_lint, snippet};\n \n-/// **What it does:** This lint checks for operations where precedence may be unclear and suggests\n-/// to add parentheses. Currently it catches the following:\n+/// **What it does:** Checks for operations where precedence may be unclear\n+/// and suggests to add parentheses. Currently it catches the following:\n /// * mixed usage of arithmetic and bit shifting/combining operators without parentheses\n /// * a \"negative\" numeric literal (which is really a unary `-` followed by a numeric literal)\n ///   followed by a method call\n ///\n-/// **Why is this bad?** Because not everyone knows the precedence of those operators by heart, so\n-/// expressions like these may trip others trying to reason about the code.\n+/// **Why is this bad?** Not everyone knows the precedence of those operators by\n+/// heart, so expressions like these may trip others trying to reason about the\n+/// code.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Examples:**\n+/// **Example:**\n /// * `1 << 2 + 3` equals 32, while `(1 << 2) + 3` equals 7\n /// * `-1i32.abs()` equals -1, while `(-1i32).abs()` equals 1\n declare_lint! {\n-    pub PRECEDENCE, Warn,\n-    \"catches operations where precedence may be unclear\"\n+    pub PRECEDENCE,\n+    Warn,\n+    \"operations where precedence may be unclear\"\n }\n \n #[derive(Copy,Clone)]"}, {"sha": "39f1f5b39a211a159be1b84aaeee1515292ec870", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -4,11 +4,11 @@ use rustc::lint::*;\n use utils::paths;\n use utils::{is_expn_of, match_path, span_lint};\n \n-/// **What it does:** This lint warns whenever you print on *stdout*. The purpose of this lint is\n-/// to catch debugging remnants.\n+/// **What it does:** Checks for printing on *stdout*. The purpose of this lint\n+/// is to catch debugging remnants.\n ///\n-/// **Why is this bad?** People often print on *stdout* while debugging an application and might\n-/// forget to remove those prints afterward.\n+/// **Why is this bad?** People often print on *stdout* while debugging an\n+/// application and might forget to remove those prints afterward.\n ///\n /// **Known problems:** Only catches `print!` and `println!` calls.\n ///\n@@ -22,11 +22,11 @@ declare_lint! {\n     \"printing on stdout\"\n }\n \n-/// **What it does:** This lint warns whenever you use `Debug` formatting. The purpose of this lint\n-/// is to catch debugging remnants.\n+/// **What it does:** Checks for use of `Debug` formatting. The purpose of this\n+/// lint is to catch debugging remnants.\n ///\n-/// **Why is this bad?** The purpose of the `Debug` trait is to facilitate debugging Rust code. It\n-/// should not be used in in user-facing output.\n+/// **Why is this bad?** The purpose of the `Debug` trait is to facilitate\n+/// debugging Rust code. It should not be used in in user-facing output.\n ///\n /// **Example:**\n /// ```rust\n@@ -35,7 +35,7 @@ declare_lint! {\n declare_lint! {\n     pub USE_DEBUG,\n     Allow,\n-    \"use `Debug`-based formatting\"\n+    \"use of `Debug`-based formatting\"\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "f985b2a00319566a6692cf9a695b5094b49850cb", "filename": "clippy_lints/src/ptr_arg.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_arg.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -7,14 +7,14 @@ use rustc::ty;\n use syntax::ast::NodeId;\n use utils::{match_type, paths, span_lint};\n \n-/// **What it does:** This lint checks for function arguments of type `&String` or `&Vec` unless\n-/// the references are mutable.\n+/// **What it does:** Checks for function arguments of type `&String` or `&Vec`\n+/// unless the references are mutable.\n ///\n-/// **Why is this bad?** Requiring the argument to be of the specific size makes the function less\n-/// useful for no benefit; slices in the form of `&[T]` or `&str` usually suffice and can be\n-/// obtained from other types, too.\n+/// **Why is this bad?** Requiring the argument to be of the specific size makes\n+/// the function less useful for no benefit; slices in the form of `&[T]` or\n+/// `&str` usually suffice and can be obtained from other types, too.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -23,8 +23,7 @@ use utils::{match_type, paths, span_lint};\n declare_lint! {\n     pub PTR_ARG,\n     Warn,\n-    \"fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` \\\n-     instead, respectively\"\n+    \"arguments of the type `&Vec<...>` (instead of `&[...]`) or `&String` (instead of `&str`)\"\n }\n \n #[derive(Copy,Clone)]"}, {"sha": "2e9a72e54a9dfde61be8879ac6e2c9efd33f8ee5", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -4,35 +4,37 @@ use syntax::codemap::Spanned;\n use utils::{is_integer_literal, match_type, paths, snippet, span_lint};\n use utils::higher;\n \n-/// **What it does:** This lint checks for iterating over ranges with a `.step_by(0)`, which never\n-/// terminates.\n+/// **What it does:** Checks for iterating over ranges with a `.step_by(0)`,\n+/// which never terminates.\n ///\n-/// **Why is this bad?** This very much looks like an oversight, since with `loop { .. }` there is\n-/// an obvious better way to endlessly loop.\n+/// **Why is this bad?** This very much looks like an oversight, since with\n+/// `loop { .. }` there is an obvious better way to endlessly loop.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n /// for x in (5..5).step_by(0) { .. }\n /// ```\n declare_lint! {\n-    pub RANGE_STEP_BY_ZERO, Warn,\n-    \"using Range::step_by(0), which produces an infinite iterator\"\n+    pub RANGE_STEP_BY_ZERO,\n+    Warn,\n+    \"using `Range::step_by(0)`, which produces an infinite iterator\"\n }\n-/// **What it does:** This lint checks for zipping a collection with the range of `0.._.len()`.\n+/// **What it does:** Checks for zipping a collection with the range of `0.._.len()`.\n ///\n /// **Why is this bad?** The code is better expressed with `.enumerate()`.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n /// x.iter().zip(0..x.len())\n /// ```\n declare_lint! {\n-    pub RANGE_ZIP_WITH_LEN, Warn,\n-    \"zipping iterator with a range when enumerate() would do\"\n+    pub RANGE_ZIP_WITH_LEN,\n+    Warn,\n+    \"zipping iterator with a range when `enumerate()` would do\"\n }\n \n #[derive(Copy,Clone)]"}, {"sha": "770c524b946cc8af56242143a6d5cb019d903626", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -11,8 +11,8 @@ use syntax::codemap::{Span, BytePos};\n use syntax::parse::token::InternedString;\n use utils::{is_expn_of, match_def_path, match_type, paths, span_lint, span_help_and_lint};\n \n-/// **What it does:** This lint checks [regex] creation (with `Regex::new`, `RegexBuilder::new` or\n-/// `RegexSet::new`) for correct regex syntax.\n+/// **What it does:** Checks [regex] creation (with `Regex::new`,\n+/// `RegexBuilder::new` or `RegexSet::new`) for correct regex syntax.\n ///\n /// [regex]: https://crates.io/crates/regex\n ///\n@@ -27,16 +27,17 @@ use utils::{is_expn_of, match_def_path, match_type, paths, span_lint, span_help_\n declare_lint! {\n     pub INVALID_REGEX,\n     Deny,\n-    \"finds invalid regular expressions\"\n+    \"invalid regular expressions\"\n }\n \n-/// **What it does:** This lint checks for trivial [regex] creation (with `Regex::new`,\n+/// **What it does:** Checks for trivial [regex] creation (with `Regex::new`,\n /// `RegexBuilder::new` or `RegexSet::new`).\n ///\n /// [regex]: https://crates.io/crates/regex\n ///\n-/// **Why is this bad?** This can likely be replaced by `==` or `str::starts_with`,\n-/// `str::ends_with` or `std::contains` or other `str` methods.\n+/// **Why is this bad?** Matching the regex can likely be replaced by `==` or\n+/// `str::starts_with`, `str::ends_with` or `std::contains` or other `str`\n+/// methods.\n ///\n /// **Known problems:** None.\n ///\n@@ -47,16 +48,17 @@ declare_lint! {\n declare_lint! {\n     pub TRIVIAL_REGEX,\n     Warn,\n-    \"finds trivial regular expressions\"\n+    \"trivial regular expressions\"\n }\n \n-/// **What it does:** This lint checks for usage of `regex!(_)` which as of now is usually slower\n-/// than `Regex::new(_)` unless called in a loop (which is a bad idea anyway).\n+/// **What it does:** Checks for usage of `regex!(_)` which (as of now) is\n+/// usually slower than `Regex::new(_)` unless called in a loop (which is a bad\n+/// idea anyway).\n ///\n-/// **Why is this bad?** Performance, at least for now. The macro version is likely to catch up\n-/// long-term, but for now the dynamic version is faster.\n+/// **Why is this bad?** Performance, at least for now. The macro version is\n+/// likely to catch up long-term, but for now the dynamic version is faster.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -65,7 +67,7 @@ declare_lint! {\n declare_lint! {\n     pub REGEX_MACRO,\n     Warn,\n-    \"finds use of `regex!(_)`, suggests `Regex::new(_)` instead\"\n+    \"use of `regex!(_)` instead of `Regex::new(_)`\"\n }\n \n #[derive(Clone, Default)]"}, {"sha": "770194dddbe141f615666346b719a9080b791ace", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -5,37 +5,43 @@ use syntax::visit::FnKind;\n \n use utils::{span_note_and_lint, span_lint_and_then, snippet_opt, match_path_ast, in_external_macro};\n \n-/// **What it does:** This lint checks for return statements at the end of a block.\n+/// **What it does:** Checks for return statements at the end of a block.\n ///\n-/// **Why is this bad?** Removing the `return` and semicolon will make the code more rusty.\n+/// **Why is this bad?** Removing the `return` and semicolon will make the code\n+/// more rusty.\n ///\n-/// **Known problems:** Following this lint's advice may currently run afoul of Rust issue\n-/// [#31439](https://github.com/rust-lang/rust/issues/31439), so if you get lifetime errors, please\n-/// roll back the change until that issue is fixed.\n+/// **Known problems:** Following this lint's advice may currently run afoul of\n+/// Rust issue [#31439](https://github.com/rust-lang/rust/issues/31439), so if\n+/// you get lifetime errors, please roll back the change until that issue is\n+/// fixed.\n ///\n /// **Example:**\n /// ```rust\n /// fn foo(x: usize) { return x; }\n /// ```\n declare_lint! {\n-    pub NEEDLESS_RETURN, Warn,\n+    pub NEEDLESS_RETURN,\n+    Warn,\n     \"using a return statement like `return expr;` where an expression would suffice\"\n }\n \n-/// **What it does:** This lint checks for `let`-bindings, which are subsequently returned.\n+/// **What it does:** Checks for `let`-bindings, which are subsequently returned.\n ///\n-/// **Why is this bad?** It is just extraneous code. Remove it to make your code more rusty.\n+/// **Why is this bad?** It is just extraneous code. Remove it to make your code\n+/// more rusty.\n ///\n-/// **Known problems:** Following this lint's advice may currently run afoul of Rust issue\n-/// [#31439](https://github.com/rust-lang/rust/issues/31439), so if you get lifetime errors, please\n-/// roll back the change until that issue is fixed.\n+/// **Known problems:** Following this lint's advice may currently run afoul of\n+/// Rust issue [#31439](https://github.com/rust-lang/rust/issues/31439), so if\n+/// you get lifetime errors, please roll back the change until that issue is\n+/// fixed.\n ///\n /// **Example:**\n /// ```rust\n /// { let x = ..; x }\n /// ```\n declare_lint! {\n-    pub LET_AND_RETURN, Warn,\n+    pub LET_AND_RETURN,\n+    Warn,\n     \"creating a let-binding and then immediately returning it like `let x = expr; x` at \\\n      the end of a block\"\n }"}, {"sha": "6cf10d883d31d47767bc5dbd90dcc03231e3264b", "filename": "clippy_lints/src/serde.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fserde.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fserde.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -2,16 +2,18 @@ use rustc::lint::*;\n use rustc::hir::*;\n use utils::{span_lint, get_trait_def_id, paths};\n \n-/// **What it does:** This lint checks for mis-uses of the serde API\n+/// **What it does:** Checks for mis-uses of the serde API.\n ///\n-/// **Why is this bad?** Serde is very finnicky about how its API should be used, but the type system can't be used to enforce it (yet)\n+/// **Why is this bad?** Serde is very finnicky about how its API should be\n+/// used, but the type system can't be used to enforce it (yet).\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** implementing `Visitor::visit_string` but not `Visitor::visit_str`\n+/// **Example:** Implementing `Visitor::visit_string` but not `Visitor::visit_str`.\n declare_lint! {\n-    pub SERDE_API_MISUSE, Warn,\n-    \"Various things that will negatively affect your serde experience\"\n+    pub SERDE_API_MISUSE,\n+    Warn,\n+    \"various things that will negatively affect your serde experience\"\n }\n \n "}, {"sha": "8e3a44031ab516cf1963d7ba191ad01e8f81ff43", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -7,62 +7,68 @@ use std::ops::Deref;\n use syntax::codemap::Span;\n use utils::{higher, in_external_macro, snippet, span_lint_and_then};\n \n-/// **What it does:** This lint checks for bindings that shadow other bindings already in scope,\n-/// while just changing reference level or mutability.\n+/// **What it does:** Checks for bindings that shadow other bindings already in\n+/// scope, while just changing reference level or mutability.\n ///\n-/// **Why is this bad?** Not much, in fact it's a very common pattern in Rust code. Still, some may\n-/// opt to avoid it in their code base, they can set this lint to `Warn`.\n+/// **Why is this bad?** Not much, in fact it's a very common pattern in Rust\n+/// code. Still, some may opt to avoid it in their code base, they can set this\n+/// lint to `Warn`.\n ///\n-/// **Known problems:** This lint, as the other shadowing related lints, currently only catches\n-/// very simple patterns.\n+/// **Known problems:** This lint, as the other shadowing related lints,\n+/// currently only catches very simple patterns.\n ///\n /// **Example:**\n /// ```rust\n /// let x = &x;\n /// ```\n declare_lint! {\n-    pub SHADOW_SAME, Allow,\n+    pub SHADOW_SAME,\n+    Allow,\n     \"rebinding a name to itself, e.g. `let mut x = &mut x`\"\n }\n \n-/// **What it does:** This lint checks for bindings that shadow other bindings already in scope,\n-/// while reusing the original value.\n+/// **What it does:** Checks for bindings that shadow other bindings already in\n+/// scope, while reusing the original value.\n ///\n-/// **Why is this bad?** Not too much, in fact it's a common pattern in Rust code. Still, some\n-/// argue that name shadowing like this hurts readability, because a value may be bound to\n-/// different things depending on position in the code.\n+/// **Why is this bad?** Not too much, in fact it's a common pattern in Rust\n+/// code. Still, some argue that name shadowing like this hurts readability,\n+/// because a value may be bound to different things depending on position in\n+/// the code.\n ///\n-/// **Known problems:** This lint, as the other shadowing related lints, currently only catches\n-/// very simple patterns.\n+/// **Known problems:** This lint, as the other shadowing related lints,\n+/// currently only catches very simple patterns.\n ///\n /// **Example:**\n /// ```rust\n /// let x = x + 1;\n /// ```\n declare_lint! {\n-    pub SHADOW_REUSE, Allow,\n+    pub SHADOW_REUSE,\n+    Allow,\n     \"rebinding a name to an expression that re-uses the original value, e.g. \\\n-    `let x = x + 1`\"\n+     `let x = x + 1`\"\n }\n \n-/// **What it does:** This lint checks for bindings that shadow other bindings already in scope,\n-/// either without a initialization or with one that does not even use the original value.\n+/// **What it does:** Checks for bindings that shadow other bindings already in\n+/// scope, either without a initialization or with one that does not even use\n+/// the original value.\n ///\n-/// **Why is this bad?** Name shadowing can hurt readability, especially in large code bases,\n-/// because it is easy to lose track of the active binding at any place in the code. This can be\n-/// alleviated by either giving more specific names to bindings ore introducing more scopes to\n-/// contain the bindings.\n+/// **Why is this bad?** Name shadowing can hurt readability, especially in\n+/// large code bases, because it is easy to lose track of the active binding at\n+/// any place in the code. This can be alleviated by either giving more specific\n+/// names to bindings ore introducing more scopes to contain the bindings.\n ///\n-/// **Known problems:** This lint, as the other shadowing related lints, currently only catches\n-/// very simple patterns.\n+/// **Known problems:** This lint, as the other shadowing related lints,\n+/// currently only catches very simple patterns.\n ///\n /// **Example:**\n /// ```rust\n /// let x = y; let x = z; // shadows the earlier binding\n /// ```\n declare_lint! {\n-    pub SHADOW_UNRELATED, Allow,\n-    \"The name is re-bound without even using the original value\"\n+    pub SHADOW_UNRELATED,\n+    Allow,\n+    \"rebinding a name without even using the original value\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "28e61cf2e206893c4303c7b0c864607348d219b0", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -4,10 +4,11 @@ use syntax::codemap::Spanned;\n use utils::SpanlessEq;\n use utils::{match_type, paths, span_lint, span_lint_and_then, walk_ptrs_ty, get_parent_expr};\n \n-/// **What it does:** This lint matches code of the form `x = x + y` (without `let`!).\n+/// **What it does:** Checks for string appends of the form `x = x + y` (without\n+/// `let`!).\n ///\n-/// **Why is this bad?** It's not really bad, but some people think that the `.push_str(_)` method\n-/// is more readable.\n+/// **Why is this bad?** It's not really bad, but some people think that the\n+/// `.push_str(_)` method is more readable.\n ///\n /// **Known problems:** None.\n ///\n@@ -20,21 +21,24 @@ use utils::{match_type, paths, span_lint, span_lint_and_then, walk_ptrs_ty, get_\n declare_lint! {\n     pub STRING_ADD_ASSIGN,\n     Allow,\n-    \"using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\"\n+    \"using `x = x + ..` where x is a `String` instead of `push_str()`\"\n }\n \n-/// **What it does:** The `string_add` lint matches all instances of `x + _` where `x` is of type\n-/// `String`, but only if [`string_add_assign`](#string_add_assign) does *not* match.\n+/// **What it does:** Checks for all instances of `x + _` where `x` is of type\n+/// `String`, but only if [`string_add_assign`](#string_add_assign) does *not*\n+/// match.\n ///\n-/// **Why is this bad?** It's not bad in and of itself. However, this particular `Add`\n-/// implementation is asymmetric (the other operand need not be `String`, but `x` does), while\n-/// addition as mathematically defined is symmetric, also the `String::push_str(_)` function is a\n-/// perfectly good replacement. Therefore some dislike it and wish not to have it in their code.\n+/// **Why is this bad?** It's not bad in and of itself. However, this particular\n+/// `Add` implementation is asymmetric (the other operand need not be `String`,\n+/// but `x` does), while addition as mathematically defined is symmetric, also\n+/// the `String::push_str(_)` function is a perfectly good replacement.\n+/// Therefore some dislike it and wish not to have it in their code.\n ///\n-/// That said, other people think that string addition, having a long tradition in other languages\n-/// is actually fine, which is why we decided to make this particular lint `allow` by default.\n+/// That said, other people think that string addition, having a long tradition\n+/// in other languages is actually fine, which is why we decided to make this\n+/// particular lint `allow` by default.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n ///\n@@ -45,24 +49,25 @@ declare_lint! {\n declare_lint! {\n     pub STRING_ADD,\n     Allow,\n-    \"using `x + ..` where x is a `String`; suggests using `push_str()` instead\"\n+    \"using `x + ..` where x is a `String` instead of `push_str()`\"\n }\n \n-/// **What it does:** This lint matches the `as_bytes` method called on string\n-/// literals that contain only ASCII characters.\n+/// **What it does:** Checks for the `as_bytes` method called on string literals\n+/// that contain only ASCII characters.\n ///\n-/// **Why is this bad?** Byte string literals (e.g. `b\"foo\"`) can be used instead. They are shorter\n-/// but less discoverable than `as_bytes()`.\n+/// **Why is this bad?** Byte string literals (e.g. `b\"foo\"`) can be used\n+/// instead. They are shorter but less discoverable than `as_bytes()`.\n ///\n-/// **Example:**\n+/// **Known Problems:** None.\n ///\n+/// **Example:**\n /// ```rust\n /// let bs = \"a byte string\".as_bytes();\n /// ```\n declare_lint! {\n     pub STRING_LIT_AS_BYTES,\n     Warn,\n-    \"calling `as_bytes` on a string literal; suggests using a byte string literal instead\"\n+    \"calling `as_bytes` on a string literal instead of using a byte string literal\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "584bcb0d866a76ea0b1d40c1485beb0a4a5f3120", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -5,10 +5,10 @@ use syntax::codemap::mk_sp;\n use utils::{differing_macro_contexts, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty, SpanlessEq};\n use utils::sugg::Sugg;\n \n-/// **What it does:** This lints manual swapping.\n+/// **What it does:** Checks for manual swapping.\n ///\n-/// **Why is this bad?** The `std::mem::swap` function exposes the intent better without\n-/// deinitializing or copying either variable.\n+/// **Why is this bad?** The `std::mem::swap` function exposes the intent better\n+/// without deinitializing or copying either variable.\n ///\n /// **Known problems:** None.\n ///\n@@ -21,10 +21,10 @@ use utils::sugg::Sugg;\n declare_lint! {\n     pub MANUAL_SWAP,\n     Warn,\n-    \"manual swap\"\n+    \"manual swap of two variables\"\n }\n \n-/// **What it does:** This lints `foo = bar; bar = foo` sequences.\n+/// **What it does:** Checks for `foo = bar; bar = foo` sequences.\n ///\n /// **Why is this bad?** This looks like a failed attempt to swap.\n ///"}, {"sha": "5b5802695bb894aa0adca8aff695ae7ff3bad2bd", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -3,11 +3,11 @@ use rustc::hir::{Expr, ExprAssign, ExprField, ExprStruct, ExprTup, ExprTupField}\n use utils::is_adjusted;\n use utils::span_lint;\n \n-/// **What it does:** This lint checks for construction of a structure or tuple just to assign a\n-/// value in it.\n+/// **What it does:** Checks for construction of a structure or tuple just to\n+/// assign a value in it.\n ///\n-/// **Why is this bad?** Readability. If the structure is only created to be updated, why not write\n-/// the structure you want in the first place?\n+/// **Why is this bad?** Readability. If the structure is only created to be\n+/// updated, why not write the structure you want in the first place?\n ///\n /// **Known problems:** None.\n ///"}, {"sha": "e042cb678e3384cdb4b18c1ee68e419e759b4d88", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -5,12 +5,13 @@ use rustc::hir::*;\n use utils::{match_def_path, paths, span_lint, span_lint_and_then};\n use utils::sugg;\n \n-/// **What it does:** This lint checks for transmutes that can't ever be correct on any architecture\n+/// **What it does:** Checks for transmutes that can't ever be correct on any\n+/// architecture.\n ///\n-/// **Why is this bad?** It's basically guaranteed to be undefined behaviour\n+/// **Why is this bad?** It's basically guaranteed to be undefined behaviour.\n ///\n-/// **Known problems:** When accessing C, users might want to store pointer sized objects in\n-/// `extradata` arguments to save an allocation.\n+/// **Known problems:** When accessing C, users might want to store pointer\n+/// sized objects in `extradata` arguments to save an allocation.\n ///\n /// **Example:**\n /// ```rust\n@@ -22,11 +23,11 @@ declare_lint! {\n     \"transmutes that are confusing at best, undefined behaviour at worst and always useless\"\n }\n \n-/// **What it does:** This lint checks for transmutes to the original type of the object and\n-/// transmutes that could be a cast.\n+/// **What it does:** Checks for transmutes to the original type of the object\n+/// and transmutes that could be a cast.\n ///\n-/// **Why is this bad?** Readability. The code tricks people into thinking that something complex\n-/// is going on\n+/// **Why is this bad?** Readability. The code tricks people into thinking that\n+/// something complex is going on.\n ///\n /// **Known problems:** None.\n ///\n@@ -40,9 +41,10 @@ declare_lint! {\n     \"transmutes that have the same to and from types or could be a cast/coercion\"\n }\n \n-/// **What it does:*** This lint checks for transmutes between a type `T` and `*T`.\n+/// **What it does:** Checks for transmutes between a type `T` and `*T`.\n ///\n-/// **Why is this bad?** It's easy to mistakenly transmute between a type and a pointer to that type.\n+/// **Why is this bad?** It's easy to mistakenly transmute between a type and a\n+/// pointer to that type.\n ///\n /// **Known problems:** None.\n ///\n@@ -56,7 +58,7 @@ declare_lint! {\n     \"transmutes that have to or from types that are a pointer to the other\"\n }\n \n-/// **What it does:*** This lint checks for transmutes from a pointer to a reference.\n+/// **What it does:** Checks for transmutes from a pointer to a reference.\n ///\n /// **Why is this bad?** This can always be rewritten with `&` and `*`.\n ///"}, {"sha": "b240fb6199cf83701797f271378e8740d4dd106b", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 157, "deletions": 67, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -14,12 +14,13 @@ use utils::paths;\n #[allow(missing_copy_implementations)]\n pub struct TypePass;\n \n-/// **What it does:** This lint checks for use of `Box<Vec<_>>` anywhere in the code.\n+/// **What it does:** Checks for use of `Box<Vec<_>>` anywhere in the code.\n ///\n-/// **Why is this bad?** `Vec` already keeps its contents in a separate area on the heap. So if you\n-/// `Box` it, you just add another level of indirection without any benefit whatsoever.\n+/// **Why is this bad?** `Vec` already keeps its contents in a separate area on\n+/// the heap. So if you `Box` it, you just add another level of indirection\n+/// without any benefit whatsoever.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -28,12 +29,13 @@ pub struct TypePass;\n /// }\n /// ```\n declare_lint! {\n-    pub BOX_VEC, Warn,\n+    pub BOX_VEC,\n+    Warn,\n     \"usage of `Box<Vec<T>>`, vector elements are already on the heap\"\n }\n \n-/// **What it does:** This lint checks for usage of any `LinkedList`, suggesting to use a `Vec` or\n-/// a `VecDeque` (formerly called `RingBuf`).\n+/// **What it does:** Checks for usage of any `LinkedList`, suggesting to use a\n+/// `Vec` or a `VecDeque` (formerly called `RingBuf`).\n ///\n /// **Why is this bad?** Gankro says:\n ///\n@@ -47,15 +49,16 @@ declare_lint! {\n /// > if you're doing a lot of insertion in the middle of the list, `RingBuf` can still be better\n /// > because of how expensive it is to seek to the middle of a `LinkedList`.\n ///\n-/// **Known problems:** False positives \u2013 the instances where using a `LinkedList` makes sense are\n-/// few and far between, but they can still happen.\n+/// **Known problems:** False positives \u2013 the instances where using a\n+/// `LinkedList` makes sense are few and far between, but they can still happen.\n ///\n /// **Example:**\n /// ```rust\n /// let x = LinkedList::new();\n /// ```\n declare_lint! {\n-    pub LINKEDLIST, Warn,\n+    pub LINKEDLIST,\n+    Warn,\n     \"usage of LinkedList, usually a vector is faster, or a more specialized data \\\n      structure like a VecDeque\"\n }\n@@ -104,15 +107,20 @@ impl LateLintPass for TypePass {\n #[allow(missing_copy_implementations)]\n pub struct LetPass;\n \n-/// **What it does:** This lint checks for binding a unit value.\n+/// **What it does:** Checks for binding a unit value.\n ///\n-/// **Why is this bad?** A unit value cannot usefully be used anywhere. So binding one is kind of pointless.\n+/// **Why is this bad?** A unit value cannot usefully be used anywhere. So\n+/// binding one is kind of pointless.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `let x = { 1; };`\n+/// **Example:**\n+/// ```rust\n+/// let x = { 1; };\n+/// ```\n declare_lint! {\n-    pub LET_UNIT_VALUE, Warn,\n+    pub LET_UNIT_VALUE,\n+    Warn,\n     \"creating a let binding to a value of unit type, which usually can't be used afterwards\"\n }\n \n@@ -147,16 +155,26 @@ impl LateLintPass for LetPass {\n     }\n }\n \n-/// **What it does:** This lint checks for comparisons to unit.\n+/// **What it does:** Checks for comparisons to unit.\n ///\n-/// **Why is this bad?** Unit is always equal to itself, and thus is just a clumsily written constant. Mostly this happens when someone accidentally adds semicolons at the end of the operands.\n+/// **Why is this bad?** Unit is always equal to itself, and thus is just a\n+/// clumsily written constant. Mostly this happens when someone accidentally\n+/// adds semicolons at the end of the operands.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `if { foo(); } == { bar(); } { baz(); }` is equal to `{ foo(); bar(); baz(); }`\n+/// **Example:**\n+/// ```rust\n+/// if { foo(); } == { bar(); } { baz(); }\n+/// ```\n+/// is equal to\n+/// ```rust\n+/// { foo(); bar(); baz(); }\n+/// ```\n declare_lint! {\n-    pub UNIT_CMP, Warn,\n-    \"comparing unit values (which is always `true` or `false`, respectively)\"\n+    pub UNIT_CMP,\n+    Warn,\n+    \"comparing unit values\"\n }\n \n #[allow(missing_copy_implementations)]\n@@ -194,54 +212,94 @@ impl LateLintPass for UnitCmp {\n \n pub struct CastPass;\n \n-/// **What it does:** This lint checks for casts from any numerical to a float type where the receiving type cannot store all values from the original type without rounding errors. This possible rounding is to be expected, so this lint is `Allow` by default.\n+/// **What it does:** Checks for casts from any numerical to a float type where\n+/// the receiving type cannot store all values from the original type without\n+/// rounding errors. This possible rounding is to be expected, so this lint is\n+/// `Allow` by default.\n ///\n-/// Basically, this warns on casting any integer with 32 or more bits to `f32` or any 64-bit integer to `f64`.\n+/// Basically, this warns on casting any integer with 32 or more bits to `f32`\n+/// or any 64-bit integer to `f64`.\n ///\n-/// **Why is this bad?** It's not bad at all. But in some applications it can be helpful to know where precision loss can take place. This lint can help find those places in the code.\n+/// **Why is this bad?** It's not bad at all. But in some applications it can be\n+/// helpful to know where precision loss can take place. This lint can help find\n+/// those places in the code.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `let x = u64::MAX; x as f64`\n+/// **Example:**\n+/// ```rust\n+/// let x = u64::MAX; x as f64\n+/// ```\n declare_lint! {\n-    pub CAST_PRECISION_LOSS, Allow,\n+    pub CAST_PRECISION_LOSS,\n+    Allow,\n     \"casts that cause loss of precision, e.g `x as f32` where `x: u64`\"\n }\n \n-/// **What it does:** This lint checks for casts from a signed to an unsigned numerical type. In this case, negative values wrap around to large positive values, which can be quite surprising in practice. However, as the cast works as defined, this lint is `Allow` by default.\n+/// **What it does:** Checks for casts from a signed to an unsigned numerical\n+/// type. In this case, negative values wrap around to large positive values,\n+/// which can be quite surprising in practice. However, as the cast works as\n+/// defined, this lint is `Allow` by default.\n ///\n-/// **Why is this bad?** Possibly surprising results. You can activate this lint as a one-time check to see where numerical wrapping can arise.\n+/// **Why is this bad?** Possibly surprising results. You can activate this lint\n+/// as a one-time check to see where numerical wrapping can arise.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `let y : i8 = -1; y as u64` will return 18446744073709551615\n+/// **Example:**\n+/// ```rust\n+/// let y: i8 = -1;\n+/// y as u64  // will return 18446744073709551615\n+/// ```\n declare_lint! {\n-    pub CAST_SIGN_LOSS, Allow,\n+    pub CAST_SIGN_LOSS,\n+    Allow,\n     \"casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\"\n }\n \n-/// **What it does:** This lint checks for on casts between numerical types that may truncate large values. This is expected behavior, so the cast is `Allow` by default.\n+/// **What it does:** Checks for on casts between numerical types that may\n+/// truncate large values. This is expected behavior, so the cast is `Allow` by\n+/// default.\n ///\n-/// **Why is this bad?** In some problem domains, it is good practice to avoid truncation. This lint can be activated to help assess where additional checks could be beneficial.\n+/// **Why is this bad?** In some problem domains, it is good practice to avoid\n+/// truncation. This lint can be activated to help assess where additional\n+/// checks could be beneficial.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `fn as_u8(x: u64) -> u8 { x as u8 }`\n+/// **Example:**\n+/// ```rust\n+/// fn as_u8(x: u64) -> u8 { x as u8 }\n+/// ```\n declare_lint! {\n-    pub CAST_POSSIBLE_TRUNCATION, Allow,\n-    \"casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\"\n+    pub CAST_POSSIBLE_TRUNCATION,\n+    Allow,\n+    \"casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, \\\n+     or `x as i32` where `x: f32`\"\n }\n \n-/// **What it does:** This lint checks for casts from an unsigned type to a signed type of the same size. Performing such a cast is a 'no-op' for the compiler, i.e. nothing is changed at the bit level, and the binary representation of the value is reinterpreted. This can cause wrapping if the value is too big for the target signed type. However, the cast works as defined, so this lint is `Allow` by default.\n+/// **What it does:** Checks for casts from an unsigned type to a signed type of\n+/// the same size. Performing such a cast is a 'no-op' for the compiler,\n+/// i.e. nothing is changed at the bit level, and the binary representation of\n+/// the value is reinterpreted. This can cause wrapping if the value is too big\n+/// for the target signed type. However, the cast works as defined, so this lint\n+/// is `Allow` by default.\n ///\n-/// **Why is this bad?** While such a cast is not bad in itself, the results can be surprising when this is not the intended behavior, as demonstrated by the example below.\n+/// **Why is this bad?** While such a cast is not bad in itself, the results can\n+/// be surprising when this is not the intended behavior, as demonstrated by the\n+/// example below.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `u32::MAX as i32` will yield a value of `-1`.\n+/// **Example:**\n+/// ```rust\n+/// u32::MAX as i32  // will yield a value of `-1`\n+/// ```\n declare_lint! {\n-    pub CAST_POSSIBLE_WRAP, Allow,\n-    \"casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\"\n+    pub CAST_POSSIBLE_WRAP,\n+    Allow,\n+    \"casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` \\\n+     and `x > i32::MAX`\"\n }\n \n /// Returns the size in bits of an integral type.\n@@ -433,16 +491,22 @@ impl LateLintPass for CastPass {\n     }\n }\n \n-/// **What it does:** This lint checks for types used in structs, parameters and `let` declarations above a certain complexity threshold.\n+/// **What it does:** Checks for types used in structs, parameters and `let`\n+/// declarations above a certain complexity threshold.\n ///\n-/// **Why is this bad?** Too complex types make the code less readable. Consider using a `type` definition to simplify them.\n+/// **Why is this bad?** Too complex types make the code less readable. Consider\n+/// using a `type` definition to simplify them.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `struct Foo { inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>> }`\n+/// **Example:**\n+/// ```rust\n+/// struct Foo { inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>> }\n+/// ```\n declare_lint! {\n-    pub TYPE_COMPLEXITY, Warn,\n-    \"usage of very complex types; recommends factoring out parts into `type` definitions\"\n+    pub TYPE_COMPLEXITY,\n+    Warn,\n+    \"usage of very complex types that might be better factored into `type` definitions\"\n }\n \n #[allow(missing_copy_implementations)]\n@@ -575,16 +639,25 @@ impl<'v> Visitor<'v> for TypeComplexityVisitor {\n     }\n }\n \n-/// **What it does:** This lint points out expressions where a character literal is casted to `u8` and suggests using a byte literal instead.\n+/// **What it does:** Checks for expressions where a character literal is cast\n+/// to `u8` and suggests using a byte literal instead.\n ///\n-/// **Why is this bad?** In general, casting values to smaller types is error-prone and should be avoided where possible. In the particular case of converting a character literal to u8, it is easy to avoid by just using a byte literal instead. As an added bonus, `b'a'` is even slightly shorter than `'a' as u8`.\n+/// **Why is this bad?** In general, casting values to smaller types is\n+/// error-prone and should be avoided where possible. In the particular case of\n+/// converting a character literal to u8, it is easy to avoid by just using a\n+/// byte literal instead. As an added bonus, `b'a'` is even slightly shorter\n+/// than `'a' as u8`.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `'x' as u8`\n+/// **Example:**\n+/// ```rust\n+/// 'x' as u8\n+/// ```\n declare_lint! {\n-    pub CHAR_LIT_AS_U8, Warn,\n-    \"Casting a character literal to u8\"\n+    pub CHAR_LIT_AS_U8,\n+    Warn,\n+    \"casting a character literal to u8\"\n }\n \n pub struct CharLitAsU8;\n@@ -617,17 +690,26 @@ impl LateLintPass for CharLitAsU8 {\n     }\n }\n \n-/// **What it does:** This lint checks for comparisons where one side of the relation is either the minimum or maximum value for its type and warns if it involves a case that is always true or always false. Only integer and boolean types are checked.\n+/// **What it does:** Checks for comparisons where one side of the relation is\n+/// either the minimum or maximum value for its type and warns if it involves a\n+/// case that is always true or always false. Only integer and boolean types are\n+/// checked.\n ///\n-/// **Why is this bad?** An expression like `min <= x` may misleadingly imply that is is possible for `x` to be less than the minimum. Expressions like `max < x` are probably mistakes.\n+/// **Why is this bad?** An expression like `min <= x` may misleadingly imply\n+/// that is is possible for `x` to be less than the minimum. Expressions like\n+/// `max < x` are probably mistakes.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example:** `vec.len() <= 0`, `100 > std::i32::MAX`\n+/// **Example:**\n+/// ```rust\n+/// vec.len() <= 0\n+/// 100 > std::i32::MAX\n+/// ```\n declare_lint! {\n-    pub ABSURD_EXTREME_COMPARISONS, Warn,\n-    \"a comparison involving a maximum or minimum value involves a case that is always \\\n-    true or always false\"\n+    pub ABSURD_EXTREME_COMPARISONS,\n+    Warn,\n+    \"a comparison with a maximum or minimum value that is always true or false\"\n }\n \n pub struct AbsurdExtremeComparisons;\n@@ -787,15 +869,23 @@ impl LateLintPass for AbsurdExtremeComparisons {\n     }\n }\n \n-/// **What it does:** This lint checks for comparisons where the relation is always either true or false, but where one side has been upcast so that the comparison is necessary. Only integer types are checked.\n+/// **What it does:** Checks for comparisons where the relation is always either\n+/// true or false, but where one side has been upcast so that the comparison is\n+/// necessary. Only integer types are checked.\n ///\n-/// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300` will mistakenly imply that it is possible for `x` to be outside the range of `u8`.\n+/// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300`\n+/// will mistakenly imply that it is possible for `x` to be outside the range of\n+/// `u8`.\n ///\n /// **Known problems:** https://github.com/Manishearth/rust-clippy/issues/886\n ///\n-/// **Example:** `let x : u8 = ...; (x as u32) > 300`\n+/// **Example:**\n+/// ```rust\n+/// let x : u8 = ...; (x as u32) > 300\n+/// ```\n declare_lint! {\n-    pub INVALID_UPCAST_COMPARISONS, Allow,\n+    pub INVALID_UPCAST_COMPARISONS,\n+    Allow,\n     \"a comparison involving an upcast which is always true or false\"\n }\n "}, {"sha": "afe519893a9f86ad77a1677af5f6b389a7c364b6", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -5,49 +5,55 @@ use syntax::codemap::Span;\n use unicode_normalization::UnicodeNormalization;\n use utils::{snippet, span_help_and_lint};\n \n-/// **What it does:** This lint checks for the Unicode zero-width space in the code.\n+/// **What it does:** Checks for the Unicode zero-width space in the code.\n ///\n-/// **Why is this bad?** Having an invisible character in the code makes for all sorts of April\n-/// fools, but otherwise is very much frowned upon.\n+/// **Why is this bad?** Having an invisible character in the code makes for all\n+/// sorts of April fools, but otherwise is very much frowned upon.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:** You don't see it, but there may be a zero-width space somewhere in this text.\n declare_lint! {\n-    pub ZERO_WIDTH_SPACE, Deny,\n+    pub ZERO_WIDTH_SPACE,\n+    Deny,\n     \"using a zero-width space in a string literal, which is confusing\"\n }\n \n-/// **What it does:** This lint checks for non-ASCII characters in string literals.\n+/// **What it does:** Checks for non-ASCII characters in string literals.\n ///\n-/// **Why is this bad?** Yeah, we know, the 90's called and wanted their charset back. Even so,\n-/// there still are editors and other programs out there that don't work well with Unicode. So if\n-/// the code is meant to be used internationally, on multiple operating systems, or has other\n-/// portability requirements, activating this lint could be useful.\n+/// **Why is this bad?** Yeah, we know, the 90's called and wanted their charset\n+/// back. Even so, there still are editors and other programs out there that\n+/// don't work well with Unicode. So if the code is meant to be used\n+/// internationally, on multiple operating systems, or has other portability\n+/// requirements, activating this lint could be useful.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n /// let x = \"H\u00e4?\"\n /// ```\n declare_lint! {\n-    pub NON_ASCII_LITERAL, Allow,\n-    \"using any literal non-ASCII chars in a string literal; suggests \\\n-     using the `\\\\u` escape instead\"\n+    pub NON_ASCII_LITERAL,\n+    Allow,\n+    \"using any literal non-ASCII chars in a string literal instead of \\\n+     using the `\\\\u` escape\"\n }\n \n-/// **What it does:** This lint checks for string literals that contain Unicode in a form that is\n-/// not equal to its [NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms).\n+/// **What it does:** Checks for string literals that contain Unicode in a form\n+/// that is not equal to its\n+/// [NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms).\n ///\n-/// **Why is this bad?** If such a string is compared to another, the results may be surprising.\n+/// **Why is this bad?** If such a string is compared to another, the results\n+/// may be surprising.\n ///\n-/// **Known problems** None\n+/// **Known problems** None.\n ///\n-/// **Example:** You may not see it, but \u201ca\u0300\u201d and \u201c\u00e0\u201d aren't the same string. The former when\n-/// escaped is actually `\"a\\u{300}\"` while the latter is `\"\\u{e0}\"`.\n+/// **Example:** You may not see it, but \u201ca\u0300\u201d and \u201c\u00e0\u201d aren't the same string. The\n+/// former when escaped is actually `\"a\\u{300}\"` while the latter is `\"\\u{e0}\"`.\n declare_lint! {\n-    pub UNICODE_NOT_NFC, Allow,\n+    pub UNICODE_NOT_NFC,\n+    Allow,\n     \"using a unicode literal not in NFC normal form (see \\\n      [unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\"\n }"}, {"sha": "8d5e01db570f99012f3b1ab1981e350884b10840", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -5,9 +5,11 @@ use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use utils::span_lint;\n \n-/// **What it does:** This lint checks for imports that remove \"unsafe\" from an item's name\n+/// **What it does:** Checks for imports that remove \"unsafe\" from an item's\n+/// name.\n ///\n-/// **Why is this bad?** Renaming makes it less clear which traits and structures are unsafe.\n+/// **Why is this bad?** Renaming makes it less clear which traits and\n+/// structures are unsafe.\n ///\n /// **Known problems:** None.\n ///\n@@ -21,7 +23,7 @@ use utils::span_lint;\n declare_lint! {\n     pub UNSAFE_REMOVED_FROM_NAME,\n     Warn,\n-    \"unsafe removed from name\"\n+    \"`unsafe` removed from API names on import\"\n }\n \n pub struct UnsafeNameRemoval;"}, {"sha": "899fc940cf13dfda746a2d28ae4a385cb34566d6", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -7,10 +7,10 @@ use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use utils::{in_macro, span_lint};\n \n-/// **What it does:** This lint checks for unused labels.\n+/// **What it does:** Checks for unused labels.\n ///\n-/// **Why is this bad?** Maybe the label should be used in which case there is an error in the\n-/// code or it should be removed.\n+/// **Why is this bad?** Maybe the label should be used in which case there is\n+/// an error in the code or it should be removed.\n ///\n /// **Known problems:** Hopefully none.\n ///\n@@ -24,7 +24,7 @@ use utils::{in_macro, span_lint};\n declare_lint! {\n     pub UNUSED_LABEL,\n     Warn,\n-    \"unused label\"\n+    \"unused labels\"\n }\n \n pub struct UnusedLabel;"}, {"sha": "443d433e1d368ecfdc197bf14ff3022ed5431424", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -3,16 +3,17 @@ use utils::span_lint;\n use syntax::parse::token::InternedString;\n use syntax::ast::*;\n \n-/// **What it does:** This lint checks for various things we like to keep tidy in clippy\n+/// **What it does:** Checks for various things we like to keep tidy in clippy.\n ///\n-/// **Why is this bad?** ???\n+/// **Why is this bad?** We like to pretend we're an example of tidy code.\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** wrong ordering of the util::paths constants\n+/// **Example:** Wrong ordering of the util::paths constants.\n declare_lint! {\n-    pub CLIPPY_LINTS_INTERNAL, Allow,\n-    \"Various things that will negatively affect your clippy experience\"\n+    pub CLIPPY_LINTS_INTERNAL,\n+    Allow,\n+    \"various things that will negatively affect your clippy experience\"\n }\n \n "}, {"sha": "38f3340c8b6e203872054e6cb1defdfdd9011289", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -6,7 +6,8 @@ use rustc_const_eval::eval_const_expr_partial;\n use syntax::codemap::Span;\n use utils::{higher, is_copy, snippet, span_lint_and_then};\n \n-/// **What it does:** This lint warns about using `&vec![..]` when using `&[..]` would be possible.\n+/// **What it does:** Checks for usage of `&vec![..]` when using `&[..]` would\n+/// be possible.\n ///\n /// **Why is this bad?** This is less efficient.\n ///"}, {"sha": "71221933d56c10eec51b6b708408cafb04904f99", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -3,18 +3,13 @@ use rustc::lint::*;\n use rustc::hir::*;\n use utils::span_help_and_lint;\n \n-/// `Pass` is a pass that checks for a binary expression that consists\n-/// `of 0.0/0.0`, which is always `NaN`. It is more clear to replace instances of\n-/// `0.0/0.0` with `std::f32::NaN` or `std::f64::NaN`, depending on the precision.\n-pub struct Pass;\n-\n-/// **What it does:** This lint checks for `0.0 / 0.0`.\n+/// **What it does:** Checks for `0.0 / 0.0`.\n ///\n-/// **Why is this bad?** It's less readable than `std::f32::NAN` or `std::f64::NAN`\n+/// **Why is this bad?** It's less readable than `std::f32::NAN` or `std::f64::NAN`.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** None.\n ///\n-/// **Example**\n+/// **Example:**\n /// ```rust\n /// 0.0f32 / 0.0\n /// ```\n@@ -24,6 +19,8 @@ declare_lint! {\n     \"usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN\"\n }\n \n+pub struct Pass;\n+\n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(ZERO_DIVIDED_BY_ZERO)"}, {"sha": "ae8e4a72c08d8827efeed86d9f27844fbfc719f5", "filename": "util/export.py", "status": "modified", "additions": 29, "deletions": 127, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/util%2Fexport.py", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/util%2Fexport.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fexport.py?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -1,79 +1,29 @@\n #!/usr/bin/env python\n # Build the gh-pages\n \n-import json\n-import os\n import re\n import sys\n+import json\n \n+from lintlib import parse_all, log\n \n-level_re = re.compile(r'''(Forbid|Deny|Warn|Allow)''')\n-conf_re = re.compile(r'''define_Conf! {\\n([^}]*)\\n}''', re.MULTILINE)\n-confvar_re = re.compile(r'''/// Lint: (\\w+). (.*).*\\n *\\(\"([^\"]*)\", (?:[^,]*), (.*) => (.*)\\),''')\n lint_subheadline = re.compile(r'''^\\*\\*([\\w\\s]+?)[:?.!]?\\*\\*(.*)''')\n \n-conf_template = \"\"\"\n+CONF_TEMPLATE = \"\"\"\\\n This lint has the following configuration variables:\n \n-* `%s: %s`: %s (defaults to `%s`).\n-\"\"\"\n-\n-\n-# TODO: actual logging\n-def warn(*args):\n-    print(args)\n-\n-\n-def debug(*args):\n-    print(args)\n-\n-\n-def info(*args):\n-    print(args)\n-\n-\n-def parse_path(p=\"clippy_lints/src\"):\n-    lints = []\n-    for f in os.listdir(p):\n-        if f.endswith(\".rs\"):\n-            parse_file(lints, os.path.join(p, f))\n-\n-    conf = parse_conf(p)\n-    info(conf)\n+* `%s: %s`: %s (defaults to `%s`).\"\"\"\n \n-    for lint_id in conf:\n-        lint = next(l for l in lints if l['id'] == lint_id)\n-        if lint:\n-            lint['docs']['Configuration'] = (conf_template % conf[lint_id]).strip()\n \n-    return lints\n-\n-\n-def parse_conf(p):\n-    c = {}\n-    with open(p + '/utils/conf.rs') as f:\n-        f = f.read()\n-\n-        m = re.search(conf_re, f)\n-        m = m.groups()[0]\n-\n-        m = re.findall(confvar_re, m)\n-\n-        for (lint, doc, name, default, ty) in m:\n-            c[lint.lower()] = (name, ty, doc, default)\n-\n-    return c\n-\n-\n-def parseLintDef(level, comment, name):\n-    lint = {}\n-    lint['id'] = name\n-    lint['level'] = level\n-    lint['docs'] = {}\n+def parse_lint_def(lint):\n+    lint_dict = {}\n+    lint_dict['id'] = lint.name\n+    lint_dict['level'] = lint.level\n+    lint_dict['docs'] = {}\n \n     last_section = None\n \n-    for line in comment:\n+    for line in lint.doc:\n         if len(line.strip()) == 0:\n             continue\n \n@@ -86,77 +36,29 @@ def parseLintDef(level, comment, name):\n             text = line\n \n         if not last_section:\n-            warn(\"Skipping comment line as it was not preceded by a heading\")\n-            debug(\"in lint `%s`, line `%s`\" % name, line)\n-\n-        lint['docs'][last_section] = (lint['docs'].get(last_section, \"\") + \"\\n\" + text).strip()\n-\n-    return lint\n-\n-\n-def parse_file(d, f):\n-    last_comment = []\n-    comment = True\n-\n-    with open(f) as rs:\n-        for line in rs:\n-            if comment:\n-                if line.startswith(\"///\"):\n-                    if line.startswith(\"/// \"):\n-                        last_comment.append(line[4:])\n-                    else:\n-                        last_comment.append(line[3:])\n-                elif line.startswith(\"declare_lint!\"):\n-                    comment = False\n-                    deprecated = False\n-                    restriction = False\n-                elif line.startswith(\"declare_restriction_lint!\"):\n-                    comment = False\n-                    deprecated = False\n-                    restriction = True\n-                elif line.startswith(\"declare_deprecated_lint!\"):\n-                    comment = False\n-                    deprecated = True\n-                else:\n-                    last_comment = []\n-            if not comment:\n-                l = line.strip()\n-                m = re.search(r\"pub\\s+([A-Z_][A-Z_0-9]*)\", l)\n-\n-                if m:\n-                    name = m.group(1).lower()\n-\n-                    # Intentionally either a never looping or infinite loop\n-                    while not deprecated and not restriction:\n-                        m = re.search(level_re, line)\n-                        if m:\n-                            level = m.group(0)\n-                            break\n-\n-                        line = next(rs)\n-\n-                    if deprecated:\n-                        level = \"Deprecated\"\n-                    elif restriction:\n-                        level = \"Allow\"\n-\n-                    info(\"found %s with level %s in %s\" % (name, level, f))\n-                    d.append(parseLintDef(level, last_comment, name=name))\n-                    last_comment = []\n-                    comment = True\n-                if \"}\" in l:\n-                    warn(\"Warning: Missing Lint-Name in\", f)\n-                    comment = True\n+            log.warn(\"Skipping comment line as it was not preceded by a heading\")\n+            log.debug(\"in lint `%s`, line `%s`\", lint.name, line)\n+\n+        lint_dict['docs'][last_section] = \\\n+            (lint_dict['docs'].get(last_section, \"\") + \"\\n\" + text).strip()\n+\n+    return lint_dict\n \n \n def main():\n-    lints = parse_path()\n-    info(\"got %s lints\" % len(lints))\n+    lintlist, configs = parse_all()\n+    lints = {}\n+    for lint in lintlist:\n+        lints[lint.name] = parse_lint_def(lint)\n+        if lint.name in configs:\n+            lints[lint.name]['docs']['Configuration'] = \\\n+                CONF_TEMPLATE % configs[lint.name]\n+\n+    outfile = sys.argv[1] if len(sys.argv) > 1 else \"util/gh-pages/lints.json\"\n+    with open(outfile, \"w\") as fp:\n+        json.dump(list(lints.values()), fp, indent=2)\n+        log.info(\"wrote JSON for great justice\")\n \n-    outdir = sys.argv[1] if len(sys.argv) > 1 else \"util/gh-pages/lints.json\"\n-    with open(outdir, \"w\") as file:\n-        json.dump(lints, file, indent=2)\n-        info(\"wrote JSON for great justice\")\n \n if __name__ == \"__main__\":\n     main()"}, {"sha": "45a7110b6a9779c9cd1f4da4782d5791701a0033", "filename": "util/lintlib.py", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/util%2Flintlib.py", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/util%2Flintlib.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Flintlib.py?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -0,0 +1,95 @@\n+# Common utils for the several housekeeping scripts.\n+\n+import os\n+import re\n+import collections\n+\n+import logging as log\n+log.basicConfig(level=log.INFO, format='%(levelname)s: %(message)s')\n+\n+Lint = collections.namedtuple('Lint', 'name level doc sourcefile')\n+Config = collections.namedtuple('Config', 'name ty doc default')\n+\n+lintname_re = re.compile(r'''pub\\s+([A-Z_][A-Z_0-9]*)''')\n+level_re = re.compile(r'''(Forbid|Deny|Warn|Allow)''')\n+conf_re = re.compile(r'''define_Conf! {\\n([^}]*)\\n}''', re.MULTILINE)\n+confvar_re = re.compile(\n+    r'''/// Lint: (\\w+). (.*).*\\n *\\(\"([^\"]*)\", (?:[^,]*), (.*) => (.*)\\),''')\n+\n+\n+def parse_lints(lints, filepath):\n+    last_comment = []\n+    comment = True\n+\n+    with open(filepath) as fp:\n+        for line in fp:\n+            if comment:\n+                if line.startswith(\"/// \"):\n+                    last_comment.append(line[4:])\n+                elif line.startswith(\"///\"):\n+                    last_comment.append(line[3:])\n+                elif line.startswith(\"declare_lint!\"):\n+                    comment = False\n+                    deprecated = False\n+                    restriction = False\n+                elif line.startswith(\"declare_restriction_lint!\"):\n+                    comment = False\n+                    deprecated = False\n+                    restriction = True\n+                elif line.startswith(\"declare_deprecated_lint!\"):\n+                    comment = False\n+                    deprecated = True\n+                else:\n+                    last_comment = []\n+            if not comment:\n+                m = lintname_re.search(line)\n+                if m:\n+                    name = m.group(1).lower()\n+\n+                    if deprecated:\n+                        level = \"Deprecated\"\n+                    elif restriction:\n+                        level = \"Allow\"\n+                    else:\n+                        while True:\n+                            m = level_re.search(line)\n+                            if m:\n+                                level = m.group(0)\n+                                break\n+                            line = next(fp)\n+\n+                    log.info(\"found %s with level %s in %s\",\n+                             name, level, filepath)\n+                    lints.append(Lint(name, level, last_comment, filepath))\n+                    last_comment = []\n+                    comment = True\n+                if \"}\" in line:\n+                    log.warn(\"Warning: missing Lint-Name in %s\", filepath)\n+                    comment = True\n+\n+\n+def parse_configs(path):\n+    configs = {}\n+    with open(os.path.join(path, 'utils/conf.rs')) as fp:\n+        contents = fp.read()\n+\n+    match = re.search(conf_re, contents)\n+    confvars = re.findall(confvar_re, match.group(1))\n+\n+    for (lint, doc, name, default, ty) in confvars:\n+        configs[lint.lower()] = Config(name, ty, doc, default)\n+\n+    return configs\n+\n+\n+def parse_all(path=\"clippy_lints/src\"):\n+    lints = []\n+    for filename in os.listdir(path):\n+        if filename.endswith(\".rs\"):\n+            parse_lints(lints, os.path.join(path, filename))\n+    log.info(\"got %s lints\", len(lints))\n+\n+    configs = parse_configs(path)\n+    log.info(\"got %d configs\", len(configs))\n+\n+    return lints, configs"}, {"sha": "965d7e272c5b10b25ef16e29c4e250619f98f395", "filename": "util/update_lints.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/util%2Fupdate_lints.py", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/util%2Fupdate_lints.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fupdate_lints.py?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -72,7 +72,7 @@ def gen_table(lints, link=None):\n     w_name = max(len(l[1]) for l in lints)\n     w_desc = max(len(l[3]) for l in lints)\n     # header and underline\n-    yield '%-*s | default | meaning\\n' % (w_name, 'name')\n+    yield '%-*s | default | triggers on\\n' % (w_name, 'name')\n     yield '%s-|-%s-|-%s\\n' % ('-' * w_name, '-' * 7, '-' * w_desc)\n     # one table row per lint\n     for (_, name, default, meaning) in sorted(lints, key=lambda l: l[1]):"}, {"sha": "a9bd32f2098972b0a3e4e902a8739c41db865470", "filename": "util/update_wiki.py", "status": "modified", "additions": 35, "deletions": 119, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/cdfa8e9f61dc165614b658421c1567800d94096d/util%2Fupdate_wiki.py", "raw_url": "https://github.com/rust-lang/rust/raw/cdfa8e9f61dc165614b658421c1567800d94096d/util%2Fupdate_wiki.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fupdate_wiki.py?ref=cdfa8e9f61dc165614b658421c1567800d94096d", "patch": "@@ -3,93 +3,11 @@\n # requires the checked out wiki in ../rust-clippy.wiki/\n # with -c option, print a warning and set exit status 1 if the file would be\n # changed.\n-import os\n+\n import re\n import sys\n \n-\n-level_re = re.compile(r'''(Forbid|Deny|Warn|Allow)''')\n-conf_re = re.compile(r'''define_Conf! {\\n([^}]*)\\n}''', re.MULTILINE)\n-confvar_re = re.compile(r'''/// Lint: (\\w+). (.*).*\\n *\\(\"([^\"]*)\", (?:[^,]*), (.*) => (.*)\\),''')\n-\n-\n-def parse_path(p=\"clippy_lints/src\"):\n-    d = {}\n-    for f in os.listdir(p):\n-        if f.endswith(\".rs\"):\n-            parse_file(d, os.path.join(p, f))\n-    return (d, parse_conf(p))\n-\n-\n-def parse_conf(p):\n-    c = {}\n-    with open(p + '/utils/conf.rs') as f:\n-        f = f.read()\n-\n-        m = re.search(conf_re, f)\n-        m = m.groups()[0]\n-\n-        m = re.findall(confvar_re, m)\n-\n-        for (lint, doc, name, default, ty) in m:\n-            c[lint.lower()] = (name, ty, doc, default)\n-\n-    return c\n-\n-\n-def parse_file(d, f):\n-    last_comment = []\n-    comment = True\n-\n-    with open(f) as rs:\n-        for line in rs:\n-            if comment:\n-                if line.startswith(\"///\"):\n-                    if line.startswith(\"/// \"):\n-                        last_comment.append(line[4:])\n-                    else:\n-                        last_comment.append(line[3:])\n-                elif line.startswith(\"declare_lint!\"):\n-                    comment = False\n-                    deprecated = False\n-                    restriction = False\n-                elif line.startswith(\"declare_restriction_lint!\"):\n-                    comment = False\n-                    deprecated = False\n-                    restriction = True\n-                elif line.startswith(\"declare_deprecated_lint!\"):\n-                    comment = False\n-                    deprecated = True\n-                else:\n-                    last_comment = []\n-            if not comment:\n-                l = line.strip()\n-                m = re.search(r\"pub\\s+([A-Z_][A-Z_0-9]*)\", l)\n-\n-                if m:\n-                    name = m.group(1).lower()\n-\n-                    # Intentionally either a never looping or infinite loop\n-                    while not deprecated and not restriction:\n-                        m = re.search(level_re, line)\n-                        if m:\n-                            level = m.group(0)\n-                            break\n-\n-                        line = next(rs)\n-\n-                    if deprecated:\n-                        level = \"Deprecated\"\n-                    elif restriction:\n-                        level = \"Allow\"\n-\n-                    print(\"found %s with level %s in %s\" % (name, level, f))\n-                    d[name] = (level, last_comment)\n-                    last_comment = []\n-                    comment = True\n-                if \"}\" in l:\n-                    print(\"Warning: Missing Lint-Name in\", f)\n-                    comment = True\n+from lintlib import log, parse_all\n \n PREFIX = \"\"\"Welcome to the rust-clippy wiki!\n \n@@ -108,14 +26,13 @@ def parse_file(d, f):\n \n \"\"\"\n \n-\n-template = \"\"\"\\n# `%s`\n+TEMPLATE = \"\"\"\\n# `%s`\n \n **Default level:** %s\n \n %s\"\"\"\n \n-conf_template = \"\"\"\n+CONF_TEMPLATE = \"\"\"\n **Configuration:** This lint has the following configuration variables:\n \n * `%s: %s`: %s (defaults to `%s`).\n@@ -129,51 +46,50 @@ def level_message(level):\n         return \"\\n**Those lints are %s by default**:\\n\\n\" % level\n \n \n-def write_wiki_page(d, c, f):\n-    keys = list(d.keys())\n-    keys.sort()\n-    with open(f, \"w\") as w:\n-        w.write(PREFIX)\n+def write_wiki_page(lints, configs, filepath):\n+    lints.sort()\n+    with open(filepath, \"w\") as fp:\n+        fp.write(PREFIX)\n \n         for level in ('Deny', 'Warn', 'Allow', 'Deprecated'):\n-            w.write(level_message(level))\n-            for k in keys:\n-                if d[k][0] == level:\n-                    w.write(\"[`%s`](#%s)\\n\" % (k, k))\n+            fp.write(level_message(level))\n+            for lint in lints:\n+                if lint.level == level:\n+                    fp.write(\"[`%s`](#%s)\\n\" % (lint.name, lint.name))\n \n-        w.write(WARNING)\n-        for k in keys:\n-            w.write(template % (k, d[k][0], \"\".join(d[k][1])))\n+        fp.write(WARNING)\n+        for lint in lints:\n+            fp.write(TEMPLATE % (lint.name, lint.level, \"\".join(lint.doc)))\n \n-            if k in c:\n-                w.write(conf_template % c[k])\n+            if lint.name in configs:\n+                fp.write(CONF_TEMPLATE % configs[lint.name])\n \n \n-def check_wiki_page(d, c, f):\n-    errors = []\n-    with open(f) as w:\n-        for line in w:\n-            m = re.match(\"# `([a-z_]+)`\", line)\n+def check_wiki_page(lints, configs, filepath):\n+    lintdict = dict((lint.name, lint) for lint in lints)\n+    errors = False\n+    with open(filepath) as fp:\n+        for line in fp:\n+            m = re.match(\"# `([a-z_0-9]+)`\", line)\n             if m:\n-                v = d.pop(m.group(1), \"()\")\n-                if v == \"()\":\n-                    errors.append(\"Missing wiki entry: \" + m.group(1))\n-    keys = list(d.keys())\n-    keys.sort()\n-    for k in keys:\n-        errors.append(\"Spurious wiki entry: \" + k)\n+                v = lintdict.pop(m.group(1), None)\n+                if v is None:\n+                    log.error(\"Spurious wiki entry: %s\", m.group(1))\n+                    errors = True\n+    for n in sorted(lintdict):\n+        log.error(\"Missing wiki entry: %s\", n)\n+        errors = True\n     if errors:\n-        print(\"\\n\".join(errors))\n-        sys.exit(1)\n+        return 1\n \n \n def main():\n-    (d, c) = parse_path()\n-    print('Found %s lints' % len(d))\n+    lints, configs = parse_all()\n     if \"-c\" in sys.argv:\n-        check_wiki_page(d, c, \"../rust-clippy.wiki/Home.md\")\n+        check_wiki_page(lints, configs, \"../rust-clippy.wiki/Home.md\")\n     else:\n-        write_wiki_page(d, c, \"../rust-clippy.wiki/Home.md\")\n+        write_wiki_page(lints, configs, \"../rust-clippy.wiki/Home.md\")\n+\n \n if __name__ == \"__main__\":\n     main()"}]}