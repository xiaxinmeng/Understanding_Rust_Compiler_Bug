{"sha": "a5673de454a330df075834732861080ad6f9c124", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NjczZGU0NTRhMzMwZGYwNzU4MzQ3MzI4NjEwODBhZDZmOWMxMjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-07T20:39:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-16T12:41:29Z"}, "message": "refactor inhabitedness to have clearer public entry points", "tree": {"sha": "f086d9597c05dfd955fa55cc8fa370b869b15f01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f086d9597c05dfd955fa55cc8fa370b869b15f01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5673de454a330df075834732861080ad6f9c124", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5673de454a330df075834732861080ad6f9c124", "html_url": "https://github.com/rust-lang/rust/commit/a5673de454a330df075834732861080ad6f9c124", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5673de454a330df075834732861080ad6f9c124/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abe7c87eefe4a15b7e83feb6b8962ae15452c16c", "url": "https://api.github.com/repos/rust-lang/rust/commits/abe7c87eefe4a15b7e83feb6b8962ae15452c16c", "html_url": "https://github.com/rust-lang/rust/commit/abe7c87eefe4a15b7e83feb6b8962ae15452c16c"}], "stats": {"total": 186, "additions": 100, "deletions": 86}, "files": [{"sha": "9dc1b19c0f16de6717491076cc1199f14b813b5a", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 90, "deletions": 22, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a5673de454a330df075834732861080ad6f9c124/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5673de454a330df075834732861080ad6f9c124/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=a5673de454a330df075834732861080ad6f9c124", "patch": "@@ -10,7 +10,7 @@\n \n use util::nodemap::{FxHashMap, FxHashSet};\n use ty::context::TyCtxt;\n-use ty::{AdtDef, VariantDef, FieldDef, TyS};\n+use ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n use ty::{DefId, Substs};\n use ty::{AdtKind, Visibility};\n use ty::TypeVariants::*;\n@@ -62,13 +62,81 @@ mod def_id_forest;\n // This code should only compile in modules where the uninhabitedness of Foo is\n // visible.\n \n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    /// Checks whether a type is visibly uninhabited from a particular module.\n+    /// # Example\n+    /// ```rust\n+    /// enum Void {}\n+    /// mod a {\n+    ///     pub mod b {\n+    ///         pub struct SecretlyUninhabited {\n+    ///             _priv: !,\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// mod c {\n+    ///     pub struct AlsoSecretlyUninhabited {\n+    ///         _priv: Void,\n+    ///     }\n+    ///     mod d {\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Foo {\n+    ///     x: a::b::SecretlyUninhabited,\n+    ///     y: c::AlsoSecretlyUninhabited,\n+    /// }\n+    /// ```\n+    /// In this code, the type `Foo` will only be visibly uninhabited inside the\n+    /// modules b, c and d. This effects pattern-matching on `Foo` or types that\n+    /// contain `Foo`.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// let foo_result: Result<T, Foo> = ... ;\n+    /// let Ok(t) = foo_result;\n+    /// ```\n+    /// This code should only compile in modules where the uninhabitedness of Foo is\n+    /// visible.\n+    pub fn is_ty_uninhabited_from(self, module: DefId, ty: Ty<'tcx>) -> bool {\n+        let forest = ty.uninhabited_from(&mut FxHashMap(), self);\n+\n+        // To check whether this type is uninhabited at all (not just from the\n+        // given node) you could check whether the forest is empty.\n+        // ```\n+        // forest.is_empty()\n+        // ```\n+        forest.contains(self, module)\n+    }\n+\n+    pub fn is_enum_variant_uninhabited_from(self,\n+                                            module: DefId,\n+                                            variant: &'tcx VariantDef,\n+                                            substs: &'tcx Substs<'tcx>)\n+                                            -> bool\n+    {\n+        let adt_kind = AdtKind::Enum;\n+        variant.uninhabited_from(&mut FxHashMap(), self, substs, adt_kind).contains(self, module)\n+    }\n+\n+    pub fn is_variant_uninhabited_from_all_modules(self,\n+                                                   variant: &'tcx VariantDef,\n+                                                   substs: &'tcx Substs<'tcx>,\n+                                                   adt_kind: AdtKind)\n+                                                   -> bool\n+    {\n+        !variant.uninhabited_from(&mut FxHashMap(), self, substs, adt_kind).is_empty()\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n-    pub fn uninhabited_from(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                substs: &'tcx Substs<'tcx>) -> DefIdForest\n+    fn uninhabited_from(\n+        &self,\n+        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        substs: &'tcx Substs<'tcx>) -> DefIdForest\n     {\n         DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n             v.uninhabited_from(visited, tcx, substs, self.adt_kind())\n@@ -78,12 +146,12 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n     /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n-    pub fn uninhabited_from(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                substs: &'tcx Substs<'tcx>,\n-                adt_kind: AdtKind) -> DefIdForest\n+    fn uninhabited_from(\n+        &self,\n+        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        substs: &'tcx Substs<'tcx>,\n+        adt_kind: AdtKind) -> DefIdForest\n     {\n         match adt_kind {\n             AdtKind::Union => {\n@@ -107,12 +175,12 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n \n impl<'a, 'gcx, 'tcx> FieldDef {\n     /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n-    pub fn uninhabited_from(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                substs: &'tcx Substs<'tcx>,\n-                is_enum: bool) -> DefIdForest\n+    fn uninhabited_from(\n+        &self,\n+        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        substs: &'tcx Substs<'tcx>,\n+        is_enum: bool) -> DefIdForest\n     {\n         let mut data_uninhabitedness = move || {\n             self.ty(tcx, substs).uninhabited_from(visited, tcx)\n@@ -138,10 +206,10 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n \n impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n-    pub fn uninhabited_from(\n-                &self,\n-                visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n+    fn uninhabited_from(\n+        &self,\n+        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match tcx.lift_to_global(&self) {\n             Some(global_ty) => {"}, {"sha": "064627c21bfe64f98cd2e0323e990b2bf5655994", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a5673de454a330df075834732861080ad6f9c124/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5673de454a330df075834732861080ad6f9c124/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=a5673de454a330df075834732861080ad6f9c124", "patch": "@@ -24,7 +24,6 @@ use std::cmp::Ordering;\n use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::symbol::keywords;\n-use util::nodemap::FxHashMap;\n \n use serialize;\n \n@@ -1070,54 +1069,6 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Checks whether a type is visibly uninhabited from a particular module.\n-    /// # Example\n-    /// ```rust\n-    /// enum Void {}\n-    /// mod a {\n-    ///     pub mod b {\n-    ///         pub struct SecretlyUninhabited {\n-    ///             _priv: !,\n-    ///         }\n-    ///     }\n-    /// }\n-    ///\n-    /// mod c {\n-    ///     pub struct AlsoSecretlyUninhabited {\n-    ///         _priv: Void,\n-    ///     }\n-    ///     mod d {\n-    ///     }\n-    /// }\n-    ///\n-    /// struct Foo {\n-    ///     x: a::b::SecretlyUninhabited,\n-    ///     y: c::AlsoSecretlyUninhabited,\n-    /// }\n-    /// ```\n-    /// In this code, the type `Foo` will only be visibly uninhabited inside the\n-    /// modules b, c and d. This effects pattern-matching on `Foo` or types that\n-    /// contain `Foo`.\n-    ///\n-    /// # Example\n-    /// ```rust\n-    /// let foo_result: Result<T, Foo> = ... ;\n-    /// let Ok(t) = foo_result;\n-    /// ```\n-    /// This code should only compile in modules where the uninhabitedness of Foo is\n-    /// visible.\n-    pub fn is_uninhabited_from(&self, module: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        let mut visited = FxHashMap::default();\n-        let forest = self.uninhabited_from(&mut visited, tcx);\n-\n-        // To check whether this type is uninhabited at all (not just from the\n-        // given node) you could check whether the forest is empty.\n-        // ```\n-        // forest.is_empty()\n-        // ```\n-        forest.contains(tcx, module)\n-    }\n-\n     pub fn is_primitive(&self) -> bool {\n         match self.sty {\n             TyBool | TyChar | TyInt(_) | TyUint(_) | TyFloat(_) => true,"}, {"sha": "08f3b0a4c5fd1cfd0e1104fa852a58d7f1c14723", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5673de454a330df075834732861080ad6f9c124/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5673de454a330df075834732861080ad6f9c124/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=a5673de454a330df075834732861080ad6f9c124", "patch": "@@ -25,7 +25,7 @@ use pattern::{PatternFoldable, PatternFolder};\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::RangeEnd;\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc::mir::Field;\n use rustc::util::common::ErrorReported;\n@@ -202,21 +202,19 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n     fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n         if self.tcx.sess.features.borrow().never_type {\n-            ty.is_uninhabited_from(self.module, self.tcx)\n+            self.tcx.is_ty_uninhabited_from(self.module, ty)\n         } else {\n             false\n         }\n     }\n \n     fn is_variant_uninhabited(&self,\n                               variant: &'tcx ty::VariantDef,\n-                              substs: &'tcx ty::subst::Substs<'tcx>) -> bool\n+                              substs: &'tcx ty::subst::Substs<'tcx>)\n+                              -> bool\n     {\n         if self.tcx.sess.features.borrow().never_type {\n-            let forest = variant.uninhabited_from(\n-                &mut FxHashMap::default(), self.tcx, substs, AdtKind::Enum\n-            );\n-            forest.contains(self.tcx, self.module)\n+            self.tcx.is_enum_variant_uninhabited_from(self.module, variant, substs)\n         } else {\n             false\n         }"}, {"sha": "a9eda3c2f6979a91576219c62981c5cd813e81b2", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5673de454a330df075834732861080ad6f9c124/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5673de454a330df075834732861080ad6f9c124/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=a5673de454a330df075834732861080ad6f9c124", "patch": "@@ -192,7 +192,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             let module = self.tcx.hir.get_module_parent(scrut.id);\n             if inlined_arms.is_empty() {\n                 let scrutinee_is_uninhabited = if self.tcx.sess.features.borrow().never_type {\n-                    pat_ty.is_uninhabited_from(module, self.tcx)\n+                    self.tcx.is_ty_uninhabited_from(module, pat_ty)\n                 } else {\n                     self.conservative_is_uninhabited(pat_ty)\n                 };"}, {"sha": "f7d15d9118887137023b2e95fc4286d4e2475434", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a5673de454a330df075834732861080ad6f9c124/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5673de454a330df075834732861080ad6f9c124/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=a5673de454a330df075834732861080ad6f9c124", "patch": "@@ -26,7 +26,6 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::matches::{Binding, MatchPair, Candidate};\n use hair::*;\n use rustc::mir::*;\n-use rustc_data_structures::fx::FxHashMap;\n \n use std::mem;\n \n@@ -102,12 +101,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if self.hir.tcx().sess.features.borrow().never_type {\n                     let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n                         i == variant_index || {\n-                            let mut visited = FxHashMap::default();\n-                            let node_set = v.uninhabited_from(&mut visited,\n-                                                              self.hir.tcx(),\n-                                                              substs,\n-                                                              adt_def.adt_kind());\n-                            !node_set.is_empty()\n+                            let adt_kind = adt_def.adt_kind();\n+                            self.hir.tcx().is_variant_uninhabited_from_all_modules(v,\n+                                                                                   substs,\n+                                                                                   adt_kind)\n                         }\n                     });\n                     if irrefutable {"}]}