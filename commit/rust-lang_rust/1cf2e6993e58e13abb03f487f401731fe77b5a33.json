{"sha": "1cf2e6993e58e13abb03f487f401731fe77b5a33", "node_id": "C_kwDOAAsO6NoAKDFjZjJlNjk5M2U1OGUxM2FiYjAzZjQ4N2Y0MDE3MzFmZTc3YjVhMzM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-22T11:16:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-22T11:16:28Z"}, "message": "Rollup merge of #94169 - Amanieu:asm_stuff, r=nagisa\n\nFix several asm! related issues\n\nThis is a combination of several fixes, each split into a separate commit. Splitting these into PRs is not practical since they conflict with each other.\n\nFixes #92378\nFixes #85247\n\nr? ``@nagisa``", "tree": {"sha": "80ed8f1b12d21e15830668c38c6d1ff47a75ea4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80ed8f1b12d21e15830668c38c6d1ff47a75ea4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cf2e6993e58e13abb03f487f401731fe77b5a33", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiFMYMCRBK7hj4Ov3rIwAAzVAIAArxNK70TbH7iWaHSkVEUYNi\nuyJsZ1aKHwoFl51tmfuyvTonxI2ezZwEEqlE3o1/0j4unXeuJjycDnIWbirp3NPK\nVp2sBAs8XS5ArVkaGA0ba3sTOw+5uTPl9wF5OHLitXh7cBz3LK3UlDwGQpsLmlyu\nsTZu1PG2F16aVCZw1oCvgPIeKDYW2XUeSMMhFRCraSenu2oBNVYlhTgY/2exaw4E\n1iy9hmMijhG+t4Rmuc3uqMPjRgodzBiDzgyN9CymDzKm1rRdLgfWXdEy5Y+IrWlT\nqlIm8ct4RM6ls+N0nWNNhngsNo8r2kKpdcXvD5b+lWzUSGWG5ksz/V6ly2zrMo0=\n=2kVt\n-----END PGP SIGNATURE-----\n", "payload": "tree 80ed8f1b12d21e15830668c38c6d1ff47a75ea4e\nparent 58a721af9f818bdf57f86448557b45c5ae19a3ef\nparent a60b79137ca7829797111a63d8f480316af71aa8\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645528588 +0100\ncommitter GitHub <noreply@github.com> 1645528588 +0100\n\nRollup merge of #94169 - Amanieu:asm_stuff, r=nagisa\n\nFix several asm! related issues\n\nThis is a combination of several fixes, each split into a separate commit. Splitting these into PRs is not practical since they conflict with each other.\n\nFixes #92378\nFixes #85247\n\nr? ``@nagisa``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf2e6993e58e13abb03f487f401731fe77b5a33", "html_url": "https://github.com/rust-lang/rust/commit/1cf2e6993e58e13abb03f487f401731fe77b5a33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cf2e6993e58e13abb03f487f401731fe77b5a33/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58a721af9f818bdf57f86448557b45c5ae19a3ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/58a721af9f818bdf57f86448557b45c5ae19a3ef", "html_url": "https://github.com/rust-lang/rust/commit/58a721af9f818bdf57f86448557b45c5ae19a3ef"}, {"sha": "a60b79137ca7829797111a63d8f480316af71aa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a60b79137ca7829797111a63d8f480316af71aa8", "html_url": "https://github.com/rust-lang/rust/commit/a60b79137ca7829797111a63d8f480316af71aa8"}], "stats": {"total": 529, "additions": 292, "deletions": 237}, "files": [{"sha": "171cc60dfd77c28b79dca802aa4c81d31b7543ea", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -64,12 +64,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut clobber_abis = FxHashMap::default();\n         if let Some(asm_arch) = asm_arch {\n             for (abi_name, abi_span) in &asm.clobber_abis {\n-                match asm::InlineAsmClobberAbi::parse(\n-                    asm_arch,\n-                    &self.sess.target_features,\n-                    &self.sess.target,\n-                    *abi_name,\n-                ) {\n+                match asm::InlineAsmClobberAbi::parse(asm_arch, &self.sess.target, *abi_name) {\n                     Ok(abi) => {\n                         // If the abi was already in the list, emit an error\n                         match clobber_abis.get(&abi) {\n@@ -129,17 +124,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .operands\n             .iter()\n             .map(|(op, op_sp)| {\n-                let lower_reg = |reg, is_clobber| match reg {\n+                let lower_reg = |reg| match reg {\n                     InlineAsmRegOrRegClass::Reg(s) => {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmReg::parse(\n-                                asm_arch,\n-                                &sess.target_features,\n-                                &sess.target,\n-                                is_clobber,\n-                                s,\n-                            )\n-                            .unwrap_or_else(|e| {\n+                            asm::InlineAsmReg::parse(asm_arch, s).unwrap_or_else(|e| {\n                                 let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n                                 sess.struct_span_err(*op_sp, &msg).emit();\n                                 asm::InlineAsmReg::Err\n@@ -163,24 +151,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 let op = match *op {\n                     InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n-                        reg: lower_reg(reg, false),\n+                        reg: lower_reg(reg),\n                         expr: self.lower_expr_mut(expr),\n                     },\n                     InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n-                        reg: lower_reg(reg, expr.is_none()),\n+                        reg: lower_reg(reg),\n                         late,\n                         expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n                     },\n                     InlineAsmOperand::InOut { reg, late, ref expr } => {\n                         hir::InlineAsmOperand::InOut {\n-                            reg: lower_reg(reg, false),\n+                            reg: lower_reg(reg),\n                             late,\n                             expr: self.lower_expr_mut(expr),\n                         }\n                     }\n                     InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n                         hir::InlineAsmOperand::SplitInOut {\n-                            reg: lower_reg(reg, false),\n+                            reg: lower_reg(reg),\n                             late,\n                             in_expr: self.lower_expr_mut(in_expr),\n                             out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),"}, {"sha": "deac5dfd3ec1adc43b8e2380446dba99a493eb6e", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -106,6 +106,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     let mut asm_gen = InlineAssemblyGenerator {\n         tcx: fx.tcx,\n         arch: fx.tcx.sess.asm_arch.unwrap(),\n+        enclosing_def_id: fx.instance.def_id(),\n         template,\n         operands,\n         options,\n@@ -169,6 +170,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n struct InlineAssemblyGenerator<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     arch: InlineAsmArch,\n+    enclosing_def_id: DefId,\n     template: &'a [InlineAsmTemplatePiece],\n     operands: &'a [InlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n@@ -182,7 +184,12 @@ struct InlineAssemblyGenerator<'a, 'tcx> {\n impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n     fn allocate_registers(&mut self) {\n         let sess = self.tcx.sess;\n-        let map = allocatable_registers(self.arch, &sess.target_features, &sess.target);\n+        let map = allocatable_registers(\n+            self.arch,\n+            sess.relocation_model(),\n+            self.tcx.asm_target_features(self.enclosing_def_id),\n+            &sess.target,\n+        );\n         let mut allocated = FxHashMap::<_, (bool, bool)>::default();\n         let mut regs = vec![None; self.operands.len()];\n \n@@ -313,14 +320,9 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         let mut new_slot = |x| new_slot_fn(&mut slot_size, x);\n \n         // Allocate stack slots for saving clobbered registers\n-        let abi_clobber = InlineAsmClobberAbi::parse(\n-            self.arch,\n-            &self.tcx.sess.target_features,\n-            &self.tcx.sess.target,\n-            sym::C,\n-        )\n-        .unwrap()\n-        .clobbered_regs();\n+        let abi_clobber = InlineAsmClobberAbi::parse(self.arch, &self.tcx.sess.target, sym::C)\n+            .unwrap()\n+            .clobbered_regs();\n         for (i, reg) in self.registers.iter().enumerate().filter_map(|(i, r)| r.map(|r| (i, r))) {\n             let mut need_save = true;\n             // If the register overlaps with a register clobbered by function call, then"}, {"sha": "77166c89735e43b9f77c7facf88b24144398452f", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -36,7 +36,6 @@ const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     // #[target_feature].\n     (\"thumb-mode\", Some(sym::arm_target_feature)),\n     (\"thumb2\", Some(sym::arm_target_feature)),\n-    (\"reserve-r9\", Some(sym::arm_target_feature)),\n ];\n \n const AARCH64_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &["}, {"sha": "069dac969c66e0cdce9bafabbec4e02c9fe86203", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -1046,6 +1046,10 @@ rustc_queries! {\n         cache_on_disk_if { true }\n     }\n \n+    query asm_target_features(def_id: DefId) -> &'tcx FxHashSet<Symbol> {\n+        desc { |tcx| \"computing target features for inline asm of `{}`\", tcx.def_path_str(def_id) }\n+    }\n+\n     query fn_arg_names(def_id: DefId) -> &'tcx [rustc_span::symbol::Ident] {\n         desc { |tcx| \"looking up function parameter names for `{}`\", tcx.def_path_str(def_id) }\n         separate_provide_extern"}, {"sha": "d7dde157864a499049360dae548cf53b2df1628a", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -1,4 +1,5 @@\n use rustc_ast::InlineAsmTemplatePiece;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -138,7 +139,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n         template: &[InlineAsmTemplatePiece],\n         is_input: bool,\n         tied_input: Option<(&hir::Expr<'tcx>, Option<InlineAsmType>)>,\n-        target_features: &[Symbol],\n+        target_features: &FxHashSet<Symbol>,\n     ) -> Option<InlineAsmType> {\n         // Check the type against the allowed types for inline asm.\n         let ty = self.typeck_results.expr_ty_adjusted(expr);\n@@ -285,9 +286,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n         // (!). In that case we still need the earlier check to verify that the\n         // register class is usable at all.\n         if let Some(feature) = feature {\n-            if !self.tcx.sess.target_features.contains(&feature)\n-                && !target_features.contains(&feature)\n-            {\n+            if !target_features.contains(&feature) {\n                 let msg = &format!(\"`{}` target feature is not enabled\", feature);\n                 let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n                 err.note(&format!(\n@@ -347,7 +346,8 @@ impl<'tcx> ExprVisitor<'tcx> {\n         let hir = self.tcx.hir();\n         let enclosing_id = hir.enclosing_body_owner(hir_id);\n         let enclosing_def_id = hir.local_def_id(enclosing_id).to_def_id();\n-        let attrs = self.tcx.codegen_fn_attrs(enclosing_def_id);\n+        let target_features = self.tcx.asm_target_features(enclosing_def_id);\n+        let asm_arch = self.tcx.sess.asm_arch.unwrap();\n         for (idx, (op, op_sp)) in asm.operands.iter().enumerate() {\n             // Validate register classes against currently enabled target\n             // features. We check that at least one type is available for\n@@ -360,16 +360,29 @@ impl<'tcx> ExprVisitor<'tcx> {\n             // Note that this is only possible for explicit register\n             // operands, which cannot be used in the asm string.\n             if let Some(reg) = op.reg() {\n+                // Some explicit registers cannot be used depending on the\n+                // target. Reject those here.\n+                if let InlineAsmRegOrRegClass::Reg(reg) = reg {\n+                    if let Err(msg) = reg.validate(\n+                        asm_arch,\n+                        self.tcx.sess.relocation_model(),\n+                        &target_features,\n+                        &self.tcx.sess.target,\n+                        op.is_clobber(),\n+                    ) {\n+                        let msg = format!(\"cannot use register `{}`: {}\", reg.name(), msg);\n+                        self.tcx.sess.struct_span_err(*op_sp, &msg).emit();\n+                        continue;\n+                    }\n+                }\n+\n                 if !op.is_clobber() {\n                     let mut missing_required_features = vec![];\n                     let reg_class = reg.reg_class();\n-                    for &(_, feature) in reg_class.supported_types(self.tcx.sess.asm_arch.unwrap())\n-                    {\n+                    for &(_, feature) in reg_class.supported_types(asm_arch) {\n                         match feature {\n                             Some(feature) => {\n-                                if self.tcx.sess.target_features.contains(&feature)\n-                                    || attrs.target_features.contains(&feature)\n-                                {\n+                                if target_features.contains(&feature) {\n                                     missing_required_features.clear();\n                                     break;\n                                 } else {\n@@ -425,7 +438,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                         asm.template,\n                         true,\n                         None,\n-                        &attrs.target_features,\n+                        &target_features,\n                     );\n                 }\n                 hir::InlineAsmOperand::Out { reg, late: _, ref expr } => {\n@@ -437,7 +450,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                             asm.template,\n                             false,\n                             None,\n-                            &attrs.target_features,\n+                            &target_features,\n                         );\n                     }\n                 }\n@@ -449,7 +462,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                         asm.template,\n                         false,\n                         None,\n-                        &attrs.target_features,\n+                        &target_features,\n                     );\n                 }\n                 hir::InlineAsmOperand::SplitInOut { reg, late: _, ref in_expr, ref out_expr } => {\n@@ -460,7 +473,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                         asm.template,\n                         true,\n                         None,\n-                        &attrs.target_features,\n+                        &target_features,\n                     );\n                     if let Some(out_expr) = out_expr {\n                         self.check_asm_operand_type(\n@@ -470,7 +483,7 @@ impl<'tcx> ExprVisitor<'tcx> {\n                             asm.template,\n                             false,\n                             Some((in_expr, in_ty)),\n-                            &attrs.target_features,\n+                            &target_features,\n                         );\n                     }\n                 }"}, {"sha": "6767593bbc51a8ce455cd8daec8e5d5cbb57db0e", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -1122,7 +1122,6 @@ symbols! {\n         repr_packed,\n         repr_simd,\n         repr_transparent,\n-        reserved_r9: \"reserved-r9\",\n         residual,\n         result,\n         rhs,"}, {"sha": "7fb4dbdf2b181086d3e29a4d2e0efd19a920c95f", "filename": "compiler/rustc_target/src/asm/aarch64.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -1,5 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n-use crate::spec::Target;\n+use crate::spec::{RelocModel, Target};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n@@ -73,17 +73,18 @@ impl AArch64InlineAsmRegClass {\n     }\n }\n \n-pub fn reserved_x18(\n+pub fn target_reserves_x18(target: &Target) -> bool {\n+    target.os == \"android\" || target.is_like_fuchsia || target.is_like_osx || target.is_like_windows\n+}\n+\n+fn reserved_x18(\n     _arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     target: &Target,\n     _is_clobber: bool,\n ) -> Result<(), &'static str> {\n-    if target.os == \"android\"\n-        || target.is_like_fuchsia\n-        || target.is_like_osx\n-        || target.is_like_windows\n-    {\n+    if target_reserves_x18(target) {\n         Err(\"x18 is a reserved register on this target\")\n     } else {\n         Ok(())"}, {"sha": "88f2d3f80d2c38d352d19fdcb7b2a18c99d1b122", "filename": "compiler/rustc_target/src/asm/arm.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -1,5 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n-use crate::spec::Target;\n+use crate::spec::{RelocModel, Target};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::{sym, Symbol};\n@@ -67,11 +67,12 @@ fn frame_pointer_is_r7(target_features: &FxHashSet<Symbol>, target: &Target) ->\n \n fn frame_pointer_r11(\n     arch: InlineAsmArch,\n+    reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     target: &Target,\n     is_clobber: bool,\n ) -> Result<(), &'static str> {\n-    not_thumb1(arch, target_features, target, is_clobber)?;\n+    not_thumb1(arch, reloc_model, target_features, target, is_clobber)?;\n \n     if !frame_pointer_is_r7(target_features, target) {\n         Err(\"the frame pointer (r11) cannot be used as an operand for inline asm\")\n@@ -82,6 +83,7 @@ fn frame_pointer_r11(\n \n fn frame_pointer_r7(\n     _arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     target: &Target,\n     _is_clobber: bool,\n@@ -95,6 +97,7 @@ fn frame_pointer_r7(\n \n fn not_thumb1(\n     _arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     is_clobber: bool,\n@@ -111,18 +114,18 @@ fn not_thumb1(\n \n fn reserved_r9(\n     arch: InlineAsmArch,\n+    reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     target: &Target,\n     is_clobber: bool,\n ) -> Result<(), &'static str> {\n-    not_thumb1(arch, target_features, target, is_clobber)?;\n+    not_thumb1(arch, reloc_model, target_features, target, is_clobber)?;\n \n-    // We detect this using the reserved-r9 feature instead of using the target\n-    // because the relocation model can be changed with compiler options.\n-    if target_features.contains(&sym::reserved_r9) {\n-        Err(\"the RWPI static base register (r9) cannot be used as an operand for inline asm\")\n-    } else {\n-        Ok(())\n+    match reloc_model {\n+        RelocModel::Rwpi | RelocModel::RopiRwpi => {\n+            Err(\"the RWPI static base register (r9) cannot be used as an operand for inline asm\")\n+        }\n+        _ => Ok(()),\n     }\n }\n "}, {"sha": "3b03766a089b22f12406b083cae5cd2e84d716d2", "filename": "compiler/rustc_target/src/asm/bpf.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fbpf.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -1,7 +1,6 @@\n-use super::{InlineAsmArch, InlineAsmType, Target};\n-use rustc_data_structures::stable_set::FxHashSet;\n+use super::{InlineAsmArch, InlineAsmType};\n use rustc_macros::HashStable_Generic;\n-use rustc_span::{sym, Symbol};\n+use rustc_span::Symbol;\n use std::fmt;\n \n def_reg_class! {\n@@ -43,19 +42,6 @@ impl BpfInlineAsmRegClass {\n     }\n }\n \n-fn only_alu32(\n-    _arch: InlineAsmArch,\n-    target_features: &FxHashSet<Symbol>,\n-    _target: &Target,\n-    _is_clobber: bool,\n-) -> Result<(), &'static str> {\n-    if !target_features.contains(&sym::alu32) {\n-        Err(\"register can't be used without the `alu32` target feature\")\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n def_regs! {\n     Bpf BpfInlineAsmReg BpfInlineAsmRegClass {\n         r0: reg = [\"r0\"],\n@@ -68,16 +54,16 @@ def_regs! {\n         r7: reg = [\"r7\"],\n         r8: reg = [\"r8\"],\n         r9: reg = [\"r9\"],\n-        w0: wreg = [\"w0\"] % only_alu32,\n-        w1: wreg = [\"w1\"] % only_alu32,\n-        w2: wreg = [\"w2\"] % only_alu32,\n-        w3: wreg = [\"w3\"] % only_alu32,\n-        w4: wreg = [\"w4\"] % only_alu32,\n-        w5: wreg = [\"w5\"] % only_alu32,\n-        w6: wreg = [\"w6\"] % only_alu32,\n-        w7: wreg = [\"w7\"] % only_alu32,\n-        w8: wreg = [\"w8\"] % only_alu32,\n-        w9: wreg = [\"w9\"] % only_alu32,\n+        w0: wreg = [\"w0\"],\n+        w1: wreg = [\"w1\"],\n+        w2: wreg = [\"w2\"],\n+        w3: wreg = [\"w3\"],\n+        w4: wreg = [\"w4\"],\n+        w5: wreg = [\"w5\"],\n+        w6: wreg = [\"w6\"],\n+        w7: wreg = [\"w7\"],\n+        w8: wreg = [\"w8\"],\n+        w9: wreg = [\"w9\"],\n \n         #error = [\"r10\", \"w10\"] =>\n             \"the stack pointer cannot be used as an operand for inline asm\","}, {"sha": "5bc4b566daf67f86a241082c544ba75b90a6444d", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 106, "deletions": 127, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -1,5 +1,5 @@\n-use crate::abi::Size;\n use crate::spec::Target;\n+use crate::{abi::Size, spec::RelocModel};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n@@ -25,7 +25,7 @@ macro_rules! def_reg_class {\n                 }\n             }\n \n-            pub fn parse(_arch: super::InlineAsmArch, name: rustc_span::Symbol) -> Result<Self, &'static str> {\n+            pub fn parse(name: rustc_span::Symbol) -> Result<Self, &'static str> {\n                 match name {\n                     $(\n                         rustc_span::sym::$class => Ok(Self::$class),\n@@ -79,30 +79,45 @@ macro_rules! def_regs {\n                 }\n             }\n \n-            pub fn parse(\n-                _arch: super::InlineAsmArch,\n-                _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n-                _target: &crate::spec::Target,\n-                _is_clobber: bool,\n-                name: &str,\n-            ) -> Result<Self, &'static str> {\n+            pub fn parse(name: &str) -> Result<Self, &'static str> {\n                 match name {\n                     $(\n-                        $($alias)|* | $reg_name => {\n-                            $($filter(_arch, _target_features, _target, _is_clobber)?;)?\n-                            Ok(Self::$reg)\n-                        }\n+                        $($alias)|* | $reg_name => Ok(Self::$reg),\n                     )*\n                     $(\n                         $($bad_reg)|* => Err($error),\n                     )*\n                     _ => Err(\"unknown register\"),\n                 }\n             }\n+\n+            pub fn validate(self,\n+                _arch: super::InlineAsmArch,\n+                _reloc_model: crate::spec::RelocModel,\n+                _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n+                _target: &crate::spec::Target,\n+                _is_clobber: bool,\n+            ) -> Result<(), &'static str> {\n+                match self {\n+                    $(\n+                        Self::$reg => {\n+                            $($filter(\n+                                _arch,\n+                                _reloc_model,\n+                                _target_features,\n+                                _target,\n+                                _is_clobber\n+                            )?;)?\n+                            Ok(())\n+                        }\n+                    )*\n+                }\n+            }\n         }\n \n         pub(super) fn fill_reg_map(\n             _arch: super::InlineAsmArch,\n+            _reloc_model: crate::spec::RelocModel,\n             _target_features: &rustc_data_structures::fx::FxHashSet<Symbol>,\n             _target: &crate::spec::Target,\n             _map: &mut rustc_data_structures::fx::FxHashMap<\n@@ -113,7 +128,7 @@ macro_rules! def_regs {\n             #[allow(unused_imports)]\n             use super::{InlineAsmReg, InlineAsmRegClass};\n             $(\n-                if $($filter(_arch, _target_features, _target, false).is_ok() &&)? true {\n+                if $($filter(_arch, _reloc_model, _target_features, _target, false).is_ok() &&)? true {\n                     if let Some(set) = _map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$class)) {\n                         set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n                     }\n@@ -295,94 +310,60 @@ impl InlineAsmReg {\n         }\n     }\n \n-    pub fn parse(\n-        arch: InlineAsmArch,\n-        target_features: &FxHashSet<Symbol>,\n-        target: &Target,\n-        is_clobber: bool,\n-        name: Symbol,\n-    ) -> Result<Self, &'static str> {\n+    pub fn parse(arch: InlineAsmArch, name: Symbol) -> Result<Self, &'static str> {\n         // FIXME: use direct symbol comparison for register names\n         // Use `Symbol::as_str` instead of `Symbol::with` here because `has_feature` may access `Symbol`.\n         let name = name.as_str();\n         Ok(match arch {\n-            InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n-                Self::X86(X86InlineAsmReg::parse(arch, target_features, target, is_clobber, name)?)\n+            InlineAsmArch::X86 | InlineAsmArch::X86_64 => Self::X86(X86InlineAsmReg::parse(name)?),\n+            InlineAsmArch::Arm => Self::Arm(ArmInlineAsmReg::parse(name)?),\n+            InlineAsmArch::AArch64 => Self::AArch64(AArch64InlineAsmReg::parse(name)?),\n+            InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n+                Self::RiscV(RiscVInlineAsmReg::parse(name)?)\n             }\n-            InlineAsmArch::Arm => {\n-                Self::Arm(ArmInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?)\n+            InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmReg::parse(name)?),\n+            InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {\n+                Self::PowerPC(PowerPCInlineAsmReg::parse(name)?)\n             }\n-            InlineAsmArch::AArch64 => Self::AArch64(AArch64InlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => Self::RiscV(\n-                RiscVInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?,\n-            ),\n-            InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => Self::PowerPC(\n-                PowerPCInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?,\n-            ),\n-            InlineAsmArch::Hexagon => Self::Hexagon(HexagonInlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::Mips | InlineAsmArch::Mips64 => Self::Mips(MipsInlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::S390x => Self::S390x(S390xInlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => Self::Wasm(WasmInlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n-            InlineAsmArch::Bpf => {\n-                Self::Bpf(BpfInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?)\n+            InlineAsmArch::Hexagon => Self::Hexagon(HexagonInlineAsmReg::parse(name)?),\n+            InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n+                Self::Mips(MipsInlineAsmReg::parse(name)?)\n             }\n-            InlineAsmArch::Avr => {\n-                Self::Avr(AvrInlineAsmReg::parse(arch, target_features, target, is_clobber, name)?)\n+            InlineAsmArch::S390x => Self::S390x(S390xInlineAsmReg::parse(name)?),\n+            InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmReg::parse(name)?),\n+            InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {\n+                Self::Wasm(WasmInlineAsmReg::parse(name)?)\n             }\n-            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmReg::parse(\n-                arch,\n-                target_features,\n-                target,\n-                is_clobber,\n-                name,\n-            )?),\n+            InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmReg::parse(name)?),\n+            InlineAsmArch::Avr => Self::Avr(AvrInlineAsmReg::parse(name)?),\n+            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmReg::parse(name)?),\n         })\n     }\n \n+    pub fn validate(\n+        self,\n+        arch: InlineAsmArch,\n+        reloc_model: RelocModel,\n+        target_features: &FxHashSet<Symbol>,\n+        target: &Target,\n+        is_clobber: bool,\n+    ) -> Result<(), &'static str> {\n+        match self {\n+            Self::X86(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Arm(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::AArch64(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::RiscV(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::PowerPC(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Hexagon(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Mips(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::S390x(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Bpf(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Avr(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Msp430(r) => r.validate(arch, reloc_model, target_features, target, is_clobber),\n+            Self::Err => unreachable!(),\n+        }\n+    }\n+\n     // NOTE: This function isn't used at the moment, but is needed to support\n     // falling back to an external assembler.\n     pub fn emit(\n@@ -584,29 +565,29 @@ impl InlineAsmRegClass {\n     pub fn parse(arch: InlineAsmArch, name: Symbol) -> Result<Self, &'static str> {\n         Ok(match arch {\n             InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n-                Self::X86(X86InlineAsmRegClass::parse(arch, name)?)\n+                Self::X86(X86InlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::Arm => Self::Arm(ArmInlineAsmRegClass::parse(arch, name)?),\n-            InlineAsmArch::AArch64 => Self::AArch64(AArch64InlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Arm => Self::Arm(ArmInlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::AArch64 => Self::AArch64(AArch64InlineAsmRegClass::parse(name)?),\n             InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n-                Self::RiscV(RiscVInlineAsmRegClass::parse(arch, name)?)\n+                Self::RiscV(RiscVInlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmRegClass::parse(name)?),\n             InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {\n-                Self::PowerPC(PowerPCInlineAsmRegClass::parse(arch, name)?)\n+                Self::PowerPC(PowerPCInlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::Hexagon => Self::Hexagon(HexagonInlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Hexagon => Self::Hexagon(HexagonInlineAsmRegClass::parse(name)?),\n             InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n-                Self::Mips(MipsInlineAsmRegClass::parse(arch, name)?)\n+                Self::Mips(MipsInlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::S390x => Self::S390x(S390xInlineAsmRegClass::parse(arch, name)?),\n-            InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::S390x => Self::S390x(S390xInlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmRegClass::parse(name)?),\n             InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {\n-                Self::Wasm(WasmInlineAsmRegClass::parse(arch, name)?)\n+                Self::Wasm(WasmInlineAsmRegClass::parse(name)?)\n             }\n-            InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(arch, name)?),\n-            InlineAsmArch::Avr => Self::Avr(AvrInlineAsmRegClass::parse(arch, name)?),\n-            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::Avr => Self::Avr(AvrInlineAsmRegClass::parse(name)?),\n+            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmRegClass::parse(name)?),\n         })\n     }\n \n@@ -749,78 +730,79 @@ impl fmt::Display for InlineAsmType {\n // falling back to an external assembler.\n pub fn allocatable_registers(\n     arch: InlineAsmArch,\n+    reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     target: &crate::spec::Target,\n ) -> FxHashMap<InlineAsmRegClass, FxHashSet<InlineAsmReg>> {\n     match arch {\n         InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n             let mut map = x86::regclass_map();\n-            x86::fill_reg_map(arch, target_features, target, &mut map);\n+            x86::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Arm => {\n             let mut map = arm::regclass_map();\n-            arm::fill_reg_map(arch, target_features, target, &mut map);\n+            arm::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::AArch64 => {\n             let mut map = aarch64::regclass_map();\n-            aarch64::fill_reg_map(arch, target_features, target, &mut map);\n+            aarch64::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n             let mut map = riscv::regclass_map();\n-            riscv::fill_reg_map(arch, target_features, target, &mut map);\n+            riscv::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Nvptx64 => {\n             let mut map = nvptx::regclass_map();\n-            nvptx::fill_reg_map(arch, target_features, target, &mut map);\n+            nvptx::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {\n             let mut map = powerpc::regclass_map();\n-            powerpc::fill_reg_map(arch, target_features, target, &mut map);\n+            powerpc::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Hexagon => {\n             let mut map = hexagon::regclass_map();\n-            hexagon::fill_reg_map(arch, target_features, target, &mut map);\n+            hexagon::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n             let mut map = mips::regclass_map();\n-            mips::fill_reg_map(arch, target_features, target, &mut map);\n+            mips::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::S390x => {\n             let mut map = s390x::regclass_map();\n-            s390x::fill_reg_map(arch, target_features, target, &mut map);\n+            s390x::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::SpirV => {\n             let mut map = spirv::regclass_map();\n-            spirv::fill_reg_map(arch, target_features, target, &mut map);\n+            spirv::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {\n             let mut map = wasm::regclass_map();\n-            wasm::fill_reg_map(arch, target_features, target, &mut map);\n+            wasm::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Bpf => {\n             let mut map = bpf::regclass_map();\n-            bpf::fill_reg_map(arch, target_features, target, &mut map);\n+            bpf::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Avr => {\n             let mut map = avr::regclass_map();\n-            avr::fill_reg_map(arch, target_features, target, &mut map);\n+            avr::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n         InlineAsmArch::Msp430 => {\n             let mut map = msp430::regclass_map();\n-            msp430::fill_reg_map(arch, target_features, target, &mut map);\n+            msp430::fill_reg_map(arch, reloc_model, target_features, target, &mut map);\n             map\n         }\n     }\n@@ -853,7 +835,6 @@ impl InlineAsmClobberAbi {\n     /// clobber ABIs for the target.\n     pub fn parse(\n         arch: InlineAsmArch,\n-        target_features: &FxHashSet<Symbol>,\n         target: &Target,\n         name: Symbol,\n     ) -> Result<Self, &'static [&'static str]> {\n@@ -877,13 +858,11 @@ impl InlineAsmClobberAbi {\n                 _ => Err(&[\"C\", \"system\", \"efiapi\", \"aapcs\"]),\n             },\n             InlineAsmArch::AArch64 => match name {\n-                \"C\" | \"system\" | \"efiapi\" => {\n-                    Ok(if aarch64::reserved_x18(arch, target_features, target, true).is_err() {\n-                        InlineAsmClobberAbi::AArch64NoX18\n-                    } else {\n-                        InlineAsmClobberAbi::AArch64\n-                    })\n-                }\n+                \"C\" | \"system\" | \"efiapi\" => Ok(if aarch64::target_reserves_x18(target) {\n+                    InlineAsmClobberAbi::AArch64NoX18\n+                } else {\n+                    InlineAsmClobberAbi::AArch64\n+                }),\n                 _ => Err(&[\"C\", \"system\", \"efiapi\"]),\n             },\n             InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => match name {"}, {"sha": "987bf9705293338c6a28c3d0f195a3158347ca6a", "filename": "compiler/rustc_target/src/asm/riscv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Friscv.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -1,5 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n-use crate::spec::Target;\n+use crate::spec::{RelocModel, Target};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::{sym, Symbol};\n@@ -54,6 +54,7 @@ impl RiscVInlineAsmRegClass {\n \n fn not_e(\n     _arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,"}, {"sha": "7c136a475486b63eb835a2e3bdac065f6204f54a", "filename": "compiler/rustc_target/src/asm/x86.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -1,5 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n-use crate::spec::Target;\n+use crate::spec::{RelocModel, Target};\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n@@ -139,6 +139,7 @@ impl X86InlineAsmRegClass {\n \n fn x86_64_only(\n     arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n@@ -152,6 +153,7 @@ fn x86_64_only(\n \n fn high_byte(\n     arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n@@ -164,6 +166,7 @@ fn high_byte(\n \n fn rbx_reserved(\n     arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,\n@@ -179,6 +182,7 @@ fn rbx_reserved(\n \n fn esi_reserved(\n     arch: InlineAsmArch,\n+    _reloc_model: RelocModel,\n     _target_features: &FxHashSet<Symbol>,\n     _target: &Target,\n     _is_clobber: bool,"}, {"sha": "392144ca7639c81799e6a9d5b53b0ef7d29fad3e", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -87,6 +88,7 @@ pub fn provide(providers: &mut Providers) {\n         static_mutability,\n         generator_kind,\n         codegen_fn_attrs,\n+        asm_target_features,\n         collect_mod_item_types,\n         should_inherit_track_caller,\n         ..*providers\n@@ -3255,6 +3257,24 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     codegen_fn_attrs\n }\n \n+/// Computes the set of target features used in a function for the purposes of\n+/// inline assembly.\n+fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, id: DefId) -> &'tcx FxHashSet<Symbol> {\n+    let mut target_features = tcx.sess.target_features.clone();\n+    let attrs = tcx.codegen_fn_attrs(id);\n+    target_features.extend(&attrs.target_features);\n+    match attrs.instruction_set {\n+        None => {}\n+        Some(InstructionSetAttr::ArmA32) => {\n+            target_features.remove(&sym::thumb_mode);\n+        }\n+        Some(InstructionSetAttr::ArmT32) => {\n+            target_features.insert(sym::thumb_mode);\n+        }\n+    }\n+    tcx.arena.alloc(target_features)\n+}\n+\n /// Checks if the provided DefId is a method in a trait impl for a trait which has track_caller\n /// applied to the method prototype.\n fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {"}, {"sha": "e64f5e8af52384a2de783a8d0d848a1d804ddd04", "filename": "src/test/ui/asm/issue-85247.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/src%2Ftest%2Fui%2Fasm%2Fissue-85247.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/src%2Ftest%2Fui%2Fasm%2Fissue-85247.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-85247.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -0,0 +1,26 @@\n+// revisions: ropi rwpi\n+\n+// [ropi] compile-flags: --target armv7-unknown-linux-gnueabihf -C relocation-model=ropi\n+// [rwpi] compile-flags: --target armv7-unknown-linux-gnueabihf -C relocation-model=rwpi\n+// [ropi] needs-llvm-components: arm\n+// [rwpi] needs-llvm-components: arm\n+// [ropi] build-pass\n+\n+#![feature(no_core, lang_items, rustc_attrs)]\n+#![no_core]\n+#![crate_type = \"rlib\"]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+// R9 is reserved as the RWPI base register\n+fn main() {\n+    unsafe {\n+        asm!(\"\", out(\"r9\") _);\n+        //[rwpi]~^ cannot use register `r9`\n+    }\n+}"}, {"sha": "996b0933a34122bfeca371fc039977b33c29bb9c", "filename": "src/test/ui/asm/issue-85247.rwpi.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/src%2Ftest%2Fui%2Fasm%2Fissue-85247.rwpi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/src%2Ftest%2Fui%2Fasm%2Fissue-85247.rwpi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-85247.rwpi.stderr?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -0,0 +1,8 @@\n+error: cannot use register `r9`: the RWPI static base register (r9) cannot be used as an operand for inline asm\n+  --> $DIR/issue-85247.rs:23:18\n+   |\n+LL |         asm!(\"\", out(\"r9\") _);\n+   |                  ^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "d595e88ff80c5d6536641408aaa3eb6946983adc", "filename": "src/test/ui/asm/issue-92378.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/src%2Ftest%2Fui%2Fasm%2Fissue-92378.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/src%2Ftest%2Fui%2Fasm%2Fissue-92378.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-92378.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -0,0 +1,30 @@\n+// compile-flags: --target armv5te-unknown-linux-gnueabi\n+// needs-llvm-components: arm\n+// build-pass\n+\n+#![feature(no_core, lang_items, rustc_attrs, isa_attribute)]\n+#![no_core]\n+#![crate_type = \"rlib\"]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+// ARM uses R11 for the frame pointer, make sure R7 is usable.\n+#[instruction_set(arm::a32)]\n+pub fn arm() {\n+    unsafe {\n+        asm!(\"\", out(\"r7\") _);\n+    }\n+}\n+\n+// Thumb uses R7 for the frame pointer, make sure R11 is usable.\n+#[instruction_set(arm::t32)]\n+pub fn thumb() {\n+    unsafe {\n+        asm!(\"\", out(\"r11\") _);\n+    }\n+}"}, {"sha": "4c4ce8b5e9e493ecd6f22fcc9bd70a9d036b4038", "filename": "src/test/ui/asm/x86_64/bad-reg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.rs?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -31,8 +31,6 @@ fn main() {\n         //~^ ERROR invalid register `ip`: the instruction pointer cannot be used as an operand\n         asm!(\"\", in(\"k0\") foo);\n         //~^ ERROR invalid register `k0`: the k0 AVX mask register cannot be used as an operand\n-        asm!(\"\", in(\"ah\") foo);\n-        //~^ ERROR invalid register `ah`: high byte registers cannot be used as an operand\n \n         asm!(\"\", in(\"st(2)\") foo);\n         //~^ ERROR register class `x87_reg` can only be used as a clobber, not as an input or output"}, {"sha": "f8b024e1acd62c3b7d8891d4cc80ce558a312f63", "filename": "src/test/ui/asm/x86_64/bad-reg.stderr", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2e6993e58e13abb03f487f401731fe77b5a33/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2e6993e58e13abb03f487f401731fe77b5a33/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fx86_64%2Fbad-reg.stderr?ref=1cf2e6993e58e13abb03f487f401731fe77b5a33", "patch": "@@ -70,91 +70,85 @@ error: invalid register `k0`: the k0 AVX mask register cannot be used as an oper\n LL |         asm!(\"\", in(\"k0\") foo);\n    |                  ^^^^^^^^^^^^\n \n-error: invalid register `ah`: high byte registers cannot be used as an operand on x86_64\n-  --> $DIR/bad-reg.rs:34:18\n-   |\n-LL |         asm!(\"\", in(\"ah\") foo);\n-   |                  ^^^^^^^^^^^^\n-\n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:37:18\n+  --> $DIR/bad-reg.rs:35:18\n    |\n LL |         asm!(\"\", in(\"st(2)\") foo);\n    |                  ^^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:39:18\n+  --> $DIR/bad-reg.rs:37:18\n    |\n LL |         asm!(\"\", in(\"mm0\") foo);\n    |                  ^^^^^^^^^^^^^\n \n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:43:20\n+  --> $DIR/bad-reg.rs:41:20\n    |\n LL |         asm!(\"{}\", in(x87_reg) foo);\n    |                    ^^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:45:20\n+  --> $DIR/bad-reg.rs:43:20\n    |\n LL |         asm!(\"{}\", in(mmx_reg) foo);\n    |                    ^^^^^^^^^^^^^^^\n \n error: register class `x87_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:47:20\n+  --> $DIR/bad-reg.rs:45:20\n    |\n LL |         asm!(\"{}\", out(x87_reg) _);\n    |                    ^^^^^^^^^^^^^^\n \n error: register class `mmx_reg` can only be used as a clobber, not as an input or output\n-  --> $DIR/bad-reg.rs:49:20\n+  --> $DIR/bad-reg.rs:47:20\n    |\n LL |         asm!(\"{}\", out(mmx_reg) _);\n    |                    ^^^^^^^^^^^^^^\n \n error: register `al` conflicts with register `ax`\n-  --> $DIR/bad-reg.rs:55:33\n+  --> $DIR/bad-reg.rs:53:33\n    |\n LL |         asm!(\"\", in(\"eax\") foo, in(\"al\") bar);\n    |                  -------------  ^^^^^^^^^^^^ register `al`\n    |                  |\n    |                  register `ax`\n \n error: register `ax` conflicts with register `ax`\n-  --> $DIR/bad-reg.rs:57:33\n+  --> $DIR/bad-reg.rs:55:33\n    |\n LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n    |                  -------------  ^^^^^^^^^^^^^^ register `ax`\n    |                  |\n    |                  register `ax`\n    |\n help: use `lateout` instead of `out` to avoid conflict\n-  --> $DIR/bad-reg.rs:57:18\n+  --> $DIR/bad-reg.rs:55:18\n    |\n LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n    |                  ^^^^^^^^^^^^^\n \n error: register `ymm0` conflicts with register `xmm0`\n-  --> $DIR/bad-reg.rs:60:34\n+  --> $DIR/bad-reg.rs:58:34\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, in(\"ymm0\") bar);\n    |                  --------------  ^^^^^^^^^^^^^^ register `ymm0`\n    |                  |\n    |                  register `xmm0`\n \n error: register `ymm0` conflicts with register `xmm0`\n-  --> $DIR/bad-reg.rs:62:34\n+  --> $DIR/bad-reg.rs:60:34\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n    |                  --------------  ^^^^^^^^^^^^^^^ register `ymm0`\n    |                  |\n    |                  register `xmm0`\n    |\n help: use `lateout` instead of `out` to avoid conflict\n-  --> $DIR/bad-reg.rs:62:18\n+  --> $DIR/bad-reg.rs:60:18\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n    |                  ^^^^^^^^^^^^^^\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 20 previous errors\n "}]}