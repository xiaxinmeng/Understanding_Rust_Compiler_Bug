{"sha": "fb14ad06fab41a4e5c1436749dea21b67105c069", "node_id": "C_kwDOAAsO6NoAKGZiMTRhZDA2ZmFiNDFhNGU1YzE0MzY3NDlkZWEyMWI2NzEwNWMwNjk", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-09-01T12:31:27Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-09-01T12:31:27Z"}, "message": "Correctly merge impl block cfg attributes with its parents", "tree": {"sha": "d2254b45b2895fb12d1d6679c258dbbceaeb374c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2254b45b2895fb12d1d6679c258dbbceaeb374c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb14ad06fab41a4e5c1436749dea21b67105c069", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb14ad06fab41a4e5c1436749dea21b67105c069", "html_url": "https://github.com/rust-lang/rust/commit/fb14ad06fab41a4e5c1436749dea21b67105c069", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb14ad06fab41a4e5c1436749dea21b67105c069/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a42ca942cda0d197a63373127e7e373305957a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a42ca942cda0d197a63373127e7e373305957a0", "html_url": "https://github.com/rust-lang/rust/commit/7a42ca942cda0d197a63373127e7e373305957a0"}], "stats": {"total": 60, "additions": 40, "deletions": 20}, "files": [{"sha": "765f7c61bd392dc433d5e2e5aa2c55ea95828992", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 40, "deletions": 20, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fb14ad06fab41a4e5c1436749dea21b67105c069/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb14ad06fab41a4e5c1436749dea21b67105c069/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=fb14ad06fab41a4e5c1436749dea21b67105c069", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n \n use crate::clean::cfg::Cfg;\n use crate::clean::inline::{load_attrs, merge_attrs};\n-use crate::clean::{Crate, Item};\n+use crate::clean::{Crate, Item, ItemKind};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::Pass;\n@@ -26,30 +26,50 @@ struct CfgPropagator<'a, 'tcx> {\n     cx: &'a mut DocContext<'tcx>,\n }\n \n-impl<'a, 'tcx> DocFolder for CfgPropagator<'a, 'tcx> {\n-    fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n-        let old_parent_cfg = self.parent_cfg.clone();\n+impl<'a, 'tcx> CfgPropagator<'a, 'tcx> {\n+    // Some items need to merge their attributes with their parents' otherwise a few of them\n+    // (mostly `cfg` ones) will be missing.\n+    fn merge_with_parent_attributes(&mut self, item: &mut Item) {\n+        let check_parent = match &*item.kind {\n+            // impl blocks can be in different modules with different cfg and we need to get them\n+            // as well.\n+            ItemKind::ImplItem(_) => false,\n+            kind if kind.is_non_assoc() => true,\n+            _ => return,\n+        };\n \n-        if item.kind.is_non_assoc() &&\n-            let Some(def_id) = item.item_id.as_def_id().and_then(|def_id| def_id.as_local()) {\n-            let hir = self.cx.tcx.hir();\n-            let hir_id = hir.local_def_id_to_hir_id(def_id);\n+        let Some(def_id) = item.item_id.as_def_id().and_then(|def_id| def_id.as_local())\n+            else { return };\n+\n+        let hir = self.cx.tcx.hir();\n+        let hir_id = hir.local_def_id_to_hir_id(def_id);\n+\n+        if check_parent {\n             let expected_parent = hir.get_parent_item(hir_id);\n+            // If parents are different, it means that `item` is a reexport and we need\n+            // to compute the actual `cfg` by iterating through its \"real\" parents.\n+            if self.parent == Some(expected_parent) {\n+                return;\n+            }\n+        }\n \n-            // If parents are different, it means that `item` is a reexport and we need to compute\n-            // the actual `cfg` by iterating through its \"real\" parents.\n-            if self.parent != Some(expected_parent) {\n-                let mut attrs = Vec::new();\n-                for (parent_hir_id, _) in hir.parent_iter(hir_id) {\n-                    if let Some(def_id) = hir.opt_local_def_id(parent_hir_id) {\n-                        attrs.extend_from_slice(load_attrs(self.cx, def_id.to_def_id()));\n-                    }\n-                }\n-                let (_, cfg) =\n-                    merge_attrs(self.cx, None, item.attrs.other_attrs.as_slice(), Some(&attrs));\n-                item.cfg = cfg;\n+        let mut attrs = Vec::new();\n+        for (parent_hir_id, _) in hir.parent_iter(hir_id) {\n+            if let Some(def_id) = hir.opt_local_def_id(parent_hir_id) {\n+                attrs.extend_from_slice(load_attrs(self.cx, def_id.to_def_id()));\n             }\n         }\n+        let (_, cfg) = merge_attrs(self.cx, None, item.attrs.other_attrs.as_slice(), Some(&attrs));\n+        item.cfg = cfg;\n+    }\n+}\n+\n+impl<'a, 'tcx> DocFolder for CfgPropagator<'a, 'tcx> {\n+    fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n+        let old_parent_cfg = self.parent_cfg.clone();\n+\n+        self.merge_with_parent_attributes(&mut item);\n+\n         let new_cfg = match (self.parent_cfg.take(), item.cfg.take()) {\n             (None, None) => None,\n             (Some(rc), None) | (None, Some(rc)) => Some(rc),"}]}