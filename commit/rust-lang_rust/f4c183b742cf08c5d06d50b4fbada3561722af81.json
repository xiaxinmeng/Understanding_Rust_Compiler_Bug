{"sha": "f4c183b742cf08c5d06d50b4fbada3561722af81", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YzE4M2I3NDJjZjA4YzVkMDZkNTBiNGZiYWRhMzU2MTcyMmFmODE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-17T16:35:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-21T21:26:53Z"}, "message": "move the trans trait caches into tcx\n\nArguably these could become custom queries, but I chose not to do that\nbecause the relationship of queries and trait system is not yet fleshed\nout enough. For now it seems fine to have them be `DepTrackingMap` using\nthe memoize pattern.", "tree": {"sha": "ca7e0426a573623dff194fd8fc5908c25cfbedca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca7e0426a573623dff194fd8fc5908c25cfbedca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4c183b742cf08c5d06d50b4fbada3561722af81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4c183b742cf08c5d06d50b4fbada3561722af81", "html_url": "https://github.com/rust-lang/rust/commit/f4c183b742cf08c5d06d50b4fbada3561722af81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4c183b742cf08c5d06d50b4fbada3561722af81/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e48a759f51ae23f817339eda1485fa3afe6d8d04", "url": "https://api.github.com/repos/rust-lang/rust/commits/e48a759f51ae23f817339eda1485fa3afe6d8d04", "html_url": "https://github.com/rust-lang/rust/commit/e48a759f51ae23f817339eda1485fa3afe6d8d04"}], "stats": {"total": 167, "additions": 89, "deletions": 78}, "files": [{"sha": "18f0a749f701853e3a694786ed6452cd9a79503c", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4c183b742cf08c5d06d50b4fbada3561722af81/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c183b742cf08c5d06d50b4fbada3561722af81/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=f4c183b742cf08c5d06d50b4fbada3561722af81", "patch": "@@ -55,6 +55,7 @@ mod object_safety;\n mod select;\n mod specialize;\n mod structural_impls;\n+pub mod trans;\n mod util;\n \n /// An `Obligation` represents some trait reference (e.g. `int:Eq`) for"}, {"sha": "8517f573e602d644ba1a1d6aac4a80a68f73cd94", "filename": "src/librustc/traits/trans/mod.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f4c183b742cf08c5d06d50b4fbada3561722af81/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c183b742cf08c5d06d50b4fbada3561722af81/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=f4c183b742cf08c5d06d50b4fbada3561722af81", "patch": "@@ -0,0 +1,73 @@\n+use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n+use hir::def_id::DefId;\n+use std::cell::RefCell;\n+use std::marker::PhantomData;\n+use traits::Vtable;\n+use ty::{self, Ty};\n+\n+/// Specializes caches used in trans -- in particular, they assume all\n+/// types are fully monomorphized and that free regions can be erased.\n+pub struct TransTraitCaches<'tcx> {\n+    pub trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n+    pub project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n+}\n+\n+impl<'tcx> TransTraitCaches<'tcx> {\n+    pub fn new(graph: DepGraph) -> Self {\n+        TransTraitCaches {\n+            trait_cache: RefCell::new(DepTrackingMap::new(graph.clone())),\n+            project_cache: RefCell::new(DepTrackingMap::new(graph)),\n+        }\n+    }\n+}\n+\n+// Implement DepTrackingMapConfig for `trait_cache`\n+pub struct TraitSelectionCache<'tcx> {\n+    data: PhantomData<&'tcx ()>\n+}\n+\n+impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n+    type Key = ty::PolyTraitRef<'tcx>;\n+    type Value = Vtable<'tcx, ()>;\n+    fn to_dep_node(key: &ty::PolyTraitRef<'tcx>) -> DepNode<DefId> {\n+        key.to_poly_trait_predicate().dep_node()\n+    }\n+}\n+\n+// # Global Cache\n+\n+pub struct ProjectionCache<'gcx> {\n+    data: PhantomData<&'gcx ()>\n+}\n+\n+impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n+    type Key = Ty<'gcx>;\n+    type Value = Ty<'gcx>;\n+    fn to_dep_node(key: &Self::Key) -> DepNode<DefId> {\n+        // Ideally, we'd just put `key` into the dep-node, but we\n+        // can't put full types in there. So just collect up all the\n+        // def-ids of structs/enums as well as any traits that we\n+        // project out of. It doesn't matter so much what we do here,\n+        // except that if we are too coarse, we'll create overly\n+        // coarse edges between impls and the trans. For example, if\n+        // we just used the def-id of things we are projecting out of,\n+        // then the key for `<Foo as SomeTrait>::T` and `<Bar as\n+        // SomeTrait>::T` would both share a dep-node\n+        // (`TraitSelect(SomeTrait)`), and hence the impls for both\n+        // `Foo` and `Bar` would be considered inputs. So a change to\n+        // `Bar` would affect things that just normalized `Foo`.\n+        // Anyway, this heuristic is not ideal, but better than\n+        // nothing.\n+        let def_ids: Vec<DefId> =\n+            key.walk()\n+               .filter_map(|t| match t.sty {\n+                   ty::TyAdt(adt_def, _) => Some(adt_def.did),\n+                   ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n+                   _ => None,\n+               })\n+               .collect();\n+\n+        DepNode::ProjectionCache { def_ids: def_ids }\n+    }\n+}\n+"}, {"sha": "e836bf23a5a81f8766aaecb6e7a26963ccc3f3b5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f4c183b742cf08c5d06d50b4fbada3561722af81/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c183b742cf08c5d06d50b4fbada3561722af81/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f4c183b742cf08c5d06d50b4fbada3561722af81", "patch": "@@ -407,6 +407,8 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub specializes_cache: RefCell<traits::SpecializesCache>,\n \n+    pub trans_trait_caches: traits::trans::TransTraitCaches<'tcx>,\n+\n     pub dep_graph: DepGraph,\n \n     /// Common types, pre-interned for your convenience.\n@@ -689,6 +691,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         providers[LOCAL_CRATE] = local_providers;\n         tls::enter_global(GlobalCtxt {\n             sess: s,\n+            trans_trait_caches: traits::trans::TransTraitCaches::new(dep_graph.clone()),\n             specializes_cache: RefCell::new(traits::SpecializesCache::new()),\n             global_arenas: arenas,\n             global_interners: interners,"}, {"sha": "ceb292c13c12aaacdb7c163d2236131a2ee5ea3f", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 65, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f4c183b742cf08c5d06d50b4fbada3561722af81/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c183b742cf08c5d06d50b4fbada3561722af81/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=f4c183b742cf08c5d06d50b4fbada3561722af81", "patch": "@@ -10,7 +10,7 @@\n \n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef};\n-use rustc::dep_graph::{DepGraph, DepGraphSafe, DepNode, DepTrackingMap, DepTrackingMapConfig};\n+use rustc::dep_graph::{DepGraph, DepGraphSafe};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n@@ -34,7 +34,6 @@ use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n-use std::marker::PhantomData;\n use std::ptr;\n use std::iter;\n use std::str;\n@@ -84,9 +83,6 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     check_overflow: bool,\n \n     use_dll_storage_attrs: bool,\n-\n-    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n-    project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n@@ -171,56 +167,6 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     symbol_cache: &'a SymbolCache<'a, 'tcx>,\n }\n \n-// Implement DepTrackingMapConfig for `trait_cache`\n-pub struct TraitSelectionCache<'tcx> {\n-    data: PhantomData<&'tcx ()>\n-}\n-\n-impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n-    type Key = ty::PolyTraitRef<'tcx>;\n-    type Value = traits::Vtable<'tcx, ()>;\n-    fn to_dep_node(key: &ty::PolyTraitRef<'tcx>) -> DepNode<DefId> {\n-        key.to_poly_trait_predicate().dep_node()\n-    }\n-}\n-\n-// # Global Cache\n-\n-pub struct ProjectionCache<'gcx> {\n-    data: PhantomData<&'gcx ()>\n-}\n-\n-impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n-    type Key = Ty<'gcx>;\n-    type Value = Ty<'gcx>;\n-    fn to_dep_node(key: &Self::Key) -> DepNode<DefId> {\n-        // Ideally, we'd just put `key` into the dep-node, but we\n-        // can't put full types in there. So just collect up all the\n-        // def-ids of structs/enums as well as any traits that we\n-        // project out of. It doesn't matter so much what we do here,\n-        // except that if we are too coarse, we'll create overly\n-        // coarse edges between impls and the trans. For example, if\n-        // we just used the def-id of things we are projecting out of,\n-        // then the key for `<Foo as SomeTrait>::T` and `<Bar as\n-        // SomeTrait>::T` would both share a dep-node\n-        // (`TraitSelect(SomeTrait)`), and hence the impls for both\n-        // `Foo` and `Bar` would be considered inputs. So a change to\n-        // `Bar` would affect things that just normalized `Foo`.\n-        // Anyway, this heuristic is not ideal, but better than\n-        // nothing.\n-        let def_ids: Vec<DefId> =\n-            key.walk()\n-               .filter_map(|t| match t.sty {\n-                   ty::TyAdt(adt_def, _) => Some(adt_def.did),\n-                   ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n-                   _ => None,\n-               })\n-               .collect();\n-\n-        DepNode::ProjectionCache { def_ids: def_ids }\n-    }\n-}\n-\n /// A CrateContext value binds together one LocalCrateContext with the\n /// SharedCrateContext. It exists as a convenience wrapper, so we don't have to\n /// pass around (SharedCrateContext, LocalCrateContext) tuples all over trans.\n@@ -382,8 +328,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             tcx: tcx,\n             check_overflow: check_overflow,\n             use_dll_storage_attrs: use_dll_storage_attrs,\n-            trait_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n-            project_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n         }\n     }\n \n@@ -403,14 +347,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.exported_symbols\n     }\n \n-    pub fn trait_cache(&self) -> &RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>> {\n-        &self.trait_cache\n-    }\n-\n-    pub fn project_cache(&self) -> &RefCell<DepTrackingMap<ProjectionCache<'tcx>>> {\n-        &self.project_cache\n-    }\n-\n     pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n     }"}, {"sha": "33626e7c39fc1e16115fdb7b4e96c93d0579977b", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f4c183b742cf08c5d06d50b4fbada3561722af81/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c183b742cf08c5d06d50b4fbada3561722af81/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=f4c183b742cf08c5d06d50b4fbada3561722af81", "patch": "@@ -117,7 +117,7 @@ fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // Remove any references to regions; this helps improve caching.\n     let trait_ref = tcx.erase_regions(&trait_ref);\n \n-    scx.trait_cache().memoize(trait_ref, || {\n+    tcx.trans_trait_caches.trait_cache.memoize(trait_ref, || {\n         debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n                trait_ref, trait_ref.def_id());\n \n@@ -307,7 +307,7 @@ pub fn apply_param_substs<'a, 'tcx, T>(scx: &SharedCrateContext<'a, 'tcx>,\n     debug!(\"apply_param_substs(param_substs={:?}, value={:?})\", param_substs, value);\n     let substituted = value.subst(tcx, param_substs);\n     let substituted = scx.tcx().erase_regions(&substituted);\n-    AssociatedTypeNormalizer::new(scx).fold(&substituted)\n+    AssociatedTypeNormalizer::new(tcx).fold(&substituted)\n }\n \n /// Returns the normalized type of a struct field\n@@ -319,15 +319,13 @@ pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.normalize_associated_type(&f.ty(tcx, param_substs))\n }\n \n-struct AssociatedTypeNormalizer<'a, 'b: 'a, 'gcx: 'b> {\n-    shared: &'a SharedCrateContext<'b, 'gcx>,\n+struct AssociatedTypeNormalizer<'a, 'gcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n }\n \n-impl<'a, 'b, 'gcx> AssociatedTypeNormalizer<'a, 'b, 'gcx> {\n-    fn new(shared: &'a SharedCrateContext<'b, 'gcx>) -> Self {\n-        AssociatedTypeNormalizer {\n-            shared: shared,\n-        }\n+impl<'a, 'gcx> AssociatedTypeNormalizer<'a, 'gcx> {\n+    fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>) -> Self {\n+        AssociatedTypeNormalizer { tcx }\n     }\n \n     fn fold<T:TypeFoldable<'gcx>>(&mut self, value: &T) -> T {\n@@ -339,18 +337,18 @@ impl<'a, 'b, 'gcx> AssociatedTypeNormalizer<'a, 'b, 'gcx> {\n     }\n }\n \n-impl<'a, 'b, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'b, 'gcx> {\n+impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n     fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'gcx> {\n-        self.shared.tcx()\n+        self.tcx\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'gcx>) -> Ty<'gcx> {\n         if !ty.has_projection_types() {\n             ty\n         } else {\n-            self.shared.project_cache().memoize(ty, || {\n+            self.tcx.trans_trait_caches.project_cache.memoize(ty, || {\n                 debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n-                self.shared.tcx().normalize_associated_type(&ty)\n+                self.tcx.normalize_associated_type(&ty)\n             })\n         }\n     }"}]}