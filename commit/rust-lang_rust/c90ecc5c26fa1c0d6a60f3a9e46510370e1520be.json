{"sha": "c90ecc5c26fa1c0d6a60f3a9e46510370e1520be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MGVjYzVjMjZmYTFjMGQ2YTYwZjNhOWU0NjUxMDM3MGUxNTIwYmU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-16T15:07:25Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-16T15:07:25Z"}, "message": "Only add entries to SourceToDef dynmaps when they come from the same file", "tree": {"sha": "b7904c506ad53072483490bf548c137f3e2ed520", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7904c506ad53072483490bf548c137f3e2ed520"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c90ecc5c26fa1c0d6a60f3a9e46510370e1520be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c90ecc5c26fa1c0d6a60f3a9e46510370e1520be", "html_url": "https://github.com/rust-lang/rust/commit/c90ecc5c26fa1c0d6a60f3a9e46510370e1520be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c90ecc5c26fa1c0d6a60f3a9e46510370e1520be/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c0142f61ae990a62c51c904952ca49ee8073c1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c0142f61ae990a62c51c904952ca49ee8073c1c", "html_url": "https://github.com/rust-lang/rust/commit/0c0142f61ae990a62c51c904952ca49ee8073c1c"}], "stats": {"total": 201, "additions": 125, "deletions": 76}, "files": [{"sha": "4d4b26b8d86c3ae0fb5190b33e3cf286ffee53df", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c90ecc5c26fa1c0d6a60f3a9e46510370e1520be/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90ecc5c26fa1c0d6a60f3a9e46510370e1520be/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=c90ecc5c26fa1c0d6a60f3a9e46510370e1520be", "patch": "@@ -95,7 +95,7 @@ use hir_def::{\n     GenericDefId, ImplId, LifetimeParamId, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n     TypeParamId, UnionId, VariantId,\n };\n-use hir_expand::{name::AsName, AstId, MacroCallId, MacroDefId, MacroDefKind};\n+use hir_expand::{name::AsName, AstId, HirFileId, MacroCallId, MacroDefId, MacroDefKind};\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use stdx::impl_from;\n@@ -106,7 +106,7 @@ use syntax::{\n \n use crate::{db::HirDatabase, InFile};\n \n-pub(super) type SourceToDefCache = FxHashMap<ChildContainer, DynMap>;\n+pub(super) type SourceToDefCache = FxHashMap<ChildContainer, FxHashMap<HirFileId, DynMap>>;\n \n pub(super) struct SourceToDefCtx<'a, 'b> {\n     pub(super) db: &'b dyn HirDatabase,\n@@ -252,17 +252,18 @@ impl SourceToDefCtx<'_, '_> {\n \n     fn dyn_map<Ast: AstNode + 'static>(&mut self, src: InFile<&Ast>) -> Option<&DynMap> {\n         let container = self.find_container(src.map(|it| it.syntax()))?;\n+        Some(self.cache_for(container, src.file_id))\n+    }\n+\n+    fn cache_for(&mut self, container: ChildContainer, file_id: HirFileId) -> &DynMap {\n         let db = self.db;\n-        let dyn_map =\n-            &*self.cache.entry(container).or_insert_with(|| container.child_by_source(db));\n-        Some(dyn_map)\n+        let dyn_maps = self.cache.entry(container).or_default();\n+        dyn_maps.entry(file_id).or_insert_with(|| container.child_by_source(db, file_id))\n     }\n \n     pub(super) fn type_param_to_def(&mut self, src: InFile<ast::TypeParam>) -> Option<TypeParamId> {\n         let container: ChildContainer = self.find_generic_param_container(src.syntax())?.into();\n-        let db = self.db;\n-        let dyn_map =\n-            &*self.cache.entry(container).or_insert_with(|| container.child_by_source(db));\n+        let dyn_map = self.cache_for(container, src.file_id);\n         dyn_map[keys::TYPE_PARAM].get(&src).copied()\n     }\n \n@@ -271,9 +272,7 @@ impl SourceToDefCtx<'_, '_> {\n         src: InFile<ast::LifetimeParam>,\n     ) -> Option<LifetimeParamId> {\n         let container: ChildContainer = self.find_generic_param_container(src.syntax())?.into();\n-        let db = self.db;\n-        let dyn_map =\n-            &*self.cache.entry(container).or_insert_with(|| container.child_by_source(db));\n+        let dyn_map = self.cache_for(container, src.file_id);\n         dyn_map[keys::LIFETIME_PARAM].get(&src).copied()\n     }\n \n@@ -282,9 +281,7 @@ impl SourceToDefCtx<'_, '_> {\n         src: InFile<ast::ConstParam>,\n     ) -> Option<ConstParamId> {\n         let container: ChildContainer = self.find_generic_param_container(src.syntax())?.into();\n-        let db = self.db;\n-        let dyn_map =\n-            &*self.cache.entry(container).or_insert_with(|| container.child_by_source(db));\n+        let dyn_map = self.cache_for(container, src.file_id);\n         dyn_map[keys::CONST_PARAM].get(&src).copied()\n     }\n \n@@ -422,17 +419,17 @@ impl_from! {\n }\n \n impl ChildContainer {\n-    fn child_by_source(self, db: &dyn HirDatabase) -> DynMap {\n+    fn child_by_source(self, db: &dyn HirDatabase, file_id: HirFileId) -> DynMap {\n         let db = db.upcast();\n         match self {\n-            ChildContainer::DefWithBodyId(it) => it.child_by_source(db),\n-            ChildContainer::ModuleId(it) => it.child_by_source(db),\n-            ChildContainer::TraitId(it) => it.child_by_source(db),\n-            ChildContainer::ImplId(it) => it.child_by_source(db),\n-            ChildContainer::EnumId(it) => it.child_by_source(db),\n-            ChildContainer::VariantId(it) => it.child_by_source(db),\n+            ChildContainer::DefWithBodyId(it) => it.child_by_source(db, file_id),\n+            ChildContainer::ModuleId(it) => it.child_by_source(db, file_id),\n+            ChildContainer::TraitId(it) => it.child_by_source(db, file_id),\n+            ChildContainer::ImplId(it) => it.child_by_source(db, file_id),\n+            ChildContainer::EnumId(it) => it.child_by_source(db, file_id),\n+            ChildContainer::VariantId(it) => it.child_by_source(db, file_id),\n             ChildContainer::TypeAliasId(_) => DynMap::default(),\n-            ChildContainer::GenericDefId(it) => it.child_by_source(db),\n+            ChildContainer::GenericDefId(it) => it.child_by_source(db, file_id),\n         }\n     }\n }"}, {"sha": "980e08983d4fb98eba535b8b7680e9e219dd9fa0", "filename": "crates/hir_def/src/child_by_source.rs", "status": "modified", "additions": 104, "deletions": 52, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/c90ecc5c26fa1c0d6a60f3a9e46510370e1520be/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90ecc5c26fa1c0d6a60f3a9e46510370e1520be/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs?ref=c90ecc5c26fa1c0d6a60f3a9e46510370e1520be", "patch": "@@ -5,6 +5,7 @@\n //! node for a *child*, and get its hir.\n \n use either::Either;\n+use hir_expand::HirFileId;\n \n use crate::{\n     db::DefDatabase,\n@@ -17,145 +18,196 @@ use crate::{\n };\n \n pub trait ChildBySource {\n-    fn child_by_source(&self, db: &dyn DefDatabase) -> DynMap {\n+    fn child_by_source(&self, db: &dyn DefDatabase, file_id: HirFileId) -> DynMap {\n         let mut res = DynMap::default();\n-        self.child_by_source_to(db, &mut res);\n+        self.child_by_source_to(db, file_id, &mut res);\n         res\n     }\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, map: &mut DynMap);\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, file_id: HirFileId, map: &mut DynMap);\n }\n \n impl ChildBySource for TraitId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, file_id: HirFileId, res: &mut DynMap) {\n         let data = db.trait_data(*self);\n-        for (_name, item) in data.items.iter() {\n-            match *item {\n+        for &(_, item) in data.items.iter() {\n+            match item {\n                 AssocItemId::FunctionId(func) => {\n-                    let src = func.lookup(db).source(db);\n-                    res[keys::FUNCTION].insert(src, func)\n+                    let loc = func.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        res[keys::FUNCTION].insert(src, func)\n+                    }\n                 }\n                 AssocItemId::ConstId(konst) => {\n-                    let src = konst.lookup(db).source(db);\n-                    res[keys::CONST].insert(src, konst)\n+                    let loc = konst.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        res[keys::CONST].insert(src, konst)\n+                    }\n                 }\n                 AssocItemId::TypeAliasId(ty) => {\n-                    let src = ty.lookup(db).source(db);\n-                    res[keys::TYPE_ALIAS].insert(src, ty)\n+                    let loc = ty.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        res[keys::TYPE_ALIAS].insert(src, ty)\n+                    }\n                 }\n             }\n         }\n     }\n }\n \n impl ChildBySource for ImplId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, file_id: HirFileId, res: &mut DynMap) {\n         let data = db.impl_data(*self);\n         for &item in data.items.iter() {\n             match item {\n                 AssocItemId::FunctionId(func) => {\n-                    let src = func.lookup(db).source(db);\n-                    res[keys::FUNCTION].insert(src, func)\n+                    let loc = func.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        res[keys::FUNCTION].insert(src, func)\n+                    }\n                 }\n                 AssocItemId::ConstId(konst) => {\n-                    let src = konst.lookup(db).source(db);\n-                    res[keys::CONST].insert(src, konst)\n+                    let loc = konst.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        res[keys::CONST].insert(src, konst)\n+                    }\n                 }\n                 AssocItemId::TypeAliasId(ty) => {\n-                    let src = ty.lookup(db).source(db);\n-                    res[keys::TYPE_ALIAS].insert(src, ty)\n+                    let loc = ty.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        res[keys::TYPE_ALIAS].insert(src, ty)\n+                    }\n                 }\n             }\n         }\n     }\n }\n \n impl ChildBySource for ModuleId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, file_id: HirFileId, res: &mut DynMap) {\n         let def_map = self.def_map(db);\n         let module_data = &def_map[self.local_id];\n-        module_data.scope.child_by_source_to(db, res);\n+        module_data.scope.child_by_source_to(db, file_id, res);\n     }\n }\n \n impl ChildBySource for ItemScope {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n-        self.declarations().for_each(|item| add_module_def(db, res, item));\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, file_id: HirFileId, res: &mut DynMap) {\n+        self.declarations().for_each(|item| add_module_def(db, file_id, res, item));\n         self.unnamed_consts().for_each(|konst| {\n             let src = konst.lookup(db).source(db);\n             res[keys::CONST].insert(src, konst);\n         });\n-        self.impls().for_each(|imp| add_impl(db, res, imp));\n+        self.impls().for_each(|imp| add_impl(db, file_id, res, imp));\n         self.attr_macro_invocs().for_each(|(ast_id, call_id)| {\n             let item = ast_id.with_value(ast_id.to_node(db.upcast()));\n             res[keys::ATTR_MACRO].insert(item, call_id);\n         });\n \n-        fn add_module_def(db: &dyn DefDatabase, map: &mut DynMap, item: ModuleDefId) {\n+        fn add_module_def(\n+            db: &dyn DefDatabase,\n+            file_id: HirFileId,\n+            map: &mut DynMap,\n+            item: ModuleDefId,\n+        ) {\n             match item {\n                 ModuleDefId::FunctionId(func) => {\n-                    let src = func.lookup(db).source(db);\n-                    map[keys::FUNCTION].insert(src, func)\n+                    let loc = func.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        map[keys::FUNCTION].insert(src, func)\n+                    }\n                 }\n                 ModuleDefId::ConstId(konst) => {\n-                    let src = konst.lookup(db).source(db);\n-                    map[keys::CONST].insert(src, konst)\n+                    let loc = konst.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        map[keys::CONST].insert(src, konst)\n+                    }\n                 }\n                 ModuleDefId::StaticId(statik) => {\n-                    let src = statik.lookup(db).source(db);\n-                    map[keys::STATIC].insert(src, statik)\n+                    let loc = statik.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        map[keys::STATIC].insert(src, statik)\n+                    }\n                 }\n                 ModuleDefId::TypeAliasId(ty) => {\n-                    let src = ty.lookup(db).source(db);\n-                    map[keys::TYPE_ALIAS].insert(src, ty)\n+                    let loc = ty.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        map[keys::TYPE_ALIAS].insert(src, ty)\n+                    }\n                 }\n                 ModuleDefId::TraitId(trait_) => {\n-                    let src = trait_.lookup(db).source(db);\n-                    map[keys::TRAIT].insert(src, trait_)\n+                    let loc = trait_.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        map[keys::TRAIT].insert(src, trait_)\n+                    }\n                 }\n                 ModuleDefId::AdtId(adt) => match adt {\n                     AdtId::StructId(strukt) => {\n-                        let src = strukt.lookup(db).source(db);\n-                        map[keys::STRUCT].insert(src, strukt)\n+                        let loc = strukt.lookup(db);\n+                        if loc.id.file_id() == file_id {\n+                            let src = loc.source(db);\n+                            map[keys::STRUCT].insert(src, strukt)\n+                        }\n                     }\n                     AdtId::UnionId(union_) => {\n-                        let src = union_.lookup(db).source(db);\n-                        map[keys::UNION].insert(src, union_)\n+                        let loc = union_.lookup(db);\n+                        if loc.id.file_id() == file_id {\n+                            let src = loc.source(db);\n+                            map[keys::UNION].insert(src, union_)\n+                        }\n                     }\n                     AdtId::EnumId(enum_) => {\n-                        let src = enum_.lookup(db).source(db);\n-                        map[keys::ENUM].insert(src, enum_)\n+                        let loc = enum_.lookup(db);\n+                        if loc.id.file_id() == file_id {\n+                            let src = loc.source(db);\n+                            map[keys::ENUM].insert(src, enum_)\n+                        }\n                     }\n                 },\n                 _ => (),\n             }\n         }\n-        fn add_impl(db: &dyn DefDatabase, map: &mut DynMap, imp: ImplId) {\n-            let src = imp.lookup(db).source(db);\n-            map[keys::IMPL].insert(src, imp)\n+        fn add_impl(db: &dyn DefDatabase, file_id: HirFileId, map: &mut DynMap, imp: ImplId) {\n+            let loc = imp.lookup(db);\n+            if loc.id.file_id() == file_id {\n+                let src = loc.source(db);\n+                map[keys::IMPL].insert(src, imp)\n+            }\n         }\n     }\n }\n \n impl ChildBySource for VariantId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, _: HirFileId, res: &mut DynMap) {\n         let arena_map = self.child_source(db);\n         let arena_map = arena_map.as_ref();\n+        let parent = *self;\n         for (local_id, source) in arena_map.value.iter() {\n-            let id = FieldId { parent: *self, local_id };\n-            match source {\n+            let id = FieldId { parent, local_id };\n+            match source.clone() {\n                 Either::Left(source) => {\n-                    res[keys::TUPLE_FIELD].insert(arena_map.with_value(source.clone()), id)\n+                    res[keys::TUPLE_FIELD].insert(arena_map.with_value(source), id)\n                 }\n                 Either::Right(source) => {\n-                    res[keys::RECORD_FIELD].insert(arena_map.with_value(source.clone()), id)\n+                    res[keys::RECORD_FIELD].insert(arena_map.with_value(source), id)\n                 }\n             }\n         }\n     }\n }\n \n impl ChildBySource for EnumId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, _: HirFileId, res: &mut DynMap) {\n         let arena_map = self.child_source(db);\n         let arena_map = arena_map.as_ref();\n         for (local_id, source) in arena_map.value.iter() {\n@@ -166,12 +218,12 @@ impl ChildBySource for EnumId {\n }\n \n impl ChildBySource for DefWithBodyId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, file_id: HirFileId, res: &mut DynMap) {\n         let body = db.body(*self);\n         for (_, def_map) in body.blocks(db) {\n             // All block expressions are merged into the same map, because they logically all add\n             // inner items to the containing `DefWithBodyId`.\n-            def_map[def_map.root()].scope.child_by_source_to(db, res);\n+            def_map[def_map.root()].scope.child_by_source_to(db, file_id, res);\n         }\n     }\n }"}, {"sha": "1e5cebcaca9b9cd1b8dc2fe47671687ff429317b", "filename": "crates/hir_def/src/generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c90ecc5c26fa1c0d6a60f3a9e46510370e1520be/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c90ecc5c26fa1c0d6a60f3a9e46510370e1520be/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fgenerics.rs?ref=c90ecc5c26fa1c0d6a60f3a9e46510370e1520be", "patch": "@@ -7,7 +7,7 @@ use base_db::FileId;\n use either::Either;\n use hir_expand::{\n     name::{name, AsName, Name},\n-    InFile,\n+    HirFileId, InFile,\n };\n use la_arena::{Arena, ArenaMap};\n use syntax::ast::{self, GenericParamsOwner, NameOwner, TypeBoundsOwner};\n@@ -438,7 +438,7 @@ impl HasChildSource<LocalConstParamId> for GenericDefId {\n }\n \n impl ChildBySource for GenericDefId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, _: HirFileId, res: &mut DynMap) {\n         let (_, sm) = GenericParams::new(db, *self);\n \n         let sm = sm.as_ref();"}]}