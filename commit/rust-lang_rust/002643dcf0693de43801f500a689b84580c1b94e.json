{"sha": "002643dcf0693de43801f500a689b84580c1b94e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwMjY0M2RjZjA2OTNkZTQzODAxZjUwMGE2ODliODQ1ODBjMWI5NGU=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-01T05:25:22Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-01T17:34:39Z"}, "message": "Remove librustuv\n\nThis commit removes the `librustuv` crate.\n\nSee the [runtime removal\nRFC](https://github.com/rust-lang/rfcs/pull/230) for more context.\n\nSee [green-rs](https://github.com/alexcrichton/green-rs/) for a possible\nmigration path if you wish to continue using green-threaded I/O. The\nlibrary provides its own I/O API surface.\n\n[breaking-change]", "tree": {"sha": "bae68570964335f477dbc0a40f6a7f91339eaf6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bae68570964335f477dbc0a40f6a7f91339eaf6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/002643dcf0693de43801f500a689b84580c1b94e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/002643dcf0693de43801f500a689b84580c1b94e", "html_url": "https://github.com/rust-lang/rust/commit/002643dcf0693de43801f500a689b84580c1b94e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/002643dcf0693de43801f500a689b84580c1b94e/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15966c3c1f99810ac81053769651776a67181dae", "url": "https://api.github.com/repos/rust-lang/rust/commits/15966c3c1f99810ac81053769651776a67181dae", "html_url": "https://github.com/rust-lang/rust/commit/15966c3c1f99810ac81053769651776a67181dae"}], "stats": {"total": 6470, "additions": 2, "deletions": 6468}, "files": [{"sha": "1da124fb563b5d5dc5416f7943840e2522318e94", "filename": "mk/crates.mk", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/002643dcf0693de43801f500a689b84580c1b94e/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/002643dcf0693de43801f500a689b84580c1b94e/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=002643dcf0693de43801f500a689b84580c1b94e", "patch": "@@ -49,7 +49,7 @@\n # automatically generated for all stage/host/target combinations.\n ################################################################################\n \n-TARGET_CRATES := libc std green rustuv native flate arena glob term semver \\\n+TARGET_CRATES := libc std green native flate arena glob term semver \\\n                  uuid serialize sync getopts collections num test time rand \\\n                  url log regex graphviz core rbml rlibc alloc debug rustrt \\\n                  unicode\n@@ -69,7 +69,6 @@ DEPS_std := core libc rand alloc collections rustrt sync unicode \\\n \tnative:rust_builtin native:backtrace\n DEPS_graphviz := std\n DEPS_green := std native:context_switch\n-DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n DEPS_syntax := std term serialize log fmt_macros debug arena libc\n DEPS_rustc := syntax flate arena serialize getopts rbml \\\n@@ -102,7 +101,7 @@ DEPS_regex := std\n DEPS_regex_macros = rustc syntax std regex\n DEPS_fmt_macros = std\n \n-TOOL_DEPS_compiletest := test green rustuv getopts\n+TOOL_DEPS_compiletest := test getopts\n TOOL_DEPS_rustdoc := rustdoc native\n TOOL_DEPS_rustc := rustc native\n TOOL_SOURCE_compiletest := $(S)src/compiletest/compiletest.rs"}, {"sha": "1bfa2641b4a05367c7f55fe74937c12f6b34b24e", "filename": "src/README.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/002643dcf0693de43801f500a689b84580c1b94e/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/002643dcf0693de43801f500a689b84580c1b94e/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=002643dcf0693de43801f500a689b84580c1b94e", "patch": "@@ -57,8 +57,6 @@ Source layout:\n | `test/auxiliary`    | - Dependencies of tests                                   |\n | ------------------- | --------------------------------------------------------- |\n | `librustdoc/`       | The Rust API documentation tool                           |\n-| `libuv/`            | The libuv submodule                                       |\n-| `librustuv/`        | Rust libuv support code                                   |\n | ------------------- | --------------------------------------------------------- |\n | `llvm/`             | The LLVM submodule                                        |\n | `rustllvm/`         | LLVM support code                                         |"}, {"sha": "b7475c8c077fc3b5f65eb327079f21c6ae9d7820", "filename": "src/librustuv/access.rs", "status": "removed", "additions": 0, "deletions": 173, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Faccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Faccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faccess.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,173 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// An exclusive access primitive\n-///\n-/// This primitive is used to gain exclusive access to read() and write() in uv.\n-/// It is assumed that all invocations of this struct happen on the same thread\n-/// (the uv event loop).\n-\n-use alloc::arc::Arc;\n-use std::mem;\n-use std::rt::local::Local;\n-use std::rt::task::{BlockedTask, Task};\n-use std::cell::UnsafeCell;\n-\n-use homing::HomingMissile;\n-\n-pub struct Access<T> {\n-    inner: Arc<UnsafeCell<Inner<T>>>,\n-}\n-\n-pub struct Guard<'a, T:'static> {\n-    access: &'a mut Access<T>,\n-    missile: Option<HomingMissile>,\n-}\n-\n-struct Inner<T> {\n-    queue: Vec<(BlockedTask, uint)>,\n-    held: bool,\n-    closed: bool,\n-    data: T,\n-}\n-\n-impl<T: Send> Access<T> {\n-    pub fn new(data: T) -> Access<T> {\n-        Access {\n-            inner: Arc::new(UnsafeCell::new(Inner {\n-                queue: vec![],\n-                held: false,\n-                closed: false,\n-                data: data,\n-            }))\n-        }\n-    }\n-\n-    pub fn grant<'a>(&'a mut self, token: uint,\n-                     missile: HomingMissile) -> Guard<'a, T> {\n-        // This unsafety is actually OK because the homing missile argument\n-        // guarantees that we're on the same event loop as all the other objects\n-        // attempting to get access granted.\n-        let inner = unsafe { &mut *self.inner.get() };\n-\n-        if inner.held {\n-            let t: Box<Task> = Local::take();\n-            t.deschedule(1, |task| {\n-                inner.queue.push((task, token));\n-                Ok(())\n-            });\n-            assert!(inner.held);\n-        } else {\n-            inner.held = true;\n-        }\n-\n-        Guard { access: self, missile: Some(missile) }\n-    }\n-\n-    pub fn unsafe_get(&self) -> *mut T {\n-        unsafe { &mut (*self.inner.get()).data  as *mut _ }\n-    }\n-\n-    // Safe version which requires proof that you are on the home scheduler.\n-    pub fn get_mut<'a>(&'a mut self, _missile: &HomingMissile) -> &'a mut T {\n-        unsafe { &mut *self.unsafe_get() }\n-    }\n-\n-    pub fn close(&self, _missile: &HomingMissile) {\n-        // This unsafety is OK because with a homing missile we're guaranteed to\n-        // be the only task looking at the `closed` flag (and are therefore\n-        // allowed to modify it). Additionally, no atomics are necessary because\n-        // everyone's running on the same thread and has already done the\n-        // necessary synchronization to be running on this thread.\n-        unsafe { (*self.inner.get()).closed = true; }\n-    }\n-\n-    // Dequeue a blocked task with a specified token. This is unsafe because it\n-    // is only safe to invoke while on the home event loop, and there is no\n-    // guarantee that this i being invoked on the home event loop.\n-    pub unsafe fn dequeue(&mut self, token: uint) -> Option<BlockedTask> {\n-        let inner = &mut *self.inner.get();\n-        match inner.queue.iter().position(|&(_, t)| t == token) {\n-            Some(i) => Some(inner.queue.remove(i).unwrap().val0()),\n-            None => None,\n-        }\n-    }\n-\n-    /// Test whether this access is closed, using a homing missile to prove\n-    /// that it's safe\n-    pub fn is_closed(&self, _missile: &HomingMissile) -> bool {\n-        unsafe { (*self.inner.get()).closed }\n-    }\n-}\n-\n-impl<T: Send> Clone for Access<T> {\n-    fn clone(&self) -> Access<T> {\n-        Access { inner: self.inner.clone() }\n-    }\n-}\n-\n-impl<'a, T: Send> Guard<'a, T> {\n-    pub fn is_closed(&self) -> bool {\n-        // See above for why this unsafety is ok, it just applies to the read\n-        // instead of the write.\n-        unsafe { (*self.access.inner.get()).closed }\n-    }\n-}\n-\n-impl<'a, T: Send> Deref<T> for Guard<'a, T> {\n-    fn deref<'a>(&'a self) -> &'a T {\n-        // A guard represents exclusive access to a piece of data, so it's safe\n-        // to hand out shared and mutable references\n-        unsafe { &(*self.access.inner.get()).data }\n-    }\n-}\n-\n-impl<'a, T: Send> DerefMut<T> for Guard<'a, T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n-        unsafe { &mut (*self.access.inner.get()).data }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<'a, T:Send> Drop for Guard<'a, T> {\n-    fn drop(&mut self) {\n-        // This guard's homing missile is still armed, so we're guaranteed to be\n-        // on the same I/O event loop, so this unsafety should be ok.\n-        assert!(self.missile.is_some());\n-        let inner: &mut Inner<T> = unsafe {\n-            mem::transmute(self.access.inner.get())\n-        };\n-\n-        match inner.queue.remove(0) {\n-            // Here we have found a task that was waiting for access, and we\n-            // current have the \"access lock\" we need to relinquish access to\n-            // this sleeping task.\n-            //\n-            // To do so, we first drop out homing missile and we then reawaken\n-            // the task. In reawakening the task, it will be immediately\n-            // scheduled on this scheduler. Because we might be woken up on some\n-            // other scheduler, we drop our homing missile before we reawaken\n-            // the task.\n-            Some((task, _)) => {\n-                drop(self.missile.take());\n-                task.reawaken();\n-            }\n-            None => { inner.held = false; }\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for Inner<T> {\n-    fn drop(&mut self) {\n-        assert!(!self.held);\n-        assert_eq!(self.queue.len(), 0);\n-    }\n-}"}, {"sha": "609ce016d38da4f1dfd99ae4b91c61b74920a7c6", "filename": "src/librustuv/addrinfo.rs", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,143 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::c_int;\n-use libc;\n-use std::mem;\n-use std::ptr::{null, null_mut};\n-use std::rt::task::BlockedTask;\n-use std::rt::rtio;\n-\n-use net;\n-use super::{Loop, UvError, Request, wait_until_woken_after, wakeup};\n-use uvll;\n-\n-pub struct Addrinfo {\n-    handle: *const libc::addrinfo,\n-}\n-\n-struct Ctx {\n-    slot: Option<BlockedTask>,\n-    status: c_int,\n-    addrinfo: Option<Addrinfo>,\n-}\n-\n-pub struct GetAddrInfoRequest;\n-\n-impl GetAddrInfoRequest {\n-    pub fn run(loop_: &Loop, node: Option<&str>, service: Option<&str>,\n-               hints: Option<rtio::AddrinfoHint>)\n-        -> Result<Vec<rtio::AddrinfoInfo>, UvError>\n-    {\n-        assert!(node.is_some() || service.is_some());\n-        let (_c_node, c_node_ptr) = match node {\n-            Some(n) => {\n-                let c_node = n.to_c_str();\n-                let c_node_ptr = c_node.as_ptr();\n-                (Some(c_node), c_node_ptr)\n-            }\n-            None => (None, null())\n-        };\n-\n-        let (_c_service, c_service_ptr) = match service {\n-            Some(s) => {\n-                let c_service = s.to_c_str();\n-                let c_service_ptr = c_service.as_ptr();\n-                (Some(c_service), c_service_ptr)\n-            }\n-            None => (None, null())\n-        };\n-\n-        let hint = hints.map(|hint| {\n-            libc::addrinfo {\n-                ai_flags: 0,\n-                ai_family: hint.family as c_int,\n-                ai_socktype: 0,\n-                ai_protocol: 0,\n-                ai_addrlen: 0,\n-                ai_canonname: null_mut(),\n-                ai_addr: null_mut(),\n-                ai_next: null_mut(),\n-            }\n-        });\n-        let hint_ptr = hint.as_ref().map_or(null(), |x| {\n-            x as *const libc::addrinfo\n-        });\n-        let mut req = Request::new(uvll::UV_GETADDRINFO);\n-\n-        return match unsafe {\n-            uvll::uv_getaddrinfo(loop_.handle, req.handle,\n-                                 getaddrinfo_cb, c_node_ptr, c_service_ptr,\n-                                 hint_ptr)\n-        } {\n-            0 => {\n-                req.defuse(); // uv callback now owns this request\n-                let mut cx = Ctx { slot: None, status: 0, addrinfo: None };\n-\n-                wait_until_woken_after(&mut cx.slot, loop_, || {\n-                    req.set_data(&mut cx);\n-                });\n-\n-                match cx.status {\n-                    0 => Ok(accum_addrinfo(cx.addrinfo.as_ref().unwrap())),\n-                    n => Err(UvError(n))\n-                }\n-            }\n-            n => Err(UvError(n))\n-        };\n-\n-\n-        extern fn getaddrinfo_cb(req: *mut uvll::uv_getaddrinfo_t,\n-                                 status: c_int,\n-                                 res: *const libc::addrinfo) {\n-            let req = Request::wrap(req);\n-            assert!(status != uvll::ECANCELED);\n-            let cx: &mut Ctx = unsafe { req.get_data() };\n-            cx.status = status;\n-            cx.addrinfo = Some(Addrinfo { handle: res });\n-\n-            wakeup(&mut cx.slot);\n-        }\n-    }\n-}\n-\n-impl Drop for Addrinfo {\n-    fn drop(&mut self) {\n-        unsafe { uvll::uv_freeaddrinfo(self.handle as *mut _) }\n-    }\n-}\n-\n-// Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n-pub fn accum_addrinfo(addr: &Addrinfo) -> Vec<rtio::AddrinfoInfo> {\n-    unsafe {\n-        let mut addr = addr.handle;\n-\n-        let mut addrs = Vec::new();\n-        loop {\n-            let rustaddr = net::sockaddr_to_addr(mem::transmute((*addr).ai_addr),\n-                                                 (*addr).ai_addrlen as uint);\n-\n-            addrs.push(rtio::AddrinfoInfo {\n-                address: rustaddr,\n-                family: (*addr).ai_family as uint,\n-                socktype: 0,\n-                protocol: 0,\n-                flags: 0,\n-            });\n-            if (*addr).ai_next.is_not_null() {\n-                addr = (*addr).ai_next as *const _;\n-            } else {\n-                break;\n-            }\n-        }\n-\n-        addrs\n-    }\n-}"}, {"sha": "8bed4cfb8114b590c800b9ba630928ed4f2694d8", "filename": "src/librustuv/async.rs", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,156 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use alloc::arc::Arc;\n-use std::mem;\n-use std::rt::exclusive::Exclusive;\n-use std::rt::rtio::{Callback, RemoteCallback};\n-\n-use uvll;\n-use super::{Loop, UvHandle};\n-\n-// The entire point of async is to call into a loop from other threads so it\n-// does not need to home.\n-pub struct AsyncWatcher {\n-    handle: *mut uvll::uv_async_t,\n-\n-    // A flag to tell the callback to exit, set from the dtor. This is\n-    // almost never contested - only in rare races with the dtor.\n-    exit_flag: Arc<Exclusive<bool>>,\n-}\n-\n-struct Payload {\n-    callback: Box<Callback + Send>,\n-    exit_flag: Arc<Exclusive<bool>>,\n-}\n-\n-impl AsyncWatcher {\n-    pub fn new(loop_: &mut Loop, cb: Box<Callback + Send>) -> AsyncWatcher {\n-        let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n-        assert_eq!(unsafe {\n-            uvll::uv_async_init(loop_.handle, handle, async_cb)\n-        }, 0);\n-        let flag = Arc::new(Exclusive::new(false));\n-        let payload = box Payload { callback: cb, exit_flag: flag.clone() };\n-        unsafe {\n-            let payload: *mut u8 = mem::transmute(payload);\n-            uvll::set_data_for_uv_handle(handle, payload);\n-        }\n-        return AsyncWatcher { handle: handle, exit_flag: flag, };\n-    }\n-}\n-\n-impl UvHandle<uvll::uv_async_t> for AsyncWatcher {\n-    fn uv_handle(&self) -> *mut uvll::uv_async_t { self.handle }\n-    unsafe fn from_uv_handle<'a>(_: &'a *mut uvll::uv_async_t) -> &'a mut AsyncWatcher {\n-        fail!(\"async watchers can't be built from their handles\");\n-    }\n-}\n-\n-extern fn async_cb(handle: *mut uvll::uv_async_t) {\n-    let payload: &mut Payload = unsafe {\n-        mem::transmute(uvll::get_data_for_uv_handle(handle))\n-    };\n-\n-    // The synchronization logic here is subtle. To review,\n-    // the uv async handle type promises that, after it is\n-    // triggered the remote callback is definitely called at\n-    // least once. UvRemoteCallback needs to maintain those\n-    // semantics while also shutting down cleanly from the\n-    // dtor. In our case that means that, when the\n-    // UvRemoteCallback dtor calls `async.send()`, here `f` is\n-    // always called later.\n-\n-    // In the dtor both the exit flag is set and the async\n-    // callback fired under a lock.  Here, before calling `f`,\n-    // we take the lock and check the flag. Because we are\n-    // checking the flag before calling `f`, and the flag is\n-    // set under the same lock as the send, then if the flag\n-    // is set then we're guaranteed to call `f` after the\n-    // final send.\n-\n-    // If the check was done after `f()` then there would be a\n-    // period between that call and the check where the dtor\n-    // could be called in the other thread, missing the final\n-    // callback while still destroying the handle.\n-\n-    let should_exit = unsafe { *payload.exit_flag.lock() };\n-\n-    payload.callback.call();\n-\n-    if should_exit {\n-        unsafe { uvll::uv_close(handle, close_cb) }\n-    }\n-}\n-\n-extern fn close_cb(handle: *mut uvll::uv_handle_t) {\n-    // drop the payload\n-    let _payload: Box<Payload> = unsafe {\n-        mem::transmute(uvll::get_data_for_uv_handle(handle))\n-    };\n-    // and then free the handle\n-    unsafe { uvll::free_handle(handle) }\n-}\n-\n-impl RemoteCallback for AsyncWatcher {\n-    fn fire(&mut self) {\n-        unsafe { uvll::uv_async_send(self.handle) }\n-    }\n-}\n-\n-impl Drop for AsyncWatcher {\n-    fn drop(&mut self) {\n-        let mut should_exit = unsafe { self.exit_flag.lock() };\n-        // NB: These two things need to happen atomically. Otherwise\n-        // the event handler could wake up due to a *previous*\n-        // signal and see the exit flag, destroying the handle\n-        // before the final send.\n-        *should_exit = true;\n-        unsafe { uvll::uv_async_send(self.handle) }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_remote {\n-    use std::rt::rtio::{Callback, RemoteCallback};\n-    use std::rt::thread::Thread;\n-\n-    use super::AsyncWatcher;\n-    use super::super::local_loop;\n-\n-    // Make sure that we can fire watchers in remote threads and that they\n-    // actually trigger what they say they will.\n-    #[test]\n-    fn smoke_test() {\n-        struct MyCallback(Option<Sender<int>>);\n-        impl Callback for MyCallback {\n-            fn call(&mut self) {\n-                // this can get called more than once, but we only want to send\n-                // once\n-                let MyCallback(ref mut s) = *self;\n-                if s.is_some() {\n-                    s.take().unwrap().send(1);\n-                }\n-            }\n-        }\n-\n-        let (tx, rx) = channel();\n-        let cb = box MyCallback(Some(tx));\n-        let watcher = AsyncWatcher::new(&mut local_loop().loop_, cb);\n-\n-        let thread = Thread::start(proc() {\n-            let mut watcher = watcher;\n-            watcher.fire();\n-        });\n-\n-        assert_eq!(rx.recv(), 1);\n-        thread.join();\n-    }\n-}"}, {"sha": "f42f42d2111601e28190a0c4de3ec4fa8df2d6fc", "filename": "src/librustuv/file.rs", "status": "removed", "additions": 0, "deletions": 581, "changes": 581, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,581 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::{c_int, c_char, c_void, ssize_t};\n-use libc;\n-use std::c_str::CString;\n-use std::c_str;\n-use std::mem;\n-use std::os;\n-use std::rt::rtio::{IoResult, IoError};\n-use std::rt::rtio;\n-use std::rt::task::BlockedTask;\n-\n-use homing::{HomingIO, HomeHandle};\n-use super::{Loop, UvError, uv_error_to_io_error, wait_until_woken_after, wakeup};\n-use uvio::UvIoFactory;\n-use uvll;\n-\n-pub struct FsRequest {\n-    req: *mut uvll::uv_fs_t,\n-    fired: bool,\n-}\n-\n-pub struct FileWatcher {\n-    loop_: Loop,\n-    fd: c_int,\n-    close: rtio::CloseBehavior,\n-    home: HomeHandle,\n-}\n-\n-impl FsRequest {\n-    pub fn open(io: &mut UvIoFactory, path: &CString, flags: int, mode: int)\n-        -> Result<FileWatcher, UvError>\n-    {\n-        execute(|req, cb| unsafe {\n-            uvll::uv_fs_open(io.uv_loop(),\n-                             req, path.as_ptr(), flags as c_int,\n-                             mode as c_int, cb)\n-        }).map(|req|\n-            FileWatcher::new(io, req.get_result() as c_int,\n-                             rtio::CloseSynchronously)\n-        )\n-    }\n-\n-    pub fn unlink(loop_: &Loop, path: &CString) -> Result<(), UvError> {\n-        execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_unlink(loop_.handle, req, path.as_ptr(),\n-                               cb)\n-        })\n-    }\n-\n-    pub fn lstat(loop_: &Loop, path: &CString)\n-        -> Result<rtio::FileStat, UvError>\n-    {\n-        execute(|req, cb| unsafe {\n-            uvll::uv_fs_lstat(loop_.handle, req, path.as_ptr(),\n-                              cb)\n-        }).map(|req| req.mkstat())\n-    }\n-\n-    pub fn stat(loop_: &Loop, path: &CString) -> Result<rtio::FileStat, UvError> {\n-        execute(|req, cb| unsafe {\n-            uvll::uv_fs_stat(loop_.handle, req, path.as_ptr(),\n-                             cb)\n-        }).map(|req| req.mkstat())\n-    }\n-\n-    pub fn fstat(loop_: &Loop, fd: c_int) -> Result<rtio::FileStat, UvError> {\n-        execute(|req, cb| unsafe {\n-            uvll::uv_fs_fstat(loop_.handle, req, fd, cb)\n-        }).map(|req| req.mkstat())\n-    }\n-\n-    pub fn write(loop_: &Loop, fd: c_int, buf: &[u8], offset: i64)\n-        -> Result<(), UvError>\n-    {\n-        // In libuv, uv_fs_write is basically just shelling out to a write()\n-        // syscall at some point, with very little fluff around it. This means\n-        // that write() could actually be a short write, so we need to be sure\n-        // to call it continuously if we get a short write back. This method is\n-        // expected to write the full data if it returns success.\n-        let mut written = 0;\n-        while written < buf.len() {\n-            let offset = if offset == -1 {\n-                offset\n-            } else {\n-                offset + written as i64\n-            };\n-            let uvbuf = uvll::uv_buf_t {\n-                base: buf.slice_from(written as uint).as_ptr() as *mut _,\n-                len: (buf.len() - written) as uvll::uv_buf_len_t,\n-            };\n-            match execute(|req, cb| unsafe {\n-                uvll::uv_fs_write(loop_.handle, req, fd, &uvbuf, 1, offset, cb)\n-            }).map(|req| req.get_result()) {\n-                Err(e) => return Err(e),\n-                Ok(n) => { written += n as uint; }\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn read(loop_: &Loop, fd: c_int, buf: &mut [u8], offset: i64)\n-        -> Result<int, UvError>\n-    {\n-        execute(|req, cb| unsafe {\n-            let mut uvbuf = uvll::uv_buf_t {\n-                base: buf.as_mut_ptr(),\n-                len: buf.len() as uvll::uv_buf_len_t,\n-            };\n-            uvll::uv_fs_read(loop_.handle, req, fd, &mut uvbuf, 1, offset, cb)\n-        }).map(|req| {\n-            req.get_result() as int\n-        })\n-    }\n-\n-    pub fn mkdir(loop_: &Loop, path: &CString, mode: c_int)\n-        -> Result<(), UvError>\n-    {\n-        execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_mkdir(loop_.handle, req, path.as_ptr(),\n-                              mode, cb)\n-        })\n-    }\n-\n-    pub fn rmdir(loop_: &Loop, path: &CString) -> Result<(), UvError> {\n-        execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_rmdir(loop_.handle, req, path.as_ptr(),\n-                              cb)\n-        })\n-    }\n-\n-    pub fn rename(loop_: &Loop, path: &CString, to: &CString)\n-        -> Result<(), UvError>\n-    {\n-        execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_rename(loop_.handle,\n-                               req,\n-                               path.as_ptr(),\n-                               to.as_ptr(),\n-                               cb)\n-        })\n-    }\n-\n-    pub fn chmod(loop_: &Loop, path: &CString, mode: c_int)\n-        -> Result<(), UvError>\n-    {\n-        execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_chmod(loop_.handle, req, path.as_ptr(),\n-                              mode, cb)\n-        })\n-    }\n-\n-    pub fn readdir(loop_: &Loop, path: &CString, flags: c_int)\n-        -> Result<Vec<CString>, UvError>\n-    {\n-        execute(|req, cb| unsafe {\n-            uvll::uv_fs_readdir(loop_.handle,\n-                                req, path.as_ptr(), flags, cb)\n-        }).map(|req| unsafe {\n-            let mut paths = vec!();\n-            let path = CString::new(path.as_ptr(), false);\n-            let parent = Path::new(path);\n-            let _ = c_str::from_c_multistring(req.get_ptr() as *const libc::c_char,\n-                                              Some(req.get_result() as uint),\n-                                              |rel| {\n-                let p = rel.as_bytes();\n-                paths.push(parent.join(p.slice_to(rel.len())).to_c_str());\n-            });\n-            paths\n-        })\n-    }\n-\n-    pub fn readlink(loop_: &Loop, path: &CString) -> Result<CString, UvError> {\n-        execute(|req, cb| unsafe {\n-            uvll::uv_fs_readlink(loop_.handle, req,\n-                                 path.as_ptr(), cb)\n-        }).map(|req| {\n-            // Be sure to clone the cstring so we get an independently owned\n-            // allocation to work with and return.\n-            unsafe {\n-                CString::new(req.get_ptr() as *const libc::c_char, false).clone()\n-            }\n-        })\n-    }\n-\n-    pub fn chown(loop_: &Loop, path: &CString, uid: int, gid: int)\n-        -> Result<(), UvError>\n-    {\n-        execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_chown(loop_.handle,\n-                              req, path.as_ptr(),\n-                              uid as uvll::uv_uid_t,\n-                              gid as uvll::uv_gid_t,\n-                              cb)\n-        })\n-    }\n-\n-    pub fn truncate(loop_: &Loop, file: c_int, offset: i64)\n-        -> Result<(), UvError>\n-    {\n-        execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_ftruncate(loop_.handle, req, file, offset, cb)\n-        })\n-    }\n-\n-    pub fn link(loop_: &Loop, src: &CString, dst: &CString)\n-        -> Result<(), UvError>\n-    {\n-        execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_link(loop_.handle, req,\n-                             src.as_ptr(),\n-                             dst.as_ptr(),\n-                             cb)\n-        })\n-    }\n-\n-    pub fn symlink(loop_: &Loop, src: &CString, dst: &CString)\n-        -> Result<(), UvError>\n-    {\n-        execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_symlink(loop_.handle, req,\n-                                src.as_ptr(),\n-                                dst.as_ptr(),\n-                                0, cb)\n-        })\n-    }\n-\n-    pub fn fsync(loop_: &Loop, fd: c_int) -> Result<(), UvError> {\n-        execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_fsync(loop_.handle, req, fd, cb)\n-        })\n-    }\n-\n-    pub fn datasync(loop_: &Loop, fd: c_int) -> Result<(), UvError> {\n-        execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_fdatasync(loop_.handle, req, fd, cb)\n-        })\n-    }\n-\n-    pub fn utime(loop_: &Loop, path: &CString, atime: u64, mtime: u64)\n-        -> Result<(), UvError>\n-    {\n-        // libuv takes seconds\n-        let atime = atime as libc::c_double / 1000.0;\n-        let mtime = mtime as libc::c_double / 1000.0;\n-        execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_utime(loop_.handle, req, path.as_ptr(),\n-                              atime, mtime, cb)\n-        })\n-    }\n-\n-    pub fn get_result(&self) -> ssize_t {\n-        unsafe { uvll::get_result_from_fs_req(self.req) }\n-    }\n-\n-    pub fn get_stat(&self) -> uvll::uv_stat_t {\n-        let mut stat = uvll::uv_stat_t::new();\n-        unsafe { uvll::populate_stat(self.req, &mut stat); }\n-        stat\n-    }\n-\n-    pub fn get_ptr(&self) -> *mut libc::c_void {\n-        unsafe { uvll::get_ptr_from_fs_req(self.req) }\n-    }\n-\n-    pub fn mkstat(&self) -> rtio::FileStat {\n-        let stat = self.get_stat();\n-        fn to_msec(stat: uvll::uv_timespec_t) -> u64 {\n-            // Be sure to cast to u64 first to prevent overflowing if the tv_sec\n-            // field is a 32-bit integer.\n-            (stat.tv_sec as u64) * 1000 + (stat.tv_nsec as u64) / 1000000\n-        }\n-        rtio::FileStat {\n-            size: stat.st_size as u64,\n-            kind: stat.st_mode as u64,\n-            perm: stat.st_mode as u64,\n-            created: to_msec(stat.st_birthtim),\n-            modified: to_msec(stat.st_mtim),\n-            accessed: to_msec(stat.st_atim),\n-            device: stat.st_dev as u64,\n-            inode: stat.st_ino as u64,\n-            rdev: stat.st_rdev as u64,\n-            nlink: stat.st_nlink as u64,\n-            uid: stat.st_uid as u64,\n-            gid: stat.st_gid as u64,\n-            blksize: stat.st_blksize as u64,\n-            blocks: stat.st_blocks as u64,\n-            flags: stat.st_flags as u64,\n-            gen: stat.st_gen as u64,\n-        }\n-    }\n-}\n-\n-impl Drop for FsRequest {\n-    fn drop(&mut self) {\n-        unsafe {\n-            if self.fired {\n-                uvll::uv_fs_req_cleanup(self.req);\n-            }\n-            uvll::free_req(self.req);\n-        }\n-    }\n-}\n-\n-fn execute(f: |*mut uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n-    -> Result<FsRequest, UvError>\n-{\n-    let mut req = FsRequest {\n-        fired: false,\n-        req: unsafe { uvll::malloc_req(uvll::UV_FS) }\n-    };\n-    return match f(req.req, fs_cb) {\n-        0 => {\n-            req.fired = true;\n-            let mut slot = None;\n-            let loop_ = unsafe { uvll::get_loop_from_fs_req(req.req) };\n-            wait_until_woken_after(&mut slot, &Loop::wrap(loop_), || {\n-                unsafe { uvll::set_data_for_req(req.req, &mut slot) }\n-            });\n-            match req.get_result() {\n-                n if n < 0 => Err(UvError(n as i32)),\n-                _ => Ok(req),\n-            }\n-        }\n-        n => Err(UvError(n))\n-    };\n-\n-    extern fn fs_cb(req: *mut uvll::uv_fs_t) {\n-        let slot: &mut Option<BlockedTask> = unsafe {\n-            mem::transmute(uvll::get_data_for_req(req))\n-        };\n-        wakeup(slot);\n-    }\n-}\n-\n-fn execute_nop(f: |*mut uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n-    -> Result<(), UvError> {\n-    execute(f).map(|_| {})\n-}\n-\n-impl HomingIO for FileWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n-}\n-\n-impl FileWatcher {\n-    pub fn new(io: &mut UvIoFactory, fd: c_int,\n-               close: rtio::CloseBehavior) -> FileWatcher {\n-        FileWatcher {\n-            loop_: Loop::wrap(io.uv_loop()),\n-            fd: fd,\n-            close: close,\n-            home: io.make_handle(),\n-        }\n-    }\n-\n-    fn base_read(&mut self, buf: &mut [u8], offset: i64) -> IoResult<int> {\n-        let _m = self.fire_homing_missile();\n-        let r = FsRequest::read(&self.loop_, self.fd, buf, offset);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn base_write(&mut self, buf: &[u8], offset: i64) -> IoResult<()> {\n-        let _m = self.fire_homing_missile();\n-        let r = FsRequest::write(&self.loop_, self.fd, buf, offset);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn seek_common(&self, pos: i64, whence: c_int) -> IoResult<u64>{\n-        match unsafe { libc::lseek(self.fd, pos as libc::off_t, whence) } {\n-            -1 => {\n-                Err(IoError {\n-                    code: os::errno() as uint,\n-                    extra: 0,\n-                    detail: None,\n-                })\n-            },\n-            n => Ok(n as u64)\n-        }\n-    }\n-}\n-\n-impl Drop for FileWatcher {\n-    fn drop(&mut self) {\n-        let _m = self.fire_homing_missile();\n-        match self.close {\n-            rtio::DontClose => {}\n-            rtio::CloseAsynchronously => {\n-                unsafe {\n-                    let req = uvll::malloc_req(uvll::UV_FS);\n-                    assert_eq!(uvll::uv_fs_close(self.loop_.handle, req,\n-                                                 self.fd, close_cb), 0);\n-                }\n-\n-                extern fn close_cb(req: *mut uvll::uv_fs_t) {\n-                    unsafe {\n-                        uvll::uv_fs_req_cleanup(req);\n-                        uvll::free_req(req);\n-                    }\n-                }\n-            }\n-            rtio::CloseSynchronously => {\n-                let _ = execute_nop(|req, cb| unsafe {\n-                    uvll::uv_fs_close(self.loop_.handle, req, self.fd, cb)\n-                });\n-            }\n-        }\n-    }\n-}\n-\n-impl rtio::RtioFileStream for FileWatcher {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n-        self.base_read(buf, -1)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.base_write(buf, -1)\n-    }\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n-        self.base_read(buf, offset as i64)\n-    }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> {\n-        self.base_write(buf, offset as i64)\n-    }\n-    fn seek(&mut self, pos: i64, whence: rtio::SeekStyle) -> IoResult<u64> {\n-        use libc::{SEEK_SET, SEEK_CUR, SEEK_END};\n-        let whence = match whence {\n-            rtio::SeekSet => SEEK_SET,\n-            rtio::SeekCur => SEEK_CUR,\n-            rtio::SeekEnd => SEEK_END\n-        };\n-        self.seek_common(pos, whence)\n-    }\n-    fn tell(&self) -> IoResult<u64> {\n-        use libc::SEEK_CUR;\n-\n-        self.seek_common(0, SEEK_CUR)\n-    }\n-    fn fsync(&mut self) -> IoResult<()> {\n-        let _m = self.fire_homing_missile();\n-        FsRequest::fsync(&self.loop_, self.fd).map_err(uv_error_to_io_error)\n-    }\n-    fn datasync(&mut self) -> IoResult<()> {\n-        let _m = self.fire_homing_missile();\n-        FsRequest::datasync(&self.loop_, self.fd).map_err(uv_error_to_io_error)\n-    }\n-    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n-        let _m = self.fire_homing_missile();\n-        let r = FsRequest::truncate(&self.loop_, self.fd, offset);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-\n-    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n-        let _m = self.fire_homing_missile();\n-        FsRequest::fstat(&self.loop_, self.fd).map_err(uv_error_to_io_error)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use libc::c_int;\n-    use libc::{O_CREAT, O_RDWR, O_RDONLY, S_IWUSR, S_IRUSR};\n-    use std::str;\n-    use super::FsRequest;\n-    use super::super::Loop;\n-    use super::super::local_loop;\n-\n-    fn l() -> &'static mut Loop { &mut local_loop().loop_ }\n-\n-    #[test]\n-    fn file_test_full_simple_sync() {\n-        let create_flags = O_RDWR | O_CREAT;\n-        let read_flags = O_RDONLY;\n-        let mode = S_IWUSR | S_IRUSR;\n-        let path_str = \"./tmp/file_full_simple_sync.txt\";\n-\n-        {\n-            // open/create\n-            let result = FsRequest::open(local_loop(), &path_str.to_c_str(),\n-                                         create_flags as int, mode as int);\n-            assert!(result.is_ok());\n-            let result = result.unwrap();\n-            let fd = result.fd;\n-\n-            // write\n-            let result = FsRequest::write(l(), fd, \"hello\".as_bytes(), -1);\n-            assert!(result.is_ok());\n-        }\n-\n-        {\n-            // re-open\n-            let result = FsRequest::open(local_loop(), &path_str.to_c_str(),\n-                                         read_flags as int, 0);\n-            assert!(result.is_ok());\n-            let result = result.unwrap();\n-            let fd = result.fd;\n-\n-            // read\n-            let mut read_mem = Vec::from_elem(1000, 0u8);\n-            let result = FsRequest::read(l(), fd, read_mem.as_mut_slice(), 0);\n-            assert!(result.is_ok());\n-\n-            let nread = result.unwrap();\n-            assert!(nread > 0);\n-            let read_str = str::from_utf8(read_mem.slice_to(nread as uint)).unwrap();\n-            assert_eq!(read_str, \"hello\");\n-        }\n-        // unlink\n-        let result = FsRequest::unlink(l(), &path_str.to_c_str());\n-        assert!(result.is_ok());\n-    }\n-\n-    #[test]\n-    fn file_test_stat() {\n-        let path = &\"./tmp/file_test_stat_simple\".to_c_str();\n-        let create_flags = (O_RDWR | O_CREAT) as int;\n-        let mode = (S_IWUSR | S_IRUSR) as int;\n-\n-        let result = FsRequest::open(local_loop(), path, create_flags, mode);\n-        assert!(result.is_ok());\n-        let file = result.unwrap();\n-\n-        let result = FsRequest::write(l(), file.fd, \"hello\".as_bytes(), 0);\n-        assert!(result.is_ok());\n-\n-        let result = FsRequest::stat(l(), path);\n-        assert!(result.is_ok());\n-        assert_eq!(result.unwrap().size, 5);\n-\n-        let result = FsRequest::fstat(l(), file.fd);\n-        assert!(result.is_ok());\n-        assert_eq!(result.unwrap().size, 5);\n-\n-        fn free<T>(_: T) {}\n-        free(file);\n-\n-        let result = FsRequest::unlink(l(), path);\n-        assert!(result.is_ok());\n-    }\n-\n-    #[test]\n-    fn file_test_mk_rm_dir() {\n-        let path = &\"./tmp/mk_rm_dir\".to_c_str();\n-        let mode = S_IWUSR | S_IRUSR;\n-\n-        let result = FsRequest::mkdir(l(), path, mode as c_int);\n-        assert!(result.is_ok());\n-\n-        let result = FsRequest::rmdir(l(), path);\n-        assert!(result.is_ok());\n-\n-        let result = FsRequest::stat(l(), path);\n-        assert!(result.is_err());\n-    }\n-\n-    #[test]\n-    fn file_test_mkdir_chokes_on_double_create() {\n-        let path = &\"./tmp/double_create_dir\".to_c_str();\n-        let mode = S_IWUSR | S_IRUSR;\n-\n-        let result = FsRequest::stat(l(), path);\n-        assert!(result.is_err(), \"{:?}\", result);\n-        let result = FsRequest::mkdir(l(), path, mode as c_int);\n-        assert!(result.is_ok(), \"{:?}\", result);\n-        let result = FsRequest::mkdir(l(), path, mode as c_int);\n-        assert!(result.is_err(), \"{:?}\", result);\n-        let result = FsRequest::rmdir(l(), path);\n-        assert!(result.is_ok(), \"{:?}\", result);\n-    }\n-\n-    #[test]\n-    fn file_test_rmdir_chokes_on_nonexistant_path() {\n-        let path = &\"./tmp/never_existed_dir\".to_c_str();\n-        let result = FsRequest::rmdir(l(), path);\n-        assert!(result.is_err());\n-    }\n-}"}, {"sha": "55d9811ccadc05a65a0a770c4bb3f264521bc4d1", "filename": "src/librustuv/homing.rs", "status": "removed", "additions": 0, "deletions": 214, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,214 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Homing I/O implementation\n-//!\n-//! In libuv, whenever a handle is created on an I/O loop it is illegal to use\n-//! that handle outside of that I/O loop. We use libuv I/O with our green\n-//! scheduler, and each green scheduler corresponds to a different I/O loop on a\n-//! different OS thread. Green tasks are also free to roam among schedulers,\n-//! which implies that it is possible to create an I/O handle on one event loop\n-//! and then attempt to use it on another.\n-//!\n-//! In order to solve this problem, this module implements the notion of a\n-//! \"homing operation\" which will transplant a task from its currently running\n-//! scheduler back onto the original I/O loop. This is accomplished entirely at\n-//! the librustuv layer with very little cooperation from the scheduler (which\n-//! we don't even know exists technically).\n-//!\n-//! These homing operations are completed by first realizing that we're on the\n-//! wrong I/O loop, then descheduling ourselves, sending ourselves to the\n-//! correct I/O loop, and then waking up the I/O loop in order to process its\n-//! local queue of tasks which need to run.\n-//!\n-//! This enqueueing is done with a concurrent queue from libstd, and the\n-//! signalling is achieved with an async handle.\n-\n-#![allow(dead_code)]\n-\n-use std::mem;\n-use std::rt::local::Local;\n-use std::rt::rtio::LocalIo;\n-use std::rt::task::{Task, BlockedTask};\n-\n-use ForbidUnwind;\n-use queue::{Queue, QueuePool};\n-\n-/// A handle to a remote libuv event loop. This handle will keep the event loop\n-/// alive while active in order to ensure that a homing operation can always be\n-/// completed.\n-///\n-/// Handles are clone-able in order to derive new handles from existing handles\n-/// (very useful for when accepting a socket from a server).\n-pub struct HomeHandle {\n-    queue: Queue,\n-    id: uint,\n-}\n-\n-impl HomeHandle {\n-    pub fn new(id: uint, pool: &mut QueuePool) -> HomeHandle {\n-        HomeHandle { queue: pool.queue(), id: id }\n-    }\n-\n-    fn send(&mut self, task: BlockedTask) {\n-        self.queue.push(task);\n-    }\n-}\n-\n-impl Clone for HomeHandle {\n-    fn clone(&self) -> HomeHandle {\n-        HomeHandle {\n-            queue: self.queue.clone(),\n-            id: self.id,\n-        }\n-    }\n-}\n-\n-pub fn local_id() -> uint {\n-    use std::raw::TraitObject;\n-\n-    let mut io = match LocalIo::borrow() {\n-        Some(io) => io, None => return 0,\n-    };\n-    let io = io.get();\n-    unsafe {\n-        let obj: TraitObject = mem::transmute(io);\n-        return mem::transmute(obj.data);\n-    }\n-}\n-\n-#[doc(hidden)]\n-pub trait HomingIO {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle;\n-\n-    /// This function will move tasks to run on their home I/O scheduler. Note\n-    /// that this function does *not* pin the task to the I/O scheduler, but\n-    /// rather it simply moves it to running on the I/O scheduler.\n-    fn go_to_io_home(&mut self) -> uint {\n-        let _f = ForbidUnwind::new(\"going home\");\n-\n-        let cur_loop_id = local_id();\n-        let destination = self.home().id;\n-\n-        // Try at all costs to avoid the homing operation because it is quite\n-        // expensive. Hence, we only deschedule/send if we're not on the correct\n-        // event loop. If we're already on the home event loop, then we're good\n-        // to go (remember we have no preemption, so we're guaranteed to stay on\n-        // this event loop as long as we avoid the scheduler).\n-        if cur_loop_id != destination {\n-            let cur_task: Box<Task> = Local::take();\n-            cur_task.deschedule(1, |task| {\n-                self.home().send(task);\n-                Ok(())\n-            });\n-\n-            // Once we wake up, assert that we're in the right location\n-            assert_eq!(local_id(), destination);\n-        }\n-\n-        return destination;\n-    }\n-\n-    /// Fires a single homing missile, returning another missile targeted back\n-    /// at the original home of this task. In other words, this function will\n-    /// move the local task to its I/O scheduler and then return an RAII wrapper\n-    /// which will return the task home.\n-    fn fire_homing_missile(&mut self) -> HomingMissile {\n-        HomingMissile { io_home: self.go_to_io_home() }\n-    }\n-}\n-\n-/// After a homing operation has been completed, this will return the current\n-/// task back to its appropriate home (if applicable). The field is used to\n-/// assert that we are where we think we are.\n-pub struct HomingMissile {\n-    io_home: uint,\n-}\n-\n-impl HomingMissile {\n-    /// Check at runtime that the task has *not* transplanted itself to a\n-    /// different I/O loop while executing.\n-    pub fn check(&self, msg: &'static str) {\n-        assert!(local_id() == self.io_home, \"{}\", msg);\n-    }\n-}\n-\n-impl Drop for HomingMissile {\n-    fn drop(&mut self) {\n-        let _f = ForbidUnwind::new(\"leaving home\");\n-\n-        // It would truly be a sad day if we had moved off the home I/O\n-        // scheduler while we were doing I/O.\n-        self.check(\"task moved away from the home scheduler\");\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use green::sched;\n-    use green::{SchedPool, PoolConfig};\n-    use std::rt::rtio::RtioUdpSocket;\n-    use std::rt::task::TaskOpts;\n-\n-    use net::UdpWatcher;\n-    use super::super::local_loop;\n-\n-    // On one thread, create a udp socket. Then send that socket to another\n-    // thread and destroy the socket on the remote thread. This should make sure\n-    // that homing kicks in for the socket to go back home to the original\n-    // thread, close itself, and then come back to the last thread.\n-    #[test]\n-    fn test_homing_closes_correctly() {\n-        let (tx, rx) = channel();\n-        let mut pool = SchedPool::new(PoolConfig {\n-            threads: 1,\n-            event_loop_factory: ::event_loop,\n-        });\n-\n-        pool.spawn(TaskOpts::new(), proc() {\n-            let listener = UdpWatcher::bind(local_loop(), ::next_test_ip4());\n-            tx.send(listener.unwrap());\n-        });\n-\n-        let task = pool.task(TaskOpts::new(), proc() {\n-            drop(rx.recv());\n-        });\n-        pool.spawn_sched().send(sched::TaskFromFriend(task));\n-\n-        pool.shutdown();\n-    }\n-\n-    #[test]\n-    fn test_homing_read() {\n-        let (tx, rx) = channel();\n-        let mut pool = SchedPool::new(PoolConfig {\n-            threads: 1,\n-            event_loop_factory: ::event_loop,\n-        });\n-\n-        pool.spawn(TaskOpts::new(), proc() {\n-            let addr1 = ::next_test_ip4();\n-            let addr2 = ::next_test_ip4();\n-            let listener = UdpWatcher::bind(local_loop(), addr2);\n-            tx.send((listener.unwrap(), addr1));\n-            let mut listener = UdpWatcher::bind(local_loop(), addr1).unwrap();\n-            listener.send_to([1, 2, 3, 4], addr2).ok().unwrap();\n-        });\n-\n-        let task = pool.task(TaskOpts::new(), proc() {\n-            let (mut watcher, addr) = rx.recv();\n-            let mut buf = [0, ..10];\n-            assert!(watcher.recv_from(buf).ok().unwrap() == (4, addr));\n-        });\n-        pool.spawn_sched().send(sched::TaskFromFriend(task));\n-\n-        pool.shutdown();\n-    }\n-}"}, {"sha": "7b9a2fcf4446779af43fad88ec92f87217afc9b3", "filename": "src/librustuv/idle.rs", "status": "removed", "additions": 0, "deletions": 206, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,206 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::c_void;\n-use std::mem;\n-\n-use uvll;\n-use super::{Loop, UvHandle};\n-use std::rt::rtio::{Callback, PausableIdleCallback};\n-\n-pub struct IdleWatcher {\n-    handle: *mut uvll::uv_idle_t,\n-    idle_flag: bool,\n-    callback: Box<Callback + Send>,\n-}\n-\n-impl IdleWatcher {\n-    pub fn new(loop_: &mut Loop, cb: Box<Callback + Send>) -> Box<IdleWatcher> {\n-        let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n-        assert_eq!(unsafe {\n-            uvll::uv_idle_init(loop_.handle, handle)\n-        }, 0);\n-        let me = box IdleWatcher {\n-            handle: handle,\n-            idle_flag: false,\n-            callback: cb,\n-        };\n-        return me.install();\n-    }\n-\n-    pub fn onetime(loop_: &mut Loop, f: proc()) {\n-        let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n-        unsafe {\n-            assert_eq!(uvll::uv_idle_init(loop_.handle, handle), 0);\n-            let data: *mut c_void = mem::transmute(box f);\n-            uvll::set_data_for_uv_handle(handle, data);\n-            assert_eq!(uvll::uv_idle_start(handle, onetime_cb), 0)\n-        }\n-\n-        extern fn onetime_cb(handle: *mut uvll::uv_idle_t) {\n-            unsafe {\n-                let data = uvll::get_data_for_uv_handle(handle);\n-                let f: Box<proc()> = mem::transmute(data);\n-                (*f)();\n-                assert_eq!(uvll::uv_idle_stop(handle), 0);\n-                uvll::uv_close(handle, close_cb);\n-            }\n-        }\n-\n-        extern fn close_cb(handle: *mut uvll::uv_handle_t) {\n-            unsafe { uvll::free_handle(handle) }\n-        }\n-    }\n-}\n-\n-impl PausableIdleCallback for IdleWatcher {\n-    fn pause(&mut self) {\n-        if self.idle_flag == true {\n-            assert_eq!(unsafe {uvll::uv_idle_stop(self.handle) }, 0);\n-            self.idle_flag = false;\n-        }\n-    }\n-    fn resume(&mut self) {\n-        if self.idle_flag == false {\n-            assert_eq!(unsafe { uvll::uv_idle_start(self.handle, idle_cb) }, 0)\n-            self.idle_flag = true;\n-        }\n-    }\n-}\n-\n-impl UvHandle<uvll::uv_idle_t> for IdleWatcher {\n-    fn uv_handle(&self) -> *mut uvll::uv_idle_t { self.handle }\n-}\n-\n-extern fn idle_cb(handle: *mut uvll::uv_idle_t) {\n-    let idle: &mut IdleWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n-    idle.callback.call();\n-}\n-\n-impl Drop for IdleWatcher {\n-    fn drop(&mut self) {\n-        self.pause();\n-        self.close_async_();\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use std::mem;\n-    use std::cell::RefCell;\n-    use std::rc::Rc;\n-    use std::rt::rtio::{Callback, PausableIdleCallback};\n-    use std::rt::task::{BlockedTask, Task};\n-    use std::rt::local::Local;\n-    use super::IdleWatcher;\n-    use super::super::local_loop;\n-\n-    type Chan = Rc<RefCell<(Option<BlockedTask>, uint)>>;\n-\n-    struct MyCallback(Rc<RefCell<(Option<BlockedTask>, uint)>>, uint);\n-    impl Callback for MyCallback {\n-        fn call(&mut self) {\n-            let task = match *self {\n-                MyCallback(ref rc, n) => {\n-                    match *rc.borrow_mut().deref_mut() {\n-                        (ref mut task, ref mut val) => {\n-                            *val = n;\n-                            match task.take() {\n-                                Some(t) => t,\n-                                None => return\n-                            }\n-                        }\n-                    }\n-                }\n-            };\n-            let _ = task.wake().map(|t| t.reawaken());\n-        }\n-    }\n-\n-    fn mk(v: uint) -> (Box<IdleWatcher>, Chan) {\n-        let rc = Rc::new(RefCell::new((None, 0)));\n-        let cb = box MyCallback(rc.clone(), v);\n-        let cb = cb as Box<Callback>;\n-        let cb = unsafe { mem::transmute(cb) };\n-        (IdleWatcher::new(&mut local_loop().loop_, cb), rc)\n-    }\n-\n-    fn sleep(chan: &Chan) -> uint {\n-        let task: Box<Task> = Local::take();\n-        task.deschedule(1, |task| {\n-            match *chan.borrow_mut().deref_mut() {\n-                (ref mut slot, _) => {\n-                    assert!(slot.is_none());\n-                    *slot = Some(task);\n-                }\n-            }\n-            Ok(())\n-        });\n-\n-        match *chan.borrow() { (_, n) => n }\n-    }\n-\n-    #[test]\n-    fn not_used() {\n-        let (_idle, _chan) = mk(1);\n-    }\n-\n-    #[test]\n-    fn smoke_test() {\n-        let (mut idle, chan) = mk(1);\n-        idle.resume();\n-        assert_eq!(sleep(&chan), 1);\n-    }\n-\n-    #[test] #[should_fail]\n-    fn smoke_fail() {\n-        // By default, the test harness is capturing our stderr output through a\n-        // channel. This means that when we start failing and \"print\" our error\n-        // message, we could be switched to running on another test. The\n-        // IdleWatcher assumes that we're already running on the same task, so\n-        // it can cause serious problems and internal race conditions.\n-        //\n-        // To fix this bug, we just set our stderr to a null writer which will\n-        // never reschedule us, so we're guaranteed to stay on the same\n-        // task/event loop.\n-        use std::io;\n-        drop(io::stdio::set_stderr(box io::util::NullWriter));\n-\n-        let (mut idle, _chan) = mk(1);\n-        idle.resume();\n-        fail!();\n-    }\n-\n-    #[test]\n-    fn fun_combinations_of_methods() {\n-        let (mut idle, chan) = mk(1);\n-        idle.resume();\n-        assert_eq!(sleep(&chan), 1);\n-        idle.pause();\n-        idle.resume();\n-        idle.resume();\n-        assert_eq!(sleep(&chan), 1);\n-        idle.pause();\n-        idle.pause();\n-        idle.resume();\n-        assert_eq!(sleep(&chan), 1);\n-    }\n-\n-    #[test]\n-    fn pause_pauses() {\n-        let (mut idle1, chan1) = mk(1);\n-        let (mut idle2, chan2) = mk(2);\n-        idle2.resume();\n-        assert_eq!(sleep(&chan2), 2);\n-        idle2.pause();\n-        idle1.resume();\n-        assert_eq!(sleep(&chan1), 1);\n-    }\n-}"}, {"sha": "44cfafe30749865a317a9fb2befe2cee439279c7", "filename": "src/librustuv/lib.rs", "status": "removed", "additions": 0, "deletions": 536, "changes": 536, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,536 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Bindings to libuv, along with the default implementation of `std::rt::rtio`.\n-\n-UV types consist of the event loop (Loop), Watchers, Requests and\n-Callbacks.\n-\n-Watchers and Requests encapsulate pointers to uv *handles*, which have\n-subtyping relationships with each other.  This subtyping is reflected\n-in the bindings with explicit or implicit coercions. For example, an\n-upcast from TcpWatcher to StreamWatcher is done with\n-`tcp_watcher.as_stream()`. In other cases a callback on a specific\n-type of watcher will be passed a watcher of a supertype.\n-\n-Currently all use of Request types (connect/write requests) are\n-encapsulated in the bindings and don't need to be dealt with by the\n-caller.\n-\n-# Safety note\n-\n-Due to the complex lifecycle of uv handles, as well as compiler bugs,\n-this module is not memory safe and requires explicit memory management,\n-via `close` and `delete` methods.\n-\n-*/\n-\n-#![crate_name = \"rustuv\"]\n-#![experimental]\n-#![license = \"MIT/ASL2\"]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/master/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-\n-#![feature(macro_rules, unsafe_destructor)]\n-#![deny(unused_result, unused_must_use)]\n-\n-#![reexport_test_harness_main = \"test_main\"]\n-\n-#[cfg(test)] extern crate green;\n-#[cfg(test)] extern crate debug;\n-#[cfg(test)] extern crate \"rustuv\" as realrustuv;\n-extern crate libc;\n-extern crate alloc;\n-\n-use libc::{c_int, c_void};\n-use std::fmt;\n-use std::mem;\n-use std::ptr;\n-use std::string;\n-use std::rt::local::Local;\n-use std::rt::rtio;\n-use std::rt::rtio::{IoResult, IoError};\n-use std::rt::task::{BlockedTask, Task};\n-use std::task;\n-\n-pub use self::async::AsyncWatcher;\n-pub use self::file::{FsRequest, FileWatcher};\n-pub use self::idle::IdleWatcher;\n-pub use self::net::{TcpWatcher, TcpListener, TcpAcceptor, UdpWatcher};\n-pub use self::pipe::{PipeWatcher, PipeListener, PipeAcceptor};\n-pub use self::process::Process;\n-pub use self::signal::SignalWatcher;\n-pub use self::timer::TimerWatcher;\n-pub use self::tty::TtyWatcher;\n-\n-// Run tests with libgreen instead of libnative.\n-#[cfg(test)] #[start]\n-fn start(argc: int, argv: *const *const u8) -> int {\n-    green::start(argc, argv, event_loop, test_main)\n-}\n-\n-mod macros;\n-\n-mod access;\n-mod timeout;\n-mod homing;\n-mod queue;\n-mod rc;\n-\n-pub mod uvio;\n-pub mod uvll;\n-\n-pub mod file;\n-pub mod net;\n-pub mod idle;\n-pub mod timer;\n-pub mod async;\n-pub mod addrinfo;\n-pub mod process;\n-pub mod pipe;\n-pub mod tty;\n-pub mod signal;\n-pub mod stream;\n-\n-/// Creates a new event loop which is powered by libuv\n-///\n-/// This function is used in tandem with libgreen's `PoolConfig` type as a value\n-/// for the `event_loop_factory` field. Using this function as the event loop\n-/// factory will power programs with libuv and enable green threading.\n-///\n-/// # Example\n-///\n-/// ```\n-/// extern crate rustuv;\n-/// extern crate green;\n-///\n-/// #[start]\n-/// fn start(argc: int, argv: *const *const u8) -> int {\n-///     green::start(argc, argv, rustuv::event_loop, main)\n-/// }\n-///\n-/// fn main() {\n-///     // this code is running inside of a green task powered by libuv\n-/// }\n-/// ```\n-pub fn event_loop() -> Box<rtio::EventLoop + Send> {\n-    box uvio::UvEventLoop::new() as Box<rtio::EventLoop + Send>\n-}\n-\n-/// A type that wraps a uv handle\n-pub trait UvHandle<T> {\n-    fn uv_handle(&self) -> *mut T;\n-\n-    fn uv_loop(&self) -> Loop {\n-        Loop::wrap(unsafe { uvll::get_loop_for_uv_handle(self.uv_handle()) })\n-    }\n-\n-    // FIXME(#8888) dummy self\n-    fn alloc(_: Option<Self>, ty: uvll::uv_handle_type) -> *mut T {\n-        unsafe {\n-            let handle = uvll::malloc_handle(ty);\n-            assert!(!handle.is_null());\n-            handle as *mut T\n-        }\n-    }\n-\n-    unsafe fn from_uv_handle<'a>(h: &'a *mut T) -> &'a mut Self {\n-        mem::transmute(uvll::get_data_for_uv_handle(*h))\n-    }\n-\n-    fn install(self: Box<Self>) -> Box<Self> {\n-        unsafe {\n-            let myptr = mem::transmute::<&Box<Self>, &*mut u8>(&self);\n-            uvll::set_data_for_uv_handle(self.uv_handle(), *myptr);\n-        }\n-        self\n-    }\n-\n-    fn close_async_(&mut self) {\n-        // we used malloc to allocate all handles, so we must always have at\n-        // least a callback to free all the handles we allocated.\n-        extern fn close_cb(handle: *mut uvll::uv_handle_t) {\n-            unsafe { uvll::free_handle(handle) }\n-        }\n-\n-        unsafe {\n-            uvll::set_data_for_uv_handle(self.uv_handle(), ptr::null_mut::<()>());\n-            uvll::uv_close(self.uv_handle() as *mut uvll::uv_handle_t, close_cb)\n-        }\n-    }\n-\n-    fn close(&mut self) {\n-        let mut slot = None;\n-\n-        unsafe {\n-            uvll::uv_close(self.uv_handle() as *mut uvll::uv_handle_t, close_cb);\n-            uvll::set_data_for_uv_handle(self.uv_handle(),\n-                                         ptr::null_mut::<()>());\n-\n-            wait_until_woken_after(&mut slot, &self.uv_loop(), || {\n-                uvll::set_data_for_uv_handle(self.uv_handle(), &mut slot);\n-            })\n-        }\n-\n-        extern fn close_cb(handle: *mut uvll::uv_handle_t) {\n-            unsafe {\n-                let data = uvll::get_data_for_uv_handle(handle);\n-                uvll::free_handle(handle);\n-                if data == ptr::null_mut() { return }\n-                let slot: &mut Option<BlockedTask> = mem::transmute(data);\n-                wakeup(slot);\n-            }\n-        }\n-    }\n-}\n-\n-pub struct ForbidSwitch {\n-    msg: &'static str,\n-    io: uint,\n-}\n-\n-impl ForbidSwitch {\n-    fn new(s: &'static str) -> ForbidSwitch {\n-        ForbidSwitch {\n-            msg: s,\n-            io: homing::local_id(),\n-        }\n-    }\n-}\n-\n-impl Drop for ForbidSwitch {\n-    fn drop(&mut self) {\n-        assert!(self.io == homing::local_id(),\n-                \"didn't want a scheduler switch: {}\",\n-                self.msg);\n-    }\n-}\n-\n-pub struct ForbidUnwind {\n-    msg: &'static str,\n-    failing_before: bool,\n-}\n-\n-impl ForbidUnwind {\n-    fn new(s: &'static str) -> ForbidUnwind {\n-        ForbidUnwind {\n-            msg: s, failing_before: task::failing(),\n-        }\n-    }\n-}\n-\n-impl Drop for ForbidUnwind {\n-    fn drop(&mut self) {\n-        assert!(self.failing_before == task::failing(),\n-                \"didn't want an unwind during: {}\", self.msg);\n-    }\n-}\n-\n-fn wait_until_woken_after(slot: *mut Option<BlockedTask>,\n-                          loop_: &Loop,\n-                          f: ||) {\n-    let _f = ForbidUnwind::new(\"wait_until_woken_after\");\n-    unsafe {\n-        assert!((*slot).is_none());\n-        let task: Box<Task> = Local::take();\n-        loop_.modify_blockers(1);\n-        task.deschedule(1, |task| {\n-            *slot = Some(task);\n-            f();\n-            Ok(())\n-        });\n-        loop_.modify_blockers(-1);\n-    }\n-}\n-\n-fn wakeup(slot: &mut Option<BlockedTask>) {\n-    assert!(slot.is_some());\n-    let _ = slot.take().unwrap().wake().map(|t| t.reawaken());\n-}\n-\n-pub struct Request {\n-    pub handle: *mut uvll::uv_req_t,\n-    defused: bool,\n-}\n-\n-impl Request {\n-    pub fn new(ty: uvll::uv_req_type) -> Request {\n-        unsafe {\n-            let handle = uvll::malloc_req(ty);\n-            uvll::set_data_for_req(handle, ptr::null_mut::<()>());\n-            Request::wrap(handle)\n-        }\n-    }\n-\n-    pub fn wrap(handle: *mut uvll::uv_req_t) -> Request {\n-        Request { handle: handle, defused: false }\n-    }\n-\n-    pub fn set_data<T>(&self, t: *mut T) {\n-        unsafe { uvll::set_data_for_req(self.handle, t) }\n-    }\n-\n-    pub unsafe fn get_data<T>(&self) -> &'static mut T {\n-        let data = uvll::get_data_for_req(self.handle);\n-        assert!(data != ptr::null_mut());\n-        mem::transmute(data)\n-    }\n-\n-    // This function should be used when the request handle has been given to an\n-    // underlying uv function, and the uv function has succeeded. This means\n-    // that uv will at some point invoke the callback, and in the meantime we\n-    // can't deallocate the handle because libuv could be using it.\n-    //\n-    // This is still a problem in blocking situations due to linked failure. In\n-    // the connection callback the handle should be re-wrapped with the `wrap`\n-    // function to ensure its destruction.\n-    pub fn defuse(&mut self) {\n-        self.defused = true;\n-    }\n-}\n-\n-impl Drop for Request {\n-    fn drop(&mut self) {\n-        if !self.defused {\n-            unsafe { uvll::free_req(self.handle) }\n-        }\n-    }\n-}\n-\n-/// FIXME: Loop(*handle) is buggy with destructors. Normal structs\n-/// with dtors may not be destructured, but tuple structs can,\n-/// but the results are not correct.\n-pub struct Loop {\n-    handle: *mut uvll::uv_loop_t\n-}\n-\n-impl Loop {\n-    pub fn new() -> Loop {\n-        let handle = unsafe { uvll::loop_new() };\n-        assert!(handle.is_not_null());\n-        unsafe { uvll::set_data_for_uv_loop(handle, 0 as *mut c_void) }\n-        Loop::wrap(handle)\n-    }\n-\n-    pub fn wrap(handle: *mut uvll::uv_loop_t) -> Loop { Loop { handle: handle } }\n-\n-    pub fn run(&mut self) {\n-        assert_eq!(unsafe { uvll::uv_run(self.handle, uvll::RUN_DEFAULT) }, 0);\n-    }\n-\n-    pub fn close(&mut self) {\n-        unsafe { uvll::uv_loop_delete(self.handle) };\n-    }\n-\n-    // The 'data' field of the uv_loop_t is used to count the number of tasks\n-    // that are currently blocked waiting for I/O to complete.\n-    fn modify_blockers(&self, amt: uint) {\n-        unsafe {\n-            let cur = uvll::get_data_for_uv_loop(self.handle) as uint;\n-            uvll::set_data_for_uv_loop(self.handle, (cur + amt) as *mut c_void)\n-        }\n-    }\n-\n-    fn get_blockers(&self) -> uint {\n-        unsafe { uvll::get_data_for_uv_loop(self.handle) as uint }\n-    }\n-}\n-\n-// FIXME: Need to define the error constants like EOF so they can be\n-// compared to the UvError type\n-\n-pub struct UvError(c_int);\n-\n-impl UvError {\n-    pub fn name(&self) -> String {\n-        unsafe {\n-            let inner = match self { &UvError(a) => a };\n-            let name_str = uvll::uv_err_name(inner);\n-            assert!(name_str.is_not_null());\n-            string::raw::from_buf(name_str as *const u8)\n-        }\n-    }\n-\n-    pub fn desc(&self) -> String {\n-        unsafe {\n-            let inner = match self { &UvError(a) => a };\n-            let desc_str = uvll::uv_strerror(inner);\n-            assert!(desc_str.is_not_null());\n-            string::raw::from_buf(desc_str as *const u8)\n-        }\n-    }\n-\n-    pub fn is_eof(&self) -> bool {\n-        let UvError(handle) = *self;\n-        handle == uvll::EOF\n-    }\n-}\n-\n-impl fmt::Show for UvError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}: {}\", self.name(), self.desc())\n-    }\n-}\n-\n-#[test]\n-fn error_smoke_test() {\n-    let err: UvError = UvError(uvll::EOF);\n-    assert_eq!(err.to_string(), \"EOF: end of file\".to_string());\n-}\n-\n-#[cfg(unix)]\n-pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n-    let UvError(errcode) = uverr;\n-    IoError {\n-        code: if errcode == uvll::EOF {libc::EOF as uint} else {-errcode as uint},\n-        extra: 0,\n-        detail: Some(uverr.desc()),\n-    }\n-}\n-\n-#[cfg(windows)]\n-pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n-    let UvError(errcode) = uverr;\n-    IoError {\n-        code: match errcode {\n-            uvll::EOF => libc::EOF,\n-            uvll::EACCES => libc::ERROR_ACCESS_DENIED,\n-            uvll::ECONNREFUSED => libc::WSAECONNREFUSED,\n-            uvll::ECONNRESET => libc::WSAECONNRESET,\n-            uvll::ENOTCONN => libc::WSAENOTCONN,\n-            uvll::ENOENT => libc::ERROR_FILE_NOT_FOUND,\n-            uvll::EPIPE => libc::ERROR_NO_DATA,\n-            uvll::ECONNABORTED => libc::WSAECONNABORTED,\n-            uvll::EADDRNOTAVAIL => libc::WSAEADDRNOTAVAIL,\n-            uvll::ECANCELED => libc::ERROR_OPERATION_ABORTED,\n-            uvll::EADDRINUSE => libc::WSAEADDRINUSE,\n-            uvll::EPERM => libc::ERROR_ACCESS_DENIED,\n-            err => {\n-                uvdebug!(\"uverr.code {}\", err as int);\n-                // FIXME: Need to map remaining uv error types\n-                -1\n-            }\n-        } as uint,\n-        extra: 0,\n-        detail: Some(uverr.desc()),\n-    }\n-}\n-\n-/// Given a uv error code, convert a callback status to a UvError\n-pub fn status_to_maybe_uv_error(status: c_int) -> Option<UvError> {\n-    if status >= 0 {\n-        None\n-    } else {\n-        Some(UvError(status))\n-    }\n-}\n-\n-pub fn status_to_io_result(status: c_int) -> IoResult<()> {\n-    if status >= 0 {Ok(())} else {Err(uv_error_to_io_error(UvError(status)))}\n-}\n-\n-/// The uv buffer type\n-pub type Buf = uvll::uv_buf_t;\n-\n-pub fn empty_buf() -> Buf {\n-    uvll::uv_buf_t {\n-        base: ptr::null_mut(),\n-        len: 0,\n-    }\n-}\n-\n-/// Borrow a slice to a Buf\n-pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n-    let data = v.as_ptr();\n-    uvll::uv_buf_t { base: data as *mut u8, len: v.len() as uvll::uv_buf_len_t }\n-}\n-\n-// This function is full of lies!\n-#[cfg(test)]\n-fn local_loop() -> &'static mut uvio::UvIoFactory {\n-    use std::raw::TraitObject;\n-    unsafe {\n-        mem::transmute({\n-            let mut task = Local::borrow(None::<Task>);\n-            let mut io = task.local_io().unwrap();\n-            let obj: TraitObject =\n-                mem::transmute(io.get());\n-            obj.data\n-        })\n-    }\n-}\n-\n-#[cfg(test)]\n-fn next_test_ip4() -> std::rt::rtio::SocketAddr {\n-    use std::io;\n-    use std::rt::rtio;\n-\n-    let io::net::ip::SocketAddr { ip, port } = io::test::next_test_ip4();\n-    let ip = match ip {\n-        io::net::ip::Ipv4Addr(a, b, c, d) => rtio::Ipv4Addr(a, b, c, d),\n-        _ => unreachable!(),\n-    };\n-    rtio::SocketAddr { ip: ip, port: port }\n-}\n-\n-#[cfg(test)]\n-fn next_test_ip6() -> std::rt::rtio::SocketAddr {\n-    use std::io;\n-    use std::rt::rtio;\n-\n-    let io::net::ip::SocketAddr { ip, port } = io::test::next_test_ip6();\n-    let ip = match ip {\n-        io::net::ip::Ipv6Addr(a, b, c, d, e, f, g, h) =>\n-            rtio::Ipv6Addr(a, b, c, d, e, f, g, h),\n-        _ => unreachable!(),\n-    };\n-    rtio::SocketAddr { ip: ip, port: port }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use std::mem::transmute;\n-    use std::rt::thread::Thread;\n-\n-    use super::{slice_to_uv_buf, Loop};\n-\n-    #[test]\n-    fn test_slice_to_uv_buf() {\n-        let slice = [0, .. 20];\n-        let buf = slice_to_uv_buf(slice);\n-\n-        assert_eq!(buf.len, 20);\n-\n-        unsafe {\n-            let base = transmute::<*mut u8, *mut u8>(buf.base);\n-            (*base) = 1;\n-            (*base.offset(1)) = 2;\n-        }\n-\n-        assert!(slice[0] == 1);\n-        assert!(slice[1] == 2);\n-    }\n-\n-\n-    #[test]\n-    fn loop_smoke_test() {\n-        Thread::start(proc() {\n-            let mut loop_ = Loop::new();\n-            loop_.run();\n-            loop_.close();\n-        }).join();\n-    }\n-}"}, {"sha": "deb7036848f96413bd1c26c7038f8eebda416f9e", "filename": "src/librustuv/macros.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,34 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![macro_escape]\n-\n-use std::fmt;\n-\n-macro_rules! uverrln (\n-    ($($arg:tt)*) => ( {\n-        format_args!(::macros::dumb_println, $($arg)*)\n-    } )\n-)\n-\n-// Some basic logging. Enabled by passing `--cfg uvdebug` to the libstd build.\n-macro_rules! uvdebug (\n-    ($($arg:tt)*) => ( {\n-        if cfg!(uvdebug) {\n-            uverrln!($($arg)*)\n-        }\n-    })\n-)\n-\n-pub fn dumb_println(args: &fmt::Arguments) {\n-    use std::rt;\n-    let mut w = rt::Stderr;\n-    let _ = writeln!(&mut w, \"{}\", args);\n-}"}, {"sha": "3531d162db08115968eae31dde7f78cdd2c946cf", "filename": "src/librustuv/net.rs", "status": "removed", "additions": 0, "deletions": 1288, "changes": 1288, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,1288 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n-use libc;\n-use std::mem;\n-use std::ptr;\n-use std::rt::rtio;\n-use std::rt::rtio::IoError;\n-use std::rt::task::BlockedTask;\n-\n-use homing::{HomingIO, HomeHandle};\n-use rc::Refcount;\n-use stream::StreamWatcher;\n-use super::{Loop, Request, UvError, Buf, status_to_io_result,\n-            uv_error_to_io_error, UvHandle, slice_to_uv_buf,\n-            wait_until_woken_after, wakeup};\n-use timeout::{AccessTimeout, ConnectCtx, AcceptTimeout};\n-use uvio::UvIoFactory;\n-use uvll;\n-\n-////////////////////////////////////////////////////////////////////////////////\n-/// Generic functions related to dealing with sockaddr things\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub fn htons(u: u16) -> u16 { u.to_be() }\n-pub fn ntohs(u: u16) -> u16 { Int::from_be(u) }\n-\n-pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n-                        len: uint) -> rtio::SocketAddr {\n-    match storage.ss_family as c_int {\n-        libc::AF_INET => {\n-            assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n-            let storage: &libc::sockaddr_in = unsafe {\n-                mem::transmute(storage)\n-            };\n-            let ip = (storage.sin_addr.s_addr as u32).to_be();\n-            let a = (ip >> 24) as u8;\n-            let b = (ip >> 16) as u8;\n-            let c = (ip >>  8) as u8;\n-            let d = (ip >>  0) as u8;\n-            rtio::SocketAddr {\n-                ip: rtio::Ipv4Addr(a, b, c, d),\n-                port: ntohs(storage.sin_port),\n-            }\n-        }\n-        libc::AF_INET6 => {\n-            assert!(len as uint >= mem::size_of::<libc::sockaddr_in6>());\n-            let storage: &libc::sockaddr_in6 = unsafe {\n-                mem::transmute(storage)\n-            };\n-            let a = ntohs(storage.sin6_addr.s6_addr[0]);\n-            let b = ntohs(storage.sin6_addr.s6_addr[1]);\n-            let c = ntohs(storage.sin6_addr.s6_addr[2]);\n-            let d = ntohs(storage.sin6_addr.s6_addr[3]);\n-            let e = ntohs(storage.sin6_addr.s6_addr[4]);\n-            let f = ntohs(storage.sin6_addr.s6_addr[5]);\n-            let g = ntohs(storage.sin6_addr.s6_addr[6]);\n-            let h = ntohs(storage.sin6_addr.s6_addr[7]);\n-            rtio::SocketAddr {\n-                ip: rtio::Ipv6Addr(a, b, c, d, e, f, g, h),\n-                port: ntohs(storage.sin6_port),\n-            }\n-        }\n-        n => {\n-            fail!(\"unknown family {}\", n);\n-        }\n-    }\n-}\n-\n-fn addr_to_sockaddr(addr: rtio::SocketAddr,\n-                    storage: &mut libc::sockaddr_storage)\n-                    -> libc::socklen_t {\n-    unsafe {\n-        let len = match addr.ip {\n-            rtio::Ipv4Addr(a, b, c, d) => {\n-                let ip = (a as u32 << 24) |\n-                         (b as u32 << 16) |\n-                         (c as u32 <<  8) |\n-                         (d as u32 <<  0);\n-                let storage = storage as *mut _ as *mut libc::sockaddr_in;\n-                (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n-                (*storage).sin_port = htons(addr.port);\n-                (*storage).sin_addr = libc::in_addr {\n-                    s_addr: Int::from_be(ip),\n-\n-                };\n-                mem::size_of::<libc::sockaddr_in>()\n-            }\n-            rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n-                let storage = storage as *mut _ as *mut libc::sockaddr_in6;\n-                (*storage).sin6_family = libc::AF_INET6 as libc::sa_family_t;\n-                (*storage).sin6_port = htons(addr.port);\n-                (*storage).sin6_addr = libc::in6_addr {\n-                    s6_addr: [\n-                        htons(a),\n-                        htons(b),\n-                        htons(c),\n-                        htons(d),\n-                        htons(e),\n-                        htons(f),\n-                        htons(g),\n-                        htons(h),\n-                    ]\n-                };\n-                mem::size_of::<libc::sockaddr_in6>()\n-            }\n-        };\n-        return len as libc::socklen_t\n-    }\n-}\n-\n-enum SocketNameKind {\n-    TcpPeer,\n-    Tcp,\n-    Udp\n-}\n-\n-fn socket_name(sk: SocketNameKind,\n-               handle: *mut c_void) -> Result<rtio::SocketAddr, IoError> {\n-    let getsockname = match sk {\n-        TcpPeer => uvll::uv_tcp_getpeername,\n-        Tcp     => uvll::uv_tcp_getsockname,\n-        Udp     => uvll::uv_udp_getsockname,\n-    };\n-\n-    // Allocate a sockaddr_storage since we don't know if it's ipv4 or ipv6\n-    let mut sockaddr: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-    let mut namelen = mem::size_of::<libc::sockaddr_storage>() as c_int;\n-\n-    let sockaddr_p = &mut sockaddr as *mut libc::sockaddr_storage;\n-    match unsafe {\n-        getsockname(&*handle, sockaddr_p as *mut libc::sockaddr, &mut namelen)\n-    } {\n-        0 => Ok(sockaddr_to_addr(&sockaddr, namelen as uint)),\n-        n => Err(uv_error_to_io_error(UvError(n)))\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-/// TCP implementation\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct TcpWatcher {\n-    handle: *mut uvll::uv_tcp_t,\n-    stream: StreamWatcher,\n-    home: HomeHandle,\n-    refcount: Refcount,\n-\n-    // libuv can't support concurrent reads and concurrent writes of the same\n-    // stream object, so we use these access guards in order to arbitrate among\n-    // multiple concurrent reads and writes. Note that libuv *can* read and\n-    // write simultaneously, it just can't read and read simultaneously.\n-    read_access: AccessTimeout<()>,\n-    write_access: AccessTimeout<()>,\n-}\n-\n-pub struct TcpListener {\n-    home: HomeHandle,\n-    handle: *mut uvll::uv_tcp_t,\n-}\n-\n-pub struct TcpAcceptor {\n-    home: HomeHandle,\n-    handle: *mut uvll::uv_tcp_t,\n-    access: AcceptTimeout<Box<rtio::RtioTcpStream + Send>>,\n-    refcount: Refcount,\n-}\n-\n-// TCP watchers (clients/streams)\n-\n-impl TcpWatcher {\n-    pub fn new(io: &mut UvIoFactory) -> TcpWatcher {\n-        let handle = io.make_handle();\n-        TcpWatcher::new_home(&io.loop_, handle)\n-    }\n-\n-    fn new_home(loop_: &Loop, home: HomeHandle) -> TcpWatcher {\n-        let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n-        assert_eq!(unsafe {\n-            uvll::uv_tcp_init(loop_.handle, handle)\n-        }, 0);\n-        TcpWatcher {\n-            home: home,\n-            handle: handle,\n-            stream: StreamWatcher::new(handle, true),\n-            refcount: Refcount::new(),\n-            read_access: AccessTimeout::new(()),\n-            write_access: AccessTimeout::new(()),\n-        }\n-    }\n-\n-    pub fn connect(io: &mut UvIoFactory,\n-                   address: rtio::SocketAddr,\n-                   timeout: Option<u64>) -> Result<TcpWatcher, UvError> {\n-        let tcp = TcpWatcher::new(io);\n-        let cx = ConnectCtx { status: -1, task: None, timer: None };\n-        let mut storage = unsafe { mem::zeroed() };\n-        let _len = addr_to_sockaddr(address, &mut storage);\n-        let addr_p = &storage as *const _ as *const libc::sockaddr;\n-        cx.connect(tcp, timeout, io, |req, tcp, cb| {\n-            unsafe { uvll::uv_tcp_connect(req.handle, tcp.handle, addr_p, cb) }\n-        })\n-    }\n-}\n-\n-impl HomingIO for TcpWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n-}\n-\n-impl rtio::RtioSocket for TcpWatcher {\n-    fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n-        let _m = self.fire_homing_missile();\n-        socket_name(Tcp, self.handle)\n-    }\n-}\n-\n-impl rtio::RtioTcpStream for TcpWatcher {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        let m = self.fire_homing_missile();\n-        let guard = try!(self.read_access.grant(m));\n-\n-        // see comments in close_read about this check\n-        if guard.access.is_closed() {\n-            return Err(uv_error_to_io_error(UvError(uvll::EOF)))\n-        }\n-\n-        self.stream.read(buf).map_err(uv_error_to_io_error)\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let m = self.fire_homing_missile();\n-        let guard = try!(self.write_access.grant(m));\n-        self.stream.write(buf, guard.can_timeout).map_err(uv_error_to_io_error)\n-    }\n-\n-    fn peer_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n-        let _m = self.fire_homing_missile();\n-        socket_name(TcpPeer, self.handle)\n-    }\n-\n-    fn control_congestion(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_tcp_nodelay(self.handle, 0 as c_int)\n-        })\n-    }\n-\n-    fn nodelay(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_tcp_nodelay(self.handle, 1 as c_int)\n-        })\n-    }\n-\n-    fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_tcp_keepalive(self.handle, 1 as c_int,\n-                                   delay_in_seconds as c_uint)\n-        })\n-    }\n-\n-    fn letdie(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_tcp_keepalive(self.handle, 0 as c_int, 0 as c_uint)\n-        })\n-    }\n-\n-    fn clone(&self) -> Box<rtio::RtioTcpStream + Send> {\n-        box TcpWatcher {\n-            handle: self.handle,\n-            stream: StreamWatcher::new(self.handle, false),\n-            home: self.home.clone(),\n-            refcount: self.refcount.clone(),\n-            read_access: self.read_access.clone(),\n-            write_access: self.write_access.clone(),\n-        } as Box<rtio::RtioTcpStream + Send>\n-    }\n-\n-    fn close_read(&mut self) -> Result<(), IoError> {\n-        // see comments in PipeWatcher::close_read\n-        let task = {\n-            let m = self.fire_homing_missile();\n-            self.read_access.access.close(&m);\n-            self.stream.cancel_read(uvll::EOF as libc::ssize_t)\n-        };\n-        let _ = task.map(|t| t.reawaken());\n-        Ok(())\n-    }\n-\n-    fn close_write(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        shutdown(self.handle, &self.uv_loop())\n-    }\n-\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        self.set_read_timeout(timeout);\n-        self.set_write_timeout(timeout);\n-    }\n-\n-    fn set_read_timeout(&mut self, ms: Option<u64>) {\n-        let _m = self.fire_homing_missile();\n-        let loop_ = self.uv_loop();\n-        self.read_access.set_timeout(ms, &self.home, &loop_, cancel_read,\n-                                     &self.stream as *const _ as uint);\n-\n-        fn cancel_read(stream: uint) -> Option<BlockedTask> {\n-            let stream: &mut StreamWatcher = unsafe { mem::transmute(stream) };\n-            stream.cancel_read(uvll::ECANCELED as ssize_t)\n-        }\n-    }\n-\n-    fn set_write_timeout(&mut self, ms: Option<u64>) {\n-        let _m = self.fire_homing_missile();\n-        let loop_ = self.uv_loop();\n-        self.write_access.set_timeout(ms, &self.home, &loop_, cancel_write,\n-                                      &self.stream as *const _ as uint);\n-\n-        fn cancel_write(stream: uint) -> Option<BlockedTask> {\n-            let stream: &mut StreamWatcher = unsafe { mem::transmute(stream) };\n-            stream.cancel_write()\n-        }\n-    }\n-}\n-\n-impl UvHandle<uvll::uv_tcp_t> for TcpWatcher {\n-    fn uv_handle(&self) -> *mut uvll::uv_tcp_t { self.stream.handle }\n-}\n-\n-impl Drop for TcpWatcher {\n-    fn drop(&mut self) {\n-        let _m = self.fire_homing_missile();\n-        if self.refcount.decrement() {\n-            self.close();\n-        }\n-    }\n-}\n-\n-// TCP listeners (unbound servers)\n-\n-impl TcpListener {\n-    pub fn bind(io: &mut UvIoFactory, address: rtio::SocketAddr)\n-                -> Result<Box<TcpListener>, UvError> {\n-        let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n-        assert_eq!(unsafe {\n-            uvll::uv_tcp_init(io.uv_loop(), handle)\n-        }, 0);\n-        let l = box TcpListener {\n-            home: io.make_handle(),\n-            handle: handle,\n-        };\n-        let mut storage = unsafe { mem::zeroed() };\n-        let _len = addr_to_sockaddr(address, &mut storage);\n-        let res = unsafe {\n-            let addr_p = &storage as *const _ as *const libc::sockaddr;\n-            uvll::uv_tcp_bind(l.handle, addr_p, 0)\n-        };\n-        return match res {\n-            0 => Ok(l.install()),\n-            n => Err(UvError(n))\n-        };\n-    }\n-}\n-\n-impl HomingIO for TcpListener {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n-}\n-\n-impl UvHandle<uvll::uv_tcp_t> for TcpListener {\n-    fn uv_handle(&self) -> *mut uvll::uv_tcp_t { self.handle }\n-}\n-\n-impl rtio::RtioSocket for TcpListener {\n-    fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n-        let _m = self.fire_homing_missile();\n-        socket_name(Tcp, self.handle)\n-    }\n-}\n-\n-impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(mut self: Box<TcpListener>)\n-              -> Result<Box<rtio::RtioTcpAcceptor + Send>, IoError> {\n-        let _m = self.fire_homing_missile();\n-\n-        // create the acceptor object from ourselves\n-        let acceptor = (box TcpAcceptor {\n-            handle: self.handle,\n-            home: self.home.clone(),\n-            access: AcceptTimeout::new(),\n-            refcount: Refcount::new(),\n-        }).install();\n-        self.handle = 0 as *mut _;\n-\n-        // FIXME: the 128 backlog should be configurable\n-        match unsafe { uvll::uv_listen(acceptor.handle, 128, listen_cb) } {\n-            0 => Ok(acceptor as Box<rtio::RtioTcpAcceptor + Send>),\n-            n => Err(uv_error_to_io_error(UvError(n))),\n-        }\n-    }\n-}\n-\n-extern fn listen_cb(server: *mut uvll::uv_stream_t, status: c_int) {\n-    assert!(status != uvll::ECANCELED);\n-    let tcp: &mut TcpAcceptor = unsafe { UvHandle::from_uv_handle(&server) };\n-    let msg = match status {\n-        0 => {\n-            let loop_ = Loop::wrap(unsafe {\n-                uvll::get_loop_for_uv_handle(server)\n-            });\n-            let client = TcpWatcher::new_home(&loop_, tcp.home().clone());\n-            assert_eq!(unsafe { uvll::uv_accept(server, client.handle) }, 0);\n-            Ok(box client as Box<rtio::RtioTcpStream + Send>)\n-        }\n-        n => Err(uv_error_to_io_error(UvError(n)))\n-    };\n-\n-    // If we're running then we have exclusive access, so the unsafe_get() is ok\n-    unsafe { tcp.access.push(msg); }\n-}\n-\n-impl Drop for TcpListener {\n-    fn drop(&mut self) {\n-        if self.handle.is_null() { return }\n-\n-        let _m = self.fire_homing_missile();\n-        self.close();\n-    }\n-}\n-\n-// TCP acceptors (bound servers)\n-\n-impl HomingIO for TcpAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n-}\n-\n-impl rtio::RtioSocket for TcpAcceptor {\n-    fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n-        let _m = self.fire_homing_missile();\n-        socket_name(Tcp, self.handle)\n-    }\n-}\n-\n-impl UvHandle<uvll::uv_tcp_t> for TcpAcceptor {\n-    fn uv_handle(&self) -> *mut uvll::uv_tcp_t { self.handle }\n-}\n-\n-impl rtio::RtioTcpAcceptor for TcpAcceptor {\n-    fn accept(&mut self) -> Result<Box<rtio::RtioTcpStream + Send>, IoError> {\n-        let m = self.fire_homing_missile();\n-        let loop_ = self.uv_loop();\n-        self.access.accept(m, &loop_)\n-    }\n-\n-    fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_tcp_simultaneous_accepts(self.handle, 1)\n-        })\n-    }\n-\n-    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_tcp_simultaneous_accepts(self.handle, 0)\n-        })\n-    }\n-\n-    fn set_timeout(&mut self, ms: Option<u64>) {\n-        let _m = self.fire_homing_missile();\n-        let loop_ = self.uv_loop();\n-        self.access.set_timeout(ms, &loop_, &self.home);\n-    }\n-\n-    fn clone(&self) -> Box<rtio::RtioTcpAcceptor + Send> {\n-        box TcpAcceptor {\n-            refcount: self.refcount.clone(),\n-            home: self.home.clone(),\n-            handle: self.handle,\n-            access: self.access.clone(),\n-        } as Box<rtio::RtioTcpAcceptor + Send>\n-    }\n-\n-    fn close_accept(&mut self) -> Result<(), IoError> {\n-        let m = self.fire_homing_missile();\n-        self.access.close(m);\n-        Ok(())\n-    }\n-}\n-\n-impl Drop for TcpAcceptor {\n-    fn drop(&mut self) {\n-        let _m = self.fire_homing_missile();\n-        if self.refcount.decrement() {\n-            self.close();\n-        }\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-/// UDP implementation\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct UdpWatcher {\n-    handle: *mut uvll::uv_udp_t,\n-    home: HomeHandle,\n-\n-    // See above for what these fields are\n-    refcount: Refcount,\n-    read_access: AccessTimeout<()>,\n-    write_access: AccessTimeout<()>,\n-\n-    blocked_sender: Option<BlockedTask>,\n-}\n-\n-struct UdpRecvCtx {\n-    task: Option<BlockedTask>,\n-    buf: Option<Buf>,\n-    result: Option<(ssize_t, Option<rtio::SocketAddr>)>,\n-}\n-\n-struct UdpSendCtx {\n-    result: c_int,\n-    data: Option<Vec<u8>>,\n-    udp: *mut UdpWatcher,\n-}\n-\n-impl UdpWatcher {\n-    pub fn bind(io: &mut UvIoFactory, address: rtio::SocketAddr)\n-                -> Result<UdpWatcher, UvError> {\n-        let udp = UdpWatcher {\n-            handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n-            home: io.make_handle(),\n-            refcount: Refcount::new(),\n-            read_access: AccessTimeout::new(()),\n-            write_access: AccessTimeout::new(()),\n-            blocked_sender: None,\n-        };\n-        assert_eq!(unsafe {\n-            uvll::uv_udp_init(io.uv_loop(), udp.handle)\n-        }, 0);\n-        let mut storage = unsafe { mem::zeroed() };\n-        let _len = addr_to_sockaddr(address, &mut storage);\n-        let result = unsafe {\n-            let addr_p = &storage as *const _ as *const libc::sockaddr;\n-            uvll::uv_udp_bind(udp.handle, addr_p, 0u32)\n-        };\n-        return match result {\n-            0 => Ok(udp),\n-            n => Err(UvError(n)),\n-        };\n-    }\n-}\n-\n-impl UvHandle<uvll::uv_udp_t> for UdpWatcher {\n-    fn uv_handle(&self) -> *mut uvll::uv_udp_t { self.handle }\n-}\n-\n-impl HomingIO for UdpWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n-}\n-\n-impl rtio::RtioSocket for UdpWatcher {\n-    fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n-        let _m = self.fire_homing_missile();\n-        socket_name(Udp, self.handle)\n-    }\n-}\n-\n-impl rtio::RtioUdpSocket for UdpWatcher {\n-    fn recv_from(&mut self, buf: &mut [u8])\n-        -> Result<(uint, rtio::SocketAddr), IoError>\n-    {\n-        let loop_ = self.uv_loop();\n-        let m = self.fire_homing_missile();\n-        let _guard = try!(self.read_access.grant(m));\n-\n-        return match unsafe {\n-            uvll::uv_udp_recv_start(self.handle, alloc_cb, recv_cb)\n-        } {\n-            0 => {\n-                let mut cx = UdpRecvCtx {\n-                    task: None,\n-                    buf: Some(slice_to_uv_buf(buf)),\n-                    result: None,\n-                };\n-                let handle = self.handle;\n-                wait_until_woken_after(&mut cx.task, &loop_, || {\n-                    unsafe { uvll::set_data_for_uv_handle(handle, &mut cx) }\n-                });\n-                match cx.result.take().unwrap() {\n-                    (n, _) if n < 0 =>\n-                        Err(uv_error_to_io_error(UvError(n as c_int))),\n-                    (n, addr) => Ok((n as uint, addr.unwrap()))\n-                }\n-            }\n-            n => Err(uv_error_to_io_error(UvError(n)))\n-        };\n-\n-        extern fn alloc_cb(handle: *mut uvll::uv_udp_t,\n-                           _suggested_size: size_t,\n-                           buf: *mut Buf) {\n-            unsafe {\n-                let cx = uvll::get_data_for_uv_handle(handle);\n-                let cx = &mut *(cx as *mut UdpRecvCtx);\n-                *buf = cx.buf.take().expect(\"recv alloc_cb called more than once\")\n-            }\n-        }\n-\n-        extern fn recv_cb(handle: *mut uvll::uv_udp_t, nread: ssize_t,\n-                          buf: *const Buf,\n-                          addr: *const libc::sockaddr, _flags: c_uint) {\n-            assert!(nread != uvll::ECANCELED as ssize_t);\n-            let cx = unsafe {\n-                &mut *(uvll::get_data_for_uv_handle(handle) as *mut UdpRecvCtx)\n-            };\n-\n-            // When there's no data to read the recv callback can be a no-op.\n-            // This can happen if read returns EAGAIN/EWOULDBLOCK. By ignoring\n-            // this we just drop back to kqueue and wait for the next callback.\n-            if nread == 0 {\n-                cx.buf = Some(unsafe { *buf });\n-                return\n-            }\n-\n-            unsafe { assert_eq!(uvll::uv_udp_recv_stop(handle), 0) }\n-            let addr = if addr == ptr::null() {\n-                None\n-            } else {\n-                let len = mem::size_of::<libc::sockaddr_storage>();\n-                Some(sockaddr_to_addr(unsafe { mem::transmute(addr) }, len))\n-            };\n-            cx.result = Some((nread, addr));\n-            wakeup(&mut cx.task);\n-        }\n-    }\n-\n-    fn send_to(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> Result<(), IoError> {\n-        let m = self.fire_homing_missile();\n-        let loop_ = self.uv_loop();\n-        let guard = try!(self.write_access.grant(m));\n-\n-        let mut req = Request::new(uvll::UV_UDP_SEND);\n-        let mut storage = unsafe { mem::zeroed() };\n-        let _len = addr_to_sockaddr(dst, &mut storage);\n-        let addr_p = &storage as *const _ as *const libc::sockaddr;\n-\n-        // see comments in StreamWatcher::write for why we may allocate a buffer\n-        // here.\n-        let data = if guard.can_timeout {Some(buf.to_vec())} else {None};\n-        let uv_buf = if guard.can_timeout {\n-            slice_to_uv_buf(data.as_ref().unwrap().as_slice())\n-        } else {\n-            slice_to_uv_buf(buf)\n-        };\n-\n-        return match unsafe {\n-            uvll::uv_udp_send(req.handle, self.handle, [uv_buf], addr_p, send_cb)\n-        } {\n-            0 => {\n-                req.defuse(); // uv callback now owns this request\n-                let mut cx = UdpSendCtx {\n-                    result: uvll::ECANCELED, data: data, udp: self as *mut _\n-                };\n-                wait_until_woken_after(&mut self.blocked_sender, &loop_, || {\n-                    req.set_data(&mut cx);\n-                });\n-\n-                if cx.result != uvll::ECANCELED {\n-                    return match cx.result {\n-                        0 => Ok(()),\n-                        n => Err(uv_error_to_io_error(UvError(n)))\n-                    }\n-                }\n-                let mut new_cx = box UdpSendCtx {\n-                    result: 0,\n-                    udp: 0 as *mut UdpWatcher,\n-                    data: cx.data.take(),\n-                };\n-                unsafe {\n-                    req.set_data(&mut *new_cx);\n-                    mem::forget(new_cx);\n-                }\n-                Err(uv_error_to_io_error(UvError(cx.result)))\n-            }\n-            n => Err(uv_error_to_io_error(UvError(n)))\n-        };\n-\n-        // This function is the same as stream::write_cb, but adapted for udp\n-        // instead of streams.\n-        extern fn send_cb(req: *mut uvll::uv_udp_send_t, status: c_int) {\n-            let req = Request::wrap(req);\n-            let cx: &mut UdpSendCtx = unsafe { req.get_data() };\n-            cx.result = status;\n-\n-            if cx.udp as uint != 0 {\n-                let udp: &mut UdpWatcher = unsafe { &mut *cx.udp };\n-                wakeup(&mut udp.blocked_sender);\n-            } else {\n-                let _cx: Box<UdpSendCtx> = unsafe { mem::transmute(cx) };\n-            }\n-        }\n-    }\n-\n-    fn join_multicast(&mut self, multi: rtio::IpAddr) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            multi.to_string().with_c_str(|m_addr| {\n-                uvll::uv_udp_set_membership(self.handle,\n-                                            m_addr, ptr::null(),\n-                                            uvll::UV_JOIN_GROUP)\n-            })\n-        })\n-    }\n-\n-    fn leave_multicast(&mut self, multi: rtio::IpAddr) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            multi.to_string().with_c_str(|m_addr| {\n-                uvll::uv_udp_set_membership(self.handle,\n-                                            m_addr, ptr::null(),\n-                                            uvll::UV_LEAVE_GROUP)\n-            })\n-        })\n-    }\n-\n-    fn loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_udp_set_multicast_loop(self.handle,\n-                                            1 as c_int)\n-        })\n-    }\n-\n-    fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_udp_set_multicast_loop(self.handle,\n-                                            0 as c_int)\n-        })\n-    }\n-\n-    fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_udp_set_multicast_ttl(self.handle,\n-                                           ttl as c_int)\n-        })\n-    }\n-\n-    fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_udp_set_ttl(self.handle, ttl as c_int)\n-        })\n-    }\n-\n-    fn hear_broadcasts(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_udp_set_broadcast(self.handle,\n-                                       1 as c_int)\n-        })\n-    }\n-\n-    fn ignore_broadcasts(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_udp_set_broadcast(self.handle,\n-                                       0 as c_int)\n-        })\n-    }\n-\n-    fn clone(&self) -> Box<rtio::RtioUdpSocket + Send> {\n-        box UdpWatcher {\n-            handle: self.handle,\n-            home: self.home.clone(),\n-            refcount: self.refcount.clone(),\n-            write_access: self.write_access.clone(),\n-            read_access: self.read_access.clone(),\n-            blocked_sender: None,\n-        } as Box<rtio::RtioUdpSocket + Send>\n-    }\n-\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        self.set_read_timeout(timeout);\n-        self.set_write_timeout(timeout);\n-    }\n-\n-    fn set_read_timeout(&mut self, ms: Option<u64>) {\n-        let _m = self.fire_homing_missile();\n-        let loop_ = self.uv_loop();\n-        self.read_access.set_timeout(ms, &self.home, &loop_, cancel_read,\n-                                     self.handle as uint);\n-\n-        fn cancel_read(stream: uint) -> Option<BlockedTask> {\n-            // This method is quite similar to StreamWatcher::cancel_read, see\n-            // there for more information\n-            let handle = stream as *mut uvll::uv_udp_t;\n-            assert_eq!(unsafe { uvll::uv_udp_recv_stop(handle) }, 0);\n-            let data = unsafe {\n-                let data = uvll::get_data_for_uv_handle(handle);\n-                if data.is_null() { return None }\n-                uvll::set_data_for_uv_handle(handle, 0 as *mut int);\n-                &mut *(data as *mut UdpRecvCtx)\n-            };\n-            data.result = Some((uvll::ECANCELED as ssize_t, None));\n-            data.task.take()\n-        }\n-    }\n-\n-    fn set_write_timeout(&mut self, ms: Option<u64>) {\n-        let _m = self.fire_homing_missile();\n-        let loop_ = self.uv_loop();\n-        self.write_access.set_timeout(ms, &self.home, &loop_, cancel_write,\n-                                      self as *mut _ as uint);\n-\n-        fn cancel_write(stream: uint) -> Option<BlockedTask> {\n-            let stream: &mut UdpWatcher = unsafe { mem::transmute(stream) };\n-            stream.blocked_sender.take()\n-        }\n-    }\n-}\n-\n-impl Drop for UdpWatcher {\n-    fn drop(&mut self) {\n-        // Send ourselves home to close this handle (blocking while doing so).\n-        let _m = self.fire_homing_missile();\n-        if self.refcount.decrement() {\n-            self.close();\n-        }\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Shutdown helper\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub fn shutdown(handle: *mut uvll::uv_stream_t, loop_: &Loop) -> Result<(), IoError> {\n-    struct Ctx {\n-        slot: Option<BlockedTask>,\n-        status: c_int,\n-    }\n-    let mut req = Request::new(uvll::UV_SHUTDOWN);\n-\n-    return match unsafe { uvll::uv_shutdown(req.handle, handle, shutdown_cb) } {\n-        0 => {\n-            req.defuse(); // uv callback now owns this request\n-            let mut cx = Ctx { slot: None, status: 0 };\n-\n-            wait_until_woken_after(&mut cx.slot, loop_, || {\n-                req.set_data(&mut cx);\n-            });\n-\n-            status_to_io_result(cx.status)\n-        }\n-        n => Err(uv_error_to_io_error(UvError(n)))\n-    };\n-\n-    extern fn shutdown_cb(req: *mut uvll::uv_shutdown_t, status: libc::c_int) {\n-        let req = Request::wrap(req);\n-        assert!(status != uvll::ECANCELED);\n-        let cx: &mut Ctx = unsafe { req.get_data() };\n-        cx.status = status;\n-        wakeup(&mut cx.slot);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioTcpAcceptor,\n-                        RtioUdpSocket};\n-\n-    use super::{UdpWatcher, TcpWatcher, TcpListener};\n-    use super::super::local_loop;\n-\n-    #[test]\n-    fn connect_close_ip4() {\n-        match TcpWatcher::connect(local_loop(), ::next_test_ip4(), None) {\n-            Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_string()),\n-        }\n-    }\n-\n-    #[test]\n-    fn connect_close_ip6() {\n-        match TcpWatcher::connect(local_loop(), ::next_test_ip6(), None) {\n-            Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_string()),\n-        }\n-    }\n-\n-    #[test]\n-    fn udp_bind_close_ip4() {\n-        match UdpWatcher::bind(local_loop(), ::next_test_ip4()) {\n-            Ok(..) => {}\n-            Err(..) => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    fn udp_bind_close_ip6() {\n-        match UdpWatcher::bind(local_loop(), ::next_test_ip6()) {\n-            Ok(..) => {}\n-            Err(..) => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    fn listen_ip4() {\n-        let (tx, rx) = channel();\n-        let addr = ::next_test_ip4();\n-\n-        spawn(proc() {\n-            let w = match TcpListener::bind(local_loop(), addr) {\n-                Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n-            };\n-            let mut w = match w.listen() {\n-                Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n-            };\n-            tx.send(());\n-            match w.accept() {\n-                Ok(mut stream) => {\n-                    let mut buf = [0u8, ..10];\n-                    match stream.read(buf) {\n-                        Ok(10) => {} e => fail!(\"{:?}\", e),\n-                    }\n-                    for i in range(0, 10u8) {\n-                        assert_eq!(buf[i as uint], i + 1);\n-                    }\n-                }\n-                Err(e) => fail!(\"{:?}\", e)\n-            }\n-        });\n-\n-        rx.recv();\n-        let mut w = match TcpWatcher::connect(local_loop(), addr, None) {\n-            Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n-        };\n-        match w.write([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) {\n-            Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n-        }\n-    }\n-\n-    #[test]\n-    fn listen_ip6() {\n-        let (tx, rx) = channel();\n-        let addr = ::next_test_ip6();\n-\n-        spawn(proc() {\n-            let w = match TcpListener::bind(local_loop(), addr) {\n-                Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n-            };\n-            let mut w = match w.listen() {\n-                Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n-            };\n-            tx.send(());\n-            match w.accept() {\n-                Ok(mut stream) => {\n-                    let mut buf = [0u8, ..10];\n-                    match stream.read(buf) {\n-                        Ok(10) => {} e => fail!(\"{:?}\", e),\n-                    }\n-                    for i in range(0, 10u8) {\n-                        assert_eq!(buf[i as uint], i + 1);\n-                    }\n-                }\n-                Err(e) => fail!(\"{:?}\", e)\n-            }\n-        });\n-\n-        rx.recv();\n-        let mut w = match TcpWatcher::connect(local_loop(), addr, None) {\n-            Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n-        };\n-        match w.write([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) {\n-            Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n-        }\n-    }\n-\n-    #[test]\n-    fn udp_recv_ip4() {\n-        let (tx, rx) = channel();\n-        let client = ::next_test_ip4();\n-        let server = ::next_test_ip4();\n-\n-        spawn(proc() {\n-            match UdpWatcher::bind(local_loop(), server) {\n-                Ok(mut w) => {\n-                    tx.send(());\n-                    let mut buf = [0u8, ..10];\n-                    match w.recv_from(buf) {\n-                        Ok((10, addr)) => assert!(addr == client),\n-                        e => fail!(\"{:?}\", e),\n-                    }\n-                    for i in range(0, 10u8) {\n-                        assert_eq!(buf[i as uint], i + 1);\n-                    }\n-                }\n-                Err(e) => fail!(\"{:?}\", e)\n-            }\n-        });\n-\n-        rx.recv();\n-        let mut w = match UdpWatcher::bind(local_loop(), client) {\n-            Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n-        };\n-        match w.send_to([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], server) {\n-            Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n-        }\n-    }\n-\n-    #[test]\n-    fn udp_recv_ip6() {\n-        let (tx, rx) = channel();\n-        let client = ::next_test_ip6();\n-        let server = ::next_test_ip6();\n-\n-        spawn(proc() {\n-            match UdpWatcher::bind(local_loop(), server) {\n-                Ok(mut w) => {\n-                    tx.send(());\n-                    let mut buf = [0u8, ..10];\n-                    match w.recv_from(buf) {\n-                        Ok((10, addr)) => assert!(addr == client),\n-                        e => fail!(\"{:?}\", e),\n-                    }\n-                    for i in range(0, 10u8) {\n-                        assert_eq!(buf[i as uint], i + 1);\n-                    }\n-                }\n-                Err(e) => fail!(\"{:?}\", e)\n-            }\n-        });\n-\n-        rx.recv();\n-        let mut w = match UdpWatcher::bind(local_loop(), client) {\n-            Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n-        };\n-        match w.send_to([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], server) {\n-            Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_read_read() {\n-        let addr = ::next_test_ip4();\n-        static MAX: uint = 5000;\n-        let (tx, rx) = channel();\n-\n-        spawn(proc() {\n-            let listener = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut acceptor = listener.listen().ok().unwrap();\n-            tx.send(());\n-            let mut stream = acceptor.accept().ok().unwrap();\n-            let buf = [1, .. 2048];\n-            let mut total_bytes_written = 0;\n-            while total_bytes_written < MAX {\n-                assert!(stream.write(buf).is_ok());\n-                uvdebug!(\"wrote bytes\");\n-                total_bytes_written += buf.len();\n-            }\n-        });\n-\n-        rx.recv();\n-        let mut stream = TcpWatcher::connect(local_loop(), addr, None).unwrap();\n-        let mut buf = [0, .. 2048];\n-        let mut total_bytes_read = 0;\n-        while total_bytes_read < MAX {\n-            let nread = stream.read(buf).ok().unwrap();\n-            total_bytes_read += nread;\n-            for i in range(0u, nread) {\n-                assert_eq!(buf[i], 1);\n-            }\n-        }\n-        uvdebug!(\"read {} bytes total\", total_bytes_read);\n-    }\n-\n-    #[test]\n-    #[cfg_attr(windows, ignore)] // FIXME(#10102) server never sees second packet\n-    fn test_udp_twice() {\n-        let server_addr = ::next_test_ip4();\n-        let client_addr = ::next_test_ip4();\n-        let (tx, rx) = channel();\n-\n-        spawn(proc() {\n-            let mut client = UdpWatcher::bind(local_loop(), client_addr).unwrap();\n-            rx.recv();\n-            assert!(client.send_to([1], server_addr).is_ok());\n-            assert!(client.send_to([2], server_addr).is_ok());\n-        });\n-\n-        let mut server = UdpWatcher::bind(local_loop(), server_addr).unwrap();\n-        tx.send(());\n-        let mut buf1 = [0];\n-        let mut buf2 = [0];\n-        let (nread1, src1) = server.recv_from(buf1).ok().unwrap();\n-        let (nread2, src2) = server.recv_from(buf2).ok().unwrap();\n-        assert_eq!(nread1, 1);\n-        assert_eq!(nread2, 1);\n-        assert!(src1 == client_addr);\n-        assert!(src2 == client_addr);\n-        assert_eq!(buf1[0], 1);\n-        assert_eq!(buf2[0], 2);\n-    }\n-\n-    #[test]\n-    fn test_udp_many_read() {\n-        let server_out_addr = ::next_test_ip4();\n-        let server_in_addr = ::next_test_ip4();\n-        let client_out_addr = ::next_test_ip4();\n-        let client_in_addr = ::next_test_ip4();\n-        static MAX: uint = 500_000;\n-\n-        let (tx1, rx1) = channel::<()>();\n-        let (tx2, rx2) = channel::<()>();\n-\n-        spawn(proc() {\n-            let l = local_loop();\n-            let mut server_out = UdpWatcher::bind(l, server_out_addr).unwrap();\n-            let mut server_in = UdpWatcher::bind(l, server_in_addr).unwrap();\n-            let (tx, rx) = (tx2, rx1);\n-            tx.send(());\n-            rx.recv();\n-            let msg = [1, .. 2048];\n-            let mut total_bytes_sent = 0;\n-            let mut buf = [1];\n-            while buf[0] == 1 {\n-                // send more data\n-                assert!(server_out.send_to(msg, client_in_addr).is_ok());\n-                total_bytes_sent += msg.len();\n-                // check if the client has received enough\n-                let res = server_in.recv_from(buf);\n-                assert!(res.is_ok());\n-                let (nread, src) = res.ok().unwrap();\n-                assert_eq!(nread, 1);\n-                assert!(src == client_out_addr);\n-            }\n-            assert!(total_bytes_sent >= MAX);\n-        });\n-\n-        let l = local_loop();\n-        let mut client_out = UdpWatcher::bind(l, client_out_addr).unwrap();\n-        let mut client_in = UdpWatcher::bind(l, client_in_addr).unwrap();\n-        let (tx, rx) = (tx1, rx2);\n-        rx.recv();\n-        tx.send(());\n-        let mut total_bytes_recv = 0;\n-        let mut buf = [0, .. 2048];\n-        while total_bytes_recv < MAX {\n-            // ask for more\n-            assert!(client_out.send_to([1], server_in_addr).is_ok());\n-            // wait for data\n-            let res = client_in.recv_from(buf);\n-            assert!(res.is_ok());\n-            let (nread, src) = res.ok().unwrap();\n-            assert!(src == server_out_addr);\n-            total_bytes_recv += nread;\n-            for i in range(0u, nread) {\n-                assert_eq!(buf[i], 1);\n-            }\n-        }\n-        // tell the server we're done\n-        assert!(client_out.send_to([0], server_in_addr).is_ok());\n-    }\n-\n-    #[test]\n-    fn test_read_and_block() {\n-        let addr = ::next_test_ip4();\n-        let (tx, rx) = channel::<Receiver<()>>();\n-\n-        spawn(proc() {\n-            let rx = rx.recv();\n-            let mut stream = TcpWatcher::connect(local_loop(), addr, None).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n-            rx.recv();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n-            rx.recv();\n-        });\n-\n-        let listener = TcpListener::bind(local_loop(), addr).unwrap();\n-        let mut acceptor = listener.listen().ok().unwrap();\n-        let (tx2, rx2) = channel();\n-        tx.send(rx2);\n-        let mut stream = acceptor.accept().ok().unwrap();\n-        let mut buf = [0, .. 2048];\n-\n-        let expected = 32;\n-        let mut current = 0;\n-        let mut reads = 0u;\n-\n-        while current < expected {\n-            let nread = stream.read(buf).ok().unwrap();\n-            for i in range(0u, nread) {\n-                let val = buf[i] as uint;\n-                assert_eq!(val, current % 8);\n-                current += 1;\n-            }\n-            reads += 1;\n-\n-            let _ = tx2.send_opt(());\n-        }\n-\n-        // Make sure we had multiple reads\n-        assert!(reads > 1);\n-    }\n-\n-    #[test]\n-    fn test_simple_tcp_server_and_client_on_diff_threads() {\n-        let addr = ::next_test_ip4();\n-\n-        spawn(proc() {\n-            let listener = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut acceptor = listener.listen().ok().unwrap();\n-            let mut stream = acceptor.accept().ok().unwrap();\n-            let mut buf = [0, .. 2048];\n-            let nread = stream.read(buf).ok().unwrap();\n-            assert_eq!(nread, 8);\n-            for i in range(0u, nread) {\n-                assert_eq!(buf[i], i as u8);\n-            }\n-        });\n-\n-        let mut stream = TcpWatcher::connect(local_loop(), addr, None);\n-        while stream.is_err() {\n-            stream = TcpWatcher::connect(local_loop(), addr, None);\n-        }\n-        stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]).ok().unwrap();\n-    }\n-\n-    #[should_fail] #[test]\n-    fn tcp_listener_fail_cleanup() {\n-        let addr = ::next_test_ip4();\n-        let w = TcpListener::bind(local_loop(), addr).unwrap();\n-        let _w = w.listen().ok().unwrap();\n-        fail!();\n-    }\n-\n-    #[should_fail] #[test]\n-    fn tcp_stream_fail_cleanup() {\n-        let (tx, rx) = channel();\n-        let addr = ::next_test_ip4();\n-\n-        spawn(proc() {\n-            let w = TcpListener::bind(local_loop(), addr).unwrap();\n-            let mut w = w.listen().ok().unwrap();\n-            tx.send(());\n-            drop(w.accept().ok().unwrap());\n-        });\n-        rx.recv();\n-        let _w = TcpWatcher::connect(local_loop(), addr, None).unwrap();\n-        fail!();\n-    }\n-\n-    #[should_fail] #[test]\n-    fn udp_listener_fail_cleanup() {\n-        let addr = ::next_test_ip4();\n-        let _w = UdpWatcher::bind(local_loop(), addr).unwrap();\n-        fail!();\n-    }\n-\n-    #[should_fail] #[test]\n-    fn udp_fail_other_task() {\n-        let addr = ::next_test_ip4();\n-        let (tx, rx) = channel();\n-\n-        // force the handle to be created on a different scheduler, failure in\n-        // the original task will force a homing operation back to this\n-        // scheduler.\n-        spawn(proc() {\n-            let w = UdpWatcher::bind(local_loop(), addr).unwrap();\n-            tx.send(w);\n-        });\n-\n-        let _w = rx.recv();\n-        fail!();\n-    }\n-}"}, {"sha": "9ece6525e1e82b07239e342a0e54a6811d4c76fa", "filename": "src/librustuv/pipe.rs", "status": "removed", "additions": 0, "deletions": 436, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,436 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc;\n-use std::c_str::CString;\n-use std::mem;\n-use std::rt::rtio;\n-use std::rt::rtio::IoResult;\n-use std::rt::task::BlockedTask;\n-\n-use homing::{HomingIO, HomeHandle};\n-use net;\n-use rc::Refcount;\n-use stream::StreamWatcher;\n-use super::{Loop, UvError, UvHandle, uv_error_to_io_error};\n-use timeout::{AcceptTimeout, ConnectCtx, AccessTimeout};\n-use uvio::UvIoFactory;\n-use uvll;\n-\n-pub struct PipeWatcher {\n-    stream: StreamWatcher,\n-    home: HomeHandle,\n-    defused: bool,\n-    refcount: Refcount,\n-\n-    // see comments in TcpWatcher for why these exist\n-    write_access: AccessTimeout<()>,\n-    read_access: AccessTimeout<()>,\n-}\n-\n-pub struct PipeListener {\n-    home: HomeHandle,\n-    pipe: *mut uvll::uv_pipe_t,\n-}\n-\n-pub struct PipeAcceptor {\n-    home: HomeHandle,\n-    handle: *mut uvll::uv_pipe_t,\n-    access: AcceptTimeout<Box<rtio::RtioPipe + Send>>,\n-    refcount: Refcount,\n-}\n-\n-// PipeWatcher implementation and traits\n-\n-impl PipeWatcher {\n-    // Creates an uninitialized pipe watcher. The underlying uv pipe is ready to\n-    // get bound to some other source (this is normally a helper method paired\n-    // with another call).\n-    pub fn new(io: &mut UvIoFactory, ipc: bool) -> PipeWatcher {\n-        let home = io.make_handle();\n-        PipeWatcher::new_home(&io.loop_, home, ipc)\n-    }\n-\n-    pub fn new_home(loop_: &Loop, home: HomeHandle, ipc: bool) -> PipeWatcher {\n-        let handle = unsafe {\n-            let handle = uvll::malloc_handle(uvll::UV_NAMED_PIPE);\n-            assert!(!handle.is_null());\n-            let ipc = ipc as libc::c_int;\n-            assert_eq!(uvll::uv_pipe_init(loop_.handle, handle, ipc), 0);\n-            handle\n-        };\n-        PipeWatcher {\n-            stream: StreamWatcher::new(handle, true),\n-            home: home,\n-            defused: false,\n-            refcount: Refcount::new(),\n-            read_access: AccessTimeout::new(()),\n-            write_access: AccessTimeout::new(()),\n-        }\n-    }\n-\n-    pub fn open(io: &mut UvIoFactory, file: libc::c_int)\n-        -> Result<PipeWatcher, UvError>\n-    {\n-        let pipe = PipeWatcher::new(io, false);\n-        match unsafe { uvll::uv_pipe_open(pipe.handle(), file) } {\n-            0 => Ok(pipe),\n-            n => Err(UvError(n))\n-        }\n-    }\n-\n-    pub fn connect(io: &mut UvIoFactory, name: &CString, timeout: Option<u64>)\n-        -> Result<PipeWatcher, UvError>\n-    {\n-        let pipe = PipeWatcher::new(io, false);\n-        let cx = ConnectCtx { status: -1, task: None, timer: None };\n-        cx.connect(pipe, timeout, io, |req, pipe, cb| {\n-            unsafe {\n-                uvll::uv_pipe_connect(req.handle, pipe.handle(),\n-                                      name.as_ptr(), cb)\n-            }\n-            0\n-        })\n-    }\n-\n-    pub fn handle(&self) -> *mut uvll::uv_pipe_t { self.stream.handle }\n-\n-    // Unwraps the underlying uv pipe. This cancels destruction of the pipe and\n-    // allows the pipe to get moved elsewhere\n-    fn unwrap(mut self) -> *mut uvll::uv_pipe_t {\n-        self.defused = true;\n-        return self.stream.handle;\n-    }\n-}\n-\n-impl rtio::RtioPipe for PipeWatcher {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let m = self.fire_homing_missile();\n-        let guard = try!(self.read_access.grant(m));\n-\n-        // see comments in close_read about this check\n-        if guard.access.is_closed() {\n-            return Err(uv_error_to_io_error(UvError(uvll::EOF)))\n-        }\n-\n-        self.stream.read(buf).map_err(uv_error_to_io_error)\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let m = self.fire_homing_missile();\n-        let guard = try!(self.write_access.grant(m));\n-        self.stream.write(buf, guard.can_timeout).map_err(uv_error_to_io_error)\n-    }\n-\n-    fn clone(&self) -> Box<rtio::RtioPipe + Send> {\n-        box PipeWatcher {\n-            stream: StreamWatcher::new(self.stream.handle, false),\n-            defused: false,\n-            home: self.home.clone(),\n-            refcount: self.refcount.clone(),\n-            read_access: self.read_access.clone(),\n-            write_access: self.write_access.clone(),\n-        } as Box<rtio::RtioPipe + Send>\n-    }\n-\n-    fn close_read(&mut self) -> IoResult<()> {\n-        // The current uv_shutdown method only shuts the writing half of the\n-        // connection, and no method is provided to shut down the reading half\n-        // of the connection. With a lack of method, we emulate shutting down\n-        // the reading half of the connection by manually returning early from\n-        // all future calls to `read`.\n-        //\n-        // Note that we must be careful to ensure that *all* cloned handles see\n-        // the closing of the read half, so we stored the \"is closed\" bit in the\n-        // Access struct, not in our own personal watcher. Additionally, the\n-        // homing missile is used as a locking mechanism to ensure there is no\n-        // contention over this bit.\n-        //\n-        // To shutdown the read half, we must first flag the access as being\n-        // closed, and then afterwards we cease any pending read. Note that this\n-        // ordering is crucial because we could in theory be rescheduled during\n-        // the uv_read_stop which means that another read invocation could leak\n-        // in before we set the flag.\n-        let task = {\n-            let m = self.fire_homing_missile();\n-            self.read_access.access.close(&m);\n-            self.stream.cancel_read(uvll::EOF as libc::ssize_t)\n-        };\n-        let _ = task.map(|t| t.reawaken());\n-        Ok(())\n-    }\n-\n-    fn close_write(&mut self) -> IoResult<()> {\n-        let _m = self.fire_homing_missile();\n-        net::shutdown(self.stream.handle, &self.uv_loop())\n-    }\n-\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        self.set_read_timeout(timeout);\n-        self.set_write_timeout(timeout);\n-    }\n-\n-    fn set_read_timeout(&mut self, ms: Option<u64>) {\n-        let _m = self.fire_homing_missile();\n-        let loop_ = self.uv_loop();\n-        self.read_access.set_timeout(ms, &self.home, &loop_, cancel_read,\n-                                     &self.stream as *const _ as uint);\n-\n-        fn cancel_read(stream: uint) -> Option<BlockedTask> {\n-            let stream: &mut StreamWatcher = unsafe { mem::transmute(stream) };\n-            stream.cancel_read(uvll::ECANCELED as libc::ssize_t)\n-        }\n-    }\n-\n-    fn set_write_timeout(&mut self, ms: Option<u64>) {\n-        let _m = self.fire_homing_missile();\n-        let loop_ = self.uv_loop();\n-        self.write_access.set_timeout(ms, &self.home, &loop_, cancel_write,\n-                                      &self.stream as *const _ as uint);\n-\n-        fn cancel_write(stream: uint) -> Option<BlockedTask> {\n-            let stream: &mut StreamWatcher = unsafe { mem::transmute(stream) };\n-            stream.cancel_write()\n-        }\n-    }\n-}\n-\n-impl HomingIO for PipeWatcher {\n-    fn home<'a>(&'a mut self) -> &'a mut HomeHandle { &mut self.home }\n-}\n-\n-impl UvHandle<uvll::uv_pipe_t> for PipeWatcher {\n-    fn uv_handle(&self) -> *mut uvll::uv_pipe_t { self.stream.handle }\n-}\n-\n-impl Drop for PipeWatcher {\n-    fn drop(&mut self) {\n-        let _m = self.fire_homing_missile();\n-        if !self.defused && self.refcount.decrement() {\n-            self.close();\n-        }\n-    }\n-}\n-\n-// PipeListener implementation and traits\n-\n-impl PipeListener {\n-    pub fn bind(io: &mut UvIoFactory, name: &CString)\n-        -> Result<Box<PipeListener>, UvError>\n-    {\n-        let pipe = PipeWatcher::new(io, false);\n-        match unsafe {\n-            uvll::uv_pipe_bind(pipe.handle(), name.as_ptr())\n-        } {\n-            0 => {\n-                // If successful, unwrap the PipeWatcher because we control how\n-                // we close the pipe differently. We can't rely on\n-                // StreamWatcher's default close method.\n-                let p = box PipeListener {\n-                    home: io.make_handle(),\n-                    pipe: pipe.unwrap(),\n-                };\n-                Ok(p.install())\n-            }\n-            n => Err(UvError(n))\n-        }\n-    }\n-}\n-\n-impl rtio::RtioUnixListener for PipeListener {\n-    fn listen(mut self: Box<PipeListener>)\n-              -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n-        let _m = self.fire_homing_missile();\n-\n-        // create the acceptor object from ourselves\n-        let acceptor = (box PipeAcceptor {\n-            handle: self.pipe,\n-            home: self.home.clone(),\n-            access: AcceptTimeout::new(),\n-            refcount: Refcount::new(),\n-        }).install();\n-        self.pipe = 0 as *mut _;\n-\n-        // FIXME: the 128 backlog should be configurable\n-        match unsafe { uvll::uv_listen(acceptor.handle, 128, listen_cb) } {\n-            0 => Ok(acceptor as Box<rtio::RtioUnixAcceptor + Send>),\n-            n => Err(uv_error_to_io_error(UvError(n))),\n-        }\n-    }\n-}\n-\n-impl HomingIO for PipeListener {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n-}\n-\n-impl UvHandle<uvll::uv_pipe_t> for PipeListener {\n-    fn uv_handle(&self) -> *mut uvll::uv_pipe_t { self.pipe }\n-}\n-\n-extern fn listen_cb(server: *mut uvll::uv_stream_t, status: libc::c_int) {\n-    assert!(status != uvll::ECANCELED);\n-\n-    let pipe: &mut PipeAcceptor = unsafe { UvHandle::from_uv_handle(&server) };\n-    let msg = match status {\n-        0 => {\n-            let loop_ = Loop::wrap(unsafe {\n-                uvll::get_loop_for_uv_handle(server)\n-            });\n-            let client = PipeWatcher::new_home(&loop_, pipe.home().clone(), false);\n-            assert_eq!(unsafe { uvll::uv_accept(server, client.handle()) }, 0);\n-            Ok(box client as Box<rtio::RtioPipe + Send>)\n-        }\n-        n => Err(uv_error_to_io_error(UvError(n)))\n-    };\n-\n-    // If we're running then we have exclusive access, so the unsafe_get() is ok\n-    unsafe { pipe.access.push(msg); }\n-}\n-\n-impl Drop for PipeListener {\n-    fn drop(&mut self) {\n-        if self.pipe.is_null() { return }\n-\n-        let _m = self.fire_homing_missile();\n-        self.close();\n-    }\n-}\n-\n-// PipeAcceptor implementation and traits\n-\n-impl rtio::RtioUnixAcceptor for PipeAcceptor {\n-    fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe + Send>> {\n-        let m = self.fire_homing_missile();\n-        let loop_ = self.uv_loop();\n-        self.access.accept(m, &loop_)\n-    }\n-\n-    fn set_timeout(&mut self, ms: Option<u64>) {\n-        let _m = self.fire_homing_missile();\n-        let loop_ = self.uv_loop();\n-        self.access.set_timeout(ms, &loop_, &self.home);\n-    }\n-\n-    fn clone(&self) -> Box<rtio::RtioUnixAcceptor + Send> {\n-        box PipeAcceptor {\n-            refcount: self.refcount.clone(),\n-            home: self.home.clone(),\n-            handle: self.handle,\n-            access: self.access.clone(),\n-        } as Box<rtio::RtioUnixAcceptor + Send>\n-    }\n-\n-    fn close_accept(&mut self) -> IoResult<()> {\n-        let m = self.fire_homing_missile();\n-        self.access.close(m);\n-        Ok(())\n-    }\n-}\n-\n-impl HomingIO for PipeAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n-}\n-\n-impl UvHandle<uvll::uv_pipe_t> for PipeAcceptor {\n-    fn uv_handle(&self) -> *mut uvll::uv_pipe_t { self.handle }\n-}\n-\n-impl Drop for PipeAcceptor {\n-    fn drop(&mut self) {\n-        let _m = self.fire_homing_missile();\n-        if self.refcount.decrement() {\n-            self.close();\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::rt::rtio::{RtioUnixListener, RtioUnixAcceptor, RtioPipe};\n-    use std::io::test::next_test_unix;\n-\n-    use super::{PipeWatcher, PipeListener};\n-    use super::super::local_loop;\n-\n-    #[test]\n-    fn connect_err() {\n-        match PipeWatcher::connect(local_loop(), &\"path/to/nowhere\".to_c_str(),\n-                                   None) {\n-            Ok(..) => fail!(),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn bind_err() {\n-        match PipeListener::bind(local_loop(), &\"path/to/nowhere\".to_c_str()) {\n-            Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.name(), \"EACCES\".to_string()),\n-        }\n-    }\n-\n-    #[test]\n-    fn bind() {\n-        let p = next_test_unix().to_c_str();\n-        match PipeListener::bind(local_loop(), &p) {\n-            Ok(..) => {}\n-            Err(..) => fail!(),\n-        }\n-    }\n-\n-    #[test] #[should_fail]\n-    fn bind_fail() {\n-        let p = next_test_unix().to_c_str();\n-        let _w = PipeListener::bind(local_loop(), &p).unwrap();\n-        fail!();\n-    }\n-\n-    #[test]\n-    fn connect() {\n-        let path = next_test_unix();\n-        let path2 = path.clone();\n-        let (tx, rx) = channel();\n-\n-        spawn(proc() {\n-            let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n-            let mut p = p.listen().ok().unwrap();\n-            tx.send(());\n-            let mut client = p.accept().ok().unwrap();\n-            let mut buf = [0];\n-            assert!(client.read(buf).ok().unwrap() == 1);\n-            assert_eq!(buf[0], 1);\n-            assert!(client.write([2]).is_ok());\n-        });\n-        rx.recv();\n-        let mut c = PipeWatcher::connect(local_loop(), &path.to_c_str(), None).unwrap();\n-        assert!(c.write([1]).is_ok());\n-        let mut buf = [0];\n-        assert!(c.read(buf).ok().unwrap() == 1);\n-        assert_eq!(buf[0], 2);\n-    }\n-\n-    #[test] #[should_fail]\n-    fn connect_fail() {\n-        let path = next_test_unix();\n-        let path2 = path.clone();\n-        let (tx, rx) = channel();\n-\n-        spawn(proc() {\n-            let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n-            let mut p = p.listen().ok().unwrap();\n-            tx.send(());\n-            drop(p.accept().ok().unwrap());\n-        });\n-        rx.recv();\n-        let _c = PipeWatcher::connect(local_loop(), &path.to_c_str(), None).unwrap();\n-        fail!()\n-\n-    }\n-}"}, {"sha": "31c9fdde68cd02a127679c1d9d856cd412b00c65", "filename": "src/librustuv/process.rs", "status": "removed", "additions": 0, "deletions": 324, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,324 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::c_int;\n-use libc;\n-use std::ptr;\n-use std::c_str::CString;\n-use std::rt::rtio;\n-use std::rt::rtio::IoResult;\n-use std::rt::task::BlockedTask;\n-\n-use homing::{HomingIO, HomeHandle};\n-use pipe::PipeWatcher;\n-use super::{UvHandle, UvError, uv_error_to_io_error,\n-            wait_until_woken_after, wakeup, Loop};\n-use timer::TimerWatcher;\n-use uvio::UvIoFactory;\n-use uvll;\n-\n-pub struct Process {\n-    handle: *mut uvll::uv_process_t,\n-    home: HomeHandle,\n-\n-    /// Task to wake up (may be null) for when the process exits\n-    to_wake: Option<BlockedTask>,\n-\n-    /// Collected from the exit_cb\n-    exit_status: Option<rtio::ProcessExit>,\n-\n-    /// Lazily initialized timeout timer\n-    timer: Option<Box<TimerWatcher>>,\n-    timeout_state: TimeoutState,\n-}\n-\n-enum TimeoutState {\n-    NoTimeout,\n-    TimeoutPending,\n-    TimeoutElapsed,\n-}\n-\n-impl Process {\n-    /// Spawn a new process inside the specified event loop.\n-    ///\n-    /// Returns either the corresponding process object or an error which\n-    /// occurred.\n-    pub fn spawn(io_loop: &mut UvIoFactory, cfg: rtio::ProcessConfig)\n-                -> Result<(Box<Process>, Vec<Option<PipeWatcher>>), UvError> {\n-        let mut io = vec![cfg.stdin, cfg.stdout, cfg.stderr];\n-        for slot in cfg.extra_io.iter() {\n-            io.push(*slot);\n-        }\n-        let mut stdio = Vec::<uvll::uv_stdio_container_t>::with_capacity(io.len());\n-        let mut ret_io = Vec::with_capacity(io.len());\n-        unsafe {\n-            stdio.set_len(io.len());\n-            for (slot, other) in stdio.iter_mut().zip(io.iter()) {\n-                let io = set_stdio(slot as *mut uvll::uv_stdio_container_t, other,\n-                                   io_loop);\n-                ret_io.push(io);\n-            }\n-        }\n-\n-        let ret = with_argv(cfg.program, cfg.args, |argv| {\n-            with_env(cfg.env, |envp| {\n-                let mut flags = 0;\n-                if cfg.uid.is_some() {\n-                    flags |= uvll::PROCESS_SETUID;\n-                }\n-                if cfg.gid.is_some() {\n-                    flags |= uvll::PROCESS_SETGID;\n-                }\n-                if cfg.detach {\n-                    flags |= uvll::PROCESS_DETACHED;\n-                }\n-                let mut options = uvll::uv_process_options_t {\n-                    exit_cb: on_exit,\n-                    file: unsafe { *argv },\n-                    args: argv,\n-                    env: envp,\n-                    cwd: match cfg.cwd {\n-                        Some(cwd) => cwd.as_ptr(),\n-                        None => ptr::null(),\n-                    },\n-                    flags: flags as libc::c_uint,\n-                    stdio_count: stdio.len() as libc::c_int,\n-                    stdio: stdio.as_mut_ptr(),\n-                    uid: cfg.uid.unwrap_or(0) as uvll::uv_uid_t,\n-                    gid: cfg.gid.unwrap_or(0) as uvll::uv_gid_t,\n-                };\n-\n-                let handle = UvHandle::alloc(None::<Process>, uvll::UV_PROCESS);\n-                let process = box Process {\n-                    handle: handle,\n-                    home: io_loop.make_handle(),\n-                    to_wake: None,\n-                    exit_status: None,\n-                    timer: None,\n-                    timeout_state: NoTimeout,\n-                };\n-                match unsafe {\n-                    uvll::uv_spawn(io_loop.uv_loop(), handle, &mut options)\n-                } {\n-                    0 => Ok(process.install()),\n-                    err => Err(UvError(err)),\n-                }\n-            })\n-        });\n-\n-        match ret {\n-            Ok(p) => Ok((p, ret_io)),\n-            Err(e) => Err(e),\n-        }\n-    }\n-\n-    pub fn kill(pid: libc::pid_t, signum: int) -> Result<(), UvError> {\n-        match unsafe {\n-            uvll::uv_kill(pid as libc::c_int, signum as libc::c_int)\n-        } {\n-            0 => Ok(()),\n-            n => Err(UvError(n))\n-        }\n-    }\n-}\n-\n-extern fn on_exit(handle: *mut uvll::uv_process_t,\n-                  exit_status: i64,\n-                  term_signal: libc::c_int) {\n-    let p: &mut Process = unsafe { UvHandle::from_uv_handle(&handle) };\n-\n-    assert!(p.exit_status.is_none());\n-    p.exit_status = Some(match term_signal {\n-        0 => rtio::ExitStatus(exit_status as int),\n-        n => rtio::ExitSignal(n as int),\n-    });\n-\n-    if p.to_wake.is_none() { return }\n-    wakeup(&mut p.to_wake);\n-}\n-\n-unsafe fn set_stdio(dst: *mut uvll::uv_stdio_container_t,\n-                    io: &rtio::StdioContainer,\n-                    io_loop: &mut UvIoFactory) -> Option<PipeWatcher> {\n-    match *io {\n-        rtio::Ignored => {\n-            uvll::set_stdio_container_flags(dst, uvll::STDIO_IGNORE);\n-            None\n-        }\n-        rtio::InheritFd(fd) => {\n-            uvll::set_stdio_container_flags(dst, uvll::STDIO_INHERIT_FD);\n-            uvll::set_stdio_container_fd(dst, fd);\n-            None\n-        }\n-        rtio::CreatePipe(readable, writable) => {\n-            let mut flags = uvll::STDIO_CREATE_PIPE as libc::c_int;\n-            if readable {\n-                flags |= uvll::STDIO_READABLE_PIPE as libc::c_int;\n-            }\n-            if writable {\n-                flags |= uvll::STDIO_WRITABLE_PIPE as libc::c_int;\n-            }\n-            let pipe = PipeWatcher::new(io_loop, false);\n-            uvll::set_stdio_container_flags(dst, flags);\n-            uvll::set_stdio_container_stream(dst, pipe.handle());\n-            Some(pipe)\n-        }\n-    }\n-}\n-\n-/// Converts the program and arguments to the argv array expected by libuv.\n-fn with_argv<T>(prog: &CString, args: &[CString],\n-                cb: |*const *const libc::c_char| -> T) -> T {\n-    let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n-\n-    // Convert the CStrings into an array of pointers. Note: the\n-    // lifetime of the various CStrings involved is guaranteed to be\n-    // larger than the lifetime of our invocation of cb, but this is\n-    // technically unsafe as the callback could leak these pointers\n-    // out of our scope.\n-    ptrs.push(prog.as_ptr());\n-    ptrs.extend(args.iter().map(|tmp| tmp.as_ptr()));\n-\n-    // Add a terminating null pointer (required by libc).\n-    ptrs.push(ptr::null());\n-\n-    cb(ptrs.as_ptr())\n-}\n-\n-/// Converts the environment to the env array expected by libuv\n-fn with_env<T>(env: Option<&[(&CString, &CString)]>,\n-               cb: |*const *const libc::c_char| -> T) -> T {\n-    // We can pass a char** for envp, which is a null-terminated array\n-    // of \"k=v\\0\" strings. Since we must create these strings locally,\n-    // yet expose a raw pointer to them, we create a temporary vector\n-    // to own the CStrings that outlives the call to cb.\n-    match env {\n-        Some(env) => {\n-            let mut tmps = Vec::with_capacity(env.len());\n-\n-            for pair in env.iter() {\n-                let mut kv = Vec::new();\n-                kv.push_all(pair.ref0().as_bytes_no_nul());\n-                kv.push('=' as u8);\n-                kv.push_all(pair.ref1().as_bytes()); // includes terminal \\0\n-                tmps.push(kv);\n-            }\n-\n-            // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n-            let mut ptrs: Vec<*const libc::c_char> =\n-                tmps.iter()\n-                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n-                    .collect();\n-            ptrs.push(ptr::null());\n-\n-            cb(ptrs.as_ptr())\n-        }\n-        _ => cb(ptr::null())\n-    }\n-}\n-\n-impl HomingIO for Process {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n-}\n-\n-impl UvHandle<uvll::uv_process_t> for Process {\n-    fn uv_handle(&self) -> *mut uvll::uv_process_t { self.handle }\n-}\n-\n-impl rtio::RtioProcess for Process {\n-    fn id(&self) -> libc::pid_t {\n-        unsafe { uvll::process_pid(self.handle) as libc::pid_t }\n-    }\n-\n-    fn kill(&mut self, signal: int) -> IoResult<()> {\n-        let _m = self.fire_homing_missile();\n-        match unsafe {\n-            uvll::uv_process_kill(self.handle, signal as libc::c_int)\n-        } {\n-            0 => Ok(()),\n-            err => Err(uv_error_to_io_error(UvError(err)))\n-        }\n-    }\n-\n-    fn wait(&mut self) -> IoResult<rtio::ProcessExit> {\n-        // Make sure (on the home scheduler) that we have an exit status listed\n-        let _m = self.fire_homing_missile();\n-        match self.exit_status {\n-            Some(status) => return Ok(status),\n-            None => {}\n-        }\n-\n-        // If there's no exit code previously listed, then the process's exit\n-        // callback has yet to be invoked. We just need to deschedule ourselves\n-        // and wait to be reawoken.\n-        match self.timeout_state {\n-            NoTimeout | TimeoutPending => {\n-                wait_until_woken_after(&mut self.to_wake, &self.uv_loop(), || {});\n-            }\n-            TimeoutElapsed => {}\n-        }\n-\n-        // If there's still no exit status listed, then we timed out, and we\n-        // need to return.\n-        match self.exit_status {\n-            Some(status) => Ok(status),\n-            None => Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n-        }\n-    }\n-\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let _m = self.fire_homing_missile();\n-        self.timeout_state = NoTimeout;\n-        let ms = match timeout {\n-            Some(ms) => ms,\n-            None => {\n-                match self.timer {\n-                    Some(ref mut timer) => timer.stop(),\n-                    None => {}\n-                }\n-                return\n-            }\n-        };\n-        if self.timer.is_none() {\n-            let loop_ = Loop::wrap(unsafe {\n-                uvll::get_loop_for_uv_handle(self.uv_handle())\n-            });\n-            let mut timer = box TimerWatcher::new_home(&loop_, self.home().clone());\n-            unsafe {\n-                timer.set_data(self as *mut _);\n-            }\n-            self.timer = Some(timer);\n-        }\n-\n-        let timer = self.timer.as_mut().unwrap();\n-        timer.stop();\n-        timer.start(timer_cb, ms, 0);\n-        self.timeout_state = TimeoutPending;\n-\n-        extern fn timer_cb(timer: *mut uvll::uv_timer_t) {\n-            let p: &mut Process = unsafe {\n-                &mut *(uvll::get_data_for_uv_handle(timer) as *mut Process)\n-            };\n-            p.timeout_state = TimeoutElapsed;\n-            match p.to_wake.take() {\n-                Some(task) => { let _t = task.wake().map(|t| t.reawaken()); }\n-                None => {}\n-            }\n-        }\n-    }\n-}\n-\n-impl Drop for Process {\n-    fn drop(&mut self) {\n-        let _m = self.fire_homing_missile();\n-        assert!(self.to_wake.is_none());\n-        self.close();\n-    }\n-}"}, {"sha": "6a0f2a27b184d23d22f61878af0dadde925226e3", "filename": "src/librustuv/queue.rs", "status": "removed", "additions": 0, "deletions": 185, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,185 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A concurrent queue used to signal remote event loops\n-//!\n-//! This queue implementation is used to send tasks among event loops. This is\n-//! backed by a multi-producer/single-consumer queue from libstd and uv_async_t\n-//! handles (to wake up a remote event loop).\n-//!\n-//! The uv_async_t is stored next to the event loop, so in order to not keep the\n-//! event loop alive we use uv_ref and uv_unref in order to control when the\n-//! async handle is active or not.\n-\n-#![allow(dead_code)]\n-\n-use alloc::arc::Arc;\n-use libc::c_void;\n-use std::mem;\n-use std::rt::mutex::NativeMutex;\n-use std::rt::task::BlockedTask;\n-use std::sync::mpsc_queue as mpsc;\n-\n-use async::AsyncWatcher;\n-use super::{Loop, UvHandle};\n-use uvll;\n-\n-enum Message {\n-    Task(BlockedTask),\n-    Increment,\n-    Decrement,\n-}\n-\n-struct State {\n-    handle: *mut uvll::uv_async_t,\n-    lock: NativeMutex, // see comments in async_cb for why this is needed\n-    queue: mpsc::Queue<Message>,\n-}\n-\n-/// This structure is intended to be stored next to the event loop, and it is\n-/// used to create new `Queue` structures.\n-pub struct QueuePool {\n-    queue: Arc<State>,\n-    refcnt: uint,\n-}\n-\n-/// This type is used to send messages back to the original event loop.\n-pub struct Queue {\n-    queue: Arc<State>,\n-}\n-\n-extern fn async_cb(handle: *mut uvll::uv_async_t) {\n-    let pool: &mut QueuePool = unsafe {\n-        mem::transmute(uvll::get_data_for_uv_handle(handle))\n-    };\n-    let state: &State = &*pool.queue;\n-\n-    // Remember that there is no guarantee about how many times an async\n-    // callback is called with relation to the number of sends, so process the\n-    // entire queue in a loop.\n-    loop {\n-        match state.queue.pop() {\n-            mpsc::Data(Task(task)) => {\n-                let _ = task.wake().map(|t| t.reawaken());\n-            }\n-            mpsc::Data(Increment) => unsafe {\n-                if pool.refcnt == 0 {\n-                    uvll::uv_ref(state.handle);\n-                }\n-                pool.refcnt += 1;\n-            },\n-            mpsc::Data(Decrement) => unsafe {\n-                pool.refcnt -= 1;\n-                if pool.refcnt == 0 {\n-                    uvll::uv_unref(state.handle);\n-                }\n-            },\n-            mpsc::Empty | mpsc::Inconsistent => break\n-        };\n-    }\n-\n-    // If the refcount is now zero after processing the queue, then there is no\n-    // longer a reference on the async handle and it is possible that this event\n-    // loop can exit. What we're not guaranteed, however, is that a producer in\n-    // the middle of dropping itself is yet done with the handle. It could be\n-    // possible that we saw their Decrement message but they have yet to signal\n-    // on the async handle. If we were to return immediately, the entire uv loop\n-    // could be destroyed meaning the call to uv_async_send would abort()\n-    //\n-    // In order to fix this, an OS mutex is used to wait for the other end to\n-    // finish before we continue. The drop block on a handle will acquire a\n-    // mutex and then drop it after both the push and send have been completed.\n-    // If we acquire the mutex here, then we are guaranteed that there are no\n-    // longer any senders which are holding on to their handles, so we can\n-    // safely allow the event loop to exit.\n-    if pool.refcnt == 0 {\n-        unsafe {\n-            let _l = state.lock.lock();\n-        }\n-    }\n-}\n-\n-impl QueuePool {\n-    pub fn new(loop_: &mut Loop) -> Box<QueuePool> {\n-        let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n-        let state = Arc::new(State {\n-            handle: handle,\n-            lock: unsafe {NativeMutex::new()},\n-            queue: mpsc::Queue::new(),\n-        });\n-        let mut q = box QueuePool {\n-            refcnt: 0,\n-            queue: state,\n-        };\n-\n-        unsafe {\n-            assert_eq!(uvll::uv_async_init(loop_.handle, handle, async_cb), 0);\n-            uvll::uv_unref(handle);\n-            let data = &mut *q as *mut QueuePool as *mut c_void;\n-            uvll::set_data_for_uv_handle(handle, data);\n-        }\n-\n-        return q;\n-    }\n-\n-    pub fn queue(&mut self) -> Queue {\n-        unsafe {\n-            if self.refcnt == 0 {\n-                uvll::uv_ref(self.queue.handle);\n-            }\n-            self.refcnt += 1;\n-        }\n-        Queue { queue: self.queue.clone() }\n-    }\n-\n-    pub fn handle(&self) -> *mut uvll::uv_async_t { self.queue.handle }\n-}\n-\n-impl Queue {\n-    pub fn push(&mut self, task: BlockedTask) {\n-        self.queue.queue.push(Task(task));\n-        unsafe { uvll::uv_async_send(self.queue.handle); }\n-    }\n-}\n-\n-impl Clone for Queue {\n-    fn clone(&self) -> Queue {\n-        // Push a request to increment on the queue, but there's no need to\n-        // signal the event loop to process it at this time. We're guaranteed\n-        // that the count is at least one (because we have a queue right here),\n-        // and if the queue is dropped later on it'll see the increment for the\n-        // decrement anyway.\n-        self.queue.queue.push(Increment);\n-        Queue { queue: self.queue.clone() }\n-    }\n-}\n-\n-impl Drop for Queue {\n-    fn drop(&mut self) {\n-        // See the comments in the async_cb function for why there is a lock\n-        // that is acquired only on a drop.\n-        unsafe {\n-            let _l = self.queue.lock.lock();\n-            self.queue.queue.push(Decrement);\n-            uvll::uv_async_send(self.queue.handle);\n-        }\n-    }\n-}\n-\n-impl Drop for State {\n-    fn drop(&mut self) {\n-        unsafe {\n-            uvll::uv_close(self.handle, mem::transmute(0u));\n-            // Note that this does *not* free the handle, that is the\n-            // responsibility of the caller because the uv loop must be closed\n-            // before we deallocate this uv handle.\n-        }\n-    }\n-}"}, {"sha": "7016ece642725033313458afc6650c07c2eed8af", "filename": "src/librustuv/rc.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Frc.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,50 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// Simple refcount structure for cloning handles\n-///\n-/// This is meant to be an unintrusive solution to cloning handles in rustuv.\n-/// The handles themselves shouldn't be sharing memory because there are bits of\n-/// state in the rust objects which shouldn't be shared across multiple users of\n-/// the same underlying uv object, hence Rc is not used and this simple counter\n-/// should suffice.\n-\n-use alloc::arc::Arc;\n-use std::cell::UnsafeCell;\n-\n-pub struct Refcount {\n-    rc: Arc<UnsafeCell<uint>>,\n-}\n-\n-impl Refcount {\n-    /// Creates a new refcount of 1\n-    pub fn new() -> Refcount {\n-        Refcount { rc: Arc::new(UnsafeCell::new(1)) }\n-    }\n-\n-    fn increment(&self) {\n-        unsafe { *self.rc.get() += 1; }\n-    }\n-\n-    /// Returns whether the refcount just hit 0 or not\n-    pub fn decrement(&self) -> bool {\n-        unsafe {\n-            *self.rc.get() -= 1;\n-            *self.rc.get() == 0\n-        }\n-    }\n-}\n-\n-impl Clone for Refcount {\n-    fn clone(&self) -> Refcount {\n-        self.increment();\n-        Refcount { rc: self.rc.clone() }\n-    }\n-}"}, {"sha": "49ef4e9a24bccad8f1ce42d507539e1c616b386b", "filename": "src/librustuv/signal.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,68 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::c_int;\n-use std::rt::rtio::{RtioSignal, Callback};\n-\n-use homing::{HomingIO, HomeHandle};\n-use super::{UvError, UvHandle};\n-use uvll;\n-use uvio::UvIoFactory;\n-\n-pub struct SignalWatcher {\n-    handle: *mut uvll::uv_signal_t,\n-    home: HomeHandle,\n-\n-    cb: Box<Callback + Send>,\n-}\n-\n-impl SignalWatcher {\n-    pub fn new(io: &mut UvIoFactory, signum: int, cb: Box<Callback + Send>)\n-               -> Result<Box<SignalWatcher>, UvError> {\n-        let s = box SignalWatcher {\n-            handle: UvHandle::alloc(None::<SignalWatcher>, uvll::UV_SIGNAL),\n-            home: io.make_handle(),\n-            cb: cb,\n-        };\n-        assert_eq!(unsafe {\n-            uvll::uv_signal_init(io.uv_loop(), s.handle)\n-        }, 0);\n-\n-        match unsafe {\n-            uvll::uv_signal_start(s.handle, signal_cb, signum as c_int)\n-        } {\n-            0 => Ok(s.install()),\n-            n => Err(UvError(n)),\n-        }\n-\n-    }\n-}\n-\n-extern fn signal_cb(handle: *mut uvll::uv_signal_t, _signum: c_int) {\n-    let s: &mut SignalWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n-    let _ = s.cb.call();\n-}\n-\n-impl HomingIO for SignalWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n-}\n-\n-impl UvHandle<uvll::uv_signal_t> for SignalWatcher {\n-    fn uv_handle(&self) -> *mut uvll::uv_signal_t { self.handle }\n-}\n-\n-impl RtioSignal for SignalWatcher {}\n-\n-impl Drop for SignalWatcher {\n-    fn drop(&mut self) {\n-        let _m = self.fire_homing_missile();\n-        self.close();\n-    }\n-}"}, {"sha": "de49fd6cf0986539483a728bc68ad926a4c36f04", "filename": "src/librustuv/stream.rs", "status": "removed", "additions": 0, "deletions": 281, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,281 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::{c_int, size_t, ssize_t};\n-use std::mem;\n-use std::ptr;\n-use std::rt::task::BlockedTask;\n-\n-use Loop;\n-use super::{UvError, Buf, slice_to_uv_buf, Request, wait_until_woken_after,\n-            ForbidUnwind, wakeup};\n-use uvll;\n-\n-// This is a helper structure which is intended to get embedded into other\n-// Watcher structures. This structure will retain a handle to the underlying\n-// uv_stream_t instance, and all I/O operations assume that it's already located\n-// on the appropriate scheduler.\n-pub struct StreamWatcher {\n-    pub handle: *mut uvll::uv_stream_t,\n-\n-    // Cache the last used uv_write_t so we don't have to allocate a new one on\n-    // every call to uv_write(). Ideally this would be a stack-allocated\n-    // structure, but currently we don't have mappings for all the structures\n-    // defined in libuv, so we're forced to malloc this.\n-    last_write_req: Option<Request>,\n-\n-    blocked_writer: Option<BlockedTask>,\n-}\n-\n-struct ReadContext {\n-    buf: Option<Buf>,\n-    result: ssize_t,\n-    task: Option<BlockedTask>,\n-}\n-\n-struct WriteContext {\n-    result: c_int,\n-    stream: *mut StreamWatcher,\n-    data: Option<Vec<u8>>,\n-}\n-\n-impl StreamWatcher {\n-    // Creates a new helper structure which should be then embedded into another\n-    // watcher. This provides the generic read/write methods on streams.\n-    //\n-    // This structure will *not* close the stream when it is dropped. It is up\n-    // to the enclosure structure to be sure to call the close method (which\n-    // will block the task). Note that this is also required to prevent memory\n-    // leaks.\n-    //\n-    // It should also be noted that the `data` field of the underlying uv handle\n-    // will be manipulated on each of the methods called on this watcher.\n-    // Wrappers should ensure to always reset the field to an appropriate value\n-    // if they rely on the field to perform an action.\n-    pub fn new(stream: *mut uvll::uv_stream_t,\n-               init: bool) -> StreamWatcher {\n-        if init {\n-            unsafe { uvll::set_data_for_uv_handle(stream, 0 as *mut int) }\n-        }\n-        StreamWatcher {\n-            handle: stream,\n-            last_write_req: None,\n-            blocked_writer: None,\n-        }\n-    }\n-\n-    pub fn read(&mut self, buf: &mut [u8]) -> Result<uint, UvError> {\n-        // This read operation needs to get canceled on an unwind via libuv's\n-        // uv_read_stop function\n-        let _f = ForbidUnwind::new(\"stream read\");\n-\n-        let mut rcx = ReadContext {\n-            buf: Some(slice_to_uv_buf(buf)),\n-            // if the read is canceled, we'll see eof, otherwise this will get\n-            // overwritten\n-            result: 0,\n-            task: None,\n-        };\n-        // When reading a TTY stream on windows, libuv will invoke alloc_cb\n-        // immediately as part of the call to alloc_cb. What this means is that\n-        // we must be ready for this to happen (by setting the data in the uv\n-        // handle). In theory this otherwise doesn't need to happen until after\n-        // the read is successfully started.\n-        unsafe { uvll::set_data_for_uv_handle(self.handle, &mut rcx) }\n-\n-        // Send off the read request, but don't block until we're sure that the\n-        // read request is queued.\n-        let ret = match unsafe {\n-            uvll::uv_read_start(self.handle, alloc_cb, read_cb)\n-        } {\n-            0 => {\n-                let loop_ = unsafe { uvll::get_loop_for_uv_handle(self.handle) };\n-                wait_until_woken_after(&mut rcx.task, &Loop::wrap(loop_), || {});\n-                match rcx.result {\n-                    n if n < 0 => Err(UvError(n as c_int)),\n-                    n => Ok(n as uint),\n-                }\n-            }\n-            n => Err(UvError(n))\n-        };\n-        // Make sure a read cancellation sees that there's no pending read\n-        unsafe { uvll::set_data_for_uv_handle(self.handle, 0 as *mut int) }\n-        return ret;\n-    }\n-\n-    pub fn cancel_read(&mut self, reason: ssize_t) -> Option<BlockedTask> {\n-        // When we invoke uv_read_stop, it cancels the read and alloc\n-        // callbacks. We need to manually wake up a pending task (if one was\n-        // present).\n-        assert_eq!(unsafe { uvll::uv_read_stop(self.handle) }, 0);\n-        let data = unsafe {\n-            let data = uvll::get_data_for_uv_handle(self.handle);\n-            if data.is_null() { return None }\n-            uvll::set_data_for_uv_handle(self.handle, 0 as *mut int);\n-            &mut *(data as *mut ReadContext)\n-        };\n-        data.result = reason;\n-        data.task.take()\n-    }\n-\n-    pub fn write(&mut self, buf: &[u8], may_timeout: bool) -> Result<(), UvError> {\n-        // The ownership of the write request is dubious if this function\n-        // unwinds. I believe that if the write_cb fails to re-schedule the task\n-        // then the write request will be leaked.\n-        let _f = ForbidUnwind::new(\"stream write\");\n-\n-        // Prepare the write request, either using a cached one or allocating a\n-        // new one\n-        let mut req = match self.last_write_req.take() {\n-            Some(req) => req, None => Request::new(uvll::UV_WRITE),\n-        };\n-        req.set_data(ptr::null_mut::<()>());\n-\n-        // And here's where timeouts get a little interesting. Currently, libuv\n-        // does not support canceling an in-flight write request. Consequently,\n-        // when a write timeout expires, there's not much we can do other than\n-        // detach the sleeping task from the write request itself. Semantically,\n-        // this means that the write request will complete asynchronously, but\n-        // the calling task will return error (because the write timed out).\n-        //\n-        // There is special wording in the documentation of set_write_timeout()\n-        // indicating that this is a plausible failure scenario, and this\n-        // function is why that wording exists.\n-        //\n-        // Implementation-wise, we must be careful when passing a buffer down to\n-        // libuv. Most of this implementation avoids allocations because of the\n-        // blocking guarantee (all stack local variables are valid for the\n-        // entire read/write request). If our write request can be timed out,\n-        // however, we must heap allocate the data and pass that to the libuv\n-        // functions instead. The reason for this is that if we time out and\n-        // return, there's no guarantee that `buf` is a valid buffer any more.\n-        //\n-        // To do this, the write context has an optionally owned vector of\n-        // bytes.\n-        let data = if may_timeout {Some(buf.to_vec())} else {None};\n-        let uv_buf = if may_timeout {\n-            slice_to_uv_buf(data.as_ref().unwrap().as_slice())\n-        } else {\n-            slice_to_uv_buf(buf)\n-        };\n-\n-        // Send off the request, but be careful to not block until we're sure\n-        // that the write request is queued. If the request couldn't be queued,\n-        // then we should return immediately with an error.\n-        match unsafe {\n-            uvll::uv_write(req.handle, self.handle, [uv_buf], write_cb)\n-        } {\n-            0 => {\n-                let mut wcx = WriteContext {\n-                    result: uvll::ECANCELED,\n-                    stream: self as *mut _,\n-                    data: data,\n-                };\n-                req.defuse(); // uv callback now owns this request\n-\n-                let loop_ = unsafe { uvll::get_loop_for_uv_handle(self.handle) };\n-                wait_until_woken_after(&mut self.blocked_writer,\n-                                       &Loop::wrap(loop_), || {\n-                    req.set_data(&mut wcx);\n-                });\n-\n-                if wcx.result != uvll::ECANCELED {\n-                    self.last_write_req = Some(Request::wrap(req.handle));\n-                    return match wcx.result {\n-                        0 => Ok(()),\n-                        n => Err(UvError(n)),\n-                    }\n-                }\n-\n-                // This is the second case where canceling an in-flight write\n-                // gets interesting. If we've been canceled (no one reset our\n-                // result), then someone still needs to free the request, and\n-                // someone still needs to free the allocate buffer.\n-                //\n-                // To take care of this, we swap out the stack-allocated write\n-                // context for a heap-allocated context, transferring ownership\n-                // of everything to the write_cb. Libuv guarantees that this\n-                // callback will be invoked at some point, and the callback will\n-                // be responsible for deallocating these resources.\n-                //\n-                // Note that we don't cache this write request back in the\n-                // stream watcher because we no longer have ownership of it, and\n-                // we never will.\n-                let mut new_wcx = box WriteContext {\n-                    result: 0,\n-                    stream: 0 as *mut StreamWatcher,\n-                    data: wcx.data.take(),\n-                };\n-                unsafe {\n-                    req.set_data(&mut *new_wcx);\n-                    mem::forget(new_wcx);\n-                }\n-                Err(UvError(wcx.result))\n-            }\n-            n => Err(UvError(n)),\n-        }\n-    }\n-\n-    pub fn cancel_write(&mut self) -> Option<BlockedTask> {\n-        self.blocked_writer.take()\n-    }\n-}\n-\n-// This allocation callback expects to be invoked once and only once. It will\n-// unwrap the buffer in the ReadContext stored in the stream and return it. This\n-// will fail if it is called more than once.\n-extern fn alloc_cb(stream: *mut uvll::uv_stream_t, _hint: size_t, buf: *mut Buf) {\n-    uvdebug!(\"alloc_cb\");\n-    unsafe {\n-        let rcx: &mut ReadContext =\n-            mem::transmute(uvll::get_data_for_uv_handle(stream));\n-        *buf = rcx.buf.take().expect(\"stream alloc_cb called more than once\");\n-    }\n-}\n-\n-// When a stream has read some data, we will always forcibly stop reading and\n-// return all the data read (even if it didn't fill the whole buffer).\n-extern fn read_cb(handle: *mut uvll::uv_stream_t, nread: ssize_t,\n-                  _buf: *const Buf) {\n-    uvdebug!(\"read_cb {}\", nread);\n-    assert!(nread != uvll::ECANCELED as ssize_t);\n-    let rcx: &mut ReadContext = unsafe {\n-        mem::transmute(uvll::get_data_for_uv_handle(handle))\n-    };\n-    // Stop reading so that no read callbacks are\n-    // triggered before the user calls `read` again.\n-    // FIXME: Is there a performance impact to calling\n-    // stop here?\n-    unsafe { assert_eq!(uvll::uv_read_stop(handle), 0); }\n-    rcx.result = nread;\n-\n-    wakeup(&mut rcx.task);\n-}\n-\n-// Unlike reading, the WriteContext is stored in the uv_write_t request. Like\n-// reading, however, all this does is wake up the blocked task after squirreling\n-// away the error code as a result.\n-extern fn write_cb(req: *mut uvll::uv_write_t, status: c_int) {\n-    let mut req = Request::wrap(req);\n-    // Remember to not free the request because it is re-used between writes on\n-    // the same stream.\n-    let wcx: &mut WriteContext = unsafe { req.get_data() };\n-    wcx.result = status;\n-\n-    // If the stream is present, we haven't timed out, otherwise we acquire\n-    // ownership of everything and then deallocate it all at once.\n-    if wcx.stream as uint != 0 {\n-        req.defuse();\n-        let stream: &mut StreamWatcher = unsafe { &mut *wcx.stream };\n-        wakeup(&mut stream.blocked_writer);\n-    } else {\n-        let _wcx: Box<WriteContext> = unsafe { mem::transmute(wcx) };\n-    }\n-}"}, {"sha": "88267c0ac45acc614bcb451b6486aa252ec74e62", "filename": "src/librustuv/timeout.rs", "status": "removed", "additions": 0, "deletions": 411, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,411 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::c_int;\n-use std::mem;\n-use std::rt::task::BlockedTask;\n-use std::rt::rtio::IoResult;\n-\n-use access;\n-use homing::{HomeHandle, HomingMissile};\n-use timer::TimerWatcher;\n-use uvll;\n-use uvio::UvIoFactory;\n-use {Loop, UvError, uv_error_to_io_error, Request, wakeup};\n-use {UvHandle, wait_until_woken_after};\n-\n-/// Management of a timeout when gaining access to a portion of a duplex stream.\n-pub struct AccessTimeout<T> {\n-    state: TimeoutState,\n-    timer: Option<Box<TimerWatcher>>,\n-    pub access: access::Access<T>,\n-}\n-\n-pub struct Guard<'a, T:'static> {\n-    state: &'a mut TimeoutState,\n-    pub access: access::Guard<'a, T>,\n-    pub can_timeout: bool,\n-}\n-\n-#[deriving(PartialEq)]\n-enum TimeoutState {\n-    NoTimeout,\n-    TimeoutPending(ClientState),\n-    TimedOut,\n-}\n-\n-#[deriving(PartialEq)]\n-enum ClientState {\n-    NoWaiter,\n-    AccessPending,\n-    RequestPending,\n-}\n-\n-struct TimerContext {\n-    timeout: *mut AccessTimeout<()>,\n-    callback: fn(*mut AccessTimeout<()>, &TimerContext),\n-    user_unblock: fn(uint) -> Option<BlockedTask>,\n-    user_payload: uint,\n-}\n-\n-impl<T: Send> AccessTimeout<T> {\n-    pub fn new(data: T) -> AccessTimeout<T> {\n-        AccessTimeout {\n-            state: NoTimeout,\n-            timer: None,\n-            access: access::Access::new(data),\n-        }\n-    }\n-\n-    /// Grants access to half of a duplex stream, timing out if necessary.\n-    ///\n-    /// On success, Ok(Guard) is returned and access has been granted to the\n-    /// stream. If a timeout occurs, then Err is returned with an appropriate\n-    /// error.\n-    pub fn grant<'a>(&'a mut self, m: HomingMissile) -> IoResult<Guard<'a, T>> {\n-        // First, flag that we're attempting to acquire access. This will allow\n-        // us to cancel the pending grant if we timeout out while waiting for a\n-        // grant.\n-        match self.state {\n-            NoTimeout => {},\n-            TimeoutPending(ref mut client) => *client = AccessPending,\n-            TimedOut => return Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n-        }\n-        let access = self.access.grant(self as *mut _ as uint, m);\n-\n-        // After acquiring the grant, we need to flag ourselves as having a\n-        // pending request so the timeout knows to cancel the request.\n-        let can_timeout = match self.state {\n-            NoTimeout => false,\n-            TimeoutPending(ref mut client) => { *client = RequestPending; true }\n-            TimedOut => return Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n-        };\n-\n-        Ok(Guard {\n-            access: access,\n-            state: &mut self.state,\n-            can_timeout: can_timeout\n-        })\n-    }\n-\n-    pub fn timed_out(&self) -> bool {\n-        match self.state {\n-            TimedOut => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Sets the pending timeout to the value specified.\n-    ///\n-    /// The home/loop variables are used to construct a timer if one has not\n-    /// been previously constructed.\n-    ///\n-    /// The callback will be invoked if the timeout elapses, and the data of\n-    /// the time will be set to `data`.\n-    pub fn set_timeout(&mut self, ms: Option<u64>,\n-                       home: &HomeHandle,\n-                       loop_: &Loop,\n-                       cb: fn(uint) -> Option<BlockedTask>,\n-                       data: uint) {\n-        self.state = NoTimeout;\n-        let ms = match ms {\n-            Some(ms) => ms,\n-            None => return match self.timer {\n-                Some(ref mut t) => t.stop(),\n-                None => {}\n-            }\n-        };\n-\n-        // If we have a timeout, lazily initialize the timer which will be used\n-        // to fire when the timeout runs out.\n-        if self.timer.is_none() {\n-            let mut timer = box TimerWatcher::new_home(loop_, home.clone());\n-            let mut cx = box TimerContext {\n-                timeout: self as *mut _ as *mut AccessTimeout<()>,\n-                callback: real_cb::<T>,\n-                user_unblock: cb,\n-                user_payload: data,\n-            };\n-            unsafe {\n-                timer.set_data(&mut *cx);\n-                mem::forget(cx);\n-            }\n-            self.timer = Some(timer);\n-        }\n-\n-        let timer = self.timer.as_mut().unwrap();\n-        unsafe {\n-            let cx = uvll::get_data_for_uv_handle(timer.handle);\n-            let cx = cx as *mut TimerContext;\n-            (*cx).user_unblock = cb;\n-            (*cx).user_payload = data;\n-        }\n-        timer.stop();\n-        timer.start(timer_cb, ms, 0);\n-        self.state = TimeoutPending(NoWaiter);\n-\n-        extern fn timer_cb(timer: *mut uvll::uv_timer_t) {\n-            let cx: &TimerContext = unsafe {\n-                &*(uvll::get_data_for_uv_handle(timer) as *const TimerContext)\n-            };\n-            (cx.callback)(cx.timeout, cx);\n-        }\n-\n-        fn real_cb<T: Send>(timeout: *mut AccessTimeout<()>, cx: &TimerContext) {\n-            let timeout = timeout as *mut AccessTimeout<T>;\n-            let me = unsafe { &mut *timeout };\n-\n-            match mem::replace(&mut me.state, TimedOut) {\n-                TimedOut | NoTimeout => unreachable!(),\n-                TimeoutPending(NoWaiter) => {}\n-                TimeoutPending(AccessPending) => {\n-                    match unsafe { me.access.dequeue(me as *mut _ as uint) } {\n-                        Some(task) => task.reawaken(),\n-                        None => unreachable!(),\n-                    }\n-                }\n-                TimeoutPending(RequestPending) => {\n-                    match (cx.user_unblock)(cx.user_payload) {\n-                        Some(task) => task.reawaken(),\n-                        None => unreachable!(),\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<T: Send> Clone for AccessTimeout<T> {\n-    fn clone(&self) -> AccessTimeout<T> {\n-        AccessTimeout {\n-            access: self.access.clone(),\n-            state: NoTimeout,\n-            timer: None,\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<'a, T> Drop for Guard<'a, T> {\n-    fn drop(&mut self) {\n-        match *self.state {\n-            TimeoutPending(NoWaiter) | TimeoutPending(AccessPending) =>\n-                unreachable!(),\n-\n-            NoTimeout | TimedOut => {}\n-            TimeoutPending(RequestPending) => {\n-                *self.state = TimeoutPending(NoWaiter);\n-            }\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for AccessTimeout<T> {\n-    fn drop(&mut self) {\n-        match self.timer {\n-            Some(ref timer) => unsafe {\n-                let data = uvll::get_data_for_uv_handle(timer.handle);\n-                let _data: Box<TimerContext> = mem::transmute(data);\n-            },\n-            None => {}\n-        }\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Connect timeouts\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct ConnectCtx {\n-    pub status: c_int,\n-    pub task: Option<BlockedTask>,\n-    pub timer: Option<Box<TimerWatcher>>,\n-}\n-\n-impl ConnectCtx {\n-    pub fn connect<T>(\n-        mut self, obj: T, timeout: Option<u64>, io: &mut UvIoFactory,\n-        f: |&Request, &T, uvll::uv_connect_cb| -> c_int\n-    ) -> Result<T, UvError> {\n-        let mut req = Request::new(uvll::UV_CONNECT);\n-        let r = f(&req, &obj, connect_cb);\n-        return match r {\n-            0 => {\n-                req.defuse(); // uv callback now owns this request\n-                match timeout {\n-                    Some(t) => {\n-                        let mut timer = TimerWatcher::new(io);\n-                        timer.start(timer_cb, t, 0);\n-                        self.timer = Some(timer);\n-                    }\n-                    None => {}\n-                }\n-                wait_until_woken_after(&mut self.task, &io.loop_, || {\n-                    let data = &self as *const _ as *mut ConnectCtx;\n-                    match self.timer {\n-                        Some(ref mut timer) => unsafe { timer.set_data(data) },\n-                        None => {}\n-                    }\n-                    req.set_data(data);\n-                });\n-                // Make sure an erroneously fired callback doesn't have access\n-                // to the context any more.\n-                req.set_data(0 as *mut int);\n-\n-                // If we failed because of a timeout, drop the TcpWatcher as\n-                // soon as possible because it's data is now set to null and we\n-                // want to cancel the callback ASAP.\n-                match self.status {\n-                    0 => Ok(obj),\n-                    n => { drop(obj); Err(UvError(n)) }\n-                }\n-            }\n-            n => Err(UvError(n))\n-        };\n-\n-        extern fn timer_cb(handle: *mut uvll::uv_timer_t) {\n-            // Don't close the corresponding tcp request, just wake up the task\n-            // and let RAII take care of the pending watcher.\n-            let cx: &mut ConnectCtx = unsafe {\n-                &mut *(uvll::get_data_for_uv_handle(handle) as *mut ConnectCtx)\n-            };\n-            cx.status = uvll::ECANCELED;\n-            wakeup(&mut cx.task);\n-        }\n-\n-        extern fn connect_cb(req: *mut uvll::uv_connect_t, status: c_int) {\n-            // This callback can be invoked with ECANCELED if the watcher is\n-            // closed by the timeout callback. In that case we just want to free\n-            // the request and be along our merry way.\n-            let req = Request::wrap(req);\n-            if status == uvll::ECANCELED { return }\n-\n-            // Apparently on windows when the handle is closed this callback may\n-            // not be invoked with ECANCELED but rather another error code.\n-            // Either ways, if the data is null, then our timeout has expired\n-            // and there's nothing we can do.\n-            let data = unsafe { uvll::get_data_for_req(req.handle) };\n-            if data.is_null() { return }\n-\n-            let cx: &mut ConnectCtx = unsafe { &mut *(data as *mut ConnectCtx) };\n-            cx.status = status;\n-            match cx.timer {\n-                Some(ref mut t) => t.stop(),\n-                None => {}\n-            }\n-            // Note that the timer callback doesn't cancel the connect request\n-            // (that's the job of uv_close()), so it's possible for this\n-            // callback to get triggered after the timeout callback fires, but\n-            // before the task wakes up. In that case, we did indeed\n-            // successfully connect, but we don't need to wake someone up. We\n-            // updated the status above (correctly so), and the task will pick\n-            // up on this when it wakes up.\n-            if cx.task.is_some() {\n-                wakeup(&mut cx.task);\n-            }\n-        }\n-    }\n-}\n-\n-pub struct AcceptTimeout<T> {\n-    access: AccessTimeout<AcceptorState<T>>,\n-}\n-\n-struct AcceptorState<T> {\n-    blocked_acceptor: Option<BlockedTask>,\n-    pending: Vec<IoResult<T>>,\n-}\n-\n-impl<T: Send> AcceptTimeout<T> {\n-    pub fn new() -> AcceptTimeout<T> {\n-        AcceptTimeout {\n-            access: AccessTimeout::new(AcceptorState {\n-                blocked_acceptor: None,\n-                pending: Vec::new(),\n-            })\n-        }\n-    }\n-\n-    pub fn accept(&mut self,\n-                  missile: HomingMissile,\n-                  loop_: &Loop) -> IoResult<T> {\n-        // If we've timed out but we're not closed yet, poll the state of the\n-        // queue to see if we can peel off a connection.\n-        if self.access.timed_out() && !self.access.access.is_closed(&missile) {\n-            let tmp = self.access.access.get_mut(&missile);\n-            return match tmp.pending.remove(0) {\n-                Some(msg) => msg,\n-                None => Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n-            }\n-        }\n-\n-        // Now that we're not polling, attempt to gain access and then peel off\n-        // a connection. If we have no pending connections, then we need to go\n-        // to sleep and wait for one.\n-        //\n-        // Note that if we're woken up for a pending connection then we're\n-        // guaranteed that the check above will not steal our connection due to\n-        // the single-threaded nature of the event loop.\n-        let mut guard = try!(self.access.grant(missile));\n-        if guard.access.is_closed() {\n-            return Err(uv_error_to_io_error(UvError(uvll::EOF)))\n-        }\n-\n-        match guard.access.pending.remove(0) {\n-            Some(msg) => return msg,\n-            None => {}\n-        }\n-\n-        wait_until_woken_after(&mut guard.access.blocked_acceptor, loop_, || {});\n-\n-        match guard.access.pending.remove(0) {\n-            _ if guard.access.is_closed() => {\n-                Err(uv_error_to_io_error(UvError(uvll::EOF)))\n-            }\n-            Some(msg) => msg,\n-            None => Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n-        }\n-    }\n-\n-    pub unsafe fn push(&mut self, t: IoResult<T>) {\n-        let state = self.access.access.unsafe_get();\n-        (*state).pending.push(t);\n-        let _ = (*state).blocked_acceptor.take().map(|t| t.reawaken());\n-    }\n-\n-    pub fn set_timeout(&mut self,\n-                       ms: Option<u64>,\n-                       loop_: &Loop,\n-                       home: &HomeHandle) {\n-        self.access.set_timeout(ms, home, loop_, cancel_accept::<T>,\n-                                self as *mut _ as uint);\n-\n-        fn cancel_accept<T: Send>(me: uint) -> Option<BlockedTask> {\n-            unsafe {\n-                let me: &mut AcceptTimeout<T> = mem::transmute(me);\n-                (*me.access.access.unsafe_get()).blocked_acceptor.take()\n-            }\n-        }\n-    }\n-\n-    pub fn close(&mut self, m: HomingMissile) {\n-        self.access.access.close(&m);\n-        let task = self.access.access.get_mut(&m).blocked_acceptor.take();\n-        drop(m);\n-        let _ = task.map(|t| t.reawaken());\n-    }\n-}\n-\n-impl<T: Send> Clone for AcceptTimeout<T> {\n-    fn clone(&self) -> AcceptTimeout<T> {\n-        AcceptTimeout { access: self.access.clone() }\n-    }\n-}"}, {"sha": "412506604c674cc50bf90e8e1c6939ce47b91e87", "filename": "src/librustuv/timer.rs", "status": "removed", "additions": 0, "deletions": 173, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,173 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::mem;\n-use std::rt::rtio::{RtioTimer, Callback};\n-use std::rt::task::BlockedTask;\n-\n-use homing::{HomeHandle, HomingIO};\n-use super::{UvHandle, ForbidUnwind, ForbidSwitch, wait_until_woken_after, Loop};\n-use uvio::UvIoFactory;\n-use uvll;\n-\n-pub struct TimerWatcher {\n-    pub handle: *mut uvll::uv_timer_t,\n-    home: HomeHandle,\n-    action: Option<NextAction>,\n-    blocker: Option<BlockedTask>,\n-    id: uint, // see comments in timer_cb\n-}\n-\n-pub enum NextAction {\n-    WakeTask,\n-    CallOnce(Box<Callback + Send>),\n-    CallMany(Box<Callback + Send>, uint),\n-}\n-\n-impl TimerWatcher {\n-    pub fn new(io: &mut UvIoFactory) -> Box<TimerWatcher> {\n-        let handle = io.make_handle();\n-        let me = box TimerWatcher::new_home(&io.loop_, handle);\n-        me.install()\n-    }\n-\n-    pub fn new_home(loop_: &Loop, home: HomeHandle) -> TimerWatcher {\n-        let handle = UvHandle::alloc(None::<TimerWatcher>, uvll::UV_TIMER);\n-        assert_eq!(unsafe { uvll::uv_timer_init(loop_.handle, handle) }, 0);\n-        TimerWatcher {\n-            handle: handle,\n-            action: None,\n-            blocker: None,\n-            home: home,\n-            id: 0,\n-        }\n-    }\n-\n-    pub fn start(&mut self, f: uvll::uv_timer_cb, msecs: u64, period: u64) {\n-        assert_eq!(unsafe {\n-            uvll::uv_timer_start(self.handle, f, msecs, period)\n-        }, 0)\n-    }\n-\n-    pub fn stop(&mut self) {\n-        assert_eq!(unsafe { uvll::uv_timer_stop(self.handle) }, 0)\n-    }\n-\n-    pub unsafe fn set_data<T>(&mut self, data: *mut T) {\n-        uvll::set_data_for_uv_handle(self.handle, data);\n-    }\n-}\n-\n-impl HomingIO for TimerWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n-}\n-\n-impl UvHandle<uvll::uv_timer_t> for TimerWatcher {\n-    fn uv_handle(&self) -> *mut uvll::uv_timer_t { self.handle }\n-}\n-\n-impl RtioTimer for TimerWatcher {\n-    fn sleep(&mut self, msecs: u64) {\n-        // As with all of the below functions, we must be extra careful when\n-        // destroying the previous action. If the previous action was a channel,\n-        // destroying it could invoke a context switch. For these situations,\n-        // we must temporarily un-home ourselves, then destroy the action, and\n-        // then re-home again.\n-        let missile = self.fire_homing_missile();\n-        self.id += 1;\n-        self.stop();\n-        let _missile = match mem::replace(&mut self.action, None) {\n-            None => missile, // no need to do a homing dance\n-            Some(action) => {\n-                drop(missile);      // un-home ourself\n-                drop(action);       // destroy the previous action\n-                self.fire_homing_missile()  // re-home ourself\n-            }\n-        };\n-\n-        // If the descheduling operation unwinds after the timer has been\n-        // started, then we need to call stop on the timer.\n-        let _f = ForbidUnwind::new(\"timer\");\n-\n-        self.action = Some(WakeTask);\n-        wait_until_woken_after(&mut self.blocker, &self.uv_loop(), || {\n-            self.start(timer_cb, msecs, 0);\n-        });\n-        self.stop();\n-    }\n-\n-    fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n-        // similarly to the destructor, we must drop the previous action outside\n-        // of the homing missile\n-        let _prev_action = {\n-            let _m = self.fire_homing_missile();\n-            self.id += 1;\n-            self.stop();\n-            self.start(timer_cb, msecs, 0);\n-            mem::replace(&mut self.action, Some(CallOnce(cb)))\n-        };\n-    }\n-\n-    fn period(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n-        // similarly to the destructor, we must drop the previous action outside\n-        // of the homing missile\n-        let _prev_action = {\n-            let _m = self.fire_homing_missile();\n-            self.id += 1;\n-            self.stop();\n-            self.start(timer_cb, msecs, msecs);\n-            mem::replace(&mut self.action, Some(CallMany(cb, self.id)))\n-        };\n-    }\n-}\n-\n-extern fn timer_cb(handle: *mut uvll::uv_timer_t) {\n-    let _f = ForbidSwitch::new(\"timer callback can't switch\");\n-    let timer: &mut TimerWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n-\n-    match timer.action.take().unwrap() {\n-        WakeTask => {\n-            let task = timer.blocker.take().unwrap();\n-            let _ = task.wake().map(|t| t.reawaken());\n-        }\n-        CallOnce(mut cb) => { cb.call() }\n-        CallMany(mut cb, id) => {\n-            cb.call();\n-\n-            // Note that the above operation could have performed some form of\n-            // scheduling. This means that the timer may have decided to insert\n-            // some other action to happen. This 'id' keeps track of the updates\n-            // to the timer, so we only reset the action back to sending on this\n-            // channel if the id has remained the same. This is essentially a\n-            // bug in that we have mutably aliasable memory, but that's libuv\n-            // for you. We're guaranteed to all be running on the same thread,\n-            // so there's no need for any synchronization here.\n-            if timer.id == id {\n-                timer.action = Some(CallMany(cb, id));\n-            }\n-        }\n-    }\n-}\n-\n-impl Drop for TimerWatcher {\n-    fn drop(&mut self) {\n-        // note that this drop is a little subtle. Dropping a channel which is\n-        // held internally may invoke some scheduling operations. We can't take\n-        // the channel unless we're on the home scheduler, but once we're on the\n-        // home scheduler we should never move. Hence, we take the timer's\n-        // action item and then move it outside of the homing block.\n-        let _action = {\n-            let _m = self.fire_homing_missile();\n-            self.stop();\n-            self.close();\n-            self.action.take()\n-        };\n-    }\n-}"}, {"sha": "43973f2fb8e50dceddad621ce5fd4b62133f1824", "filename": "src/librustuv/tty.rs", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,136 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc;\n-use std::ptr;\n-use std::rt::rtio::{RtioTTY, IoResult};\n-\n-use homing::{HomingIO, HomeHandle};\n-use stream::StreamWatcher;\n-use super::{UvError, UvHandle, uv_error_to_io_error};\n-use uvio::UvIoFactory;\n-use uvll;\n-\n-pub struct TtyWatcher{\n-    tty: *mut uvll::uv_tty_t,\n-    stream: StreamWatcher,\n-    home: HomeHandle,\n-    fd: libc::c_int,\n-}\n-\n-impl TtyWatcher {\n-    pub fn new(io: &mut UvIoFactory, fd: libc::c_int, readable: bool)\n-        -> Result<TtyWatcher, UvError>\n-    {\n-        // libuv may succeed in giving us a handle (via uv_tty_init), but if the\n-        // handle isn't actually connected to a terminal there are frequently\n-        // many problems in using it with libuv. To get around this, always\n-        // return a failure if the specified file descriptor isn't actually a\n-        // TTY.\n-        //\n-        // Related:\n-        // - https://github.com/joyent/libuv/issues/982\n-        // - https://github.com/joyent/libuv/issues/988\n-        let guess = unsafe { uvll::guess_handle(fd) };\n-        if guess != uvll::UV_TTY as libc::c_int {\n-            return Err(UvError(uvll::EBADF));\n-        }\n-\n-        // libuv was recently changed to not close the stdio file descriptors,\n-        // but it did not change the behavior for windows. Until this issue is\n-        // fixed, we need to dup the stdio file descriptors because otherwise\n-        // uv_close will close them\n-        let fd = if cfg!(windows) && fd <= libc::STDERR_FILENO {\n-            unsafe { libc::dup(fd) }\n-        } else { fd };\n-\n-        // If this file descriptor is indeed guessed to be a tty, then go ahead\n-        // with attempting to open it as a tty.\n-        let handle = UvHandle::alloc(None::<TtyWatcher>, uvll::UV_TTY);\n-        let mut watcher = TtyWatcher {\n-            tty: handle,\n-            stream: StreamWatcher::new(handle, true),\n-            home: io.make_handle(),\n-            fd: fd,\n-        };\n-        match unsafe {\n-            uvll::uv_tty_init(io.uv_loop(), handle, fd as libc::c_int,\n-                              readable as libc::c_int)\n-        } {\n-            0 => Ok(watcher),\n-            n => {\n-                // On windows, libuv returns errors before initializing the\n-                // handle, so our only cleanup is to free the handle itself\n-                if cfg!(windows) {\n-                    unsafe { uvll::free_handle(handle); }\n-                    watcher.tty = ptr::null_mut();\n-                }\n-                Err(UvError(n))\n-            }\n-        }\n-    }\n-}\n-\n-impl RtioTTY for TtyWatcher {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let _m = self.fire_homing_missile();\n-        self.stream.read(buf).map_err(uv_error_to_io_error)\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let _m = self.fire_homing_missile();\n-        self.stream.write(buf, false).map_err(uv_error_to_io_error)\n-    }\n-\n-    fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n-        let raw = raw as libc::c_int;\n-        let _m = self.fire_homing_missile();\n-        match unsafe { uvll::uv_tty_set_mode(self.tty, raw) } {\n-            0 => Ok(()),\n-            n => Err(uv_error_to_io_error(UvError(n)))\n-        }\n-    }\n-\n-    #[allow(unused_mut)]\n-    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n-        let mut width: libc::c_int = 0;\n-        let mut height: libc::c_int = 0;\n-        let widthptr: *mut libc::c_int = &mut width;\n-        let heightptr: *mut libc::c_int = &mut width;\n-\n-        let _m = self.fire_homing_missile();\n-        match unsafe { uvll::uv_tty_get_winsize(self.tty,\n-                                                widthptr, heightptr) } {\n-            0 => Ok((width as int, height as int)),\n-            n => Err(uv_error_to_io_error(UvError(n)))\n-        }\n-    }\n-\n-    fn isatty(&self) -> bool {\n-        unsafe { uvll::guess_handle(self.fd) == uvll::UV_TTY as libc::c_int }\n-    }\n-}\n-\n-impl UvHandle<uvll::uv_tty_t> for TtyWatcher {\n-    fn uv_handle(&self) -> *mut uvll::uv_tty_t { self.tty }\n-}\n-\n-impl HomingIO for TtyWatcher {\n-    fn home<'a>(&'a mut self) -> &'a mut HomeHandle { &mut self.home }\n-}\n-\n-impl Drop for TtyWatcher {\n-    fn drop(&mut self) {\n-        if !self.tty.is_null() {\n-            let _m = self.fire_homing_missile();\n-            self.close_async_();\n-        }\n-    }\n-}"}, {"sha": "f2a2b5d2f1d3b4220080b9a5a8c27c44d9bd92f8", "filename": "src/librustuv/uvio.rs", "status": "removed", "additions": 0, "deletions": 326, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,326 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The implementation of `rtio` for libuv\n-\n-use std::c_str::CString;\n-use std::mem;\n-use libc::c_int;\n-use libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY, S_IRUSR,\n-                S_IWUSR};\n-use libc;\n-use std::rt::rtio;\n-use std::rt::rtio::{ProcessConfig, IoFactory, EventLoop, IoResult};\n-\n-#[cfg(test)] use std::rt::thread::Thread;\n-\n-use super::{uv_error_to_io_error, Loop};\n-\n-use addrinfo::GetAddrInfoRequest;\n-use async::AsyncWatcher;\n-use file::{FsRequest, FileWatcher};\n-use queue::QueuePool;\n-use homing::HomeHandle;\n-use idle::IdleWatcher;\n-use net::{TcpWatcher, TcpListener, UdpWatcher};\n-use pipe::{PipeWatcher, PipeListener};\n-use process::Process;\n-use signal::SignalWatcher;\n-use timer::TimerWatcher;\n-use tty::TtyWatcher;\n-use uvll;\n-\n-// Obviously an Event Loop is always home.\n-pub struct UvEventLoop {\n-    uvio: UvIoFactory\n-}\n-\n-impl UvEventLoop {\n-    pub fn new() -> UvEventLoop {\n-        let mut loop_ = Loop::new();\n-        let handle_pool = QueuePool::new(&mut loop_);\n-        UvEventLoop {\n-            uvio: UvIoFactory {\n-                loop_: loop_,\n-                handle_pool: Some(handle_pool),\n-            }\n-        }\n-    }\n-}\n-\n-impl Drop for UvEventLoop {\n-    fn drop(&mut self) {\n-        // Must first destroy the pool of handles before we destroy the loop\n-        // because otherwise the contained async handle will be destroyed after\n-        // the loop is free'd (use-after-free). We also must free the uv handle\n-        // after the loop has been closed because during the closing of the loop\n-        // the handle is required to be used apparently.\n-        //\n-        // Lastly, after we've closed the pool of handles we pump the event loop\n-        // one last time to run any closing callbacks to make sure the loop\n-        // shuts down cleanly.\n-        let handle = self.uvio.handle_pool.as_ref().unwrap().handle();\n-        drop(self.uvio.handle_pool.take());\n-        self.run();\n-\n-        self.uvio.loop_.close();\n-        unsafe { uvll::free_handle(handle) }\n-    }\n-}\n-\n-impl EventLoop for UvEventLoop {\n-    fn run(&mut self) {\n-        self.uvio.loop_.run();\n-    }\n-\n-    fn callback(&mut self, f: proc()) {\n-        IdleWatcher::onetime(&mut self.uvio.loop_, f);\n-    }\n-\n-    fn pausable_idle_callback(&mut self, cb: Box<rtio::Callback + Send>)\n-                              -> Box<rtio::PausableIdleCallback + Send> {\n-        IdleWatcher::new(&mut self.uvio.loop_, cb)\n-                         as Box<rtio::PausableIdleCallback + Send>\n-    }\n-\n-    fn remote_callback(&mut self, f: Box<rtio::Callback + Send>)\n-                       -> Box<rtio::RemoteCallback + Send> {\n-        box AsyncWatcher::new(&mut self.uvio.loop_, f) as\n-            Box<rtio::RemoteCallback + Send>\n-    }\n-\n-    fn io<'a>(&'a mut self) -> Option<&'a mut rtio::IoFactory> {\n-        let factory = &mut self.uvio as &mut rtio::IoFactory;\n-        Some(factory)\n-    }\n-\n-    fn has_active_io(&self) -> bool {\n-        self.uvio.loop_.get_blockers() > 0\n-    }\n-}\n-\n-#[test]\n-fn test_callback_run_once() {\n-    Thread::start(proc() {\n-        let mut event_loop = UvEventLoop::new();\n-        let mut count = 0;\n-        let count_ptr: *mut int = &mut count;\n-        event_loop.callback(proc() {\n-            unsafe { *count_ptr += 1 }\n-        });\n-        event_loop.run();\n-        assert_eq!(count, 1);\n-    }).join();\n-}\n-\n-pub struct UvIoFactory {\n-    pub loop_: Loop,\n-    handle_pool: Option<Box<QueuePool>>,\n-}\n-\n-impl UvIoFactory {\n-    pub fn uv_loop<'a>(&mut self) -> *mut uvll::uv_loop_t { self.loop_.handle }\n-\n-    pub fn make_handle(&mut self) -> HomeHandle {\n-        // It's understood by the homing code that the \"local id\" is just the\n-        // pointer of the local I/O factory cast to a uint.\n-        let id: uint = unsafe { mem::transmute_copy(&self) };\n-        HomeHandle::new(id, &mut **self.handle_pool.as_mut().unwrap())\n-    }\n-}\n-\n-impl IoFactory for UvIoFactory {\n-    // Connect to an address and return a new stream\n-    // NB: This blocks the task waiting on the connection.\n-    // It would probably be better to return a future\n-    fn tcp_connect(&mut self, addr: rtio::SocketAddr, timeout: Option<u64>)\n-                   -> IoResult<Box<rtio::RtioTcpStream + Send>> {\n-        match TcpWatcher::connect(self, addr, timeout) {\n-            Ok(t) => Ok(box t as Box<rtio::RtioTcpStream + Send>),\n-            Err(e) => Err(uv_error_to_io_error(e)),\n-        }\n-    }\n-\n-    fn tcp_bind(&mut self, addr: rtio::SocketAddr)\n-                -> IoResult<Box<rtio::RtioTcpListener + Send>> {\n-        match TcpListener::bind(self, addr) {\n-            Ok(t) => Ok(t as Box<rtio::RtioTcpListener + Send>),\n-            Err(e) => Err(uv_error_to_io_error(e)),\n-        }\n-    }\n-\n-    fn udp_bind(&mut self, addr: rtio::SocketAddr)\n-                -> IoResult<Box<rtio::RtioUdpSocket + Send>> {\n-        match UdpWatcher::bind(self, addr) {\n-            Ok(u) => Ok(box u as Box<rtio::RtioUdpSocket + Send>),\n-            Err(e) => Err(uv_error_to_io_error(e)),\n-        }\n-    }\n-\n-    fn timer_init(&mut self) -> IoResult<Box<rtio::RtioTimer + Send>> {\n-        Ok(TimerWatcher::new(self) as Box<rtio::RtioTimer + Send>)\n-    }\n-\n-    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<rtio::AddrinfoHint>)\n-        -> IoResult<Vec<rtio::AddrinfoInfo>>\n-    {\n-        let r = GetAddrInfoRequest::run(&self.loop_, host, servname, hint);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-\n-    fn fs_from_raw_fd(&mut self, fd: c_int, close: rtio::CloseBehavior)\n-                      -> Box<rtio::RtioFileStream + Send> {\n-        box FileWatcher::new(self, fd, close) as\n-            Box<rtio::RtioFileStream + Send>\n-    }\n-\n-    fn fs_open(&mut self, path: &CString, fm: rtio::FileMode,\n-               fa: rtio::FileAccess)\n-        -> IoResult<Box<rtio::RtioFileStream + Send>>\n-    {\n-        let flags = match fm {\n-            rtio::Open => 0,\n-            rtio::Append => libc::O_APPEND,\n-            rtio::Truncate => libc::O_TRUNC,\n-        };\n-        // Opening with a write permission must silently create the file.\n-        let (flags, mode) = match fa {\n-            rtio::Read => (flags | libc::O_RDONLY, 0),\n-            rtio::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n-                            libc::S_IRUSR | libc::S_IWUSR),\n-            rtio::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n-                                libc::S_IRUSR | libc::S_IWUSR),\n-        };\n-\n-        match FsRequest::open(self, path, flags as int, mode as int) {\n-            Ok(fs) => Ok(box fs as Box<rtio::RtioFileStream + Send>),\n-            Err(e) => Err(uv_error_to_io_error(e))\n-        }\n-    }\n-\n-    fn fs_unlink(&mut self, path: &CString) -> IoResult<()> {\n-        let r = FsRequest::unlink(&self.loop_, path);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn fs_lstat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n-        let r = FsRequest::lstat(&self.loop_, path);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn fs_stat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n-        let r = FsRequest::stat(&self.loop_, path);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn fs_mkdir(&mut self, path: &CString, perm: uint) -> IoResult<()> {\n-        let r = FsRequest::mkdir(&self.loop_, path, perm as c_int);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()> {\n-        let r = FsRequest::rmdir(&self.loop_, path);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()> {\n-        let r = FsRequest::rename(&self.loop_, path, to);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn fs_chmod(&mut self, path: &CString, perm: uint) -> IoResult<()> {\n-        let r = FsRequest::chmod(&self.loop_, path, perm as c_int);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn fs_readdir(&mut self, path: &CString, flags: c_int)\n-        -> IoResult<Vec<CString>>\n-    {\n-        let r = FsRequest::readdir(&self.loop_, path, flags);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n-        let r = FsRequest::link(&self.loop_, src, dst);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n-        let r = FsRequest::symlink(&self.loop_, src, dst);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> IoResult<()> {\n-        let r = FsRequest::chown(&self.loop_, path, uid, gid);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn fs_readlink(&mut self, path: &CString) -> IoResult<CString> {\n-        let r = FsRequest::readlink(&self.loop_, path);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-    fn fs_utime(&mut self, path: &CString, atime: u64, mtime: u64)\n-        -> IoResult<()>\n-    {\n-        let r = FsRequest::utime(&self.loop_, path, atime, mtime);\n-        r.map_err(uv_error_to_io_error)\n-    }\n-\n-    fn spawn(&mut self, cfg: ProcessConfig)\n-            -> IoResult<(Box<rtio::RtioProcess + Send>,\n-                         Vec<Option<Box<rtio::RtioPipe + Send>>>)>\n-    {\n-        match Process::spawn(self, cfg) {\n-            Ok((p, io)) => {\n-                Ok((p as Box<rtio::RtioProcess + Send>,\n-                    io.into_iter().map(|i| i.map(|p| {\n-                        box p as Box<rtio::RtioPipe + Send>\n-                    })).collect()))\n-            }\n-            Err(e) => Err(uv_error_to_io_error(e)),\n-        }\n-    }\n-\n-    fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> {\n-        Process::kill(pid, signum).map_err(uv_error_to_io_error)\n-    }\n-\n-    fn unix_bind(&mut self, path: &CString)\n-                 -> IoResult<Box<rtio::RtioUnixListener + Send>> {\n-        match PipeListener::bind(self, path) {\n-            Ok(p) => Ok(p as Box<rtio::RtioUnixListener + Send>),\n-            Err(e) => Err(uv_error_to_io_error(e)),\n-        }\n-    }\n-\n-    fn unix_connect(&mut self, path: &CString, timeout: Option<u64>)\n-                    -> IoResult<Box<rtio::RtioPipe + Send>> {\n-        match PipeWatcher::connect(self, path, timeout) {\n-            Ok(p) => Ok(box p as Box<rtio::RtioPipe + Send>),\n-            Err(e) => Err(uv_error_to_io_error(e)),\n-        }\n-    }\n-\n-    fn tty_open(&mut self, fd: c_int, readable: bool)\n-            -> IoResult<Box<rtio::RtioTTY + Send>> {\n-        match TtyWatcher::new(self, fd, readable) {\n-            Ok(tty) => Ok(box tty as Box<rtio::RtioTTY + Send>),\n-            Err(e) => Err(uv_error_to_io_error(e))\n-        }\n-    }\n-\n-    fn pipe_open(&mut self, fd: c_int)\n-        -> IoResult<Box<rtio::RtioPipe + Send>>\n-    {\n-        match PipeWatcher::open(self, fd) {\n-            Ok(s) => Ok(box s as Box<rtio::RtioPipe + Send>),\n-            Err(e) => Err(uv_error_to_io_error(e))\n-        }\n-    }\n-\n-    fn signal(&mut self, signum: int, cb: Box<rtio::Callback + Send>)\n-        -> IoResult<Box<rtio::RtioSignal + Send>>\n-    {\n-        match SignalWatcher::new(self, signum, cb) {\n-            Ok(s) => Ok(s as Box<rtio::RtioSignal + Send>),\n-            Err(e) => Err(uv_error_to_io_error(e)),\n-        }\n-    }\n-}"}, {"sha": "35bd20c0dd90b7bcee88e6f768c4d9278ae0a891", "filename": "src/librustuv/uvll.rs", "status": "removed", "additions": 0, "deletions": 742, "changes": 742, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -1,742 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * Low-level bindings to the libuv library.\n- *\n- * This module contains a set of direct, 'bare-metal' wrappers around\n- * the libuv C-API.\n- *\n- * We're not bothering yet to redefine uv's structs as Rust structs\n- * because they are quite large and change often between versions.\n- * The maintenance burden is just too high. Instead we use the uv's\n- * `uv_handle_size` and `uv_req_size` to find the correct size of the\n- * structs and allocate them on the heap. This can be revisited later.\n- *\n- * There are also a collection of helper functions to ease interacting\n- * with the low-level API.\n- *\n- * As new functionality, existent in uv.h, is added to the rust stdlib,\n- * the mappings should be added in this module.\n- */\n-\n-#![allow(non_camel_case_types)] // C types\n-\n-use libc::{size_t, c_int, c_uint, c_void, c_char, c_double};\n-use libc::{ssize_t, sockaddr, free, addrinfo};\n-use libc;\n-use std::rt::libc_heap::malloc_raw;\n-\n-#[cfg(test)]\n-use libc::uintptr_t;\n-\n-pub use self::errors::{EACCES, ECONNREFUSED, ECONNRESET, EPIPE, ECONNABORTED,\n-                       ECANCELED, EBADF, ENOTCONN, ENOENT, EADDRNOTAVAIL,\n-                       EADDRINUSE, EPERM};\n-\n-pub static OK: c_int = 0;\n-pub static EOF: c_int = -4095;\n-pub static UNKNOWN: c_int = -4094;\n-\n-// uv-errno.h redefines error codes for windows, but not for unix...\n-// https://github.com/joyent/libuv/blob/master/include/uv-errno.h\n-\n-#[cfg(windows)]\n-pub mod errors {\n-    use libc::c_int;\n-\n-    pub static EACCES: c_int = -4092;\n-    pub static ECONNREFUSED: c_int = -4078;\n-    pub static ECONNRESET: c_int = -4077;\n-    pub static ENOENT: c_int = -4058;\n-    pub static ENOTCONN: c_int = -4053;\n-    pub static EPIPE: c_int = -4047;\n-    pub static ECONNABORTED: c_int = -4079;\n-    pub static ECANCELED: c_int = -4081;\n-    pub static EBADF: c_int = -4083;\n-    pub static EADDRNOTAVAIL: c_int = -4090;\n-    pub static EADDRINUSE: c_int = -4091;\n-    pub static EPERM: c_int = -4048;\n-}\n-#[cfg(not(windows))]\n-pub mod errors {\n-    use libc;\n-    use libc::c_int;\n-\n-    pub static EACCES: c_int = -libc::EACCES;\n-    pub static ECONNREFUSED: c_int = -libc::ECONNREFUSED;\n-    pub static ECONNRESET: c_int = -libc::ECONNRESET;\n-    pub static ENOENT: c_int = -libc::ENOENT;\n-    pub static ENOTCONN: c_int = -libc::ENOTCONN;\n-    pub static EPIPE: c_int = -libc::EPIPE;\n-    pub static ECONNABORTED: c_int = -libc::ECONNABORTED;\n-    pub static ECANCELED : c_int = -libc::ECANCELED;\n-    pub static EBADF : c_int = -libc::EBADF;\n-    pub static EADDRNOTAVAIL : c_int = -libc::EADDRNOTAVAIL;\n-    pub static EADDRINUSE : c_int = -libc::EADDRINUSE;\n-    pub static EPERM: c_int = -libc::EPERM;\n-}\n-\n-pub static PROCESS_SETUID: c_int = 1 << 0;\n-pub static PROCESS_SETGID: c_int = 1 << 1;\n-pub static PROCESS_WINDOWS_VERBATIM_ARGUMENTS: c_int = 1 << 2;\n-pub static PROCESS_DETACHED: c_int = 1 << 3;\n-pub static PROCESS_WINDOWS_HIDE: c_int = 1 << 4;\n-\n-pub static STDIO_IGNORE: c_int = 0x00;\n-pub static STDIO_CREATE_PIPE: c_int = 0x01;\n-pub static STDIO_INHERIT_FD: c_int = 0x02;\n-pub static STDIO_INHERIT_STREAM: c_int = 0x04;\n-pub static STDIO_READABLE_PIPE: c_int = 0x10;\n-pub static STDIO_WRITABLE_PIPE: c_int = 0x20;\n-\n-#[cfg(unix)]\n-pub type uv_buf_len_t = libc::size_t;\n-#[cfg(windows)]\n-pub type uv_buf_len_t = libc::c_ulong;\n-\n-// see libuv/include/uv-unix.h\n-#[repr(C)]\n-#[cfg(unix)]\n-pub struct uv_buf_t {\n-    pub base: *mut u8,\n-    pub len: uv_buf_len_t,\n-}\n-\n-#[cfg(unix)]\n-pub type uv_os_socket_t = c_int;\n-\n-// see libuv/include/uv-win.h\n-#[cfg(windows)]\n-#[repr(C)]\n-pub struct uv_buf_t {\n-    pub len: uv_buf_len_t,\n-    pub base: *mut u8,\n-}\n-\n-#[cfg(windows)]\n-pub type uv_os_socket_t = libc::SOCKET;\n-\n-#[repr(C)]\n-pub enum uv_run_mode {\n-    RUN_DEFAULT = 0,\n-    RUN_ONCE,\n-    RUN_NOWAIT,\n-}\n-\n-#[repr(C)]\n-pub enum uv_poll_event {\n-    UV_READABLE = 1,\n-    UV_WRITABLE = 2,\n-}\n-\n-#[repr(C)]\n-pub struct uv_process_options_t {\n-    pub exit_cb: uv_exit_cb,\n-    pub file: *const libc::c_char,\n-    pub args: *const *const libc::c_char,\n-    pub env: *const *const libc::c_char,\n-    pub cwd: *const libc::c_char,\n-    pub flags: libc::c_uint,\n-    pub stdio_count: libc::c_int,\n-    pub stdio: *mut uv_stdio_container_t,\n-    pub uid: uv_uid_t,\n-    pub gid: uv_gid_t,\n-}\n-\n-// These fields are private because they must be interfaced with through the\n-// functions below.\n-#[repr(C)]\n-pub struct uv_stdio_container_t {\n-    flags: libc::c_int,\n-    stream: *mut uv_stream_t,\n-}\n-\n-pub type uv_handle_t = c_void;\n-pub type uv_req_t = c_void;\n-pub type uv_loop_t = c_void;\n-pub type uv_idle_t = c_void;\n-pub type uv_tcp_t = c_void;\n-pub type uv_udp_t = c_void;\n-pub type uv_poll_t = c_void;\n-pub type uv_connect_t = c_void;\n-pub type uv_connection_t = c_void;\n-pub type uv_write_t = c_void;\n-pub type uv_async_t = c_void;\n-pub type uv_timer_t = c_void;\n-pub type uv_stream_t = c_void;\n-pub type uv_fs_t = c_void;\n-pub type uv_udp_send_t = c_void;\n-pub type uv_getaddrinfo_t = c_void;\n-pub type uv_process_t = c_void;\n-pub type uv_pipe_t = c_void;\n-pub type uv_tty_t = c_void;\n-pub type uv_signal_t = c_void;\n-pub type uv_shutdown_t = c_void;\n-\n-#[repr(C)]\n-pub struct uv_timespec_t {\n-    pub tv_sec: libc::c_long,\n-    pub tv_nsec: libc::c_long\n-}\n-\n-#[repr(C)]\n-pub struct uv_stat_t {\n-    pub st_dev: libc::uint64_t,\n-    pub st_mode: libc::uint64_t,\n-    pub st_nlink: libc::uint64_t,\n-    pub st_uid: libc::uint64_t,\n-    pub st_gid: libc::uint64_t,\n-    pub st_rdev: libc::uint64_t,\n-    pub st_ino: libc::uint64_t,\n-    pub st_size: libc::uint64_t,\n-    pub st_blksize: libc::uint64_t,\n-    pub st_blocks: libc::uint64_t,\n-    pub st_flags: libc::uint64_t,\n-    pub st_gen: libc::uint64_t,\n-    pub st_atim: uv_timespec_t,\n-    pub st_mtim: uv_timespec_t,\n-    pub st_ctim: uv_timespec_t,\n-    pub st_birthtim: uv_timespec_t\n-}\n-\n-impl uv_stat_t {\n-    pub fn new() -> uv_stat_t {\n-        uv_stat_t {\n-            st_dev: 0,\n-            st_mode: 0,\n-            st_nlink: 0,\n-            st_uid: 0,\n-            st_gid: 0,\n-            st_rdev: 0,\n-            st_ino: 0,\n-            st_size: 0,\n-            st_blksize: 0,\n-            st_blocks: 0,\n-            st_flags: 0,\n-            st_gen: 0,\n-            st_atim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n-            st_mtim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n-            st_ctim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 },\n-            st_birthtim: uv_timespec_t { tv_sec: 0, tv_nsec: 0 }\n-        }\n-    }\n-    pub fn is_file(&self) -> bool {\n-        ((self.st_mode) & libc::S_IFMT as libc::uint64_t) == libc::S_IFREG as libc::uint64_t\n-    }\n-    pub fn is_dir(&self) -> bool {\n-        ((self.st_mode) & libc::S_IFMT as libc::uint64_t) == libc::S_IFDIR as libc::uint64_t\n-    }\n-}\n-\n-pub type uv_idle_cb = extern \"C\" fn(handle: *mut uv_idle_t);\n-pub type uv_alloc_cb = extern \"C\" fn(stream: *mut uv_stream_t,\n-                                     suggested_size: size_t,\n-                                     buf: *mut uv_buf_t);\n-pub type uv_read_cb = extern \"C\" fn(stream: *mut uv_stream_t,\n-                                    nread: ssize_t,\n-                                    buf: *const uv_buf_t);\n-pub type uv_udp_send_cb = extern \"C\" fn(req: *mut uv_udp_send_t,\n-                                        status: c_int);\n-pub type uv_udp_recv_cb = extern \"C\" fn(handle: *mut uv_udp_t,\n-                                        nread: ssize_t,\n-                                        buf: *const uv_buf_t,\n-                                        addr: *const sockaddr,\n-                                        flags: c_uint);\n-pub type uv_close_cb = extern \"C\" fn(handle: *mut uv_handle_t);\n-pub type uv_poll_cb = extern \"C\" fn(handle: *mut uv_poll_t,\n-                                    status: c_int,\n-                                    events: c_int);\n-pub type uv_walk_cb = extern \"C\" fn(handle: *mut uv_handle_t,\n-                                    arg: *mut c_void);\n-pub type uv_async_cb = extern \"C\" fn(handle: *mut uv_async_t);\n-pub type uv_connect_cb = extern \"C\" fn(handle: *mut uv_connect_t,\n-                                       status: c_int);\n-pub type uv_connection_cb = extern \"C\" fn(handle: *mut uv_connection_t,\n-                                          status: c_int);\n-pub type uv_timer_cb = extern \"C\" fn(handle: *mut uv_timer_t);\n-pub type uv_write_cb = extern \"C\" fn(handle: *mut uv_write_t,\n-                                     status: c_int);\n-pub type uv_getaddrinfo_cb = extern \"C\" fn(req: *mut uv_getaddrinfo_t,\n-                                           status: c_int,\n-                                           res: *const addrinfo);\n-pub type uv_exit_cb = extern \"C\" fn(handle: *mut uv_process_t,\n-                                    exit_status: i64,\n-                                    term_signal: c_int);\n-pub type uv_signal_cb = extern \"C\" fn(handle: *mut uv_signal_t,\n-                                      signum: c_int);\n-pub type uv_fs_cb = extern \"C\" fn(req: *mut uv_fs_t);\n-pub type uv_shutdown_cb = extern \"C\" fn(req: *mut uv_shutdown_t, status: c_int);\n-\n-#[cfg(unix)] pub type uv_uid_t = libc::types::os::arch::posix88::uid_t;\n-#[cfg(unix)] pub type uv_gid_t = libc::types::os::arch::posix88::gid_t;\n-#[cfg(windows)] pub type uv_uid_t = libc::c_uchar;\n-#[cfg(windows)] pub type uv_gid_t = libc::c_uchar;\n-\n-#[repr(C)]\n-#[deriving(PartialEq)]\n-pub enum uv_handle_type {\n-    UV_UNKNOWN_HANDLE,\n-    UV_ASYNC,\n-    UV_CHECK,\n-    UV_FS_EVENT,\n-    UV_FS_POLL,\n-    UV_HANDLE,\n-    UV_IDLE,\n-    UV_NAMED_PIPE,\n-    UV_POLL,\n-    UV_PREPARE,\n-    UV_PROCESS,\n-    UV_STREAM,\n-    UV_TCP,\n-    UV_TIMER,\n-    UV_TTY,\n-    UV_UDP,\n-    UV_SIGNAL,\n-    UV_FILE,\n-    UV_HANDLE_TYPE_MAX\n-}\n-\n-#[repr(C)]\n-#[cfg(unix)]\n-#[deriving(PartialEq)]\n-pub enum uv_req_type {\n-    UV_UNKNOWN_REQ,\n-    UV_REQ,\n-    UV_CONNECT,\n-    UV_WRITE,\n-    UV_SHUTDOWN,\n-    UV_UDP_SEND,\n-    UV_FS,\n-    UV_WORK,\n-    UV_GETADDRINFO,\n-    UV_GETNAMEINFO,\n-    UV_REQ_TYPE_MAX\n-}\n-\n-// uv_req_type may have additional fields defined by UV_REQ_TYPE_PRIVATE.\n-// See UV_REQ_TYPE_PRIVATE at libuv/include/uv-win.h\n-#[repr(C)]\n-#[cfg(windows)]\n-#[deriving(PartialEq)]\n-pub enum uv_req_type {\n-    UV_UNKNOWN_REQ,\n-    UV_REQ,\n-    UV_CONNECT,\n-    UV_WRITE,\n-    UV_SHUTDOWN,\n-    UV_UDP_SEND,\n-    UV_FS,\n-    UV_WORK,\n-    UV_GETNAMEINFO,\n-    UV_GETADDRINFO,\n-    UV_ACCEPT,\n-    UV_FS_EVENT_REQ,\n-    UV_POLL_REQ,\n-    UV_PROCESS_EXIT,\n-    UV_READ,\n-    UV_UDP_RECV,\n-    UV_WAKEUP,\n-    UV_SIGNAL_REQ,\n-    UV_REQ_TYPE_MAX\n-}\n-\n-#[repr(C)]\n-#[deriving(PartialEq)]\n-pub enum uv_membership {\n-    UV_LEAVE_GROUP,\n-    UV_JOIN_GROUP\n-}\n-\n-pub unsafe fn malloc_handle(handle: uv_handle_type) -> *mut c_void {\n-    assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n-    let size = uv_handle_size(handle);\n-    malloc_raw(size as uint) as *mut c_void\n-}\n-\n-pub unsafe fn free_handle(v: *mut c_void) {\n-    free(v as *mut c_void)\n-}\n-\n-pub unsafe fn malloc_req(req: uv_req_type) -> *mut c_void {\n-    assert!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n-    let size = uv_req_size(req);\n-    malloc_raw(size as uint) as *mut c_void\n-}\n-\n-pub unsafe fn free_req(v: *mut c_void) {\n-    free(v as *mut c_void)\n-}\n-\n-#[test]\n-fn handle_sanity_check() {\n-    unsafe {\n-        assert_eq!(UV_HANDLE_TYPE_MAX as libc::uintptr_t, rust_uv_handle_type_max());\n-    }\n-}\n-\n-#[test]\n-fn request_sanity_check() {\n-    unsafe {\n-        assert_eq!(UV_REQ_TYPE_MAX as libc::uintptr_t, rust_uv_req_type_max());\n-    }\n-}\n-\n-// FIXME Event loops ignore SIGPIPE by default.\n-pub unsafe fn loop_new() -> *mut c_void {\n-    return rust_uv_loop_new();\n-}\n-\n-pub unsafe fn uv_write(req: *mut uv_write_t,\n-                       stream: *mut uv_stream_t,\n-                       buf_in: &[uv_buf_t],\n-                       cb: uv_write_cb) -> c_int {\n-    extern {\n-        fn uv_write(req: *mut uv_write_t, stream: *mut uv_stream_t,\n-                    buf_in: *const uv_buf_t, buf_cnt: c_int,\n-                    cb: uv_write_cb) -> c_int;\n-    }\n-\n-    let buf_ptr = buf_in.as_ptr();\n-    let buf_cnt = buf_in.len() as i32;\n-    return uv_write(req, stream, buf_ptr, buf_cnt, cb);\n-}\n-\n-pub unsafe fn uv_udp_send(req: *mut uv_udp_send_t,\n-                          handle: *mut uv_udp_t,\n-                          buf_in: &[uv_buf_t],\n-                          addr: *const sockaddr,\n-                          cb: uv_udp_send_cb) -> c_int {\n-    extern {\n-        fn uv_udp_send(req: *mut uv_write_t, stream: *mut uv_stream_t,\n-                       buf_in: *const uv_buf_t, buf_cnt: c_int,\n-                       addr: *const sockaddr,\n-                       cb: uv_udp_send_cb) -> c_int;\n-    }\n-\n-    let buf_ptr = buf_in.as_ptr();\n-    let buf_cnt = buf_in.len() as i32;\n-    return uv_udp_send(req, handle, buf_ptr, buf_cnt, addr, cb);\n-}\n-\n-pub unsafe fn get_udp_handle_from_send_req(send_req: *mut uv_udp_send_t) -> *mut uv_udp_t {\n-    return rust_uv_get_udp_handle_from_send_req(send_req);\n-}\n-\n-pub unsafe fn process_pid(p: *mut uv_process_t) -> c_int {\n-\n-    return rust_uv_process_pid(p);\n-}\n-\n-pub unsafe fn set_stdio_container_flags(c: *mut uv_stdio_container_t,\n-                                        flags: libc::c_int) {\n-\n-    rust_set_stdio_container_flags(c, flags);\n-}\n-\n-pub unsafe fn set_stdio_container_fd(c: *mut uv_stdio_container_t,\n-                                     fd: libc::c_int) {\n-\n-    rust_set_stdio_container_fd(c, fd);\n-}\n-\n-pub unsafe fn set_stdio_container_stream(c: *mut uv_stdio_container_t,\n-                                         stream: *mut uv_stream_t) {\n-    rust_set_stdio_container_stream(c, stream);\n-}\n-\n-// data access helpers\n-pub unsafe fn get_result_from_fs_req(req: *mut uv_fs_t) -> ssize_t {\n-    rust_uv_get_result_from_fs_req(req)\n-}\n-pub unsafe fn get_ptr_from_fs_req(req: *mut uv_fs_t) -> *mut libc::c_void {\n-    rust_uv_get_ptr_from_fs_req(req)\n-}\n-pub unsafe fn get_path_from_fs_req(req: *mut uv_fs_t) -> *mut c_char {\n-    rust_uv_get_path_from_fs_req(req)\n-}\n-pub unsafe fn get_loop_from_fs_req(req: *mut uv_fs_t) -> *mut uv_loop_t {\n-    rust_uv_get_loop_from_fs_req(req)\n-}\n-pub unsafe fn get_loop_from_getaddrinfo_req(req: *mut uv_getaddrinfo_t) -> *mut uv_loop_t {\n-    rust_uv_get_loop_from_getaddrinfo_req(req)\n-}\n-pub unsafe fn get_loop_for_uv_handle<T>(handle: *mut T) -> *mut c_void {\n-    return rust_uv_get_loop_for_uv_handle(handle as *mut c_void);\n-}\n-pub unsafe fn get_stream_handle_from_connect_req(connect: *mut uv_connect_t) -> *mut uv_stream_t {\n-    return rust_uv_get_stream_handle_from_connect_req(connect);\n-}\n-pub unsafe fn get_stream_handle_from_write_req(write_req: *mut uv_write_t) -> *mut uv_stream_t {\n-    return rust_uv_get_stream_handle_from_write_req(write_req);\n-}\n-pub unsafe fn get_data_for_uv_loop(loop_ptr: *mut c_void) -> *mut c_void {\n-    rust_uv_get_data_for_uv_loop(loop_ptr)\n-}\n-pub unsafe fn set_data_for_uv_loop(loop_ptr: *mut c_void, data: *mut c_void) {\n-    rust_uv_set_data_for_uv_loop(loop_ptr, data);\n-}\n-pub unsafe fn get_data_for_uv_handle<T>(handle: *mut T) -> *mut c_void {\n-    return rust_uv_get_data_for_uv_handle(handle as *mut c_void);\n-}\n-pub unsafe fn set_data_for_uv_handle<T, U>(handle: *mut T, data: *mut U) {\n-    rust_uv_set_data_for_uv_handle(handle as *mut c_void, data as *mut c_void);\n-}\n-pub unsafe fn get_data_for_req<T>(req: *mut T) -> *mut c_void {\n-    return rust_uv_get_data_for_req(req as *mut c_void);\n-}\n-pub unsafe fn set_data_for_req<T, U>(req: *mut T, data: *mut U) {\n-    rust_uv_set_data_for_req(req as *mut c_void, data as *mut c_void);\n-}\n-pub unsafe fn populate_stat(req_in: *mut uv_fs_t, stat_out: *mut uv_stat_t) {\n-    rust_uv_populate_uv_stat(req_in, stat_out)\n-}\n-pub unsafe fn guess_handle(handle: c_int) -> c_int {\n-    rust_uv_guess_handle(handle)\n-}\n-\n-\n-// uv_support is the result of compiling rust_uv.cpp\n-//\n-// Note that this is in a cfg'd block so it doesn't get linked during testing.\n-// There's a bit of a conundrum when testing in that we're actually assuming\n-// that the tests are running in a uv loop, but they were created from the\n-// statically linked uv to the original rustuv crate. When we create the test\n-// executable, on some platforms if we re-link against uv, it actually creates\n-// second copies of everything. We obviously don't want this, so instead of\n-// dying horribly during testing, we allow all of the test rustuv's references\n-// to get resolved to the original rustuv crate.\n-#[cfg(not(test))]\n-#[link(name = \"uv_support\", kind = \"static\")]\n-#[link(name = \"uv\", kind = \"static\")]\n-extern {}\n-\n-extern {\n-    fn rust_uv_loop_new() -> *mut c_void;\n-\n-    #[cfg(test)]\n-    fn rust_uv_handle_type_max() -> uintptr_t;\n-    #[cfg(test)]\n-    fn rust_uv_req_type_max() -> uintptr_t;\n-    fn rust_uv_get_udp_handle_from_send_req(req: *mut uv_udp_send_t) -> *mut uv_udp_t;\n-\n-    fn rust_uv_populate_uv_stat(req_in: *mut uv_fs_t, stat_out: *mut uv_stat_t);\n-    fn rust_uv_get_result_from_fs_req(req: *mut uv_fs_t) -> ssize_t;\n-    fn rust_uv_get_ptr_from_fs_req(req: *mut uv_fs_t) -> *mut libc::c_void;\n-    fn rust_uv_get_path_from_fs_req(req: *mut uv_fs_t) -> *mut c_char;\n-    fn rust_uv_get_loop_from_fs_req(req: *mut uv_fs_t) -> *mut uv_loop_t;\n-    fn rust_uv_get_loop_from_getaddrinfo_req(req: *mut uv_fs_t) -> *mut uv_loop_t;\n-    fn rust_uv_get_stream_handle_from_connect_req(req: *mut uv_connect_t) -> *mut uv_stream_t;\n-    fn rust_uv_get_stream_handle_from_write_req(req: *mut uv_write_t) -> *mut uv_stream_t;\n-    fn rust_uv_get_loop_for_uv_handle(handle: *mut c_void) -> *mut c_void;\n-    fn rust_uv_get_data_for_uv_loop(loop_ptr: *mut c_void) -> *mut c_void;\n-    fn rust_uv_set_data_for_uv_loop(loop_ptr: *mut c_void, data: *mut c_void);\n-    fn rust_uv_get_data_for_uv_handle(handle: *mut c_void) -> *mut c_void;\n-    fn rust_uv_set_data_for_uv_handle(handle: *mut c_void, data: *mut c_void);\n-    fn rust_uv_get_data_for_req(req: *mut c_void) -> *mut c_void;\n-    fn rust_uv_set_data_for_req(req: *mut c_void, data: *mut c_void);\n-    fn rust_set_stdio_container_flags(c: *mut uv_stdio_container_t, flags: c_int);\n-    fn rust_set_stdio_container_fd(c: *mut uv_stdio_container_t, fd: c_int);\n-    fn rust_set_stdio_container_stream(c: *mut uv_stdio_container_t,\n-                                       stream: *mut uv_stream_t);\n-    fn rust_uv_process_pid(p: *mut uv_process_t) -> c_int;\n-    fn rust_uv_guess_handle(fd: c_int) -> c_int;\n-\n-    // generic uv functions\n-    pub fn uv_loop_delete(l: *mut uv_loop_t);\n-    pub fn uv_ref(t: *mut uv_handle_t);\n-    pub fn uv_unref(t: *mut uv_handle_t);\n-    pub fn uv_handle_size(ty: uv_handle_type) -> size_t;\n-    pub fn uv_req_size(ty: uv_req_type) -> size_t;\n-    pub fn uv_run(l: *mut uv_loop_t, mode: uv_run_mode) -> c_int;\n-    pub fn uv_close(h: *mut uv_handle_t, cb: uv_close_cb);\n-    pub fn uv_walk(l: *mut uv_loop_t, cb: uv_walk_cb, arg: *mut c_void);\n-    pub fn uv_buf_init(base: *mut c_char, len: c_uint) -> uv_buf_t;\n-    pub fn uv_strerror(err: c_int) -> *const c_char;\n-    pub fn uv_err_name(err: c_int) -> *const c_char;\n-    pub fn uv_listen(s: *mut uv_stream_t, backlog: c_int,\n-                     cb: uv_connection_cb) -> c_int;\n-    pub fn uv_accept(server: *mut uv_stream_t, client: *mut uv_stream_t) -> c_int;\n-    pub fn uv_read_start(stream: *mut uv_stream_t,\n-                         on_alloc: uv_alloc_cb,\n-                         on_read: uv_read_cb) -> c_int;\n-    pub fn uv_read_stop(stream: *mut uv_stream_t) -> c_int;\n-    pub fn uv_shutdown(req: *mut uv_shutdown_t, handle: *mut uv_stream_t,\n-                       cb: uv_shutdown_cb) -> c_int;\n-\n-    // idle bindings\n-    pub fn uv_idle_init(l: *mut uv_loop_t, i: *mut uv_idle_t) -> c_int;\n-    pub fn uv_idle_start(i: *mut uv_idle_t, cb: uv_idle_cb) -> c_int;\n-    pub fn uv_idle_stop(i: *mut uv_idle_t) -> c_int;\n-\n-    // async bindings\n-    pub fn uv_async_init(l: *mut uv_loop_t, a: *mut uv_async_t,\n-                         cb: uv_async_cb) -> c_int;\n-    pub fn uv_async_send(a: *mut uv_async_t);\n-\n-    // tcp bindings\n-    pub fn uv_tcp_init(l: *mut uv_loop_t, h: *mut uv_tcp_t) -> c_int;\n-    pub fn uv_tcp_connect(c: *mut uv_connect_t, h: *mut uv_tcp_t,\n-                          addr: *const sockaddr, cb: uv_connect_cb) -> c_int;\n-    pub fn uv_tcp_bind(t: *mut uv_tcp_t,\n-                       addr: *const sockaddr,\n-                       flags: c_uint) -> c_int;\n-    pub fn uv_tcp_nodelay(h: *mut uv_tcp_t, enable: c_int) -> c_int;\n-    pub fn uv_tcp_keepalive(h: *mut uv_tcp_t, enable: c_int,\n-                            delay: c_uint) -> c_int;\n-    pub fn uv_tcp_simultaneous_accepts(h: *mut uv_tcp_t, enable: c_int) -> c_int;\n-    pub fn uv_tcp_getsockname(h: *const uv_tcp_t, name: *mut sockaddr,\n-                              len: *mut c_int) -> c_int;\n-    pub fn uv_tcp_getpeername(h: *const uv_tcp_t, name: *mut sockaddr,\n-                              len: *mut c_int) -> c_int;\n-\n-    // udp bindings\n-    pub fn uv_udp_init(l: *mut uv_loop_t, h: *mut uv_udp_t) -> c_int;\n-    pub fn uv_udp_bind(h: *mut uv_udp_t, addr: *const sockaddr,\n-                       flags: c_uint) -> c_int;\n-    pub fn uv_udp_recv_start(server: *mut uv_udp_t,\n-                             on_alloc: uv_alloc_cb,\n-                             on_recv: uv_udp_recv_cb) -> c_int;\n-    pub fn uv_udp_set_membership(handle: *mut uv_udp_t,\n-                                 multicast_addr: *const c_char,\n-                                 interface_addr: *const c_char,\n-                                 membership: uv_membership) -> c_int;\n-    pub fn uv_udp_recv_stop(server: *mut uv_udp_t) -> c_int;\n-    pub fn uv_udp_set_multicast_loop(handle: *mut uv_udp_t, on: c_int) -> c_int;\n-    pub fn uv_udp_set_multicast_ttl(handle: *mut uv_udp_t, ttl: c_int) -> c_int;\n-    pub fn uv_udp_set_ttl(handle: *mut uv_udp_t, ttl: c_int) -> c_int;\n-    pub fn uv_udp_set_broadcast(handle: *mut uv_udp_t, on: c_int) -> c_int;\n-    pub fn uv_udp_getsockname(h: *const uv_udp_t, name: *mut sockaddr,\n-                              len: *mut c_int) -> c_int;\n-\n-    // timer bindings\n-    pub fn uv_timer_init(l: *mut uv_loop_t, t: *mut uv_timer_t) -> c_int;\n-    pub fn uv_timer_start(t: *mut uv_timer_t, cb: uv_timer_cb,\n-                          timeout: libc::uint64_t,\n-                          repeat: libc::uint64_t) -> c_int;\n-    pub fn uv_timer_stop(handle: *mut uv_timer_t) -> c_int;\n-\n-    // fs operations\n-    pub fn uv_fs_open(loop_ptr: *mut uv_loop_t, req: *mut uv_fs_t,\n-                      path: *const c_char, flags: c_int, mode: c_int,\n-                      cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_unlink(loop_ptr: *mut uv_loop_t, req: *mut uv_fs_t,\n-                        path: *const c_char, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_write(l: *mut uv_loop_t, req: *mut uv_fs_t, fd: c_int,\n-                       bufs: *const uv_buf_t, nbufs: c_uint,\n-                       offset: i64, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_read(l: *mut uv_loop_t, req: *mut uv_fs_t, fd: c_int,\n-                      bufs: *mut uv_buf_t, nbufs: c_uint,\n-                      offset: i64, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_close(l: *mut uv_loop_t, req: *mut uv_fs_t, fd: c_int,\n-                       cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_stat(l: *mut uv_loop_t, req: *mut uv_fs_t, path: *const c_char,\n-                      cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_fstat(l: *mut uv_loop_t, req: *mut uv_fs_t, fd: c_int,\n-                       cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_mkdir(l: *mut uv_loop_t, req: *mut uv_fs_t, path: *const c_char,\n-                       mode: c_int, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_rmdir(l: *mut uv_loop_t, req: *mut uv_fs_t, path: *const c_char,\n-                       cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_readdir(l: *mut uv_loop_t, req: *mut uv_fs_t,\n-                         path: *const c_char, flags: c_int,\n-                         cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_req_cleanup(req: *mut uv_fs_t);\n-    pub fn uv_fs_fsync(handle: *mut uv_loop_t, req: *mut uv_fs_t, file: c_int,\n-                       cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_fdatasync(handle: *mut uv_loop_t, req: *mut uv_fs_t, file: c_int,\n-                           cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_ftruncate(handle: *mut uv_loop_t, req: *mut uv_fs_t, file: c_int,\n-                           offset: i64, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_readlink(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n-                          file: *const c_char, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_symlink(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n-                         src: *const c_char, dst: *const c_char, flags: c_int,\n-                         cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_rename(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n-                        src: *const c_char, dst: *const c_char,\n-                        cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_utime(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n-                       path: *const c_char, atime: c_double, mtime: c_double,\n-                       cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_link(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n-                      src: *const c_char, dst: *const c_char,\n-                      cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_chown(handle: *mut uv_loop_t, req: *mut uv_fs_t, src: *const c_char,\n-                       uid: uv_uid_t, gid: uv_gid_t, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_chmod(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n-                       path: *const c_char, mode: c_int, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_lstat(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n-                       file: *const c_char, cb: uv_fs_cb) -> c_int;\n-\n-    // poll bindings\n-    pub fn uv_poll_init_socket(l: *mut uv_loop_t, h: *mut uv_poll_t, s: uv_os_socket_t) -> c_int;\n-    pub fn uv_poll_start(h: *mut uv_poll_t, events: c_int, cb: uv_poll_cb) -> c_int;\n-    pub fn uv_poll_stop(h: *mut uv_poll_t) -> c_int;\n-\n-    // getaddrinfo\n-    pub fn uv_getaddrinfo(loop_: *mut uv_loop_t, req: *mut uv_getaddrinfo_t,\n-                          getaddrinfo_cb: uv_getaddrinfo_cb,\n-                          node: *const c_char, service: *const c_char,\n-                          hints: *const addrinfo) -> c_int;\n-    pub fn uv_freeaddrinfo(ai: *mut addrinfo);\n-\n-    // process spawning\n-    pub fn uv_spawn(loop_ptr: *mut uv_loop_t, outptr: *mut uv_process_t,\n-                    options: *mut uv_process_options_t) -> c_int;\n-    pub fn uv_process_kill(p: *mut uv_process_t, signum: c_int) -> c_int;\n-    pub fn uv_kill(pid: c_int, signum: c_int) -> c_int;\n-\n-    // pipes\n-    pub fn uv_pipe_init(l: *mut uv_loop_t, p: *mut uv_pipe_t,\n-                        ipc: c_int) -> c_int;\n-    pub fn uv_pipe_open(pipe: *mut uv_pipe_t, file: c_int) -> c_int;\n-    pub fn uv_pipe_bind(pipe: *mut uv_pipe_t, name: *const c_char) -> c_int;\n-    pub fn uv_pipe_connect(req: *mut uv_connect_t, handle: *mut uv_pipe_t,\n-                           name: *const c_char, cb: uv_connect_cb);\n-\n-    // tty\n-    pub fn uv_tty_init(l: *mut uv_loop_t, tty: *mut uv_tty_t, fd: c_int,\n-                       readable: c_int) -> c_int;\n-    pub fn uv_tty_set_mode(tty: *mut uv_tty_t, mode: c_int) -> c_int;\n-    pub fn uv_tty_get_winsize(tty: *mut uv_tty_t,\n-                              width: *mut c_int,\n-                              height: *mut c_int) -> c_int;\n-\n-    // signals\n-    pub fn uv_signal_init(loop_: *mut uv_loop_t,\n-                          handle: *mut uv_signal_t) -> c_int;\n-    pub fn uv_signal_start(h: *mut uv_signal_t, cb: uv_signal_cb,\n-                           signum: c_int) -> c_int;\n-    pub fn uv_signal_stop(handle: *mut uv_signal_t) -> c_int;\n-}\n-\n-// libuv requires other native libraries on various platforms. These are all\n-// listed here (for each platform)\n-\n-// libuv doesn't use pthread on windows\n-// android libc (bionic) provides pthread, so no additional link is required\n-#[cfg(not(any(windows, target_os = \"android\")))]\n-#[link(name = \"pthread\")]\n-extern {}\n-\n-#[cfg(any(target_os = \"linux\", target_os = \"dragonfly\"))]\n-#[link(name = \"rt\")]\n-extern {}\n-\n-#[cfg(target_os = \"windows\")]\n-#[link(name = \"ws2_32\")]\n-#[link(name = \"psapi\")]\n-#[link(name = \"iphlpapi\")]\n-extern {}\n-\n-#[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n-#[link(name = \"kvm\")]\n-extern {}"}]}