{"sha": "7a8c6351bf50c1dcfb111be9f91da3c1f9cf2ec3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhOGM2MzUxYmY1MGMxZGNmYjExMWJlOWY5MWRhM2MxZjljZjJlYzM=", "commit": {"author": {"name": "Emil Lauridsen", "email": "mine809@gmail.com", "date": "2020-01-15T15:33:58Z"}, "committer": {"name": "Emil Lauridsen", "email": "mine809@gmail.com", "date": "2020-01-15T15:33:58Z"}, "message": "Extract check task handling into function", "tree": {"sha": "2bf69b6078dafa70a43d51ea5d6f19978eb847c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bf69b6078dafa70a43d51ea5d6f19978eb847c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a8c6351bf50c1dcfb111be9f91da3c1f9cf2ec3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a8c6351bf50c1dcfb111be9f91da3c1f9cf2ec3", "html_url": "https://github.com/rust-lang/rust/commit/7a8c6351bf50c1dcfb111be9f91da3c1f9cf2ec3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a8c6351bf50c1dcfb111be9f91da3c1f9cf2ec3/comments", "author": {"login": "kiljacken", "id": 209321, "node_id": "MDQ6VXNlcjIwOTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/209321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kiljacken", "html_url": "https://github.com/kiljacken", "followers_url": "https://api.github.com/users/kiljacken/followers", "following_url": "https://api.github.com/users/kiljacken/following{/other_user}", "gists_url": "https://api.github.com/users/kiljacken/gists{/gist_id}", "starred_url": "https://api.github.com/users/kiljacken/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kiljacken/subscriptions", "organizations_url": "https://api.github.com/users/kiljacken/orgs", "repos_url": "https://api.github.com/users/kiljacken/repos", "events_url": "https://api.github.com/users/kiljacken/events{/privacy}", "received_events_url": "https://api.github.com/users/kiljacken/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kiljacken", "id": 209321, "node_id": "MDQ6VXNlcjIwOTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/209321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kiljacken", "html_url": "https://github.com/kiljacken", "followers_url": "https://api.github.com/users/kiljacken/followers", "following_url": "https://api.github.com/users/kiljacken/following{/other_user}", "gists_url": "https://api.github.com/users/kiljacken/gists{/gist_id}", "starred_url": "https://api.github.com/users/kiljacken/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kiljacken/subscriptions", "organizations_url": "https://api.github.com/users/kiljacken/orgs", "repos_url": "https://api.github.com/users/kiljacken/repos", "events_url": "https://api.github.com/users/kiljacken/events{/privacy}", "received_events_url": "https://api.github.com/users/kiljacken/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ade657cb668d843606f87601885927515e890954", "url": "https://api.github.com/repos/rust-lang/rust/commits/ade657cb668d843606f87601885927515e890954", "html_url": "https://github.com/rust-lang/rust/commit/ade657cb668d843606f87601885927515e890954"}], "stats": {"total": 103, "additions": 56, "deletions": 47}, "files": [{"sha": "7822be2e2107ed43cf9cb7418728646816f1bec3", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 56, "deletions": 47, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/7a8c6351bf50c1dcfb111be9f91da3c1f9cf2ec3/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8c6351bf50c1dcfb111be9f91da3c1f9cf2ec3/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=7a8c6351bf50c1dcfb111be9f91da3c1f9cf2ec3", "patch": "@@ -9,7 +9,7 @@ use std::{error::Error, fmt, panic, path::PathBuf, sync::Arc, time::Instant};\n \n use crossbeam_channel::{select, unbounded, RecvError, Sender};\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n-use lsp_types::{ClientCapabilities, NumberOrString};\n+use lsp_types::{ClientCapabilities, NumberOrString, Url};\n use ra_cargo_watch::{CheckOptions, CheckTask};\n use ra_ide::{Canceled, FeatureFlags, FileId, LibraryData, SourceRootId};\n use ra_prof::profile;\n@@ -336,52 +336,7 @@ fn loop_turn(\n             world_state.maybe_collect_garbage();\n             loop_state.in_flight_libraries -= 1;\n         }\n-        Event::CheckWatcher(task) => match task {\n-            CheckTask::ClearDiagnostics => {\n-                let cleared_files = world_state.check_watcher.state.write().clear();\n-\n-                // Send updated diagnostics for each cleared file\n-                for url in cleared_files {\n-                    let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n-                    if let Some(file_id) = world_state.vfs.read().path2file(&path) {\n-                        let params = handlers::publish_diagnostics(\n-                            &world_state.snapshot(),\n-                            FileId(file_id.0),\n-                        )?;\n-                        let not = notification_new::<req::PublishDiagnostics>(params);\n-                        task_sender.send(Task::Notify(not)).unwrap();\n-                    }\n-                }\n-            }\n-\n-            CheckTask::AddDiagnostic(url, diagnostic) => {\n-                world_state\n-                    .check_watcher\n-                    .state\n-                    .write()\n-                    .add_diagnostic_with_fixes(url.clone(), diagnostic);\n-\n-                // We manually send a diagnostic update when the watcher asks\n-                // us to, to avoid the issue of having to change the file to\n-                // receive updated diagnostics.\n-                let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n-                if let Some(file_id) = world_state.vfs.read().path2file(&path) {\n-                    let params =\n-                        handlers::publish_diagnostics(&world_state.snapshot(), FileId(file_id.0))?;\n-                    let not = notification_new::<req::PublishDiagnostics>(params);\n-                    task_sender.send(Task::Notify(not)).unwrap();\n-                }\n-            }\n-\n-            CheckTask::Status(progress) => {\n-                let params = req::ProgressParams {\n-                    token: req::ProgressToken::String(\"rustAnalyzer/cargoWatcher\".to_string()),\n-                    value: req::ProgressParamsValue::WorkDone(progress),\n-                };\n-                let not = notification_new::<req::Progress>(params);\n-                task_sender.send(Task::Notify(not)).unwrap();\n-            }\n-        },\n+        Event::CheckWatcher(task) => on_check_task(task, world_state, task_sender)?,\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n                 world_state,\n@@ -629,6 +584,60 @@ fn on_notification(\n     Ok(())\n }\n \n+fn on_check_task(\n+    task: CheckTask,\n+    world_state: &WorldState,\n+    task_sender: &Sender<Task>,\n+) -> Result<()> {\n+    match task {\n+        CheckTask::ClearDiagnostics => {\n+            let cleared_files = world_state.check_watcher.state.write().clear();\n+\n+            // Send updated diagnostics for each cleared file\n+            for url in cleared_files {\n+                publish_diagnostics_for_url(&url, world_state, task_sender)?;\n+            }\n+        }\n+\n+        CheckTask::AddDiagnostic(url, diagnostic) => {\n+            world_state\n+                .check_watcher\n+                .state\n+                .write()\n+                .add_diagnostic_with_fixes(url.clone(), diagnostic);\n+\n+            // We manually send a diagnostic update when the watcher asks\n+            // us to, to avoid the issue of having to change the file to\n+            // receive updated diagnostics.\n+            publish_diagnostics_for_url(&url, world_state, task_sender)?;\n+        }\n+\n+        CheckTask::Status(progress) => {\n+            let params = req::ProgressParams {\n+                token: req::ProgressToken::String(\"rustAnalyzer/cargoWatcher\".to_string()),\n+                value: req::ProgressParamsValue::WorkDone(progress),\n+            };\n+            let not = notification_new::<req::Progress>(params);\n+            task_sender.send(Task::Notify(not)).unwrap();\n+        }\n+    }\n+    Ok(())\n+}\n+\n+fn publish_diagnostics_for_url(\n+    url: &Url,\n+    world_state: &WorldState,\n+    task_sender: &Sender<Task>,\n+) -> Result<()> {\n+    let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n+    if let Some(file_id) = world_state.vfs.read().path2file(&path) {\n+        let params = handlers::publish_diagnostics(&world_state.snapshot(), FileId(file_id.0))?;\n+        let not = notification_new::<req::PublishDiagnostics>(params);\n+        task_sender.send(Task::Notify(not)).unwrap();\n+    }\n+    Ok(())\n+}\n+\n struct PoolDispatcher<'a> {\n     req: Option<Request>,\n     pool: &'a ThreadPool,"}]}