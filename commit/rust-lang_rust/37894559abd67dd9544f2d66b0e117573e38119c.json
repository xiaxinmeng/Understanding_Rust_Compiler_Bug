{"sha": "37894559abd67dd9544f2d66b0e117573e38119c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ODk0NTU5YWJkNjdkZDk1NDRmMmQ2NmIwZTExNzU3M2UzODExOWM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-29T19:58:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-29T19:58:34Z"}, "message": "Rollup merge of #72439 - westernmagic:master, r=Amanieu\n\nNVPTX support for new asm!\n\nThis PR implements the new `asm!` syntax for the `nvptx64-nvidia-cuda` target.\n\nr? @Amanieu", "tree": {"sha": "7181e9b4fbc17f325d4a0147b5e379589c7671e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7181e9b4fbc17f325d4a0147b5e379589c7671e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37894559abd67dd9544f2d66b0e117573e38119c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe0WlqCRBK7hj4Ov3rIwAAdHIIAHjuphm/km1Arc7WCqH4NYgZ\nvhgMID6wAKOI94tzw47DXrO08955JlgccxGCyDr8serxLVMW3XgFSpLEqP5qKxtt\nOS4KZ5vg8RsRB8HMx45Eg++e8lYJBGKHsxM/NJbeR6byskBNgk64jOze6IfXYITq\nP5aZl/qnvwu4cMz2h91SOr4IHBD/NM8E25XGRTClLPIXhOl016KBWYgeibzNbQ6w\n5AdnXpuE+c4rdEGRUKteET4SdrBCMqvk4oBI9xoMmnN6J3CvEpEDmJTtu58rYY3S\naUn9AZTEvKcn1G9QQShtZeDZQwa46J/beGWWjYT4QJNosV3trF4gfkhH94IPy4o=\n=ztdt\n-----END PGP SIGNATURE-----\n", "payload": "tree 7181e9b4fbc17f325d4a0147b5e379589c7671e9\nparent b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76\nparent e18054d5c07c2303380b47c3ea21f5bd7cccddc9\nauthor Ralf Jung <post@ralfj.de> 1590782314 +0200\ncommitter GitHub <noreply@github.com> 1590782314 +0200\n\nRollup merge of #72439 - westernmagic:master, r=Amanieu\n\nNVPTX support for new asm!\n\nThis PR implements the new `asm!` syntax for the `nvptx64-nvidia-cuda` target.\n\nr? @Amanieu\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37894559abd67dd9544f2d66b0e117573e38119c", "html_url": "https://github.com/rust-lang/rust/commit/37894559abd67dd9544f2d66b0e117573e38119c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37894559abd67dd9544f2d66b0e117573e38119c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76", "url": "https://api.github.com/repos/rust-lang/rust/commits/b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76", "html_url": "https://github.com/rust-lang/rust/commit/b965196ce0bb0b484336f1f2ba3a6a72cbfb4f76"}, {"sha": "e18054d5c07c2303380b47c3ea21f5bd7cccddc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e18054d5c07c2303380b47c3ea21f5bd7cccddc9", "html_url": "https://github.com/rust-lang/rust/commit/e18054d5c07c2303380b47c3ea21f5bd7cccddc9"}], "stats": {"total": 230, "additions": 227, "deletions": 3}, "files": [{"sha": "ea560a6d70915a1d51d7bf1cd7e75c29084cceb3", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/37894559abd67dd9544f2d66b0e117573e38119c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/37894559abd67dd9544f2d66b0e117573e38119c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=37894559abd67dd9544f2d66b0e117573e38119c", "patch": "@@ -468,12 +468,17 @@ Here is the list of currently supported register classes:\n | ARM | `qreg` | `q[0-15]` | `w` |\n | ARM | `qreg_low8` | `q[0-7]` | `t` |\n | ARM | `qreg_low4` | `q[0-3]` | `x` |\n+| NVPTX | `reg16` | None\\* | `h` |\n+| NVPTX | `reg32` | None\\* | `r` |\n+| NVPTX | `reg64` | None\\* | `l` |\n | RISC-V | `reg` | `x1`, `x[5-7]`, `x[9-15]`, `x[16-31]` (non-RV32E) | `r` |\n | RISC-V | `freg` | `f[0-31]` | `f` |\n \n > **Note**: On x86 we treat `reg_byte` differently from `reg` because the compiler can allocate `al` and `ah` separately whereas `reg` reserves the whole register.\n >\n > Note #2: On x86-64 the high byte registers (e.g. `ah`) are only available when used as an explicit register. Specifying the `reg_byte` register class for an operand will always allocate a low byte register.\n+>\n+> Note #3: NVPTX doesn't have a fixed register set, so named registers are not supported.\n \n Additional register classes may be added in the future based on demand (e.g. MMX, x87, etc).\n \n@@ -495,6 +500,9 @@ Each register class has constraints on which value types they can be used with.\n | ARM | `sreg` | `vfp2` | `i32`, `f32` |\n | ARM | `dreg` | `vfp2` | `i64`, `f64`, `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2` |\n | ARM | `qreg` | `neon` | `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4` |\n+| NVPTX | `reg16` | None | `i8`, `i16` |\n+| NVPTX | `reg32` | None | `i8`, `i16`, `i32`, `f32` |\n+| NVPTX | `reg64` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n | RISC-V32 | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n | RISC-V64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n | RISC-V | `freg` | `f` | `f32` |\n@@ -610,6 +618,9 @@ The supported modifiers are a subset of LLVM's (and GCC's) [asm template argumen\n | ARM | `dreg` | None | `d0` | `P` |\n | ARM | `qreg` | None | `q0` | `q` |\n | ARM | `qreg` | `e` / `f` | `d0` / `d1` | `e` / `f` |\n+| NVPTX | `reg16` | None | `rs0` | None |\n+| NVPTX | `reg32` | None | `r0` | None |\n+| NVPTX | `reg64` | None | `rd0` | None |\n | RISC-V | `reg` | None | `x1` | None |\n | RISC-V | `freg` | None | `f0` | None |\n "}, {"sha": "f3b46dd322a39988e31a6d4ab77d80055febc5f5", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37894559abd67dd9544f2d66b0e117573e38119c/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37894559abd67dd9544f2d66b0e117573e38119c/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=37894559abd67dd9544f2d66b0e117573e38119c", "patch": "@@ -254,6 +254,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     ]);\n                 }\n                 InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {}\n+                InlineAsmArch::Nvptx64 => {}\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -410,6 +411,9 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass) -> String {\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => \"x\",\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => \"w\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => \"h\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => \"r\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => \"l\",\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n@@ -452,6 +456,7 @@ fn modifier_to_llvm(\n                 modifier\n             }\n         }\n+        InlineAsmRegClass::Nvptx(_) => None,\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n         | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => None,\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n@@ -502,6 +507,9 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n             cx.type_vector(cx.type_i64(), 2)\n         }\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => cx.type_i16(),\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => cx.type_i32(),\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => cx.type_i64(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => cx.type_f32(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)"}, {"sha": "a18a4dbd3e214f9a764fac279df862e3f5373981", "filename": "src/librustc_target/asm/mod.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/37894559abd67dd9544f2d66b0e117573e38119c/src%2Flibrustc_target%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37894559abd67dd9544f2d66b0e117573e38119c/src%2Flibrustc_target%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fmod.rs?ref=37894559abd67dd9544f2d66b0e117573e38119c", "patch": "@@ -60,6 +60,7 @@ macro_rules! def_regs {\n             #error = [$($bad_reg:literal),+] => $error:literal,\n         )*\n     }) => {\n+        #[allow(unreachable_code)]\n         #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n         #[allow(non_camel_case_types)]\n         pub enum $arch_reg {\n@@ -102,19 +103,20 @@ macro_rules! def_regs {\n         pub(super) fn fill_reg_map(\n             _arch: super::InlineAsmArch,\n             mut _has_feature: impl FnMut(&str) -> bool,\n-            map: &mut rustc_data_structures::fx::FxHashMap<\n+            _map: &mut rustc_data_structures::fx::FxHashMap<\n                 super::InlineAsmRegClass,\n                 rustc_data_structures::fx::FxHashSet<super::InlineAsmReg>,\n             >,\n         ) {\n+            #[allow(unused_imports)]\n             use super::{InlineAsmReg, InlineAsmRegClass};\n             $(\n                 if $($filter(_arch, &mut _has_feature, true).is_ok() &&)? true {\n-                    if let Some(set) = map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$class)) {\n+                    if let Some(set) = _map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$class)) {\n                         set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n                     }\n                     $(\n-                        if let Some(set) = map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$extra_class)) {\n+                        if let Some(set) = _map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$extra_class)) {\n                             set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n                         }\n                     )*\n@@ -146,11 +148,13 @@ macro_rules! types {\n \n mod aarch64;\n mod arm;\n+mod nvptx;\n mod riscv;\n mod x86;\n \n pub use aarch64::{AArch64InlineAsmReg, AArch64InlineAsmRegClass};\n pub use arm::{ArmInlineAsmReg, ArmInlineAsmRegClass};\n+pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n pub use riscv::{RiscVInlineAsmReg, RiscVInlineAsmRegClass};\n pub use x86::{X86InlineAsmReg, X86InlineAsmRegClass};\n \n@@ -162,6 +166,7 @@ pub enum InlineAsmArch {\n     AArch64,\n     RiscV32,\n     RiscV64,\n+    Nvptx64,\n }\n \n impl FromStr for InlineAsmArch {\n@@ -175,6 +180,7 @@ impl FromStr for InlineAsmArch {\n             \"aarch64\" => Ok(Self::AArch64),\n             \"riscv32\" => Ok(Self::RiscV32),\n             \"riscv64\" => Ok(Self::RiscV64),\n+            \"nvptx64\" => Ok(Self::Nvptx64),\n             _ => Err(()),\n         }\n     }\n@@ -196,6 +202,7 @@ pub enum InlineAsmReg {\n     Arm(ArmInlineAsmReg),\n     AArch64(AArch64InlineAsmReg),\n     RiscV(RiscVInlineAsmReg),\n+    Nvptx(NvptxInlineAsmReg),\n }\n \n impl InlineAsmReg {\n@@ -236,6 +243,9 @@ impl InlineAsmReg {\n             InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n                 Self::RiscV(RiscVInlineAsmReg::parse(arch, has_feature, &name)?)\n             }\n+            InlineAsmArch::Nvptx64 => {\n+                Self::Nvptx(NvptxInlineAsmReg::parse(arch, has_feature, &name)?)\n+            }\n         })\n     }\n \n@@ -281,6 +291,7 @@ pub enum InlineAsmRegClass {\n     Arm(ArmInlineAsmRegClass),\n     AArch64(AArch64InlineAsmRegClass),\n     RiscV(RiscVInlineAsmRegClass),\n+    Nvptx(NvptxInlineAsmRegClass),\n }\n \n impl InlineAsmRegClass {\n@@ -290,6 +301,7 @@ impl InlineAsmRegClass {\n             Self::Arm(r) => r.name(),\n             Self::AArch64(r) => r.name(),\n             Self::RiscV(r) => r.name(),\n+            Self::Nvptx(r) => r.name(),\n         }\n     }\n \n@@ -302,6 +314,7 @@ impl InlineAsmRegClass {\n             Self::Arm(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Arm),\n             Self::AArch64(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::AArch64),\n             Self::RiscV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::RiscV),\n+            Self::Nvptx(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Nvptx),\n         }\n     }\n \n@@ -321,6 +334,7 @@ impl InlineAsmRegClass {\n             Self::Arm(r) => r.suggest_modifier(arch, ty),\n             Self::AArch64(r) => r.suggest_modifier(arch, ty),\n             Self::RiscV(r) => r.suggest_modifier(arch, ty),\n+            Self::Nvptx(r) => r.suggest_modifier(arch, ty),\n         }\n     }\n \n@@ -336,6 +350,7 @@ impl InlineAsmRegClass {\n             Self::Arm(r) => r.default_modifier(arch),\n             Self::AArch64(r) => r.default_modifier(arch),\n             Self::RiscV(r) => r.default_modifier(arch),\n+            Self::Nvptx(r) => r.default_modifier(arch),\n         }\n     }\n \n@@ -350,6 +365,7 @@ impl InlineAsmRegClass {\n             Self::Arm(r) => r.supported_types(arch),\n             Self::AArch64(r) => r.supported_types(arch),\n             Self::RiscV(r) => r.supported_types(arch),\n+            Self::Nvptx(r) => r.supported_types(arch),\n         }\n     }\n \n@@ -367,6 +383,7 @@ impl InlineAsmRegClass {\n                 InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n                     Self::RiscV(RiscVInlineAsmRegClass::parse(arch, name)?)\n                 }\n+                InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmRegClass::parse(arch, name)?),\n             })\n         })\n     }\n@@ -379,6 +396,7 @@ impl InlineAsmRegClass {\n             Self::Arm(r) => r.valid_modifiers(arch),\n             Self::AArch64(r) => r.valid_modifiers(arch),\n             Self::RiscV(r) => r.valid_modifiers(arch),\n+            Self::Nvptx(r) => r.valid_modifiers(arch),\n         }\n     }\n }\n@@ -518,5 +536,10 @@ pub fn allocatable_registers(\n             riscv::fill_reg_map(arch, has_feature, &mut map);\n             map\n         }\n+        InlineAsmArch::Nvptx64 => {\n+            let mut map = nvptx::regclass_map();\n+            nvptx::fill_reg_map(arch, has_feature, &mut map);\n+            map\n+        }\n     }\n }"}, {"sha": "43d16ae0f5d102a51db4d16691e503c8f1b7fc3f", "filename": "src/librustc_target/asm/nvptx.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/37894559abd67dd9544f2d66b0e117573e38119c/src%2Flibrustc_target%2Fasm%2Fnvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37894559abd67dd9544f2d66b0e117573e38119c/src%2Flibrustc_target%2Fasm%2Fnvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fnvptx.rs?ref=37894559abd67dd9544f2d66b0e117573e38119c", "patch": "@@ -0,0 +1,49 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+\n+def_reg_class! {\n+    Nvptx NvptxInlineAsmRegClass {\n+        reg16,\n+        reg32,\n+        reg64,\n+    }\n+}\n+\n+impl NvptxInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg16 => types! { _: I8, I16; },\n+            Self::reg32 => types! { _: I8, I16, I32, F32; },\n+            Self::reg64 => types! { _: I8, I16, I32, F32, I64, F64; },\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    // Registers in PTX are declared in the assembly.\n+    // There are no predefined registers that one can use.\n+    Nvptx NvptxInlineAsmReg NvptxInlineAsmRegClass {}\n+}"}, {"sha": "4ee79d1bcc8396a92ef766553288cdcf894d0316", "filename": "src/test/assembly/asm/nvptx-types.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/37894559abd67dd9544f2d66b0e117573e38119c/src%2Ftest%2Fassembly%2Fasm%2Fnvptx-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37894559abd67dd9544f2d66b0e117573e38119c/src%2Ftest%2Fassembly%2Fasm%2Fnvptx-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fnvptx-types.rs?ref=37894559abd67dd9544f2d66b0e117573e38119c", "patch": "@@ -0,0 +1,133 @@\n+// no-system-llvm\n+// assembly-output: emit-asm\n+// compile-flags: --target nvptx64-nvidia-cuda\n+// compile-flags: --crate-type cdylib\n+\n+#![feature(no_core, lang_items, rustc_attrs)]\n+#![no_core]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *mut u8;\n+\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for f32 {}\n+impl Copy for i64 {}\n+impl Copy for f64 {}\n+impl Copy for ptr {}\n+\n+// NVPTX does not support static variables\n+#[no_mangle]\n+fn extern_func() {}\n+\n+// CHECK-LABEL: .visible .func sym_fn()\n+// CHECK: // begin inline asm\n+// CHECK: call extern_func;\n+// CHECK: // end inline asm\n+#[no_mangle]\n+pub unsafe fn sym_fn() {\n+    asm!(\"call {};\", sym extern_func);\n+}\n+\n+macro_rules! check {\n+    ($func:ident $ty:ident $class:ident $mov:literal) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(concat!($mov, \" {}, {};\"), out($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg16_i8\n+// CHECK: // begin inline asm\n+// CHECK: mov.i16 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg16_i8 i8 reg16 \"mov.i16\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg16_i16\n+// CHECK: // begin inline asm\n+// CHECK: mov.i16 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg16_i16 i16 reg16 \"mov.i16\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg32_i8\n+// CHECK: // begin inline asm\n+// CHECK: mov.i32 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg32_i8 i8 reg32 \"mov.i32\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg32_i16\n+// CHECK: // begin inline asm\n+// CHECK: mov.i32 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg32_i16 i16 reg32 \"mov.i32\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg32_i32\n+// CHECK: // begin inline asm\n+// CHECK: mov.i32 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg32_i32 i32 reg32 \"mov.i32\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg32_f32\n+// CHECK: // begin inline asm\n+// CHECK: mov.i32 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg32_f32 f32 reg32 \"mov.i32\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg64_i8\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_i8 i8 reg64 \"mov.i64\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg64_i16\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_i16 i16 reg64 \"mov.i64\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg64_i32\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_i32 i32 reg64 \"mov.i64\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg64_f32\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_f32 f32 reg64 \"mov.i64\");\n+\n+// CHECK-LABEL: .visible .func (.param .b64 func_retval0) reg64_i64\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_i64 i64 reg64 \"mov.i64\");\n+\n+// CHECK-LABEL: .visible .func (.param .b64 func_retval0) reg64_f64\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_f64 f64 reg64 \"mov.i64\");\n+\n+// CHECK-LABEL: .visible .func (.param .b64 func_retval0) reg64_ptr\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_ptr ptr reg64 \"mov.i64\");"}]}