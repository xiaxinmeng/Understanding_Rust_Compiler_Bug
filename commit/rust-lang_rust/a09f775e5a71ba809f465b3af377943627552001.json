{"sha": "a09f775e5a71ba809f465b3af377943627552001", "node_id": "C_kwDOAAsO6NoAKGEwOWY3NzVlNWE3MWJhODA5ZjQ2NWIzYWYzNzc5NDM2Mjc1NTIwMDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-30T20:53:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-30T20:53:39Z"}, "message": "Auto merge of #92426 - calebcartwright:sync-rustfmt-subtree, r=calebcartwright\n\nSync rustfmt subtree\n\nr? `@ghost`\n\nMostly refactoring and a few minor lint fixes, along with a couple small bug fixes", "tree": {"sha": "5aafb762c9cf254fe4a9c10cc47570a1079d58cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5aafb762c9cf254fe4a9c10cc47570a1079d58cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a09f775e5a71ba809f465b3af377943627552001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a09f775e5a71ba809f465b3af377943627552001", "html_url": "https://github.com/rust-lang/rust/commit/a09f775e5a71ba809f465b3af377943627552001", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a09f775e5a71ba809f465b3af377943627552001/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b60e32c82864d841e87359333af1e6d1f9cff9ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/b60e32c82864d841e87359333af1e6d1f9cff9ee", "html_url": "https://github.com/rust-lang/rust/commit/b60e32c82864d841e87359333af1e6d1f9cff9ee"}, {"sha": "521fdcbe4ddaa717be2acbeb30f8978d6378fea1", "url": "https://api.github.com/repos/rust-lang/rust/commits/521fdcbe4ddaa717be2acbeb30f8978d6378fea1", "html_url": "https://github.com/rust-lang/rust/commit/521fdcbe4ddaa717be2acbeb30f8978d6378fea1"}], "stats": {"total": 1120, "additions": 710, "deletions": 410}, "files": [{"sha": "d4cdcec2018aa6cb61a2fd8a01527321b1a2cbb6", "filename": "src/tools/rustfmt/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Frust-toolchain?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-11-08\"\n+channel = \"nightly-2021-12-29\"\n components = [\"rustc-dev\"]"}, {"sha": "4d845547cdfed179647f86dca9bd0e36c3740211", "filename": "src/tools/rustfmt/src/bin/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -26,7 +26,7 @@ fn main() {\n     let exit_code = match execute(&opts) {\n         Ok(code) => code,\n         Err(e) => {\n-            eprintln!(\"{}\", e.to_string());\n+            eprintln!(\"{}\", e);\n             1\n         }\n     };"}, {"sha": "e688db1c39d7c79209178ef2c1ae108fa909647d", "filename": "src/tools/rustfmt/src/closures.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -236,21 +236,21 @@ fn rewrite_closure_fn_decl(\n     context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<(String, usize)> {\n-    let is_async = if asyncness.is_async() { \"async \" } else { \"\" };\n-    let mover = if capture == ast::CaptureBy::Value {\n-        \"move \"\n+    let immovable = if movability == ast::Movability::Static {\n+        \"static \"\n     } else {\n         \"\"\n     };\n-    let immovable = if movability == ast::Movability::Static {\n-        \"static \"\n+    let is_async = if asyncness.is_async() { \"async \" } else { \"\" };\n+    let mover = if capture == ast::CaptureBy::Value {\n+        \"move \"\n     } else {\n         \"\"\n     };\n     // 4 = \"|| {\".len(), which is overconservative when the closure consists of\n     // a single expression.\n     let nested_shape = shape\n-        .shrink_left(is_async.len() + mover.len() + immovable.len())?\n+        .shrink_left(immovable.len() + is_async.len() + mover.len())?\n         .sub_width(4)?;\n \n     // 1 = |\n@@ -288,7 +288,7 @@ fn rewrite_closure_fn_decl(\n         .tactic(tactic)\n         .preserve_newline(true);\n     let list_str = write_list(&item_vec, &fmt)?;\n-    let mut prefix = format!(\"{}{}{}|{}|\", is_async, immovable, mover, list_str);\n+    let mut prefix = format!(\"{}{}{}|{}|\", immovable, is_async, mover, list_str);\n \n     if !ret_str.is_empty() {\n         if prefix.contains('\\n') {"}, {"sha": "7b498dc46b320cd1444274cf17921fd5394326a9", "filename": "src/tools/rustfmt/src/config/file_lines.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Ffile_lines.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -13,9 +13,9 @@ use thiserror::Error;\n \n /// A range of lines in a file, inclusive of both ends.\n pub struct LineRange {\n-    pub file: Lrc<SourceFile>,\n-    pub lo: usize,\n-    pub hi: usize,\n+    pub(crate) file: Lrc<SourceFile>,\n+    pub(crate) lo: usize,\n+    pub(crate) hi: usize,\n }\n \n /// Defines the name of an input - either a file or stdin.\n@@ -75,7 +75,7 @@ impl Serialize for FileName {\n }\n \n impl LineRange {\n-    pub fn file_name(&self) -> FileName {\n+    pub(crate) fn file_name(&self) -> FileName {\n         self.file.name.clone().into()\n     }\n }"}, {"sha": "d857c29be29c631bb42d3fd0c4439f8ae6fedaf9", "filename": "src/tools/rustfmt/src/config/options.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Foptions.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -218,24 +218,24 @@ pub enum Verbosity {\n pub struct WidthHeuristics {\n     // Maximum width of the args of a function call before falling back\n     // to vertical formatting.\n-    pub fn_call_width: usize,\n+    pub(crate) fn_call_width: usize,\n     // Maximum width of the args of a function-like attributes before falling\n     // back to vertical formatting.\n-    pub attr_fn_like_width: usize,\n+    pub(crate) attr_fn_like_width: usize,\n     // Maximum width in the body of a struct lit before falling back to\n     // vertical formatting.\n-    pub struct_lit_width: usize,\n+    pub(crate) struct_lit_width: usize,\n     // Maximum width in the body of a struct variant before falling back\n     // to vertical formatting.\n-    pub struct_variant_width: usize,\n+    pub(crate) struct_variant_width: usize,\n     // Maximum width of an array literal before falling back to vertical\n     // formatting.\n-    pub array_width: usize,\n+    pub(crate) array_width: usize,\n     // Maximum length of a chain to fit on a single line.\n-    pub chain_width: usize,\n+    pub(crate) chain_width: usize,\n     // Maximum line length for single line if-else expressions. A value\n     // of zero means always break if-else expressions.\n-    pub single_line_if_else_max_width: usize,\n+    pub(crate) single_line_if_else_max_width: usize,\n }\n \n impl fmt::Display for WidthHeuristics {"}, {"sha": "c9c8852cd3b56276d223ac6acc1b7ea79b73e643", "filename": "src/tools/rustfmt/src/expr.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -108,9 +108,21 @@ pub(crate) fn format_expr(\n         ast::ExprKind::Unary(op, ref subexpr) => rewrite_unary_op(context, op, subexpr, shape),\n         ast::ExprKind::Struct(ref struct_expr) => {\n             let ast::StructExpr {\n-                fields, path, rest, ..\n+                qself,\n+                fields,\n+                path,\n+                rest,\n             } = &**struct_expr;\n-            rewrite_struct_lit(context, path, fields, rest, &expr.attrs, expr.span, shape)\n+            rewrite_struct_lit(\n+                context,\n+                path,\n+                qself.as_ref(),\n+                fields,\n+                rest,\n+                &expr.attrs,\n+                expr.span,\n+                shape,\n+            )\n         }\n         ast::ExprKind::Tup(ref items) => {\n             rewrite_tuple(context, items.iter(), expr.span, shape, items.len() == 1)\n@@ -1511,6 +1523,7 @@ fn struct_lit_can_be_aligned(fields: &[ast::ExprField], has_base: bool) -> bool\n fn rewrite_struct_lit<'a>(\n     context: &RewriteContext<'_>,\n     path: &ast::Path,\n+    qself: Option<&ast::QSelf>,\n     fields: &'a [ast::ExprField],\n     struct_rest: &ast::StructRest,\n     attrs: &[ast::Attribute],\n@@ -1527,7 +1540,7 @@ fn rewrite_struct_lit<'a>(\n \n     // 2 = \" {\".len()\n     let path_shape = shape.sub_width(2)?;\n-    let path_str = rewrite_path(context, PathContext::Expr, None, path, path_shape)?;\n+    let path_str = rewrite_path(context, PathContext::Expr, qself, path, path_shape)?;\n \n     let has_base_or_rest = match struct_rest {\n         ast::StructRest::None if fields.is_empty() => return Some(format!(\"{} {{}}\", path_str)),\n@@ -2003,9 +2016,7 @@ fn choose_rhs<R: Rewrite>(\n     has_rhs_comment: bool,\n ) -> Option<String> {\n     match orig_rhs {\n-        Some(ref new_str) if new_str.is_empty() => {\n-            return Some(String::new());\n-        }\n+        Some(ref new_str) if new_str.is_empty() => Some(String::new()),\n         Some(ref new_str)\n             if !new_str.contains('\\n') && unicode_str_width(new_str) <= shape.width =>\n         {"}, {"sha": "67cf1232f66abe93f3905070f965ad72a70066c5", "filename": "src/tools/rustfmt/src/formatting.rs", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -5,6 +5,7 @@ use std::io::{self, Write};\n use std::time::{Duration, Instant};\n \n use rustc_ast::ast;\n+use rustc_ast::AstLike;\n use rustc_span::Span;\n \n use self::newline_style::apply_newline_style;\n@@ -13,9 +14,9 @@ use crate::config::{Config, FileName, Verbosity};\n use crate::formatting::generated::is_generated_file;\n use crate::issues::BadIssueSeeker;\n use crate::modules::Module;\n-use crate::syntux::parser::{DirectoryOwnership, Parser, ParserError};\n-use crate::syntux::session::ParseSess;\n-use crate::utils::count_newlines;\n+use crate::parse::parser::{DirectoryOwnership, Parser, ParserError};\n+use crate::parse::session::ParseSess;\n+use crate::utils::{contains_skip, count_newlines};\n use crate::visitor::FmtVisitor;\n use crate::{modules, source_file, ErrorKind, FormatReport, Input, Session};\n \n@@ -58,6 +59,39 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n     }\n }\n \n+/// Determine if a module should be skipped. True if the module should be skipped, false otherwise.\n+fn should_skip_module<T: FormatHandler>(\n+    config: &Config,\n+    context: &FormatContext<'_, T>,\n+    input_is_stdin: bool,\n+    main_file: &FileName,\n+    path: &FileName,\n+    module: &Module<'_>,\n+) -> bool {\n+    if contains_skip(module.attrs()) {\n+        return true;\n+    }\n+\n+    if config.skip_children() && path != main_file {\n+        return true;\n+    }\n+\n+    if !input_is_stdin && context.ignore_file(path) {\n+        return true;\n+    }\n+\n+    if !config.format_generated_files() {\n+        let source_file = context.parse_session.span_to_file_contents(module.span);\n+        let src = source_file.src.as_ref().expect(\"SourceFile without src\");\n+\n+        if is_generated_file(src) {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}\n+\n // Format an entire crate (or subset of the module tree).\n fn format_project<T: FormatHandler>(\n     input: Input,\n@@ -97,23 +131,19 @@ fn format_project<T: FormatHandler>(\n         directory_ownership.unwrap_or(DirectoryOwnership::UnownedViaBlock),\n         !input_is_stdin && !config.skip_children(),\n     )\n-    .visit_crate(&krate)?;\n+    .visit_crate(&krate)?\n+    .into_iter()\n+    .filter(|(path, module)| {\n+        !should_skip_module(config, &context, input_is_stdin, &main_file, path, module)\n+    })\n+    .collect::<Vec<_>>();\n \n     timer = timer.done_parsing();\n \n     // Suppress error output if we have to do any further parsing.\n     context.parse_session.set_silent_emitter();\n \n     for (path, module) in files {\n-        let source_file = context.parse_session.span_to_file_contents(module.span);\n-        let src = source_file.src.as_ref().expect(\"SourceFile without src\");\n-\n-        let should_ignore = (!input_is_stdin && context.ignore_file(&path))\n-            || (!config.format_generated_files() && is_generated_file(src));\n-\n-        if (config.skip_children() && path != main_file) || should_ignore {\n-            continue;\n-        }\n         should_emit_verbose(input_is_stdin, config, || println!(\"Formatting {}\", path));\n         context.format_file(path, &module, is_macro_def)?;\n     }"}, {"sha": "babc56f86edc6db1a23ce47472563b9a2d71d10e", "filename": "src/tools/rustfmt/src/items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -1535,15 +1535,15 @@ pub(crate) fn rewrite_type_alias<'a, 'b>(\n     // https://rustc-dev-guide.rust-lang.org/opaque-types-type-alias-impl-trait.html\n     // https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/items.md#type-aliases\n     match (visitor_kind, &op_ty) {\n-        (Item(_) | AssocTraitItem(_) | ForeignItem(_), Some(ref op_bounds)) => {\n+        (Item(_) | AssocTraitItem(_) | ForeignItem(_), Some(op_bounds)) => {\n             let op = OpaqueType { bounds: op_bounds };\n             rewrite_ty(rw_info, Some(bounds), Some(&op), vis)\n         }\n         (Item(_) | AssocTraitItem(_) | ForeignItem(_), None) => {\n             rewrite_ty(rw_info, Some(bounds), ty_opt, vis)\n         }\n         (AssocImplItem(_), _) => {\n-            let result = if let Some(ref op_bounds) = op_ty {\n+            let result = if let Some(op_bounds) = op_ty {\n                 let op = OpaqueType { bounds: op_bounds };\n                 rewrite_ty(rw_info, Some(bounds), Some(&op), &DEFAULT_VISIBILITY)\n             } else {\n@@ -3124,7 +3124,7 @@ impl Rewrite for ast::ForeignItem {\n                     let inner_attrs = inner_attributes(&self.attrs);\n                     let fn_ctxt = visit::FnCtxt::Foreign;\n                     visitor.visit_fn(\n-                        visit::FnKind::Fn(fn_ctxt, self.ident, &sig, &self.vis, Some(body)),\n+                        visit::FnKind::Fn(fn_ctxt, self.ident, sig, &self.vis, Some(body)),\n                         generics,\n                         &sig.decl,\n                         self.span,\n@@ -3137,7 +3137,7 @@ impl Rewrite for ast::ForeignItem {\n                         context,\n                         shape.indent,\n                         self.ident,\n-                        &FnSig::from_method_sig(&sig, generics, &self.vis),\n+                        &FnSig::from_method_sig(sig, generics, &self.vis),\n                         span,\n                         FnBraceStyle::None,\n                     )\n@@ -3166,7 +3166,7 @@ impl Rewrite for ast::ForeignItem {\n                 .map(|s| s + \";\")\n             }\n             ast::ForeignItemKind::TyAlias(ref ty_alias) => {\n-                let (kind, span) = (&ItemVisitorKind::ForeignItem(&self), self.span);\n+                let (kind, span) = (&ItemVisitorKind::ForeignItem(self), self.span);\n                 rewrite_type_alias(ty_alias, context, shape.indent, kind, span)\n             }\n             ast::ForeignItemKind::MacCall(ref mac) => {"}, {"sha": "ad23b16e02ec19d11c1e7cacd3ac27e81bc5fd71", "filename": "src/tools/rustfmt/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -15,6 +15,7 @@ extern crate log;\n // N.B. these crates are loaded from the sysroot, so they need extern crate.\n extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n+extern crate rustc_builtin_macros;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n extern crate rustc_expand;\n@@ -40,8 +41,8 @@ use crate::emitter::Emitter;\n use crate::formatting::{FormatErrorMap, FormattingError, ReportedErrors, SourceFile};\n use crate::issues::Issue;\n use crate::modules::ModuleResolutionError;\n+use crate::parse::parser::DirectoryOwnership;\n use crate::shape::Indent;\n-use crate::syntux::parser::DirectoryOwnership;\n use crate::utils::indent_next_line;\n \n pub use crate::config::{\n@@ -77,6 +78,7 @@ mod missed_spans;\n pub(crate) mod modules;\n mod overflow;\n mod pairs;\n+mod parse;\n mod patterns;\n mod release_channel;\n mod reorder;\n@@ -89,7 +91,6 @@ pub(crate) mod source_map;\n mod spanned;\n mod stmt;\n mod string;\n-mod syntux;\n #[cfg(test)]\n mod test;\n mod types;"}, {"sha": "7aa0315f18c262b21a678830251902ef7a333f9b", "filename": "src/tools/rustfmt/src/lists.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Flists.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -448,10 +448,8 @@ where\n                     true\n                 } else if starts_with_newline(comment) {\n                     false\n-                } else if comment.trim().contains('\\n') || comment.trim().len() > width {\n-                    true\n                 } else {\n-                    false\n+                    comment.trim().contains('\\n') || comment.trim().len() > width\n                 };\n \n                 rewrite_comment("}, {"sha": "f29552caf8d87efb2c585ced695eb065c302c9d6", "filename": "src/tools/rustfmt/src/macros.rs", "status": "modified", "additions": 22, "deletions": 236, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -16,8 +16,6 @@ use rustc_ast::token::{BinOpToken, DelimToken, Token, TokenKind};\n use rustc_ast::tokenstream::{Cursor, Spacing, TokenStream, TokenTree};\n use rustc_ast::{ast, ptr};\n use rustc_ast_pretty::pprust;\n-use rustc_parse::parser::{ForceCollect, Parser};\n-use rustc_parse::{stream_to_parser, MACRO_ARGUMENTS};\n use rustc_span::{\n     symbol::{self, kw},\n     BytePos, Span, Symbol, DUMMY_SP,\n@@ -30,6 +28,8 @@ use crate::config::lists::*;\n use crate::expr::{rewrite_array, rewrite_assign_rhs, RhsAssignKind};\n use crate::lists::{itemize_list, write_list, ListFormatting};\n use crate::overflow;\n+use crate::parse::macros::lazy_static::parse_lazy_static;\n+use crate::parse::macros::{parse_expr, parse_macro_args, ParsedMacroArgs};\n use crate::rewrite::{Rewrite, RewriteContext};\n use crate::shape::{Indent, Shape};\n use crate::source_map::SpanUtils;\n@@ -60,7 +60,7 @@ pub(crate) enum MacroArg {\n }\n \n impl MacroArg {\n-    fn is_item(&self) -> bool {\n+    pub(crate) fn is_item(&self) -> bool {\n         match self {\n             MacroArg::Item(..) => true,\n             _ => false,\n@@ -90,61 +90,6 @@ impl Rewrite for MacroArg {\n     }\n }\n \n-fn build_parser<'a>(context: &RewriteContext<'a>, cursor: Cursor) -> Parser<'a> {\n-    stream_to_parser(\n-        context.parse_sess.inner(),\n-        cursor.collect(),\n-        MACRO_ARGUMENTS,\n-    )\n-}\n-\n-fn parse_macro_arg<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n-    macro_rules! parse_macro_arg {\n-        ($macro_arg:ident, $parser:expr, $f:expr) => {\n-            let mut cloned_parser = (*parser).clone();\n-            match $parser(&mut cloned_parser) {\n-                Ok(x) => {\n-                    if parser.sess.span_diagnostic.has_errors() {\n-                        parser.sess.span_diagnostic.reset_err_count();\n-                    } else {\n-                        // Parsing succeeded.\n-                        *parser = cloned_parser;\n-                        return Some(MacroArg::$macro_arg($f(x)?));\n-                    }\n-                }\n-                Err(mut e) => {\n-                    e.cancel();\n-                    parser.sess.span_diagnostic.reset_err_count();\n-                }\n-            }\n-        };\n-    }\n-\n-    parse_macro_arg!(\n-        Expr,\n-        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_expr(),\n-        |x: ptr::P<ast::Expr>| Some(x)\n-    );\n-    parse_macro_arg!(\n-        Ty,\n-        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_ty(),\n-        |x: ptr::P<ast::Ty>| Some(x)\n-    );\n-    parse_macro_arg!(\n-        Pat,\n-        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_pat_no_top_alt(None),\n-        |x: ptr::P<ast::Pat>| Some(x)\n-    );\n-    // `parse_item` returns `Option<ptr::P<ast::Item>>`.\n-    parse_macro_arg!(\n-        Item,\n-        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_item(ForceCollect::No),\n-        |x: Option<ptr::P<ast::Item>>| x\n-    );\n-\n-    None\n-}\n-\n /// Rewrite macro name without using pretty-printer if possible.\n fn rewrite_macro_name(\n     context: &RewriteContext<'_>,\n@@ -232,25 +177,6 @@ pub(crate) fn rewrite_macro(\n     }\n }\n \n-fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n-    for &keyword in RUST_KW.iter() {\n-        if parser.token.is_keyword(keyword)\n-            && parser.look_ahead(1, |t| {\n-                t.kind == TokenKind::Eof\n-                    || t.kind == TokenKind::Comma\n-                    || t.kind == TokenKind::CloseDelim(DelimToken::NoDelim)\n-            })\n-        {\n-            parser.bump();\n-            return Some(MacroArg::Keyword(\n-                symbol::Ident::with_dummy_span(keyword),\n-                parser.prev_token.span,\n-            ));\n-        }\n-    }\n-    None\n-}\n-\n fn rewrite_macro_inner(\n     mac: &ast::MacCall,\n     extra_ident: Option<symbol::Ident>,\n@@ -269,8 +195,9 @@ fn rewrite_macro_inner(\n     let original_style = macro_style(mac, context);\n \n     let macro_name = rewrite_macro_name(context, &mac.path, extra_ident);\n+    let is_forced_bracket = FORCED_BRACKET_MACROS.contains(&&macro_name[..]);\n \n-    let style = if FORCED_BRACKET_MACROS.contains(&&macro_name[..]) && !is_nested_macro {\n+    let style = if is_forced_bracket && !is_nested_macro {\n         DelimToken::Bracket\n     } else {\n         original_style\n@@ -294,67 +221,21 @@ fn rewrite_macro_inner(\n     }\n     // Format well-known macros which cannot be parsed as a valid AST.\n     if macro_name == \"lazy_static!\" && !has_comment {\n-        if let success @ Some(..) = format_lazy_static(context, shape, &ts) {\n+        if let success @ Some(..) = format_lazy_static(context, shape, ts.trees().collect()) {\n             return success;\n         }\n     }\n \n-    let mut parser = build_parser(context, ts.trees());\n-    let mut arg_vec = Vec::new();\n-    let mut vec_with_semi = false;\n-    let mut trailing_comma = false;\n-\n-    if DelimToken::Brace != style {\n-        loop {\n-            if let Some(arg) = check_keyword(&mut parser) {\n-                arg_vec.push(arg);\n-            } else if let Some(arg) = parse_macro_arg(&mut parser) {\n-                arg_vec.push(arg);\n-            } else {\n-                return return_macro_parse_failure_fallback(context, shape.indent, mac.span());\n-            }\n-\n-            match parser.token.kind {\n-                TokenKind::Eof => break,\n-                TokenKind::Comma => (),\n-                TokenKind::Semi => {\n-                    // Try to parse `vec![expr; expr]`\n-                    if FORCED_BRACKET_MACROS.contains(&&macro_name[..]) {\n-                        parser.bump();\n-                        if parser.token.kind != TokenKind::Eof {\n-                            match parse_macro_arg(&mut parser) {\n-                                Some(arg) => {\n-                                    arg_vec.push(arg);\n-                                    parser.bump();\n-                                    if parser.token.kind == TokenKind::Eof && arg_vec.len() == 2 {\n-                                        vec_with_semi = true;\n-                                        break;\n-                                    }\n-                                }\n-                                None => {\n-                                    return return_macro_parse_failure_fallback(\n-                                        context,\n-                                        shape.indent,\n-                                        mac.span(),\n-                                    );\n-                                }\n-                            }\n-                        }\n-                    }\n-                    return return_macro_parse_failure_fallback(context, shape.indent, mac.span());\n-                }\n-                _ if arg_vec.last().map_or(false, MacroArg::is_item) => continue,\n-                _ => return return_macro_parse_failure_fallback(context, shape.indent, mac.span()),\n-            }\n-\n-            parser.bump();\n-\n-            if parser.token.kind == TokenKind::Eof {\n-                trailing_comma = true;\n-                break;\n-            }\n+    let ParsedMacroArgs {\n+        args: arg_vec,\n+        vec_with_semi,\n+        trailing_comma,\n+    } = match parse_macro_args(context, ts, style, is_forced_bracket) {\n+        Some(args) => args,\n+        None => {\n+            return return_macro_parse_failure_fallback(context, shape.indent, mac.span());\n         }\n-    }\n+    };\n \n     if !arg_vec.is_empty() && arg_vec.iter().all(MacroArg::is_item) {\n         return rewrite_macro_with_items(\n@@ -1179,11 +1060,10 @@ pub(crate) fn convert_try_mac(\n     let path = &pprust::path_to_string(&mac.path);\n     if path == \"try\" || path == \"r#try\" {\n         let ts = mac.args.inner_tokens();\n-        let mut parser = build_parser(context, ts.trees());\n \n         Some(ast::Expr {\n             id: ast::NodeId::root(), // dummy value\n-            kind: ast::ExprKind::Try(parser.parse_expr().ok()?),\n+            kind: ast::ExprKind::Try(parse_expr(context, ts)?),\n             span: mac.span(), // incorrect span, but shouldn't matter too much\n             attrs: ast::AttrVec::new(),\n             tokens: None,\n@@ -1414,53 +1294,21 @@ impl MacroBranch {\n fn format_lazy_static(\n     context: &RewriteContext<'_>,\n     shape: Shape,\n-    ts: &TokenStream,\n+    ts: TokenStream,\n ) -> Option<String> {\n     let mut result = String::with_capacity(1024);\n-    let mut parser = build_parser(context, ts.trees());\n     let nested_shape = shape\n         .block_indent(context.config.tab_spaces())\n         .with_max_width(context.config);\n \n     result.push_str(\"lazy_static! {\");\n     result.push_str(&nested_shape.indent.to_string_with_newline(context.config));\n \n-    macro_rules! parse_or {\n-        ($method:ident $(,)* $($arg:expr),* $(,)*) => {\n-            match parser.$method($($arg,)*) {\n-                Ok(val) => {\n-                    if parser.sess.span_diagnostic.has_errors() {\n-                        parser.sess.span_diagnostic.reset_err_count();\n-                        return None;\n-                    } else {\n-                        val\n-                    }\n-                }\n-                Err(mut err) => {\n-                    err.cancel();\n-                    parser.sess.span_diagnostic.reset_err_count();\n-                    return None;\n-                }\n-            }\n-        }\n-    }\n-\n-    while parser.token.kind != TokenKind::Eof {\n-        // Parse a `lazy_static!` item.\n-        let vis = crate::utils::format_visibility(\n-            context,\n-            &parse_or!(parse_visibility, rustc_parse::parser::FollowedByType::No),\n-        );\n-        parser.eat_keyword(kw::Static);\n-        parser.eat_keyword(kw::Ref);\n-        let id = parse_or!(parse_ident);\n-        parser.eat(&TokenKind::Colon);\n-        let ty = parse_or!(parse_ty);\n-        parser.eat(&TokenKind::Eq);\n-        let expr = parse_or!(parse_expr);\n-        parser.eat(&TokenKind::Semi);\n-\n+    let parsed_elems = parse_lazy_static(context, ts)?;\n+    let last = parsed_elems.len() - 1;\n+    for (i, (vis, id, ty, expr)) in parsed_elems.iter().enumerate() {\n         // Rewrite as a static item.\n+        let vis = crate::utils::format_visibility(context, vis);\n         let mut stmt = String::with_capacity(128);\n         stmt.push_str(&format!(\n             \"{}static ref {}: {} =\",\n@@ -1476,7 +1324,7 @@ fn format_lazy_static(\n             nested_shape.sub_width(1)?,\n         )?);\n         result.push(';');\n-        if parser.token.kind != TokenKind::Eof {\n+        if i != last {\n             result.push_str(&nested_shape.indent.to_string_with_newline(context.config));\n         }\n     }\n@@ -1528,65 +1376,3 @@ fn rewrite_macro_with_items(\n     result.push_str(trailing_semicolon);\n     Some(result)\n }\n-\n-const RUST_KW: [Symbol; 59] = [\n-    kw::PathRoot,\n-    kw::DollarCrate,\n-    kw::Underscore,\n-    kw::As,\n-    kw::Box,\n-    kw::Break,\n-    kw::Const,\n-    kw::Continue,\n-    kw::Crate,\n-    kw::Else,\n-    kw::Enum,\n-    kw::Extern,\n-    kw::False,\n-    kw::Fn,\n-    kw::For,\n-    kw::If,\n-    kw::Impl,\n-    kw::In,\n-    kw::Let,\n-    kw::Loop,\n-    kw::Match,\n-    kw::Mod,\n-    kw::Move,\n-    kw::Mut,\n-    kw::Pub,\n-    kw::Ref,\n-    kw::Return,\n-    kw::SelfLower,\n-    kw::SelfUpper,\n-    kw::Static,\n-    kw::Struct,\n-    kw::Super,\n-    kw::Trait,\n-    kw::True,\n-    kw::Type,\n-    kw::Unsafe,\n-    kw::Use,\n-    kw::Where,\n-    kw::While,\n-    kw::Abstract,\n-    kw::Become,\n-    kw::Do,\n-    kw::Final,\n-    kw::Macro,\n-    kw::Override,\n-    kw::Priv,\n-    kw::Typeof,\n-    kw::Unsized,\n-    kw::Virtual,\n-    kw::Yield,\n-    kw::Dyn,\n-    kw::Async,\n-    kw::Try,\n-    kw::UnderscoreLifetime,\n-    kw::StaticLifetime,\n-    kw::Auto,\n-    kw::Catch,\n-    kw::Default,\n-    kw::Union,\n-];"}, {"sha": "85d9c5d2b9bbf4f3e80ec3371cc733d9dea157ea", "filename": "src/tools/rustfmt/src/matches.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmatches.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -322,7 +322,11 @@ fn flatten_arm_body<'a>(\n     if let Some(block) = block_can_be_flattened(context, body) {\n         if let ast::StmtKind::Expr(ref expr) = block.stmts[0].kind {\n             if let ast::ExprKind::Block(..) = expr.kind {\n-                flatten_arm_body(context, expr, None)\n+                if expr.attrs.is_empty() {\n+                    flatten_arm_body(context, expr, None)\n+                } else {\n+                    (true, body)\n+                }\n             } else {\n                 let cond_becomes_muti_line = opt_shape\n                     .and_then(|shape| rewrite_cond(context, expr, shape))"}, {"sha": "9c964b274e088158301fdb7a76a6a7d0eea2e70d", "filename": "src/tools/rustfmt/src/modules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -12,10 +12,10 @@ use thiserror::Error;\n use crate::attr::MetaVisitor;\n use crate::config::FileName;\n use crate::items::is_mod_decl;\n-use crate::syntux::parser::{\n+use crate::parse::parser::{\n     Directory, DirectoryOwnership, ModError, ModulePathSuccess, Parser, ParserError,\n };\n-use crate::syntux::session::ParseSess;\n+use crate::parse::session::ParseSess;\n use crate::utils::{contains_skip, mk_sp};\n \n mod visitor;"}, {"sha": "ea67977c17a2b7e016ac906e280c30e3e1659a53", "filename": "src/tools/rustfmt/src/modules/visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules%2Fvisitor.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -3,8 +3,8 @@ use rustc_ast::visit::Visitor;\n use rustc_span::Symbol;\n \n use crate::attr::MetaVisitor;\n-use crate::syntux::parser::Parser;\n-use crate::syntux::session::ParseSess;\n+use crate::parse::macros::cfg_if::parse_cfg_if;\n+use crate::parse::session::ParseSess;\n \n pub(crate) struct ModItem {\n     pub(crate) item: ast::Item,\n@@ -62,7 +62,7 @@ impl<'a, 'ast: 'a> CfgIfVisitor<'a> {\n             }\n         };\n \n-        let items = Parser::parse_cfg_if(self.parse_sess, mac)?;\n+        let items = parse_cfg_if(self.parse_sess, mac)?;\n         self.mods\n             .append(&mut items.into_iter().map(|item| ModItem { item }).collect());\n "}, {"sha": "cc9fb5072ce1eada112c9c5238072b2e95f6edd2", "filename": "src/tools/rustfmt/src/parse/macros/asm.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fasm.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,11 @@\n+use rustc_ast::ast;\n+use rustc_builtin_macros::asm::{parse_asm_args, AsmArgs};\n+\n+use crate::rewrite::RewriteContext;\n+\n+#[allow(dead_code)]\n+pub(crate) fn parse_asm(context: &RewriteContext<'_>, mac: &ast::MacCall) -> Option<AsmArgs> {\n+    let ts = mac.args.inner_tokens();\n+    let mut parser = super::build_parser(context, ts);\n+    parse_asm_args(&mut parser, context.parse_sess.inner(), mac.span(), false).ok()\n+}"}, {"sha": "e10fbe64bcdbeff4f7bce0082e815ff4232a2350", "filename": "src/tools/rustfmt/src/parse/macros/cfg_if.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,89 @@\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+\n+use rustc_ast::ast;\n+use rustc_ast::token::{DelimToken, TokenKind};\n+use rustc_parse::parser::ForceCollect;\n+use rustc_span::symbol::kw;\n+\n+use crate::parse::macros::build_stream_parser;\n+use crate::parse::session::ParseSess;\n+\n+pub(crate) fn parse_cfg_if<'a>(\n+    sess: &'a ParseSess,\n+    mac: &'a ast::MacCall,\n+) -> Result<Vec<ast::Item>, &'static str> {\n+    match catch_unwind(AssertUnwindSafe(|| parse_cfg_if_inner(sess, mac))) {\n+        Ok(Ok(items)) => Ok(items),\n+        Ok(err @ Err(_)) => err,\n+        Err(..) => Err(\"failed to parse cfg_if!\"),\n+    }\n+}\n+\n+fn parse_cfg_if_inner<'a>(\n+    sess: &'a ParseSess,\n+    mac: &'a ast::MacCall,\n+) -> Result<Vec<ast::Item>, &'static str> {\n+    let ts = mac.args.inner_tokens();\n+    let mut parser = build_stream_parser(sess.inner(), ts);\n+\n+    let mut items = vec![];\n+    let mut process_if_cfg = true;\n+\n+    while parser.token.kind != TokenKind::Eof {\n+        if process_if_cfg {\n+            if !parser.eat_keyword(kw::If) {\n+                return Err(\"Expected `if`\");\n+            }\n+            // Inner attributes are not actually syntactically permitted here, but we don't\n+            // care about inner vs outer attributes in this position. Our purpose with this\n+            // special case parsing of cfg_if macros is to ensure we can correctly resolve\n+            // imported modules that may have a custom `path` defined.\n+            //\n+            // As such, we just need to advance the parser past the attribute and up to\n+            // to the opening brace.\n+            // See also https://github.com/rust-lang/rust/pull/79433\n+            parser\n+                .parse_attribute(rustc_parse::parser::attr::InnerAttrPolicy::Permitted)\n+                .map_err(|_| \"Failed to parse attributes\")?;\n+        }\n+\n+        if !parser.eat(&TokenKind::OpenDelim(DelimToken::Brace)) {\n+            return Err(\"Expected an opening brace\");\n+        }\n+\n+        while parser.token != TokenKind::CloseDelim(DelimToken::Brace)\n+            && parser.token.kind != TokenKind::Eof\n+        {\n+            let item = match parser.parse_item(ForceCollect::No) {\n+                Ok(Some(item_ptr)) => item_ptr.into_inner(),\n+                Ok(None) => continue,\n+                Err(mut err) => {\n+                    err.cancel();\n+                    parser.sess.span_diagnostic.reset_err_count();\n+                    return Err(\n+                        \"Expected item inside cfg_if block, but failed to parse it as an item\",\n+                    );\n+                }\n+            };\n+            if let ast::ItemKind::Mod(..) = item.kind {\n+                items.push(item);\n+            }\n+        }\n+\n+        if !parser.eat(&TokenKind::CloseDelim(DelimToken::Brace)) {\n+            return Err(\"Expected a closing brace\");\n+        }\n+\n+        if parser.eat(&TokenKind::Eof) {\n+            break;\n+        }\n+\n+        if !parser.eat_keyword(kw::Else) {\n+            return Err(\"Expected `else`\");\n+        }\n+\n+        process_if_cfg = parser.token.is_keyword(kw::If);\n+    }\n+\n+    Ok(items)\n+}"}, {"sha": "9c8651aa3faf78c68b8de3cfe9a11f4423624cbb", "filename": "src/tools/rustfmt/src/parse/macros/lazy_static.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Flazy_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Flazy_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Flazy_static.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,50 @@\n+use rustc_ast::ast;\n+use rustc_ast::ptr::P;\n+use rustc_ast::token::TokenKind;\n+use rustc_ast::tokenstream::TokenStream;\n+use rustc_span::symbol::{self, kw};\n+\n+use crate::rewrite::RewriteContext;\n+\n+pub(crate) fn parse_lazy_static(\n+    context: &RewriteContext<'_>,\n+    ts: TokenStream,\n+) -> Option<Vec<(ast::Visibility, symbol::Ident, P<ast::Ty>, P<ast::Expr>)>> {\n+    let mut result = vec![];\n+    let mut parser = super::build_parser(context, ts);\n+    macro_rules! parse_or {\n+        ($method:ident $(,)* $($arg:expr),* $(,)*) => {\n+            match parser.$method($($arg,)*) {\n+                Ok(val) => {\n+                    if parser.sess.span_diagnostic.has_errors() {\n+                        parser.sess.span_diagnostic.reset_err_count();\n+                        return None;\n+                    } else {\n+                        val\n+                    }\n+                }\n+                Err(mut err) => {\n+                    err.cancel();\n+                    parser.sess.span_diagnostic.reset_err_count();\n+                    return None;\n+                }\n+            }\n+        }\n+    }\n+\n+    while parser.token.kind != TokenKind::Eof {\n+        // Parse a `lazy_static!` item.\n+        let vis = parse_or!(parse_visibility, rustc_parse::parser::FollowedByType::No);\n+        parser.eat_keyword(kw::Static);\n+        parser.eat_keyword(kw::Ref);\n+        let id = parse_or!(parse_ident);\n+        parser.eat(&TokenKind::Colon);\n+        let ty = parse_or!(parse_ty);\n+        parser.eat(&TokenKind::Eq);\n+        let expr = parse_or!(parse_expr);\n+        parser.eat(&TokenKind::Semi);\n+        result.push((vis, id, ty, expr));\n+    }\n+\n+    Some(result)\n+}"}, {"sha": "2e9ce1d35f4003bdffadd9f3976c7d2177ebf0b3", "filename": "src/tools/rustfmt/src/parse/macros/mod.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fmod.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,231 @@\n+use rustc_ast::token::{DelimToken, TokenKind};\n+use rustc_ast::tokenstream::TokenStream;\n+use rustc_ast::{ast, ptr};\n+use rustc_parse::parser::{ForceCollect, Parser};\n+use rustc_parse::{stream_to_parser, MACRO_ARGUMENTS};\n+use rustc_session::parse::ParseSess;\n+use rustc_span::symbol::{self, kw};\n+use rustc_span::Symbol;\n+\n+use crate::macros::MacroArg;\n+use crate::rewrite::RewriteContext;\n+\n+pub(crate) mod asm;\n+pub(crate) mod cfg_if;\n+pub(crate) mod lazy_static;\n+\n+fn build_stream_parser<'a>(sess: &'a ParseSess, tokens: TokenStream) -> Parser<'a> {\n+    stream_to_parser(sess, tokens, MACRO_ARGUMENTS)\n+}\n+\n+fn build_parser<'a>(context: &RewriteContext<'a>, tokens: TokenStream) -> Parser<'a> {\n+    build_stream_parser(context.parse_sess.inner(), tokens)\n+}\n+\n+fn parse_macro_arg<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n+    macro_rules! parse_macro_arg {\n+        ($macro_arg:ident, $parser:expr, $f:expr) => {\n+            let mut cloned_parser = (*parser).clone();\n+            match $parser(&mut cloned_parser) {\n+                Ok(x) => {\n+                    if parser.sess.span_diagnostic.has_errors() {\n+                        parser.sess.span_diagnostic.reset_err_count();\n+                    } else {\n+                        // Parsing succeeded.\n+                        *parser = cloned_parser;\n+                        return Some(MacroArg::$macro_arg($f(x)?));\n+                    }\n+                }\n+                Err(mut e) => {\n+                    e.cancel();\n+                    parser.sess.span_diagnostic.reset_err_count();\n+                }\n+            }\n+        };\n+    }\n+\n+    parse_macro_arg!(\n+        Expr,\n+        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_expr(),\n+        |x: ptr::P<ast::Expr>| Some(x)\n+    );\n+    parse_macro_arg!(\n+        Ty,\n+        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_ty(),\n+        |x: ptr::P<ast::Ty>| Some(x)\n+    );\n+    parse_macro_arg!(\n+        Pat,\n+        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_pat_no_top_alt(None),\n+        |x: ptr::P<ast::Pat>| Some(x)\n+    );\n+    // `parse_item` returns `Option<ptr::P<ast::Item>>`.\n+    parse_macro_arg!(\n+        Item,\n+        |parser: &mut rustc_parse::parser::Parser<'b>| parser.parse_item(ForceCollect::No),\n+        |x: Option<ptr::P<ast::Item>>| x\n+    );\n+\n+    None\n+}\n+\n+pub(crate) struct ParsedMacroArgs {\n+    pub(crate) vec_with_semi: bool,\n+    pub(crate) trailing_comma: bool,\n+    pub(crate) args: Vec<MacroArg>,\n+}\n+\n+fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n+    for &keyword in RUST_KW.iter() {\n+        if parser.token.is_keyword(keyword)\n+            && parser.look_ahead(1, |t| {\n+                t.kind == TokenKind::Eof\n+                    || t.kind == TokenKind::Comma\n+                    || t.kind == TokenKind::CloseDelim(DelimToken::NoDelim)\n+            })\n+        {\n+            parser.bump();\n+            return Some(MacroArg::Keyword(\n+                symbol::Ident::with_dummy_span(keyword),\n+                parser.prev_token.span,\n+            ));\n+        }\n+    }\n+    None\n+}\n+\n+pub(crate) fn parse_macro_args(\n+    context: &RewriteContext<'_>,\n+    tokens: TokenStream,\n+    style: DelimToken,\n+    forced_bracket: bool,\n+) -> Option<ParsedMacroArgs> {\n+    let mut parser = build_parser(context, tokens);\n+    let mut args = Vec::new();\n+    let mut vec_with_semi = false;\n+    let mut trailing_comma = false;\n+\n+    if DelimToken::Brace != style {\n+        loop {\n+            if let Some(arg) = check_keyword(&mut parser) {\n+                args.push(arg);\n+            } else if let Some(arg) = parse_macro_arg(&mut parser) {\n+                args.push(arg);\n+            } else {\n+                return None;\n+            }\n+\n+            match parser.token.kind {\n+                TokenKind::Eof => break,\n+                TokenKind::Comma => (),\n+                TokenKind::Semi => {\n+                    // Try to parse `vec![expr; expr]`\n+                    if forced_bracket {\n+                        parser.bump();\n+                        if parser.token.kind != TokenKind::Eof {\n+                            match parse_macro_arg(&mut parser) {\n+                                Some(arg) => {\n+                                    args.push(arg);\n+                                    parser.bump();\n+                                    if parser.token.kind == TokenKind::Eof && args.len() == 2 {\n+                                        vec_with_semi = true;\n+                                        break;\n+                                    }\n+                                }\n+                                None => {\n+                                    return None;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    return None;\n+                }\n+                _ if args.last().map_or(false, MacroArg::is_item) => continue,\n+                _ => return None,\n+            }\n+\n+            parser.bump();\n+\n+            if parser.token.kind == TokenKind::Eof {\n+                trailing_comma = true;\n+                break;\n+            }\n+        }\n+    }\n+\n+    Some(ParsedMacroArgs {\n+        vec_with_semi,\n+        trailing_comma,\n+        args,\n+    })\n+}\n+\n+pub(crate) fn parse_expr(\n+    context: &RewriteContext<'_>,\n+    tokens: TokenStream,\n+) -> Option<ptr::P<ast::Expr>> {\n+    let mut parser = build_parser(context, tokens);\n+    parser.parse_expr().ok()\n+}\n+\n+const RUST_KW: [Symbol; 59] = [\n+    kw::PathRoot,\n+    kw::DollarCrate,\n+    kw::Underscore,\n+    kw::As,\n+    kw::Box,\n+    kw::Break,\n+    kw::Const,\n+    kw::Continue,\n+    kw::Crate,\n+    kw::Else,\n+    kw::Enum,\n+    kw::Extern,\n+    kw::False,\n+    kw::Fn,\n+    kw::For,\n+    kw::If,\n+    kw::Impl,\n+    kw::In,\n+    kw::Let,\n+    kw::Loop,\n+    kw::Match,\n+    kw::Mod,\n+    kw::Move,\n+    kw::Mut,\n+    kw::Pub,\n+    kw::Ref,\n+    kw::Return,\n+    kw::SelfLower,\n+    kw::SelfUpper,\n+    kw::Static,\n+    kw::Struct,\n+    kw::Super,\n+    kw::Trait,\n+    kw::True,\n+    kw::Type,\n+    kw::Unsafe,\n+    kw::Use,\n+    kw::Where,\n+    kw::While,\n+    kw::Abstract,\n+    kw::Become,\n+    kw::Do,\n+    kw::Final,\n+    kw::Macro,\n+    kw::Override,\n+    kw::Priv,\n+    kw::Typeof,\n+    kw::Unsized,\n+    kw::Virtual,\n+    kw::Yield,\n+    kw::Dyn,\n+    kw::Async,\n+    kw::Try,\n+    kw::UnderscoreLifetime,\n+    kw::StaticLifetime,\n+    kw::Auto,\n+    kw::Catch,\n+    kw::Default,\n+    kw::Union,\n+];"}, {"sha": "5e88826ea8cc5f6f9470d53069989b02b74967c1", "filename": "src/tools/rustfmt/src/parse/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmod.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,3 @@\n+pub(crate) mod macros;\n+pub(crate) mod parser;\n+pub(crate) mod session;"}, {"sha": "657217633f4abcb812e22da88dbf6727ae5115e7", "filename": "src/tools/rustfmt/src/parse/parser.rs", "status": "renamed", "additions": 4, "deletions": 87, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -1,17 +1,14 @@\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::path::{Path, PathBuf};\n \n-use rustc_ast::token::{DelimToken, TokenKind};\n+use rustc_ast::token::TokenKind;\n use rustc_ast::{ast, ptr};\n use rustc_errors::Diagnostic;\n-use rustc_parse::{\n-    new_parser_from_file,\n-    parser::{ForceCollect, Parser as RawParser},\n-};\n-use rustc_span::{sym, symbol::kw, Span};\n+use rustc_parse::{new_parser_from_file, parser::Parser as RawParser};\n+use rustc_span::{sym, Span};\n \n use crate::attr::first_attr_value_str_by_name;\n-use crate::syntux::session::ParseSess;\n+use crate::parse::session::ParseSess;\n use crate::Input;\n \n pub(crate) type DirectoryOwnership = rustc_expand::module::DirOwnership;\n@@ -175,84 +172,4 @@ impl<'a> Parser<'a> {\n             Err(_) => Err(ParserError::ParsePanicError),\n         }\n     }\n-\n-    pub(crate) fn parse_cfg_if(\n-        sess: &'a ParseSess,\n-        mac: &'a ast::MacCall,\n-    ) -> Result<Vec<ast::Item>, &'static str> {\n-        match catch_unwind(AssertUnwindSafe(|| Parser::parse_cfg_if_inner(sess, mac))) {\n-            Ok(Ok(items)) => Ok(items),\n-            Ok(err @ Err(_)) => err,\n-            Err(..) => Err(\"failed to parse cfg_if!\"),\n-        }\n-    }\n-\n-    fn parse_cfg_if_inner(\n-        sess: &'a ParseSess,\n-        mac: &'a ast::MacCall,\n-    ) -> Result<Vec<ast::Item>, &'static str> {\n-        let token_stream = mac.args.inner_tokens();\n-        let mut parser = rustc_parse::stream_to_parser(sess.inner(), token_stream, Some(\"\"));\n-\n-        let mut items = vec![];\n-        let mut process_if_cfg = true;\n-\n-        while parser.token.kind != TokenKind::Eof {\n-            if process_if_cfg {\n-                if !parser.eat_keyword(kw::If) {\n-                    return Err(\"Expected `if`\");\n-                }\n-                // Inner attributes are not actually syntactically permitted here, but we don't\n-                // care about inner vs outer attributes in this position. Our purpose with this\n-                // special case parsing of cfg_if macros is to ensure we can correctly resolve\n-                // imported modules that may have a custom `path` defined.\n-                //\n-                // As such, we just need to advance the parser past the attribute and up to\n-                // to the opening brace.\n-                // See also https://github.com/rust-lang/rust/pull/79433\n-                parser\n-                    .parse_attribute(rustc_parse::parser::attr::InnerAttrPolicy::Permitted)\n-                    .map_err(|_| \"Failed to parse attributes\")?;\n-            }\n-\n-            if !parser.eat(&TokenKind::OpenDelim(DelimToken::Brace)) {\n-                return Err(\"Expected an opening brace\");\n-            }\n-\n-            while parser.token != TokenKind::CloseDelim(DelimToken::Brace)\n-                && parser.token.kind != TokenKind::Eof\n-            {\n-                let item = match parser.parse_item(ForceCollect::No) {\n-                    Ok(Some(item_ptr)) => item_ptr.into_inner(),\n-                    Ok(None) => continue,\n-                    Err(mut err) => {\n-                        err.cancel();\n-                        parser.sess.span_diagnostic.reset_err_count();\n-                        return Err(\n-                            \"Expected item inside cfg_if block, but failed to parse it as an item\",\n-                        );\n-                    }\n-                };\n-                if let ast::ItemKind::Mod(..) = item.kind {\n-                    items.push(item);\n-                }\n-            }\n-\n-            if !parser.eat(&TokenKind::CloseDelim(DelimToken::Brace)) {\n-                return Err(\"Expected a closing brace\");\n-            }\n-\n-            if parser.eat(&TokenKind::Eof) {\n-                break;\n-            }\n-\n-            if !parser.eat_keyword(kw::Else) {\n-                return Err(\"Expected `else`\");\n-            }\n-\n-            process_if_cfg = parser.token.is_keyword(kw::If);\n-        }\n-\n-        Ok(items)\n-    }\n }", "previous_filename": "src/tools/rustfmt/src/syntux/parser.rs"}, {"sha": "624fed0d2de2644df8bfbc8d6915d61e53c4b8a3", "filename": "src/tools/rustfmt/src/parse/session.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -222,7 +222,7 @@ impl ParseSess {\n     }\n }\n \n-// Methods that should be restricted within the syntux module.\n+// Methods that should be restricted within the parse module.\n impl ParseSess {\n     pub(super) fn emit_diagnostics(&self, diagnostics: Vec<Diagnostic>) {\n         for diagnostic in diagnostics {", "previous_filename": "src/tools/rustfmt/src/syntux/session.rs"}, {"sha": "9b74b35f31413cc20c8b0cdd3863fad51b1ae5b0", "filename": "src/tools/rustfmt/src/patterns.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fpatterns.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -318,19 +318,20 @@ fn rewrite_struct_pat(\n     let mut fields_str = write_list(&item_vec, &fmt)?;\n     let one_line_width = h_shape.map_or(0, |shape| shape.width);\n \n+    let has_trailing_comma = fmt.needs_trailing_separator();\n+\n     if ellipsis {\n         if fields_str.contains('\\n') || fields_str.len() > one_line_width {\n             // Add a missing trailing comma.\n-            if context.config.trailing_comma() == SeparatorTactic::Never {\n+            if !has_trailing_comma {\n                 fields_str.push(',');\n             }\n             fields_str.push('\\n');\n             fields_str.push_str(&nested_shape.indent.to_string(context.config));\n         } else {\n             if !fields_str.is_empty() {\n                 // there are preceding struct fields being matched on\n-                if tactic == DefinitiveListTactic::Vertical {\n-                    // if the tactic is Vertical, write_list already added a trailing ,\n+                if has_trailing_comma {\n                     fields_str.push(' ');\n                 } else {\n                     fields_str.push_str(\", \");"}, {"sha": "4a3bd129d16f5ad62b017f0ba277c87c8a80968d", "filename": "src/tools/rustfmt/src/rewrite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Frewrite.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -7,9 +7,9 @@ use rustc_ast::ptr;\n use rustc_span::Span;\n \n use crate::config::{Config, IndentStyle};\n+use crate::parse::session::ParseSess;\n use crate::shape::Shape;\n use crate::skip::SkipContext;\n-use crate::syntux::session::ParseSess;\n use crate::visitor::SnippetProvider;\n use crate::FormatReport;\n "}, {"sha": "1724a0f87bf7c48ffa114bcc77bf52b32e0dc20e", "filename": "src/tools/rustfmt/src/rustfmt_diff.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Frustfmt_diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Frustfmt_diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Frustfmt_diff.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -6,20 +6,20 @@ use std::io::Write;\n use crate::config::{Color, Config, Verbosity};\n \n #[derive(Debug, PartialEq)]\n-pub enum DiffLine {\n+pub(crate) enum DiffLine {\n     Context(String),\n     Expected(String),\n     Resulting(String),\n }\n \n #[derive(Debug, PartialEq)]\n-pub struct Mismatch {\n+pub(crate) struct Mismatch {\n     /// The line number in the formatted version.\n-    pub line_number: u32,\n+    pub(crate) line_number: u32,\n     /// The line number in the original version.\n-    pub line_number_orig: u32,\n+    pub(crate) line_number_orig: u32,\n     /// The set of lines (context and old/new) in the mismatch.\n-    pub lines: Vec<DiffLine>,\n+    pub(crate) lines: Vec<DiffLine>,\n }\n \n impl Mismatch {"}, {"sha": "56d4ab4003832f57cda0b4774731766d22fbdf6f", "filename": "src/tools/rustfmt/src/source_file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fsource_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fsource_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fsource_file.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -4,7 +4,7 @@ use std::path::Path;\n \n use crate::config::FileName;\n use crate::emitter::{self, Emitter};\n-use crate::syntux::session::ParseSess;\n+use crate::parse::session::ParseSess;\n use crate::NewlineStyle;\n \n #[cfg(test)]"}, {"sha": "92949ab576a6bffd4c0d546bdab19db91ad40ed3", "filename": "src/tools/rustfmt/src/test/configuration_snippet.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fconfiguration_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fconfiguration_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fconfiguration_snippet.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -110,14 +110,7 @@ impl ConfigCodeBlock {\n         assert!(self.code_block.is_some() && self.code_block_start.is_some());\n \n         // See if code block begins with #![rustfmt::skip].\n-        let fmt_skip = self\n-            .code_block\n-            .as_ref()\n-            .unwrap()\n-            .lines()\n-            .nth(0)\n-            .unwrap_or(\"\")\n-            == \"#![rustfmt::skip]\";\n+        let fmt_skip = self.fmt_skip();\n \n         if self.config_name.is_none() && !fmt_skip {\n             write_message(&format!(\n@@ -138,6 +131,17 @@ impl ConfigCodeBlock {\n         true\n     }\n \n+    /// True if the code block starts with #![rustfmt::skip]\n+    fn fmt_skip(&self) -> bool {\n+        self.code_block\n+            .as_ref()\n+            .unwrap()\n+            .lines()\n+            .nth(0)\n+            .unwrap_or(\"\")\n+            == \"#![rustfmt::skip]\"\n+    }\n+\n     fn has_parsing_errors<T: Write>(&self, session: &Session<'_, T>) -> bool {\n         if session.has_parsing_errors() {\n             write_message(&format!(\n@@ -251,6 +255,7 @@ fn configuration_snippet_tests() {\n     let blocks = get_code_blocks();\n     let failures = blocks\n         .iter()\n+        .filter(|block| !block.fmt_skip())\n         .map(ConfigCodeBlock::formatted_is_idempotent)\n         .fold(0, |acc, r| acc + (!r as u32));\n "}, {"sha": "ec9ed0f0b8d6249357980d28ddc9955c8a9e850b", "filename": "src/tools/rustfmt/src/test/mod_resolver.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fmod_resolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fmod_resolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fmod_resolver.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -41,3 +41,12 @@ fn out_of_line_nested_inline_within_out_of_line() {\n         ],\n     );\n }\n+\n+#[test]\n+fn skip_out_of_line_nested_inline_within_out_of_line() {\n+    // See also https://github.com/rust-lang/rustfmt/issues/5065\n+    verify_mod_resolution(\n+        \"tests/mod-resolver/skip-files-issue-5065/main.rs\",\n+        &[\"tests/mod-resolver/skip-files-issue-5065/one.rs\"],\n+    );\n+}"}, {"sha": "0177689958aa7994b0d130b52736a05d44d813b6", "filename": "src/tools/rustfmt/src/visitor.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -16,13 +16,13 @@ use crate::items::{\n };\n use crate::macros::{macro_style, rewrite_macro, rewrite_macro_def, MacroPosition};\n use crate::modules::Module;\n+use crate::parse::session::ParseSess;\n use crate::rewrite::{Rewrite, RewriteContext};\n use crate::shape::{Indent, Shape};\n use crate::skip::{is_skip_attr, SkipContext};\n use crate::source_map::{LineRangeUtils, SpanUtils};\n use crate::spanned::Spanned;\n use crate::stmt::Stmt;\n-use crate::syntux::session::ParseSess;\n use crate::utils::{\n     self, contains_skip, count_newlines, depr_skip_annotation, format_unsafety, inner_attributes,\n     last_line_width, mk_sp, ptr_vec_to_ref_vec, rewrite_ident, starts_with_newline, stmt_expr,\n@@ -552,7 +552,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                             _ => visit::FnCtxt::Foreign,\n                         };\n                         self.visit_fn(\n-                            visit::FnKind::Fn(fn_ctxt, item.ident, &sig, &item.vis, Some(body)),\n+                            visit::FnKind::Fn(fn_ctxt, item.ident, sig, &item.vis, Some(body)),\n                             generics,\n                             &sig.decl,\n                             item.span,\n@@ -562,14 +562,14 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     } else {\n                         let indent = self.block_indent;\n                         let rewrite = self.rewrite_required_fn(\n-                            indent, item.ident, &sig, &item.vis, generics, item.span,\n+                            indent, item.ident, sig, &item.vis, generics, item.span,\n                         );\n                         self.push_rewrite(item.span, rewrite);\n                     }\n                 }\n                 ast::ItemKind::TyAlias(ref ty_alias) => {\n                     use ItemVisitorKind::Item;\n-                    self.visit_ty_alias_kind(ty_alias, &Item(&item), item.span);\n+                    self.visit_ty_alias_kind(ty_alias, &Item(item), item.span);\n                 }\n                 ast::ItemKind::GlobalAsm(..) => {\n                     let snippet = Some(self.snippet(item.span).to_owned());\n@@ -619,17 +619,17 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         skip_out_of_file_lines_range_visitor!(self, ai.span);\n \n         if self.visit_attrs(&ai.attrs, ast::AttrStyle::Outer) {\n-            self.push_skipped_with_span(&ai.attrs.as_slice(), skip_span, skip_span);\n+            self.push_skipped_with_span(ai.attrs.as_slice(), skip_span, skip_span);\n             return;\n         }\n \n         // TODO(calebcartwright): consider enabling box_patterns feature gate\n         match (&ai.kind, visitor_kind) {\n             (ast::AssocItemKind::Const(..), AssocTraitItem(_)) => {\n-                self.visit_static(&StaticParts::from_trait_item(&ai))\n+                self.visit_static(&StaticParts::from_trait_item(ai))\n             }\n             (ast::AssocItemKind::Const(..), AssocImplItem(_)) => {\n-                self.visit_static(&StaticParts::from_impl_item(&ai))\n+                self.visit_static(&StaticParts::from_impl_item(ai))\n             }\n             (ast::AssocItemKind::Fn(ref fn_kind), _) => {\n                 let ast::Fn {\n@@ -948,12 +948,13 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n     pub(crate) fn format_separate_mod(&mut self, m: &Module<'_>, end_pos: BytePos) {\n         self.block_indent = Indent::empty();\n-        if self.visit_attrs(m.attrs(), ast::AttrStyle::Inner) {\n-            self.push_skipped_with_span(m.attrs(), m.span, m.span);\n-        } else {\n-            self.walk_mod_items(&m.items);\n-            self.format_missing_with_indent(end_pos);\n-        }\n+        let skipped = self.visit_attrs(m.attrs(), ast::AttrStyle::Inner);\n+        assert!(\n+            !skipped,\n+            \"Skipping module must be handled before reaching this line.\"\n+        );\n+        self.walk_mod_items(&m.items);\n+        self.format_missing_with_indent(end_pos);\n     }\n \n     pub(crate) fn skip_empty_lines(&mut self, end_pos: BytePos) {"}, {"sha": "74889acf0c38afe3442fb18faa75c8faeb3d8a74", "filename": "src/tools/rustfmt/tests/mod-resolver/skip-files-issue-5065/foo.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Fmod-resolver%2Fskip-files-issue-5065%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Fmod-resolver%2Fskip-files-issue-5065%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fmod-resolver%2Fskip-files-issue-5065%2Ffoo.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,5 @@\n+#![rustfmt::skip]\n+\n+mod bar {\n+\n+        mod baz;}\n\\ No newline at end of file"}, {"sha": "3519b0ee59c88f71c373633ef2abd085d3e1ea16", "filename": "src/tools/rustfmt/tests/mod-resolver/skip-files-issue-5065/foo/bar/baz.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Fmod-resolver%2Fskip-files-issue-5065%2Ffoo%2Fbar%2Fbaz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Fmod-resolver%2Fskip-files-issue-5065%2Ffoo%2Fbar%2Fbaz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fmod-resolver%2Fskip-files-issue-5065%2Ffoo%2Fbar%2Fbaz.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1 @@\n+fn    baz()    {       }\n\\ No newline at end of file"}, {"sha": "3122e4f220f6291bc2ce3193020bad339b714055", "filename": "src/tools/rustfmt/tests/mod-resolver/skip-files-issue-5065/main.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Fmod-resolver%2Fskip-files-issue-5065%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Fmod-resolver%2Fskip-files-issue-5065%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fmod-resolver%2Fskip-files-issue-5065%2Fmain.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,9 @@\n+#![rustfmt::skip]\n+\n+mod foo;\n+mod one;\n+\n+fn main() {println!(\"Hello, world!\");\n+}\n+\n+// trailing commet"}, {"sha": "e7eb2c2d64ddafd911c78d132b1355d984421345", "filename": "src/tools/rustfmt/tests/mod-resolver/skip-files-issue-5065/one.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Fmod-resolver%2Fskip-files-issue-5065%2Fone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Fmod-resolver%2Fskip-files-issue-5065%2Fone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fmod-resolver%2Fskip-files-issue-5065%2Fone.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1 @@\n+struct One {   value:    String }\n\\ No newline at end of file"}, {"sha": "18cb4fb5f5cc53bcc15db4b349c40419e249895b", "filename": "src/tools/rustfmt/tests/source/async_block.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fasync_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fasync_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fasync_block.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -32,4 +32,20 @@ fn baz() {\n             Ok(())\n         },\n     );\n+\n+    spawn(\n+        a,\n+        static async || {\n+            action();\n+            Ok(())\n+        },\n+    );\n+\n+    spawn(\n+        a,\n+        static async move || {\n+            action();\n+            Ok(())\n+        },\n+    );\n }"}, {"sha": "b5dc9957a2caa2ca5f8bf6f61d37bbf86b90562f", "filename": "src/tools/rustfmt/tests/source/match.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fmatch.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -568,3 +568,22 @@ fn issue_3774() {\n         }\n     }\n }\n+\n+// #4109\n+fn issue_4109() {\n+    match () {\n+        _ => {\n+#[cfg(debug_assertions)]\n+{\n+println!(\"Foo\");\n+}\n+}\n+}\n+\n+match () {\n+_ => {\n+#[allow(unsafe_code)]\n+unsafe {}\n+}\n+}\n+}"}, {"sha": "137d849c9ee027b0c4debb44e729176311d08e9b", "filename": "src/tools/rustfmt/tests/target/async_block.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fasync_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fasync_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fasync_block.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -22,4 +22,14 @@ fn baz() {\n         action();\n         Ok(())\n     });\n+\n+    spawn(a, static async || {\n+        action();\n+        Ok(())\n+    });\n+\n+    spawn(a, static async move || {\n+        action();\n+        Ok(())\n+    });\n }"}, {"sha": "c7122c676237e4bffaa3de0d04c9770a82c31bea", "filename": "src/tools/rustfmt/tests/target/issue-5066/multi_line_struct_trailing_comma_always_struct_lit_width_0.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fmulti_line_struct_trailing_comma_always_struct_lit_width_0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fmulti_line_struct_trailing_comma_always_struct_lit_width_0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fmulti_line_struct_trailing_comma_always_struct_lit_width_0.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,10 @@\n+// rustfmt-trailing_comma: Always\n+// rustfmt-struct_lit_single_line: false\n+// rustfmt-struct_lit_width: 0\n+\n+fn main() {\n+    let Foo {\n+        a,\n+        ..\n+    } = b;\n+}"}, {"sha": "68e89c4179f7d00053fcae307b6b9876e0f7cf48", "filename": "src/tools/rustfmt/tests/target/issue-5066/multi_line_struct_trailing_comma_never_struct_lit_width_0.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fmulti_line_struct_trailing_comma_never_struct_lit_width_0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fmulti_line_struct_trailing_comma_never_struct_lit_width_0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fmulti_line_struct_trailing_comma_never_struct_lit_width_0.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,10 @@\n+// rustfmt-trailing_comma: Never\n+// rustfmt-struct_lit_single_line: false\n+// rustfmt-struct_lit_width: 0\n+\n+fn main() {\n+    let Foo {\n+        a,\n+        ..\n+    } = b;\n+}"}, {"sha": "3368f07038684b194ff61b1595d71e57785a1d38", "filename": "src/tools/rustfmt/tests/target/issue-5066/multi_line_struct_with_trailing_comma_always.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fmulti_line_struct_with_trailing_comma_always.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fmulti_line_struct_with_trailing_comma_always.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fmulti_line_struct_with_trailing_comma_always.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,10 @@\n+// rustfmt-trailing_comma: Always\n+// rustfmt-struct_lit_single_line: false\n+\n+// There is an issue with how this is formatted.\n+// formatting should look like ./multi_line_struct_trailing_comma_always_struct_lit_width_0.rs\n+fn main() {\n+    let Foo {\n+        a, ..\n+    } = b;\n+}"}, {"sha": "cf63c4c983c46e32e395b32e86a395c666c95b16", "filename": "src/tools/rustfmt/tests/target/issue-5066/multi_line_struct_with_trailing_comma_never.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fmulti_line_struct_with_trailing_comma_never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fmulti_line_struct_with_trailing_comma_never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fmulti_line_struct_with_trailing_comma_never.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,10 @@\n+// rustfmt-trailing_comma: Never\n+// rustfmt-struct_lit_single_line: false\n+\n+// There is an issue with how this is formatted.\n+// formatting should look like ./multi_line_struct_trailing_comma_never_struct_lit_width_0.rs\n+fn main() {\n+    let Foo {\n+        a, ..\n+    } = b;\n+}"}, {"sha": "e20bcec93169683336e838757ab39153a1325106", "filename": "src/tools/rustfmt/tests/target/issue-5066/with_trailing_comma_always.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fwith_trailing_comma_always.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fwith_trailing_comma_always.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fwith_trailing_comma_always.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-trailing_comma: Always\n+\n+fn main() {\n+    let Foo { a, .. } = b;\n+}"}, {"sha": "8b95bb137bca30bba4fae1c65c0742f72a286d3c", "filename": "src/tools/rustfmt/tests/target/issue-5066/with_trailing_comma_never.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fwith_trailing_comma_never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fwith_trailing_comma_never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5066%2Fwith_trailing_comma_never.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-trailing_comma: Never\n+\n+fn main() {\n+    let Foo { a, .. } = b;\n+}"}, {"sha": "2ed3d936e32aefafb663b2f2da7de0046e0f7203", "filename": "src/tools/rustfmt/tests/target/issue-5151/minimum_example.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5151%2Fminimum_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5151%2Fminimum_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue-5151%2Fminimum_example.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,16 @@\n+#![feature(more_qualified_paths)]\n+\n+struct Struct {}\n+\n+trait Trait {\n+    type Type;\n+}\n+\n+impl Trait for Struct {\n+    type Type = Self;\n+}\n+\n+fn main() {\n+    // keep the qualified path details\n+    let _ = <Struct as Trait>::Type {};\n+}"}, {"sha": "1bf3fb758ee868379eeb9c22038b59d9c8bf33d6", "filename": "src/tools/rustfmt/tests/target/match.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fmatch.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -608,3 +608,22 @@ fn issue_3774() {\n         }\n     }\n }\n+\n+// #4109\n+fn issue_4109() {\n+    match () {\n+        _ => {\n+            #[cfg(debug_assertions)]\n+            {\n+                println!(\"Foo\");\n+            }\n+        }\n+    }\n+\n+    match () {\n+        _ => {\n+            #[allow(unsafe_code)]\n+            unsafe {}\n+        }\n+    }\n+}"}, {"sha": "f85de33257cccd5fc062ed45294168a1ab0dfa2e", "filename": "src/tools/rustfmt/tests/target/skip/preserve_trailing_comment.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fskip%2Fpreserve_trailing_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09f775e5a71ba809f465b3af377943627552001/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fskip%2Fpreserve_trailing_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fskip%2Fpreserve_trailing_comment.rs?ref=a09f775e5a71ba809f465b3af377943627552001", "patch": "@@ -0,0 +1,7 @@\n+#![rustfmt::skip]\n+\n+fn main() {\n+    println!(\"Hello, world!\");\n+}\n+\n+// Trailing Comment"}]}