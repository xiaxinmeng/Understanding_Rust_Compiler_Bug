{"sha": "2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxODdmM2M3ZjJhMWJmMWQ2ZTRmOWExZTYzNGE4ODdmOTExODUzMmQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-11-09T18:06:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-09T18:06:44Z"}, "message": "Rollup merge of #78480 - ssomers:btree-alias, r=Mark-Simulacrum\n\nBTreeMap: fix pointer provenance rules\n\nFixes #78477 and includes #78476\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "0e47a1aba8f792ac995d26a5df1b989cf7f2a1f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e47a1aba8f792ac995d26a5df1b989cf7f2a1f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfqYU1CRBK7hj4Ov3rIwAAdHIIAJMnIKDozGIH6FtNfa3Vxf/l\nsFq925CE+YWSgDsditY6v5STZ62bdrx7Cne+ACdmTptSzHgH+OcqnnqXJFY2hKtC\n1YUkpLil7wS33s2SaOfS4JYSItXYFF/OD56XlLdQ2EBdyW8wilbDaEbFcjggvffS\nbM6ngjXklzC1AsyzjvHYeZdjn9CEhEzdsiYmNU9R1kHqpkPUdzkTrP9Vs3rFnzRs\nksBlcFrEDPC9UHRiD//En0QJ7fudxy3x4qSH8WVJdd9BxhxIXv9QbZyAq+TE2evx\njsNVd/W8RmtoxKklW1rtvOe6RaSHqhEchrTu+jt/ZA1uPrFCvWTwfESz6pqO3Ns=\n=uK1H\n-----END PGP SIGNATURE-----\n", "payload": "tree 0e47a1aba8f792ac995d26a5df1b989cf7f2a1f9\nparent 391136ed582432855a4e316dadd37089158b698a\nparent 7ca6e8f767eaaaf30cec10ec6936587fc521b934\nauthor Dylan DPC <dylan.dpc@gmail.com> 1604945204 +0100\ncommitter GitHub <noreply@github.com> 1604945204 +0100\n\nRollup merge of #78480 - ssomers:btree-alias, r=Mark-Simulacrum\n\nBTreeMap: fix pointer provenance rules\n\nFixes #78477 and includes #78476\n\nr? `@Mark-Simulacrum`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d", "html_url": "https://github.com/rust-lang/rust/commit/2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "391136ed582432855a4e316dadd37089158b698a", "url": "https://api.github.com/repos/rust-lang/rust/commits/391136ed582432855a4e316dadd37089158b698a", "html_url": "https://github.com/rust-lang/rust/commit/391136ed582432855a4e316dadd37089158b698a"}, {"sha": "7ca6e8f767eaaaf30cec10ec6936587fc521b934", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ca6e8f767eaaaf30cec10ec6936587fc521b934", "html_url": "https://github.com/rust-lang/rust/commit/7ca6e8f767eaaaf30cec10ec6936587fc521b934"}], "stats": {"total": 575, "additions": 328, "deletions": 247}, "files": [{"sha": "dbf9031620ee1e7f401edb145ef058efe49041f8", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 326, "deletions": 246, "changes": 572, "blob_url": "https://github.com/rust-lang/rust/blob/2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d", "patch": "@@ -32,7 +32,6 @@ use core::cmp::Ordering;\n use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n use core::ptr::{self, NonNull, Unique};\n-use core::slice;\n \n use crate::alloc::{AllocRef, Global, Layout};\n use crate::boxed::Box;\n@@ -120,11 +119,11 @@ struct BoxedNode<K, V> {\n \n impl<K, V> BoxedNode<K, V> {\n     fn from_leaf(node: Box<LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Box::into_unique(node).0 }\n+        BoxedNode { ptr: Unique::from(Box::leak(node)) }\n     }\n \n     fn from_internal(node: Box<InternalNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::from(&mut Box::leak(node).data) }\n+        BoxedNode { ptr: Unique::from(Box::leak(node)).cast() }\n     }\n \n     fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n@@ -189,6 +188,11 @@ impl<K, V> Root<K, V> {\n         NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n     }\n \n+    /// Packs the reference, aware of type and height, into a type-agnostic pointer.\n+    fn into_boxed_node(self) -> BoxedNode<K, V> {\n+        self.node\n+    }\n+\n     /// Adds a new internal node with a single edge pointing to the previous root node,\n     /// make that new node the root node, and return it. This increases the height by 1\n     /// and is the opposite of `pop_internal_level`.\n@@ -218,15 +222,16 @@ impl<K, V> Root<K, V> {\n     pub fn pop_internal_level(&mut self) {\n         assert!(self.height > 0);\n \n-        let top = self.node.ptr;\n+        let top = BoxedNode::as_ptr(&self.node);\n \n         let mut internal_node = unsafe { self.internal_node_as_mut() };\n-        self.node = unsafe { internal_node.as_internal_mut().edges[0].assume_init_read() };\n+        let internal_node = NodeRef::as_internal_mut(&mut internal_node);\n+        self.node = unsafe { internal_node.edges[0].assume_init_read() };\n         self.height -= 1;\n-        self.node_as_mut().as_leaf_mut().parent = None;\n+        self.node_as_mut().clear_parent_link();\n \n         unsafe {\n-            Global.dealloc(NonNull::from(top).cast(), Layout::new::<InternalNode<K, V>>());\n+            Global.dealloc(top.cast(), Layout::new::<InternalNode<K, V>>());\n         }\n     }\n }\n@@ -236,21 +241,49 @@ impl<K, V> Root<K, V> {\n // internal use of `NodeRef` because we stay completely generic over `K` and `V`.\n // However, whenever a public type wraps `NodeRef`, make sure that it has the\n // correct variance.\n+///\n /// A reference to a node.\n ///\n /// This type has a number of parameters that controls how it acts:\n-/// - `BorrowType`: This can be `Immut<'a>`, `Mut<'a>` or `ValMut<'a>' for some `'a`\n-///    or `Owned`.\n-///    When this is `Immut<'a>`, the `NodeRef` acts roughly like `&'a Node`,\n-///    when this is `Mut<'a>`, the `NodeRef` acts roughly like `&'a mut Node`,\n-///    when this is `ValMut<'a>`, the `NodeRef` acts as immutable with respect\n-///    to keys and tree structure, but allows mutable references to values,\n-///    and when this is `Owned`, the `NodeRef` acts roughly like `Box<Node>`.\n-/// - `K` and `V`: These control what types of things are stored in the nodes.\n+/// - `BorrowType`: A dummy type that describes the kind of borrow and carries a lifetime.\n+///    - When this is `Immut<'a>`, the `NodeRef` acts roughly like `&'a Node`.\n+///    - When this is `ValMut<'a>`, the `NodeRef` acts roughly like `&'a Node`\n+///      with respect to keys and tree structure, but also allows many\n+///      mutable references to values throughout the tree to coexist.\n+///    - When this is `Mut<'a>`, the `NodeRef` acts roughly like `&'a mut Node`,\n+///      although insert methods allow a mutable pointer to a value to coexist.\n+///    - When this is `Owned`, the `NodeRef` acts roughly like `Box<Node>`,\n+///      but does not have a destructor, and must be cleaned up manually.\n+/// - `K` and `V`: These are the types of keys and values stored in the nodes.\n /// - `Type`: This can be `Leaf`, `Internal`, or `LeafOrInternal`. When this is\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n+///   `Type` is named `NodeType` when used outside `NodeRef`.\n+///\n+/// Both `BorrowType` and `NodeType` restrict what methods we implement, to\n+/// exploit static type safety. There are limitations in the way we can apply\n+/// such restrictions:\n+/// - For each type parameter, we can only define a method either generically\n+///   or for one particular type. For example, we cannot define a method like\n+///   `key_at` generically for all `BorrowType`, because we want to return\n+///   `&'a K` for most choices of `BorrowType`, but plain `K` for `Owned`.\n+///   We cannot define `key_at` once for all types that have a lifetime.\n+///   Therefore, we define it only for the least powerful type `Immut<'a>`.\n+/// - We cannot get implicit coercion from say `Mut<'a>` to `Immut<'a>`.\n+///   Therefore, we have to explicitly call `reborrow` on a more powerfull\n+///   `NodeRef` in order to reach a method like `key_at`.\n+/// - All methods on `NodeRef` that return some kind of reference, except\n+///   `reborrow` and `reborrow_mut`, take `self` by value and not by reference.\n+///   This avoids silently returning a second reference somewhere in the tree.\n+///   That is irrelevant when `BorrowType` is `Immut<'a>`, but the rule does\n+///   no harm because we make those `NodeRef` implicitly `Copy`.\n+///   The rule also avoids implicitly returning the lifetime of `&self`,\n+///   instead of the lifetime contained in `BorrowType`.\n+///   An exception to this rule are the insert functions.\n+/// - Given the above, we need a `reborrow_mut` to explicitly copy a `Mut<'a>`\n+///   `NodeRef` whenever we want to invoke a method returning an extra reference\n+///   somewhere in the tree.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     /// The number of levels below the node, a property of the node that cannot be\n     /// entirely described by `Type` and that the node does not store itself either.\n@@ -277,30 +310,45 @@ unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::Mut<'\n unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::ValMut<'a>, K, V, Type> {}\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type> {}\n \n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    /// Unpack a node reference that was packed by `Root::into_boxed_node`.\n+    fn from_boxed_node(boxed_node: BoxedNode<K, V>, height: usize) -> Self {\n+        NodeRef { height, node: boxed_node.as_ptr(), _marker: PhantomData }\n+    }\n+}\n+\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n+    /// Unpack a node reference that was packed as `NodeRef::parent`.\n+    fn from_internal(node: NonNull<InternalNode<K, V>>, height: usize) -> Self {\n+        debug_assert!(height > 0);\n+        NodeRef { height, node: node.cast(), _marker: PhantomData }\n+    }\n+}\n+\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n-    /// Exposes the data of an internal node for reading.\n+    /// Exposes the data of an internal node.\n     ///\n-    /// Returns a raw ptr to avoid invalidating other references to this node,\n-    /// which is possible when BorrowType is marker::ValMut.\n-    fn as_internal_ptr(&self) -> *const InternalNode<K, V> {\n-        self.node.as_ptr() as *const InternalNode<K, V>\n+    /// Returns a raw ptr to avoid invalidating other references to this node.\n+    fn as_internal_ptr(this: &Self) -> *mut InternalNode<K, V> {\n+        // SAFETY: the static node type is `Internal`.\n+        this.node.as_ptr() as *mut InternalNode<K, V>\n     }\n }\n \n-impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Exposes the data of an internal node for reading,\n-    /// when we know we have exclusive access.\n-    fn as_internal(&mut self) -> &InternalNode<K, V> {\n-        unsafe { &*self.as_internal_ptr() }\n+impl<'a, K, V> NodeRef<marker::Immut<'a>, K, V, marker::Internal> {\n+    /// Exposes the data of an internal node in an immutable tree.\n+    fn as_internal(this: &Self) -> &'a InternalNode<K, V> {\n+        let ptr = Self::as_internal_ptr(this);\n+        // SAFETY: there can be no mutable references into this tree borrowed as `Immut`.\n+        unsafe { &*ptr }\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Exposes the data of an internal node for writing.\n-    ///\n-    /// We don't need to return a raw ptr because we have unique access to the entire node.\n-    fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n-        unsafe { &mut *(self.node.as_ptr() as *mut InternalNode<K, V>) }\n+    /// Offers exclusive access to the data of an internal node.\n+    fn as_internal_mut(this: &mut Self) -> &'a mut InternalNode<K, V> {\n+        let ptr = Self::as_internal_ptr(this);\n+        unsafe { &mut *ptr }\n     }\n }\n \n@@ -312,7 +360,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     pub fn len(&self) -> usize {\n         // Crucially, we only access the `len` field here. If BorrowType is marker::ValMut,\n         // there might be outstanding mutable references to values that we must not invalidate.\n-        unsafe { usize::from((*self.as_leaf_ptr()).len) }\n+        unsafe { usize::from((*Self::as_leaf_ptr(self)).len) }\n     }\n \n     /// Returns the height of this node with respect to the leaf level. Zero height means the\n@@ -322,48 +370,49 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     /// Temporarily takes out another, immutable reference to the same node.\n-    fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {\n+    pub fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n     /// Exposes the leaf portion of any leaf or internal node.\n     ///\n-    /// Returns a raw ptr to avoid invalidating other references to this node,\n-    /// which is possible when BorrowType is marker::ValMut.\n-    fn as_leaf_ptr(&self) -> *const LeafNode<K, V> {\n+    /// Returns a raw ptr to avoid invalidating other references to this node.\n+    fn as_leaf_ptr(this: &Self) -> *mut LeafNode<K, V> {\n         // The node must be valid for at least the LeafNode portion.\n         // This is not a reference in the NodeRef type because we don't know if\n         // it should be unique or shared.\n-        self.node.as_ptr()\n+        this.node.as_ptr()\n     }\n+}\n \n-    /// Borrows a reference to one of the keys stored in the node.\n+impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n+    /// Exposes one of the keys stored in the node.\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    pub unsafe fn key_at(&self, idx: usize) -> &K {\n-        unsafe { self.reborrow().into_key_at(idx) }\n+    pub unsafe fn key_at(self, idx: usize) -> &'a K {\n+        debug_assert!(idx < self.len());\n+        unsafe { Self::as_leaf(&self).keys.get_unchecked(idx).assume_init_ref() }\n     }\n \n-    /// Borrows a reference to one of the values stored in the node.\n+    /// Exposes one of the values stored in the node.\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    unsafe fn val_at(&self, idx: usize) -> &V {\n-        unsafe { self.reborrow().into_val_at(idx) }\n+    unsafe fn val_at(self, idx: usize) -> &'a V {\n+        debug_assert!(idx < self.len());\n+        unsafe { Self::as_leaf(&self).vals.get_unchecked(idx).assume_init_ref() }\n     }\n }\n \n-impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n-    /// Borrows a reference to the contents of one of the edges that delimit\n-    /// the elements of the node, without invalidating other references.\n+impl<'a, K, V> NodeRef<marker::Immut<'a>, K, V, marker::Internal> {\n+    /// Exposes the contents of one of the edges in the node.\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    unsafe fn edge_at(&self, idx: usize) -> &BoxedNode<K, V> {\n+    unsafe fn edge_at(self, idx: usize) -> &'a BoxedNode<K, V> {\n         debug_assert!(idx <= self.len());\n-        let node = self.as_internal_ptr();\n-        unsafe { (*node).edges.get_unchecked(idx).assume_init_ref() }\n+        unsafe { Self::as_internal(&self).edges.get_unchecked(idx).assume_init_ref() }\n     }\n }\n \n@@ -380,15 +429,11 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     ) -> Result<Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>, Self> {\n         // We need to use raw pointers to nodes because, if BorrowType is marker::ValMut,\n         // there might be outstanding mutable references to values that we must not invalidate.\n-        let leaf_ptr = self.as_leaf_ptr();\n+        let leaf_ptr: *const _ = Self::as_leaf_ptr(&self);\n         unsafe { (*leaf_ptr).parent }\n             .as_ref()\n             .map(|parent| Handle {\n-                node: NodeRef {\n-                    height: self.height + 1,\n-                    node: parent.cast(),\n-                    _marker: PhantomData,\n-                },\n+                node: NodeRef::from_internal(*parent, self.height + 1),\n                 idx: unsafe { usize::from((*leaf_ptr).parent_idx.assume_init()) },\n                 _marker: PhantomData,\n             })\n@@ -420,11 +465,11 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    /// Exposes the data of a leaf node for reading in an immutable tree.\n-    fn into_leaf(self) -> &'a LeafNode<K, V> {\n-        // SAFETY: we can access the entire node freely and do no need raw pointers,\n-        // because there can be no mutable references to this Immut tree.\n-        unsafe { &(*self.as_leaf_ptr()) }\n+    /// Exposes the leaf portion of any leaf or internal node in an immutable tree.\n+    fn as_leaf(this: &Self) -> &'a LeafNode<K, V> {\n+        let ptr = Self::as_leaf_ptr(this);\n+        // SAFETY: there can be no mutable references into this tree borrowed as `Immut`.\n+        unsafe { &*ptr }\n     }\n }\n \n@@ -473,139 +518,155 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n-    /// Exposes the leaf portion of any leaf or internal node for writing.\n-    ///\n-    /// We don't need to return a raw ptr because we have unique access to the entire node.\n-    fn as_leaf_mut(&mut self) -> &'a mut LeafNode<K, V> {\n-        unsafe { &mut (*self.node.as_ptr()) }\n+    /// Offers exclusive access to the leaf portion of any leaf or internal node.\n+    fn as_leaf_mut(this: &mut Self) -> &'a mut LeafNode<K, V> {\n+        let ptr = Self::as_leaf_ptr(this);\n+        // SAFETY: we have exclusive access to the entire node.\n+        unsafe { &mut *ptr }\n     }\n+}\n \n-    /// Borrows a mutable reference to one of the keys stored in the node.\n+impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    /// Offers exclusive access to a part of the key storage area.\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    unsafe fn key_mut_at(&mut self, idx: usize) -> &mut K {\n-        unsafe { self.reborrow_mut().into_key_mut_at(idx) }\n+    unsafe fn into_key_area_mut_at(mut self, idx: usize) -> &'a mut MaybeUninit<K> {\n+        debug_assert!(idx < self.len());\n+        unsafe { Self::as_leaf_mut(&mut self).keys.get_unchecked_mut(idx) }\n     }\n \n-    /// Borrows a mutable reference to one of the values stored in the node.\n+    /// Offers exclusive access to a part of the value storage area.\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    unsafe fn val_mut_at(&mut self, idx: usize) -> &mut V {\n-        unsafe { self.reborrow_mut().into_val_mut_at(idx) }\n-    }\n-\n-    fn keys_mut(&mut self) -> &mut [K]\n-    where\n-        K: 'a,\n-        V: 'a,\n-    {\n-        // SAFETY: the caller will not be able to call further methods on self\n-        // until the key slice reference is dropped, as we have unique access\n-        // for the lifetime of the borrow.\n-        // SAFETY: The keys of a node must always be initialized up to length.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().keys),\n-                self.len(),\n-            )\n-        }\n-    }\n-\n-    fn vals_mut(&mut self) -> &mut [V]\n-    where\n-        K: 'a,\n-        V: 'a,\n-    {\n-        // SAFETY: the caller will not be able to call further methods on self\n-        // until the value slice reference is dropped, as we have unique access\n-        // for the lifetime of the borrow.\n-        // SAFETY: The values of a node must always be initialized up to length.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().vals),\n-                self.len(),\n-            )\n-        }\n+    unsafe fn into_val_area_mut_at(mut self, idx: usize) -> &'a mut MaybeUninit<V> {\n+        debug_assert!(idx < self.len());\n+        unsafe { Self::as_leaf_mut(&mut self).vals.get_unchecked_mut(idx) }\n     }\n }\n \n-impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    fn edges_mut(&mut self) -> &mut [BoxedNode<K, V>] {\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut self.as_internal_mut().edges),\n-                self.len() + 1,\n-            )\n-        }\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    /// Offers exclusive access to a part of the storage area for edge contents.\n+    ///\n+    /// # Safety\n+    /// The node has at least `idx` initialized elements.\n+    unsafe fn into_edge_area_mut_at(mut self, idx: usize) -> &'a mut MaybeUninit<BoxedNode<K, V>> {\n+        debug_assert!(idx <= self.len());\n+        unsafe { Self::as_internal_mut(&mut self).edges.get_unchecked_mut(idx) }\n     }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn into_key_at(self, idx: usize) -> &'a K {\n-        unsafe { self.into_leaf().keys.get_unchecked(idx).assume_init_ref() }\n+    /// Exposes the entire key storage area in the node,\n+    /// regardless of the node's current length,\n+    /// having exclusive access to the entire node.\n+    unsafe fn key_area(self) -> &'a [MaybeUninit<K>] {\n+        Self::as_leaf(&self).keys.as_slice()\n     }\n \n-    /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn into_val_at(self, idx: usize) -> &'a V {\n-        unsafe { self.into_leaf().vals.get_unchecked(idx).assume_init_ref() }\n+    /// Exposes the entire value storage area in the node,\n+    /// regardless of the node's current length,\n+    /// having exclusive access to the entire node.\n+    unsafe fn val_area(self) -> &'a [MaybeUninit<V>] {\n+        Self::as_leaf(&self).vals.as_slice()\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n-    /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn into_key_mut_at(mut self, idx: usize) -> &'a mut K {\n-        debug_assert!(idx < self.len());\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::Internal> {\n+    /// Exposes the entire storage area for edge contents in the node,\n+    /// regardless of the node's current length,\n+    /// having exclusive access to the entire node.\n+    unsafe fn edge_area(self) -> &'a [MaybeUninit<BoxedNode<K, V>>] {\n+        Self::as_internal(&self).edges.as_slice()\n+    }\n+}\n \n-        let leaf = self.as_leaf_mut();\n-        unsafe { leaf.keys.get_unchecked_mut(idx).assume_init_mut() }\n+impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    /// Offers exclusive access to a sized slice of key storage area in the node.\n+    unsafe fn into_key_area_slice(mut self) -> &'a mut [MaybeUninit<K>] {\n+        let len = self.len();\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the key slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { Self::as_leaf_mut(&mut self).keys.get_unchecked_mut(..len) }\n     }\n \n-    /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn into_val_mut_at(mut self, idx: usize) -> &'a mut V {\n-        debug_assert!(idx < self.len());\n+    /// Offers exclusive access to a sized slice of value storage area in the node.\n+    unsafe fn into_val_area_slice(mut self) -> &'a mut [MaybeUninit<V>] {\n+        let len = self.len();\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the value slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { Self::as_leaf_mut(&mut self).vals.get_unchecked_mut(..len) }\n+    }\n+}\n \n-        let leaf = self.as_leaf_mut();\n-        unsafe { leaf.vals.get_unchecked_mut(idx).assume_init_mut() }\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    /// Offers exclusive access to a sized slice of storage area for edge contents in the node.\n+    unsafe fn into_edge_area_slice(mut self) -> &'a mut [MaybeUninit<BoxedNode<K, V>>] {\n+        let len = self.len();\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the edge slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { Self::as_internal_mut(&mut self).edges.get_unchecked_mut(..len + 1) }\n     }\n }\n \n impl<'a, K, V, Type> NodeRef<marker::ValMut<'a>, K, V, Type> {\n     /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn into_key_val_mut_at(self, idx: usize) -> (&'a K, &'a mut V) {\n+    /// - The node has more than `idx` initialized elements.\n+    /// - The keys and values of the node must be initialized up to its current length.\n+    unsafe fn into_key_val_mut_at(mut self, idx: usize) -> (&'a K, &'a mut V) {\n         // We only create a reference to the one element we are interested in,\n         // to avoid aliasing with outstanding references to other elements,\n         // in particular, those returned to the caller in earlier iterations.\n-        let leaf = self.node.as_ptr();\n+        let leaf = Self::as_leaf_ptr(&mut self);\n         let keys = unsafe { &raw const (*leaf).keys };\n         let vals = unsafe { &raw mut (*leaf).vals };\n         // We must coerce to unsized array pointers because of Rust issue #74679.\n         let keys: *const [_] = keys;\n         let vals: *mut [_] = vals;\n-        // SAFETY: The keys and values of a node must always be initialized up to length.\n         let key = unsafe { (&*keys.get_unchecked(idx)).assume_init_ref() };\n         let val = unsafe { (&mut *vals.get_unchecked_mut(idx)).assume_init_mut() };\n         (key, val)\n     }\n }\n \n+impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n+    /// Exposes exclusive access to the length of the node.\n+    pub fn into_len_mut(mut self) -> &'a mut u16 {\n+        &mut (*Self::as_leaf_mut(&mut self)).len\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Set or clear the node's link to its parent edge,\n+    /// without invalidating other references to the node.\n+    fn set_parent_link(&mut self, parent: NonNull<InternalNode<K, V>>, parent_idx: usize) {\n+        let leaf = Self::as_leaf_ptr(self);\n+        unsafe { (*leaf).parent = Some(parent) };\n+        unsafe { (*leaf).parent_idx.write(parent_idx as u16) };\n+    }\n+\n+    /// Clear the node's link to its parent edge, freeing it from its tree.\n+    /// This only makes sense when there are no other references to the node.\n+    fn clear_parent_link(&mut self) {\n+        let leaf = Self::as_leaf_mut(self);\n+        leaf.parent = None;\n+    }\n+}\n+\n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair to the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n-        let len = &mut self.as_leaf_mut().len;\n+        let len = unsafe { self.reborrow_mut().into_len_mut() };\n         let idx = usize::from(*len);\n         assert!(idx < CAPACITY);\n         *len += 1;\n         unsafe {\n-            ptr::write(self.key_mut_at(idx), key);\n-            ptr::write(self.val_mut_at(idx), val);\n+            self.reborrow_mut().into_key_area_mut_at(idx).write(key);\n+            self.reborrow_mut().into_val_area_mut_at(idx).write(val);\n         }\n     }\n \n@@ -614,10 +675,10 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         assert!(self.len() < CAPACITY);\n \n         unsafe {\n-            slice_insert(self.keys_mut(), 0, key);\n-            slice_insert(self.vals_mut(), 0, val);\n+            *self.reborrow_mut().into_len_mut() += 1;\n+            slice_insert(self.reborrow_mut().into_key_area_slice(), 0, key);\n+            slice_insert(self.reborrow_mut().into_val_area_slice(), 0, val);\n         }\n-        self.as_leaf_mut().len += 1;\n     }\n }\n \n@@ -643,14 +704,14 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n \n-        let len = &mut self.as_leaf_mut().len;\n+        let len = unsafe { self.reborrow_mut().into_len_mut() };\n         let idx = usize::from(*len);\n         assert!(idx < CAPACITY);\n         *len += 1;\n         unsafe {\n-            ptr::write(self.key_mut_at(idx), key);\n-            ptr::write(self.val_mut_at(idx), val);\n-            self.as_internal_mut().edges.get_unchecked_mut(idx + 1).write(edge.node);\n+            self.reborrow_mut().into_key_area_mut_at(idx).write(key);\n+            self.reborrow_mut().into_val_area_mut_at(idx).write(val);\n+            self.reborrow_mut().into_edge_area_mut_at(idx + 1).write(edge.into_boxed_node());\n             Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();\n         }\n     }\n@@ -662,13 +723,12 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         assert!(self.len() < CAPACITY);\n \n         unsafe {\n-            slice_insert(self.keys_mut(), 0, key);\n-            slice_insert(self.vals_mut(), 0, val);\n-            slice_insert(self.edges_mut(), 0, edge.node);\n+            *self.reborrow_mut().into_len_mut() += 1;\n+            slice_insert(self.reborrow_mut().into_key_area_slice(), 0, key);\n+            slice_insert(self.reborrow_mut().into_val_area_slice(), 0, val);\n+            slice_insert(self.reborrow_mut().into_edge_area_slice(), 0, edge.into_boxed_node());\n         }\n \n-        self.as_leaf_mut().len += 1;\n-\n         self.correct_all_childrens_parent_links();\n     }\n }\n@@ -683,19 +743,21 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let idx = self.len() - 1;\n \n         unsafe {\n-            let key = ptr::read(self.key_at(idx));\n-            let val = ptr::read(self.val_at(idx));\n+            let key = ptr::read(self.reborrow().key_at(idx));\n+            let val = ptr::read(self.reborrow().val_at(idx));\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(internal) => {\n-                    let edge = ptr::read(internal.edge_at(idx + 1));\n-                    let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    new_root.node_as_mut().as_leaf_mut().parent = None;\n-                    Some(new_root)\n+                    let boxed_node = ptr::read(internal.reborrow().edge_at(idx + 1));\n+                    let mut edge = Root { node: boxed_node, height: internal.height - 1 };\n+                    // In practice, clearing the parent is a waste of time, because we will\n+                    // insert the node elsewhere and set its parent link again.\n+                    edge.node_as_mut().clear_parent_link();\n+                    Some(edge)\n                 }\n             };\n \n-            self.as_leaf_mut().len -= 1;\n+            *self.reborrow_mut().into_len_mut() -= 1;\n             (key, val, edge)\n         }\n     }\n@@ -709,29 +771,35 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let old_len = self.len();\n \n         unsafe {\n-            let key = slice_remove(self.keys_mut(), 0);\n-            let val = slice_remove(self.vals_mut(), 0);\n+            let key = slice_remove(self.reborrow_mut().into_key_area_slice(), 0);\n+            let val = slice_remove(self.reborrow_mut().into_val_area_slice(), 0);\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(mut internal) => {\n-                    let edge = slice_remove(internal.edges_mut(), 0);\n-                    let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    new_root.node_as_mut().as_leaf_mut().parent = None;\n+                    let boxed_node =\n+                        slice_remove(internal.reborrow_mut().into_edge_area_slice(), 0);\n+                    let mut edge = Root { node: boxed_node, height: internal.height - 1 };\n+                    // In practice, clearing the parent is a waste of time, because we will\n+                    // insert the node elsewhere and set its parent link again.\n+                    edge.node_as_mut().clear_parent_link();\n \n                     internal.correct_childrens_parent_links(0..old_len);\n \n-                    Some(new_root)\n+                    Some(edge)\n                 }\n             };\n \n-            self.as_leaf_mut().len -= 1;\n+            *self.reborrow_mut().into_len_mut() -= 1;\n \n             (key, val, edge)\n         }\n     }\n \n     fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n-        (self.keys_mut().as_mut_ptr(), self.vals_mut().as_mut_ptr())\n+        let leaf = Self::as_leaf_mut(&mut self);\n+        let keys = MaybeUninit::slice_as_mut_ptr(&mut leaf.keys);\n+        let vals = MaybeUninit::slice_as_mut_ptr(&mut leaf.vals);\n+        (keys, vals)\n     }\n }\n \n@@ -816,7 +884,7 @@ impl<BorrowType, K, V, NodeType> NodeRef<BorrowType, K, V, NodeType> {\n     /// Could be a public implementation of PartialEq, but only used in this module.\n     fn eq(&self, other: &Self) -> bool {\n         let Self { node, height, _marker: _ } = self;\n-        if *node == other.node {\n+        if node.eq(&other.node) {\n             debug_assert_eq!(*height, other.height);\n             true\n         } else {\n@@ -924,11 +992,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         debug_assert!(self.node.len() < CAPACITY);\n \n         unsafe {\n-            slice_insert(self.node.keys_mut(), self.idx, key);\n-            slice_insert(self.node.vals_mut(), self.idx, val);\n-            self.node.as_leaf_mut().len += 1;\n+            *self.node.reborrow_mut().into_len_mut() += 1;\n+            slice_insert(self.node.reborrow_mut().into_key_area_slice(), self.idx, key);\n+            slice_insert(self.node.reborrow_mut().into_val_area_slice(), self.idx, val);\n \n-            self.node.val_mut_at(self.idx)\n+            self.node.reborrow_mut().into_val_area_mut_at(self.idx).assume_init_mut()\n         }\n     }\n }\n@@ -964,12 +1032,12 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n     /// Fixes the parent pointer and index in the child node below this edge. This is useful\n     /// when the ordering of edges has been changed, such as in the various `insert` methods.\n-    fn correct_parent_link(mut self) {\n-        let idx = self.idx as u16;\n-        let ptr = NonNull::new(self.node.as_internal_mut());\n+    fn correct_parent_link(self) {\n+        // Create backpointer without invalidating other references to the node.\n+        let ptr = unsafe { NonNull::new_unchecked(NodeRef::as_internal_ptr(&self.node)) };\n+        let idx = self.idx;\n         let mut child = self.descend();\n-        child.as_leaf_mut().parent = ptr;\n-        child.as_leaf_mut().parent_idx.write(idx);\n+        child.set_parent_link(ptr, idx);\n     }\n }\n \n@@ -981,11 +1049,12 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         debug_assert!(self.node.len() < CAPACITY);\n         debug_assert!(edge.height == self.node.height - 1);\n \n+        let boxed_node = edge.into_boxed_node();\n         unsafe {\n-            slice_insert(self.node.keys_mut(), self.idx, key);\n-            slice_insert(self.node.vals_mut(), self.idx, val);\n-            slice_insert(self.node.edges_mut(), self.idx + 1, edge.node);\n-            self.node.as_leaf_mut().len += 1;\n+            *self.node.reborrow_mut().into_len_mut() += 1;\n+            slice_insert(self.node.reborrow_mut().into_key_area_slice(), self.idx, key);\n+            slice_insert(self.node.reborrow_mut().into_val_area_slice(), self.idx, val);\n+            slice_insert(self.node.reborrow_mut().into_edge_area_slice(), self.idx + 1, boxed_node);\n \n             self.node.correct_childrens_parent_links((self.idx + 1)..=self.node.len());\n         }\n@@ -1073,28 +1142,25 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n         // node pointer is dereferenced, we access the edges array with a\n         // reference (Rust issue #73987) and invalidate any other references\n         // to or inside the array, should any be around.\n-        let internal_node = self.node.as_internal_ptr();\n-        NodeRef {\n-            height: self.node.height - 1,\n-            node: unsafe { (&*(*internal_node).edges.get_unchecked(self.idx).as_ptr()).as_ptr() },\n-            _marker: PhantomData,\n-        }\n+        let parent_ptr = NodeRef::as_internal_ptr(&self.node);\n+        let boxed_node = unsafe { (*parent_ptr).edges.get_unchecked(self.idx).assume_init_read() };\n+        NodeRef::from_boxed_node(boxed_node, self.node.height - 1)\n     }\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv(self) -> (&'a K, &'a V) {\n-        (unsafe { self.node.into_key_at(self.idx) }, unsafe { self.node.into_val_at(self.idx) })\n+        (unsafe { self.node.key_at(self.idx) }, unsafe { self.node.val_at(self.idx) })\n     }\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_key_mut(self) -> &'a mut K {\n-        unsafe { self.node.into_key_mut_at(self.idx) }\n+        unsafe { self.node.into_key_area_mut_at(self.idx).assume_init_mut() }\n     }\n \n     pub fn into_val_mut(self) -> &'a mut V {\n-        unsafe { self.node.into_val_mut_at(self.idx) }\n+        unsafe { self.node.into_val_area_mut_at(self.idx).assume_init_mut() }\n     }\n }\n \n@@ -1106,12 +1172,14 @@ impl<'a, K, V, NodeType> Handle<NodeRef<marker::ValMut<'a>, K, V, NodeType>, mar\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn kv_mut(&mut self) -> (&mut K, &mut V) {\n-        // We cannot call into_key_mut_at and into_val_mut_at, because calling the second one\n+        // We cannot call separate key and value methods, because calling the second one\n         // invalidates the reference returned by the first.\n-        let leaf = self.node.as_leaf_mut();\n-        let key = unsafe { leaf.keys.get_unchecked_mut(self.idx).assume_init_mut() };\n-        let val = unsafe { leaf.vals.get_unchecked_mut(self.idx).assume_init_mut() };\n-        (key, val)\n+        unsafe {\n+            let leaf = NodeRef::as_leaf_mut(&mut self.node.reborrow_mut());\n+            let key = leaf.keys.get_unchecked_mut(self.idx).assume_init_mut();\n+            let val = leaf.vals.get_unchecked_mut(self.idx).assume_init_mut();\n+            (key, val)\n+        }\n     }\n }\n \n@@ -1127,23 +1195,23 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n     /// by taking care of leaf data.\n     fn split_leaf_data(&mut self, new_node: &mut LeafNode<K, V>) -> (K, V) {\n         let new_len = self.split_new_node_len();\n+        new_node.len = new_len as u16;\n         unsafe {\n-            let k = ptr::read(self.node.key_at(self.idx));\n-            let v = ptr::read(self.node.val_at(self.idx));\n+            let k = ptr::read(self.node.reborrow().key_at(self.idx));\n+            let v = ptr::read(self.node.reborrow().val_at(self.idx));\n \n             ptr::copy_nonoverlapping(\n-                self.node.key_at(self.idx + 1),\n-                MaybeUninit::slice_as_mut_ptr(&mut new_node.keys),\n+                self.node.reborrow().key_area().as_ptr().add(self.idx + 1),\n+                new_node.keys.as_mut_ptr(),\n                 new_len,\n             );\n             ptr::copy_nonoverlapping(\n-                self.node.val_at(self.idx + 1),\n-                MaybeUninit::slice_as_mut_ptr(&mut new_node.vals),\n+                self.node.reborrow().val_area().as_ptr().add(self.idx + 1),\n+                new_node.vals.as_mut_ptr(),\n                 new_len,\n             );\n \n-            self.node.as_leaf_mut().len = self.idx as u16;\n-            new_node.len = new_len as u16;\n+            *self.node.reborrow_mut().into_len_mut() = self.idx as u16;\n             (k, v)\n         }\n     }\n@@ -1174,9 +1242,9 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         mut self,\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         unsafe {\n-            let k = slice_remove(self.node.keys_mut(), self.idx);\n-            let v = slice_remove(self.node.vals_mut(), self.idx);\n-            self.node.as_leaf_mut().len -= 1;\n+            let k = slice_remove(self.node.reborrow_mut().into_key_area_slice(), self.idx);\n+            let v = slice_remove(self.node.reborrow_mut().into_val_area_slice(), self.idx);\n+            *self.node.reborrow_mut().into_len_mut() -= 1;\n             ((k, v), self.left_edge())\n         }\n     }\n@@ -1205,11 +1273,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {\n         unsafe {\n             let mut new_node = Box::new(InternalNode::new());\n-            // Move edges out before reducing length:\n             let new_len = self.split_new_node_len();\n+            // Move edges out before reducing length:\n             ptr::copy_nonoverlapping(\n-                self.node.edge_at(self.idx + 1),\n-                MaybeUninit::slice_as_mut_ptr(&mut new_node.edges),\n+                self.node.reborrow().edge_area().as_ptr().add(self.idx + 1),\n+                new_node.edges.as_mut_ptr(),\n                 new_len + 1,\n             );\n             let (k, v) = self.split_leaf_data(&mut new_node.data);\n@@ -1241,40 +1309,37 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         assert!(left_len + right_len < CAPACITY);\n \n         unsafe {\n-            ptr::write(\n-                left_node.keys_mut().get_unchecked_mut(left_len),\n-                slice_remove(self.node.keys_mut(), self.idx),\n-            );\n+            *left_node.reborrow_mut().into_len_mut() += right_len as u16 + 1;\n+\n+            let parent_key = slice_remove(self.node.reborrow_mut().into_key_area_slice(), self.idx);\n+            left_node.reborrow_mut().into_key_area_mut_at(left_len).write(parent_key);\n             ptr::copy_nonoverlapping(\n-                right_node.key_at(0),\n-                left_node.keys_mut().as_mut_ptr().add(left_len + 1),\n+                right_node.reborrow().key_area().as_ptr(),\n+                left_node.reborrow_mut().into_key_area_slice().as_mut_ptr().add(left_len + 1),\n                 right_len,\n             );\n-            ptr::write(\n-                left_node.vals_mut().get_unchecked_mut(left_len),\n-                slice_remove(self.node.vals_mut(), self.idx),\n-            );\n+\n+            let parent_val = slice_remove(self.node.reborrow_mut().into_val_area_slice(), self.idx);\n+            left_node.reborrow_mut().into_val_area_mut_at(left_len).write(parent_val);\n             ptr::copy_nonoverlapping(\n-                right_node.val_at(0),\n-                left_node.vals_mut().as_mut_ptr().add(left_len + 1),\n+                right_node.reborrow().val_area().as_ptr(),\n+                left_node.reborrow_mut().into_val_area_slice().as_mut_ptr().add(left_len + 1),\n                 right_len,\n             );\n \n-            slice_remove(&mut self.node.edges_mut(), self.idx + 1);\n+            slice_remove(&mut self.node.reborrow_mut().into_edge_area_slice(), self.idx + 1);\n             let self_len = self.node.len();\n             self.node.correct_childrens_parent_links(self.idx + 1..self_len);\n-            self.node.as_leaf_mut().len -= 1;\n-\n-            left_node.as_leaf_mut().len += right_len as u16 + 1;\n+            *self.node.reborrow_mut().into_len_mut() -= 1;\n \n             if self.node.height > 1 {\n                 // SAFETY: the height of the nodes being merged is one below the height\n                 // of the node of this edge, thus above zero, so they are internal.\n                 let mut left_node = left_node.cast_to_internal_unchecked();\n                 let right_node = right_node.cast_to_internal_unchecked();\n                 ptr::copy_nonoverlapping(\n-                    right_node.edge_at(0),\n-                    left_node.edges_mut().as_mut_ptr().add(left_len + 1),\n+                    right_node.reborrow().edge_area().as_ptr(),\n+                    left_node.reborrow_mut().into_edge_area_slice().as_mut_ptr().add(left_len + 1),\n                     right_len + 1,\n                 );\n \n@@ -1360,13 +1425,14 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                 move_kv(left_kv, new_left_len, parent_kv, 0, 1);\n             }\n \n-            left_node.as_leaf_mut().len -= count as u16;\n-            right_node.as_leaf_mut().len += count as u16;\n+            *left_node.reborrow_mut().into_len_mut() -= count as u16;\n+            *right_node.reborrow_mut().into_len_mut() += count as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n                     // Make room for stolen edges.\n-                    let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n+                    let left = left.reborrow();\n+                    let right_edges = right.reborrow_mut().into_edge_area_slice().as_mut_ptr();\n                     ptr::copy(right_edges, right_edges.add(count), right_len + 1);\n                     right.correct_childrens_parent_links(count..count + right_len + 1);\n \n@@ -1415,15 +1481,15 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                 ptr::copy(right_kv.1.add(count), right_kv.1, new_right_len);\n             }\n \n-            left_node.as_leaf_mut().len += count as u16;\n-            right_node.as_leaf_mut().len -= count as u16;\n+            *left_node.reborrow_mut().into_len_mut() += count as u16;\n+            *right_node.reborrow_mut().into_len_mut() -= count as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n-                    move_edges(right.reborrow_mut(), 0, left, left_len + 1, count);\n+                    move_edges(right.reborrow(), 0, left, left_len + 1, count);\n \n                     // Fix right indexing.\n-                    let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n+                    let right_edges = right.reborrow_mut().into_edge_area_slice().as_mut_ptr();\n                     ptr::copy(right_edges.add(count), right_edges, new_right_len + 1);\n                     right.correct_childrens_parent_links(0..=new_right_len);\n                 }\n@@ -1448,16 +1514,16 @@ unsafe fn move_kv<K, V>(\n }\n \n // Source and destination must have the same height.\n-unsafe fn move_edges<K, V>(\n-    mut source: NodeRef<marker::Mut<'_>, K, V, marker::Internal>,\n+unsafe fn move_edges<'a, K: 'a, V: 'a>(\n+    source: NodeRef<marker::Immut<'a>, K, V, marker::Internal>,\n     source_offset: usize,\n-    mut dest: NodeRef<marker::Mut<'_>, K, V, marker::Internal>,\n+    mut dest: NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     dest_offset: usize,\n     count: usize,\n ) {\n-    let source_ptr = source.as_internal().edges.as_ptr();\n-    let dest_ptr = dest.as_internal_mut().edges.as_mut_ptr();\n     unsafe {\n+        let source_ptr = source.edge_area().as_ptr();\n+        let dest_ptr = dest.reborrow_mut().into_edge_area_slice().as_mut_ptr();\n         ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n         dest.correct_childrens_parent_links(dest_offset..dest_offset + count);\n     }\n@@ -1553,11 +1619,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n \n                 move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n \n-                left_node.as_leaf_mut().len = left_new_len as u16;\n-                right_node.as_leaf_mut().len = right_new_len as u16;\n+                *left_node.reborrow_mut().into_len_mut() = left_new_len as u16;\n+                *right_node.reborrow_mut().into_len_mut() = right_new_len as u16;\n \n                 match (left_node.force(), right_node.force()) {\n                     (ForceResult::Internal(left), ForceResult::Internal(right)) => {\n+                        let left = left.reborrow();\n                         move_edges(left, left_new_len + 1, right, 1, right_new_len);\n                     }\n                     (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n@@ -1606,20 +1673,33 @@ pub mod marker {\n     pub enum Edge {}\n }\n \n-unsafe fn slice_insert<T>(slice: &mut [T], idx: usize, val: T) {\n+/// Inserts a value into a slice of initialized elements followed by one uninitialized element.\n+///\n+/// # Safety\n+/// The slice has more than `idx` elements.\n+unsafe fn slice_insert<T>(slice: &mut [MaybeUninit<T>], idx: usize, val: T) {\n     unsafe {\n         let len = slice.len();\n+        debug_assert!(len > idx);\n         let slice_ptr = slice.as_mut_ptr();\n-        ptr::copy(slice_ptr.add(idx), slice_ptr.add(idx + 1), len - idx);\n-        ptr::write(slice_ptr.add(idx), val);\n+        if len > idx + 1 {\n+            ptr::copy(slice_ptr.add(idx), slice_ptr.add(idx + 1), len - idx - 1);\n+        }\n+        (*slice_ptr.add(idx)).write(val);\n     }\n }\n \n-unsafe fn slice_remove<T>(slice: &mut [T], idx: usize) -> T {\n+/// Removes and returns a value from a slice of all initialized elements, leaving behind one\n+/// trailing uninitialized element.\n+///\n+/// # Safety\n+/// The slice has more than `idx` elements.\n+unsafe fn slice_remove<T>(slice: &mut [MaybeUninit<T>], idx: usize) -> T {\n     unsafe {\n         let len = slice.len();\n+        debug_assert!(idx < len);\n         let slice_ptr = slice.as_mut_ptr();\n-        let ret = ptr::read(slice_ptr.add(idx));\n+        let ret = (*slice_ptr.add(idx)).assume_init_read();\n         ptr::copy(slice_ptr.add(idx + 1), slice_ptr.add(idx), len - idx - 1);\n         ret\n     }"}, {"sha": "701d5ec73e218ddfb38bcd2d73db6f40a8e8d4bb", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d", "patch": "@@ -72,7 +72,7 @@ where\n     // is an index -- not a reference.\n     let len = node.len();\n     for i in 0..len {\n-        let k = unsafe { node.key_at(i) };\n+        let k = unsafe { node.reborrow().key_at(i) };\n         match key.cmp(k.borrow()) {\n             Ordering::Greater => {}\n             Ordering::Equal => return (i, true),"}, {"sha": "f21fc8854d05e16af76539b0493fee70616a092b", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d", "patch": "@@ -78,6 +78,7 @@\n #![cfg_attr(test, feature(new_uninit))]\n #![feature(allocator_api)]\n #![feature(array_chunks)]\n+#![feature(array_methods)]\n #![feature(array_value_iter)]\n #![feature(array_windows)]\n #![feature(allow_internal_unstable)]"}]}