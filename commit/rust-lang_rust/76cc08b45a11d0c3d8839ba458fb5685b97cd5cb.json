{"sha": "76cc08b45a11d0c3d8839ba458fb5685b97cd5cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2Y2MwOGI0NWExMWQwYzNkODgzOWJhNDU4ZmI1Njg1Yjk3Y2Q1Y2I=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-27T20:24:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-27T20:24:12Z"}, "message": "Rollup merge of #40516 - alexcrichton:no-cache-handles, r=aturon\n\nstd: Don't cache stdio handles on Windows\n\nThis alters the stdio code on Windows to always call `GetStdHandle` whenever the\nstdio read/write functions are called as this allows us to track changes to the\nvalue over time (such as if a process calls `SetStdHandle` while it's running).\n\nCloses #40490", "tree": {"sha": "819c14b37ec2153e65a60fd70d33912de197ede0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/819c14b37ec2153e65a60fd70d33912de197ede0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76cc08b45a11d0c3d8839ba458fb5685b97cd5cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76cc08b45a11d0c3d8839ba458fb5685b97cd5cb", "html_url": "https://github.com/rust-lang/rust/commit/76cc08b45a11d0c3d8839ba458fb5685b97cd5cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76cc08b45a11d0c3d8839ba458fb5685b97cd5cb/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e857e296c191ded418956143ef18dc2f419bd304", "url": "https://api.github.com/repos/rust-lang/rust/commits/e857e296c191ded418956143ef18dc2f419bd304", "html_url": "https://github.com/rust-lang/rust/commit/e857e296c191ded418956143ef18dc2f419bd304"}, {"sha": "5ca8a735ca36219abbf601624606c41148b95210", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ca8a735ca36219abbf601624606c41148b95210", "html_url": "https://github.com/rust-lang/rust/commit/5ca8a735ca36219abbf601624606c41148b95210"}], "stats": {"total": 165, "additions": 110, "deletions": 55}, "files": [{"sha": "dfbc1b581ee55f39b4bb22366beb1240e3c4c79a", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76cc08b45a11d0c3d8839ba458fb5685b97cd5cb/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cc08b45a11d0c3d8839ba458fb5685b97cd5cb/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=76cc08b45a11d0c3d8839ba458fb5685b97cd5cb", "patch": "@@ -257,8 +257,13 @@ impl Stdio {\n             // INVALID_HANDLE_VALUE.\n             Stdio::Inherit => {\n                 match stdio::get(stdio_id) {\n-                    Ok(io) => io.handle().duplicate(0, true,\n-                                                    c::DUPLICATE_SAME_ACCESS),\n+                    Ok(io) => {\n+                        let io = Handle::new(io.handle());\n+                        let ret = io.duplicate(0, true,\n+                                               c::DUPLICATE_SAME_ACCESS);\n+                        io.into_raw();\n+                        return ret\n+                    }\n                     Err(..) => Ok(Handle::new(c::INVALID_HANDLE_VALUE)),\n                 }\n             }"}, {"sha": "d72e4b4438b7bc8d367638bcb55ec96a6bf77474", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 39, "deletions": 53, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/76cc08b45a11d0c3d8839ba458fb5685b97cd5cb/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cc08b45a11d0c3d8839ba458fb5685b97cd5cb/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=76cc08b45a11d0c3d8839ba458fb5685b97cd5cb", "patch": "@@ -22,42 +22,43 @@ use sys::cvt;\n use sys::handle::Handle;\n use sys_common::io::read_to_end_uninitialized;\n \n-pub struct NoClose(Option<Handle>);\n-\n pub enum Output {\n-    Console(NoClose),\n-    Pipe(NoClose),\n+    Console(c::HANDLE),\n+    Pipe(c::HANDLE),\n }\n \n pub struct Stdin {\n-    handle: Output,\n     utf8: Mutex<io::Cursor<Vec<u8>>>,\n }\n-pub struct Stdout(Output);\n-pub struct Stderr(Output);\n+pub struct Stdout;\n+pub struct Stderr;\n \n pub fn get(handle: c::DWORD) -> io::Result<Output> {\n     let handle = unsafe { c::GetStdHandle(handle) };\n     if handle == c::INVALID_HANDLE_VALUE {\n         Err(io::Error::last_os_error())\n     } else if handle.is_null() {\n-        Err(io::Error::new(io::ErrorKind::Other,\n-                           \"no stdio handle available for this process\"))\n+        Err(io::Error::from_raw_os_error(c::ERROR_INVALID_HANDLE as i32))\n     } else {\n-        let ret = NoClose::new(handle);\n         let mut out = 0;\n         match unsafe { c::GetConsoleMode(handle, &mut out) } {\n-            0 => Ok(Output::Pipe(ret)),\n-            _ => Ok(Output::Console(ret)),\n+            0 => Ok(Output::Pipe(handle)),\n+            _ => Ok(Output::Console(handle)),\n         }\n     }\n }\n \n-fn write(out: &Output, data: &[u8]) -> io::Result<usize> {\n-    let handle = match *out {\n-        Output::Console(ref c) => c.get().raw(),\n-        Output::Pipe(ref p) => return p.get().write(data),\n+fn write(handle: c::DWORD, data: &[u8]) -> io::Result<usize> {\n+    let handle = match try!(get(handle)) {\n+        Output::Console(c) => c,\n+        Output::Pipe(p) => {\n+            let handle = Handle::new(p);\n+            let ret = handle.write(data);\n+            handle.into_raw();\n+            return ret\n+        }\n     };\n+\n     // As with stdin on windows, stdout often can't handle writes of large\n     // sizes. For an example, see #14940. For this reason, don't try to\n     // write the entire output buffer on windows.\n@@ -93,18 +94,20 @@ fn write(out: &Output, data: &[u8]) -> io::Result<usize> {\n \n impl Stdin {\n     pub fn new() -> io::Result<Stdin> {\n-        get(c::STD_INPUT_HANDLE).map(|handle| {\n-            Stdin {\n-                handle: handle,\n-                utf8: Mutex::new(Cursor::new(Vec::new())),\n-            }\n+        Ok(Stdin {\n+            utf8: Mutex::new(Cursor::new(Vec::new())),\n         })\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let handle = match self.handle {\n-            Output::Console(ref c) => c.get().raw(),\n-            Output::Pipe(ref p) => return p.get().read(buf),\n+        let handle = match try!(get(c::STD_INPUT_HANDLE)) {\n+            Output::Console(c) => c,\n+            Output::Pipe(p) => {\n+                let handle = Handle::new(p);\n+                let ret = handle.read(buf);\n+                handle.into_raw();\n+                return ret\n+            }\n         };\n         let mut utf8 = self.utf8.lock().unwrap();\n         // Read more if the buffer is empty\n@@ -125,11 +128,9 @@ impl Stdin {\n                 Ok(utf8) => utf8.into_bytes(),\n                 Err(..) => return Err(invalid_encoding()),\n             };\n-            if let Output::Console(_) = self.handle {\n-                if let Some(&last_byte) = data.last() {\n-                    if last_byte == CTRL_Z {\n-                        data.pop();\n-                    }\n+            if let Some(&last_byte) = data.last() {\n+                if last_byte == CTRL_Z {\n+                    data.pop();\n                 }\n             }\n             *utf8 = Cursor::new(data);\n@@ -158,11 +159,11 @@ impl<'a> Read for &'a Stdin {\n \n impl Stdout {\n     pub fn new() -> io::Result<Stdout> {\n-        get(c::STD_OUTPUT_HANDLE).map(Stdout)\n+        Ok(Stdout)\n     }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        write(&self.0, data)\n+        write(c::STD_OUTPUT_HANDLE, data)\n     }\n \n     pub fn flush(&self) -> io::Result<()> {\n@@ -172,11 +173,11 @@ impl Stdout {\n \n impl Stderr {\n     pub fn new() -> io::Result<Stderr> {\n-        get(c::STD_ERROR_HANDLE).map(Stderr)\n+        Ok(Stderr)\n     }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        write(&self.0, data)\n+        write(c::STD_ERROR_HANDLE, data)\n     }\n \n     pub fn flush(&self) -> io::Result<()> {\n@@ -197,27 +198,12 @@ impl io::Write for Stderr {\n     }\n }\n \n-impl NoClose {\n-    fn new(handle: c::HANDLE) -> NoClose {\n-        NoClose(Some(Handle::new(handle)))\n-    }\n-\n-    fn get(&self) -> &Handle { self.0.as_ref().unwrap() }\n-}\n-\n-impl Drop for NoClose {\n-    fn drop(&mut self) {\n-        self.0.take().unwrap().into_raw();\n-    }\n-}\n-\n impl Output {\n-    pub fn handle(&self) -> &Handle {\n-        let nc = match *self {\n-            Output::Console(ref c) => c,\n-            Output::Pipe(ref c) => c,\n-        };\n-        nc.0.as_ref().unwrap()\n+    pub fn handle(&self) -> c::HANDLE {\n+        match *self {\n+            Output::Console(c) => c,\n+            Output::Pipe(c) => c,\n+        }\n     }\n }\n "}, {"sha": "4542e27545a4c9768dbb1054431635b359fb5ad4", "filename": "src/test/run-pass-fulldeps/switch-stdout.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/76cc08b45a11d0c3d8839ba458fb5685b97cd5cb/src%2Ftest%2Frun-pass-fulldeps%2Fswitch-stdout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cc08b45a11d0c3d8839ba458fb5685b97cd5cb/src%2Ftest%2Frun-pass-fulldeps%2Fswitch-stdout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fswitch-stdout.rs?ref=76cc08b45a11d0c3d8839ba458fb5685b97cd5cb", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_private)]\n+\n+extern crate rustc_back;\n+\n+use std::fs::File;\n+use std::io::{Read, Write};\n+\n+use rustc_back::tempdir::TempDir;\n+\n+#[cfg(unix)]\n+fn switch_stdout_to(file: File) {\n+    use std::os::unix::prelude::*;\n+\n+    extern {\n+        fn dup2(old: i32, new: i32) -> i32;\n+    }\n+\n+    unsafe {\n+        assert_eq!(dup2(file.as_raw_fd(), 1), 1);\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn switch_stdout_to(file: File) {\n+    use std::os::windows::prelude::*;\n+\n+    extern \"system\" {\n+        fn SetStdHandle(nStdHandle: u32, handle: *mut u8) -> i32;\n+    }\n+\n+    const STD_OUTPUT_HANDLE: u32 = (-11i32) as u32;\n+\n+    unsafe {\n+        let rc = SetStdHandle(STD_OUTPUT_HANDLE,\n+                              file.into_raw_handle() as *mut _);\n+        assert!(rc != 0);\n+    }\n+}\n+\n+fn main() {\n+    let td = TempDir::new(\"foo\").unwrap();\n+    let path = td.path().join(\"bar\");\n+    let f = File::create(&path).unwrap();\n+\n+    println!(\"foo\");\n+    std::io::stdout().flush().unwrap();\n+    switch_stdout_to(f);\n+    println!(\"bar\");\n+    std::io::stdout().flush().unwrap();\n+\n+    let mut contents = String::new();\n+    File::open(&path).unwrap().read_to_string(&mut contents).unwrap();\n+    assert_eq!(contents, \"bar\\n\");\n+}"}]}