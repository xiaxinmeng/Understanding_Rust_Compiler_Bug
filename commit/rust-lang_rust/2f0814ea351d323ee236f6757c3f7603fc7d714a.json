{"sha": "2f0814ea351d323ee236f6757c3f7603fc7d714a", "node_id": "C_kwDOAAsO6NoAKDJmMDgxNGVhMzUxZDMyM2VlMjM2ZjY3NTdjM2Y3NjAzZmM3ZDcxNGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-02T12:37:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-02T12:37:17Z"}, "message": "Auto merge of #12347 - feniljain:fix_extract_module, r=Veykril\n\nfix(extract_module) resolving import panics and improve import resolution\n\n- Should solve #11766\n- While adding a test case for this issue, I observed another issue:\nFor this test case:\n```rust\n            mod x {\n                pub struct Foo;\n                pub struct Bar;\n            }\n\n            use x::{Bar, Foo};\n\n            $0type A = (Foo, Bar);$0\n```\nextract module should yield this:\n\n```rust\n            mod x {\n                pub struct Foo;\n                pub struct Bar;\n            }\n\n            use x::{};\n\n            mod modname {\n                use super::x::Bar;\n\n                use super::x::Foo;\n\n                pub(crate) type A = (Foo, Bar);\n            }\n```\n\ninstead it gave:\n\n```rust\n            mod x {\n                pub struct Foo;\n                pub struct Bar;\n            }\n\n            use x::{};\n\n            mod modname {\n                use x::Bar;\n\n                use x::Foo;\n\n                pub(crate) type A = (Foo, Bar);\n            }\n```\n\nSo fixed this problem with second commit", "tree": {"sha": "85c225f83fce5758eb4cc178501d5311e4620df7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85c225f83fce5758eb4cc178501d5311e4620df7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f0814ea351d323ee236f6757c3f7603fc7d714a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f0814ea351d323ee236f6757c3f7603fc7d714a", "html_url": "https://github.com/rust-lang/rust/commit/2f0814ea351d323ee236f6757c3f7603fc7d714a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f0814ea351d323ee236f6757c3f7603fc7d714a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f7c5589abfc93fbdfc071cc2716d1ea7b527e2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f7c5589abfc93fbdfc071cc2716d1ea7b527e2e", "html_url": "https://github.com/rust-lang/rust/commit/6f7c5589abfc93fbdfc071cc2716d1ea7b527e2e"}, {"sha": "8a1ef52f5c39e1d549bf4c731f5d7756fe54cd0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a1ef52f5c39e1d549bf4c731f5d7756fe54cd0e", "html_url": "https://github.com/rust-lang/rust/commit/8a1ef52f5c39e1d549bf4c731f5d7756fe54cd0e"}], "stats": {"total": 98, "additions": 92, "deletions": 6}, "files": [{"sha": "11349b45d3c3f61465f4bb60b0cc42dd32e60724", "filename": "crates/ide-assists/src/handlers/extract_module.rs", "status": "modified", "additions": 92, "deletions": 6, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/2f0814ea351d323ee236f6757c3f7603fc7d714a/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0814ea351d323ee236f6757c3f7603fc7d714a/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=2f0814ea351d323ee236f6757c3f7603fc7d714a", "patch": "@@ -413,7 +413,10 @@ impl Module {\n                                         ctx,\n                                     )\n                                 {\n-                                    import_paths_to_be_removed.push(import_path);\n+                                    check_intersection_and_push(\n+                                        &mut import_paths_to_be_removed,\n+                                        import_path,\n+                                    );\n                                 }\n                             }\n                         }\n@@ -439,7 +442,10 @@ impl Module {\n                                         ctx,\n                                     )\n                                 {\n-                                    import_paths_to_be_removed.push(import_path);\n+                                    check_intersection_and_push(\n+                                        &mut import_paths_to_be_removed,\n+                                        import_path,\n+                                    );\n                                 }\n                             }\n                         }\n@@ -543,12 +549,25 @@ impl Module {\n         } else if exists_inside_sel && !exists_outside_sel {\n             //Changes to be made inside new module, and remove import from outside\n \n-            if let Some((use_tree_str, text_range_opt)) =\n+            if let Some((mut use_tree_str, text_range_opt)) =\n                 self.process_use_stmt_for_import_resolve(use_stmt_opt, node_syntax)\n             {\n                 if let Some(text_range) = text_range_opt {\n                     import_path_to_be_removed = Some(text_range);\n                 }\n+\n+                if source_exists_outside_sel_in_same_mod {\n+                    if let Some(first_path_in_use_tree) = use_tree_str.last() {\n+                        let first_path_in_use_tree_str = first_path_in_use_tree.to_string();\n+                        if !first_path_in_use_tree_str.contains(\"super\")\n+                            && !first_path_in_use_tree_str.contains(\"crate\")\n+                        {\n+                            let super_path = make::ext::ident_path(\"super\");\n+                            use_tree_str.push(super_path);\n+                        }\n+                    }\n+                }\n+\n                 use_tree_str_opt = Some(use_tree_str);\n             } else if source_exists_outside_sel_in_same_mod {\n                 self.make_use_stmt_of_node_with_super(node_syntax);\n@@ -558,9 +577,16 @@ impl Module {\n         if let Some(use_tree_str) = use_tree_str_opt {\n             let mut use_tree_str = use_tree_str;\n             use_tree_str.reverse();\n-            if use_tree_str[0].to_string().contains(\"super\") {\n-                let super_path = make::ext::ident_path(\"super\");\n-                use_tree_str.insert(0, super_path)\n+\n+            if !(!exists_outside_sel && exists_inside_sel && source_exists_outside_sel_in_same_mod)\n+            {\n+                if let Some(first_path_in_use_tree) = use_tree_str.first() {\n+                    let first_path_in_use_tree_str = first_path_in_use_tree.to_string();\n+                    if first_path_in_use_tree_str.contains(\"super\") {\n+                        let super_path = make::ext::ident_path(\"super\");\n+                        use_tree_str.insert(0, super_path)\n+                    }\n+                }\n             }\n \n             let use_ =\n@@ -621,6 +647,32 @@ impl Module {\n     }\n }\n \n+fn check_intersection_and_push(\n+    import_paths_to_be_removed: &mut Vec<TextRange>,\n+    import_path: TextRange,\n+) {\n+    if import_paths_to_be_removed.len() > 0 {\n+        // Text ranges recieved here for imports are extended to the\n+        // next/previous comma which can cause intersections among them\n+        // and later deletion of these can cause panics similar\n+        // to reported in #11766. So to mitigate it, we\n+        // check for intersection between all current members\n+        // and if it exists we combine both text ranges into\n+        // one\n+        let r = import_paths_to_be_removed\n+            .into_iter()\n+            .position(|it| it.intersect(import_path).is_some());\n+        match r {\n+            Some(it) => {\n+                import_paths_to_be_removed[it] = import_paths_to_be_removed[it].cover(import_path)\n+            }\n+            None => import_paths_to_be_removed.push(import_path),\n+        }\n+    } else {\n+        import_paths_to_be_removed.push(import_path);\n+    }\n+}\n+\n fn does_source_exists_outside_sel_in_same_mod(\n     def: Definition,\n     ctx: &AssistContext,\n@@ -1495,4 +1547,38 @@ mod modname {\n         \",\n         )\n     }\n+\n+    #[test]\n+    fn test_issue_11766() {\n+        //https://github.com/rust-lang/rust-analyzer/issues/11766\n+        check_assist(\n+            extract_module,\n+            r\"\n+            mod x {\n+                pub struct Foo;\n+                pub struct Bar;\n+            }\n+\n+            use x::{Bar, Foo};\n+\n+            $0type A = (Foo, Bar);$0\n+        \",\n+            r\"\n+            mod x {\n+                pub struct Foo;\n+                pub struct Bar;\n+            }\n+\n+            use x::{};\n+\n+            mod modname {\n+                use super::x::Bar;\n+\n+                use super::x::Foo;\n+\n+                pub(crate) type A = (Foo, Bar);\n+            }\n+        \",\n+        )\n+    }\n }"}]}