{"sha": "d1a83e6986470d2db81474bb7fd3eadada78b0a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxYTgzZTY5ODY0NzBkMmRiODE0NzRiYjdmZDNlYWRhZGE3OGIwYTQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-29T16:04:35Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-29T16:04:35Z"}, "message": "std: add Encoder::emit_map and Decoder::read_map", "tree": {"sha": "5dfc51c8a151176fe374735ba12fc06913a288a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dfc51c8a151176fe374735ba12fc06913a288a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1a83e6986470d2db81474bb7fd3eadada78b0a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1a83e6986470d2db81474bb7fd3eadada78b0a4", "html_url": "https://github.com/rust-lang/rust/commit/d1a83e6986470d2db81474bb7fd3eadada78b0a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1a83e6986470d2db81474bb7fd3eadada78b0a4/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed62f6dfe0c8f3b8b2769c65bb7b7bb8b3815b1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed62f6dfe0c8f3b8b2769c65bb7b7bb8b3815b1a", "html_url": "https://github.com/rust-lang/rust/commit/ed62f6dfe0c8f3b8b2769c65bb7b7bb8b3815b1a"}], "stats": {"total": 366, "additions": 263, "deletions": 103}, "files": [{"sha": "f7fe2f54c57ee766e2c499e5c92c1c75bba4bf3a", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d1a83e6986470d2db81474bb7fd3eadada78b0a4/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a83e6986470d2db81474bb7fd3eadada78b0a4/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=d1a83e6986470d2db81474bb7fd3eadada78b0a4", "patch": "@@ -402,6 +402,21 @@ pub mod reader {\n                 }\n             }\n         }\n+\n+        fn read_map<T>(&self, _f: &fn(uint) -> T) -> T {\n+            debug!(\"read_map()\");\n+            fail!(~\"read_map is unimplemented\");\n+        }\n+\n+        fn read_map_elt_key<T>(&self, idx: uint, _f: &fn() -> T) -> T {\n+            debug!(\"read_map_elt_key(idx=%u)\", idx);\n+            fail!(~\"read_map_elt_val is unimplemented\");\n+        }\n+\n+        fn read_map_elt_val<T>(&self, idx: uint, _f: &fn() -> T) -> T {\n+            debug!(\"read_map_elt_val(idx=%u)\", idx);\n+            fail!(~\"read_map_elt_val is unimplemented\");\n+        }\n     }\n }\n \n@@ -654,6 +669,18 @@ pub mod writer {\n         fn emit_option_some(&self, f: &fn()) {\n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n+\n+        fn emit_map(&self, _len: uint, _f: &fn()) {\n+            fail!(~\"emit_map is unimplemented\");\n+        }\n+\n+        fn emit_map_elt_key(&self, _idx: uint, _f: &fn()) {\n+            fail!(~\"emit_map_elt_key is unimplemented\");\n+        }\n+\n+        fn emit_map_elt_val(&self, _idx: uint, _f: &fn()) {\n+            fail!(~\"emit_map_elt_val is unimplemented\");\n+        }\n     }\n }\n "}, {"sha": "f042e2226cd4b0b244400006f4f0a83029e591e0", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1a83e6986470d2db81474bb7fd3eadada78b0a4/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a83e6986470d2db81474bb7fd3eadada78b0a4/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=d1a83e6986470d2db81474bb7fd3eadada78b0a4", "patch": "@@ -466,8 +466,8 @@ pub mod flatteners {\n         fn from_writer(w: @Writer) -> Self;\n     }\n \n-    impl<'self> FromReader for json::Decoder<'self> {\n-        fn from_reader(r: @Reader) -> json::Decoder<'self> {\n+    impl FromReader for json::Decoder {\n+        fn from_reader(r: @Reader) -> json::Decoder {\n             match json::from_reader(r) {\n                 Ok(json) => {\n                     json::Decoder(json)"}, {"sha": "f069547bc8c3d070f1cde6beed3be11b971b5f6f", "filename": "src/libstd/json.rs", "status": "modified", "additions": 136, "deletions": 85, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/d1a83e6986470d2db81474bb7fd3eadada78b0a4/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a83e6986470d2db81474bb7fd3eadada78b0a4/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=d1a83e6986470d2db81474bb7fd3eadada78b0a4", "patch": "@@ -156,6 +156,22 @@ impl serialize::Encoder for Encoder {\n     fn emit_option(&self, f: &fn()) { f(); }\n     fn emit_option_none(&self) { self.emit_nil(); }\n     fn emit_option_some(&self, f: &fn()) { f(); }\n+\n+    fn emit_map(&self, _len: uint, f: &fn()) {\n+        self.wr.write_char('{');\n+        f();\n+        self.wr.write_char('}');\n+    }\n+\n+    fn emit_map_elt_key(&self, idx: uint, f: &fn()) {\n+        if idx != 0 { self.wr.write_char(','); }\n+        f()\n+    }\n+\n+    fn emit_map_elt_val(&self, _idx: uint, f: &fn()) {\n+        self.wr.write_char(':');\n+        f()\n+    }\n }\n \n pub struct PrettyEncoder {\n@@ -276,6 +292,34 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_option(&self, f: &fn()) { f(); }\n     fn emit_option_none(&self) { self.emit_nil(); }\n     fn emit_option_some(&self, f: &fn()) { f(); }\n+\n+    fn emit_map(&self, len: uint, f: &fn()) {\n+        if len == 0 {\n+            self.wr.write_str(\"{}\");\n+        } else {\n+            self.wr.write_char('{');\n+            self.indent += 2;\n+            f();\n+            self.wr.write_char('\\n');\n+            self.indent -= 2;\n+            self.wr.write_str(spaces(self.indent));\n+            self.wr.write_char('}');\n+        }\n+    }\n+    fn emit_map_elt_key(&self, idx: uint, f: &fn()) {\n+        if idx == 0 {\n+            self.wr.write_char('\\n');\n+        } else {\n+            self.wr.write_str(\",\\n\");\n+        }\n+        self.wr.write_str(spaces(self.indent));\n+        f();\n+    }\n+\n+    fn emit_map_elt_val(&self, _idx: uint, f: &fn()) {\n+        self.wr.write_str(\": \");\n+        f();\n+    }\n }\n \n impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n@@ -285,17 +329,7 @@ impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n             String(ref v) => v.encode(e),\n             Boolean(v) => v.encode(e),\n             List(ref v) => v.encode(e),\n-            Object(ref v) => {\n-                do e.emit_struct(\"Object\", v.len())|| {\n-                    let mut idx = 0;\n-                    for v.each |&(key, value)| {\n-                        do e.emit_field(*key, idx) {\n-                            value.encode(e);\n-                        }\n-                        idx += 1;\n-                    }\n-                }\n-            },\n+            Object(ref v) => v.encode(e),\n             Null => e.emit_nil(),\n         }\n     }\n@@ -702,37 +736,20 @@ pub fn from_str(s: &str) -> Result<Json, Error> {\n     }\n }\n \n-pub struct Decoder<'self> {\n-    priv json: Json,\n-    priv mut stack: ~[&'self Json],\n+pub struct Decoder {\n+    priv mut stack: ~[Json],\n }\n \n pub fn Decoder(json: Json) -> Decoder {\n-    Decoder { json: json, stack: ~[] }\n-}\n-\n-priv impl<'self> Decoder<'self> {\n-    fn peek(&self) -> &'self Json {\n-        if vec::uniq_len(&const self.stack) == 0 {\n-            self.stack.push(&self.json);\n-        }\n-        self.stack[vec::uniq_len(&const self.stack) - 1]\n-    }\n-\n-    fn pop(&self) -> &'self Json {\n-        if vec::uniq_len(&const self.stack) == 0 {\n-            self.stack.push(&self.json);\n-        }\n-        self.stack.pop()\n-    }\n+    Decoder { stack: ~[json] }\n }\n \n-impl<'self> serialize::Decoder for Decoder<'self> {\n+impl serialize::Decoder for Decoder {\n     fn read_nil(&self) -> () {\n         debug!(\"read_nil\");\n-        match *self.pop() {\n+        match self.stack.pop() {\n             Null => (),\n-            _ => fail!(~\"not a null\")\n+            value => fail!(fmt!(\"not a null: %?\", value))\n         }\n     }\n \n@@ -750,19 +767,19 @@ impl<'self> serialize::Decoder for Decoder<'self> {\n \n     fn read_bool(&self) -> bool {\n         debug!(\"read_bool\");\n-        match *self.pop() {\n+        match self.stack.pop() {\n             Boolean(b) => b,\n-            _ => fail!(~\"not a boolean\")\n+            value => fail!(fmt!(\"not a boolean: %?\", value))\n         }\n     }\n \n     fn read_f64(&self) -> f64 { self.read_float() as f64 }\n     fn read_f32(&self) -> f32 { self.read_float() as f32 }\n     fn read_float(&self) -> float {\n         debug!(\"read_float\");\n-        match *self.pop() {\n+        match self.stack.pop() {\n             Number(f) => f,\n-            _ => fail!(~\"not a number\")\n+            value => fail!(fmt!(\"not a number: %?\", value))\n         }\n     }\n \n@@ -775,13 +792,12 @@ impl<'self> serialize::Decoder for Decoder<'self> {\n \n     fn read_str(&self) -> ~str {\n         debug!(\"read_str\");\n-        match *self.pop() {\n-            String(ref s) => copy *s,\n-            ref json => fail!(fmt!(\"not a string: %?\", *json))\n+        match self.stack.pop() {\n+            String(s) => s,\n+            json => fail!(fmt!(\"not a string: %?\", json))\n         }\n     }\n \n-\n     fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T {\n         debug!(\"read_enum(%s)\", name);\n         f()\n@@ -790,9 +806,9 @@ impl<'self> serialize::Decoder for Decoder<'self> {\n     #[cfg(stage0)]\n     fn read_enum_variant<T>(&self, f: &fn(uint) -> T) -> T {\n         debug!(\"read_enum_variant()\");\n-        let idx = match *self.peek() {\n-            Null => 0,\n-            _ => 1,\n+        let idx = match self.stack.pop() {\n+            Null => { self.stack.push(Null); 0 },\n+            value => { self.stack.push(value); 1 },\n         };\n         f(idx)\n     }\n@@ -802,12 +818,20 @@ impl<'self> serialize::Decoder for Decoder<'self> {\n     #[cfg(stage3)]\n     fn read_enum_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T {\n         debug!(\"read_enum_variant(names=%?)\", names);\n-        let name = match *self.peek() {\n-            String(ref s) => s,\n-            List([String(ref s), .. _]) => s,\n+        let name = match self.stack.pop() {\n+            String(s) => s,\n+            List(list) => {\n+                do vec::consume_reverse(list) |_i, v| {\n+                    self.stack.push(v);\n+                }\n+                match self.stack.pop() {\n+                    String(s) => s,\n+                    value => fail!(fmt!(\"invalid variant name: %?\", value)),\n+                }\n+            }\n             ref json => fail!(fmt!(\"invalid variant: %?\", *json)),\n         };\n-        let idx = match vec::position(names, |n| str::eq_slice(*n, *name)) {\n+        let idx = match vec::position(names, |n| str::eq_slice(*n, name)) {\n             Some(idx) => idx,\n             None => fail!(fmt!(\"Unknown variant name: %?\", name)),\n         };\n@@ -816,73 +840,90 @@ impl<'self> serialize::Decoder for Decoder<'self> {\n \n     fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n-        match *self.peek() {\n-            List(ref list) => {\n-                self.stack.push(&list[idx + 1]);\n-                f()\n-            }\n-            ref json => fail!(fmt!(\"not a list: %?\", json)),\n-        }\n+        f()\n     }\n \n     fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n         debug!(\"read_seq()\");\n-        let len = match *self.peek() {\n-            List(ref list) => list.len(),\n+        let len = match self.stack.pop() {\n+            List(list) => {\n+                let len = list.len();\n+                do vec::consume_reverse(list) |_i, v| {\n+                    self.stack.push(v);\n+                }\n+                len\n+            }\n             _ => fail!(~\"not a list\"),\n         };\n         let res = f(len);\n-        self.pop();\n+        self.stack.pop();\n         res\n     }\n \n     fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_seq_elt(idx=%u)\", idx);\n-        match *self.peek() {\n-            List(ref list) => {\n-                self.stack.push(&list[idx]);\n-                f()\n-            }\n-            _ => fail!(~\"not a list\"),\n-        }\n+        f()\n     }\n \n-    fn read_struct<T>(&self, _name: &str, _len: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_struct()\");\n+    fn read_struct<T>(&self, name: &str, len: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_struct(name=%s, len=%u)\", name, len);\n         let value = f();\n-        self.pop();\n+        self.stack.pop();\n         value\n     }\n \n     fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_field(%s, idx=%u)\", name, idx);\n-        let top = self.peek();\n-        match *top {\n-            Object(ref obj) => {\n-                match obj.find(&name.to_owned()) {\n+        match self.stack.pop() {\n+            Object(obj) => {\n+                let mut obj = obj;\n+                let value = match obj.pop(&name.to_owned()) {\n                     None => fail!(fmt!(\"no such field: %s\", name)),\n                     Some(json) => {\n                         self.stack.push(json);\n                         f()\n                     }\n-                }\n+                };\n+                self.stack.push(Object(obj));\n+                value\n             }\n-            Number(_) => fail!(~\"num\"),\n-            String(_) => fail!(~\"str\"),\n-            Boolean(_) => fail!(~\"bool\"),\n-            List(_) => fail!(fmt!(\"list: %?\", top)),\n-            Null => fail!(~\"null\"),\n-\n-            //_ => fail!(fmt!(\"not an object: %?\", *top))\n+            value => fail!(fmt!(\"not an object: %?\", value))\n         }\n     }\n \n     fn read_option<T>(&self, f: &fn(bool) -> T) -> T {\n-        match *self.peek() {\n-            Null => { self.pop(); f(false) }\n-            _ => f(true),\n+        match self.stack.pop() {\n+            Null => f(false),\n+            value => { self.stack.push(value); f(true) }\n         }\n     }\n+\n+    fn read_map<T>(&self, f: &fn(uint) -> T) -> T {\n+        debug!(\"read_map()\");\n+        let len = match self.stack.pop() {\n+            Object(obj) => {\n+                let mut obj = obj;\n+                let len = obj.len();\n+                do obj.consume |key, value| {\n+                    self.stack.push(value);\n+                    self.stack.push(String(key));\n+                }\n+                len\n+            }\n+            json => fail!(fmt!(\"not an object: %?\", json)),\n+        };\n+        f(len)\n+    }\n+\n+    fn read_map_elt_key<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_map_elt_key(idx=%u)\", idx);\n+        f()\n+    }\n+\n+    fn read_map_elt_val<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_map_elt_val(idx=%u)\", idx);\n+        f()\n+    }\n }\n \n impl Eq for Json {\n@@ -1251,7 +1292,7 @@ mod tests {\n \n     #[test]\n     fn test_write_object_pretty() {\n-        assert_eq!(to_pretty_str(&mk_object(~[])), ~\"{\\n}\");\n+        assert_eq!(to_pretty_str(&mk_object(~[])), ~\"{}\");\n         assert_eq!(\n             to_pretty_str(&mk_object(~[(~\"a\", Boolean(true))])),\n             ~\"\\\n@@ -1630,6 +1671,16 @@ mod tests {\n         assert_eq!(value, Frog(~\"Henry\", 349));\n     }\n \n+    #[test]\n+    fn test_read_map() {\n+        let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": [\\\"Frog\\\", \\\"Henry\\\", 349]}\";\n+        let decoder = Decoder(from_str(s).unwrap());\n+        let map: LinearMap<~str, Animal> = Decodable::decode(&decoder);\n+\n+        assert_eq!(map.find(&~\"a\"), Some(Dog));\n+        assert_eq!(map.find(&~\"b\"), Some(Frog(~\"Henry\", 349)));\n+    }\n+\n     #[test]\n     fn test_multiline_errors() {\n         assert_eq!(from_str(~\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),"}, {"sha": "dd487218fe550fa0e208d5087b274135d648b012", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d1a83e6986470d2db81474bb7fd3eadada78b0a4/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a83e6986470d2db81474bb7fd3eadada78b0a4/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=d1a83e6986470d2db81474bb7fd3eadada78b0a4", "patch": "@@ -16,9 +16,8 @@ Core encoding and decoding interfaces.\n \n #[forbid(non_camel_case_types)];\n \n-use core::at_vec;\n use core::prelude::*;\n-use core::vec;\n+use core::hashmap::linear::LinearMap;\n \n pub trait Encoder {\n     // Primitive types:\n@@ -56,6 +55,10 @@ pub trait Encoder {\n     fn emit_option(&self, f: &fn());\n     fn emit_option_none(&self);\n     fn emit_option_some(&self, f: &fn());\n+\n+    fn emit_map(&self, len: uint, f: &fn());\n+    fn emit_map_elt_key(&self, idx: uint, f: &fn());\n+    fn emit_map_elt_val(&self, idx: uint, f: &fn());\n }\n \n pub trait Decoder {\n@@ -96,6 +99,10 @@ pub trait Decoder {\n \n     // Specialized types:\n     fn read_option<T>(&self, f: &fn(bool) -> T) -> T;\n+\n+    fn read_map<T>(&self, f: &fn(uint) -> T) -> T;\n+    fn read_map_elt_key<T>(&self, idx: uint, f: &fn() -> T) -> T;\n+    fn read_map_elt_val<T>(&self, idx: uint, f: &fn() -> T) -> T;\n }\n \n pub trait Encodable<S:Encoder> {\n@@ -529,6 +536,58 @@ impl<\n     }\n }\n \n+impl<\n+    E: Encoder,\n+    K: Encodable<E> + Hash + IterBytes + Eq,\n+    V: Encodable<E>\n+> Encodable<E> for LinearMap<K, V> {\n+    fn encode(&self, e: &E) {\n+        do e.emit_map(self.len()) {\n+            let mut i = 0;\n+            for self.each |&(key, val)| {\n+                e.emit_map_elt_key(i, || key.encode(e));\n+                e.emit_map_elt_val(i, || val.encode(e));\n+                i += 1;\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    K: Decodable<D> + Hash + IterBytes + Eq,\n+    V: Decodable<D>\n+> Decodable<D> for LinearMap<K, V> {\n+    #[cfg(stage0)]\n+    fn decode(d: &D) -> LinearMap<K, V> {\n+        do d.read_map |len| {\n+            let mut map = LinearMap::new();\n+            map.reserve_at_least(len);\n+            for uint::range(0, len) |i| {\n+                let key = d.read_map_elt_key(i, || Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, || Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        }\n+    }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn decode(d: &D) -> LinearMap<K, V> {\n+        do d.read_map |len| {\n+            let mut map = LinearMap::with_capacity(len);\n+            for uint::range(0, len) |i| {\n+                let key = d.read_map_elt_key(i, || Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, || Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        }\n+    }\n+}\n+\n // ___________________________________________________________________________\n // Helper routines\n //"}, {"sha": "90f10ea50541dd8631dbfe26e2398284c00e77e4", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d1a83e6986470d2db81474bb7fd3eadada78b0a4/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a83e6986470d2db81474bb7fd3eadada78b0a4/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=d1a83e6986470d2db81474bb7fd3eadada78b0a4", "patch": "@@ -137,7 +137,11 @@ pub impl WorkKey {\n     }\n }\n \n-type WorkMap = LinearMap<WorkKey, ~str>;\n+struct WorkMap(LinearMap<WorkKey, ~str>);\n+\n+impl WorkMap {\n+    fn new() -> WorkMap { WorkMap(LinearMap::new()) }\n+}\n \n impl<S:Encoder> Encodable<S> for WorkMap {\n     fn encode(&self, s: &S) {\n@@ -153,7 +157,7 @@ impl<S:Encoder> Encodable<S> for WorkMap {\n impl<D:Decoder> Decodable<D> for WorkMap {\n     fn decode(d: &D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n-        let mut w = LinearMap::new();\n+        let mut w = WorkMap::new();\n         for v.each |&(k, v)| {\n             w.insert(copy k, copy v);\n         }\n@@ -235,7 +239,7 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n }\n \n // FIXME(#5121)\n-fn json_decode<T:Decodable<json::Decoder<'static>>>(s: &str) -> T {\n+fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     do io::with_str_reader(s) |rdr| {\n         let j = result::unwrap(json::from_reader(rdr));\n         Decodable::decode(&json::Decoder(j))\n@@ -260,18 +264,25 @@ pub impl Context {\n     fn new(db: @Mut<Database>,\n                   lg: @Mut<Logger>,\n                   cfg: @json::Object) -> Context {\n-        Context{db: db, logger: lg, cfg: cfg, freshness: LinearMap::new()}\n+        Context {\n+            db: db,\n+            logger: lg,\n+            cfg: cfg,\n+            freshness: LinearMap::new()\n+        }\n     }\n \n     fn prep<T:Owned +\n               Encodable<json::Encoder> +\n-              Decodable<json::Decoder<'static>>>( // FIXME(#5121)\n+              Decodable<json::Decoder>>( // FIXME(#5121)\n                   @self,\n                   fn_name:&str,\n                   blk: &fn(@Mut<Prep>)->Work<T>) -> Work<T> {\n-        let p = @Mut(Prep {ctxt: self,\n-                           fn_name: fn_name.to_owned(),\n-                           declared_inputs: LinearMap::new()});\n+        let p = @Mut(Prep {\n+            ctxt: self,\n+            fn_name: fn_name.to_owned(),\n+            declared_inputs: WorkMap::new()\n+        });\n         blk(p)\n     }\n }\n@@ -283,7 +294,7 @@ trait TPrep {\n     fn all_fresh(&self, cat:&str, map:&WorkMap) -> bool;\n     fn exec<T:Owned +\n               Encodable<json::Encoder> +\n-              Decodable<json::Decoder<'static>>>( // FIXME(#5121)\n+              Decodable<json::Decoder>>( // FIXME(#5121)\n         &self, blk: ~fn(&Exec) -> T) -> Work<T>;\n }\n \n@@ -324,7 +335,7 @@ impl TPrep for @Mut<Prep> {\n \n     fn exec<T:Owned +\n               Encodable<json::Encoder> +\n-              Decodable<json::Decoder<'static>>>( // FIXME(#5121)\n+              Decodable<json::Decoder>>( // FIXME(#5121)\n             &self, blk: ~fn(&Exec) -> T) -> Work<T> {\n         let mut bo = Some(blk);\n \n@@ -349,8 +360,10 @@ impl TPrep for @Mut<Prep> {\n                     let blk = blk.unwrap();\n                     let chan = Cell(chan);\n                     do task::spawn || {\n-                        let exe = Exec{discovered_inputs: LinearMap::new(),\n-                                       discovered_outputs: LinearMap::new()};\n+                        let exe = Exec {\n+                            discovered_inputs: WorkMap::new(),\n+                            discovered_outputs: WorkMap::new(),\n+                        };\n                         let chan = chan.take();\n                         let v = blk(&exe);\n                         send_one(chan, (exe, v));\n@@ -365,7 +378,7 @@ impl TPrep for @Mut<Prep> {\n \n pub impl<T:Owned +\n          Encodable<json::Encoder> +\n-         Decodable<json::Decoder<'static>>> Work<T> { // FIXME(#5121)\n+         Decodable<json::Decoder>> Work<T> { // FIXME(#5121)\n     fn new(p: @Mut<Prep>, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n         Work { prep: p, res: Some(e) }\n     }\n@@ -374,7 +387,7 @@ pub impl<T:Owned +\n // FIXME (#3724): movable self. This should be in impl Work.\n fn unwrap<T:Owned +\n             Encodable<json::Encoder> +\n-            Decodable<json::Decoder<'static>>>( // FIXME(#5121)\n+            Decodable<json::Decoder>>( // FIXME(#5121)\n         w: Work<T>) -> T {\n     let mut ww = w;\n     let mut s = None;"}, {"sha": "de01d25844924cb4572a0f7688f427296061681d", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1a83e6986470d2db81474bb7fd3eadada78b0a4/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1a83e6986470d2db81474bb7fd3eadada78b0a4/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=d1a83e6986470d2db81474bb7fd3eadada78b0a4", "patch": "@@ -1280,6 +1280,16 @@ mod test {\n             self.add_to_log(CallToEmitOptionSome);\n             f();\n         }\n+\n+        fn read_map<T>(&self, f: &fn(uint) -> T) -> T {\n+            self.add_unknown_to_log(); f(0);\n+        }\n+        fn read_map_elt_key<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+            self.add_unknown_to_log(); f();\n+        }\n+        fn read_map_elt_val<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+            self.add_unknown_to_log(); f();\n+        }\n     }\n \n "}]}