{"sha": "4e4f0417aa190bec347c53a147ca1cd134a832f6", "node_id": "C_kwDOAAsO6NoAKDRlNGYwNDE3YWExOTBiZWMzNDdjNTNhMTQ3Y2ExY2QxMzRhODMyZjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-03T21:57:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-03T21:57:24Z"}, "message": "Auto merge of #112244 - RalfJung:miri, r=oli-obk\n\nupdate Miri\n\nAlso adjust Miri's compiletest a little: in pre-subtree days we added `-A unused -Astable-features` to have the Miri toolstate break less often. But nowadays it just causes confusion when Miri CI works in rustc but fails on the Miri side so let's get rid of this difference.\n\nr? `@oli-obk`", "tree": {"sha": "bb49f98231c4b739795c1f542f27944cab9189ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb49f98231c4b739795c1f542f27944cab9189ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e4f0417aa190bec347c53a147ca1cd134a832f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e4f0417aa190bec347c53a147ca1cd134a832f6", "html_url": "https://github.com/rust-lang/rust/commit/4e4f0417aa190bec347c53a147ca1cd134a832f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e4f0417aa190bec347c53a147ca1cd134a832f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "398fa2187c88de46c13c142f600064483a563c86", "url": "https://api.github.com/repos/rust-lang/rust/commits/398fa2187c88de46c13c142f600064483a563c86", "html_url": "https://github.com/rust-lang/rust/commit/398fa2187c88de46c13c142f600064483a563c86"}, {"sha": "ca720fdfee83c7b63ee5acb29b6b5b07a493e236", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca720fdfee83c7b63ee5acb29b6b5b07a493e236", "html_url": "https://github.com/rust-lang/rust/commit/ca720fdfee83c7b63ee5acb29b6b5b07a493e236"}], "stats": {"total": 326, "additions": 218, "deletions": 108}, "files": [{"sha": "a8aae524e7101fd35a214c48329c55a65f865737", "filename": "src/tools/miri/ci.sh", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Fci.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Fci.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fci.sh?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -17,11 +17,11 @@ begingroup \"Building Miri\"\n echo \"Installing release version of Miri\"\n export RUSTFLAGS=\"-D warnings\"\n export CARGO_INCREMENTAL=0\n-./miri install # implicitly locked\n+export CARGO_EXTRA_FLAGS=\"--locked\"\n+./miri install\n \n # Prepare debug build for direct `./miri` invocations\n echo \"Building debug version of Miri\"\n-export CARGO_EXTRA_FLAGS=\"--locked\"\n ./miri check --no-default-features # make sure this can be built\n ./miri check --all-features # and this, too\n ./miri build --all-targets # the build that all the `./miri test` below will use\n@@ -39,8 +39,11 @@ function run_tests {\n   ## ui test suite\n   ./miri test\n   if [ -z \"${MIRI_TEST_TARGET+exists}\" ]; then\n-    # Only for host architecture: tests with optimizations (`-O` is what cargo passes, but crank MIR\n-    # optimizations up all the way, too).\n+    # Host-only tests: running these on all targets is unlikely to catch more problems and would\n+    # cost a lot of CI time.\n+\n+    # Tests with optimizations (`-O` is what cargo passes, but crank MIR optimizations up all the\n+    # way, too).\n     # Optimizations change diagnostics (mostly backtraces), so we don't check\n     # them. Also error locations change so we don't run the failing tests.\n     # We explicitly enable debug-assertions here, they are disabled by -O but we have tests\n@@ -51,6 +54,9 @@ function run_tests {\n     for FILE in tests/many-seeds/*.rs; do\n       MIRI_SEEDS=64 CARGO_EXTRA_FLAGS=\"$CARGO_EXTRA_FLAGS -q\" ./miri many-seeds ./miri run \"$FILE\"\n     done\n+\n+    # Check that the benchmarks build and run, but without actually benchmarking.\n+    HYPERFINE=\"bash -c\" ./miri bench\n   fi\n \n   ## test-cargo-miri\n@@ -75,13 +81,6 @@ function run_tests {\n   unset RUSTC MIRI\n   rm -rf .cargo\n \n-  # Ensure that our benchmarks all work, but only on Linux hosts.\n-  if [ -z \"${MIRI_TEST_TARGET+exists}\" ] && [ \"$HOST_TARGET\" = x86_64-unknown-linux-gnu ] ; then\n-    for BENCH in $(ls \"bench-cargo-miri\"); do\n-      cargo miri run --manifest-path bench-cargo-miri/$BENCH/Cargo.toml\n-    done\n-  fi\n-\n   endgroup\n }\n "}, {"sha": "7cda995879cfbdb9d1490afcc67a3738d65f6c09", "filename": "src/tools/miri/miri", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Fmiri", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Fmiri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fmiri?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -77,7 +77,7 @@ if [ -z \"$COMMAND\" ]; then\n fi\n shift\n # macOS does not have a useful readlink/realpath so we have to use Python instead...\n-MIRIDIR=$(python3 -c 'import os, sys; print(os.path.dirname(os.path.realpath(sys.argv[1])))' \"$0\")\n+MIRIDIR=$(python3 -c 'import pathlib, sys; print(pathlib.Path(sys.argv[1]).resolve().parent.as_posix())' \"$0\")\n # Used for rustc syncs.\n JOSH_FILTER=\":rev(75dd959a3a40eb5b4574f8d2e23aa6efbeb33573:prefix=src/tools/miri):/src/tools/miri\"\n # Needed for `./miri bench`.\n@@ -184,6 +184,8 @@ many-seeds)\n     exit 0\n     ;;\n bench)\n+    # The hyperfine to use\n+    HYPERFINE=${HYPERFINE:-hyperfine -w 1 -m 5 --shell=none}\n     # Make sure we have an up-to-date Miri installed\n     \"$0\" install\n     # Run the requested benchmarks\n@@ -193,7 +195,7 @@ bench)\n         BENCHES=(\"$@\")\n     fi\n     for BENCH in \"${BENCHES[@]}\"; do\n-        hyperfine -w 1 -m 5 --shell=none \"cargo +$TOOLCHAIN miri run --manifest-path $MIRIDIR/bench-cargo-miri/$BENCH/Cargo.toml\"\n+        $HYPERFINE \"cargo +$TOOLCHAIN miri run --manifest-path $MIRIDIR/bench-cargo-miri/$BENCH/Cargo.toml\"\n     done\n     exit 0\n     ;;\n@@ -280,10 +282,9 @@ find_sysroot() {\n # Run command.\n case \"$COMMAND\" in\n install)\n-    # \"--locked\" to respect the Cargo.lock file if it exists.\n     # Install binaries to the miri toolchain's sysroot so they do not interact with other toolchains.\n-    $CARGO install $CARGO_EXTRA_FLAGS --path \"$MIRIDIR\" --force --locked --root \"$SYSROOT\" \"$@\"\n-    $CARGO install $CARGO_EXTRA_FLAGS --path \"$MIRIDIR\"/cargo-miri --force --locked --root \"$SYSROOT\" \"$@\"\n+    $CARGO install $CARGO_EXTRA_FLAGS --path \"$MIRIDIR\" --force --root \"$SYSROOT\" \"$@\"\n+    $CARGO install $CARGO_EXTRA_FLAGS --path \"$MIRIDIR\"/cargo-miri --force --root \"$SYSROOT\" \"$@\"\n     ;;\n check)\n     # Check, and let caller control flags."}, {"sha": "ee815ae6f8fc07181b09d47a116beecefea3cab5", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -1 +1 @@\n-8b4b20836b832e91aa605a2faf5e2a55190202c8\n+33c3d101280c8eb3cd8af421bfb56a8afcc3881d"}, {"sha": "cea2cffa913badf8ebbefaad5bf2873fad87041b", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -92,7 +92,7 @@ impl HistoryData {\n         {\n             // NOTE: `transition_range` is explicitly absent from the error message, it has no significance\n             // to the user. The meaningful one is `access_range`.\n-            self.events.push((Some(span.data()), format!(\"{this} then transitioned {transition} due to a {rel} {access_kind} at offsets {access_range:?}\", rel = if is_foreign { \"foreign\" } else { \"child\" })));\n+            self.events.push((Some(span.data()), format!(\"{this} later transitioned to {endpoint} due to a {rel} {access_kind} at offsets {access_range:?}\", endpoint = transition.endpoint(), rel = if is_foreign { \"foreign\" } else { \"child\" })));\n             self.events.push((None, format!(\"this corresponds to {}\", transition.summary())));\n         }\n     }\n@@ -212,12 +212,13 @@ impl History {\n \n     /// Reconstruct the history relevant to `error_offset` by filtering\n     /// only events whose range contains the offset we are interested in.\n-    fn extract_relevant(&self, error_offset: u64) -> Self {\n+    fn extract_relevant(&self, error_offset: u64, error_kind: TransitionError) -> Self {\n         History {\n             events: self\n                 .events\n                 .iter()\n                 .filter(|e| e.transition_range.contains(&error_offset))\n+                .filter(|e| e.transition.is_relevant(error_kind))\n                 .cloned()\n                 .collect::<Vec<_>>(),\n             created: self.created,\n@@ -303,7 +304,7 @@ impl TbError<'_> {\n             history.extend(self.accessed_info.history.forget(), \"accessed\", false);\n         }\n         history.extend(\n-            self.conflicting_info.history.extract_relevant(self.error_offset),\n+            self.conflicting_info.history.extract_relevant(self.error_offset, self.error_kind),\n             conflicting_tag_name,\n             true,\n         );"}, {"sha": "6b1e722b65e670038c1fbf121b5d959856edf98b", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/perms.rs", "status": "modified", "additions": 147, "deletions": 36, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -1,6 +1,7 @@\n use std::cmp::{Ordering, PartialOrd};\n use std::fmt;\n \n+use crate::borrow_tracker::tree_borrows::diagnostics::TransitionError;\n use crate::borrow_tracker::tree_borrows::tree::AccessRelatedness;\n use crate::borrow_tracker::AccessKind;\n \n@@ -115,26 +116,31 @@ mod transition {\n /// Public interface to the state machine that controls read-write permissions.\n /// This is the \"private `enum`\" pattern.\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub struct Permission(PermissionPriv);\n+pub struct Permission {\n+    inner: PermissionPriv,\n+}\n \n /// Transition from one permission to the next.\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub struct PermTransition(PermissionPriv, PermissionPriv);\n+pub struct PermTransition {\n+    from: PermissionPriv,\n+    to: PermissionPriv,\n+}\n \n impl Permission {\n     /// Default initial permission of the root of a new tree.\n     pub fn new_root() -> Self {\n-        Self(Active)\n+        Self { inner: Active }\n     }\n \n     /// Default initial permission of a reborrowed mutable reference.\n     pub fn new_unique_2phase(ty_is_freeze: bool) -> Self {\n-        Self(Reserved { ty_is_freeze })\n+        Self { inner: Reserved { ty_is_freeze } }\n     }\n \n     /// Default initial permission of a reborrowed shared reference\n     pub fn new_frozen() -> Self {\n-        Self(Frozen)\n+        Self { inner: Frozen }\n     }\n \n     /// Apply the transition to the inner PermissionPriv.\n@@ -144,9 +150,9 @@ impl Permission {\n         old_perm: Self,\n         protected: bool,\n     ) -> Option<PermTransition> {\n-        let old_state = old_perm.0;\n+        let old_state = old_perm.inner;\n         transition::perform_access(kind, rel_pos, old_state, protected)\n-            .map(|new_state| PermTransition(old_state, new_state))\n+            .map(|new_state| PermTransition { from: old_state, to: new_state })\n     }\n }\n \n@@ -155,26 +161,27 @@ impl PermTransition {\n     /// should be possible, but the same is not guaranteed by construction of\n     /// transitions inferred by diagnostics. This checks that a transition\n     /// reconstructed by diagnostics is indeed one that could happen.\n-    fn is_possible(old: PermissionPriv, new: PermissionPriv) -> bool {\n-        old <= new\n+    fn is_possible(self) -> bool {\n+        self.from <= self.to\n     }\n \n-    pub fn from(old: Permission, new: Permission) -> Option<Self> {\n-        Self::is_possible(old.0, new.0).then_some(Self(old.0, new.0))\n+    pub fn from(from: Permission, to: Permission) -> Option<Self> {\n+        let t = Self { from: from.inner, to: to.inner };\n+        t.is_possible().then_some(t)\n     }\n \n     pub fn is_noop(self) -> bool {\n-        self.0 == self.1\n+        self.from == self.to\n     }\n \n     /// Extract result of a transition (checks that the starting point matches).\n     pub fn applied(self, starting_point: Permission) -> Option<Permission> {\n-        (starting_point.0 == self.0).then_some(Permission(self.1))\n+        (starting_point.inner == self.from).then_some(Permission { inner: self.to })\n     }\n \n     /// Extract starting point of a transition\n     pub fn started(self) -> Permission {\n-        Permission(self.0)\n+        Permission { inner: self.from }\n     }\n \n     /// Determines whether a transition that occured is compatible with the presence\n@@ -190,10 +197,9 @@ impl PermTransition {\n     /// };\n     /// ```\n     pub fn is_allowed_by_protector(&self) -> bool {\n-        let &Self(old, new) = self;\n-        assert!(Self::is_possible(old, new));\n-        match (old, new) {\n-            _ if old == new => true,\n+        assert!(self.is_possible());\n+        match (self.from, self.to) {\n+            _ if self.from == self.to => true,\n             // It is always a protector violation to not be readable anymore\n             (_, Disabled) => false,\n             // In the case of a `Reserved` under a protector, both transitions\n@@ -204,16 +210,9 @@ impl PermTransition {\n             (Reserved { .. }, Active) | (Reserved { .. }, Frozen) => true,\n             // This pointer should have stayed writeable for the whole function\n             (Active, Frozen) => false,\n-            _ => unreachable!(\"Transition from {old:?} to {new:?} should never be possible\"),\n+            _ => unreachable!(\"Transition {} should never be possible\", self),\n         }\n     }\n-\n-    /// Composition function: get the transition that can be added after `app` to\n-    /// produce `self`.\n-    pub fn apply_start(self, app: Self) -> Option<Self> {\n-        let new_start = app.applied(Permission(self.0))?;\n-        Self::from(new_start, Permission(self.1))\n-    }\n }\n \n pub mod diagnostics {\n@@ -224,24 +223,24 @@ pub mod diagnostics {\n                 f,\n                 \"{}\",\n                 match self {\n-                    PermissionPriv::Reserved { .. } => \"Reserved\",\n-                    PermissionPriv::Active => \"Active\",\n-                    PermissionPriv::Frozen => \"Frozen\",\n-                    PermissionPriv::Disabled => \"Disabled\",\n+                    Reserved { .. } => \"Reserved\",\n+                    Active => \"Active\",\n+                    Frozen => \"Frozen\",\n+                    Disabled => \"Disabled\",\n                 }\n             )\n         }\n     }\n \n     impl fmt::Display for PermTransition {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            write!(f, \"from {} to {}\", self.0, self.1)\n+            write!(f, \"from {} to {}\", self.from, self.to)\n         }\n     }\n \n     impl fmt::Display for Permission {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            write!(f, \"{}\", self.0)\n+            write!(f, \"{}\", self.inner)\n         }\n     }\n \n@@ -251,7 +250,7 @@ pub mod diagnostics {\n             // Make sure there are all of the same length as each other\n             // and also as `diagnostics::DisplayFmtPermission.uninit` otherwise\n             // alignment will be incorrect.\n-            match self.0 {\n+            match self.inner {\n                 Reserved { ty_is_freeze: true } => \"Res\",\n                 Reserved { ty_is_freeze: false } => \"Re*\",\n                 Active => \"Act\",\n@@ -269,16 +268,128 @@ pub mod diagnostics {\n         /// to have write permissions, because that's what the diagnostics care about\n         /// (otherwise `Reserved -> Frozen` would be considered a noop).\n         pub fn summary(&self) -> &'static str {\n-            assert!(Self::is_possible(self.0, self.1));\n-            match (self.0, self.1) {\n-                (_, Active) => \"an activation\",\n+            assert!(self.is_possible());\n+            match (self.from, self.to) {\n+                (_, Active) => \"the first write to a 2-phase borrowed mutable reference\",\n                 (_, Frozen) => \"a loss of write permissions\",\n                 (Frozen, Disabled) => \"a loss of read permissions\",\n                 (_, Disabled) => \"a loss of read and write permissions\",\n                 (old, new) =>\n                     unreachable!(\"Transition from {old:?} to {new:?} should never be possible\"),\n             }\n         }\n+\n+        /// Determines whether `self` is a relevant transition for the error `err`.\n+        /// `self` will be a transition that happened to a tag some time before\n+        /// that tag caused the error.\n+        ///\n+        /// Irrelevant events:\n+        /// - modifications of write permissions when the error is related to read permissions\n+        ///   (on failed reads and protected `Frozen -> Disabled`, ignore `Reserved -> Active`,\n+        ///   `Reserved -> Frozen`, and `Active -> Frozen`)\n+        /// - all transitions for attempts to deallocate strongly protected tags\n+        ///\n+        /// # Panics\n+        ///\n+        /// This function assumes that its arguments apply to the same location\n+        /// and that they were obtained during a normal execution. It will panic otherwise.\n+        /// - `err` cannot be a `ProtectedTransition(_)` of a noop transition, as those\n+        /// never trigger protectors;\n+        /// - all transitions involved in `self` and `err` should be increasing\n+        /// (Reserved < Active < Frozen < Disabled);\n+        /// - between `self` and `err` the permission should also be increasing,\n+        /// so all permissions inside `err` should be greater than `self.1`;\n+        /// - `Active` and `Reserved` cannot cause an error due to insufficient permissions,\n+        /// so `err` cannot be a `ChildAccessForbidden(_)` of either of them;\n+        pub(in super::super) fn is_relevant(&self, err: TransitionError) -> bool {\n+            // NOTE: `super::super` is the visibility of `TransitionError`\n+            assert!(self.is_possible());\n+            if self.is_noop() {\n+                return false;\n+            }\n+            match err {\n+                TransitionError::ChildAccessForbidden(insufficient) => {\n+                    // Show where the permission was gained then lost,\n+                    // but ignore unrelated permissions.\n+                    // This eliminates transitions like `Active -> Frozen`\n+                    // when the error is a failed `Read`.\n+                    match (self.to, insufficient.inner) {\n+                        (Frozen, Frozen) => true,\n+                        (Active, Frozen) => true,\n+                        (Disabled, Disabled) => true,\n+                        // A pointer being `Disabled` is a strictly stronger source of\n+                        // errors than it being `Frozen`. If we try to access a `Disabled`,\n+                        // then where it became `Frozen` (or `Active`) is the least of our concerns for now.\n+                        (Active | Frozen, Disabled) => false,\n+\n+                        // `Active` and `Reserved` have all permissions, so a\n+                        // `ChildAccessForbidden(Reserved | Active)` can never exist.\n+                        (_, Active) | (_, Reserved { .. }) =>\n+                            unreachable!(\"this permission cannot cause an error\"),\n+                        // No transition has `Reserved` as its `.to` unless it's a noop.\n+                        (Reserved { .. }, _) => unreachable!(\"self is a noop transition\"),\n+                        // All transitions produced in normal executions (using `apply_access`)\n+                        // change permissions in the order `Reserved -> Active -> Frozen -> Disabled`.\n+                        // We assume that the error was triggered on the same location that\n+                        // the transition `self` applies to, so permissions found must be increasing\n+                        // in the order `self.from < self.to <= insufficient.inner`\n+                        (Disabled, Frozen) =>\n+                            unreachable!(\"permissions between self and err must be increasing\"),\n+                    }\n+                }\n+                TransitionError::ProtectedTransition(forbidden) => {\n+                    assert!(!forbidden.is_noop());\n+                    // Show how we got to the starting point of the forbidden transition,\n+                    // but ignore what came before.\n+                    // This eliminates transitions like `Reserved -> Active`\n+                    // when the error is a `Frozen -> Disabled`.\n+                    match (self.to, forbidden.from, forbidden.to) {\n+                        // We absolutely want to know where it was activated.\n+                        (Active, Active, Frozen | Disabled) => true,\n+                        // And knowing where it became Frozen is also important.\n+                        (Frozen, Frozen, Disabled) => true,\n+                        // If the error is a transition `Frozen -> Disabled`, then we don't really\n+                        // care whether before that was `Reserved -> Active -> Frozen` or\n+                        // `Reserved -> Frozen` or even `Frozen` directly.\n+                        // The error will only show either\n+                        // - created as Frozen, then Frozen -> Disabled is forbidden\n+                        // - created as Reserved, later became Frozen, then Frozen -> Disabled is forbidden\n+                        // In both cases the `Reserved -> Active` part is inexistant or irrelevant.\n+                        (Active, Frozen, Disabled) => false,\n+\n+                        // `Reserved -> Frozen` does not trigger protectors.\n+                        (_, Reserved { .. }, Frozen) =>\n+                            unreachable!(\"this transition cannot cause an error\"),\n+                        // No transition has `Reserved` as its `.to` unless it's a noop.\n+                        (Reserved { .. }, _, _) => unreachable!(\"self is a noop transition\"),\n+                        (_, Disabled, Disabled) | (_, Frozen, Frozen) | (_, Active, Active) =>\n+                            unreachable!(\"err contains a noop transition\"),\n+\n+                        // Permissions only evolve in the order `Reserved -> Active -> Frozen -> Disabled`,\n+                        // so permissions found must be increasing in the order\n+                        // `self.from < self.to <= forbidden.from < forbidden.to`.\n+                        (Disabled, Reserved { .. } | Active | Frozen, _)\n+                        | (Frozen, Reserved { .. } | Active, _)\n+                        | (Active, Reserved { .. }, _) =>\n+                            unreachable!(\"permissions between self and err must be increasing\"),\n+                        (_, Disabled, Reserved { .. } | Active | Frozen)\n+                        | (_, Frozen, Reserved { .. } | Active)\n+                        | (_, Active, Reserved { .. }) =>\n+                            unreachable!(\"permissions within err must be increasing\"),\n+                    }\n+                }\n+                // We don't care because protectors evolve independently from\n+                // permissions.\n+                TransitionError::ProtectedDealloc => false,\n+            }\n+        }\n+\n+        /// Endpoint of a transition.\n+        /// Meant only for diagnostics, use `applied` in non-diagnostics\n+        /// code, which also checks that the starting point matches the current state.\n+        pub fn endpoint(&self) -> Permission {\n+            Permission { inner: self.to }\n+        }\n     }\n }\n "}, {"sha": "2a06bd871ef92cb379c2acb40a56df100785f09e", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -97,8 +97,12 @@ impl MachineStopType for TerminationInfo {\n     }\n     fn add_args(\n         self: Box<Self>,\n-        _: &mut dyn FnMut(std::borrow::Cow<'static, str>, rustc_errors::DiagnosticArgValue<'static>),\n-    ) {}\n+        _: &mut dyn FnMut(\n+            std::borrow::Cow<'static, str>,\n+            rustc_errors::DiagnosticArgValue<'static>,\n+        ),\n+    ) {\n+    }\n }\n \n /// Miri specific diagnostics\n@@ -324,10 +328,9 @@ pub fn report_error<'tcx, 'mir>(\n     // We want to dump the allocation if this is `InvalidUninitBytes`. Since `add_args` consumes\n     // the `InterpError`, we extract the variables it before that.\n     let extra = match e {\n-        UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(Some((alloc_id, access)))) => {\n-            Some((alloc_id, access))\n-        }\n-        _ => None\n+        UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(Some((alloc_id, access)))) =>\n+            Some((alloc_id, access)),\n+        _ => None,\n     };\n \n     // FIXME(fee1-dead), HACK: we want to use the error as title therefore we can just extract the\n@@ -477,7 +480,7 @@ pub fn report_msg<'tcx>(\n     }\n \n     let (mut err, handler) = err.into_diagnostic().unwrap();\n-    \n+\n     // Add backtrace\n     for (idx, frame_info) in stacktrace.iter().enumerate() {\n         let is_local = machine.is_local(frame_info);"}, {"sha": "befdddfa8c901bdcb422e3a0bb763253cb0de7fe", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -162,9 +162,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let instance = this.resolve_path(path, Namespace::ValueNS);\n         let cid = GlobalId { instance, promoted: None };\n         // We don't give a span -- this isn't actually used directly by the program anyway.\n-        let const_val = this\n-            .eval_global(cid, None)\n-            .unwrap_or_else(|err| panic!(\"failed to evaluate required Rust item: {path:?}\\n{err:?}\"));\n+        let const_val = this.eval_global(cid, None).unwrap_or_else(|err| {\n+            panic!(\"failed to evaluate required Rust item: {path:?}\\n{err:?}\")\n+        });\n         this.read_scalar(&const_val.into())\n             .unwrap_or_else(|err| panic!(\"failed to read required Rust item: {path:?}\\n{err:?}\"))\n     }"}, {"sha": "9e6e37031535e59c55783791597fd1f53f124aec", "filename": "src/tools/miri/tests/compiletest.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -51,18 +51,9 @@ fn test_config(target: &str, path: &str, mode: Mode, with_dependencies: bool) ->\n     let mut program = CommandBuilder::rustc();\n     program.program = miri_path();\n \n-    let in_rustc_test_suite = option_env!(\"RUSTC_STAGE\").is_some();\n-\n     // Add some flags we always want.\n-    if in_rustc_test_suite {\n-        // Less aggressive warnings to make the rustc toolstate management less painful.\n-        // (We often get warnings when e.g. a feature gets stabilized or some lint gets added/improved.)\n-        program.args.push(\"-Astable-features\".into());\n-        program.args.push(\"-Aunused\".into());\n-    } else {\n-        program.args.push(\"-Dwarnings\".into());\n-        program.args.push(\"-Dunused\".into());\n-    }\n+    program.args.push(\"-Dwarnings\".into());\n+    program.args.push(\"-Dunused\".into());\n     if let Ok(extra_flags) = env::var(\"MIRIFLAGS\") {\n         for flag in extra_flags.split_whitespace() {\n             program.args.push(flag.into());\n@@ -277,7 +268,6 @@ fn run_dep_mode(target: String, mut args: impl Iterator<Item = OsString>) -> Res\n     // the arguments to the interpreted prog\n     cmd.arg(\"--\");\n     cmd.args(args);\n-    println!(\"{cmd:?}\");\n     if cmd.spawn()?.wait()?.success() { Ok(()) } else { std::process::exit(1) }\n }\n "}, {"sha": "4554d0cb82ba0f72062991779700414314f395dd", "filename": "src/tools/miri/tests/fail/intrinsics/unchecked_shl.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Funchecked_shl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Funchecked_shl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Funchecked_shl.rs?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -0,0 +1,8 @@\n+#![feature(unchecked_math)]\n+\n+fn main() {\n+    unsafe {\n+        let _n = 1i8.unchecked_shl(8);\n+        //~^ ERROR: overflowing shift by 8 in `unchecked_shl`\n+    }\n+}"}, {"sha": "264e9baf053d654408721d362e966f7db93e9ac5", "filename": "src/tools/miri/tests/fail/intrinsics/unchecked_shl.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Funchecked_shl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Funchecked_shl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Funchecked_shl.stderr?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -0,0 +1,15 @@\n+error: Undefined Behavior: overflowing shift by 8 in `unchecked_shl`\n+  --> $DIR/unchecked_shl.rs:LL:CC\n+   |\n+LL |         let _n = 1i8.unchecked_shl(8);\n+   |                  ^^^^^^^^^^^^^^^^^^^^ overflowing shift by 8 in `unchecked_shl`\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: BACKTRACE:\n+   = note: inside `main` at $DIR/unchecked_shl.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "fe2e85be69868fe99cf579ac98e724d6b6c8495f", "filename": "src/tools/miri/tests/fail/intrinsics/unchecked_shr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Funchecked_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Funchecked_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Funchecked_shr.rs?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "previous_filename": "src/tools/miri/tests/fail/intrinsics/overflowing-unchecked-rsh.rs"}, {"sha": "378ff9734c16e69b9233c9011324baa93a2c5356", "filename": "src/tools/miri/tests/fail/intrinsics/unchecked_shr.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Funchecked_shr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Funchecked_shr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Funchecked_shr.stderr?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -1,13 +1,13 @@\n error: Undefined Behavior: overflowing shift by 64 in `unchecked_shr`\n-  --> $DIR/overflowing-unchecked-rsh.rs:LL:CC\n+  --> $DIR/unchecked_shr.rs:LL:CC\n    |\n LL |         let _n = 1i64.unchecked_shr(64);\n    |                  ^^^^^^^^^^^^^^^^^^^^^^ overflowing shift by 64 in `unchecked_shr`\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:\n-   = note: inside `main` at $DIR/overflowing-unchecked-rsh.rs:LL:CC\n+   = note: inside `main` at $DIR/unchecked_shr.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n ", "previous_filename": "src/tools/miri/tests/fail/intrinsics/overflowing-unchecked-rsh.stderr"}, {"sha": "d82cb8288a38f324c07809a344bdc54c00d5d7a3", "filename": "src/tools/miri/tests/fail/tree-borrows/alternate-read-write.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.stderr?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -17,13 +17,13 @@ help: the conflicting tag <TAG> was created here, in the initial state Reserved\n    |\n LL |     let y = unsafe { &mut *(x as *mut u8) };\n    |                      ^^^^^^^^^^^^^^^^^^^^\n-help: the conflicting tag <TAG> then transitioned from Reserved to Active due to a child write access at offsets [0x0..0x1]\n+help: the conflicting tag <TAG> later transitioned to Active due to a child write access at offsets [0x0..0x1]\n   --> $DIR/alternate-read-write.rs:LL:CC\n    |\n LL |     *y += 1; // Success\n    |     ^^^^^^^\n-   = help: this corresponds to an activation\n-help: the conflicting tag <TAG> then transitioned from Active to Frozen due to a foreign read access at offsets [0x0..0x1]\n+   = help: this corresponds to the first write to a 2-phase borrowed mutable reference\n+help: the conflicting tag <TAG> later transitioned to Frozen due to a foreign read access at offsets [0x0..0x1]\n   --> $DIR/alternate-read-write.rs:LL:CC\n    |\n LL |     let _val = *x;"}, {"sha": "10c2e95ca2f34d1dd7283e3220adfc366a016734", "filename": "src/tools/miri/tests/fail/tree-borrows/error-range.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.stderr?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -17,19 +17,7 @@ help: the conflicting tag <TAG> was created here, in the initial state Reserved\n    |\n LL |         let rmut = &mut *addr_of_mut!(data[0..6]);\n    |                                       ^^^^\n-help: the conflicting tag <TAG> then transitioned from Reserved to Active due to a child write access at offsets [0x5..0x6]\n-  --> $DIR/error-range.rs:LL:CC\n-   |\n-LL |         rmut[5] += 1;\n-   |         ^^^^^^^^^^^^\n-   = help: this corresponds to an activation\n-help: the conflicting tag <TAG> then transitioned from Active to Frozen due to a foreign read access at offsets [0x5..0x6]\n-  --> $DIR/error-range.rs:LL:CC\n-   |\n-LL |         let _v = data[5];\n-   |                  ^^^^^^^\n-   = help: this corresponds to a loss of write permissions\n-help: the conflicting tag <TAG> then transitioned from Frozen to Disabled due to a foreign write access at offsets [0x5..0x6]\n+help: the conflicting tag <TAG> later transitioned to Disabled due to a foreign write access at offsets [0x5..0x6]\n   --> $DIR/error-range.rs:LL:CC\n    |\n LL |         data[5] = 1;"}, {"sha": "86fdf97ac41a3ee0123de0425917abba8bc41be7", "filename": "src/tools/miri/tests/fail/tree-borrows/fragile-data-race.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.stderr?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -17,7 +17,7 @@ help: the conflicting tag <TAG> was created here, in the initial state Reserved\n    |\n LL | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    |                                                       ^\n-help: the conflicting tag <TAG> then transitioned from Reserved to Frozen due to a foreign read access at offsets [0x0..0x1]\n+help: the conflicting tag <TAG> later transitioned to Frozen due to a foreign read access at offsets [0x0..0x1]\n   --> RUSTLIB/core/src/ptr/mod.rs:LL:CC\n    |\n LL |         crate::intrinsics::read_via_copy(src)"}, {"sha": "6deb4b43f6a0307cf7cdfb9c453330f1f81cd357", "filename": "src/tools/miri/tests/fail/tree-borrows/read-to-local.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.stderr?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -11,13 +11,13 @@ help: the accessed tag <TAG> was created here, in the initial state Reserved\n    |\n LL |         let mref = &mut root;\n    |                    ^^^^^^^^^\n-help: the accessed tag <TAG> then transitioned from Reserved to Active due to a child write access at offsets [0x0..0x1]\n+help: the accessed tag <TAG> later transitioned to Active due to a child write access at offsets [0x0..0x1]\n   --> $DIR/read-to-local.rs:LL:CC\n    |\n LL |         *ptr = 0; // Write\n    |         ^^^^^^^^\n-   = help: this corresponds to an activation\n-help: the accessed tag <TAG> then transitioned from Active to Frozen due to a foreign read access at offsets [0x0..0x1]\n+   = help: this corresponds to the first write to a 2-phase borrowed mutable reference\n+help: the accessed tag <TAG> later transitioned to Frozen due to a foreign read access at offsets [0x0..0x1]\n   --> $DIR/read-to-local.rs:LL:CC\n    |\n LL |         assert_eq!(root, 0); // Parent Read"}, {"sha": "97088d5854cc9dd396f4d85f90a5c6b6e09eea64", "filename": "src/tools/miri/tests/fail/tree-borrows/strongly-protected.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -17,12 +17,6 @@ help: the strongly protected tag <TAG> was created here, in the initial state Re\n    |\n LL | fn inner(x: &mut i32, f: fn(&mut i32)) {\n    |          ^\n-help: the strongly protected tag <TAG> then transitioned from Reserved to Active due to a child write access at offsets [0x0..0x4]\n-  --> $DIR/strongly-protected.rs:LL:CC\n-   |\n-LL |         drop(unsafe { Box::from_raw(raw) });\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: this corresponds to an activation\n    = note: BACKTRACE (of the first span):\n    = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n    = note: inside `<std::alloc::Global as std::alloc::Allocator>::deallocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC"}, {"sha": "898f6108ccbdcda03240898b1d4176d6e6d6e550", "filename": "src/tools/miri/tests/fail/tree-borrows/write-during-2phase.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.stderr?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -18,7 +18,7 @@ LL | |         *inner = 42;\n LL | |         n\n LL | |     });\n    | |______^\n-help: the accessed tag <TAG> then transitioned from Reserved to Disabled due to a foreign write access at offsets [0x0..0x8]\n+help: the accessed tag <TAG> later transitioned to Disabled due to a foreign write access at offsets [0x0..0x8]\n   --> $DIR/write-during-2phase.rs:LL:CC\n    |\n LL |         *inner = 42;"}, {"sha": "af245aa89aa36b1a732ab621c29a1a3fb0851085", "filename": "src/tools/miri/tests/pass/shims/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4f0417aa190bec347c53a147ca1cd134a832f6/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs?ref=4e4f0417aa190bec347c53a147ca1cd134a832f6", "patch": "@@ -31,7 +31,7 @@ fn main() {\n }\n \n fn host_to_target_path(path: String) -> PathBuf {\n-    use std::ffi::{c_char, CStr, CString};\n+    use std::ffi::{CStr, CString};\n \n     let path = CString::new(path).unwrap();\n     let mut out = Vec::with_capacity(1024);"}]}