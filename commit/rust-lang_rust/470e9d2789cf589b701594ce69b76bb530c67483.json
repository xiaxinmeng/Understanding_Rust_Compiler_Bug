{"sha": "470e9d2789cf589b701594ce69b76bb530c67483", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MGU5ZDI3ODljZjU4OWI3MDE1OTRjZTY5Yjc2YmI1MzBjNjc0ODM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-10-17T17:37:05Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-10-17T17:37:05Z"}, "message": "Rc: value -> allocation", "tree": {"sha": "5709f0021e6f61a65d831346715682a033a345d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5709f0021e6f61a65d831346715682a033a345d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/470e9d2789cf589b701594ce69b76bb530c67483", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/470e9d2789cf589b701594ce69b76bb530c67483", "html_url": "https://github.com/rust-lang/rust/commit/470e9d2789cf589b701594ce69b76bb530c67483", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/470e9d2789cf589b701594ce69b76bb530c67483/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e498005a12548a8fd396312affde05c4d3ca085", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e498005a12548a8fd396312affde05c4d3ca085", "html_url": "https://github.com/rust-lang/rust/commit/7e498005a12548a8fd396312affde05c4d3ca085"}], "stats": {"total": 95, "additions": 51, "deletions": 44}, "files": [{"sha": "3178f5774eb64b78aa2acb9a9474044e62c5e5d3", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 51, "deletions": 44, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/470e9d2789cf589b701594ce69b76bb530c67483/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470e9d2789cf589b701594ce69b76bb530c67483/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=470e9d2789cf589b701594ce69b76bb530c67483", "patch": "@@ -3,8 +3,8 @@\n //!\n //! The type [`Rc<T>`][`Rc`] provides shared ownership of a value of type `T`,\n //! allocated in the heap. Invoking [`clone`][clone] on [`Rc`] produces a new\n-//! pointer to the same value in the heap. When the last [`Rc`] pointer to a\n-//! given value is destroyed, the pointed-to value is also destroyed.\n+//! pointer to the same allocation in the heap. When the last [`Rc`] pointer to a\n+//! given allocation is destroyed, the pointed-to value is also destroyed.\n //!\n //! Shared references in Rust disallow mutation by default, and [`Rc`]\n //! is no exception: you cannot generally obtain a mutable reference to\n@@ -21,7 +21,7 @@\n //!\n //! The [`downgrade`][downgrade] method can be used to create a non-owning\n //! [`Weak`] pointer. A [`Weak`] pointer can be [`upgrade`][upgrade]d\n-//! to an [`Rc`], but this will return [`None`] if the value has\n+//! to an [`Rc`], but this will return [`None`] if the allocation has\n //! already been dropped.\n //!\n //! A cycle between [`Rc`] pointers will never be deallocated. For this reason,\n@@ -41,7 +41,7 @@\n //! Rc::downgrade(&my_rc);\n //! ```\n //!\n-//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the value may have\n+//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the allocation may have\n //! already been destroyed.\n //!\n //! # Cloning references\n@@ -93,7 +93,7 @@\n //!     );\n //!\n //!     // Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc<Owner>`\n-//!     // value gives us a new pointer to the same `Owner` value, incrementing\n+//!     // gives us a new pointer to the same `Owner` allocation, incrementing\n //!     // the reference count in the process.\n //!     let gadget1 = Gadget {\n //!         id: 1,\n@@ -110,7 +110,7 @@\n //!     // Despite dropping `gadget_owner`, we're still able to print out the name\n //!     // of the `Owner` of the `Gadget`s. This is because we've only dropped a\n //!     // single `Rc<Owner>`, not the `Owner` it points to. As long as there are\n-//!     // other `Rc<Owner>` values pointing at the same `Owner`, it will remain\n+//!     // other `Rc<Owner>` pointing at the same `Owner`, it will remain\n //!     // allocated. The field projection `gadget1.owner.name` works because\n //!     // `Rc<Owner>` automatically dereferences to `Owner`.\n //!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n@@ -124,9 +124,9 @@\n //!\n //! If our requirements change, and we also need to be able to traverse from\n //! `Owner` to\u00a0`Gadget`, we will run into problems. An [`Rc`] pointer from `Owner`\n-//! to `Gadget` introduces a cycle between the values. This means that their\n-//! reference counts can never reach 0, and the values will remain allocated\n-//! forever: a memory leak. In order to get around this, we can use [`Weak`]\n+//! to `Gadget` introduces a cycle. This means that their\n+//! reference counts can never reach 0, and the allocation will never be destroyed:\n+//! a memory leak. In order to get around this, we can use [`Weak`]\n //! pointers.\n //!\n //! Rust actually makes it somewhat difficult to produce this loop in the first\n@@ -193,10 +193,10 @@\n //!     for gadget_weak in gadget_owner.gadgets.borrow().iter() {\n //!\n //!         // `gadget_weak` is a `Weak<Gadget>`. Since `Weak` pointers can't\n-//!         // guarantee the value is still allocated, we need to call\n+//!         // guarantee the allocation still exists, we need to call\n //!         // `upgrade`, which returns an `Option<Rc<Gadget>>`.\n //!         //\n-//!         // In this case we know the value still exists, so we simply\n+//!         // In this case we know the allocation still exists, so we simply\n //!         // `unwrap` the `Option`. In a more complicated program, you might\n //!         // need graceful error handling for a `None` result.\n //!\n@@ -604,7 +604,7 @@ impl<T: ?Sized> Rc<T> {\n         unsafe { NonNull::new_unchecked(Rc::into_raw(this) as *mut _) }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this value.\n+    /// Creates a new [`Weak`][weak] pointer to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -625,7 +625,7 @@ impl<T: ?Sized> Rc<T> {\n         Weak { ptr: this.ptr }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -645,7 +645,7 @@ impl<T: ?Sized> Rc<T> {\n         this.weak() - 1\n     }\n \n-    /// Gets the number of strong (`Rc`) pointers to this value.\n+    /// Gets the number of strong (`Rc`) pointers to this allocation.\n     ///\n     /// # Examples\n     ///\n@@ -664,16 +664,16 @@ impl<T: ?Sized> Rc<T> {\n     }\n \n     /// Returns `true` if there are no other `Rc` or [`Weak`][weak] pointers to\n-    /// this inner value.\n+    /// this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     #[inline]\n     fn is_unique(this: &Self) -> bool {\n         Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n \n-    /// Returns a mutable reference to the inner value, if there are\n-    /// no other `Rc` or [`Weak`][weak] pointers to the same value.\n+    /// Returns a mutable reference into the given `Rc`, if there are\n+    /// no other `Rc` or [`Weak`][weak] pointers to the same allocation.\n     ///\n     /// Returns [`None`] otherwise, because it is not safe to\n     /// mutate a shared value.\n@@ -710,7 +710,7 @@ impl<T: ?Sized> Rc<T> {\n         }\n     }\n \n-    /// Returns a mutable reference to the inner value,\n+    /// Returns a mutable reference into the given `Rc`,\n     /// without any check.\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n@@ -719,7 +719,7 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// # Safety\n     ///\n-    /// Any other `Rc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// Any other `Rc` or [`Weak`] pointers to the same allocation must not be dereferenced\n     /// for the duration of the returned borrow.\n     /// This is trivially the case if no such pointers exist,\n     /// for example immediately after `Rc::new`.\n@@ -745,8 +745,8 @@ impl<T: ?Sized> Rc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns `true` if the two `Rc`s point to the same value (not\n-    /// just values that compare as equal).\n+    /// Returns `true` if the two `Rc`s point to the same allocation\n+    /// (in a vein similar to [`ptr::eq`]).\n     ///\n     /// # Examples\n     ///\n@@ -760,6 +760,8 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(Rc::ptr_eq(&five, &same_five));\n     /// assert!(!Rc::ptr_eq(&five, &other_five));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n@@ -768,12 +770,12 @@ impl<T: ?Sized> Rc<T> {\n impl<T: Clone> Rc<T> {\n     /// Makes a mutable reference into the given `Rc`.\n     ///\n-    /// If there are other `Rc` pointers to the same value, then `make_mut` will\n-    /// [`clone`] the inner value to ensure unique ownership.  This is also\n+    /// If there are other `Rc` pointers to the same allocation, then `make_mut` will\n+    /// [`clone`] the inner value to a new allocation to ensure unique ownership.  This is also\n     /// referred to as clone-on-write.\n     ///\n-    /// If there are no other `Rc` pointers to this value, then [`Weak`]\n-    /// pointers to this value will be disassociated.\n+    /// If there are no other `Rc` pointers to this allocation, then [`Weak`]\n+    /// pointers to this allocation will be disassociated.\n     ///\n     /// See also [`get_mut`], which will fail rather than cloning.\n     ///\n@@ -794,7 +796,7 @@ impl<T: Clone> Rc<T> {\n     /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n     /// *Rc::make_mut(&mut other_data) *= 2;  // Won't clone anything\n     ///\n-    /// // Now `data` and `other_data` point to different values.\n+    /// // Now `data` and `other_data` point to different allocations.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n@@ -837,7 +839,7 @@ impl<T: Clone> Rc<T> {\n         // returned is the *only* pointer that will ever be returned to T. Our\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n-        // reference to the inner value.\n+        // reference to the allocation.\n         unsafe {\n             &mut this.ptr.as_mut().value\n         }\n@@ -1111,7 +1113,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n impl<T: ?Sized> Clone for Rc<T> {\n     /// Makes a clone of the `Rc` pointer.\n     ///\n-    /// This creates another pointer to the same inner value, increasing the\n+    /// This creates another pointer to the same allocation, increasing the\n     /// strong reference count.\n     ///\n     /// # Examples\n@@ -1189,9 +1191,11 @@ impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc`s.\n     ///\n-    /// Two `Rc`s are equal if their inner values are equal.\n+    /// Two `Rc`s are equal if their inner values are equal, even if they are\n+    /// stored in different allocation.\n     ///\n-    /// If `T` also implements `Eq`, two `Rc`s that point to the same value are\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Rc`s that point to the same allocation are\n     /// always equal.\n     ///\n     /// # Examples\n@@ -1212,7 +1216,8 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     ///\n     /// Two `Rc`s are unequal if their inner values are unequal.\n     ///\n-    /// If `T` also implements `Eq`, two `Rc`s that point to the same value are\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Rc`s that point to the same allocation are\n     /// never unequal.\n     ///\n     /// # Examples\n@@ -1541,16 +1546,16 @@ impl<'a, T: 'a + Clone> RcFromIter<&'a T, slice::Iter<'a, T>> for Rc<[T]> {\n }\n \n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n-/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n+/// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n ///\n /// Since a `Weak` reference does not count towards ownership, it will not\n-/// prevent the inner value from being dropped, and `Weak` itself makes no\n+/// prevent the value stored in the allocation from being dropped, and `Weak` itself makes no\n /// guarantees about the value still being present and may return [`None`]\n /// when [`upgrade`]d.\n ///\n-/// A `Weak` pointer is useful for keeping a temporary reference to the value\n-/// within [`Rc`] without extending its lifetime. It is also used to prevent\n+/// A `Weak` pointer is useful for keeping a temporary reference to the allocation\n+/// managed by [`Rc`] without extending its lifetime. It is also used to prevent\n /// circular references between [`Rc`] pointers, since mutual owning references\n /// would never allow either [`Rc`] to be dropped. For example, a tree could\n /// have strong [`Rc`] pointers from parent nodes to children, and `Weak`\n@@ -1751,9 +1756,9 @@ pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n \n impl<T: ?Sized> Weak<T> {\n     /// Attempts to upgrade the `Weak` pointer to an [`Rc`], extending\n-    /// the lifetime of the value if successful.\n+    /// the lifetime of the allocation if successful.\n     ///\n-    /// Returns [`None`] if the value has since been dropped.\n+    /// Returns [`None`] if the value stored in the allocation has since been dropped.\n     ///\n     /// [`Rc`]: struct.Rc.html\n     /// [`None`]: ../../std/option/enum.Option.html\n@@ -1787,7 +1792,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of strong (`Rc`) pointers pointing to this value.\n+    /// Gets the number of strong (`Rc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n@@ -1801,11 +1806,11 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of `Weak` pointers pointing to this value.\n+    /// Gets the number of `Weak` pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return `None`. If\n     /// not, the returned value is at least 1, since `self` still points to the\n-    /// value.\n+    /// allocation.\n     ///\n     /// [`Weak::new`]: #method.new\n     #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n@@ -1830,14 +1835,14 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just\n-    /// values that compare as equal), or if both don't point to any value\n+    /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n+    /// [`ptr::eq`]), or if both don't point to any allocation\n     /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n     /// Since this compares pointers it means that `Weak::new()` will equal each\n-    /// other, even though they don't point to any value.\n+    /// other, even though they don't point to any allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1869,6 +1874,8 @@ impl<T: ?Sized> Weak<T> {\n     /// let third = Rc::downgrade(&third_rc);\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1918,7 +1925,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak` pointer that points to the same value.\n+    /// Makes a clone of the `Weak` pointer that points to the same allocation.\n     ///\n     /// # Examples\n     ///"}]}