{"sha": "fab9b1d4cd5a788f46d94077b49da285ce782b74", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhYjliMWQ0Y2Q1YTc4OGY0NmQ5NDA3N2I0OWRhMjg1Y2U3ODJiNzQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-07-24T09:56:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-24T09:56:38Z"}, "message": "Rollup merge of #74677 - ssomers:btree_cleanup_2, r=Amanieu\n\nRemove needless unsafety from BTreeMap::drain_filter\n\nRemove one piece of unsafe code in the iteration over the iterator returned by BTreeMap::drain_filter.\n- Changes an explicitly unspecified part of the API: when the user-supplied predicate (or some of BTreeMap's code) panicked, and the caller tries to use the iterator again, we no longer offer the same key/value pair to the predicate again but pretend the iterator has finished. Note that Miri does not find UB in the test case added here with the unsafe code (or without).\n- Makes the code a little easier on the eyes.\n- Makes the code a little harder on the CPU:\n```\nbenchcmp c0 c2 --threshold 3\n name                                         c0 ns/iter  c2 ns/iter  diff ns/iter  diff %  speedup\n btree::set::clone_100_and_drain_all          2,794       2,900                106   3.79%   x 0.96\n btree::set::clone_100_and_drain_half         2,604       2,964                360  13.82%   x 0.88\n btree::set::clone_10k_and_drain_half         287,770     322,755           34,985  12.16%   x 0.89\n```\nr? @Amanieu", "tree": {"sha": "dd0eeeddbd39e82beb10ccd52d81f69c75e1ab8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd0eeeddbd39e82beb10ccd52d81f69c75e1ab8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fab9b1d4cd5a788f46d94077b49da285ce782b74", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGrBWCRBK7hj4Ov3rIwAAdHIIAIXwM+aWrPJACLYROHdrRRiI\nbzZC5ayQwkOx3dm4e+e6duY0O6fWmp5a4rH29BdsOm4dlthGkqjjZOaFNBQ2nKcB\njKWRqB2tlZU5q65VXrt1lEuL+kpHx5Ry5LyYq/CVFSE5WGQuPlmb3k7bQ9v1J/0C\nev8PaC+z/hOPrOLen3J5oGo4xr+q6oIjhSPDazn4mDzF6ZElKzyScwcXJtumdbdp\ncfB6o+AifA5mzGOO6PHMLqzTcwv3dRcHYcztcVJ9pQfbiOZsQVSNxSd313xSemsx\nnTALx057TfbRa+dRQ23QV2x9RaXPdXszsABZC0HBmktzPtPvWzwVlYopPOpizhc=\n=/Sra\n-----END PGP SIGNATURE-----\n", "payload": "tree dd0eeeddbd39e82beb10ccd52d81f69c75e1ab8b\nparent 7f2bb29907c333ebb71e0cf651302ebc4fc0cb1e\nparent facc46fd0a85408bc05aa19b80131e3cfb5fe3dd\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1595584598 +0900\ncommitter GitHub <noreply@github.com> 1595584598 +0900\n\nRollup merge of #74677 - ssomers:btree_cleanup_2, r=Amanieu\n\nRemove needless unsafety from BTreeMap::drain_filter\n\nRemove one piece of unsafe code in the iteration over the iterator returned by BTreeMap::drain_filter.\n- Changes an explicitly unspecified part of the API: when the user-supplied predicate (or some of BTreeMap's code) panicked, and the caller tries to use the iterator again, we no longer offer the same key/value pair to the predicate again but pretend the iterator has finished. Note that Miri does not find UB in the test case added here with the unsafe code (or without).\n- Makes the code a little easier on the eyes.\n- Makes the code a little harder on the CPU:\n```\nbenchcmp c0 c2 --threshold 3\n name                                         c0 ns/iter  c2 ns/iter  diff ns/iter  diff %  speedup\n btree::set::clone_100_and_drain_all          2,794       2,900                106   3.79%   x 0.96\n btree::set::clone_100_and_drain_half         2,604       2,964                360  13.82%   x 0.88\n btree::set::clone_10k_and_drain_half         287,770     322,755           34,985  12.16%   x 0.89\n```\nr? @Amanieu\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fab9b1d4cd5a788f46d94077b49da285ce782b74", "html_url": "https://github.com/rust-lang/rust/commit/fab9b1d4cd5a788f46d94077b49da285ce782b74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fab9b1d4cd5a788f46d94077b49da285ce782b74/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f2bb29907c333ebb71e0cf651302ebc4fc0cb1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f2bb29907c333ebb71e0cf651302ebc4fc0cb1e", "html_url": "https://github.com/rust-lang/rust/commit/7f2bb29907c333ebb71e0cf651302ebc4fc0cb1e"}, {"sha": "facc46fd0a85408bc05aa19b80131e3cfb5fe3dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/facc46fd0a85408bc05aa19b80131e3cfb5fe3dd", "html_url": "https://github.com/rust-lang/rust/commit/facc46fd0a85408bc05aa19b80131e3cfb5fe3dd"}], "stats": {"total": 67, "additions": 47, "deletions": 20}, "files": [{"sha": "24d1f61fa68c48dd773ec161e2d1f98356b4f4bd", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fab9b1d4cd5a788f46d94077b49da285ce782b74/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab9b1d4cd5a788f46d94077b49da285ce782b74/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=fab9b1d4cd5a788f46d94077b49da285ce782b74", "patch": "@@ -1672,19 +1672,12 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n         edge.reborrow().next_kv().ok().map(|kv| kv.into_kv())\n     }\n \n-    unsafe fn next_kv(\n-        &mut self,\n-    ) -> Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>> {\n-        let edge = self.cur_leaf_edge.as_ref()?;\n-        unsafe { ptr::read(edge).next_kv().ok() }\n-    }\n-\n     /// Implementation of a typical `DrainFilter::next` method, given the predicate.\n     pub(super) fn next<F>(&mut self, pred: &mut F) -> Option<(K, V)>\n     where\n         F: FnMut(&K, &mut V) -> bool,\n     {\n-        while let Some(mut kv) = unsafe { self.next_kv() } {\n+        while let Ok(mut kv) = self.cur_leaf_edge.take()?.next_kv() {\n             let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;"}, {"sha": "f9f81716e357c243b3c7ec9add10b11f6dabff5e", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fab9b1d4cd5a788f46d94077b49da285ce782b74/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab9b1d4cd5a788f46d94077b49da285ce782b74/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=fab9b1d4cd5a788f46d94077b49da285ce782b74", "patch": "@@ -887,18 +887,16 @@ mod test_drain_filter {\n             }\n         }\n \n-        let mut map = BTreeMap::new();\n-        map.insert(0, D);\n-        map.insert(4, D);\n-        map.insert(8, D);\n+        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n+        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n \n         catch_unwind(move || {\n             drop(map.drain_filter(|i, _| {\n                 PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n                 true\n             }))\n         })\n-        .ok();\n+        .unwrap_err();\n \n         assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n         assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n@@ -916,10 +914,8 @@ mod test_drain_filter {\n             }\n         }\n \n-        let mut map = BTreeMap::new();\n-        map.insert(0, D);\n-        map.insert(4, D);\n-        map.insert(8, D);\n+        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n+        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n \n         catch_unwind(AssertUnwindSafe(|| {\n             drop(map.drain_filter(|i, _| {\n@@ -930,7 +926,45 @@ mod test_drain_filter {\n                 }\n             }))\n         }))\n-        .ok();\n+        .unwrap_err();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(map.len(), 2);\n+        assert_eq!(map.first_entry().unwrap().key(), &4);\n+        assert_eq!(map.last_entry().unwrap().key(), &8);\n+    }\n+\n+    // Same as above, but attempt to use the iterator again after the panic in the predicate\n+    #[test]\n+    fn pred_panic_reuse() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                DROPS.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        // Keys are multiples of 4, so that each key is counted by a hexadecimal digit.\n+        let mut map = (0..3).map(|i| (i * 4, D)).collect::<BTreeMap<_, _>>();\n+\n+        {\n+            let mut it = map.drain_filter(|i, _| {\n+                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                match i {\n+                    0 => true,\n+                    _ => panic!(),\n+                }\n+            });\n+            catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n+            // Iterator behaviour after a panic is explicitly unspecified,\n+            // so this is just the current implementation:\n+            let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n+            assert!(matches!(result, Ok(None)));\n+        }\n \n         assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n         assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n@@ -1399,7 +1433,7 @@ fn test_into_iter_drop_leak_height_0() {\n     map.insert(\"d\", D);\n     map.insert(\"e\", D);\n \n-    catch_unwind(move || drop(map.into_iter())).ok();\n+    catch_unwind(move || drop(map.into_iter())).unwrap_err();\n \n     assert_eq!(DROPS.load(Ordering::SeqCst), 5);\n }\n@@ -1423,7 +1457,7 @@ fn test_into_iter_drop_leak_height_1() {\n         DROPS.store(0, Ordering::SeqCst);\n         PANIC_POINT.store(panic_point, Ordering::SeqCst);\n         let map: BTreeMap<_, _> = (0..size).map(|i| (i, D)).collect();\n-        catch_unwind(move || drop(map.into_iter())).ok();\n+        catch_unwind(move || drop(map.into_iter())).unwrap_err();\n         assert_eq!(DROPS.load(Ordering::SeqCst), size);\n     }\n }"}]}