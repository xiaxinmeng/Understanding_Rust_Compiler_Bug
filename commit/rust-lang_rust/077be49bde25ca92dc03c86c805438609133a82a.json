{"sha": "077be49bde25ca92dc03c86c805438609133a82a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3N2JlNDliZGUyNWNhOTJkYzAzYzg2YzgwNTQzODYwOTEzM2E4MmE=", "commit": {"author": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-05-29T17:41:36Z"}, "committer": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-30T15:03:50Z"}, "message": "rustc_llvm: move to rustc_codegen_llvm::llvm.", "tree": {"sha": "afae5c5f1b8aab0a7a6bc3ef5ff1394154af20de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afae5c5f1b8aab0a7a6bc3ef5ff1394154af20de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/077be49bde25ca92dc03c86c805438609133a82a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/077be49bde25ca92dc03c86c805438609133a82a", "html_url": "https://github.com/rust-lang/rust/commit/077be49bde25ca92dc03c86c805438609133a82a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/077be49bde25ca92dc03c86c805438609133a82a/comments", "author": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54628c8ea844956f3f4f416b82067c634eb09f7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/54628c8ea844956f3f4f416b82067c634eb09f7b", "html_url": "https://github.com/rust-lang/rust/commit/54628c8ea844956f3f4f416b82067c634eb09f7b"}], "stats": {"total": 706, "additions": 348, "deletions": 358}, "files": [{"sha": "be32872dad80a23f769d1bcc96e05b0de3d94f43", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/077be49bde25ca92dc03c86c805438609133a82a/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/077be49bde25ca92dc03c86c805438609133a82a/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=077be49bde25ca92dc03c86c805438609133a82a", "patch": "@@ -2222,11 +2222,8 @@ dependencies = [\n name = \"rustc_llvm\"\n version = \"0.0.0\"\n dependencies = [\n- \"bitflags 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"build_helper 0.1.0\",\n  \"cc 1.0.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_cratesio_shim 0.0.0\",\n ]\n \n [[package]]"}, {"sha": "14ec81fc6655b6fe932701d3263224879eee81ed", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=077be49bde25ca92dc03c86c805438609133a82a", "patch": "@@ -29,6 +29,9 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(optin_builtin_traits)]\n+#![feature(concat_idents)]\n+#![feature(link_args)]\n+#![feature(static_nobundle)]\n \n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n@@ -46,7 +49,7 @@ extern crate rustc_target;\n #[macro_use] extern crate rustc_data_structures;\n extern crate rustc_demangle;\n extern crate rustc_incremental;\n-extern crate rustc_llvm as llvm;\n+extern crate rustc_llvm;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_codegen_utils;\n \n@@ -110,6 +113,7 @@ mod debuginfo;\n mod declare;\n mod glue;\n mod intrinsic;\n+pub mod llvm;\n mod llvm_util;\n mod metadata;\n mod meth;"}, {"sha": "116f16de324bef7c09c10b96feeb840fd286f592", "filename": "src/librustc_codegen_llvm/llvm/archive_ro.rs", "status": "renamed", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs?ref=077be49bde25ca92dc03c86c805438609133a82a", "patch": "@@ -10,7 +10,7 @@\n \n //! A wrapper around LLVM's archive (.a) code\n \n-use ArchiveRef;\n+use super::ArchiveRef;\n \n use std::ffi::CString;\n use std::marker;\n@@ -26,11 +26,11 @@ unsafe impl Send for ArchiveRO {}\n \n pub struct Iter<'a> {\n     archive: &'a ArchiveRO,\n-    ptr: ::ArchiveIteratorRef,\n+    ptr: super::ArchiveIteratorRef,\n }\n \n pub struct Child<'a> {\n-    ptr: ::ArchiveChildRef,\n+    ptr: super::ArchiveChildRef,\n     _data: marker::PhantomData<&'a ArchiveRO>,\n }\n \n@@ -44,9 +44,9 @@ impl ArchiveRO {\n     pub fn open(dst: &Path) -> Result<ArchiveRO, String> {\n         return unsafe {\n             let s = path2cstr(dst);\n-            let ar = ::LLVMRustOpenArchive(s.as_ptr());\n+            let ar = super::LLVMRustOpenArchive(s.as_ptr());\n             if ar.is_null() {\n-                Err(::last_error().unwrap_or(\"failed to open archive\".to_string()))\n+                Err(super::last_error().unwrap_or(\"failed to open archive\".to_string()))\n             } else {\n                 Ok(ArchiveRO { ptr: ar })\n             }\n@@ -72,7 +72,7 @@ impl ArchiveRO {\n     pub fn iter(&self) -> Iter {\n         unsafe {\n             Iter {\n-                ptr: ::LLVMRustArchiveIteratorNew(self.ptr),\n+                ptr: super::LLVMRustArchiveIteratorNew(self.ptr),\n                 archive: self,\n             }\n         }\n@@ -82,7 +82,7 @@ impl ArchiveRO {\n impl Drop for ArchiveRO {\n     fn drop(&mut self) {\n         unsafe {\n-            ::LLVMRustDestroyArchive(self.ptr);\n+            super::LLVMRustDestroyArchive(self.ptr);\n         }\n     }\n }\n@@ -91,9 +91,9 @@ impl<'a> Iterator for Iter<'a> {\n     type Item = Result<Child<'a>, String>;\n \n     fn next(&mut self) -> Option<Result<Child<'a>, String>> {\n-        let ptr = unsafe { ::LLVMRustArchiveIteratorNext(self.ptr) };\n+        let ptr = unsafe { super::LLVMRustArchiveIteratorNext(self.ptr) };\n         if ptr.is_null() {\n-            ::last_error().map(Err)\n+            super::last_error().map(Err)\n         } else {\n             Some(Ok(Child {\n                 ptr,\n@@ -106,7 +106,7 @@ impl<'a> Iterator for Iter<'a> {\n impl<'a> Drop for Iter<'a> {\n     fn drop(&mut self) {\n         unsafe {\n-            ::LLVMRustArchiveIteratorFree(self.ptr);\n+            super::LLVMRustArchiveIteratorFree(self.ptr);\n         }\n     }\n }\n@@ -115,7 +115,7 @@ impl<'a> Child<'a> {\n     pub fn name(&self) -> Option<&'a str> {\n         unsafe {\n             let mut name_len = 0;\n-            let name_ptr = ::LLVMRustArchiveChildName(self.ptr, &mut name_len);\n+            let name_ptr = super::LLVMRustArchiveChildName(self.ptr, &mut name_len);\n             if name_ptr.is_null() {\n                 None\n             } else {\n@@ -128,23 +128,23 @@ impl<'a> Child<'a> {\n     pub fn data(&self) -> &'a [u8] {\n         unsafe {\n             let mut data_len = 0;\n-            let data_ptr = ::LLVMRustArchiveChildData(self.ptr, &mut data_len);\n+            let data_ptr = super::LLVMRustArchiveChildData(self.ptr, &mut data_len);\n             if data_ptr.is_null() {\n                 panic!(\"failed to read data from archive child\");\n             }\n             slice::from_raw_parts(data_ptr as *const u8, data_len as usize)\n         }\n     }\n \n-    pub fn raw(&self) -> ::ArchiveChildRef {\n+    pub fn raw(&self) -> super::ArchiveChildRef {\n         self.ptr\n     }\n }\n \n impl<'a> Drop for Child<'a> {\n     fn drop(&mut self) {\n         unsafe {\n-            ::LLVMRustArchiveChildFree(self.ptr);\n+            super::LLVMRustArchiveChildFree(self.ptr);\n         }\n     }\n }", "previous_filename": "src/librustc_llvm/archive_ro.rs"}, {"sha": "0674bccd51e878241029c3f2008a11b620bc18e5", "filename": "src/librustc_codegen_llvm/llvm/diagnostic.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fdiagnostic.rs?ref=077be49bde25ca92dc03c86c805438609133a82a", "patch": "@@ -16,7 +16,7 @@ pub use self::Diagnostic::*;\n use libc::c_uint;\n use std::ptr;\n \n-use {DiagnosticInfoRef, TwineRef, ValueRef};\n+use super::{DiagnosticInfoRef, TwineRef, ValueRef};\n \n #[derive(Copy, Clone)]\n pub enum OptimizationDiagnosticKind {", "previous_filename": "src/librustc_llvm/diagnostic.rs"}, {"sha": "afd1070a77ed75e6176610736ab10619a7b01b9d", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "renamed", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=077be49bde25ca92dc03c86c805438609133a82a", "patch": "@@ -14,15 +14,17 @@\n // This method was changed in this LLVM patch:\n // https://reviews.llvm.org/D26769\n \n-use debuginfo::{DIBuilderRef, DIDescriptor, DIFile, DILexicalBlock, DISubprogram, DIType,\n-                DIBasicType, DIDerivedType, DICompositeType, DIScope, DIVariable,\n-                DIGlobalVariable, DIArray, DISubrange, DITemplateTypeParameter, DIEnumerator,\n-                DINameSpace, DIFlags};\n+use super::debuginfo::{\n+    DIBuilderRef, DIDescriptor, DIFile, DILexicalBlock, DISubprogram, DIType,\n+    DIBasicType, DIDerivedType, DICompositeType, DIScope, DIVariable,\n+    DIGlobalVariable, DIArray, DISubrange, DITemplateTypeParameter, DIEnumerator,\n+    DINameSpace, DIFlags,\n+};\n \n use libc::{c_uint, c_int, size_t, c_char};\n use libc::{c_longlong, c_ulonglong, c_void};\n \n-use RustStringRef;\n+use super::RustStringRef;\n \n pub type Opcode = u32;\n pub type Bool = c_uint;\n@@ -512,13 +514,6 @@ pub mod debuginfo {\n \n pub enum ModuleBuffer {}\n \n-// This annotation is primarily needed for MSVC where attributes like\n-// dllimport/dllexport are applied and need to be correct for everything to\n-// link successfully. The #[link] annotation here says \"these symbols are\n-// included statically\" which means that they're all exported with dllexport\n-// and from the rustc_llvm dynamic library. Otherwise the rustc_codegen_llvm dynamic\n-// library would not be able to access these symbols.\n-#[link(name = \"rustllvm\", kind = \"static\")]\n extern \"C\" {\n     // Create and destroy contexts.\n     pub fn LLVMRustContextCreate(shouldDiscardNames: bool) -> ContextRef;", "previous_filename": "src/librustc_llvm/ffi.rs"}, {"sha": "b6ff9b17bd93394a5ab60492de501580105a92e1", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=077be49bde25ca92dc03c86c805438609133a82a", "patch": "@@ -0,0 +1,315 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_upper_case_globals)]\n+#![allow(non_camel_case_types)]\n+#![allow(non_snake_case)]\n+#![allow(dead_code)]\n+#![deny(bare_trait_objects)]\n+\n+pub use self::IntPredicate::*;\n+pub use self::RealPredicate::*;\n+pub use self::TypeKind::*;\n+pub use self::AtomicRmwBinOp::*;\n+pub use self::MetadataType::*;\n+pub use self::CodeGenOptSize::*;\n+pub use self::CallConv::*;\n+pub use self::Linkage::*;\n+\n+use std::str::FromStr;\n+use std::slice;\n+use std::ffi::{CString, CStr};\n+use std::cell::RefCell;\n+use libc::{self, c_uint, c_char, size_t};\n+\n+pub mod archive_ro;\n+pub mod diagnostic;\n+mod ffi;\n+\n+pub use self::ffi::*;\n+\n+impl LLVMRustResult {\n+    pub fn into_result(self) -> Result<(), ()> {\n+        match self {\n+            LLVMRustResult::Success => Ok(()),\n+            LLVMRustResult::Failure => Err(()),\n+        }\n+    }\n+}\n+\n+pub fn AddFunctionAttrStringValue(llfn: ValueRef,\n+                                  idx: AttributePlace,\n+                                  attr: &CStr,\n+                                  value: &CStr) {\n+    unsafe {\n+        LLVMRustAddFunctionAttrStringValue(llfn,\n+                                           idx.as_uint(),\n+                                           attr.as_ptr(),\n+                                           value.as_ptr())\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum AttributePlace {\n+    ReturnValue,\n+    Argument(u32),\n+    Function,\n+}\n+\n+impl AttributePlace {\n+    pub fn as_uint(self) -> c_uint {\n+        match self {\n+            AttributePlace::ReturnValue => 0,\n+            AttributePlace::Argument(i) => 1 + i,\n+            AttributePlace::Function => !0,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+#[repr(C)]\n+pub enum CodeGenOptSize {\n+    CodeGenOptSizeNone = 0,\n+    CodeGenOptSizeDefault = 1,\n+    CodeGenOptSizeAggressive = 2,\n+}\n+\n+impl FromStr for ArchiveKind {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"gnu\" => Ok(ArchiveKind::K_GNU),\n+            \"bsd\" => Ok(ArchiveKind::K_BSD),\n+            \"coff\" => Ok(ArchiveKind::K_COFF),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+#[allow(missing_copy_implementations)]\n+pub enum RustString_opaque {}\n+type RustStringRef = *mut RustString_opaque;\n+type RustStringRepr = *mut RefCell<Vec<u8>>;\n+\n+/// Appending to a Rust string -- used by RawRustStringOstream.\n+#[no_mangle]\n+pub unsafe extern \"C\" fn LLVMRustStringWriteImpl(sr: RustStringRef,\n+                                                 ptr: *const c_char,\n+                                                 size: size_t) {\n+    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n+\n+    let sr = sr as RustStringRepr;\n+    (*sr).borrow_mut().extend_from_slice(slice);\n+}\n+\n+pub fn SetInstructionCallConv(instr: ValueRef, cc: CallConv) {\n+    unsafe {\n+        LLVMSetInstructionCallConv(instr, cc as c_uint);\n+    }\n+}\n+pub fn SetFunctionCallConv(fn_: ValueRef, cc: CallConv) {\n+    unsafe {\n+        LLVMSetFunctionCallConv(fn_, cc as c_uint);\n+    }\n+}\n+\n+// Externally visible symbols that might appear in multiple codegen units need to appear in\n+// their own comdat section so that the duplicates can be discarded at link time. This can for\n+// example happen for generics when using multiple codegen units. This function simply uses the\n+// value's name as the comdat value to make sure that it is in a 1-to-1 relationship to the\n+// function.\n+// For more details on COMDAT sections see e.g. http://www.airs.com/blog/archives/52\n+pub fn SetUniqueComdat(llmod: ModuleRef, val: ValueRef) {\n+    unsafe {\n+        LLVMRustSetComdat(llmod, val, LLVMGetValueName(val));\n+    }\n+}\n+\n+pub fn UnsetComdat(val: ValueRef) {\n+    unsafe {\n+        LLVMRustUnsetComdat(val);\n+    }\n+}\n+\n+pub fn SetUnnamedAddr(global: ValueRef, unnamed: bool) {\n+    unsafe {\n+        LLVMSetUnnamedAddr(global, unnamed as Bool);\n+    }\n+}\n+\n+pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n+    unsafe {\n+        LLVMSetThreadLocal(global, is_thread_local as Bool);\n+    }\n+}\n+pub fn set_thread_local_mode(global: ValueRef, mode: ThreadLocalMode) {\n+    unsafe {\n+        LLVMSetThreadLocalMode(global, mode);\n+    }\n+}\n+\n+impl Attribute {\n+    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+        unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), *self) }\n+    }\n+\n+    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n+        unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), *self) }\n+    }\n+\n+    pub fn unapply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+        unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), *self) }\n+    }\n+\n+    pub fn toggle_llfn(&self, idx: AttributePlace, llfn: ValueRef, set: bool) {\n+        if set {\n+            self.apply_llfn(idx, llfn);\n+        } else {\n+            self.unapply_llfn(idx, llfn);\n+        }\n+    }\n+}\n+\n+// Memory-managed interface to target data.\n+\n+struct TargetData {\n+    lltd: TargetDataRef,\n+}\n+\n+impl Drop for TargetData {\n+    fn drop(&mut self) {\n+        unsafe {\n+            LLVMDisposeTargetData(self.lltd);\n+        }\n+    }\n+}\n+\n+fn mk_target_data(string_rep: &str) -> TargetData {\n+    let string_rep = CString::new(string_rep).unwrap();\n+    TargetData { lltd: unsafe { LLVMCreateTargetData(string_rep.as_ptr()) } }\n+}\n+\n+// Memory-managed interface to object files.\n+\n+pub struct ObjectFile {\n+    pub llof: ObjectFileRef,\n+}\n+\n+unsafe impl Send for ObjectFile {}\n+\n+impl ObjectFile {\n+    // This will take ownership of llmb\n+    pub fn new(llmb: MemoryBufferRef) -> Option<ObjectFile> {\n+        unsafe {\n+            let llof = LLVMCreateObjectFile(llmb);\n+            if llof as isize == 0 {\n+                // LLVMCreateObjectFile took ownership of llmb\n+                return None;\n+            }\n+\n+            Some(ObjectFile { llof: llof })\n+        }\n+    }\n+}\n+\n+impl Drop for ObjectFile {\n+    fn drop(&mut self) {\n+        unsafe {\n+            LLVMDisposeObjectFile(self.llof);\n+        }\n+    }\n+}\n+\n+// Memory-managed interface to section iterators.\n+\n+pub struct SectionIter {\n+    pub llsi: SectionIteratorRef,\n+}\n+\n+impl Drop for SectionIter {\n+    fn drop(&mut self) {\n+        unsafe {\n+            LLVMDisposeSectionIterator(self.llsi);\n+        }\n+    }\n+}\n+\n+pub fn mk_section_iter(llof: ObjectFileRef) -> SectionIter {\n+    unsafe { SectionIter { llsi: LLVMGetSections(llof) } }\n+}\n+\n+/// Safe wrapper around `LLVMGetParam`, because segfaults are no fun.\n+pub fn get_param(llfn: ValueRef, index: c_uint) -> ValueRef {\n+    unsafe {\n+        assert!(index < LLVMCountParams(llfn),\n+            \"out of bounds argument access: {} out of {} arguments\", index, LLVMCountParams(llfn));\n+        LLVMGetParam(llfn, index)\n+    }\n+}\n+\n+fn get_params(llfn: ValueRef) -> Vec<ValueRef> {\n+    unsafe {\n+        let num_params = LLVMCountParams(llfn);\n+        (0..num_params).map(|idx| LLVMGetParam(llfn, idx)).collect()\n+    }\n+}\n+\n+pub fn build_string<F>(f: F) -> Option<String>\n+    where F: FnOnce(RustStringRef)\n+{\n+    let mut buf = RefCell::new(Vec::new());\n+    f(&mut buf as RustStringRepr as RustStringRef);\n+    String::from_utf8(buf.into_inner()).ok()\n+}\n+\n+pub unsafe fn twine_to_string(tr: TwineRef) -> String {\n+    build_string(|s| LLVMRustWriteTwineToString(tr, s)).expect(\"got a non-UTF8 Twine from LLVM\")\n+}\n+\n+pub fn last_error() -> Option<String> {\n+    unsafe {\n+        let cstr = LLVMRustGetLastError();\n+        if cstr.is_null() {\n+            None\n+        } else {\n+            let err = CStr::from_ptr(cstr).to_bytes();\n+            let err = String::from_utf8_lossy(err).to_string();\n+            libc::free(cstr as *mut _);\n+            Some(err)\n+        }\n+    }\n+}\n+\n+pub struct OperandBundleDef {\n+    inner: OperandBundleDefRef,\n+}\n+\n+impl OperandBundleDef {\n+    pub fn new(name: &str, vals: &[ValueRef]) -> OperandBundleDef {\n+        let name = CString::new(name).unwrap();\n+        let def = unsafe {\n+            LLVMRustBuildOperandBundleDef(name.as_ptr(), vals.as_ptr(), vals.len() as c_uint)\n+        };\n+        OperandBundleDef { inner: def }\n+    }\n+\n+    pub fn raw(&self) -> OperandBundleDefRef {\n+        self.inner\n+    }\n+}\n+\n+impl Drop for OperandBundleDef {\n+    fn drop(&mut self) {\n+        unsafe {\n+            LLVMRustFreeOperandBundleDef(self.inner);\n+        }\n+    }\n+}"}, {"sha": "441fff5f08c8fddb258923616b2726fda2b00f5e", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=077be49bde25ca92dc03c86c805438609133a82a", "patch": "@@ -73,7 +73,7 @@ unsafe fn configure_llvm(sess: &Session) {\n \n     llvm::LLVMInitializePasses();\n \n-    llvm::initialize_available_targets();\n+    ::rustc_llvm::initialize_available_targets();\n \n     llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n                                  llvm_args.as_ptr());"}, {"sha": "013badb71cc5ab8d1bfe7a965a639e56e3b906f1", "filename": "src/librustc_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2FCargo.toml?ref=077be49bde25ca92dc03c86c805438609133a82a", "patch": "@@ -12,11 +12,6 @@ path = \"lib.rs\"\n static-libstdcpp = []\n emscripten = []\n \n-[dependencies]\n-bitflags = \"1.0\"\n-libc = \"0.2\"\n-rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n-\n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n cc = \"1.0.1\""}, {"sha": "76ec5b53523098481b5ed6f69a1b0c4b37850614", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 315, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=077be49bde25ca92dc03c86c805438609133a82a", "patch": "@@ -8,290 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n-#![allow(non_camel_case_types)]\n-#![allow(non_snake_case)]\n-#![allow(dead_code)]\n-\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n-#![feature(box_syntax)]\n-#![feature(concat_idents)]\n-#![feature(libc)]\n-#![feature(link_args)]\n-#![feature(static_nobundle)]\n-\n // See librustc_cratesio_shim/Cargo.toml for a comment explaining this.\n #[allow(unused_extern_crates)]\n extern crate rustc_cratesio_shim;\n \n-#[macro_use]\n-extern crate bitflags;\n-extern crate libc;\n-\n-pub use self::IntPredicate::*;\n-pub use self::RealPredicate::*;\n-pub use self::TypeKind::*;\n-pub use self::AtomicRmwBinOp::*;\n-pub use self::MetadataType::*;\n-pub use self::CodeGenOptSize::*;\n-pub use self::CallConv::*;\n-pub use self::Linkage::*;\n-\n-use std::str::FromStr;\n-use std::slice;\n-use std::ffi::{CString, CStr};\n-use std::cell::RefCell;\n-use libc::{c_uint, c_char, size_t};\n-\n-pub mod archive_ro;\n-pub mod diagnostic;\n-mod ffi;\n-\n-pub use ffi::*;\n-\n-impl LLVMRustResult {\n-    pub fn into_result(self) -> Result<(), ()> {\n-        match self {\n-            LLVMRustResult::Success => Ok(()),\n-            LLVMRustResult::Failure => Err(()),\n-        }\n-    }\n-}\n-\n-pub fn AddFunctionAttrStringValue(llfn: ValueRef,\n-                                  idx: AttributePlace,\n-                                  attr: &CStr,\n-                                  value: &CStr) {\n-    unsafe {\n-        LLVMRustAddFunctionAttrStringValue(llfn,\n-                                           idx.as_uint(),\n-                                           attr.as_ptr(),\n-                                           value.as_ptr())\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum AttributePlace {\n-    ReturnValue,\n-    Argument(u32),\n-    Function,\n-}\n-\n-impl AttributePlace {\n-    pub fn as_uint(self) -> c_uint {\n-        match self {\n-            AttributePlace::ReturnValue => 0,\n-            AttributePlace::Argument(i) => 1 + i,\n-            AttributePlace::Function => !0,\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-#[repr(C)]\n-pub enum CodeGenOptSize {\n-    CodeGenOptSizeNone = 0,\n-    CodeGenOptSizeDefault = 1,\n-    CodeGenOptSizeAggressive = 2,\n-}\n-\n-impl FromStr for ArchiveKind {\n-    type Err = ();\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"gnu\" => Ok(ArchiveKind::K_GNU),\n-            \"bsd\" => Ok(ArchiveKind::K_BSD),\n-            \"coff\" => Ok(ArchiveKind::K_COFF),\n-            _ => Err(()),\n-        }\n-    }\n-}\n-\n-#[allow(missing_copy_implementations)]\n-pub enum RustString_opaque {}\n-type RustStringRef = *mut RustString_opaque;\n-type RustStringRepr = *mut RefCell<Vec<u8>>;\n-\n-/// Appending to a Rust string -- used by RawRustStringOstream.\n-#[no_mangle]\n-pub unsafe extern \"C\" fn LLVMRustStringWriteImpl(sr: RustStringRef,\n-                                                 ptr: *const c_char,\n-                                                 size: size_t) {\n-    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n-\n-    let sr = sr as RustStringRepr;\n-    (*sr).borrow_mut().extend_from_slice(slice);\n-}\n-\n-pub fn SetInstructionCallConv(instr: ValueRef, cc: CallConv) {\n-    unsafe {\n-        LLVMSetInstructionCallConv(instr, cc as c_uint);\n-    }\n-}\n-pub fn SetFunctionCallConv(fn_: ValueRef, cc: CallConv) {\n-    unsafe {\n-        LLVMSetFunctionCallConv(fn_, cc as c_uint);\n-    }\n-}\n-\n-// Externally visible symbols that might appear in multiple codegen units need to appear in\n-// their own comdat section so that the duplicates can be discarded at link time. This can for\n-// example happen for generics when using multiple codegen units. This function simply uses the\n-// value's name as the comdat value to make sure that it is in a 1-to-1 relationship to the\n-// function.\n-// For more details on COMDAT sections see e.g. http://www.airs.com/blog/archives/52\n-pub fn SetUniqueComdat(llmod: ModuleRef, val: ValueRef) {\n-    unsafe {\n-        LLVMRustSetComdat(llmod, val, LLVMGetValueName(val));\n-    }\n-}\n-\n-pub fn UnsetComdat(val: ValueRef) {\n-    unsafe {\n-        LLVMRustUnsetComdat(val);\n-    }\n-}\n-\n-pub fn SetUnnamedAddr(global: ValueRef, unnamed: bool) {\n-    unsafe {\n-        LLVMSetUnnamedAddr(global, unnamed as Bool);\n-    }\n-}\n-\n-pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n-    unsafe {\n-        LLVMSetThreadLocal(global, is_thread_local as Bool);\n-    }\n-}\n-pub fn set_thread_local_mode(global: ValueRef, mode: ThreadLocalMode) {\n-    unsafe {\n-        LLVMSetThreadLocalMode(global, mode);\n-    }\n-}\n-\n-impl Attribute {\n-    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n-        unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), *self) }\n-    }\n-\n-    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n-        unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), *self) }\n-    }\n-\n-    pub fn unapply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n-        unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), *self) }\n-    }\n-\n-    pub fn toggle_llfn(&self, idx: AttributePlace, llfn: ValueRef, set: bool) {\n-        if set {\n-            self.apply_llfn(idx, llfn);\n-        } else {\n-            self.unapply_llfn(idx, llfn);\n-        }\n-    }\n-}\n-\n-// Memory-managed interface to target data.\n-\n-struct TargetData {\n-    lltd: TargetDataRef,\n-}\n-\n-impl Drop for TargetData {\n-    fn drop(&mut self) {\n-        unsafe {\n-            LLVMDisposeTargetData(self.lltd);\n-        }\n-    }\n-}\n-\n-fn mk_target_data(string_rep: &str) -> TargetData {\n-    let string_rep = CString::new(string_rep).unwrap();\n-    TargetData { lltd: unsafe { LLVMCreateTargetData(string_rep.as_ptr()) } }\n-}\n-\n-// Memory-managed interface to object files.\n-\n-pub struct ObjectFile {\n-    pub llof: ObjectFileRef,\n-}\n-\n-unsafe impl Send for ObjectFile {}\n-\n-impl ObjectFile {\n-    // This will take ownership of llmb\n-    pub fn new(llmb: MemoryBufferRef) -> Option<ObjectFile> {\n-        unsafe {\n-            let llof = LLVMCreateObjectFile(llmb);\n-            if llof as isize == 0 {\n-                // LLVMCreateObjectFile took ownership of llmb\n-                return None;\n-            }\n-\n-            Some(ObjectFile { llof: llof })\n-        }\n-    }\n-}\n-\n-impl Drop for ObjectFile {\n-    fn drop(&mut self) {\n-        unsafe {\n-            LLVMDisposeObjectFile(self.llof);\n-        }\n-    }\n-}\n-\n-// Memory-managed interface to section iterators.\n-\n-pub struct SectionIter {\n-    pub llsi: SectionIteratorRef,\n-}\n-\n-impl Drop for SectionIter {\n-    fn drop(&mut self) {\n-        unsafe {\n-            LLVMDisposeSectionIterator(self.llsi);\n-        }\n-    }\n-}\n-\n-pub fn mk_section_iter(llof: ObjectFileRef) -> SectionIter {\n-    unsafe { SectionIter { llsi: LLVMGetSections(llof) } }\n-}\n-\n-/// Safe wrapper around `LLVMGetParam`, because segfaults are no fun.\n-pub fn get_param(llfn: ValueRef, index: c_uint) -> ValueRef {\n-    unsafe {\n-        assert!(index < LLVMCountParams(llfn),\n-            \"out of bounds argument access: {} out of {} arguments\", index, LLVMCountParams(llfn));\n-        LLVMGetParam(llfn, index)\n-    }\n-}\n-\n-fn get_params(llfn: ValueRef) -> Vec<ValueRef> {\n-    unsafe {\n-        let num_params = LLVMCountParams(llfn);\n-\n-        (0..num_params).map(|idx| LLVMGetParam(llfn, idx)).collect()\n-    }\n-}\n-\n-pub fn build_string<F>(f: F) -> Option<String>\n-    where F: FnOnce(RustStringRef)\n-{\n-    let mut buf = RefCell::new(Vec::new());\n-    f(&mut buf as RustStringRepr as RustStringRef);\n-    String::from_utf8(buf.into_inner()).ok()\n-}\n-\n-pub unsafe fn twine_to_string(tr: TwineRef) -> String {\n-    build_string(|s| LLVMRustWriteTwineToString(tr, s)).expect(\"got a non-UTF8 Twine from LLVM\")\n-}\n+// NOTE: This crate only exists to allow linking on mingw targets.\n \n+/// Initialize targets enabled by the build script via `cfg(llvm_component = \"...\")`.\n+/// NB: this function can't be moved to `rustc_codegen_llvm` because of the `cfg`s.\n pub fn initialize_available_targets() {\n     macro_rules! init_target(\n         ($cfg:meta, $($method:ident),*) => { {\n@@ -383,43 +111,3 @@ pub fn initialize_available_targets() {\n                  LLVMInitializeWebAssemblyTargetMC,\n                  LLVMInitializeWebAssemblyAsmPrinter);\n }\n-\n-pub fn last_error() -> Option<String> {\n-    unsafe {\n-        let cstr = LLVMRustGetLastError();\n-        if cstr.is_null() {\n-            None\n-        } else {\n-            let err = CStr::from_ptr(cstr).to_bytes();\n-            let err = String::from_utf8_lossy(err).to_string();\n-            libc::free(cstr as *mut _);\n-            Some(err)\n-        }\n-    }\n-}\n-\n-pub struct OperandBundleDef {\n-    inner: OperandBundleDefRef,\n-}\n-\n-impl OperandBundleDef {\n-    pub fn new(name: &str, vals: &[ValueRef]) -> OperandBundleDef {\n-        let name = CString::new(name).unwrap();\n-        let def = unsafe {\n-            LLVMRustBuildOperandBundleDef(name.as_ptr(), vals.as_ptr(), vals.len() as c_uint)\n-        };\n-        OperandBundleDef { inner: def }\n-    }\n-\n-    pub fn raw(&self) -> OperandBundleDefRef {\n-        self.inner\n-    }\n-}\n-\n-impl Drop for OperandBundleDef {\n-    fn drop(&mut self) {\n-        unsafe {\n-            LLVMRustFreeOperandBundleDef(self.inner);\n-        }\n-    }\n-}"}, {"sha": "a50a5a2d1cbe711014b1587563da7b3782177a81", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/077be49bde25ca92dc03c86c805438609133a82a/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=077be49bde25ca92dc03c86c805438609133a82a", "patch": "@@ -15,11 +15,7 @@\n //! is really just odds-and-ends relating to code gen and linking.\n //! This crate mostly exists to make rustc smaller, so we might put\n //! more 'stuff' here in the future.  It does not have a dependency on\n-//! rustc_llvm.\n-//!\n-//! FIXME: Split this into two crates: one that has deps on syntax, and\n-//! one that doesn't; the one that doesn't might get decent parallel\n-//! build speedups.\n+//! LLVM.\n \n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\","}, {"sha": "49a4962858ca733d0a65ddd8ad376a25798e1512", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/077be49bde25ca92dc03c86c805438609133a82a/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/077be49bde25ca92dc03c86c805438609133a82a/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=077be49bde25ca92dc03c86c805438609133a82a", "patch": "@@ -148,7 +148,7 @@ LLVMRustArchiveChildName(LLVMRustArchiveChildConstRef Child, size_t *Size) {\n #if LLVM_VERSION_GE(4, 0)\n   Expected<StringRef> NameOrErr = Child->getName();\n   if (!NameOrErr) {\n-    // rustc_llvm currently doesn't use this error string, but it might be\n+    // rustc_codegen_llvm currently doesn't use this error string, but it might be\n     // useful in the future, and in the mean time this tells LLVM that the\n     // error was not ignored and that it shouldn't abort the process.\n     LLVMRustSetLastError(toString(NameOrErr.takeError()).c_str());"}]}