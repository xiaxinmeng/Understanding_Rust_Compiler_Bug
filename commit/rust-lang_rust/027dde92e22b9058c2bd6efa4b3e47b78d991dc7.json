{"sha": "027dde92e22b9058c2bd6efa4b3e47b78d991dc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyN2RkZTkyZTIyYjkwNThjMmJkNmVmYTRiM2U0N2I3OGQ5OTFkYzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-20T16:37:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-20T16:37:32Z"}, "message": "Auto merge of #3781 - uniphil:write_with_newline_false_positive, r=oli-obk\n\nDon't check [print/write]_with_newline on raw strings\n\nSome tests for #3778 and some maybe-not-the-greatest code that passes those tests!\n\nI didn't run `fmt` because a) it doesn't seem to install on nightly for me, and b) on stable it wanted to apply formatting to over 90 files. Happy to make any tweaks though!\n\nI suspect this contribution may require more than just tweaks. I'm still sort of new to rust so it may not be idiomatic, and the specific approach I took feels a little heavy-handed and brittle. I'm happy to make changes with some guidance, or equally happy if this gives a starting place for someone else to do it better :)", "tree": {"sha": "fc34aacf4005a5c6b094e2acc2af80221144e0bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc34aacf4005a5c6b094e2acc2af80221144e0bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/027dde92e22b9058c2bd6efa4b3e47b78d991dc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/027dde92e22b9058c2bd6efa4b3e47b78d991dc7", "html_url": "https://github.com/rust-lang/rust/commit/027dde92e22b9058c2bd6efa4b3e47b78d991dc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/027dde92e22b9058c2bd6efa4b3e47b78d991dc7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5d8d7bca50a29f1fe25482b8417704febd7ef35", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5d8d7bca50a29f1fe25482b8417704febd7ef35", "html_url": "https://github.com/rust-lang/rust/commit/d5d8d7bca50a29f1fe25482b8417704febd7ef35"}, {"sha": "ef72b2cac0c9e0715d384711b3f08567c013300d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef72b2cac0c9e0715d384711b3f08567c013300d", "html_url": "https://github.com/rust-lang/rust/commit/ef72b2cac0c9e0715d384711b3f08567c013300d"}], "stats": {"total": 140, "additions": 120, "deletions": 20}, "files": [{"sha": "012c34e9b535586c602bd7fa18ba0cd75630bf66", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/027dde92e22b9058c2bd6efa4b3e47b78d991dc7/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027dde92e22b9058c2bd6efa4b3e47b78d991dc7/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=027dde92e22b9058c2bd6efa4b3e47b78d991dc7", "patch": "@@ -5,7 +5,7 @@ use rustc_errors::Applicability;\n use std::borrow::Cow;\n use syntax::ast::*;\n use syntax::parse::{parser, token};\n-use syntax::tokenstream::TokenStream;\n+use syntax::tokenstream::{TokenStream, TokenTree};\n \n /// **What it does:** This lint warns when you use `println!(\"\")` to\n /// print a newline.\n@@ -200,8 +200,8 @@ impl EarlyLintPass for Pass {\n             }\n         } else if mac.node.path == \"print\" {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `print!`\");\n-            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false).0 {\n-                if check_newlines(&fmtstr) {\n+            if let (Some(fmtstr), _, is_raw) = check_tts(cx, &mac.node.tts, false) {\n+                if check_newlines(&fmtstr, is_raw) {\n                     span_lint(\n                         cx,\n                         PRINT_WITH_NEWLINE,\n@@ -212,8 +212,8 @@ impl EarlyLintPass for Pass {\n                 }\n             }\n         } else if mac.node.path == \"write\" {\n-            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true).0 {\n-                if check_newlines(&fmtstr) {\n+            if let (Some(fmtstr), _, is_raw) = check_tts(cx, &mac.node.tts, true) {\n+                if check_newlines(&fmtstr, is_raw) {\n                     span_lint(\n                         cx,\n                         WRITE_WITH_NEWLINE,\n@@ -252,8 +252,9 @@ impl EarlyLintPass for Pass {\n }\n \n /// Checks the arguments of `print[ln]!` and `write[ln]!` calls. It will return a tuple of two\n-/// options. The first part of the tuple is `format_str` of the macros. The second part of the tuple\n-/// is in the `write[ln]!` case the expression the `format_str` should be written to.\n+/// options and a bool. The first part of the tuple is `format_str` of the macros. The second part\n+/// of the tuple is in the `write[ln]!` case the expression the `format_str` should be written to.\n+/// The final part is a boolean flag indicating if the string is a raw string.\n ///\n /// Example:\n ///\n@@ -263,34 +264,49 @@ impl EarlyLintPass for Pass {\n /// ```\n /// will return\n /// ```rust,ignore\n-/// (Some(\"string to write: {}\"), Some(buf))\n+/// (Some(\"string to write: {}\"), Some(buf), false)\n /// ```\n-fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (Option<String>, Option<Expr>) {\n+fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (Option<String>, Option<Expr>, bool) {\n     use fmt_macros::*;\n     let tts = tts.clone();\n+    let mut is_raw = false;\n+    if let TokenStream(Some(tokens)) = &tts {\n+        for token in tokens.iter() {\n+            if let (TokenTree::Token(_, token::Token::Literal(lit, _)), _) = token {\n+                match lit {\n+                    token::Lit::Str_(_) => break,\n+                    token::Lit::StrRaw(_, _) => {\n+                        is_raw = true;\n+                        break;\n+                    },\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n     let mut parser = parser::Parser::new(&cx.sess.parse_sess, tts, None, false, false);\n     let mut expr: Option<Expr> = None;\n     if is_write {\n         expr = match parser.parse_expr().map_err(|mut err| err.cancel()) {\n             Ok(p) => Some(p.into_inner()),\n-            Err(_) => return (None, None),\n+            Err(_) => return (None, None, is_raw),\n         };\n         // might be `writeln!(foo)`\n         if parser.expect(&token::Comma).map_err(|mut err| err.cancel()).is_err() {\n-            return (None, expr);\n+            return (None, expr, is_raw);\n         }\n     }\n \n     let fmtstr = match parser.parse_str().map_err(|mut err| err.cancel()) {\n         Ok(token) => token.0.to_string(),\n-        Err(_) => return (None, expr),\n+        Err(_) => return (None, expr, is_raw),\n     };\n     let tmp = fmtstr.clone();\n     let mut args = vec![];\n     let mut fmt_parser = Parser::new(&tmp, None, Vec::new(), false);\n     while let Some(piece) = fmt_parser.next() {\n         if !fmt_parser.errors.is_empty() {\n-            return (None, expr);\n+            return (None, expr, is_raw);\n         }\n         if let Piece::NextArgument(arg) = piece {\n             if arg.format.ty == \"?\" {\n@@ -312,11 +328,11 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (O\n             ty: \"\",\n         };\n         if !parser.eat(&token::Comma) {\n-            return (Some(fmtstr), expr);\n+            return (Some(fmtstr), expr, is_raw);\n         }\n         let token_expr = match parser.parse_expr().map_err(|mut err| err.cancel()) {\n             Ok(expr) => expr,\n-            Err(_) => return (Some(fmtstr), None),\n+            Err(_) => return (Some(fmtstr), None, is_raw),\n         };\n         match &token_expr.node {\n             ExprKind::Lit(_) => {\n@@ -366,7 +382,14 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (O\n }\n \n // Checks if `s` constains a single newline that terminates it\n-fn check_newlines(s: &str) -> bool {\n+// Literal and escaped newlines are both checked (only literal for raw strings)\n+fn check_newlines(s: &str, is_raw: bool) -> bool {\n+    if s.ends_with('\\n') {\n+        return true;\n+    } else if is_raw {\n+        return false;\n+    }\n+\n     if s.len() < 2 {\n         return false;\n     }"}, {"sha": "1c219ecb325b13ab8aeb9c3fc7d1d06260b0024c", "filename": "tests/ui/print_with_newline.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/027dde92e22b9058c2bd6efa4b3e47b78d991dc7/tests%2Fui%2Fprint_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027dde92e22b9058c2bd6efa4b3e47b78d991dc7/tests%2Fui%2Fprint_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_with_newline.rs?ref=027dde92e22b9058c2bd6efa4b3e47b78d991dc7", "patch": "@@ -21,4 +21,22 @@ fn main() {\n     print!(\"Hello {} {}\\n\\n\", \"world\", \"#2\");\n     println!(\"\\ndon't\\nwarn\\nfor\\nmultiple\\nnewlines\\n\"); // #3126\n     println!(\"\\nbla\\n\\n\"); // #3126\n+\n+    // Escaping\n+    print!(\"\\\\n\"); // #3514\n+    print!(\"\\\\\\n\"); // should fail\n+    print!(\"\\\\\\\\n\");\n+\n+    // Raw strings\n+    print!(r\"\\n\"); // #3778\n+\n+    // Literal newlines should also fail\n+    print!(\n+        \"\n+\"\n+    );\n+    print!(\n+        r\"\n+\"\n+    );\n }"}, {"sha": "ff89b0d3fd446762d41ac189428422589b8744a4", "filename": "tests/ui/print_with_newline.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/027dde92e22b9058c2bd6efa4b3e47b78d991dc7/tests%2Fui%2Fprint_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027dde92e22b9058c2bd6efa4b3e47b78d991dc7/tests%2Fui%2Fprint_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_with_newline.stderr?ref=027dde92e22b9058c2bd6efa4b3e47b78d991dc7", "patch": "@@ -24,5 +24,29 @@ error: using `print!()` with a format string that ends in a single newline, cons\n LL |     print!(\"{}/n\", 1265);\n    |     ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: using `print!()` with a format string that ends in a single newline, consider using `println!()` instead\n+  --> $DIR/print_with_newline.rs:27:5\n+   |\n+LL |     print!(\"//n\"); // should fail\n+   |     ^^^^^^^^^^^^^^\n+\n+error: using `print!()` with a format string that ends in a single newline, consider using `println!()` instead\n+  --> $DIR/print_with_newline.rs:34:5\n+   |\n+LL | /     print!(\n+LL | |         \"\n+LL | | \"\n+LL | |     );\n+   | |_____^\n+\n+error: using `print!()` with a format string that ends in a single newline, consider using `println!()` instead\n+  --> $DIR/print_with_newline.rs:38:5\n+   |\n+LL | /     print!(\n+LL | |         r\"\n+LL | | \"\n+LL | |     );\n+   | |_____^\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "dd80dc0cf9c5e4cd04e853f324699742d0dbeb08", "filename": "tests/ui/write_with_newline.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/027dde92e22b9058c2bd6efa4b3e47b78d991dc7/tests%2Fui%2Fwrite_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027dde92e22b9058c2bd6efa4b3e47b78d991dc7/tests%2Fui%2Fwrite_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.rs?ref=027dde92e22b9058c2bd6efa4b3e47b78d991dc7", "patch": "@@ -29,6 +29,21 @@ fn main() {\n \n     // Escaping\n     write!(&mut v, \"\\\\n\"); // #3514\n-    write!(&mut v, \"\\\\\\n\");\n+    write!(&mut v, \"\\\\\\n\"); // should fail\n     write!(&mut v, \"\\\\\\\\n\");\n+\n+    // Raw strings\n+    write!(&mut v, r\"\\n\"); // #3778\n+\n+    // Literal newlines should also fail\n+    write!(\n+        &mut v,\n+        \"\n+\"\n+    );\n+    write!(\n+        &mut v,\n+        r\"\n+\"\n+    );\n }"}, {"sha": "3a31f61a277cfe93814a356ea305b6b505ce159f", "filename": "tests/ui/write_with_newline.stderr", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/027dde92e22b9058c2bd6efa4b3e47b78d991dc7/tests%2Fui%2Fwrite_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027dde92e22b9058c2bd6efa4b3e47b78d991dc7/tests%2Fui%2Fwrite_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.stderr?ref=027dde92e22b9058c2bd6efa4b3e47b78d991dc7", "patch": "@@ -27,8 +27,28 @@ LL |     write!(&mut v, \"{}/n\", 1265);\n error: using `write!()` with a format string that ends in a single newline, consider using `writeln!()` instead\n   --> $DIR/write_with_newline.rs:32:5\n    |\n-LL |     write!(&mut v, \"//n\");\n+LL |     write!(&mut v, \"//n\"); // should fail\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 5 previous errors\n+error: using `write!()` with a format string that ends in a single newline, consider using `writeln!()` instead\n+  --> $DIR/write_with_newline.rs:39:5\n+   |\n+LL | /     write!(\n+LL | |         &mut v,\n+LL | |         \"\n+LL | | \"\n+LL | |     );\n+   | |_____^\n+\n+error: using `write!()` with a format string that ends in a single newline, consider using `writeln!()` instead\n+  --> $DIR/write_with_newline.rs:44:5\n+   |\n+LL | /     write!(\n+LL | |         &mut v,\n+LL | |         r\"\n+LL | | \"\n+LL | |     );\n+   | |_____^\n+\n+error: aborting due to 7 previous errors\n "}]}