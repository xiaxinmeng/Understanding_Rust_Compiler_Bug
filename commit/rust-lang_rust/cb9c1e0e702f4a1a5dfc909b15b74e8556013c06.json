{"sha": "cb9c1e0e702f4a1a5dfc909b15b74e8556013c06", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiOWMxZTBlNzAyZjRhMWE1ZGZjOTA5YjE1Yjc0ZTg1NTYwMTNjMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-17T04:42:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-17T04:42:32Z"}, "message": "auto merge of #16498 : Kimundi/rust/inline-utf-encoding, r=alexcrichton\n\nThe first commit improves code generation through a few changes:\r\n- The `#[inline]` attributes allow llvm to constant fold the encoding step away in certain situations. For example, code like this changes from a call to `encode_utf8` in a inner loop to the pushing of a byte constant:\r\n\r\n ```rust\r\nlet mut s = String::new();\r\nfor _ in range(0u, 21) {\r\n        s.push_char('a');\r\n}\r\n```\r\n- Both methods changed their semantic from causing run time failure if the target buffer is not large enough to returning `None` instead. This makes llvm no longer emit code for causing failure for these methods.\r\n- A few debug `assert!()` calls got removed because they affected code generation due to unwinding, and where basically unnecessary with today's sound handling of `char` as a Unicode scalar value.\r\n\r\n~~The second commit is optional. It changes the methods from regular indexing with the `dst[i]` syntax to unsafe indexing with `dst.unsafe_mut_ref(i)`. This does not change code generation directly - in both cases llvm is smart enough to see that there can never be an out-of-bounds access. But it makes it emit a `nounwind` attribute for the function. \r\nHowever, I'm not sure whether that is a real improvement, so if there is any objection to this I'll remove the commit.~~\r\n\r\nThis changes how the methods behave on a too small buffer, so this is a \r\n\r\n[breaking-change]", "tree": {"sha": "ad975c7a4d46d39356072b693473e4e9b37159f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad975c7a4d46d39356072b693473e4e9b37159f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06", "html_url": "https://github.com/rust-lang/rust/commit/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a5654f960ca1f979e2ddf1efa57fa750dbd1dff", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a5654f960ca1f979e2ddf1efa57fa750dbd1dff", "html_url": "https://github.com/rust-lang/rust/commit/4a5654f960ca1f979e2ddf1efa57fa750dbd1dff"}, {"sha": "13079c1a85c2f3391966cc108a48f2313596d78d", "url": "https://api.github.com/repos/rust-lang/rust/commits/13079c1a85c2f3391966cc108a48f2313596d78d", "html_url": "https://github.com/rust-lang/rust/commit/13079c1a85c2f3391966cc108a48f2313596d78d"}], "stats": {"total": 89, "additions": 47, "deletions": 42}, "files": [{"sha": "b2be96621106d99a2b19646e3381dd55a6c10116", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=cb9c1e0e702f4a1a5dfc909b15b74e8556013c06", "patch": "@@ -1682,7 +1682,7 @@ mod tests {\n     fn test_chars_decoding() {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n-            let len = c.encode_utf8(bytes);\n+            let len = c.encode_utf8(bytes).unwrap_or(0);\n             let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n             if Some(c) != s.chars().next() {\n                 fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n@@ -1694,7 +1694,7 @@ mod tests {\n     fn test_chars_rev_decoding() {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n-            let len = c.encode_utf8(bytes);\n+            let len = c.encode_utf8(bytes).unwrap_or(0);\n             let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n             if Some(c) != s.chars().rev().next() {\n                 fail!(\"character {:x}={} does not decode correctly\", c as u32, c);"}, {"sha": "af4ac01bc6d78a581e84ee5b5b1023f5d739da0f", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=cb9c1e0e702f4a1a5dfc909b15b74e8556013c06", "patch": "@@ -502,7 +502,7 @@ impl String {\n                 data: self.vec.as_ptr().offset(cur_len as int),\n                 len: 4,\n             };\n-            let used = ch.encode_utf8(mem::transmute(slice));\n+            let used = ch.encode_utf8(mem::transmute(slice)).unwrap_or(0);\n             self.vec.set_len(cur_len + used);\n         }\n     }"}, {"sha": "4e9a72c6af544c95974646b77c9420bdae10640c", "filename": "src/libcore/char.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=cb9c1e0e702f4a1a5dfc909b15b74e8556013c06", "patch": "@@ -18,6 +18,7 @@\n use mem::transmute;\n use option::{None, Option, Some};\n use iter::range_step;\n+use collections::Collection;\n \n // UTF-8 ranges and tags for encoding characters\n static TAG_CONT: u8    = 0b1000_0000u8;\n@@ -27,7 +28,6 @@ static TAG_FOUR_B: u8  = 0b1111_0000u8;\n static MAX_ONE_B: u32   =     0x80u32;\n static MAX_TWO_B: u32   =    0x800u32;\n static MAX_THREE_B: u32 =  0x10000u32;\n-static MAX_FOUR_B:  u32 = 0x200000u32;\n \n /*\n     Lu  Uppercase_Letter        an uppercase letter\n@@ -217,14 +217,14 @@ pub fn escape_default(c: char, f: |char|) {\n }\n \n /// Returns the amount of bytes this `char` would need if encoded in UTF-8\n+#[inline]\n pub fn len_utf8_bytes(c: char) -> uint {\n     let code = c as u32;\n     match () {\n         _ if code < MAX_ONE_B   => 1u,\n         _ if code < MAX_TWO_B   => 2u,\n         _ if code < MAX_THREE_B => 3u,\n-        _ if code < MAX_FOUR_B  => 4u,\n-        _                       => fail!(\"invalid character!\"),\n+        _  => 4u,\n     }\n }\n \n@@ -297,21 +297,19 @@ pub trait Char {\n     /// UTF-8.\n     fn len_utf8_bytes(&self) -> uint;\n \n-    /// Encodes this character as UTF-8 into the provided byte buffer.\n-    ///\n-    /// The buffer must be at least 4 bytes long or a runtime failure may\n-    /// occur.\n+    /// Encodes this character as UTF-8 into the provided byte buffer,\n+    /// and then returns the number of bytes written.\n     ///\n-    /// This will then return the number of bytes written to the slice.\n-    fn encode_utf8(&self, dst: &mut [u8]) -> uint;\n+    /// If the buffer is not large enough, nothing will be written into it\n+    /// and a `None` will be returned.\n+    fn encode_utf8(&self, dst: &mut [u8]) -> Option<uint>;\n \n-    /// Encodes this character as UTF-16 into the provided `u16` buffer.\n+    /// Encodes this character as UTF-16 into the provided `u16` buffer,\n+    /// and then returns the number of `u16`s written.\n     ///\n-    /// The buffer must be at least 2 elements long or a runtime failure may\n-    /// occur.\n-    ///\n-    /// This will then return the number of `u16`s written to the slice.\n-    fn encode_utf16(&self, dst: &mut [u16]) -> uint;\n+    /// If the buffer is not large enough, nothing will be written into it\n+    /// and a `None` will be returned.\n+    fn encode_utf16(&self, dst: &mut [u16]) -> Option<uint>;\n }\n \n impl Char for char {\n@@ -325,45 +323,52 @@ impl Char for char {\n \n     fn escape_default(&self, f: |char|) { escape_default(*self, f) }\n \n+    #[inline]\n     fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n \n-    fn encode_utf8<'a>(&self, dst: &'a mut [u8]) -> uint {\n+    #[inline]\n+    fn encode_utf8<'a>(&self, dst: &'a mut [u8]) -> Option<uint> {\n+        // Marked #[inline] to allow llvm optimizing it away\n         let code = *self as u32;\n-        if code < MAX_ONE_B {\n+        if code < MAX_ONE_B && dst.len() >= 1 {\n             dst[0] = code as u8;\n-            1\n-        } else if code < MAX_TWO_B {\n+            Some(1)\n+        } else if code < MAX_TWO_B && dst.len() >= 2 {\n             dst[0] = (code >> 6u & 0x1F_u32) as u8 | TAG_TWO_B;\n             dst[1] = (code & 0x3F_u32) as u8 | TAG_CONT;\n-            2\n-        } else if code < MAX_THREE_B {\n+            Some(2)\n+        } else if code < MAX_THREE_B && dst.len() >= 3  {\n             dst[0] = (code >> 12u & 0x0F_u32) as u8 | TAG_THREE_B;\n             dst[1] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n             dst[2] = (code & 0x3F_u32) as u8 | TAG_CONT;\n-            3\n-        } else {\n+            Some(3)\n+        } else if dst.len() >= 4 {\n             dst[0] = (code >> 18u & 0x07_u32) as u8 | TAG_FOUR_B;\n             dst[1] = (code >> 12u & 0x3F_u32) as u8 | TAG_CONT;\n             dst[2] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n             dst[3] = (code & 0x3F_u32) as u8 | TAG_CONT;\n-            4\n+            Some(4)\n+        } else {\n+            None\n         }\n     }\n \n-    fn encode_utf16(&self, dst: &mut [u16]) -> uint {\n+    #[inline]\n+    fn encode_utf16(&self, dst: &mut [u16]) -> Option<uint> {\n+        // Marked #[inline] to allow llvm optimizing it away\n         let mut ch = *self as u32;\n-        if (ch & 0xFFFF_u32) == ch {\n+        if (ch & 0xFFFF_u32) == ch  && dst.len() >= 1 {\n             // The BMP falls through (assuming non-surrogate, as it should)\n-            assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n             dst[0] = ch as u16;\n-            1\n-        } else {\n+            Some(1)\n+        } else if dst.len() >= 2 {\n             // Supplementary planes break into surrogates.\n-            assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n             ch -= 0x1_0000_u32;\n             dst[0] = 0xD800_u16 | ((ch >> 10) as u16);\n             dst[1] = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-            2\n+            Some(2)\n+        } else {\n+            None\n         }\n     }\n }"}, {"sha": "85a289f1a303a9cdf98e52bc278a4bc473953f3a", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=cb9c1e0e702f4a1a5dfc909b15b74e8556013c06", "patch": "@@ -366,7 +366,7 @@ impl<'a> Formatter<'a> {\n         let write_prefix = |f: &mut Formatter| {\n             for c in sign.move_iter() {\n                 let mut b = [0, ..4];\n-                let n = c.encode_utf8(b);\n+                let n = c.encode_utf8(b).unwrap_or(0);\n                 try!(f.buf.write(b.slice_to(n)));\n             }\n             if prefixed { f.buf.write(prefix.as_bytes()) }\n@@ -467,7 +467,7 @@ impl<'a> Formatter<'a> {\n             try!(f(self));\n         }\n         let mut fill = [0u8, ..4];\n-        let len = self.fill.encode_utf8(fill);\n+        let len = self.fill.encode_utf8(fill).unwrap_or(0);\n         for _ in range(0, padding) {\n             try!(self.buf.write(fill.slice_to(len)));\n         }\n@@ -545,7 +545,7 @@ impl Char for char {\n         use char::Char;\n \n         let mut utf8 = [0u8, ..4];\n-        let amt = self.encode_utf8(utf8);\n+        let amt = self.encode_utf8(utf8).unwrap_or(0);\n         let s: &str = unsafe { mem::transmute(utf8.slice_to(amt)) };\n         secret_string(&s, f)\n     }"}, {"sha": "095605326c7f5a4dd6b8347ef91b9d889d6670d4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=cb9c1e0e702f4a1a5dfc909b15b74e8556013c06", "patch": "@@ -30,7 +30,7 @@ use iter::range;\n use num::{CheckedMul, Saturating};\n use option::{Option, None, Some};\n use raw::Repr;\n-use slice::ImmutableSlice;\n+use slice::{ImmutableSlice, MutableSlice};\n use slice;\n use uint;\n \n@@ -646,7 +646,7 @@ impl<'a> Iterator<u16> for Utf16CodeUnits<'a> {\n \n         let mut buf = [0u16, ..2];\n         self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(buf /* as mut slice! */);\n+            let n = ch.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n             if n == 2 { self.extra = buf[1]; }\n             buf[0]\n         })"}, {"sha": "8c3f4706a3cc57109484f0fce7ad6e85e9c70b6a", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=cb9c1e0e702f4a1a5dfc909b15b74e8556013c06", "patch": "@@ -173,7 +173,7 @@ fn test_escape_unicode() {\n fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n         let mut buf = [0u8, ..4];\n-        let n = input.encode_utf8(buf /* as mut slice! */);\n+        let n = input.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n         assert_eq!(buf.slice_to(n), expect);\n     }\n \n@@ -187,7 +187,7 @@ fn test_encode_utf8() {\n fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n         let mut buf = [0u16, ..2];\n-        let n = input.encode_utf16(buf /* as mut slice! */);\n+        let n = input.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n         assert_eq!(buf.slice_to(n), expect);\n     }\n "}, {"sha": "e93a958acc616e66ee59afd7297d1904eb61074f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb9c1e0e702f4a1a5dfc909b15b74e8556013c06/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=cb9c1e0e702f4a1a5dfc909b15b74e8556013c06", "patch": "@@ -1110,7 +1110,7 @@ pub trait Writer {\n     #[inline]\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8, ..4];\n-        let n = c.encode_utf8(buf.as_mut_slice());\n+        let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n         self.write(buf.slice_to(n))\n     }\n "}]}