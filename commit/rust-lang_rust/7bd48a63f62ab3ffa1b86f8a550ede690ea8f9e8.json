{"sha": "7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZDQ4YTYzZjYyYWIzZmZhMWI4NmY4YTU1MGVkZTY5MGVhOGY5ZTg=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-08-01T00:32:49Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-08-01T00:32:49Z"}, "message": "use static data for namespace recognition", "tree": {"sha": "143347f8cf847e5908851fd03525d0b289c7fa06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/143347f8cf847e5908851fd03525d0b289c7fa06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8", "html_url": "https://github.com/rust-lang/rust/commit/7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbdb6bd939fea04360d2a21fcc896b8bae4c8e31", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbdb6bd939fea04360d2a21fcc896b8bae4c8e31", "html_url": "https://github.com/rust-lang/rust/commit/cbdb6bd939fea04360d2a21fcc896b8bae4c8e31"}], "stats": {"total": 105, "additions": 49, "deletions": 56}, "files": [{"sha": "24fa38d5e833605764971a751d88579faeb6ed1e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8", "patch": "@@ -1083,7 +1083,6 @@ dependencies = [\n  \"indexmap\",\n  \"itertools\",\n  \"log\",\n- \"once_cell\",\n  \"oorandom\",\n  \"pulldown-cmark\",\n  \"pulldown-cmark-to-cmark\",\n@@ -1103,6 +1102,7 @@ dependencies = [\n  \"rustc-hash\",\n  \"stdx\",\n  \"test_utils\",\n+ \"url\",\n ]\n \n [[package]]"}, {"sha": "fdbd7566f8ba3d336e393f694ea9552a0fc0d8af", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8", "patch": "@@ -21,7 +21,6 @@ url = \"*\"\n pulldown-cmark-to-cmark = \"4.0.2\"\n pulldown-cmark = \"0.7.0\"\n oorandom = \"11.1.2\"\n-once_cell = \"1\"\n \n stdx = { path = \"../stdx\" }\n "}, {"sha": "f6854a18d2a66ff38a8827c6cadf0e6c2fccd4fa", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 48, "deletions": 54, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=7bd48a63f62ab3ffa1b86f8a550ede690ea8f9e8", "patch": "@@ -1,16 +1,11 @@\n-use std::collections::{HashMap, HashSet};\n-use std::{\n-    iter::{once, FromIterator},\n-    sync::Mutex,\n-};\n+use std::iter::once;\n \n use hir::{\n     db::DefDatabase, Adt, AsAssocItem, AsName, AssocItemContainer, AttrDef, Crate, Documentation,\n     FieldSource, HasSource, HirDisplay, Hygiene, ItemInNs, ModPath, Module, ModuleDef,\n     ModuleSource, Semantics,\n };\n use itertools::Itertools;\n-use once_cell::sync::Lazy;\n use pulldown_cmark::{CowStr, Event, Options, Parser, Tag};\n use pulldown_cmark_to_cmark::cmark;\n use ra_db::SourceDatabase;\n@@ -402,10 +397,9 @@ fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) ->\n                 try_resolve_path(db, definition, &target).map(|target| (target, title.to_string()))\n             });\n \n-            if let Some((target, title)) = resolved {\n-                (target, title)\n-            } else {\n-                (target.to_string(), title.to_string())\n+            match resolved {\n+                Some((target, title)) => (target, title),\n+                None => (target.to_string(), title.to_string()),\n             }\n         }\n     });\n@@ -421,65 +415,61 @@ enum Namespace {\n     Macros,\n }\n \n-static NS_MAP: Lazy<\n-    HashMap<Namespace, (HashSet<&'static &'static str>, HashSet<&'static &'static str>)>,\n-> = Lazy::new(|| {\n-    let mut map = HashMap::new();\n-    map.insert(Namespace::Types, (HashSet::new(), HashSet::new()));\n-    map.insert(\n-        Namespace::Values,\n-        (\n-            HashSet::from_iter(\n-                [\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"].iter(),\n-            ),\n-            HashSet::from_iter([\"()\"].iter()),\n-        ),\n-    );\n-    map.insert(\n-        Namespace::Macros,\n-        (HashSet::from_iter([\"macro\"].iter()), HashSet::from_iter([\"!\"].iter())),\n-    );\n-    map\n-});\n+static TYPES: ([&str; 7], [&str; 0]) =\n+    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\"], []);\n+static VALUES: ([&str; 8], [&str; 1]) =\n+    ([\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"], [\"()\"]);\n+static MACROS: ([&str; 1], [&str; 1]) = ([\"macro\"], [\"!\"]);\n \n impl Namespace {\n     /// Extract the specified namespace from an intra-doc-link if one exists.\n     fn from_intra_spec(s: &str) -> Option<Self> {\n-        NS_MAP\n-            .iter()\n-            .filter(|(_ns, (prefixes, suffixes))| {\n-                prefixes\n-                    .iter()\n-                    .map(|prefix| {\n-                        s.starts_with(*prefix)\n+        [\n+            (Namespace::Types, (TYPES.0.iter(), TYPES.1.iter())),\n+            (Namespace::Values, (VALUES.0.iter(), VALUES.1.iter())),\n+            (Namespace::Macros, (MACROS.0.iter(), MACROS.1.iter())),\n+        ]\n+        .iter()\n+        .filter(|(_ns, (prefixes, suffixes))| {\n+            prefixes\n+                .clone()\n+                .map(|prefix| {\n+                    s.starts_with(*prefix)\n+                        && s.chars()\n+                            .nth(prefix.len() + 1)\n+                            .map(|c| c == '@' || c == ' ')\n+                            .unwrap_or(false)\n+                })\n+                .any(|cond| cond)\n+                || suffixes\n+                    .clone()\n+                    .map(|suffix| {\n+                        s.starts_with(*suffix)\n                             && s.chars()\n-                                .nth(prefix.len() + 1)\n+                                .nth(suffix.len() + 1)\n                                 .map(|c| c == '@' || c == ' ')\n                                 .unwrap_or(false)\n                     })\n                     .any(|cond| cond)\n-                    || suffixes\n-                        .iter()\n-                        .map(|suffix| {\n-                            s.starts_with(*suffix)\n-                                && s.chars()\n-                                    .nth(suffix.len() + 1)\n-                                    .map(|c| c == '@' || c == ' ')\n-                                    .unwrap_or(false)\n-                        })\n-                        .any(|cond| cond)\n-            })\n-            .map(|(ns, (_, _))| *ns)\n-            .next()\n+        })\n+        .map(|(ns, (_, _))| *ns)\n+        .next()\n     }\n }\n \n // Strip prefixes, suffixes, and inline code marks from the given string.\n fn strip_prefixes_suffixes(mut s: &str) -> &str {\n     s = s.trim_matches('`');\n-    NS_MAP.iter().for_each(|(_, (prefixes, suffixes))| {\n-        prefixes.iter().for_each(|prefix| s = s.trim_start_matches(*prefix));\n-        suffixes.iter().for_each(|suffix| s = s.trim_end_matches(*suffix));\n+\n+    [\n+        (TYPES.0.iter(), TYPES.1.iter()),\n+        (VALUES.0.iter(), VALUES.1.iter()),\n+        (MACROS.0.iter(), MACROS.1.iter()),\n+    ]\n+    .iter()\n+    .for_each(|(prefixes, suffixes)| {\n+        prefixes.clone().for_each(|prefix| s = s.trim_start_matches(*prefix));\n+        suffixes.clone().for_each(|suffix| s = s.trim_end_matches(*suffix));\n     });\n     s.trim_start_matches(\"@\").trim()\n }\n@@ -493,6 +483,8 @@ fn try_resolve_intra(\n     link_text: &str,\n     link_target: &str,\n ) -> Option<(String, String)> {\n+    eprintln!(\"resolving intra\");\n+\n     // Set link_target for implied shortlinks\n     let link_target =\n         if link_target.is_empty() { link_text.trim_matches('`') } else { link_target };\n@@ -551,6 +543,8 @@ fn try_resolve_intra(\n \n /// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n fn try_resolve_path(db: &RootDatabase, definition: &Definition, link: &str) -> Option<String> {\n+    eprintln!(\"resolving path\");\n+\n     if !link.contains(\"#\") && !link.contains(\".html\") {\n         return None;\n     }"}]}