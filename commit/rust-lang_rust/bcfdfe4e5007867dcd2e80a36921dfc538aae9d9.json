{"sha": "bcfdfe4e5007867dcd2e80a36921dfc538aae9d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZmRmZTRlNTAwNzg2N2RjZDJlODBhMzY5MjFkZmM1MzhhYWU5ZDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T20:37:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T21:07:25Z"}, "message": "use the closure def-id in returns, but closure-base def-id in locals\n\nUsing the `closure_base_def_id` indiscriminantely, as we were doing\nbefore, winds up \"going wrong\" if the closure type includes the `impl\nTrait` from the parent. The problem arises because the return value\nfor closures is inferred and meant to treat the return\ntype *opaquely*, so we don't want to be \"desugaring\" it into the\nunderlying type.", "tree": {"sha": "d4d96a5ca2de12a160efed3fbc07f61423b2230b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4d96a5ca2de12a160efed3fbc07f61423b2230b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcfdfe4e5007867dcd2e80a36921dfc538aae9d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcfdfe4e5007867dcd2e80a36921dfc538aae9d9", "html_url": "https://github.com/rust-lang/rust/commit/bcfdfe4e5007867dcd2e80a36921dfc538aae9d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcfdfe4e5007867dcd2e80a36921dfc538aae9d9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7df1f530b8a88f471e60e933868e7ddf456974d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7df1f530b8a88f471e60e933868e7ddf456974d", "html_url": "https://github.com/rust-lang/rust/commit/c7df1f530b8a88f471e60e933868e7ddf456974d"}], "stats": {"total": 42, "additions": 37, "deletions": 5}, "files": [{"sha": "942f19965bf375d75402e94541a29d57f3edc521", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bcfdfe4e5007867dcd2e80a36921dfc538aae9d9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfdfe4e5007867dcd2e80a36921dfc538aae9d9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=bcfdfe4e5007867dcd2e80a36921dfc538aae9d9", "patch": "@@ -70,6 +70,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         if let Err(terr) = self.eq_opaque_type_and_type(\n             mir_output_ty,\n             normalized_output_ty,\n+            self.mir_def_id,\n             Locations::All(output_span),\n             ConstraintCategory::BoringNoLocation,\n         ) {"}, {"sha": "44b0268668595d567582adab41852177b24e00a7", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bcfdfe4e5007867dcd2e80a36921dfc538aae9d9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfdfe4e5007867dcd2e80a36921dfc538aae9d9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=bcfdfe4e5007867dcd2e80a36921dfc538aae9d9", "patch": "@@ -883,6 +883,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         )\n     }\n \n+    /// Try to relate `sub <: sup`; if this fails, instantiate opaque\n+    /// variables in `sub` with their inferred definitions and try\n+    /// again. This is used for opaque types in places (e.g., `let x:\n+    /// impl Foo = ..`).\n     fn sub_types_or_anon(\n         &mut self,\n         sub: Ty<'tcx>,\n@@ -892,7 +896,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     ) -> Fallible<()> {\n         if let Err(terr) = self.sub_types(sub, sup, locations, category) {\n             if let TyKind::Opaque(..) = sup.sty {\n-                return self.eq_opaque_type_and_type(sub, sup, locations, category);\n+                // When you have `let x: impl Foo = ...` in a closure,\n+                // the resulting inferend values are stored with the\n+                // def-id of the base function.\n+                let parent_def_id = self.tcx().closure_base_def_id(self.mir_def_id);\n+                return self.eq_opaque_type_and_type(sub, sup, parent_def_id, locations, category);\n             } else {\n                 return Err(terr);\n             }\n@@ -940,13 +948,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         &mut self,\n         revealed_ty: Ty<'tcx>,\n         anon_ty: Ty<'tcx>,\n+        anon_owner_def_id: DefId,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n+        debug!(\n+            \"eq_opaque_type_and_type( \\\n+             revealed_ty={:?}, \\\n+             anon_ty={:?})\",\n+            revealed_ty, anon_ty\n+        );\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n-        let parent_def_id = infcx.tcx.closure_base_def_id(self.mir_def_id);\n+        debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", self.mir_def_id);\n         let opaque_type_map = self.fully_perform_op(\n             locations,\n             category,\n@@ -957,7 +972,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     let dummy_body_id = ObligationCause::dummy().body_id;\n                     let (output_ty, opaque_type_map) =\n                         obligations.add(infcx.instantiate_opaque_types(\n-                            parent_def_id,\n+                            anon_owner_def_id,\n                             dummy_body_id,\n                             param_env,\n                             &anon_ty,\n@@ -978,8 +993,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n                         let opaque_defn_ty = renumber::renumber_regions(infcx, &opaque_defn_ty);\n                         debug!(\n-                            \"eq_opaque_type_and_type: concrete_ty={:?} opaque_defn_ty={:?}\",\n-                            opaque_decl.concrete_ty, opaque_defn_ty\n+                            \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?}\",\n+                            opaque_decl.concrete_ty,\n+                            infcx.resolve_type_vars_if_possible(&opaque_decl.concrete_ty),\n+                            opaque_defn_ty\n                         );\n                         obligations.add(infcx\n                             .at(&ObligationCause::dummy(), param_env)"}, {"sha": "cb5f78bd6fc0f3c620795d8f6bbfdc4ec22671ef", "filename": "src/test/ui/impl-trait/closure-calling-parent-fn.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bcfdfe4e5007867dcd2e80a36921dfc538aae9d9/src%2Ftest%2Fui%2Fimpl-trait%2Fclosure-calling-parent-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfdfe4e5007867dcd2e80a36921dfc538aae9d9/src%2Ftest%2Fui%2Fimpl-trait%2Fclosure-calling-parent-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fclosure-calling-parent-fn.rs?ref=bcfdfe4e5007867dcd2e80a36921dfc538aae9d9", "patch": "@@ -0,0 +1,14 @@\n+#![feature(nll)]\n+\n+// Regression test for #54593: the MIR type checker was going wrong\n+// when a closure returns the `impl Copy` from its parent fn. It was\n+// (incorrectly) replacing the `impl Copy` in its return type with the\n+// hidden type (`()`) but that type resulted from a recursive call to\n+// `foo` and hence is treated opaquely within the closure body.  This\n+// resulted in a failed subtype relationship.\n+//\n+// run-pass\n+\n+fn foo() -> impl Copy { || foo(); }\n+fn bar() -> impl Copy { || bar(); }\n+fn main() { }"}]}