{"sha": "19ca9e188474058c066212e103d4addb9630fbbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5Y2E5ZTE4ODQ3NDA1OGMwNjYyMTJlMTAzZDRhZGRiOTYzMGZiYmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-21T23:32:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T23:54:32Z"}, "message": "librustc: De-`@mut` `Module::children`", "tree": {"sha": "066af815db4782e2ccb613deca8e3deb80a26162", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/066af815db4782e2ccb613deca8e3deb80a26162"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19ca9e188474058c066212e103d4addb9630fbbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19ca9e188474058c066212e103d4addb9630fbbf", "html_url": "https://github.com/rust-lang/rust/commit/19ca9e188474058c066212e103d4addb9630fbbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19ca9e188474058c066212e103d4addb9630fbbf/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f857398bc960e683efd0923181c4a7fbd5497cf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f857398bc960e683efd0923181c4a7fbd5497cf8", "html_url": "https://github.com/rust-lang/rust/commit/f857398bc960e683efd0923181c4a7fbd5497cf8"}], "stats": {"total": 193, "additions": 119, "deletions": 74}, "files": [{"sha": "eeb992159df5f7f71c9be1aa83181ca94a29f9fd", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 119, "deletions": 74, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/19ca9e188474058c066212e103d4addb9630fbbf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ca9e188474058c066212e103d4addb9630fbbf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=19ca9e188474058c066212e103d4addb9630fbbf", "patch": "@@ -418,7 +418,7 @@ struct Module {\n     kind: Cell<ModuleKind>,\n     is_public: bool,\n \n-    children: @mut HashMap<Name, @NameBindings>,\n+    children: RefCell<HashMap<Name, @NameBindings>>,\n     imports: @mut ~[@ImportDirective],\n \n     // The external module children of this node that were declared with\n@@ -468,7 +468,7 @@ impl Module {\n             def_id: Cell::new(def_id),\n             kind: Cell::new(kind),\n             is_public: is_public,\n-            children: @mut HashMap::new(),\n+            children: RefCell::new(HashMap::new()),\n             imports: @mut ~[],\n             external_module_children: RefCell::new(HashMap::new()),\n             anonymous_children: RefCell::new(HashMap::new()),\n@@ -997,13 +997,18 @@ impl Resolver {\n \n         // Add or reuse the child.\n         let new_parent = ModuleReducedGraphParent(module_);\n-        match module_.children.find(&name.name) {\n+        let child_opt = {\n+            let children = module_.children.borrow();\n+            children.get().find_copy(&name.name)\n+        };\n+        match child_opt {\n             None => {\n                 let child = @NameBindings();\n-                module_.children.insert(name.name, child);\n+                let mut children = module_.children.borrow_mut();\n+                children.get().insert(name.name, child);\n                 return (child, new_parent);\n             }\n-            Some(&child) => {\n+            Some(child) => {\n                 // Enforce the duplicate checking mode:\n                 //\n                 // * If we're requesting duplicate module checking, check that\n@@ -1239,11 +1244,15 @@ impl Resolver {\n                     ty_path(ref path, _, _) if path.segments.len() == 1 => {\n                         let name = path_to_ident(path);\n \n-                        let new_parent = match parent.children.find(&name.name) {\n+                        let existing_parent_opt = {\n+                            let children = parent.children.borrow();\n+                            children.get().find_copy(&name.name)\n+                        };\n+                        let new_parent = match existing_parent_opt {\n                             // It already exists\n-                            Some(&child) if child.get_module_if_available()\n-                                                 .is_some() &&\n-                                            child.get_module().kind.get() ==\n+                            Some(child) if child.get_module_if_available()\n+                                                .is_some() &&\n+                                           child.get_module().kind.get() ==\n                                                 ImplModuleKind => {\n                                 ModuleReducedGraphParent(child.get_module())\n                             }\n@@ -2027,13 +2036,16 @@ impl Resolver {\n         self.resolve_imports_for_module(module_);\n \n         self.populate_module_if_necessary(module_);\n-        for (_, &child_node) in module_.children.iter() {\n-            match child_node.get_module_if_available() {\n-                None => {\n-                    // Nothing to do.\n-                }\n-                Some(child_module) => {\n-                    self.resolve_imports_for_module_subtree(child_module);\n+        {\n+            let children = module_.children.borrow();\n+            for (_, &child_node) in children.get().iter() {\n+                match child_node.get_module_if_available() {\n+                    None => {\n+                        // Nothing to do.\n+                    }\n+                    Some(child_module) => {\n+                        self.resolve_imports_for_module_subtree(child_module);\n+                    }\n                 }\n             }\n         }\n@@ -2258,18 +2270,22 @@ impl Resolver {\n \n         // Search for direct children of the containing module.\n         self.populate_module_if_necessary(containing_module);\n-        match containing_module.children.find(&source.name) {\n-            None => {\n-                // Continue.\n-            }\n-            Some(child_name_bindings) => {\n-                if child_name_bindings.defined_in_namespace(ValueNS) {\n-                    value_result = BoundResult(containing_module,\n-                                               *child_name_bindings);\n+\n+        {\n+            let children = containing_module.children.borrow();\n+            match children.get().find(&source.name) {\n+                None => {\n+                    // Continue.\n                 }\n-                if child_name_bindings.defined_in_namespace(TypeNS) {\n-                    type_result = BoundResult(containing_module,\n-                                              *child_name_bindings);\n+                Some(child_name_bindings) => {\n+                    if child_name_bindings.defined_in_namespace(ValueNS) {\n+                        value_result = BoundResult(containing_module,\n+                                                   *child_name_bindings);\n+                    }\n+                    if child_name_bindings.defined_in_namespace(TypeNS) {\n+                        type_result = BoundResult(containing_module,\n+                                                  *child_name_bindings);\n+                    }\n                 }\n             }\n         }\n@@ -2590,8 +2606,12 @@ impl Resolver {\n \n         // Add all children from the containing module.\n         self.populate_module_if_necessary(containing_module);\n-        for (&name, name_bindings) in containing_module.children.iter() {\n-            merge_import_resolution(name, *name_bindings);\n+\n+        {\n+            let children = containing_module.children.borrow();\n+            for (&name, name_bindings) in children.get().iter() {\n+                merge_import_resolution(name, *name_bindings);\n+            }\n         }\n \n         // Add external module children from the containing module.\n@@ -2858,13 +2878,18 @@ impl Resolver {\n         // The current module node is handled specially. First, check for\n         // its immediate children.\n         self.populate_module_if_necessary(module_);\n-        match module_.children.find(&name.name) {\n-            Some(name_bindings)\n-                    if name_bindings.defined_in_namespace(namespace) => {\n-                debug!(\"top name bindings succeeded\");\n-                return Success((Target::new(module_, *name_bindings), false));\n+\n+        {\n+            let children = module_.children.borrow();\n+            match children.get().find(&name.name) {\n+                Some(name_bindings)\n+                        if name_bindings.defined_in_namespace(namespace) => {\n+                    debug!(\"top name bindings succeeded\");\n+                    return Success((Target::new(module_, *name_bindings),\n+                                   false));\n+                }\n+                Some(_) | None => { /* Not found; continue. */ }\n             }\n-            Some(_) | None => { /* Not found; continue. */ }\n         }\n \n         // Now check for its import directives. We don't have to have resolved\n@@ -3125,14 +3150,19 @@ impl Resolver {\n \n         // First, check the direct children of the module.\n         self.populate_module_if_necessary(module_);\n-        match module_.children.find(&name.name) {\n-            Some(name_bindings)\n-                    if name_bindings.defined_in_namespace(namespace) => {\n-                debug!(\"(resolving name in module) found node as child\");\n-                return Success((Target::new(module_, *name_bindings), false));\n-            }\n-            Some(_) | None => {\n-                // Continue.\n+\n+        {\n+            let children = module_.children.borrow();\n+            match children.get().find(&name.name) {\n+                Some(name_bindings)\n+                        if name_bindings.defined_in_namespace(namespace) => {\n+                    debug!(\"(resolving name in module) found node as child\");\n+                    return Success((Target::new(module_, *name_bindings),\n+                                   false));\n+                }\n+                Some(_) | None => {\n+                    // Continue.\n+                }\n             }\n         }\n \n@@ -3211,13 +3241,17 @@ impl Resolver {\n \n         // Descend into children and anonymous children.\n         self.populate_module_if_necessary(module_);\n-        for (_, &child_node) in module_.children.iter() {\n-            match child_node.get_module_if_available() {\n-                None => {\n-                    // Continue.\n-                }\n-                Some(child_module) => {\n-                    self.report_unresolved_imports(child_module);\n+\n+        {\n+            let children = module_.children.borrow();\n+            for (_, &child_node) in children.get().iter() {\n+                match child_node.get_module_if_available() {\n+                    None => {\n+                        // Continue.\n+                    }\n+                    Some(child_module) => {\n+                        self.report_unresolved_imports(child_module);\n+                    }\n                 }\n             }\n         }\n@@ -3272,13 +3306,16 @@ impl Resolver {\n         self.record_exports_for_module(module_);\n         self.populate_module_if_necessary(module_);\n \n-        for (_, &child_name_bindings) in module_.children.iter() {\n-            match child_name_bindings.get_module_if_available() {\n-                None => {\n-                    // Nothing to do.\n-                }\n-                Some(child_module) => {\n-                    self.record_exports_for_module_subtree(child_module);\n+        {\n+            let children = module_.children.borrow();\n+            for (_, &child_name_bindings) in children.get().iter() {\n+                match child_name_bindings.get_module_if_available() {\n+                    None => {\n+                        // Nothing to do.\n+                    }\n+                    Some(child_module) => {\n+                        self.record_exports_for_module_subtree(child_module);\n+                    }\n                 }\n             }\n         }\n@@ -3382,7 +3419,9 @@ impl Resolver {\n             }\n             Some(name) => {\n                 self.populate_module_if_necessary(orig_module);\n-                match orig_module.children.find(&name.name) {\n+\n+                let children = orig_module.children.borrow();\n+                match children.get().find(&name.name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n                                self.session.str_of(name),\n@@ -4675,22 +4714,26 @@ impl Resolver {\n                                                 -> NameDefinition {\n         // First, search children.\n         self.populate_module_if_necessary(containing_module);\n-        match containing_module.children.find(&name.name) {\n-            Some(child_name_bindings) => {\n-                match child_name_bindings.def_for_namespace(namespace) {\n-                    Some(def) => {\n-                        // Found it. Stop the search here.\n-                        let p = child_name_bindings.defined_in_public_namespace(\n-                                        namespace);\n-                        let lp = if p {AllPublic} else {\n-                            DependsOn(def_id_of_def(def))\n-                        };\n-                        return ChildNameDefinition(def, lp);\n+\n+        {\n+            let children = containing_module.children.borrow();\n+            match children.get().find(&name.name) {\n+                Some(child_name_bindings) => {\n+                    match child_name_bindings.def_for_namespace(namespace) {\n+                        Some(def) => {\n+                            // Found it. Stop the search here.\n+                            let p = child_name_bindings.defined_in_public_namespace(\n+                                            namespace);\n+                            let lp = if p {AllPublic} else {\n+                                DependsOn(def_id_of_def(def))\n+                            };\n+                            return ChildNameDefinition(def, lp);\n+                        }\n+                        None => {}\n                     }\n-                    None => {}\n                 }\n+                None => {}\n             }\n-            None => {}\n         }\n \n         // Next, search import resolutions.\n@@ -5299,8 +5342,9 @@ impl Resolver {\n \n                 // Look for trait children.\n                 self.populate_module_if_necessary(search_module);\n-                for (_, &child_name_bindings) in\n-                        search_module.children.iter() {\n+\n+                let children = search_module.children.borrow();\n+                for (_, &child_name_bindings) in children.get().iter() {\n                     match child_name_bindings.def_for_namespace(TypeNS) {\n                         Some(def) => {\n                             match def {\n@@ -5514,7 +5558,8 @@ impl Resolver {\n \n         debug!(\"Children:\");\n         self.populate_module_if_necessary(module_);\n-        for (&name, _) in module_.children.iter() {\n+        let children = module_.children.borrow();\n+        for (&name, _) in children.get().iter() {\n             debug!(\"* {}\", interner_get(name));\n         }\n "}]}