{"sha": "3845a08a555fcc5f97e9f6b77e0727e756f31a01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NDVhMDhhNTU1ZmNjNWY5N2U5ZjZiNzdlMDcyN2U3NTZmMzFhMDE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-14T20:04:51Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-18T10:42:45Z"}, "message": "resolve: Move some common code into the scope visitor", "tree": {"sha": "9fedbf0c74a8edc39f9fdc28e0ad00a2280bf345", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fedbf0c74a8edc39f9fdc28e0ad00a2280bf345"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3845a08a555fcc5f97e9f6b77e0727e756f31a01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3845a08a555fcc5f97e9f6b77e0727e756f31a01", "html_url": "https://github.com/rust-lang/rust/commit/3845a08a555fcc5f97e9f6b77e0727e756f31a01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3845a08a555fcc5f97e9f6b77e0727e756f31a01/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "329c05251a007077aeb8818a5e1000796de0128d", "url": "https://api.github.com/repos/rust-lang/rust/commits/329c05251a007077aeb8818a5e1000796de0128d", "html_url": "https://github.com/rust-lang/rust/commit/329c05251a007077aeb8818a5e1000796de0128d"}], "stats": {"total": 256, "additions": 114, "deletions": 142}, "files": [{"sha": "7bd4ee0deea815bdefa65ee5c480a20dd850ac32", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 30, "deletions": 51, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/3845a08a555fcc5f97e9f6b77e0727e756f31a01/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3845a08a555fcc5f97e9f6b77e0727e756f31a01/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=3845a08a555fcc5f97e9f6b77e0727e756f31a01", "patch": "@@ -562,19 +562,10 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         scope_set: ScopeSet,\n         parent_scope: &ParentScope<'a>,\n-        orig_ident: Ident,\n+        ident: Ident,\n         filter_fn: &impl Fn(Res) -> bool,\n     ) -> Option<TypoSuggestion> {\n-        let ident = orig_ident.modern();\n-        let rust_2015 = orig_ident.span.rust_2015();\n-        let is_absolute_path = match scope_set {\n-            ScopeSet::AbsolutePath(..) => true,\n-            _ => false,\n-        };\n-\n         let mut suggestions = Vec::new();\n-        let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n-\n         self.visit_scopes(scope_set, parent_scope, ident, |this, scope, _| {\n             match scope {\n                 Scope::DeriveHelpers => {\n@@ -603,26 +594,22 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::CrateRoot => {\n-                    let root_ident = Ident::new(kw::PathRoot, orig_ident.span);\n+                    let root_ident = Ident::new(kw::PathRoot, ident.span);\n                     let root_module = this.resolve_crate_root(root_ident);\n                     add_module_candidates(root_module, &mut suggestions, filter_fn);\n                 }\n                 Scope::Module(module) => {\n-                    use_prelude = !module.no_implicit_prelude;\n                     add_module_candidates(module, &mut suggestions, filter_fn);\n                 }\n                 Scope::MacroUsePrelude => {\n-                    if use_prelude || rust_2015 {\n-                        let macro_use_prelude = &this.macro_use_prelude;\n-                        suggestions.extend(macro_use_prelude.iter().filter_map(|(name, binding)| {\n-                            let res = binding.res();\n-                            if filter_fn(res) {\n-                                Some(TypoSuggestion::from_res(*name, res))\n-                            } else {\n-                                None\n-                            }\n-                        }));\n-                    }\n+                    suggestions.extend(this.macro_use_prelude.iter().filter_map(|(name, binding)| {\n+                        let res = binding.res();\n+                        if filter_fn(res) {\n+                            Some(TypoSuggestion::from_res(*name, res))\n+                        } else {\n+                            None\n+                        }\n+                    }));\n                 }\n                 Scope::BuiltinMacros => {\n                     suggestions.extend(this.builtin_macros.iter().filter_map(|(name, binding)| {\n@@ -643,41 +630,33 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::LegacyPluginHelpers => {\n-                    if use_prelude || rust_2015 {\n-                        let res = Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper);\n-                        if filter_fn(res) {\n-                            let plugin_attributes = this.session.plugin_attributes.borrow();\n-                            suggestions.extend(plugin_attributes.iter().map(|(name, _)| {\n-                                TypoSuggestion::from_res(*name, res)\n-                            }));\n-                        }\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper);\n+                    if filter_fn(res) {\n+                        let plugin_attributes = this.session.plugin_attributes.borrow();\n+                        suggestions.extend(plugin_attributes.iter().map(|(name, _)| {\n+                            TypoSuggestion::from_res(*name, res)\n+                        }));\n                     }\n                 }\n                 Scope::ExternPrelude => {\n-                    if use_prelude || is_absolute_path {\n-                        suggestions.extend(this.extern_prelude.iter().filter_map(|(ident, _)| {\n-                            let res = Res::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX));\n-                            if filter_fn(res) {\n-                                Some(TypoSuggestion::from_res(ident.name, res))\n-                            } else {\n-                                None\n-                            }\n-                        }));\n-                    }\n+                    suggestions.extend(this.extern_prelude.iter().filter_map(|(ident, _)| {\n+                        let res = Res::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX));\n+                        if filter_fn(res) {\n+                            Some(TypoSuggestion::from_res(ident.name, res))\n+                        } else {\n+                            None\n+                        }\n+                    }));\n                 }\n                 Scope::ToolPrelude => {\n-                    if use_prelude {\n-                        let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n-                        suggestions.extend(KNOWN_TOOLS.iter().map(|name| {\n-                            TypoSuggestion::from_res(*name, res)\n-                        }));\n-                    }\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n+                    suggestions.extend(KNOWN_TOOLS.iter().map(|name| {\n+                        TypoSuggestion::from_res(*name, res)\n+                    }));\n                 }\n                 Scope::StdLibPrelude => {\n-                    if use_prelude {\n-                        if let Some(prelude) = this.prelude {\n-                            add_module_candidates(prelude, &mut suggestions, filter_fn);\n-                        }\n+                    if let Some(prelude) = this.prelude {\n+                        add_module_candidates(prelude, &mut suggestions, filter_fn);\n                     }\n                 }\n                 Scope::BuiltinTypes => {"}, {"sha": "e4d8ae11f0f7c4914a85d6f9042ab8d6317b6a93", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3845a08a555fcc5f97e9f6b77e0727e756f31a01/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3845a08a555fcc5f97e9f6b77e0727e756f31a01/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3845a08a555fcc5f97e9f6b77e0727e756f31a01", "patch": "@@ -2145,7 +2145,7 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         scope_set: ScopeSet,\n         parent_scope: &ParentScope<'a>,\n-        mut ident: Ident,\n+        ident: Ident,\n         mut visitor: impl FnMut(&mut Self, Scope<'a>, Ident) -> Option<T>,\n     ) -> Option<T> {\n         // General principles:\n@@ -2192,6 +2192,7 @@ impl<'a> Resolver<'a> {\n         //    but introduced by legacy plugins using `register_attribute`. Priority is somewhere\n         //    in prelude, not sure where exactly (creates ambiguities with any other prelude names).\n \n+        let rust_2015 = ident.span.rust_2015();\n         let (ns, is_absolute_path) = match scope_set {\n             ScopeSet::Import(ns) => (ns, false),\n             ScopeSet::AbsolutePath(ns) => (ns, true),\n@@ -2203,10 +2204,29 @@ impl<'a> Resolver<'a> {\n             TypeNS | ValueNS => Scope::Module(parent_scope.module),\n             MacroNS => Scope::DeriveHelpers,\n         };\n+        let mut ident = ident.modern();\n+        let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n \n         loop {\n-            if let break_result @ Some(..) = visitor(self, scope, ident) {\n-                return break_result;\n+            let visit = match scope {\n+                Scope::DeriveHelpers => true,\n+                Scope::MacroRules(..) => true,\n+                Scope::CrateRoot => true,\n+                Scope::Module(..) => true,\n+                Scope::MacroUsePrelude => use_prelude || rust_2015,\n+                Scope::BuiltinMacros => true,\n+                Scope::BuiltinAttrs => true,\n+                Scope::LegacyPluginHelpers => use_prelude || rust_2015,\n+                Scope::ExternPrelude => use_prelude || is_absolute_path,\n+                Scope::ToolPrelude => use_prelude,\n+                Scope::StdLibPrelude => use_prelude,\n+                Scope::BuiltinTypes => true,\n+            };\n+\n+            if visit {\n+                if let break_result @ Some(..) = visitor(self, scope, ident) {\n+                    return break_result;\n+                }\n             }\n \n             scope = match scope {\n@@ -2229,6 +2249,7 @@ impl<'a> Resolver<'a> {\n                     ValueNS | MacroNS => break,\n                 }\n                 Scope::Module(module) => {\n+                    use_prelude = !module.no_implicit_prelude;\n                     match self.hygienic_lexical_parent(module, &mut ident.span) {\n                         Some(parent_module) => Scope::Module(parent_module),\n                         None => {"}, {"sha": "9da73eb4f7cd86c87ef3d9a02a6f8294b86fda90", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 60, "deletions": 88, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/3845a08a555fcc5f97e9f6b77e0727e756f31a01/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3845a08a555fcc5f97e9f6b77e0727e756f31a01/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=3845a08a555fcc5f97e9f6b77e0727e756f31a01", "patch": "@@ -417,19 +417,17 @@ impl<'a> Resolver<'a> {\n         }\n \n         assert!(force || !record_used); // `record_used` implies `force`\n-        let ident = orig_ident.modern();\n \n         // Make sure `self`, `super` etc produce an error when passed to here.\n-        if ident.is_path_segment_keyword() {\n+        if orig_ident.is_path_segment_keyword() {\n             return Err(Determinacy::Determined);\n         }\n \n-        let rust_2015 = orig_ident.span.rust_2015();\n-        let (ns, macro_kind, is_import, is_absolute_path) = match scope_set {\n-            ScopeSet::Import(ns) => (ns, None, true, false),\n-            ScopeSet::AbsolutePath(ns) => (ns, None, false, true),\n-            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false, false),\n-            ScopeSet::Module => (TypeNS, None, false, false),\n+        let (ns, macro_kind, is_import) = match scope_set {\n+            ScopeSet::Import(ns) => (ns, None, true),\n+            ScopeSet::AbsolutePath(ns) => (ns, None, false),\n+            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n+            ScopeSet::Module => (TypeNS, None, false),\n         };\n \n         // This is *the* result, resolution from the scope closest to the resolved identifier.\n@@ -444,11 +442,11 @@ impl<'a> Resolver<'a> {\n         // So we have to save the innermost solution and continue searching in outer scopes\n         // to detect potential ambiguities.\n         let mut innermost_result: Option<(&NameBinding<'_>, Flags)> = None;\n-        let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n         let mut determinacy = Determinacy::Determined;\n \n         // Go through all the scopes and try to resolve the name.\n-        let break_result = self.visit_scopes(scope_set, parent_scope, ident, |this, scope, ident| {\n+        let break_result =\n+                self.visit_scopes(scope_set, parent_scope, orig_ident, |this, scope, ident| {\n             let result = match scope {\n                 Scope::DeriveHelpers => {\n                     let mut result = Err(Determinacy::Determined);\n@@ -478,11 +476,11 @@ impl<'a> Resolver<'a> {\n                     _ => Err(Determinacy::Determined),\n                 }\n                 Scope::CrateRoot => {\n-                    let root_ident = Ident::new(kw::PathRoot, orig_ident.span);\n+                    let root_ident = Ident::new(kw::PathRoot, ident.span);\n                     let root_module = this.resolve_crate_root(root_ident);\n                     let binding = this.resolve_ident_in_module_ext(\n                         ModuleOrUniformRoot::Module(root_module),\n-                        orig_ident,\n+                        ident,\n                         ns,\n                         None,\n                         record_used,\n@@ -498,7 +496,6 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::Module(module) => {\n-                    use_prelude = !module.no_implicit_prelude;\n                     let orig_current_module = mem::replace(&mut this.current_module, module);\n                     let binding = this.resolve_ident_in_module_unadjusted_ext(\n                         ModuleOrUniformRoot::Module(module),\n@@ -528,94 +525,69 @@ impl<'a> Resolver<'a> {\n                         Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n                     }\n                 }\n-                Scope::MacroUsePrelude => {\n-                    if use_prelude || rust_2015 {\n-                        match this.macro_use_prelude.get(&ident.name).cloned() {\n-                            Some(binding) =>\n-                                Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n-                            None => Err(Determinacy::determined(\n-                                this.graph_root.unresolved_invocations.borrow().is_empty()\n-                            ))\n-                        }\n-                    } else {\n-                        Err(Determinacy::Determined)\n-                    }\n+                Scope::MacroUsePrelude => match this.macro_use_prelude.get(&ident.name).cloned() {\n+                    Some(binding) => Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n+                    None => Err(Determinacy::determined(\n+                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                    ))\n                 }\n-                Scope::BuiltinMacros => {\n-                    match this.builtin_macros.get(&ident.name).cloned() {\n-                        Some(binding) => Ok((binding, Flags::PRELUDE)),\n-                        None => Err(Determinacy::Determined),\n-                    }\n+                Scope::BuiltinMacros => match this.builtin_macros.get(&ident.name).cloned() {\n+                    Some(binding) => Ok((binding, Flags::PRELUDE)),\n+                    None => Err(Determinacy::Determined),\n                 }\n-                Scope::BuiltinAttrs => {\n-                    if is_builtin_attr_name(ident.name) {\n-                        let binding = (Res::NonMacroAttr(NonMacroAttrKind::Builtin),\n-                                       ty::Visibility::Public, DUMMY_SP, Mark::root())\n-                                       .to_name_binding(this.arenas);\n-                        Ok((binding, Flags::PRELUDE))\n-                    } else {\n-                        Err(Determinacy::Determined)\n-                    }\n+                Scope::BuiltinAttrs => if is_builtin_attr_name(ident.name) {\n+                    let binding = (Res::NonMacroAttr(NonMacroAttrKind::Builtin),\n+                                   ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                                   .to_name_binding(this.arenas);\n+                    Ok((binding, Flags::PRELUDE))\n+                } else {\n+                    Err(Determinacy::Determined)\n                 }\n-                Scope::LegacyPluginHelpers => {\n-                    if (use_prelude || rust_2015) &&\n-                       this.session.plugin_attributes.borrow().iter()\n+                Scope::LegacyPluginHelpers => if this.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == *name) {\n-                        let binding = (Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n-                                       ty::Visibility::Public, DUMMY_SP, Mark::root())\n-                                       .to_name_binding(this.arenas);\n-                        Ok((binding, Flags::PRELUDE))\n-                    } else {\n-                        Err(Determinacy::Determined)\n-                    }\n+                    let binding = (Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n+                                   ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                                   .to_name_binding(this.arenas);\n+                    Ok((binding, Flags::PRELUDE))\n+                } else {\n+                    Err(Determinacy::Determined)\n                 }\n-                Scope::ExternPrelude => {\n-                    if use_prelude || is_absolute_path {\n-                        match this.extern_prelude_get(ident, !record_used) {\n-                            Some(binding) => Ok((binding, Flags::PRELUDE)),\n-                            None => Err(Determinacy::determined(\n-                                this.graph_root.unresolved_invocations.borrow().is_empty()\n-                            )),\n-                        }\n-                    } else {\n-                        Err(Determinacy::Determined)\n-                    }\n+                Scope::ExternPrelude => match this.extern_prelude_get(ident, !record_used) {\n+                    Some(binding) => Ok((binding, Flags::PRELUDE)),\n+                    None => Err(Determinacy::determined(\n+                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                    )),\n                 }\n-                Scope::ToolPrelude => {\n-                    if use_prelude && KNOWN_TOOLS.contains(&ident.name) {\n-                        let binding = (Res::ToolMod, ty::Visibility::Public,\n-                                       DUMMY_SP, Mark::root()).to_name_binding(this.arenas);\n-                        Ok((binding, Flags::PRELUDE))\n-                    } else {\n-                        Err(Determinacy::Determined)\n-                    }\n+                Scope::ToolPrelude => if KNOWN_TOOLS.contains(&ident.name) {\n+                    let binding = (Res::ToolMod, ty::Visibility::Public, DUMMY_SP, Mark::root())\n+                                   .to_name_binding(this.arenas);\n+                    Ok((binding, Flags::PRELUDE))\n+                } else {\n+                    Err(Determinacy::Determined)\n                 }\n                 Scope::StdLibPrelude => {\n                     let mut result = Err(Determinacy::Determined);\n-                    if use_prelude {\n-                        if let Some(prelude) = this.prelude {\n-                            if let Ok(binding) = this.resolve_ident_in_module_unadjusted(\n-                                ModuleOrUniformRoot::Module(prelude),\n-                                ident,\n-                                ns,\n-                                false,\n-                                path_span,\n-                            ) {\n-                                result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n-                            }\n+                    if let Some(prelude) = this.prelude {\n+                        if let Ok(binding) = this.resolve_ident_in_module_unadjusted(\n+                            ModuleOrUniformRoot::Module(prelude),\n+                            ident,\n+                            ns,\n+                            false,\n+                            path_span,\n+                        ) {\n+                            result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n                         }\n                     }\n                     result\n                 }\n-                Scope::BuiltinTypes => {\n-                    match this.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n-                        Some(prim_ty) => {\n-                            let binding = (Res::PrimTy(prim_ty), ty::Visibility::Public,\n-                                           DUMMY_SP, Mark::root()).to_name_binding(this.arenas);\n-                            Ok((binding, Flags::PRELUDE))\n-                        }\n-                        None => Err(Determinacy::Determined)\n+                Scope::BuiltinTypes => match this.primitive_type_table.primitive_types\n+                                                 .get(&ident.name).cloned() {\n+                    Some(prim_ty) => {\n+                        let binding = (Res::PrimTy(prim_ty), ty::Visibility::Public,\n+                                       DUMMY_SP, Mark::root()).to_name_binding(this.arenas);\n+                        Ok((binding, Flags::PRELUDE))\n                     }\n+                    None => Err(Determinacy::Determined)\n                 }\n             };\n \n@@ -712,7 +684,7 @@ impl<'a> Resolver<'a> {\n             // the last segment, so we are certainly working with a single-segment attribute here.)\n             assert!(ns == MacroNS);\n             let binding = (Res::NonMacroAttr(NonMacroAttrKind::Custom),\n-                           ty::Visibility::Public, ident.span, Mark::root())\n+                           ty::Visibility::Public, orig_ident.span, Mark::root())\n                            .to_name_binding(self.arenas);\n             Ok(binding)\n         } else {"}]}