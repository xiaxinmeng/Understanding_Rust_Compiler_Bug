{"sha": "5a3f7cdcc7ff5074c9a83346b221f04023572d4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhM2Y3Y2RjYzdmZjUwNzRjOWE4MzM0NmIyMjFmMDQwMjM1NzJkNGQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-07T15:00:26Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-10T15:46:31Z"}, "message": "move FlowAtLocation to be a dataflow abstraction\n\nWe can now use it in e.g. drop elaboration if we want to.", "tree": {"sha": "60e1c745d1cd67c38baf4d882095edc825db45c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60e1c745d1cd67c38baf4d882095edc825db45c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a3f7cdcc7ff5074c9a83346b221f04023572d4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a3f7cdcc7ff5074c9a83346b221f04023572d4d", "html_url": "https://github.com/rust-lang/rust/commit/5a3f7cdcc7ff5074c9a83346b221f04023572d4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "157231183c586dd19d150a7324b07d65cf7a002f", "url": "https://api.github.com/repos/rust-lang/rust/commits/157231183c586dd19d150a7324b07d65cf7a002f", "html_url": "https://github.com/rust-lang/rust/commit/157231183c586dd19d150a7324b07d65cf7a002f"}], "stats": {"total": 793, "additions": 378, "deletions": 415}, "files": [{"sha": "613f2e91c2ac126da91851ecd9163cc48689f463", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=5a3f7cdcc7ff5074c9a83346b221f04023572d4d", "patch": "@@ -16,8 +16,7 @@ use rustc_data_structures::indexed_vec::Idx;\n \n use super::{MirBorrowckCtxt, Context};\n use super::{InitializationRequiringAction, PrefixSet};\n-use super::flow::FlowInProgress;\n-use dataflow::{BorrowData, MovingOutStatements};\n+use dataflow::{BorrowData, FlowAtLocation, MovingOutStatements};\n use dataflow::move_paths::MovePathIndex;\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n@@ -28,7 +27,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         desired_action: InitializationRequiringAction,\n         (place, span): (&Place<'tcx>, Span),\n         mpi: MovePathIndex,\n-        curr_move_out: &FlowInProgress<MovingOutStatements<'_, 'gcx, 'tcx>>,\n+        curr_move_out: &FlowAtLocation<MovingOutStatements<'_, 'gcx, 'tcx>>,\n     ) {\n         let mois = self.move_data.path_map[mpi]\n             .iter()"}, {"sha": "5e9cee6c4b589ed9ef06e513e0d6037a8238677f", "filename": "src/librustc_mir/borrow_check/flow.rs", "status": "removed", "additions": 0, "deletions": 335, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/157231183c586dd19d150a7324b07d65cf7a002f/src%2Flibrustc_mir%2Fborrow_check%2Fflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/157231183c586dd19d150a7324b07d65cf7a002f/src%2Flibrustc_mir%2Fborrow_check%2Fflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflow.rs?ref=157231183c586dd19d150a7324b07d65cf7a002f", "patch": "@@ -1,335 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Manages the dataflow bits required for borrowck.\n-//!\n-//! FIXME: this might be better as a \"generic\" fixed-point combinator,\n-//! but is not as ugly as it is right now.\n-\n-use rustc::mir::{BasicBlock, Location};\n-use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n-use rustc_data_structures::indexed_vec::Idx;\n-\n-use dataflow::{BitDenotation, BlockSets, DataflowResults};\n-use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-use dataflow::{EverInitializedLvals, MovingOutStatements};\n-use dataflow::Borrows;\n-use dataflow::move_paths::{HasMoveData, MovePathIndex};\n-use std::fmt;\n-\n-// (forced to be `pub` due to its use as an associated type below.)\n-pub struct InProgress<'b, 'gcx: 'tcx, 'tcx: 'b> {\n-    pub borrows: FlowInProgress<Borrows<'b, 'gcx, 'tcx>>,\n-    pub inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n-    pub uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n-    pub move_outs: FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>,\n-    pub ever_inits: FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n-}\n-\n-pub struct FlowInProgress<BD>\n-where\n-    BD: BitDenotation,\n-{\n-    base_results: DataflowResults<BD>,\n-    curr_state: IdxSetBuf<BD::Idx>,\n-    stmt_gen: IdxSetBuf<BD::Idx>,\n-    stmt_kill: IdxSetBuf<BD::Idx>,\n-}\n-\n-impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n-    pub fn new(\n-        borrows: FlowInProgress<Borrows<'b, 'gcx, 'tcx>>,\n-        inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n-        uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n-        move_outs: FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>,\n-        ever_inits: FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n-    ) -> Self {\n-        InProgress {\n-            borrows,\n-            inits,\n-            uninits,\n-            move_outs,\n-            ever_inits,\n-        }\n-    }\n-\n-    fn each_flow<XB, XI, XU, XM, XE>(\n-        &mut self,\n-        mut xform_borrows: XB,\n-        mut xform_inits: XI,\n-        mut xform_uninits: XU,\n-        mut xform_move_outs: XM,\n-        mut xform_ever_inits: XE,\n-    ) where\n-        XB: FnMut(&mut FlowInProgress<Borrows<'b, 'gcx, 'tcx>>),\n-        XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>),\n-        XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>),\n-        XM: FnMut(&mut FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>),\n-        XE: FnMut(&mut FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>),\n-    {\n-        xform_borrows(&mut self.borrows);\n-        xform_inits(&mut self.inits);\n-        xform_uninits(&mut self.uninits);\n-        xform_move_outs(&mut self.move_outs);\n-        xform_ever_inits(&mut self.ever_inits);\n-    }\n-\n-    pub fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n-        self.each_flow(\n-            |b| b.reset_to_entry_of(bb),\n-            |i| i.reset_to_entry_of(bb),\n-            |u| u.reset_to_entry_of(bb),\n-            |m| m.reset_to_entry_of(bb),\n-            |e| e.reset_to_entry_of(bb),\n-        );\n-    }\n-\n-    pub fn reconstruct_statement_effect(\n-        &mut self,\n-        location: Location,\n-    ) {\n-        self.each_flow(\n-            |b| b.reconstruct_statement_effect(location),\n-            |i| i.reconstruct_statement_effect(location),\n-            |u| u.reconstruct_statement_effect(location),\n-            |m| m.reconstruct_statement_effect(location),\n-            |e| e.reconstruct_statement_effect(location),\n-        );\n-    }\n-\n-    pub fn apply_local_effect(&mut self, _location: Location) {\n-        self.each_flow(\n-            |b| b.apply_local_effect(),\n-            |i| i.apply_local_effect(),\n-            |u| u.apply_local_effect(),\n-            |m| m.apply_local_effect(),\n-            |e| e.apply_local_effect(),\n-        );\n-    }\n-\n-    pub fn reconstruct_terminator_effect(&mut self, location: Location) {\n-        self.each_flow(\n-            |b| b.reconstruct_terminator_effect(location),\n-            |i| i.reconstruct_terminator_effect(location),\n-            |u| u.reconstruct_terminator_effect(location),\n-            |m| m.reconstruct_terminator_effect(location),\n-            |e| e.reconstruct_terminator_effect(location),\n-        );\n-    }\n-}\n-\n-impl<'b, 'gcx, 'tcx> fmt::Display for InProgress<'b, 'gcx, 'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut s = String::new();\n-\n-        s.push_str(\"borrows in effect: [\");\n-        let mut saw_one = false;\n-        self.borrows.each_state_bit(|borrow| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n-            s.push_str(&format!(\"{}\", borrow_data));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"borrows generated: [\");\n-        let mut saw_one = false;\n-        self.borrows.each_gen_bit(|borrow| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n-            s.push_str(&format!(\"{}\", borrow_data));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"inits: [\");\n-        let mut saw_one = false;\n-        self.inits.each_state_bit(|mpi_init| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let move_path = &self.inits.base_results.operator().move_data().move_paths[mpi_init];\n-            s.push_str(&format!(\"{}\", move_path));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"uninits: [\");\n-        let mut saw_one = false;\n-        self.uninits.each_state_bit(|mpi_uninit| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let move_path =\n-                &self.uninits.base_results.operator().move_data().move_paths[mpi_uninit];\n-            s.push_str(&format!(\"{}\", move_path));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"move_out: [\");\n-        let mut saw_one = false;\n-        self.move_outs.each_state_bit(|mpi_move_out| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let move_out = &self.move_outs.base_results.operator().move_data().moves[mpi_move_out];\n-            s.push_str(&format!(\"{:?}\", move_out));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"ever_init: [\");\n-        let mut saw_one = false;\n-        self.ever_inits.each_state_bit(|mpi_ever_init| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let ever_init =\n-                &self.ever_inits.base_results.operator().move_data().inits[mpi_ever_init];\n-            s.push_str(&format!(\"{:?}\", ever_init));\n-        });\n-        s.push_str(\"]\");\n-\n-        fmt::Display::fmt(&s, fmt)\n-    }\n-}\n-\n-impl<'tcx, T> FlowInProgress<T>\n-where\n-    T: HasMoveData<'tcx> + BitDenotation<Idx = MovePathIndex>,\n-{\n-    pub fn has_any_child_of(&self, mpi: T::Idx) -> Option<T::Idx> {\n-        let move_data = self.base_results.operator().move_data();\n-\n-        let mut todo = vec![mpi];\n-        let mut push_siblings = false; // don't look at siblings of original `mpi`.\n-        while let Some(mpi) = todo.pop() {\n-            if self.curr_state.contains(&mpi) {\n-                return Some(mpi);\n-            }\n-            let move_path = &move_data.move_paths[mpi];\n-            if let Some(child) = move_path.first_child {\n-                todo.push(child);\n-            }\n-            if push_siblings {\n-                if let Some(sibling) = move_path.next_sibling {\n-                    todo.push(sibling);\n-                }\n-            } else {\n-                // after we've processed the original `mpi`, we should\n-                // always traverse the siblings of any of its\n-                // children.\n-                push_siblings = true;\n-            }\n-        }\n-        return None;\n-    }\n-}\n-\n-impl<BD> FlowInProgress<BD>\n-where\n-    BD: BitDenotation,\n-{\n-    pub fn each_state_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.curr_state\n-            .each_bit(self.base_results.operator().bits_per_block(), f)\n-    }\n-\n-    fn each_gen_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.stmt_gen\n-            .each_bit(self.base_results.operator().bits_per_block(), f)\n-    }\n-\n-    pub fn new(results: DataflowResults<BD>) -> Self {\n-        let bits_per_block = results.sets().bits_per_block();\n-        let curr_state = IdxSetBuf::new_empty(bits_per_block);\n-        let stmt_gen = IdxSetBuf::new_empty(bits_per_block);\n-        let stmt_kill = IdxSetBuf::new_empty(bits_per_block);\n-        FlowInProgress {\n-            base_results: results,\n-            curr_state: curr_state,\n-            stmt_gen: stmt_gen,\n-            stmt_kill: stmt_kill,\n-        }\n-    }\n-\n-    pub fn operator(&self) -> &BD {\n-        self.base_results.operator()\n-    }\n-\n-    pub fn contains(&self, x: &BD::Idx) -> bool {\n-        self.curr_state.contains(x)\n-    }\n-\n-    pub fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n-        (*self.curr_state).clone_from(self.base_results.sets().on_entry_set_for(bb.index()));\n-    }\n-\n-    pub fn reconstruct_statement_effect(&mut self, loc: Location) {\n-        self.stmt_gen.reset_to_empty();\n-        self.stmt_kill.reset_to_empty();\n-        let mut ignored = IdxSetBuf::new_empty(0);\n-        let mut sets = BlockSets {\n-            on_entry: &mut ignored,\n-            gen_set: &mut self.stmt_gen,\n-            kill_set: &mut self.stmt_kill,\n-        };\n-        self.base_results\n-            .operator()\n-            .statement_effect(&mut sets, loc);\n-    }\n-\n-    pub fn reconstruct_terminator_effect(&mut self, loc: Location) {\n-        self.stmt_gen.reset_to_empty();\n-        self.stmt_kill.reset_to_empty();\n-        let mut ignored = IdxSetBuf::new_empty(0);\n-        let mut sets = BlockSets {\n-            on_entry: &mut ignored,\n-            gen_set: &mut self.stmt_gen,\n-            kill_set: &mut self.stmt_kill,\n-        };\n-        self.base_results\n-            .operator()\n-            .terminator_effect(&mut sets, loc);\n-    }\n-\n-    pub fn apply_local_effect(&mut self) {\n-        self.curr_state.union(&self.stmt_gen);\n-        self.curr_state.subtract(&self.stmt_kill);\n-    }\n-\n-    pub fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n-        let univ = self.base_results.sets().bits_per_block();\n-        self.curr_state.elems(univ)\n-    }\n-\n-    pub fn with_elems_outgoing<F>(&self, f: F)\n-    where\n-        F: FnOnce(indexed_set::Elems<BD::Idx>),\n-    {\n-        let mut curr_state = self.curr_state.clone();\n-        curr_state.union(&self.stmt_gen);\n-        curr_state.subtract(&self.stmt_kill);\n-        let univ = self.base_results.sets().bits_per_block();\n-        f(curr_state.elems(univ));\n-    }\n-}"}, {"sha": "449062989e07ed2f1831c25c06a890afc384eed1", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=5a3f7cdcc7ff5074c9a83346b221f04023572d4d", "patch": "@@ -0,0 +1,159 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Manages the dataflow bits required for borrowck.\n+//!\n+//! FIXME: this might be better as a \"generic\" fixed-point combinator,\n+//! but is not as ugly as it is right now.\n+\n+use rustc::mir::{BasicBlock, Location};\n+\n+use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{EverInitializedLvals, MovingOutStatements};\n+use dataflow::{Borrows, FlowAtLocation, FlowsAtLocation};\n+use dataflow::move_paths::HasMoveData;\n+use std::fmt;\n+\n+// (forced to be `pub` due to its use as an associated type below.)\n+pub struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n+    pub borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n+    pub inits: FlowAtLocation<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n+    pub uninits: FlowAtLocation<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+    pub move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n+    pub ever_inits: FlowAtLocation<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n+}\n+\n+impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n+    pub fn new(\n+        borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n+        inits: FlowAtLocation<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n+        uninits: FlowAtLocation<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+        move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n+        ever_inits: FlowAtLocation<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n+    ) -> Self {\n+        Flows {\n+            borrows,\n+            inits,\n+            uninits,\n+            move_outs,\n+            ever_inits,\n+        }\n+    }\n+}\n+\n+macro_rules! each_flow {\n+    ($this:ident, $meth:ident($arg:ident)) => {\n+        FlowAtLocation::$meth(&mut $this.borrows, $arg);\n+        FlowAtLocation::$meth(&mut $this.inits, $arg);\n+        FlowAtLocation::$meth(&mut $this.uninits, $arg);\n+        FlowAtLocation::$meth(&mut $this.move_outs, $arg);\n+        FlowAtLocation::$meth(&mut $this.ever_inits, $arg);\n+    }\n+}\n+\n+impl<'b, 'gcx, 'tcx> FlowsAtLocation for Flows<'b, 'gcx, 'tcx> {\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n+        each_flow!(self, reset_to_entry_of(bb));\n+    }\n+\n+    fn reconstruct_statement_effect(&mut self, location: Location) {\n+        each_flow!(self, reconstruct_statement_effect(location));\n+    }\n+\n+    fn reconstruct_terminator_effect(&mut self, location: Location) {\n+        each_flow!(self, reconstruct_terminator_effect(location));\n+    }\n+\n+    fn apply_local_effect(&mut self, location: Location) {\n+        each_flow!(self, apply_local_effect(location));\n+    }\n+}\n+\n+impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut s = String::new();\n+\n+        s.push_str(\"borrows in effect: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_state_bit(|borrow| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"borrows generated: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_gen_bit(|borrow| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"inits: [\");\n+        let mut saw_one = false;\n+        self.inits.each_state_bit(|mpi_init| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let move_path = &self.inits.operator().move_data().move_paths[mpi_init];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"uninits: [\");\n+        let mut saw_one = false;\n+        self.uninits.each_state_bit(|mpi_uninit| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let move_path =\n+                &self.uninits.operator().move_data().move_paths[mpi_uninit];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"move_out: [\");\n+        let mut saw_one = false;\n+        self.move_outs.each_state_bit(|mpi_move_out| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let move_out = &self.move_outs.operator().move_data().moves[mpi_move_out];\n+            s.push_str(&format!(\"{:?}\", move_out));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"ever_init: [\");\n+        let mut saw_one = false;\n+        self.ever_inits.each_state_bit(|mpi_ever_init| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let ever_init =\n+                &self.ever_inits.operator().move_data().inits[mpi_ever_init];\n+            s.push_str(&format!(\"{:?}\", ever_init));\n+        });\n+        s.push_str(\"]\");\n+\n+        fmt::Display::fmt(&s, fmt)\n+    }\n+}"}, {"sha": "63b982e890626898ca0e8cfc42f83f99cdc30327", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 18, "deletions": 42, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5a3f7cdcc7ff5074c9a83346b221f04023572d4d", "patch": "@@ -31,6 +31,7 @@ use syntax_pos::Span;\n use dataflow::do_dataflow;\n use dataflow::MoveDataParamEnv;\n use dataflow::DataflowResultsConsumer;\n+use dataflow::{FlowAtLocation, FlowsAtLocation};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use dataflow::{EverInitializedLvals, MovingOutStatements};\n use dataflow::{BorrowData, BorrowIndex, Borrows};\n@@ -40,12 +41,12 @@ use util::borrowck_errors::{BorrowckErrors, Origin};\n \n use std::iter;\n \n-use self::flow::{InProgress, FlowInProgress};\n+use self::flows::Flows;\n use self::prefixes::PrefixSet;\n use self::MutateMode::{JustWrite, WriteAndRead};\n \n mod error_reporting;\n-mod flow;\n+mod flows;\n mod prefixes;\n pub(crate) mod nll;\n \n@@ -149,7 +150,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     };\n \n     let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n-    let mut flow_inits = FlowInProgress::new(do_dataflow(\n+    let mut flow_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n@@ -158,7 +159,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         MaybeInitializedLvals::new(tcx, mir, &mdpe),\n         |bd, i| &bd.move_data().move_paths[i],\n     ));\n-    let flow_uninits = FlowInProgress::new(do_dataflow(\n+    let flow_uninits = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n@@ -167,7 +168,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n         |bd, i| &bd.move_data().move_paths[i],\n     ));\n-    let flow_move_outs = FlowInProgress::new(do_dataflow(\n+    let flow_move_outs = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n@@ -176,7 +177,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         MovingOutStatements::new(tcx, mir, &mdpe),\n         |bd, i| &bd.move_data().moves[i],\n     ));\n-    let flow_ever_inits = FlowInProgress::new(do_dataflow(\n+    let flow_ever_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n@@ -204,7 +205,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     };\n     let flow_inits = flow_inits; // remove mut\n \n-    let flow_borrows = FlowInProgress::new(do_dataflow(\n+    let flow_borrows = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,\n         id,\n@@ -214,14 +215,13 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         |bd, i| bd.location(i),\n     ));\n \n-    let mut state = InProgress::new(\n+    let mut state = Flows::new(\n         flow_borrows,\n         flow_inits,\n         flow_uninits,\n         flow_move_outs,\n         flow_ever_inits,\n     );\n-\n     let mut mbcx = MirBorrowckCtxt {\n         tcx: tcx,\n         mir: mir,\n@@ -267,36 +267,12 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    type FlowState = InProgress<'cx, 'gcx, 'tcx>;\n+    type FlowState = Flows<'cx, 'gcx, 'tcx>;\n \n     fn mir(&self) -> &'cx Mir<'tcx> {\n         self.mir\n     }\n \n-    fn reset_to_entry_of(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n-        flow_state.reset_to_entry_of(bb);\n-    }\n-\n-    fn reconstruct_statement_effect(\n-        &mut self,\n-        location: Location,\n-        flow_state: &mut Self::FlowState,\n-    ) {\n-        flow_state.reconstruct_statement_effect(location);\n-    }\n-\n-    fn apply_local_effect(&mut self, location: Location, flow_state: &mut Self::FlowState) {\n-        flow_state.apply_local_effect(location);\n-    }\n-\n-    fn reconstruct_terminator_effect(\n-        &mut self,\n-        location: Location,\n-        flow_state: &mut Self::FlowState,\n-    ) {\n-        flow_state.reconstruct_terminator_effect(location);\n-    }\n-\n     fn visit_block_entry(&mut self, bb: BasicBlock, flow_state: &Self::FlowState) {\n         debug!(\"MirBorrowckCtxt::process_block({:?}): {}\", bb, flow_state);\n     }\n@@ -675,7 +651,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         place_span: (&Place<'tcx>, Span),\n         kind: (ShallowOrDeep, ReadOrWrite),\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         let (sd, rw) = kind;\n \n@@ -779,7 +755,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         place_span: (&Place<'tcx>, Span),\n         kind: ShallowOrDeep,\n         mode: MutateMode,\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n         match mode {\n@@ -813,7 +789,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         (rvalue, span): (&Rvalue<'tcx>, Span),\n         _location: Location,\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         match *rvalue {\n             Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n@@ -890,7 +866,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         (operand, span): (&Operand<'tcx>, Span),\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         match *operand {\n             Operand::Copy(ref place) => {\n@@ -1003,7 +979,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         (place, span): (&Place<'tcx>, Span),\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         let move_data = self.move_data;\n \n@@ -1046,7 +1022,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         desired_action: InitializationRequiringAction,\n         place_span: (&Place<'tcx>, Span),\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         // FIXME: analogous code in check_loans first maps `place` to\n         // its base_path ... but is that what we want here?\n@@ -1180,7 +1156,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         (place, span): (&Place<'tcx>, Span),\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         // recur down place; dispatch to check_if_path_is_moved when necessary\n         let mut place = place;\n@@ -1860,7 +1836,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         _context: Context,\n         access_place: (ShallowOrDeep, &Place<'tcx>),\n-        flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n         mut op: F,\n     ) where\n         F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>) -> Control,"}, {"sha": "59e862a56af02c5a36b50c8a82fb852221e8f99c", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=5a3f7cdcc7ff5074c9a83346b221f04023572d4d", "patch": "@@ -22,7 +22,7 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::util::common::ErrorReported;\n use rustc_data_structures::fx::FxHashSet;\n use syntax::codemap::DUMMY_SP;\n-use borrow_check::FlowInProgress;\n+use borrow_check::{FlowAtLocation, FlowsAtLocation};\n use dataflow::MaybeInitializedLvals;\n use dataflow::move_paths::{HasMoveData, MoveData};\n \n@@ -36,7 +36,7 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     mir: &Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     liveness: &LivenessResults,\n-    flow_inits: &mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n     let mut cg = ConstraintGeneration {\n@@ -61,7 +61,7 @@ struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n     mir: &'cg Mir<'tcx>,\n     liveness: &'cg LivenessResults,\n     param_env: ty::ParamEnv<'tcx>,\n-    flow_inits: &'cg mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    flow_inits: &'cg mut FlowAtLocation<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n     move_data: &'cg MoveData<'tcx>,\n }\n \n@@ -204,7 +204,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                 );\n                 self.flow_inits.reconstruct_statement_effect(location);\n             }\n-            self.flow_inits.apply_local_effect();\n+            self.flow_inits.apply_local_effect(location);\n         }\n     }\n "}, {"sha": "218142f7e2d428a60b81746d454b647dffec1b92", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=5a3f7cdcc7ff5074c9a83346b221f04023572d4d", "patch": "@@ -18,7 +18,7 @@ use std::io;\n use transform::MirSource;\n use transform::type_check;\n use util::liveness::{self, LivenessMode, LivenessResult, LocalSet};\n-use borrow_check::FlowInProgress;\n+use borrow_check::FlowAtLocation;\n use dataflow::MaybeInitializedLvals;\n use dataflow::move_paths::MoveData;\n \n@@ -69,7 +69,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     universal_regions: UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n-    flow_inits: &mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) -> (\n     RegionInferenceContext<'tcx>,"}, {"sha": "90ebb45123ed8947d1bbf62d6c438ed9481cedf0", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=5a3f7cdcc7ff5074c9a83346b221f04023572d4d", "patch": "@@ -0,0 +1,186 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A nice wrapper to consume dataflow results at several CFG\n+//! locations.\n+\n+use rustc::mir::{BasicBlock, Location};\n+use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use dataflow::{BitDenotation, BlockSets, DataflowResults};\n+use dataflow::move_paths::{HasMoveData, MovePathIndex};\n+\n+/// A trait for \"cartesian products\" of multiple FlowAtLocation.\n+///\n+/// There's probably a way to auto-impl this, but I think\n+/// it is cleaner to have manual visitor impls.\n+pub trait FlowsAtLocation {\n+    // reset the state bitvector to represent the entry to block `bb`.\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock);\n+\n+    // build gen + kill sets for statement at `loc`.\n+    fn reconstruct_statement_effect(&mut self, loc: Location);\n+\n+    // build gen + kill sets for terminator for `loc`.\n+    fn reconstruct_terminator_effect(&mut self, loc: Location);\n+\n+    // apply current gen + kill sets to `flow_state`.\n+    //\n+    // (`bb` and `stmt_idx` parameters can be ignored if desired by\n+    // client. For the terminator, the `stmt_idx` will be the number\n+    // of statements in the block.)\n+    fn apply_local_effect(&mut self, loc: Location);\n+}\n+\n+/// Represents the state of dataflow at a particular\n+/// CFG location, both before and after it is\n+/// executed.\n+pub struct FlowAtLocation<BD>\n+where\n+    BD: BitDenotation,\n+{\n+    base_results: DataflowResults<BD>,\n+    curr_state: IdxSetBuf<BD::Idx>,\n+    stmt_gen: IdxSetBuf<BD::Idx>,\n+    stmt_kill: IdxSetBuf<BD::Idx>,\n+}\n+\n+impl<BD> FlowAtLocation<BD>\n+where\n+    BD: BitDenotation,\n+{\n+    pub fn each_state_bit<F>(&self, f: F)\n+    where\n+        F: FnMut(BD::Idx),\n+    {\n+        self.curr_state\n+            .each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    pub fn each_gen_bit<F>(&self, f: F)\n+    where\n+        F: FnMut(BD::Idx),\n+    {\n+        self.stmt_gen\n+            .each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    pub fn new(results: DataflowResults<BD>) -> Self {\n+        let bits_per_block = results.sets().bits_per_block();\n+        let curr_state = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_gen = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_kill = IdxSetBuf::new_empty(bits_per_block);\n+        FlowAtLocation {\n+            base_results: results,\n+            curr_state: curr_state,\n+            stmt_gen: stmt_gen,\n+            stmt_kill: stmt_kill,\n+        }\n+    }\n+\n+    pub fn operator(&self) -> &BD {\n+        self.base_results.operator()\n+    }\n+\n+    pub fn contains(&self, x: &BD::Idx) -> bool {\n+        self.curr_state.contains(x)\n+    }\n+\n+    pub fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n+        let univ = self.base_results.sets().bits_per_block();\n+        self.curr_state.elems(univ)\n+    }\n+\n+    pub fn with_elems_outgoing<F>(&self, f: F)\n+    where\n+        F: FnOnce(indexed_set::Elems<BD::Idx>),\n+    {\n+        let mut curr_state = self.curr_state.clone();\n+        curr_state.union(&self.stmt_gen);\n+        curr_state.subtract(&self.stmt_kill);\n+        let univ = self.base_results.sets().bits_per_block();\n+        f(curr_state.elems(univ));\n+    }\n+}\n+\n+impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n+    where BD: BitDenotation\n+{\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n+        (*self.curr_state).clone_from(self.base_results.sets().on_entry_set_for(bb.index()));\n+    }\n+\n+    fn reconstruct_statement_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored,\n+            gen_set: &mut self.stmt_gen,\n+            kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results\n+            .operator()\n+            .statement_effect(&mut sets, loc);\n+    }\n+\n+    fn reconstruct_terminator_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored,\n+            gen_set: &mut self.stmt_gen,\n+            kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results\n+            .operator()\n+            .terminator_effect(&mut sets, loc);\n+    }\n+\n+    fn apply_local_effect(&mut self, _loc: Location) {\n+        self.curr_state.union(&self.stmt_gen);\n+        self.curr_state.subtract(&self.stmt_kill);\n+    }\n+}\n+\n+\n+impl<'tcx, T> FlowAtLocation<T>\n+where\n+    T: HasMoveData<'tcx> + BitDenotation<Idx = MovePathIndex>,\n+{\n+    pub fn has_any_child_of(&self, mpi: T::Idx) -> Option<T::Idx> {\n+        let move_data = self.operator().move_data();\n+\n+        let mut todo = vec![mpi];\n+        let mut push_siblings = false; // don't look at siblings of original `mpi`.\n+        while let Some(mpi) = todo.pop() {\n+            if self.contains(&mpi) {\n+                return Some(mpi);\n+            }\n+            let move_path = &move_data.move_paths[mpi];\n+            if let Some(child) = move_path.first_child {\n+                todo.push(child);\n+            }\n+            if push_siblings {\n+                if let Some(sibling) = move_path.next_sibling {\n+                    todo.push(sibling);\n+                }\n+            } else {\n+                // after we've processed the original `mpi`, we should\n+                // always traverse the siblings of any of its\n+                // children.\n+                push_siblings = true;\n+            }\n+        }\n+        return None;\n+    }\n+}"}, {"sha": "c331380566b90e59f3e9fdd57c8b97429838fa77", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3f7cdcc7ff5074c9a83346b221f04023572d4d/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=5a3f7cdcc7ff5074c9a83346b221f04023572d4d", "patch": "@@ -30,10 +30,12 @@ pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n pub use self::impls::EverInitializedLvals;\n pub use self::impls::borrows::{Borrows, BorrowData, BorrowIndex};\n+pub use self::at_location::{FlowAtLocation, FlowsAtLocation};\n pub(crate) use self::drop_flag_effects::*;\n \n use self::move_paths::MoveData;\n \n+mod at_location;\n mod drop_flag_effects;\n mod graphviz;\n mod impls;\n@@ -275,7 +277,7 @@ impl<E:Idx> Bits<E> {\n /// where we are combining the results of *multiple* flow analyses\n /// (e.g. borrows + inits + uninits).\n pub trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n-    type FlowState;\n+    type FlowState: FlowsAtLocation;\n \n     // Observation Hooks: override (at least one of) these to get analysis feedback.\n     fn visit_block_entry(&mut self,\n@@ -297,7 +299,7 @@ pub trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n     fn analyze_results(&mut self, flow_uninit: &mut Self::FlowState) {\n         let flow = flow_uninit;\n         for bb in self.mir().basic_blocks().indices() {\n-            self.reset_to_entry_of(bb, flow);\n+            flow.reset_to_entry_of(bb);\n             self.process_basic_block(bb, flow);\n         }\n     }\n@@ -307,14 +309,14 @@ pub trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n             self.mir()[bb];\n         let mut location = Location { block: bb, statement_index: 0 };\n         for stmt in statements.iter() {\n-            self.reconstruct_statement_effect(location, flow_state);\n+            flow_state.reconstruct_statement_effect(location);\n             self.visit_statement_entry(location, stmt, flow_state);\n-            self.apply_local_effect(location, flow_state);\n+            flow_state.apply_local_effect(location);\n             location.statement_index += 1;\n         }\n \n         if let Some(ref term) = *terminator {\n-            self.reconstruct_terminator_effect(location, flow_state);\n+            flow_state.reconstruct_terminator_effect(location);\n             self.visit_terminator_entry(location, term, flow_state);\n \n             // We don't need to apply the effect of the terminator,\n@@ -328,30 +330,6 @@ pub trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n     // Delegated Hooks: Provide access to the MIR and process the flow state.\n \n     fn mir(&self) -> &'a Mir<'tcx>;\n-\n-    // reset the state bitvector to represent the entry to block `bb`.\n-    fn reset_to_entry_of(&mut self,\n-                         bb: BasicBlock,\n-                         flow_state: &mut Self::FlowState);\n-\n-    // build gen + kill sets for statement at `loc`.\n-    fn reconstruct_statement_effect(&mut self,\n-                                    loc: Location,\n-                                    flow_state: &mut Self::FlowState);\n-\n-    // build gen + kill sets for terminator for `loc`.\n-    fn reconstruct_terminator_effect(&mut self,\n-                                     loc: Location,\n-                                     flow_state: &mut Self::FlowState);\n-\n-    // apply current gen + kill sets to `flow_state`.\n-    //\n-    // (`bb` and `stmt_idx` parameters can be ignored if desired by\n-    // client. For the terminator, the `stmt_idx` will be the number\n-    // of statements in the block.)\n-    fn apply_local_effect(&mut self,\n-                          loc: Location,\n-                          flow_state: &mut Self::FlowState);\n }\n \n pub fn state_for_location<T: BitDenotation>(loc: Location,"}]}